// Generated by jextract

package com.github.teruteru128.bcrypt;

import java.lang.invoke.*;
import java.lang.foreign.*;
import java.nio.charset.StandardCharsets;
import java.util.*;
import java.util.stream.*;

import static java.lang.foreign.ValueLayout.*;

public class bcrypt_h {

    bcrypt_h() {
        // Should not be called directly
    }

    static final Arena LIBRARY_ARENA = Arena.ofAuto();
    static final boolean TRACE_DOWNCALLS = Boolean.getBoolean("jextract.trace.downcalls");

    static void traceDowncall(String name, Object... args) {
         String traceArgs = Arrays.stream(args)
                       .map(Object::toString)
                       .collect(Collectors.joining(", "));
         System.out.printf("%s(%s)\n", name, traceArgs);
    }

    static MemorySegment findOrThrow(String symbol) {
        return SYMBOL_LOOKUP.find(symbol)
            .orElseThrow(() -> new UnsatisfiedLinkError("unresolved symbol: " + symbol));
    }

    static MethodHandle upcallHandle(Class<?> fi, String name, FunctionDescriptor fdesc) {
        try {
            return MethodHandles.lookup().findVirtual(fi, name, fdesc.toMethodType());
        } catch (ReflectiveOperationException ex) {
            throw new AssertionError(ex);
        }
    }

    static MemoryLayout align(MemoryLayout layout, long align) {
        return switch (layout) {
            case PaddingLayout p -> p;
            case ValueLayout v -> v.withByteAlignment(align);
            case GroupLayout g -> {
                MemoryLayout[] alignedMembers = g.memberLayouts().stream()
                        .map(m -> align(m, align)).toArray(MemoryLayout[]::new);
                yield g instanceof StructLayout ?
                        MemoryLayout.structLayout(alignedMembers) : MemoryLayout.unionLayout(alignedMembers);
            }
            case SequenceLayout s -> MemoryLayout.sequenceLayout(s.elementCount(), align(s.elementLayout(), align));
        };
    }

    static final SymbolLookup SYMBOL_LOOKUP = SymbolLookup.libraryLookup("Bcrypt", LIBRARY_ARENA)
            .or(SymbolLookup.loaderLookup())
            .or(Linker.nativeLinker().defaultLookup());

    public static final ValueLayout.OfBoolean C_BOOL = ValueLayout.JAVA_BOOLEAN;
    public static final ValueLayout.OfByte C_CHAR = ValueLayout.JAVA_BYTE;
    public static final ValueLayout.OfShort C_SHORT = ValueLayout.JAVA_SHORT;
    public static final ValueLayout.OfInt C_INT = ValueLayout.JAVA_INT;
    public static final ValueLayout.OfLong C_LONG_LONG = ValueLayout.JAVA_LONG;
    public static final ValueLayout.OfFloat C_FLOAT = ValueLayout.JAVA_FLOAT;
    public static final ValueLayout.OfDouble C_DOUBLE = ValueLayout.JAVA_DOUBLE;
    public static final AddressLayout C_POINTER = ValueLayout.ADDRESS
            .withTargetLayout(MemoryLayout.sequenceLayout(java.lang.Long.MAX_VALUE, JAVA_BYTE));
    public static final ValueLayout.OfInt C_LONG = ValueLayout.JAVA_INT;
    public static final ValueLayout.OfDouble C_LONG_DOUBLE = ValueLayout.JAVA_DOUBLE;
    private static final int BCRYPT_HASH_REUSABLE_FLAG = (int)32L;
    /**
     * {@snippet lang=c :
     * #define BCRYPT_HASH_REUSABLE_FLAG 32
     * }
     */
    public static int BCRYPT_HASH_REUSABLE_FLAG() {
        return BCRYPT_HASH_REUSABLE_FLAG;
    }
    /**
     * {@snippet lang=c :
     * typedef unsigned long DWORD
     * }
     */
    public static final OfInt DWORD = bcrypt_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef BYTE *PBYTE
     * }
     */
    public static final AddressLayout PBYTE = bcrypt_h.C_POINTER;

    /**
     * {@snippet lang=c :
     * typedef LONG NTSTATUS
     * }
     */
    public static final OfInt NTSTATUS = bcrypt_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef PVOID BCRYPT_ALG_HANDLE
     * }
     */
    public static final AddressLayout BCRYPT_ALG_HANDLE = bcrypt_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef PVOID BCRYPT_HASH_HANDLE
     * }
     */
    public static final AddressLayout BCRYPT_HASH_HANDLE = bcrypt_h.C_POINTER;

    private static class BCryptOpenAlgorithmProvider {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            bcrypt_h.C_LONG,
            bcrypt_h.C_POINTER,
            bcrypt_h.C_POINTER,
            bcrypt_h.C_POINTER,
            bcrypt_h.C_LONG
        );

        public static final MemorySegment ADDR = bcrypt_h.findOrThrow("BCryptOpenAlgorithmProvider");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * NTSTATUS BCryptOpenAlgorithmProvider(BCRYPT_ALG_HANDLE *phAlgorithm, LPCWSTR pszAlgId, LPCWSTR pszImplementation, ULONG dwFlags)
     * }
     */
    public static FunctionDescriptor BCryptOpenAlgorithmProvider$descriptor() {
        return BCryptOpenAlgorithmProvider.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * NTSTATUS BCryptOpenAlgorithmProvider(BCRYPT_ALG_HANDLE *phAlgorithm, LPCWSTR pszAlgId, LPCWSTR pszImplementation, ULONG dwFlags)
     * }
     */
    public static MethodHandle BCryptOpenAlgorithmProvider$handle() {
        return BCryptOpenAlgorithmProvider.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * NTSTATUS BCryptOpenAlgorithmProvider(BCRYPT_ALG_HANDLE *phAlgorithm, LPCWSTR pszAlgId, LPCWSTR pszImplementation, ULONG dwFlags)
     * }
     */
    public static MemorySegment BCryptOpenAlgorithmProvider$address() {
        return BCryptOpenAlgorithmProvider.ADDR;
    }

    /**
     * {@snippet lang=c :
     * NTSTATUS BCryptOpenAlgorithmProvider(BCRYPT_ALG_HANDLE *phAlgorithm, LPCWSTR pszAlgId, LPCWSTR pszImplementation, ULONG dwFlags)
     * }
     */
    public static int BCryptOpenAlgorithmProvider(MemorySegment phAlgorithm, MemorySegment pszAlgId, MemorySegment pszImplementation, int dwFlags) {
        var mh$ = BCryptOpenAlgorithmProvider.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("BCryptOpenAlgorithmProvider", phAlgorithm, pszAlgId, pszImplementation, dwFlags);
            }
            return (int)mh$.invokeExact(phAlgorithm, pszAlgId, pszImplementation, dwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class BCryptGetProperty {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            bcrypt_h.C_LONG,
            bcrypt_h.C_POINTER,
            bcrypt_h.C_POINTER,
            bcrypt_h.C_POINTER,
            bcrypt_h.C_LONG,
            bcrypt_h.C_POINTER,
            bcrypt_h.C_LONG
        );

        public static final MemorySegment ADDR = bcrypt_h.findOrThrow("BCryptGetProperty");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * NTSTATUS BCryptGetProperty(BCRYPT_HANDLE hObject, LPCWSTR pszProperty, PUCHAR pbOutput, ULONG cbOutput, ULONG *pcbResult, ULONG dwFlags)
     * }
     */
    public static FunctionDescriptor BCryptGetProperty$descriptor() {
        return BCryptGetProperty.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * NTSTATUS BCryptGetProperty(BCRYPT_HANDLE hObject, LPCWSTR pszProperty, PUCHAR pbOutput, ULONG cbOutput, ULONG *pcbResult, ULONG dwFlags)
     * }
     */
    public static MethodHandle BCryptGetProperty$handle() {
        return BCryptGetProperty.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * NTSTATUS BCryptGetProperty(BCRYPT_HANDLE hObject, LPCWSTR pszProperty, PUCHAR pbOutput, ULONG cbOutput, ULONG *pcbResult, ULONG dwFlags)
     * }
     */
    public static MemorySegment BCryptGetProperty$address() {
        return BCryptGetProperty.ADDR;
    }

    /**
     * {@snippet lang=c :
     * NTSTATUS BCryptGetProperty(BCRYPT_HANDLE hObject, LPCWSTR pszProperty, PUCHAR pbOutput, ULONG cbOutput, ULONG *pcbResult, ULONG dwFlags)
     * }
     */
    public static int BCryptGetProperty(MemorySegment hObject, MemorySegment pszProperty, MemorySegment pbOutput, int cbOutput, MemorySegment pcbResult, int dwFlags) {
        var mh$ = BCryptGetProperty.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("BCryptGetProperty", hObject, pszProperty, pbOutput, cbOutput, pcbResult, dwFlags);
            }
            return (int)mh$.invokeExact(hObject, pszProperty, pbOutput, cbOutput, pcbResult, dwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class BCryptCloseAlgorithmProvider {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            bcrypt_h.C_LONG,
            bcrypt_h.C_POINTER,
            bcrypt_h.C_LONG
        );

        public static final MemorySegment ADDR = bcrypt_h.findOrThrow("BCryptCloseAlgorithmProvider");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * NTSTATUS BCryptCloseAlgorithmProvider(BCRYPT_ALG_HANDLE hAlgorithm, ULONG dwFlags)
     * }
     */
    public static FunctionDescriptor BCryptCloseAlgorithmProvider$descriptor() {
        return BCryptCloseAlgorithmProvider.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * NTSTATUS BCryptCloseAlgorithmProvider(BCRYPT_ALG_HANDLE hAlgorithm, ULONG dwFlags)
     * }
     */
    public static MethodHandle BCryptCloseAlgorithmProvider$handle() {
        return BCryptCloseAlgorithmProvider.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * NTSTATUS BCryptCloseAlgorithmProvider(BCRYPT_ALG_HANDLE hAlgorithm, ULONG dwFlags)
     * }
     */
    public static MemorySegment BCryptCloseAlgorithmProvider$address() {
        return BCryptCloseAlgorithmProvider.ADDR;
    }

    /**
     * {@snippet lang=c :
     * NTSTATUS BCryptCloseAlgorithmProvider(BCRYPT_ALG_HANDLE hAlgorithm, ULONG dwFlags)
     * }
     */
    public static int BCryptCloseAlgorithmProvider(MemorySegment hAlgorithm, int dwFlags) {
        var mh$ = BCryptCloseAlgorithmProvider.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("BCryptCloseAlgorithmProvider", hAlgorithm, dwFlags);
            }
            return (int)mh$.invokeExact(hAlgorithm, dwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class BCryptCreateHash {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            bcrypt_h.C_LONG,
            bcrypt_h.C_POINTER,
            bcrypt_h.C_POINTER,
            bcrypt_h.C_POINTER,
            bcrypt_h.C_LONG,
            bcrypt_h.C_POINTER,
            bcrypt_h.C_LONG,
            bcrypt_h.C_LONG
        );

        public static final MemorySegment ADDR = bcrypt_h.findOrThrow("BCryptCreateHash");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * NTSTATUS BCryptCreateHash(BCRYPT_ALG_HANDLE hAlgorithm, BCRYPT_HASH_HANDLE *phHash, PUCHAR pbHashObject, ULONG cbHashObject, PUCHAR pbSecret, ULONG cbSecret, ULONG dwFlags)
     * }
     */
    public static FunctionDescriptor BCryptCreateHash$descriptor() {
        return BCryptCreateHash.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * NTSTATUS BCryptCreateHash(BCRYPT_ALG_HANDLE hAlgorithm, BCRYPT_HASH_HANDLE *phHash, PUCHAR pbHashObject, ULONG cbHashObject, PUCHAR pbSecret, ULONG cbSecret, ULONG dwFlags)
     * }
     */
    public static MethodHandle BCryptCreateHash$handle() {
        return BCryptCreateHash.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * NTSTATUS BCryptCreateHash(BCRYPT_ALG_HANDLE hAlgorithm, BCRYPT_HASH_HANDLE *phHash, PUCHAR pbHashObject, ULONG cbHashObject, PUCHAR pbSecret, ULONG cbSecret, ULONG dwFlags)
     * }
     */
    public static MemorySegment BCryptCreateHash$address() {
        return BCryptCreateHash.ADDR;
    }

    /**
     * {@snippet lang=c :
     * NTSTATUS BCryptCreateHash(BCRYPT_ALG_HANDLE hAlgorithm, BCRYPT_HASH_HANDLE *phHash, PUCHAR pbHashObject, ULONG cbHashObject, PUCHAR pbSecret, ULONG cbSecret, ULONG dwFlags)
     * }
     */
    public static int BCryptCreateHash(MemorySegment hAlgorithm, MemorySegment phHash, MemorySegment pbHashObject, int cbHashObject, MemorySegment pbSecret, int cbSecret, int dwFlags) {
        var mh$ = BCryptCreateHash.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("BCryptCreateHash", hAlgorithm, phHash, pbHashObject, cbHashObject, pbSecret, cbSecret, dwFlags);
            }
            return (int)mh$.invokeExact(hAlgorithm, phHash, pbHashObject, cbHashObject, pbSecret, cbSecret, dwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class BCryptHashData {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            bcrypt_h.C_LONG,
            bcrypt_h.C_POINTER,
            bcrypt_h.C_POINTER,
            bcrypt_h.C_LONG,
            bcrypt_h.C_LONG
        );

        public static final MemorySegment ADDR = bcrypt_h.findOrThrow("BCryptHashData");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * NTSTATUS BCryptHashData(BCRYPT_HASH_HANDLE hHash, PUCHAR pbInput, ULONG cbInput, ULONG dwFlags)
     * }
     */
    public static FunctionDescriptor BCryptHashData$descriptor() {
        return BCryptHashData.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * NTSTATUS BCryptHashData(BCRYPT_HASH_HANDLE hHash, PUCHAR pbInput, ULONG cbInput, ULONG dwFlags)
     * }
     */
    public static MethodHandle BCryptHashData$handle() {
        return BCryptHashData.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * NTSTATUS BCryptHashData(BCRYPT_HASH_HANDLE hHash, PUCHAR pbInput, ULONG cbInput, ULONG dwFlags)
     * }
     */
    public static MemorySegment BCryptHashData$address() {
        return BCryptHashData.ADDR;
    }

    /**
     * {@snippet lang=c :
     * NTSTATUS BCryptHashData(BCRYPT_HASH_HANDLE hHash, PUCHAR pbInput, ULONG cbInput, ULONG dwFlags)
     * }
     */
    public static int BCryptHashData(MemorySegment hHash, MemorySegment pbInput, int cbInput, int dwFlags) {
        var mh$ = BCryptHashData.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("BCryptHashData", hHash, pbInput, cbInput, dwFlags);
            }
            return (int)mh$.invokeExact(hHash, pbInput, cbInput, dwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class BCryptFinishHash {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            bcrypt_h.C_LONG,
            bcrypt_h.C_POINTER,
            bcrypt_h.C_POINTER,
            bcrypt_h.C_LONG,
            bcrypt_h.C_LONG
        );

        public static final MemorySegment ADDR = bcrypt_h.findOrThrow("BCryptFinishHash");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * NTSTATUS BCryptFinishHash(BCRYPT_HASH_HANDLE hHash, PUCHAR pbOutput, ULONG cbOutput, ULONG dwFlags)
     * }
     */
    public static FunctionDescriptor BCryptFinishHash$descriptor() {
        return BCryptFinishHash.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * NTSTATUS BCryptFinishHash(BCRYPT_HASH_HANDLE hHash, PUCHAR pbOutput, ULONG cbOutput, ULONG dwFlags)
     * }
     */
    public static MethodHandle BCryptFinishHash$handle() {
        return BCryptFinishHash.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * NTSTATUS BCryptFinishHash(BCRYPT_HASH_HANDLE hHash, PUCHAR pbOutput, ULONG cbOutput, ULONG dwFlags)
     * }
     */
    public static MemorySegment BCryptFinishHash$address() {
        return BCryptFinishHash.ADDR;
    }

    /**
     * {@snippet lang=c :
     * NTSTATUS BCryptFinishHash(BCRYPT_HASH_HANDLE hHash, PUCHAR pbOutput, ULONG cbOutput, ULONG dwFlags)
     * }
     */
    public static int BCryptFinishHash(MemorySegment hHash, MemorySegment pbOutput, int cbOutput, int dwFlags) {
        var mh$ = BCryptFinishHash.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("BCryptFinishHash", hHash, pbOutput, cbOutput, dwFlags);
            }
            return (int)mh$.invokeExact(hHash, pbOutput, cbOutput, dwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class BCryptDestroyHash {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            bcrypt_h.C_LONG,
            bcrypt_h.C_POINTER
        );

        public static final MemorySegment ADDR = bcrypt_h.findOrThrow("BCryptDestroyHash");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * NTSTATUS BCryptDestroyHash(BCRYPT_HASH_HANDLE hHash)
     * }
     */
    public static FunctionDescriptor BCryptDestroyHash$descriptor() {
        return BCryptDestroyHash.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * NTSTATUS BCryptDestroyHash(BCRYPT_HASH_HANDLE hHash)
     * }
     */
    public static MethodHandle BCryptDestroyHash$handle() {
        return BCryptDestroyHash.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * NTSTATUS BCryptDestroyHash(BCRYPT_HASH_HANDLE hHash)
     * }
     */
    public static MemorySegment BCryptDestroyHash$address() {
        return BCryptDestroyHash.ADDR;
    }

    /**
     * {@snippet lang=c :
     * NTSTATUS BCryptDestroyHash(BCRYPT_HASH_HANDLE hHash)
     * }
     */
    public static int BCryptDestroyHash(MemorySegment hHash) {
        var mh$ = BCryptDestroyHash.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("BCryptDestroyHash", hHash);
            }
            return (int)mh$.invokeExact(hHash);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * #define BCRYPT_OBJECT_LENGTH L"ObjectLength"
     * }
     */
    public static MemorySegment BCRYPT_OBJECT_LENGTH() {
        class Holder {
            static final MemorySegment BCRYPT_OBJECT_LENGTH
                = bcrypt_h.LIBRARY_ARENA.allocateFrom("ObjectLength", StandardCharsets.UTF_16LE);
        }
        return Holder.BCRYPT_OBJECT_LENGTH;
    }
    /**
     * {@snippet lang=c :
     * #define BCRYPT_HASH_LENGTH L"HashDigestLength"
     * }
     */
    public static MemorySegment BCRYPT_HASH_LENGTH() {
        class Holder {
            static final MemorySegment BCRYPT_HASH_LENGTH
                = bcrypt_h.LIBRARY_ARENA.allocateFrom("HashDigestLength", StandardCharsets.UTF_16LE);
        }
        return Holder.BCRYPT_HASH_LENGTH;
    }
    /**
     * {@snippet lang=c :
     * #define BCRYPT_SHA1_ALGORITHM L"SHA1"
     * }
     */
    public static MemorySegment BCRYPT_SHA1_ALGORITHM() {
        class Holder {
            static final MemorySegment BCRYPT_SHA1_ALGORITHM
                = bcrypt_h.LIBRARY_ARENA.allocateFrom("SHA1", StandardCharsets.UTF_16);
        }
        return Holder.BCRYPT_SHA1_ALGORITHM;
    }
    /**
     * {@snippet lang=c :
     * #define BCRYPT_SHA256_ALGORITHM L"SHA256"
     * }
     */
    public static MemorySegment BCRYPT_SHA256_ALGORITHM() {
        class Holder {
            static final MemorySegment BCRYPT_SHA256_ALGORITHM
                = bcrypt_h.LIBRARY_ARENA.allocateFrom("SHA256", StandardCharsets.UTF_16LE);
        }
        return Holder.BCRYPT_SHA256_ALGORITHM;
    }
    /**
     * {@snippet lang=c :
     * #define BCRYPT_SHA384_ALGORITHM L"SHA384"
     * }
     */
    public static MemorySegment BCRYPT_SHA384_ALGORITHM() {
        class Holder {
            static final MemorySegment BCRYPT_SHA384_ALGORITHM
                = bcrypt_h.LIBRARY_ARENA.allocateFrom("SHA384", StandardCharsets.UTF_16);
        }
        return Holder.BCRYPT_SHA384_ALGORITHM;
    }
    /**
     * {@snippet lang=c :
     * #define BCRYPT_SHA512_ALGORITHM L"SHA512"
     * }
     */
    public static MemorySegment BCRYPT_SHA512_ALGORITHM() {
        class Holder {
            static final MemorySegment BCRYPT_SHA512_ALGORITHM
                = bcrypt_h.LIBRARY_ARENA.allocateFrom("SHA512", StandardCharsets.UTF_16);
        }
        return Holder.BCRYPT_SHA512_ALGORITHM;
    }
    /**
     * {@snippet lang=c :
     * #define BCRYPT_RIPEMD160_ALGORITHM L"RIPEMD160"
     * }
     */
    public static MemorySegment BCRYPT_RIPEMD160_ALGORITHM() {
        class Holder {
            static final MemorySegment BCRYPT_RIPEMD160_ALGORITHM
                = bcrypt_h.LIBRARY_ARENA.allocateFrom("RIPEMD160", StandardCharsets.UTF_16);
        }
        return Holder.BCRYPT_RIPEMD160_ALGORITHM;
    }
}

