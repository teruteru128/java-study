// Generated by jextract

package com.github.teruteru128.foreign.opencl;

import java.lang.invoke.*;
import java.lang.foreign.*;

import static java.lang.foreign.ValueLayout.*;

public class opencl_h_1 extends opencl_h_2 {

    opencl_h_1() {
        // Should not be called directly
    }
    /**
     * {@snippet lang=c :
     * typedef long long int_least64_t
     * }
     */
    public static final OfLong int_least64_t = C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned char uint_least8_t
     * }
     */
    public static final OfByte uint_least8_t = C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef unsigned short uint_least16_t
     * }
     */
    public static final OfShort uint_least16_t = C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef unsigned int uint_least32_t
     * }
     */
    public static final OfInt uint_least32_t = C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned long long uint_least64_t
     * }
     */
    public static final OfLong uint_least64_t = C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef signed char int_fast8_t
     * }
     */
    public static final OfByte int_fast8_t = C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef int int_fast16_t
     * }
     */
    public static final OfInt int_fast16_t = C_INT;
    /**
     * {@snippet lang=c :
     * typedef int int_fast32_t
     * }
     */
    public static final OfInt int_fast32_t = C_INT;
    /**
     * {@snippet lang=c :
     * typedef long long int_fast64_t
     * }
     */
    public static final OfLong int_fast64_t = C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned char uint_fast8_t
     * }
     */
    public static final OfByte uint_fast8_t = C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef unsigned int uint_fast16_t
     * }
     */
    public static final OfInt uint_fast16_t = C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned int uint_fast32_t
     * }
     */
    public static final OfInt uint_fast32_t = C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned long long uint_fast64_t
     * }
     */
    public static final OfLong uint_fast64_t = C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef long long intmax_t
     * }
     */
    public static final OfLong intmax_t = C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long long uintmax_t
     * }
     */
    public static final OfLong uintmax_t = C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef signed char cl_char
     * }
     */
    public static final OfByte cl_char = C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef unsigned char cl_uchar
     * }
     */
    public static final OfByte cl_uchar = C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef short cl_short
     * }
     */
    public static final OfShort cl_short = C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef unsigned short cl_ushort
     * }
     */
    public static final OfShort cl_ushort = C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef int cl_int
     * }
     */
    public static final OfInt cl_int = C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned int cl_uint
     * }
     */
    public static final OfInt cl_uint = C_INT;
    /**
     * {@snippet lang=c :
     * typedef long long cl_long
     * }
     */
    public static final OfLong cl_long = C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long long cl_ulong
     * }
     */
    public static final OfLong cl_ulong = C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned short cl_half
     * }
     */
    public static final OfShort cl_half = C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef float cl_float
     * }
     */
    public static final OfFloat cl_float = C_FLOAT;
    /**
     * {@snippet lang=c :
     * typedef double cl_double
     * }
     */
    public static final OfDouble cl_double = C_DOUBLE;
    /**
     * {@snippet lang=c :
     * typedef double max_align_t
     * }
     */
    public static final OfDouble max_align_t = C_DOUBLE;
    /**
     * {@snippet lang=c :
     * typedef unsigned int cl_GLuint
     * }
     */
    public static final OfInt cl_GLuint = C_INT;
    /**
     * {@snippet lang=c :
     * typedef int cl_GLint
     * }
     */
    public static final OfInt cl_GLint = C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned int cl_GLenum
     * }
     */
    public static final OfInt cl_GLenum = C_INT;
    /**
     * {@snippet lang=c :
     * typedef _Bool __crt_bool
     * }
     */
    public static final OfBoolean __crt_bool = C_BOOL;

    private static class _invalid_parameter_noinfo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("_invalid_parameter_noinfo"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void _invalid_parameter_noinfo()
     * }
     */
    public static FunctionDescriptor _invalid_parameter_noinfo$descriptor() {
        return _invalid_parameter_noinfo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void _invalid_parameter_noinfo()
     * }
     */
    public static MethodHandle _invalid_parameter_noinfo$handle() {
        return _invalid_parameter_noinfo.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * void _invalid_parameter_noinfo()
     * }
     */
    public static void _invalid_parameter_noinfo() {
        var mh$ = _invalid_parameter_noinfo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_invalid_parameter_noinfo");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _invalid_parameter_noinfo_noreturn {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("_invalid_parameter_noinfo_noreturn"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void _invalid_parameter_noinfo_noreturn()
     * }
     */
    public static FunctionDescriptor _invalid_parameter_noinfo_noreturn$descriptor() {
        return _invalid_parameter_noinfo_noreturn.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void _invalid_parameter_noinfo_noreturn()
     * }
     */
    public static MethodHandle _invalid_parameter_noinfo_noreturn$handle() {
        return _invalid_parameter_noinfo_noreturn.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * void _invalid_parameter_noinfo_noreturn()
     * }
     */
    public static void _invalid_parameter_noinfo_noreturn() {
        var mh$ = _invalid_parameter_noinfo_noreturn.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_invalid_parameter_noinfo_noreturn");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _invoke_watson {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_INT,
            C_LONG_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("_invoke_watson"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void _invoke_watson(const wchar_t *_Expression, const wchar_t *_FunctionName, const wchar_t *_FileName, unsigned int _LineNo, uintptr_t _Reserved)
     * }
     */
    public static FunctionDescriptor _invoke_watson$descriptor() {
        return _invoke_watson.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void _invoke_watson(const wchar_t *_Expression, const wchar_t *_FunctionName, const wchar_t *_FileName, unsigned int _LineNo, uintptr_t _Reserved)
     * }
     */
    public static MethodHandle _invoke_watson$handle() {
        return _invoke_watson.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * void _invoke_watson(const wchar_t *_Expression, const wchar_t *_FunctionName, const wchar_t *_FileName, unsigned int _LineNo, uintptr_t _Reserved)
     * }
     */
    public static void _invoke_watson(MemorySegment _Expression, MemorySegment _FunctionName, MemorySegment _FileName, int _LineNo, long _Reserved) {
        var mh$ = _invoke_watson.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_invoke_watson", _Expression, _FunctionName, _FileName, _LineNo, _Reserved);
            }
            mh$.invokeExact(_Expression, _FunctionName, _FileName, _LineNo, _Reserved);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef int errno_t
     * }
     */
    public static final OfInt errno_t = C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned short wint_t
     * }
     */
    public static final OfShort wint_t = C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef unsigned short wctype_t
     * }
     */
    public static final OfShort wctype_t = C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef long __time32_t
     * }
     */
    public static final OfInt __time32_t = C_LONG;
    /**
     * {@snippet lang=c :
     * typedef long long __time64_t
     * }
     */
    public static final OfLong __time64_t = C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef __crt_locale_pointers *_locale_t
     * }
     */
    public static final AddressLayout _locale_t = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef __time64_t time_t
     * }
     */
    public static final OfLong time_t = C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef size_t rsize_t
     * }
     */
    public static final OfLong rsize_t = C_LONG_LONG;

    private static class _calloc_base {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_LONG_LONG,
            C_LONG_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("_calloc_base"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *_calloc_base(size_t _Count, size_t _Size)
     * }
     */
    public static FunctionDescriptor _calloc_base$descriptor() {
        return _calloc_base.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *_calloc_base(size_t _Count, size_t _Size)
     * }
     */
    public static MethodHandle _calloc_base$handle() {
        return _calloc_base.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * void *_calloc_base(size_t _Count, size_t _Size)
     * }
     */
    public static MemorySegment _calloc_base(long _Count, long _Size) {
        var mh$ = _calloc_base.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_calloc_base", _Count, _Size);
            }
            return (MemorySegment)mh$.invokeExact(_Count, _Size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class calloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_LONG_LONG,
            C_LONG_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("calloc"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *calloc(size_t _Count, size_t _Size)
     * }
     */
    public static FunctionDescriptor calloc$descriptor() {
        return calloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *calloc(size_t _Count, size_t _Size)
     * }
     */
    public static MethodHandle calloc$handle() {
        return calloc.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * void *calloc(size_t _Count, size_t _Size)
     * }
     */
    public static MemorySegment calloc(long _Count, long _Size) {
        var mh$ = calloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("calloc", _Count, _Size);
            }
            return (MemorySegment)mh$.invokeExact(_Count, _Size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _callnewh {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_LONG_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("_callnewh"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _callnewh(size_t _Size)
     * }
     */
    public static FunctionDescriptor _callnewh$descriptor() {
        return _callnewh.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _callnewh(size_t _Size)
     * }
     */
    public static MethodHandle _callnewh$handle() {
        return _callnewh.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int _callnewh(size_t _Size)
     * }
     */
    public static int _callnewh(long _Size) {
        var mh$ = _callnewh.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_callnewh", _Size);
            }
            return (int)mh$.invokeExact(_Size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _expand {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER,
            C_LONG_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("_expand"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *_expand(void *_Block, size_t _Size)
     * }
     */
    public static FunctionDescriptor _expand$descriptor() {
        return _expand.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *_expand(void *_Block, size_t _Size)
     * }
     */
    public static MethodHandle _expand$handle() {
        return _expand.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * void *_expand(void *_Block, size_t _Size)
     * }
     */
    public static MemorySegment _expand(MemorySegment _Block, long _Size) {
        var mh$ = _expand.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_expand", _Block, _Size);
            }
            return (MemorySegment)mh$.invokeExact(_Block, _Size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _free_base {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("_free_base"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void _free_base(void *_Block)
     * }
     */
    public static FunctionDescriptor _free_base$descriptor() {
        return _free_base.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void _free_base(void *_Block)
     * }
     */
    public static MethodHandle _free_base$handle() {
        return _free_base.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * void _free_base(void *_Block)
     * }
     */
    public static void _free_base(MemorySegment _Block) {
        var mh$ = _free_base.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_free_base", _Block);
            }
            mh$.invokeExact(_Block);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("free"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void free(void *_Block)
     * }
     */
    public static FunctionDescriptor free$descriptor() {
        return free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void free(void *_Block)
     * }
     */
    public static MethodHandle free$handle() {
        return free.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * void free(void *_Block)
     * }
     */
    public static void free(MemorySegment _Block) {
        var mh$ = free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("free", _Block);
            }
            mh$.invokeExact(_Block);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _malloc_base {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_LONG_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("_malloc_base"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *_malloc_base(size_t _Size)
     * }
     */
    public static FunctionDescriptor _malloc_base$descriptor() {
        return _malloc_base.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *_malloc_base(size_t _Size)
     * }
     */
    public static MethodHandle _malloc_base$handle() {
        return _malloc_base.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * void *_malloc_base(size_t _Size)
     * }
     */
    public static MemorySegment _malloc_base(long _Size) {
        var mh$ = _malloc_base.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_malloc_base", _Size);
            }
            return (MemorySegment)mh$.invokeExact(_Size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class malloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_LONG_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("malloc"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *malloc(size_t _Size)
     * }
     */
    public static FunctionDescriptor malloc$descriptor() {
        return malloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *malloc(size_t _Size)
     * }
     */
    public static MethodHandle malloc$handle() {
        return malloc.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * void *malloc(size_t _Size)
     * }
     */
    public static MemorySegment malloc(long _Size) {
        var mh$ = malloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("malloc", _Size);
            }
            return (MemorySegment)mh$.invokeExact(_Size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _msize_base {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG_LONG,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("_msize_base"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * size_t _msize_base(void *_Block)
     * }
     */
    public static FunctionDescriptor _msize_base$descriptor() {
        return _msize_base.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * size_t _msize_base(void *_Block)
     * }
     */
    public static MethodHandle _msize_base$handle() {
        return _msize_base.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * size_t _msize_base(void *_Block)
     * }
     */
    public static long _msize_base(MemorySegment _Block) {
        var mh$ = _msize_base.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_msize_base", _Block);
            }
            return (long)mh$.invokeExact(_Block);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _msize {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG_LONG,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("_msize"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * size_t _msize(void *_Block)
     * }
     */
    public static FunctionDescriptor _msize$descriptor() {
        return _msize.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * size_t _msize(void *_Block)
     * }
     */
    public static MethodHandle _msize$handle() {
        return _msize.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * size_t _msize(void *_Block)
     * }
     */
    public static long _msize(MemorySegment _Block) {
        var mh$ = _msize.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_msize", _Block);
            }
            return (long)mh$.invokeExact(_Block);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _realloc_base {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER,
            C_LONG_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("_realloc_base"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *_realloc_base(void *_Block, size_t _Size)
     * }
     */
    public static FunctionDescriptor _realloc_base$descriptor() {
        return _realloc_base.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *_realloc_base(void *_Block, size_t _Size)
     * }
     */
    public static MethodHandle _realloc_base$handle() {
        return _realloc_base.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * void *_realloc_base(void *_Block, size_t _Size)
     * }
     */
    public static MemorySegment _realloc_base(MemorySegment _Block, long _Size) {
        var mh$ = _realloc_base.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_realloc_base", _Block, _Size);
            }
            return (MemorySegment)mh$.invokeExact(_Block, _Size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class realloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER,
            C_LONG_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("realloc"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *realloc(void *_Block, size_t _Size)
     * }
     */
    public static FunctionDescriptor realloc$descriptor() {
        return realloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *realloc(void *_Block, size_t _Size)
     * }
     */
    public static MethodHandle realloc$handle() {
        return realloc.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * void *realloc(void *_Block, size_t _Size)
     * }
     */
    public static MemorySegment realloc(MemorySegment _Block, long _Size) {
        var mh$ = realloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("realloc", _Block, _Size);
            }
            return (MemorySegment)mh$.invokeExact(_Block, _Size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _recalloc_base {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER,
            C_LONG_LONG,
            C_LONG_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("_recalloc_base"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *_recalloc_base(void *_Block, size_t _Count, size_t _Size)
     * }
     */
    public static FunctionDescriptor _recalloc_base$descriptor() {
        return _recalloc_base.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *_recalloc_base(void *_Block, size_t _Count, size_t _Size)
     * }
     */
    public static MethodHandle _recalloc_base$handle() {
        return _recalloc_base.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * void *_recalloc_base(void *_Block, size_t _Count, size_t _Size)
     * }
     */
    public static MemorySegment _recalloc_base(MemorySegment _Block, long _Count, long _Size) {
        var mh$ = _recalloc_base.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_recalloc_base", _Block, _Count, _Size);
            }
            return (MemorySegment)mh$.invokeExact(_Block, _Count, _Size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _recalloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER,
            C_LONG_LONG,
            C_LONG_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("_recalloc"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *_recalloc(void *_Block, size_t _Count, size_t _Size)
     * }
     */
    public static FunctionDescriptor _recalloc$descriptor() {
        return _recalloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *_recalloc(void *_Block, size_t _Count, size_t _Size)
     * }
     */
    public static MethodHandle _recalloc$handle() {
        return _recalloc.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * void *_recalloc(void *_Block, size_t _Count, size_t _Size)
     * }
     */
    public static MemorySegment _recalloc(MemorySegment _Block, long _Count, long _Size) {
        var mh$ = _recalloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_recalloc", _Block, _Count, _Size);
            }
            return (MemorySegment)mh$.invokeExact(_Block, _Count, _Size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _aligned_free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("_aligned_free"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void _aligned_free(void *_Block)
     * }
     */
    public static FunctionDescriptor _aligned_free$descriptor() {
        return _aligned_free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void _aligned_free(void *_Block)
     * }
     */
    public static MethodHandle _aligned_free$handle() {
        return _aligned_free.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * void _aligned_free(void *_Block)
     * }
     */
    public static void _aligned_free(MemorySegment _Block) {
        var mh$ = _aligned_free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_aligned_free", _Block);
            }
            mh$.invokeExact(_Block);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _aligned_malloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_LONG_LONG,
            C_LONG_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("_aligned_malloc"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *_aligned_malloc(size_t _Size, size_t _Alignment)
     * }
     */
    public static FunctionDescriptor _aligned_malloc$descriptor() {
        return _aligned_malloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *_aligned_malloc(size_t _Size, size_t _Alignment)
     * }
     */
    public static MethodHandle _aligned_malloc$handle() {
        return _aligned_malloc.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * void *_aligned_malloc(size_t _Size, size_t _Alignment)
     * }
     */
    public static MemorySegment _aligned_malloc(long _Size, long _Alignment) {
        var mh$ = _aligned_malloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_aligned_malloc", _Size, _Alignment);
            }
            return (MemorySegment)mh$.invokeExact(_Size, _Alignment);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _aligned_offset_malloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_LONG_LONG,
            C_LONG_LONG,
            C_LONG_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("_aligned_offset_malloc"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *_aligned_offset_malloc(size_t _Size, size_t _Alignment, size_t _Offset)
     * }
     */
    public static FunctionDescriptor _aligned_offset_malloc$descriptor() {
        return _aligned_offset_malloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *_aligned_offset_malloc(size_t _Size, size_t _Alignment, size_t _Offset)
     * }
     */
    public static MethodHandle _aligned_offset_malloc$handle() {
        return _aligned_offset_malloc.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * void *_aligned_offset_malloc(size_t _Size, size_t _Alignment, size_t _Offset)
     * }
     */
    public static MemorySegment _aligned_offset_malloc(long _Size, long _Alignment, long _Offset) {
        var mh$ = _aligned_offset_malloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_aligned_offset_malloc", _Size, _Alignment, _Offset);
            }
            return (MemorySegment)mh$.invokeExact(_Size, _Alignment, _Offset);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _aligned_msize {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG_LONG,
            C_POINTER,
            C_LONG_LONG,
            C_LONG_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("_aligned_msize"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * size_t _aligned_msize(void *_Block, size_t _Alignment, size_t _Offset)
     * }
     */
    public static FunctionDescriptor _aligned_msize$descriptor() {
        return _aligned_msize.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * size_t _aligned_msize(void *_Block, size_t _Alignment, size_t _Offset)
     * }
     */
    public static MethodHandle _aligned_msize$handle() {
        return _aligned_msize.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * size_t _aligned_msize(void *_Block, size_t _Alignment, size_t _Offset)
     * }
     */
    public static long _aligned_msize(MemorySegment _Block, long _Alignment, long _Offset) {
        var mh$ = _aligned_msize.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_aligned_msize", _Block, _Alignment, _Offset);
            }
            return (long)mh$.invokeExact(_Block, _Alignment, _Offset);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _aligned_offset_realloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER,
            C_LONG_LONG,
            C_LONG_LONG,
            C_LONG_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("_aligned_offset_realloc"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *_aligned_offset_realloc(void *_Block, size_t _Size, size_t _Alignment, size_t _Offset)
     * }
     */
    public static FunctionDescriptor _aligned_offset_realloc$descriptor() {
        return _aligned_offset_realloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *_aligned_offset_realloc(void *_Block, size_t _Size, size_t _Alignment, size_t _Offset)
     * }
     */
    public static MethodHandle _aligned_offset_realloc$handle() {
        return _aligned_offset_realloc.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * void *_aligned_offset_realloc(void *_Block, size_t _Size, size_t _Alignment, size_t _Offset)
     * }
     */
    public static MemorySegment _aligned_offset_realloc(MemorySegment _Block, long _Size, long _Alignment, long _Offset) {
        var mh$ = _aligned_offset_realloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_aligned_offset_realloc", _Block, _Size, _Alignment, _Offset);
            }
            return (MemorySegment)mh$.invokeExact(_Block, _Size, _Alignment, _Offset);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _aligned_offset_recalloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER,
            C_LONG_LONG,
            C_LONG_LONG,
            C_LONG_LONG,
            C_LONG_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("_aligned_offset_recalloc"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *_aligned_offset_recalloc(void *_Block, size_t _Count, size_t _Size, size_t _Alignment, size_t _Offset)
     * }
     */
    public static FunctionDescriptor _aligned_offset_recalloc$descriptor() {
        return _aligned_offset_recalloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *_aligned_offset_recalloc(void *_Block, size_t _Count, size_t _Size, size_t _Alignment, size_t _Offset)
     * }
     */
    public static MethodHandle _aligned_offset_recalloc$handle() {
        return _aligned_offset_recalloc.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * void *_aligned_offset_recalloc(void *_Block, size_t _Count, size_t _Size, size_t _Alignment, size_t _Offset)
     * }
     */
    public static MemorySegment _aligned_offset_recalloc(MemorySegment _Block, long _Count, long _Size, long _Alignment, long _Offset) {
        var mh$ = _aligned_offset_recalloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_aligned_offset_recalloc", _Block, _Count, _Size, _Alignment, _Offset);
            }
            return (MemorySegment)mh$.invokeExact(_Block, _Count, _Size, _Alignment, _Offset);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _aligned_realloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER,
            C_LONG_LONG,
            C_LONG_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("_aligned_realloc"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *_aligned_realloc(void *_Block, size_t _Size, size_t _Alignment)
     * }
     */
    public static FunctionDescriptor _aligned_realloc$descriptor() {
        return _aligned_realloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *_aligned_realloc(void *_Block, size_t _Size, size_t _Alignment)
     * }
     */
    public static MethodHandle _aligned_realloc$handle() {
        return _aligned_realloc.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * void *_aligned_realloc(void *_Block, size_t _Size, size_t _Alignment)
     * }
     */
    public static MemorySegment _aligned_realloc(MemorySegment _Block, long _Size, long _Alignment) {
        var mh$ = _aligned_realloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_aligned_realloc", _Block, _Size, _Alignment);
            }
            return (MemorySegment)mh$.invokeExact(_Block, _Size, _Alignment);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _aligned_recalloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER,
            C_LONG_LONG,
            C_LONG_LONG,
            C_LONG_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("_aligned_recalloc"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *_aligned_recalloc(void *_Block, size_t _Count, size_t _Size, size_t _Alignment)
     * }
     */
    public static FunctionDescriptor _aligned_recalloc$descriptor() {
        return _aligned_recalloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *_aligned_recalloc(void *_Block, size_t _Count, size_t _Size, size_t _Alignment)
     * }
     */
    public static MethodHandle _aligned_recalloc$handle() {
        return _aligned_recalloc.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * void *_aligned_recalloc(void *_Block, size_t _Count, size_t _Size, size_t _Alignment)
     * }
     */
    public static MemorySegment _aligned_recalloc(MemorySegment _Block, long _Count, long _Size, long _Alignment) {
        var mh$ = _aligned_recalloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_aligned_recalloc", _Block, _Count, _Size, _Alignment);
            }
            return (MemorySegment)mh$.invokeExact(_Block, _Count, _Size, _Alignment);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class bsearch_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_LONG_LONG,
            C_LONG_LONG,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("bsearch_s"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *bsearch_s(const void *_Key, const void *_Base, rsize_t _NumOfElements, rsize_t _SizeOfElements, _CoreCrtSecureSearchSortCompareFunction _CompareFunction, void *_Context)
     * }
     */
    public static FunctionDescriptor bsearch_s$descriptor() {
        return bsearch_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *bsearch_s(const void *_Key, const void *_Base, rsize_t _NumOfElements, rsize_t _SizeOfElements, _CoreCrtSecureSearchSortCompareFunction _CompareFunction, void *_Context)
     * }
     */
    public static MethodHandle bsearch_s$handle() {
        return bsearch_s.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * void *bsearch_s(const void *_Key, const void *_Base, rsize_t _NumOfElements, rsize_t _SizeOfElements, _CoreCrtSecureSearchSortCompareFunction _CompareFunction, void *_Context)
     * }
     */
    public static MemorySegment bsearch_s(MemorySegment _Key, MemorySegment _Base, long _NumOfElements, long _SizeOfElements, MemorySegment _CompareFunction, MemorySegment _Context) {
        var mh$ = bsearch_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("bsearch_s", _Key, _Base, _NumOfElements, _SizeOfElements, _CompareFunction, _Context);
            }
            return (MemorySegment)mh$.invokeExact(_Key, _Base, _NumOfElements, _SizeOfElements, _CompareFunction, _Context);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class qsort_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C_POINTER,
            C_LONG_LONG,
            C_LONG_LONG,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("qsort_s"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void qsort_s(void *_Base, rsize_t _NumOfElements, rsize_t _SizeOfElements, _CoreCrtSecureSearchSortCompareFunction _CompareFunction, void *_Context)
     * }
     */
    public static FunctionDescriptor qsort_s$descriptor() {
        return qsort_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void qsort_s(void *_Base, rsize_t _NumOfElements, rsize_t _SizeOfElements, _CoreCrtSecureSearchSortCompareFunction _CompareFunction, void *_Context)
     * }
     */
    public static MethodHandle qsort_s$handle() {
        return qsort_s.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * void qsort_s(void *_Base, rsize_t _NumOfElements, rsize_t _SizeOfElements, _CoreCrtSecureSearchSortCompareFunction _CompareFunction, void *_Context)
     * }
     */
    public static void qsort_s(MemorySegment _Base, long _NumOfElements, long _SizeOfElements, MemorySegment _CompareFunction, MemorySegment _Context) {
        var mh$ = qsort_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("qsort_s", _Base, _NumOfElements, _SizeOfElements, _CompareFunction, _Context);
            }
            mh$.invokeExact(_Base, _NumOfElements, _SizeOfElements, _CompareFunction, _Context);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class bsearch {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_LONG_LONG,
            C_LONG_LONG,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("bsearch"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *bsearch(const void *_Key, const void *_Base, size_t _NumOfElements, size_t _SizeOfElements, _CoreCrtNonSecureSearchSortCompareFunction _CompareFunction)
     * }
     */
    public static FunctionDescriptor bsearch$descriptor() {
        return bsearch.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *bsearch(const void *_Key, const void *_Base, size_t _NumOfElements, size_t _SizeOfElements, _CoreCrtNonSecureSearchSortCompareFunction _CompareFunction)
     * }
     */
    public static MethodHandle bsearch$handle() {
        return bsearch.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * void *bsearch(const void *_Key, const void *_Base, size_t _NumOfElements, size_t _SizeOfElements, _CoreCrtNonSecureSearchSortCompareFunction _CompareFunction)
     * }
     */
    public static MemorySegment bsearch(MemorySegment _Key, MemorySegment _Base, long _NumOfElements, long _SizeOfElements, MemorySegment _CompareFunction) {
        var mh$ = bsearch.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("bsearch", _Key, _Base, _NumOfElements, _SizeOfElements, _CompareFunction);
            }
            return (MemorySegment)mh$.invokeExact(_Key, _Base, _NumOfElements, _SizeOfElements, _CompareFunction);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class qsort {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C_POINTER,
            C_LONG_LONG,
            C_LONG_LONG,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("qsort"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void qsort(void *_Base, size_t _NumOfElements, size_t _SizeOfElements, _CoreCrtNonSecureSearchSortCompareFunction _CompareFunction)
     * }
     */
    public static FunctionDescriptor qsort$descriptor() {
        return qsort.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void qsort(void *_Base, size_t _NumOfElements, size_t _SizeOfElements, _CoreCrtNonSecureSearchSortCompareFunction _CompareFunction)
     * }
     */
    public static MethodHandle qsort$handle() {
        return qsort.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * void qsort(void *_Base, size_t _NumOfElements, size_t _SizeOfElements, _CoreCrtNonSecureSearchSortCompareFunction _CompareFunction)
     * }
     */
    public static void qsort(MemorySegment _Base, long _NumOfElements, long _SizeOfElements, MemorySegment _CompareFunction) {
        var mh$ = qsort.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("qsort", _Base, _NumOfElements, _SizeOfElements, _CompareFunction);
            }
            mh$.invokeExact(_Base, _NumOfElements, _SizeOfElements, _CompareFunction);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _lfind_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_LONG_LONG,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("_lfind_s"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *_lfind_s(const void *_Key, const void *_Base, unsigned int *_NumOfElements, size_t _SizeOfElements, _CoreCrtSecureSearchSortCompareFunction _CompareFunction, void *_Context)
     * }
     */
    public static FunctionDescriptor _lfind_s$descriptor() {
        return _lfind_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *_lfind_s(const void *_Key, const void *_Base, unsigned int *_NumOfElements, size_t _SizeOfElements, _CoreCrtSecureSearchSortCompareFunction _CompareFunction, void *_Context)
     * }
     */
    public static MethodHandle _lfind_s$handle() {
        return _lfind_s.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * void *_lfind_s(const void *_Key, const void *_Base, unsigned int *_NumOfElements, size_t _SizeOfElements, _CoreCrtSecureSearchSortCompareFunction _CompareFunction, void *_Context)
     * }
     */
    public static MemorySegment _lfind_s(MemorySegment _Key, MemorySegment _Base, MemorySegment _NumOfElements, long _SizeOfElements, MemorySegment _CompareFunction, MemorySegment _Context) {
        var mh$ = _lfind_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_lfind_s", _Key, _Base, _NumOfElements, _SizeOfElements, _CompareFunction, _Context);
            }
            return (MemorySegment)mh$.invokeExact(_Key, _Base, _NumOfElements, _SizeOfElements, _CompareFunction, _Context);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _lfind {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("_lfind"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *_lfind(const void *_Key, const void *_Base, unsigned int *_NumOfElements, unsigned int _SizeOfElements, _CoreCrtNonSecureSearchSortCompareFunction _CompareFunction)
     * }
     */
    public static FunctionDescriptor _lfind$descriptor() {
        return _lfind.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *_lfind(const void *_Key, const void *_Base, unsigned int *_NumOfElements, unsigned int _SizeOfElements, _CoreCrtNonSecureSearchSortCompareFunction _CompareFunction)
     * }
     */
    public static MethodHandle _lfind$handle() {
        return _lfind.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * void *_lfind(const void *_Key, const void *_Base, unsigned int *_NumOfElements, unsigned int _SizeOfElements, _CoreCrtNonSecureSearchSortCompareFunction _CompareFunction)
     * }
     */
    public static MemorySegment _lfind(MemorySegment _Key, MemorySegment _Base, MemorySegment _NumOfElements, int _SizeOfElements, MemorySegment _CompareFunction) {
        var mh$ = _lfind.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_lfind", _Key, _Base, _NumOfElements, _SizeOfElements, _CompareFunction);
            }
            return (MemorySegment)mh$.invokeExact(_Key, _Base, _NumOfElements, _SizeOfElements, _CompareFunction);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _lsearch_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_LONG_LONG,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("_lsearch_s"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *_lsearch_s(const void *_Key, void *_Base, unsigned int *_NumOfElements, size_t _SizeOfElements, _CoreCrtSecureSearchSortCompareFunction _CompareFunction, void *_Context)
     * }
     */
    public static FunctionDescriptor _lsearch_s$descriptor() {
        return _lsearch_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *_lsearch_s(const void *_Key, void *_Base, unsigned int *_NumOfElements, size_t _SizeOfElements, _CoreCrtSecureSearchSortCompareFunction _CompareFunction, void *_Context)
     * }
     */
    public static MethodHandle _lsearch_s$handle() {
        return _lsearch_s.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * void *_lsearch_s(const void *_Key, void *_Base, unsigned int *_NumOfElements, size_t _SizeOfElements, _CoreCrtSecureSearchSortCompareFunction _CompareFunction, void *_Context)
     * }
     */
    public static MemorySegment _lsearch_s(MemorySegment _Key, MemorySegment _Base, MemorySegment _NumOfElements, long _SizeOfElements, MemorySegment _CompareFunction, MemorySegment _Context) {
        var mh$ = _lsearch_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_lsearch_s", _Key, _Base, _NumOfElements, _SizeOfElements, _CompareFunction, _Context);
            }
            return (MemorySegment)mh$.invokeExact(_Key, _Base, _NumOfElements, _SizeOfElements, _CompareFunction, _Context);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _lsearch {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("_lsearch"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *_lsearch(const void *_Key, void *_Base, unsigned int *_NumOfElements, unsigned int _SizeOfElements, _CoreCrtNonSecureSearchSortCompareFunction _CompareFunction)
     * }
     */
    public static FunctionDescriptor _lsearch$descriptor() {
        return _lsearch.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *_lsearch(const void *_Key, void *_Base, unsigned int *_NumOfElements, unsigned int _SizeOfElements, _CoreCrtNonSecureSearchSortCompareFunction _CompareFunction)
     * }
     */
    public static MethodHandle _lsearch$handle() {
        return _lsearch.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * void *_lsearch(const void *_Key, void *_Base, unsigned int *_NumOfElements, unsigned int _SizeOfElements, _CoreCrtNonSecureSearchSortCompareFunction _CompareFunction)
     * }
     */
    public static MemorySegment _lsearch(MemorySegment _Key, MemorySegment _Base, MemorySegment _NumOfElements, int _SizeOfElements, MemorySegment _CompareFunction) {
        var mh$ = _lsearch.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_lsearch", _Key, _Base, _NumOfElements, _SizeOfElements, _CompareFunction);
            }
            return (MemorySegment)mh$.invokeExact(_Key, _Base, _NumOfElements, _SizeOfElements, _CompareFunction);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lfind {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("lfind"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *lfind(const void *_Key, const void *_Base, unsigned int *_NumOfElements, unsigned int _SizeOfElements, _CoreCrtNonSecureSearchSortCompareFunction _CompareFunction)
     * }
     */
    public static FunctionDescriptor lfind$descriptor() {
        return lfind.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *lfind(const void *_Key, const void *_Base, unsigned int *_NumOfElements, unsigned int _SizeOfElements, _CoreCrtNonSecureSearchSortCompareFunction _CompareFunction)
     * }
     */
    public static MethodHandle lfind$handle() {
        return lfind.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * void *lfind(const void *_Key, const void *_Base, unsigned int *_NumOfElements, unsigned int _SizeOfElements, _CoreCrtNonSecureSearchSortCompareFunction _CompareFunction)
     * }
     */
    public static MemorySegment lfind(MemorySegment _Key, MemorySegment _Base, MemorySegment _NumOfElements, int _SizeOfElements, MemorySegment _CompareFunction) {
        var mh$ = lfind.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lfind", _Key, _Base, _NumOfElements, _SizeOfElements, _CompareFunction);
            }
            return (MemorySegment)mh$.invokeExact(_Key, _Base, _NumOfElements, _SizeOfElements, _CompareFunction);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lsearch {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("lsearch"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *lsearch(const void *_Key, void *_Base, unsigned int *_NumOfElements, unsigned int _SizeOfElements, _CoreCrtNonSecureSearchSortCompareFunction _CompareFunction)
     * }
     */
    public static FunctionDescriptor lsearch$descriptor() {
        return lsearch.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *lsearch(const void *_Key, void *_Base, unsigned int *_NumOfElements, unsigned int _SizeOfElements, _CoreCrtNonSecureSearchSortCompareFunction _CompareFunction)
     * }
     */
    public static MethodHandle lsearch$handle() {
        return lsearch.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * void *lsearch(const void *_Key, void *_Base, unsigned int *_NumOfElements, unsigned int _SizeOfElements, _CoreCrtNonSecureSearchSortCompareFunction _CompareFunction)
     * }
     */
    public static MemorySegment lsearch(MemorySegment _Key, MemorySegment _Base, MemorySegment _NumOfElements, int _SizeOfElements, MemorySegment _CompareFunction) {
        var mh$ = lsearch.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lsearch", _Key, _Base, _NumOfElements, _SizeOfElements, _CompareFunction);
            }
            return (MemorySegment)mh$.invokeExact(_Key, _Base, _NumOfElements, _SizeOfElements, _CompareFunction);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _itow_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_INT,
            C_POINTER,
            C_LONG_LONG,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("_itow_s"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t _itow_s(int _Value, wchar_t *_Buffer, size_t _BufferCount, int _Radix)
     * }
     */
    public static FunctionDescriptor _itow_s$descriptor() {
        return _itow_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t _itow_s(int _Value, wchar_t *_Buffer, size_t _BufferCount, int _Radix)
     * }
     */
    public static MethodHandle _itow_s$handle() {
        return _itow_s.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * errno_t _itow_s(int _Value, wchar_t *_Buffer, size_t _BufferCount, int _Radix)
     * }
     */
    public static int _itow_s(int _Value, MemorySegment _Buffer, long _BufferCount, int _Radix) {
        var mh$ = _itow_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_itow_s", _Value, _Buffer, _BufferCount, _Radix);
            }
            return (int)mh$.invokeExact(_Value, _Buffer, _BufferCount, _Radix);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _itow {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_INT,
            C_POINTER,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("_itow"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wchar_t *_itow(int _Value, wchar_t *_Buffer, int _Radix)
     * }
     */
    public static FunctionDescriptor _itow$descriptor() {
        return _itow.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wchar_t *_itow(int _Value, wchar_t *_Buffer, int _Radix)
     * }
     */
    public static MethodHandle _itow$handle() {
        return _itow.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * wchar_t *_itow(int _Value, wchar_t *_Buffer, int _Radix)
     * }
     */
    public static MemorySegment _itow(int _Value, MemorySegment _Buffer, int _Radix) {
        var mh$ = _itow.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_itow", _Value, _Buffer, _Radix);
            }
            return (MemorySegment)mh$.invokeExact(_Value, _Buffer, _Radix);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _ltow_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_LONG,
            C_POINTER,
            C_LONG_LONG,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("_ltow_s"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t _ltow_s(long _Value, wchar_t *_Buffer, size_t _BufferCount, int _Radix)
     * }
     */
    public static FunctionDescriptor _ltow_s$descriptor() {
        return _ltow_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t _ltow_s(long _Value, wchar_t *_Buffer, size_t _BufferCount, int _Radix)
     * }
     */
    public static MethodHandle _ltow_s$handle() {
        return _ltow_s.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * errno_t _ltow_s(long _Value, wchar_t *_Buffer, size_t _BufferCount, int _Radix)
     * }
     */
    public static int _ltow_s(int _Value, MemorySegment _Buffer, long _BufferCount, int _Radix) {
        var mh$ = _ltow_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_ltow_s", _Value, _Buffer, _BufferCount, _Radix);
            }
            return (int)mh$.invokeExact(_Value, _Buffer, _BufferCount, _Radix);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _ltow {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_LONG,
            C_POINTER,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("_ltow"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wchar_t *_ltow(long _Value, wchar_t *_Buffer, int _Radix)
     * }
     */
    public static FunctionDescriptor _ltow$descriptor() {
        return _ltow.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wchar_t *_ltow(long _Value, wchar_t *_Buffer, int _Radix)
     * }
     */
    public static MethodHandle _ltow$handle() {
        return _ltow.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * wchar_t *_ltow(long _Value, wchar_t *_Buffer, int _Radix)
     * }
     */
    public static MemorySegment _ltow(int _Value, MemorySegment _Buffer, int _Radix) {
        var mh$ = _ltow.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_ltow", _Value, _Buffer, _Radix);
            }
            return (MemorySegment)mh$.invokeExact(_Value, _Buffer, _Radix);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _ultow_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_LONG,
            C_POINTER,
            C_LONG_LONG,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("_ultow_s"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t _ultow_s(unsigned long _Value, wchar_t *_Buffer, size_t _BufferCount, int _Radix)
     * }
     */
    public static FunctionDescriptor _ultow_s$descriptor() {
        return _ultow_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t _ultow_s(unsigned long _Value, wchar_t *_Buffer, size_t _BufferCount, int _Radix)
     * }
     */
    public static MethodHandle _ultow_s$handle() {
        return _ultow_s.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * errno_t _ultow_s(unsigned long _Value, wchar_t *_Buffer, size_t _BufferCount, int _Radix)
     * }
     */
    public static int _ultow_s(int _Value, MemorySegment _Buffer, long _BufferCount, int _Radix) {
        var mh$ = _ultow_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_ultow_s", _Value, _Buffer, _BufferCount, _Radix);
            }
            return (int)mh$.invokeExact(_Value, _Buffer, _BufferCount, _Radix);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _ultow {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_LONG,
            C_POINTER,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("_ultow"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wchar_t *_ultow(unsigned long _Value, wchar_t *_Buffer, int _Radix)
     * }
     */
    public static FunctionDescriptor _ultow$descriptor() {
        return _ultow.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wchar_t *_ultow(unsigned long _Value, wchar_t *_Buffer, int _Radix)
     * }
     */
    public static MethodHandle _ultow$handle() {
        return _ultow.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * wchar_t *_ultow(unsigned long _Value, wchar_t *_Buffer, int _Radix)
     * }
     */
    public static MemorySegment _ultow(int _Value, MemorySegment _Buffer, int _Radix) {
        var mh$ = _ultow.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_ultow", _Value, _Buffer, _Radix);
            }
            return (MemorySegment)mh$.invokeExact(_Value, _Buffer, _Radix);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wcstod {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_DOUBLE,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("wcstod"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double wcstod(const wchar_t *_String, wchar_t **_EndPtr)
     * }
     */
    public static FunctionDescriptor wcstod$descriptor() {
        return wcstod.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double wcstod(const wchar_t *_String, wchar_t **_EndPtr)
     * }
     */
    public static MethodHandle wcstod$handle() {
        return wcstod.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * double wcstod(const wchar_t *_String, wchar_t **_EndPtr)
     * }
     */
    public static double wcstod(MemorySegment _String, MemorySegment _EndPtr) {
        var mh$ = wcstod.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wcstod", _String, _EndPtr);
            }
            return (double)mh$.invokeExact(_String, _EndPtr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wcstod_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_DOUBLE,
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("_wcstod_l"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double _wcstod_l(const wchar_t *_String, wchar_t **_EndPtr, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _wcstod_l$descriptor() {
        return _wcstod_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double _wcstod_l(const wchar_t *_String, wchar_t **_EndPtr, _locale_t _Locale)
     * }
     */
    public static MethodHandle _wcstod_l$handle() {
        return _wcstod_l.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * double _wcstod_l(const wchar_t *_String, wchar_t **_EndPtr, _locale_t _Locale)
     * }
     */
    public static double _wcstod_l(MemorySegment _String, MemorySegment _EndPtr, MemorySegment _Locale) {
        var mh$ = _wcstod_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wcstod_l", _String, _EndPtr, _Locale);
            }
            return (double)mh$.invokeExact(_String, _EndPtr, _Locale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wcstol {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_POINTER,
            C_POINTER,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("wcstol"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long wcstol(const wchar_t *_String, wchar_t **_EndPtr, int _Radix)
     * }
     */
    public static FunctionDescriptor wcstol$descriptor() {
        return wcstol.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long wcstol(const wchar_t *_String, wchar_t **_EndPtr, int _Radix)
     * }
     */
    public static MethodHandle wcstol$handle() {
        return wcstol.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * long wcstol(const wchar_t *_String, wchar_t **_EndPtr, int _Radix)
     * }
     */
    public static int wcstol(MemorySegment _String, MemorySegment _EndPtr, int _Radix) {
        var mh$ = wcstol.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wcstol", _String, _EndPtr, _Radix);
            }
            return (int)mh$.invokeExact(_String, _EndPtr, _Radix);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wcstol_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_POINTER,
            C_POINTER,
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("_wcstol_l"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long _wcstol_l(const wchar_t *_String, wchar_t **_EndPtr, int _Radix, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _wcstol_l$descriptor() {
        return _wcstol_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long _wcstol_l(const wchar_t *_String, wchar_t **_EndPtr, int _Radix, _locale_t _Locale)
     * }
     */
    public static MethodHandle _wcstol_l$handle() {
        return _wcstol_l.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * long _wcstol_l(const wchar_t *_String, wchar_t **_EndPtr, int _Radix, _locale_t _Locale)
     * }
     */
    public static int _wcstol_l(MemorySegment _String, MemorySegment _EndPtr, int _Radix, MemorySegment _Locale) {
        var mh$ = _wcstol_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wcstol_l", _String, _EndPtr, _Radix, _Locale);
            }
            return (int)mh$.invokeExact(_String, _EndPtr, _Radix, _Locale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wcstoll {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG_LONG,
            C_POINTER,
            C_POINTER,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("wcstoll"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long long wcstoll(const wchar_t *_String, wchar_t **_EndPtr, int _Radix)
     * }
     */
    public static FunctionDescriptor wcstoll$descriptor() {
        return wcstoll.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long long wcstoll(const wchar_t *_String, wchar_t **_EndPtr, int _Radix)
     * }
     */
    public static MethodHandle wcstoll$handle() {
        return wcstoll.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * long long wcstoll(const wchar_t *_String, wchar_t **_EndPtr, int _Radix)
     * }
     */
    public static long wcstoll(MemorySegment _String, MemorySegment _EndPtr, int _Radix) {
        var mh$ = wcstoll.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wcstoll", _String, _EndPtr, _Radix);
            }
            return (long)mh$.invokeExact(_String, _EndPtr, _Radix);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wcstoll_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG_LONG,
            C_POINTER,
            C_POINTER,
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("_wcstoll_l"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long long _wcstoll_l(const wchar_t *_String, wchar_t **_EndPtr, int _Radix, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _wcstoll_l$descriptor() {
        return _wcstoll_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long long _wcstoll_l(const wchar_t *_String, wchar_t **_EndPtr, int _Radix, _locale_t _Locale)
     * }
     */
    public static MethodHandle _wcstoll_l$handle() {
        return _wcstoll_l.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * long long _wcstoll_l(const wchar_t *_String, wchar_t **_EndPtr, int _Radix, _locale_t _Locale)
     * }
     */
    public static long _wcstoll_l(MemorySegment _String, MemorySegment _EndPtr, int _Radix, MemorySegment _Locale) {
        var mh$ = _wcstoll_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wcstoll_l", _String, _EndPtr, _Radix, _Locale);
            }
            return (long)mh$.invokeExact(_String, _EndPtr, _Radix, _Locale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wcstoul {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_POINTER,
            C_POINTER,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("wcstoul"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned long wcstoul(const wchar_t *_String, wchar_t **_EndPtr, int _Radix)
     * }
     */
    public static FunctionDescriptor wcstoul$descriptor() {
        return wcstoul.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned long wcstoul(const wchar_t *_String, wchar_t **_EndPtr, int _Radix)
     * }
     */
    public static MethodHandle wcstoul$handle() {
        return wcstoul.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * unsigned long wcstoul(const wchar_t *_String, wchar_t **_EndPtr, int _Radix)
     * }
     */
    public static int wcstoul(MemorySegment _String, MemorySegment _EndPtr, int _Radix) {
        var mh$ = wcstoul.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wcstoul", _String, _EndPtr, _Radix);
            }
            return (int)mh$.invokeExact(_String, _EndPtr, _Radix);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wcstoul_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_POINTER,
            C_POINTER,
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("_wcstoul_l"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned long _wcstoul_l(const wchar_t *_String, wchar_t **_EndPtr, int _Radix, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _wcstoul_l$descriptor() {
        return _wcstoul_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned long _wcstoul_l(const wchar_t *_String, wchar_t **_EndPtr, int _Radix, _locale_t _Locale)
     * }
     */
    public static MethodHandle _wcstoul_l$handle() {
        return _wcstoul_l.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * unsigned long _wcstoul_l(const wchar_t *_String, wchar_t **_EndPtr, int _Radix, _locale_t _Locale)
     * }
     */
    public static int _wcstoul_l(MemorySegment _String, MemorySegment _EndPtr, int _Radix, MemorySegment _Locale) {
        var mh$ = _wcstoul_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wcstoul_l", _String, _EndPtr, _Radix, _Locale);
            }
            return (int)mh$.invokeExact(_String, _EndPtr, _Radix, _Locale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wcstoull {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG_LONG,
            C_POINTER,
            C_POINTER,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("wcstoull"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned long long wcstoull(const wchar_t *_String, wchar_t **_EndPtr, int _Radix)
     * }
     */
    public static FunctionDescriptor wcstoull$descriptor() {
        return wcstoull.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned long long wcstoull(const wchar_t *_String, wchar_t **_EndPtr, int _Radix)
     * }
     */
    public static MethodHandle wcstoull$handle() {
        return wcstoull.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * unsigned long long wcstoull(const wchar_t *_String, wchar_t **_EndPtr, int _Radix)
     * }
     */
    public static long wcstoull(MemorySegment _String, MemorySegment _EndPtr, int _Radix) {
        var mh$ = wcstoull.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wcstoull", _String, _EndPtr, _Radix);
            }
            return (long)mh$.invokeExact(_String, _EndPtr, _Radix);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wcstoull_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG_LONG,
            C_POINTER,
            C_POINTER,
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("_wcstoull_l"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned long long _wcstoull_l(const wchar_t *_String, wchar_t **_EndPtr, int _Radix, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _wcstoull_l$descriptor() {
        return _wcstoull_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned long long _wcstoull_l(const wchar_t *_String, wchar_t **_EndPtr, int _Radix, _locale_t _Locale)
     * }
     */
    public static MethodHandle _wcstoull_l$handle() {
        return _wcstoull_l.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * unsigned long long _wcstoull_l(const wchar_t *_String, wchar_t **_EndPtr, int _Radix, _locale_t _Locale)
     * }
     */
    public static long _wcstoull_l(MemorySegment _String, MemorySegment _EndPtr, int _Radix, MemorySegment _Locale) {
        var mh$ = _wcstoull_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wcstoull_l", _String, _EndPtr, _Radix, _Locale);
            }
            return (long)mh$.invokeExact(_String, _EndPtr, _Radix, _Locale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wcstold {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG_DOUBLE,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("wcstold"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long double wcstold(const wchar_t *_String, wchar_t **_EndPtr)
     * }
     */
    public static FunctionDescriptor wcstold$descriptor() {
        return wcstold.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long double wcstold(const wchar_t *_String, wchar_t **_EndPtr)
     * }
     */
    public static MethodHandle wcstold$handle() {
        return wcstold.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * long double wcstold(const wchar_t *_String, wchar_t **_EndPtr)
     * }
     */
    public static double wcstold(MemorySegment _String, MemorySegment _EndPtr) {
        var mh$ = wcstold.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wcstold", _String, _EndPtr);
            }
            return (double)mh$.invokeExact(_String, _EndPtr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wcstold_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG_DOUBLE,
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("_wcstold_l"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long double _wcstold_l(const wchar_t *_String, wchar_t **_EndPtr, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _wcstold_l$descriptor() {
        return _wcstold_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long double _wcstold_l(const wchar_t *_String, wchar_t **_EndPtr, _locale_t _Locale)
     * }
     */
    public static MethodHandle _wcstold_l$handle() {
        return _wcstold_l.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * long double _wcstold_l(const wchar_t *_String, wchar_t **_EndPtr, _locale_t _Locale)
     * }
     */
    public static double _wcstold_l(MemorySegment _String, MemorySegment _EndPtr, MemorySegment _Locale) {
        var mh$ = _wcstold_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wcstold_l", _String, _EndPtr, _Locale);
            }
            return (double)mh$.invokeExact(_String, _EndPtr, _Locale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wcstof {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_FLOAT,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("wcstof"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float wcstof(const wchar_t *_String, wchar_t **_EndPtr)
     * }
     */
    public static FunctionDescriptor wcstof$descriptor() {
        return wcstof.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float wcstof(const wchar_t *_String, wchar_t **_EndPtr)
     * }
     */
    public static MethodHandle wcstof$handle() {
        return wcstof.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * float wcstof(const wchar_t *_String, wchar_t **_EndPtr)
     * }
     */
    public static float wcstof(MemorySegment _String, MemorySegment _EndPtr) {
        var mh$ = wcstof.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wcstof", _String, _EndPtr);
            }
            return (float)mh$.invokeExact(_String, _EndPtr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wcstof_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_FLOAT,
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("_wcstof_l"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float _wcstof_l(const wchar_t *_String, wchar_t **_EndPtr, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _wcstof_l$descriptor() {
        return _wcstof_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float _wcstof_l(const wchar_t *_String, wchar_t **_EndPtr, _locale_t _Locale)
     * }
     */
    public static MethodHandle _wcstof_l$handle() {
        return _wcstof_l.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * float _wcstof_l(const wchar_t *_String, wchar_t **_EndPtr, _locale_t _Locale)
     * }
     */
    public static float _wcstof_l(MemorySegment _String, MemorySegment _EndPtr, MemorySegment _Locale) {
        var mh$ = _wcstof_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wcstof_l", _String, _EndPtr, _Locale);
            }
            return (float)mh$.invokeExact(_String, _EndPtr, _Locale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wtof {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_DOUBLE,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("_wtof"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double _wtof(const wchar_t *_String)
     * }
     */
    public static FunctionDescriptor _wtof$descriptor() {
        return _wtof.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double _wtof(const wchar_t *_String)
     * }
     */
    public static MethodHandle _wtof$handle() {
        return _wtof.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * double _wtof(const wchar_t *_String)
     * }
     */
    public static double _wtof(MemorySegment _String) {
        var mh$ = _wtof.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wtof", _String);
            }
            return (double)mh$.invokeExact(_String);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wtof_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_DOUBLE,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("_wtof_l"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double _wtof_l(const wchar_t *_String, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _wtof_l$descriptor() {
        return _wtof_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double _wtof_l(const wchar_t *_String, _locale_t _Locale)
     * }
     */
    public static MethodHandle _wtof_l$handle() {
        return _wtof_l.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * double _wtof_l(const wchar_t *_String, _locale_t _Locale)
     * }
     */
    public static double _wtof_l(MemorySegment _String, MemorySegment _Locale) {
        var mh$ = _wtof_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wtof_l", _String, _Locale);
            }
            return (double)mh$.invokeExact(_String, _Locale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wtoi {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("_wtoi"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _wtoi(const wchar_t *_String)
     * }
     */
    public static FunctionDescriptor _wtoi$descriptor() {
        return _wtoi.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _wtoi(const wchar_t *_String)
     * }
     */
    public static MethodHandle _wtoi$handle() {
        return _wtoi.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int _wtoi(const wchar_t *_String)
     * }
     */
    public static int _wtoi(MemorySegment _String) {
        var mh$ = _wtoi.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wtoi", _String);
            }
            return (int)mh$.invokeExact(_String);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wtoi_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("_wtoi_l"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _wtoi_l(const wchar_t *_String, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _wtoi_l$descriptor() {
        return _wtoi_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _wtoi_l(const wchar_t *_String, _locale_t _Locale)
     * }
     */
    public static MethodHandle _wtoi_l$handle() {
        return _wtoi_l.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int _wtoi_l(const wchar_t *_String, _locale_t _Locale)
     * }
     */
    public static int _wtoi_l(MemorySegment _String, MemorySegment _Locale) {
        var mh$ = _wtoi_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wtoi_l", _String, _Locale);
            }
            return (int)mh$.invokeExact(_String, _Locale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wtol {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("_wtol"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long _wtol(const wchar_t *_String)
     * }
     */
    public static FunctionDescriptor _wtol$descriptor() {
        return _wtol.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long _wtol(const wchar_t *_String)
     * }
     */
    public static MethodHandle _wtol$handle() {
        return _wtol.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * long _wtol(const wchar_t *_String)
     * }
     */
    public static int _wtol(MemorySegment _String) {
        var mh$ = _wtol.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wtol", _String);
            }
            return (int)mh$.invokeExact(_String);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wtol_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("_wtol_l"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long _wtol_l(const wchar_t *_String, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _wtol_l$descriptor() {
        return _wtol_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long _wtol_l(const wchar_t *_String, _locale_t _Locale)
     * }
     */
    public static MethodHandle _wtol_l$handle() {
        return _wtol_l.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * long _wtol_l(const wchar_t *_String, _locale_t _Locale)
     * }
     */
    public static int _wtol_l(MemorySegment _String, MemorySegment _Locale) {
        var mh$ = _wtol_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wtol_l", _String, _Locale);
            }
            return (int)mh$.invokeExact(_String, _Locale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wtoll {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG_LONG,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("_wtoll"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long long _wtoll(const wchar_t *_String)
     * }
     */
    public static FunctionDescriptor _wtoll$descriptor() {
        return _wtoll.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long long _wtoll(const wchar_t *_String)
     * }
     */
    public static MethodHandle _wtoll$handle() {
        return _wtoll.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * long long _wtoll(const wchar_t *_String)
     * }
     */
    public static long _wtoll(MemorySegment _String) {
        var mh$ = _wtoll.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wtoll", _String);
            }
            return (long)mh$.invokeExact(_String);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wtoll_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG_LONG,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("_wtoll_l"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long long _wtoll_l(const wchar_t *_String, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _wtoll_l$descriptor() {
        return _wtoll_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long long _wtoll_l(const wchar_t *_String, _locale_t _Locale)
     * }
     */
    public static MethodHandle _wtoll_l$handle() {
        return _wtoll_l.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * long long _wtoll_l(const wchar_t *_String, _locale_t _Locale)
     * }
     */
    public static long _wtoll_l(MemorySegment _String, MemorySegment _Locale) {
        var mh$ = _wtoll_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wtoll_l", _String, _Locale);
            }
            return (long)mh$.invokeExact(_String, _Locale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _i64tow_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_LONG_LONG,
            C_POINTER,
            C_LONG_LONG,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("_i64tow_s"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t _i64tow_s(long long _Value, wchar_t *_Buffer, size_t _BufferCount, int _Radix)
     * }
     */
    public static FunctionDescriptor _i64tow_s$descriptor() {
        return _i64tow_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t _i64tow_s(long long _Value, wchar_t *_Buffer, size_t _BufferCount, int _Radix)
     * }
     */
    public static MethodHandle _i64tow_s$handle() {
        return _i64tow_s.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * errno_t _i64tow_s(long long _Value, wchar_t *_Buffer, size_t _BufferCount, int _Radix)
     * }
     */
    public static int _i64tow_s(long _Value, MemorySegment _Buffer, long _BufferCount, int _Radix) {
        var mh$ = _i64tow_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_i64tow_s", _Value, _Buffer, _BufferCount, _Radix);
            }
            return (int)mh$.invokeExact(_Value, _Buffer, _BufferCount, _Radix);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _i64tow {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_LONG_LONG,
            C_POINTER,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("_i64tow"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wchar_t *_i64tow(long long _Value, wchar_t *_Buffer, int _Radix)
     * }
     */
    public static FunctionDescriptor _i64tow$descriptor() {
        return _i64tow.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wchar_t *_i64tow(long long _Value, wchar_t *_Buffer, int _Radix)
     * }
     */
    public static MethodHandle _i64tow$handle() {
        return _i64tow.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * wchar_t *_i64tow(long long _Value, wchar_t *_Buffer, int _Radix)
     * }
     */
    public static MemorySegment _i64tow(long _Value, MemorySegment _Buffer, int _Radix) {
        var mh$ = _i64tow.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_i64tow", _Value, _Buffer, _Radix);
            }
            return (MemorySegment)mh$.invokeExact(_Value, _Buffer, _Radix);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _ui64tow_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_LONG_LONG,
            C_POINTER,
            C_LONG_LONG,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("_ui64tow_s"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t _ui64tow_s(unsigned long long _Value, wchar_t *_Buffer, size_t _BufferCount, int _Radix)
     * }
     */
    public static FunctionDescriptor _ui64tow_s$descriptor() {
        return _ui64tow_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t _ui64tow_s(unsigned long long _Value, wchar_t *_Buffer, size_t _BufferCount, int _Radix)
     * }
     */
    public static MethodHandle _ui64tow_s$handle() {
        return _ui64tow_s.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * errno_t _ui64tow_s(unsigned long long _Value, wchar_t *_Buffer, size_t _BufferCount, int _Radix)
     * }
     */
    public static int _ui64tow_s(long _Value, MemorySegment _Buffer, long _BufferCount, int _Radix) {
        var mh$ = _ui64tow_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_ui64tow_s", _Value, _Buffer, _BufferCount, _Radix);
            }
            return (int)mh$.invokeExact(_Value, _Buffer, _BufferCount, _Radix);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _ui64tow {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_LONG_LONG,
            C_POINTER,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("_ui64tow"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wchar_t *_ui64tow(unsigned long long _Value, wchar_t *_Buffer, int _Radix)
     * }
     */
    public static FunctionDescriptor _ui64tow$descriptor() {
        return _ui64tow.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wchar_t *_ui64tow(unsigned long long _Value, wchar_t *_Buffer, int _Radix)
     * }
     */
    public static MethodHandle _ui64tow$handle() {
        return _ui64tow.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * wchar_t *_ui64tow(unsigned long long _Value, wchar_t *_Buffer, int _Radix)
     * }
     */
    public static MemorySegment _ui64tow(long _Value, MemorySegment _Buffer, int _Radix) {
        var mh$ = _ui64tow.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_ui64tow", _Value, _Buffer, _Radix);
            }
            return (MemorySegment)mh$.invokeExact(_Value, _Buffer, _Radix);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wtoi64 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG_LONG,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("_wtoi64"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long long _wtoi64(const wchar_t *_String)
     * }
     */
    public static FunctionDescriptor _wtoi64$descriptor() {
        return _wtoi64.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long long _wtoi64(const wchar_t *_String)
     * }
     */
    public static MethodHandle _wtoi64$handle() {
        return _wtoi64.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * long long _wtoi64(const wchar_t *_String)
     * }
     */
    public static long _wtoi64(MemorySegment _String) {
        var mh$ = _wtoi64.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wtoi64", _String);
            }
            return (long)mh$.invokeExact(_String);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wtoi64_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG_LONG,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("_wtoi64_l"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long long _wtoi64_l(const wchar_t *_String, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _wtoi64_l$descriptor() {
        return _wtoi64_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long long _wtoi64_l(const wchar_t *_String, _locale_t _Locale)
     * }
     */
    public static MethodHandle _wtoi64_l$handle() {
        return _wtoi64_l.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * long long _wtoi64_l(const wchar_t *_String, _locale_t _Locale)
     * }
     */
    public static long _wtoi64_l(MemorySegment _String, MemorySegment _Locale) {
        var mh$ = _wtoi64_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wtoi64_l", _String, _Locale);
            }
            return (long)mh$.invokeExact(_String, _Locale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wcstoi64 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG_LONG,
            C_POINTER,
            C_POINTER,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("_wcstoi64"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long long _wcstoi64(const wchar_t *_String, wchar_t **_EndPtr, int _Radix)
     * }
     */
    public static FunctionDescriptor _wcstoi64$descriptor() {
        return _wcstoi64.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long long _wcstoi64(const wchar_t *_String, wchar_t **_EndPtr, int _Radix)
     * }
     */
    public static MethodHandle _wcstoi64$handle() {
        return _wcstoi64.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * long long _wcstoi64(const wchar_t *_String, wchar_t **_EndPtr, int _Radix)
     * }
     */
    public static long _wcstoi64(MemorySegment _String, MemorySegment _EndPtr, int _Radix) {
        var mh$ = _wcstoi64.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wcstoi64", _String, _EndPtr, _Radix);
            }
            return (long)mh$.invokeExact(_String, _EndPtr, _Radix);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wcstoi64_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG_LONG,
            C_POINTER,
            C_POINTER,
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("_wcstoi64_l"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long long _wcstoi64_l(const wchar_t *_String, wchar_t **_EndPtr, int _Radix, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _wcstoi64_l$descriptor() {
        return _wcstoi64_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long long _wcstoi64_l(const wchar_t *_String, wchar_t **_EndPtr, int _Radix, _locale_t _Locale)
     * }
     */
    public static MethodHandle _wcstoi64_l$handle() {
        return _wcstoi64_l.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * long long _wcstoi64_l(const wchar_t *_String, wchar_t **_EndPtr, int _Radix, _locale_t _Locale)
     * }
     */
    public static long _wcstoi64_l(MemorySegment _String, MemorySegment _EndPtr, int _Radix, MemorySegment _Locale) {
        var mh$ = _wcstoi64_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wcstoi64_l", _String, _EndPtr, _Radix, _Locale);
            }
            return (long)mh$.invokeExact(_String, _EndPtr, _Radix, _Locale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wcstoui64 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG_LONG,
            C_POINTER,
            C_POINTER,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("_wcstoui64"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned long long _wcstoui64(const wchar_t *_String, wchar_t **_EndPtr, int _Radix)
     * }
     */
    public static FunctionDescriptor _wcstoui64$descriptor() {
        return _wcstoui64.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned long long _wcstoui64(const wchar_t *_String, wchar_t **_EndPtr, int _Radix)
     * }
     */
    public static MethodHandle _wcstoui64$handle() {
        return _wcstoui64.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * unsigned long long _wcstoui64(const wchar_t *_String, wchar_t **_EndPtr, int _Radix)
     * }
     */
    public static long _wcstoui64(MemorySegment _String, MemorySegment _EndPtr, int _Radix) {
        var mh$ = _wcstoui64.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wcstoui64", _String, _EndPtr, _Radix);
            }
            return (long)mh$.invokeExact(_String, _EndPtr, _Radix);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wcstoui64_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG_LONG,
            C_POINTER,
            C_POINTER,
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("_wcstoui64_l"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned long long _wcstoui64_l(const wchar_t *_String, wchar_t **_EndPtr, int _Radix, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _wcstoui64_l$descriptor() {
        return _wcstoui64_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned long long _wcstoui64_l(const wchar_t *_String, wchar_t **_EndPtr, int _Radix, _locale_t _Locale)
     * }
     */
    public static MethodHandle _wcstoui64_l$handle() {
        return _wcstoui64_l.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * unsigned long long _wcstoui64_l(const wchar_t *_String, wchar_t **_EndPtr, int _Radix, _locale_t _Locale)
     * }
     */
    public static long _wcstoui64_l(MemorySegment _String, MemorySegment _EndPtr, int _Radix, MemorySegment _Locale) {
        var mh$ = _wcstoui64_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wcstoui64_l", _String, _EndPtr, _Radix, _Locale);
            }
            return (long)mh$.invokeExact(_String, _EndPtr, _Radix, _Locale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wfullpath {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_LONG_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("_wfullpath"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wchar_t *_wfullpath(wchar_t *_Buffer, const wchar_t *_Path, size_t _BufferCount)
     * }
     */
    public static FunctionDescriptor _wfullpath$descriptor() {
        return _wfullpath.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wchar_t *_wfullpath(wchar_t *_Buffer, const wchar_t *_Path, size_t _BufferCount)
     * }
     */
    public static MethodHandle _wfullpath$handle() {
        return _wfullpath.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * wchar_t *_wfullpath(wchar_t *_Buffer, const wchar_t *_Path, size_t _BufferCount)
     * }
     */
    public static MemorySegment _wfullpath(MemorySegment _Buffer, MemorySegment _Path, long _BufferCount) {
        var mh$ = _wfullpath.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wfullpath", _Buffer, _Path, _BufferCount);
            }
            return (MemorySegment)mh$.invokeExact(_Buffer, _Path, _BufferCount);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wmakepath_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_LONG_LONG,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("_wmakepath_s"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t _wmakepath_s(wchar_t *_Buffer, size_t _BufferCount, const wchar_t *_Drive, const wchar_t *_Dir, const wchar_t *_Filename, const wchar_t *_Ext)
     * }
     */
    public static FunctionDescriptor _wmakepath_s$descriptor() {
        return _wmakepath_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t _wmakepath_s(wchar_t *_Buffer, size_t _BufferCount, const wchar_t *_Drive, const wchar_t *_Dir, const wchar_t *_Filename, const wchar_t *_Ext)
     * }
     */
    public static MethodHandle _wmakepath_s$handle() {
        return _wmakepath_s.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * errno_t _wmakepath_s(wchar_t *_Buffer, size_t _BufferCount, const wchar_t *_Drive, const wchar_t *_Dir, const wchar_t *_Filename, const wchar_t *_Ext)
     * }
     */
    public static int _wmakepath_s(MemorySegment _Buffer, long _BufferCount, MemorySegment _Drive, MemorySegment _Dir, MemorySegment _Filename, MemorySegment _Ext) {
        var mh$ = _wmakepath_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wmakepath_s", _Buffer, _BufferCount, _Drive, _Dir, _Filename, _Ext);
            }
            return (int)mh$.invokeExact(_Buffer, _BufferCount, _Drive, _Dir, _Filename, _Ext);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wmakepath {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("_wmakepath"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void _wmakepath(wchar_t *_Buffer, const wchar_t *_Drive, const wchar_t *_Dir, const wchar_t *_Filename, const wchar_t *_Ext)
     * }
     */
    public static FunctionDescriptor _wmakepath$descriptor() {
        return _wmakepath.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void _wmakepath(wchar_t *_Buffer, const wchar_t *_Drive, const wchar_t *_Dir, const wchar_t *_Filename, const wchar_t *_Ext)
     * }
     */
    public static MethodHandle _wmakepath$handle() {
        return _wmakepath.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * void _wmakepath(wchar_t *_Buffer, const wchar_t *_Drive, const wchar_t *_Dir, const wchar_t *_Filename, const wchar_t *_Ext)
     * }
     */
    public static void _wmakepath(MemorySegment _Buffer, MemorySegment _Drive, MemorySegment _Dir, MemorySegment _Filename, MemorySegment _Ext) {
        var mh$ = _wmakepath.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wmakepath", _Buffer, _Drive, _Dir, _Filename, _Ext);
            }
            mh$.invokeExact(_Buffer, _Drive, _Dir, _Filename, _Ext);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wperror {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("_wperror"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void _wperror(const wchar_t *_ErrorMessage)
     * }
     */
    public static FunctionDescriptor _wperror$descriptor() {
        return _wperror.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void _wperror(const wchar_t *_ErrorMessage)
     * }
     */
    public static MethodHandle _wperror$handle() {
        return _wperror.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * void _wperror(const wchar_t *_ErrorMessage)
     * }
     */
    public static void _wperror(MemorySegment _ErrorMessage) {
        var mh$ = _wperror.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wperror", _ErrorMessage);
            }
            mh$.invokeExact(_ErrorMessage);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wsplitpath {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("_wsplitpath"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void _wsplitpath(const wchar_t *_FullPath, wchar_t *_Drive, wchar_t *_Dir, wchar_t *_Filename, wchar_t *_Ext)
     * }
     */
    public static FunctionDescriptor _wsplitpath$descriptor() {
        return _wsplitpath.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void _wsplitpath(const wchar_t *_FullPath, wchar_t *_Drive, wchar_t *_Dir, wchar_t *_Filename, wchar_t *_Ext)
     * }
     */
    public static MethodHandle _wsplitpath$handle() {
        return _wsplitpath.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * void _wsplitpath(const wchar_t *_FullPath, wchar_t *_Drive, wchar_t *_Dir, wchar_t *_Filename, wchar_t *_Ext)
     * }
     */
    public static void _wsplitpath(MemorySegment _FullPath, MemorySegment _Drive, MemorySegment _Dir, MemorySegment _Filename, MemorySegment _Ext) {
        var mh$ = _wsplitpath.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wsplitpath", _FullPath, _Drive, _Dir, _Filename, _Ext);
            }
            mh$.invokeExact(_FullPath, _Drive, _Dir, _Filename, _Ext);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wsplitpath_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_LONG_LONG,
            C_POINTER,
            C_LONG_LONG,
            C_POINTER,
            C_LONG_LONG,
            C_POINTER,
            C_LONG_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("_wsplitpath_s"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t _wsplitpath_s(const wchar_t *_FullPath, wchar_t *_Drive, size_t _DriveCount, wchar_t *_Dir, size_t _DirCount, wchar_t *_Filename, size_t _FilenameCount, wchar_t *_Ext, size_t _ExtCount)
     * }
     */
    public static FunctionDescriptor _wsplitpath_s$descriptor() {
        return _wsplitpath_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t _wsplitpath_s(const wchar_t *_FullPath, wchar_t *_Drive, size_t _DriveCount, wchar_t *_Dir, size_t _DirCount, wchar_t *_Filename, size_t _FilenameCount, wchar_t *_Ext, size_t _ExtCount)
     * }
     */
    public static MethodHandle _wsplitpath_s$handle() {
        return _wsplitpath_s.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * errno_t _wsplitpath_s(const wchar_t *_FullPath, wchar_t *_Drive, size_t _DriveCount, wchar_t *_Dir, size_t _DirCount, wchar_t *_Filename, size_t _FilenameCount, wchar_t *_Ext, size_t _ExtCount)
     * }
     */
    public static int _wsplitpath_s(MemorySegment _FullPath, MemorySegment _Drive, long _DriveCount, MemorySegment _Dir, long _DirCount, MemorySegment _Filename, long _FilenameCount, MemorySegment _Ext, long _ExtCount) {
        var mh$ = _wsplitpath_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wsplitpath_s", _FullPath, _Drive, _DriveCount, _Dir, _DirCount, _Filename, _FilenameCount, _Ext, _ExtCount);
            }
            return (int)mh$.invokeExact(_FullPath, _Drive, _DriveCount, _Dir, _DirCount, _Filename, _FilenameCount, _Ext, _ExtCount);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wdupenv_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("_wdupenv_s"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t _wdupenv_s(wchar_t **_Buffer, size_t *_BufferCount, const wchar_t *_VarName)
     * }
     */
    public static FunctionDescriptor _wdupenv_s$descriptor() {
        return _wdupenv_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t _wdupenv_s(wchar_t **_Buffer, size_t *_BufferCount, const wchar_t *_VarName)
     * }
     */
    public static MethodHandle _wdupenv_s$handle() {
        return _wdupenv_s.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * errno_t _wdupenv_s(wchar_t **_Buffer, size_t *_BufferCount, const wchar_t *_VarName)
     * }
     */
    public static int _wdupenv_s(MemorySegment _Buffer, MemorySegment _BufferCount, MemorySegment _VarName) {
        var mh$ = _wdupenv_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wdupenv_s", _Buffer, _BufferCount, _VarName);
            }
            return (int)mh$.invokeExact(_Buffer, _BufferCount, _VarName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wgetenv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("_wgetenv"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wchar_t *_wgetenv(const wchar_t *_VarName)
     * }
     */
    public static FunctionDescriptor _wgetenv$descriptor() {
        return _wgetenv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wchar_t *_wgetenv(const wchar_t *_VarName)
     * }
     */
    public static MethodHandle _wgetenv$handle() {
        return _wgetenv.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * wchar_t *_wgetenv(const wchar_t *_VarName)
     * }
     */
    public static MemorySegment _wgetenv(MemorySegment _VarName) {
        var mh$ = _wgetenv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wgetenv", _VarName);
            }
            return (MemorySegment)mh$.invokeExact(_VarName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wgetenv_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_LONG_LONG,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("_wgetenv_s"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t _wgetenv_s(size_t *_RequiredCount, wchar_t *_Buffer, size_t _BufferCount, const wchar_t *_VarName)
     * }
     */
    public static FunctionDescriptor _wgetenv_s$descriptor() {
        return _wgetenv_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t _wgetenv_s(size_t *_RequiredCount, wchar_t *_Buffer, size_t _BufferCount, const wchar_t *_VarName)
     * }
     */
    public static MethodHandle _wgetenv_s$handle() {
        return _wgetenv_s.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * errno_t _wgetenv_s(size_t *_RequiredCount, wchar_t *_Buffer, size_t _BufferCount, const wchar_t *_VarName)
     * }
     */
    public static int _wgetenv_s(MemorySegment _RequiredCount, MemorySegment _Buffer, long _BufferCount, MemorySegment _VarName) {
        var mh$ = _wgetenv_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wgetenv_s", _RequiredCount, _Buffer, _BufferCount, _VarName);
            }
            return (int)mh$.invokeExact(_RequiredCount, _Buffer, _BufferCount, _VarName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wputenv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("_wputenv"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _wputenv(const wchar_t *_EnvString)
     * }
     */
    public static FunctionDescriptor _wputenv$descriptor() {
        return _wputenv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _wputenv(const wchar_t *_EnvString)
     * }
     */
    public static MethodHandle _wputenv$handle() {
        return _wputenv.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int _wputenv(const wchar_t *_EnvString)
     * }
     */
    public static int _wputenv(MemorySegment _EnvString) {
        var mh$ = _wputenv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wputenv", _EnvString);
            }
            return (int)mh$.invokeExact(_EnvString);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wputenv_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("_wputenv_s"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t _wputenv_s(const wchar_t *_Name, const wchar_t *_Value)
     * }
     */
    public static FunctionDescriptor _wputenv_s$descriptor() {
        return _wputenv_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t _wputenv_s(const wchar_t *_Name, const wchar_t *_Value)
     * }
     */
    public static MethodHandle _wputenv_s$handle() {
        return _wputenv_s.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * errno_t _wputenv_s(const wchar_t *_Name, const wchar_t *_Value)
     * }
     */
    public static int _wputenv_s(MemorySegment _Name, MemorySegment _Value) {
        var mh$ = _wputenv_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wputenv_s", _Name, _Value);
            }
            return (int)mh$.invokeExact(_Name, _Value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wsearchenv_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_LONG_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("_wsearchenv_s"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t _wsearchenv_s(const wchar_t *_Filename, const wchar_t *_VarName, wchar_t *_Buffer, size_t _BufferCount)
     * }
     */
    public static FunctionDescriptor _wsearchenv_s$descriptor() {
        return _wsearchenv_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t _wsearchenv_s(const wchar_t *_Filename, const wchar_t *_VarName, wchar_t *_Buffer, size_t _BufferCount)
     * }
     */
    public static MethodHandle _wsearchenv_s$handle() {
        return _wsearchenv_s.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * errno_t _wsearchenv_s(const wchar_t *_Filename, const wchar_t *_VarName, wchar_t *_Buffer, size_t _BufferCount)
     * }
     */
    public static int _wsearchenv_s(MemorySegment _Filename, MemorySegment _VarName, MemorySegment _Buffer, long _BufferCount) {
        var mh$ = _wsearchenv_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wsearchenv_s", _Filename, _VarName, _Buffer, _BufferCount);
            }
            return (int)mh$.invokeExact(_Filename, _VarName, _Buffer, _BufferCount);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wsearchenv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("_wsearchenv"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void _wsearchenv(const wchar_t *_Filename, const wchar_t *_VarName, wchar_t *_ResultPath)
     * }
     */
    public static FunctionDescriptor _wsearchenv$descriptor() {
        return _wsearchenv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void _wsearchenv(const wchar_t *_Filename, const wchar_t *_VarName, wchar_t *_ResultPath)
     * }
     */
    public static MethodHandle _wsearchenv$handle() {
        return _wsearchenv.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * void _wsearchenv(const wchar_t *_Filename, const wchar_t *_VarName, wchar_t *_ResultPath)
     * }
     */
    public static void _wsearchenv(MemorySegment _Filename, MemorySegment _VarName, MemorySegment _ResultPath) {
        var mh$ = _wsearchenv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wsearchenv", _Filename, _VarName, _ResultPath);
            }
            mh$.invokeExact(_Filename, _VarName, _ResultPath);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wsystem {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("_wsystem"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _wsystem(const wchar_t *_Command)
     * }
     */
    public static FunctionDescriptor _wsystem$descriptor() {
        return _wsystem.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _wsystem(const wchar_t *_Command)
     * }
     */
    public static MethodHandle _wsystem$handle() {
        return _wsystem.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int _wsystem(const wchar_t *_Command)
     * }
     */
    public static int _wsystem(MemorySegment _Command) {
        var mh$ = _wsystem.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wsystem", _Command);
            }
            return (int)mh$.invokeExact(_Command);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _swab {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C_POINTER,
            C_POINTER,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("_swab"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void _swab(char *_Buf1, char *_Buf2, int _SizeInBytes)
     * }
     */
    public static FunctionDescriptor _swab$descriptor() {
        return _swab.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void _swab(char *_Buf1, char *_Buf2, int _SizeInBytes)
     * }
     */
    public static MethodHandle _swab$handle() {
        return _swab.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * void _swab(char *_Buf1, char *_Buf2, int _SizeInBytes)
     * }
     */
    public static void _swab(MemorySegment _Buf1, MemorySegment _Buf2, int _SizeInBytes) {
        var mh$ = _swab.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_swab", _Buf1, _Buf2, _SizeInBytes);
            }
            mh$.invokeExact(_Buf1, _Buf2, _SizeInBytes);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class exit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("exit"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void exit(int _Code)
     * }
     */
    public static FunctionDescriptor exit$descriptor() {
        return exit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void exit(int _Code)
     * }
     */
    public static MethodHandle exit$handle() {
        return exit.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * void exit(int _Code)
     * }
     */
    public static void exit(int _Code) {
        var mh$ = exit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("exit", _Code);
            }
            mh$.invokeExact(_Code);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _exit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("_exit"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void _exit(int _Code)
     * }
     */
    public static FunctionDescriptor _exit$descriptor() {
        return _exit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void _exit(int _Code)
     * }
     */
    public static MethodHandle _exit$handle() {
        return _exit.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * void _exit(int _Code)
     * }
     */
    public static void _exit(int _Code) {
        var mh$ = _exit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_exit", _Code);
            }
            mh$.invokeExact(_Code);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _Exit$ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("_Exit"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void _Exit(int _Code)
     * }
     */
    public static FunctionDescriptor _Exit$descriptor() {
        return _Exit$.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void _Exit(int _Code)
     * }
     */
    public static MethodHandle _Exit$handle() {
        return _Exit$.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * void _Exit(int _Code)
     * }
     */
    public static void _Exit(int _Code) {
        var mh$ = _Exit$.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_Exit", _Code);
            }
            mh$.invokeExact(_Code);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class quick_exit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("quick_exit"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void quick_exit(int _Code)
     * }
     */
    public static FunctionDescriptor quick_exit$descriptor() {
        return quick_exit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void quick_exit(int _Code)
     * }
     */
    public static MethodHandle quick_exit$handle() {
        return quick_exit.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * void quick_exit(int _Code)
     * }
     */
    public static void quick_exit(int _Code) {
        var mh$ = quick_exit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("quick_exit", _Code);
            }
            mh$.invokeExact(_Code);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class abort {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("abort"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void abort()
     * }
     */
    public static FunctionDescriptor abort$descriptor() {
        return abort.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void abort()
     * }
     */
    public static MethodHandle abort$handle() {
        return abort.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * void abort()
     * }
     */
    public static void abort() {
        var mh$ = abort.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("abort");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _set_abort_behavior {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_INT,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("_set_abort_behavior"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int _set_abort_behavior(unsigned int _Flags, unsigned int _Mask)
     * }
     */
    public static FunctionDescriptor _set_abort_behavior$descriptor() {
        return _set_abort_behavior.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int _set_abort_behavior(unsigned int _Flags, unsigned int _Mask)
     * }
     */
    public static MethodHandle _set_abort_behavior$handle() {
        return _set_abort_behavior.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * unsigned int _set_abort_behavior(unsigned int _Flags, unsigned int _Mask)
     * }
     */
    public static int _set_abort_behavior(int _Flags, int _Mask) {
        var mh$ = _set_abort_behavior.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_set_abort_behavior", _Flags, _Mask);
            }
            return (int)mh$.invokeExact(_Flags, _Mask);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class atexit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("atexit"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int atexit(void (*)(void) __attribute__((cdecl)))
     * }
     */
    public static FunctionDescriptor atexit$descriptor() {
        return atexit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int atexit(void (*)(void) __attribute__((cdecl)))
     * }
     */
    public static MethodHandle atexit$handle() {
        return atexit.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int atexit(void (*)(void) __attribute__((cdecl)))
     * }
     */
    public static int atexit(MemorySegment x0) {
        var mh$ = atexit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("atexit", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _onexit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("_onexit"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * _onexit_t _onexit(_onexit_t _Func)
     * }
     */
    public static FunctionDescriptor _onexit$descriptor() {
        return _onexit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * _onexit_t _onexit(_onexit_t _Func)
     * }
     */
    public static MethodHandle _onexit$handle() {
        return _onexit.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * _onexit_t _onexit(_onexit_t _Func)
     * }
     */
    public static MemorySegment _onexit(MemorySegment _Func) {
        var mh$ = _onexit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_onexit", _Func);
            }
            return (MemorySegment)mh$.invokeExact(_Func);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class at_quick_exit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("at_quick_exit"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int at_quick_exit(void (*)(void) __attribute__((cdecl)))
     * }
     */
    public static FunctionDescriptor at_quick_exit$descriptor() {
        return at_quick_exit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int at_quick_exit(void (*)(void) __attribute__((cdecl)))
     * }
     */
    public static MethodHandle at_quick_exit$handle() {
        return at_quick_exit.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int at_quick_exit(void (*)(void) __attribute__((cdecl)))
     * }
     */
    public static int at_quick_exit(MemorySegment x0) {
        var mh$ = at_quick_exit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("at_quick_exit", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _set_purecall_handler {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("_set_purecall_handler"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * _purecall_handler _set_purecall_handler(_purecall_handler _Handler)
     * }
     */
    public static FunctionDescriptor _set_purecall_handler$descriptor() {
        return _set_purecall_handler.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * _purecall_handler _set_purecall_handler(_purecall_handler _Handler)
     * }
     */
    public static MethodHandle _set_purecall_handler$handle() {
        return _set_purecall_handler.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * _purecall_handler _set_purecall_handler(_purecall_handler _Handler)
     * }
     */
    public static MemorySegment _set_purecall_handler(MemorySegment _Handler) {
        var mh$ = _set_purecall_handler.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_set_purecall_handler", _Handler);
            }
            return (MemorySegment)mh$.invokeExact(_Handler);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _get_purecall_handler {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER    );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("_get_purecall_handler"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * _purecall_handler _get_purecall_handler()
     * }
     */
    public static FunctionDescriptor _get_purecall_handler$descriptor() {
        return _get_purecall_handler.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * _purecall_handler _get_purecall_handler()
     * }
     */
    public static MethodHandle _get_purecall_handler$handle() {
        return _get_purecall_handler.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * _purecall_handler _get_purecall_handler()
     * }
     */
    public static MemorySegment _get_purecall_handler() {
        var mh$ = _get_purecall_handler.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_get_purecall_handler");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _set_invalid_parameter_handler {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("_set_invalid_parameter_handler"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * _invalid_parameter_handler _set_invalid_parameter_handler(_invalid_parameter_handler _Handler)
     * }
     */
    public static FunctionDescriptor _set_invalid_parameter_handler$descriptor() {
        return _set_invalid_parameter_handler.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * _invalid_parameter_handler _set_invalid_parameter_handler(_invalid_parameter_handler _Handler)
     * }
     */
    public static MethodHandle _set_invalid_parameter_handler$handle() {
        return _set_invalid_parameter_handler.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * _invalid_parameter_handler _set_invalid_parameter_handler(_invalid_parameter_handler _Handler)
     * }
     */
    public static MemorySegment _set_invalid_parameter_handler(MemorySegment _Handler) {
        var mh$ = _set_invalid_parameter_handler.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_set_invalid_parameter_handler", _Handler);
            }
            return (MemorySegment)mh$.invokeExact(_Handler);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _get_invalid_parameter_handler {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER    );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("_get_invalid_parameter_handler"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * _invalid_parameter_handler _get_invalid_parameter_handler()
     * }
     */
    public static FunctionDescriptor _get_invalid_parameter_handler$descriptor() {
        return _get_invalid_parameter_handler.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * _invalid_parameter_handler _get_invalid_parameter_handler()
     * }
     */
    public static MethodHandle _get_invalid_parameter_handler$handle() {
        return _get_invalid_parameter_handler.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * _invalid_parameter_handler _get_invalid_parameter_handler()
     * }
     */
    public static MemorySegment _get_invalid_parameter_handler() {
        var mh$ = _get_invalid_parameter_handler.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_get_invalid_parameter_handler");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _set_thread_local_invalid_parameter_handler {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("_set_thread_local_invalid_parameter_handler"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * _invalid_parameter_handler _set_thread_local_invalid_parameter_handler(_invalid_parameter_handler _Handler)
     * }
     */
    public static FunctionDescriptor _set_thread_local_invalid_parameter_handler$descriptor() {
        return _set_thread_local_invalid_parameter_handler.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * _invalid_parameter_handler _set_thread_local_invalid_parameter_handler(_invalid_parameter_handler _Handler)
     * }
     */
    public static MethodHandle _set_thread_local_invalid_parameter_handler$handle() {
        return _set_thread_local_invalid_parameter_handler.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * _invalid_parameter_handler _set_thread_local_invalid_parameter_handler(_invalid_parameter_handler _Handler)
     * }
     */
    public static MemorySegment _set_thread_local_invalid_parameter_handler(MemorySegment _Handler) {
        var mh$ = _set_thread_local_invalid_parameter_handler.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_set_thread_local_invalid_parameter_handler", _Handler);
            }
            return (MemorySegment)mh$.invokeExact(_Handler);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _get_thread_local_invalid_parameter_handler {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER    );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("_get_thread_local_invalid_parameter_handler"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * _invalid_parameter_handler _get_thread_local_invalid_parameter_handler()
     * }
     */
    public static FunctionDescriptor _get_thread_local_invalid_parameter_handler$descriptor() {
        return _get_thread_local_invalid_parameter_handler.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * _invalid_parameter_handler _get_thread_local_invalid_parameter_handler()
     * }
     */
    public static MethodHandle _get_thread_local_invalid_parameter_handler$handle() {
        return _get_thread_local_invalid_parameter_handler.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * _invalid_parameter_handler _get_thread_local_invalid_parameter_handler()
     * }
     */
    public static MemorySegment _get_thread_local_invalid_parameter_handler() {
        var mh$ = _get_thread_local_invalid_parameter_handler.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_get_thread_local_invalid_parameter_handler");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _set_error_mode {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("_set_error_mode"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _set_error_mode(int _Mode)
     * }
     */
    public static FunctionDescriptor _set_error_mode$descriptor() {
        return _set_error_mode.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _set_error_mode(int _Mode)
     * }
     */
    public static MethodHandle _set_error_mode$handle() {
        return _set_error_mode.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int _set_error_mode(int _Mode)
     * }
     */
    public static int _set_error_mode(int _Mode) {
        var mh$ = _set_error_mode.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_set_error_mode", _Mode);
            }
            return (int)mh$.invokeExact(_Mode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _errno {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER    );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("_errno"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int *_errno()
     * }
     */
    public static FunctionDescriptor _errno$descriptor() {
        return _errno.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int *_errno()
     * }
     */
    public static MethodHandle _errno$handle() {
        return _errno.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int *_errno()
     * }
     */
    public static MemorySegment _errno() {
        var mh$ = _errno.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_errno");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _set_errno {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("_set_errno"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t _set_errno(int _Value)
     * }
     */
    public static FunctionDescriptor _set_errno$descriptor() {
        return _set_errno.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t _set_errno(int _Value)
     * }
     */
    public static MethodHandle _set_errno$handle() {
        return _set_errno.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * errno_t _set_errno(int _Value)
     * }
     */
    public static int _set_errno(int _Value) {
        var mh$ = _set_errno.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_set_errno", _Value);
            }
            return (int)mh$.invokeExact(_Value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _get_errno {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("_get_errno"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t _get_errno(int *_Value)
     * }
     */
    public static FunctionDescriptor _get_errno$descriptor() {
        return _get_errno.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t _get_errno(int *_Value)
     * }
     */
    public static MethodHandle _get_errno$handle() {
        return _get_errno.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * errno_t _get_errno(int *_Value)
     * }
     */
    public static int _get_errno(MemorySegment _Value) {
        var mh$ = _get_errno.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_get_errno", _Value);
            }
            return (int)mh$.invokeExact(_Value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __doserrno {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER    );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("__doserrno"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned long *__doserrno()
     * }
     */
    public static FunctionDescriptor __doserrno$descriptor() {
        return __doserrno.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned long *__doserrno()
     * }
     */
    public static MethodHandle __doserrno$handle() {
        return __doserrno.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * unsigned long *__doserrno()
     * }
     */
    public static MemorySegment __doserrno() {
        var mh$ = __doserrno.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__doserrno");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _set_doserrno {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("_set_doserrno"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t _set_doserrno(unsigned long _Value)
     * }
     */
    public static FunctionDescriptor _set_doserrno$descriptor() {
        return _set_doserrno.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t _set_doserrno(unsigned long _Value)
     * }
     */
    public static MethodHandle _set_doserrno$handle() {
        return _set_doserrno.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * errno_t _set_doserrno(unsigned long _Value)
     * }
     */
    public static int _set_doserrno(int _Value) {
        var mh$ = _set_doserrno.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_set_doserrno", _Value);
            }
            return (int)mh$.invokeExact(_Value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _get_doserrno {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("_get_doserrno"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t _get_doserrno(unsigned long *_Value)
     * }
     */
    public static FunctionDescriptor _get_doserrno$descriptor() {
        return _get_doserrno.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t _get_doserrno(unsigned long *_Value)
     * }
     */
    public static MethodHandle _get_doserrno$handle() {
        return _get_doserrno.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * errno_t _get_doserrno(unsigned long *_Value)
     * }
     */
    public static int _get_doserrno(MemorySegment _Value) {
        var mh$ = _get_doserrno.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_get_doserrno", _Value);
            }
            return (int)mh$.invokeExact(_Value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __sys_errlist {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER    );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("__sys_errlist"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char **__sys_errlist()
     * }
     */
    public static FunctionDescriptor __sys_errlist$descriptor() {
        return __sys_errlist.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char **__sys_errlist()
     * }
     */
    public static MethodHandle __sys_errlist$handle() {
        return __sys_errlist.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * char **__sys_errlist()
     * }
     */
    public static MemorySegment __sys_errlist() {
        var mh$ = __sys_errlist.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__sys_errlist");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __sys_nerr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER    );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("__sys_nerr"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int *__sys_nerr()
     * }
     */
    public static FunctionDescriptor __sys_nerr$descriptor() {
        return __sys_nerr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int *__sys_nerr()
     * }
     */
    public static MethodHandle __sys_nerr$handle() {
        return __sys_nerr.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int *__sys_nerr()
     * }
     */
    public static MemorySegment __sys_nerr() {
        var mh$ = __sys_nerr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__sys_nerr");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class perror {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("perror"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void perror(const char *_ErrMsg)
     * }
     */
    public static FunctionDescriptor perror$descriptor() {
        return perror.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void perror(const char *_ErrMsg)
     * }
     */
    public static MethodHandle perror$handle() {
        return perror.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * void perror(const char *_ErrMsg)
     * }
     */
    public static void perror(MemorySegment _ErrMsg) {
        var mh$ = perror.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("perror", _ErrMsg);
            }
            mh$.invokeExact(_ErrMsg);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __p__pgmptr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER    );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("__p__pgmptr"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char **__p__pgmptr()
     * }
     */
    public static FunctionDescriptor __p__pgmptr$descriptor() {
        return __p__pgmptr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char **__p__pgmptr()
     * }
     */
    public static MethodHandle __p__pgmptr$handle() {
        return __p__pgmptr.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * char **__p__pgmptr()
     * }
     */
    public static MemorySegment __p__pgmptr() {
        var mh$ = __p__pgmptr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__p__pgmptr");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __p__wpgmptr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER    );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("__p__wpgmptr"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wchar_t **__p__wpgmptr()
     * }
     */
    public static FunctionDescriptor __p__wpgmptr$descriptor() {
        return __p__wpgmptr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wchar_t **__p__wpgmptr()
     * }
     */
    public static MethodHandle __p__wpgmptr$handle() {
        return __p__wpgmptr.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * wchar_t **__p__wpgmptr()
     * }
     */
    public static MemorySegment __p__wpgmptr() {
        var mh$ = __p__wpgmptr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__p__wpgmptr");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __p__fmode {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER    );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("__p__fmode"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int *__p__fmode()
     * }
     */
    public static FunctionDescriptor __p__fmode$descriptor() {
        return __p__fmode.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int *__p__fmode()
     * }
     */
    public static MethodHandle __p__fmode$handle() {
        return __p__fmode.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int *__p__fmode()
     * }
     */
    public static MemorySegment __p__fmode() {
        var mh$ = __p__fmode.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__p__fmode");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _get_pgmptr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("_get_pgmptr"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t _get_pgmptr(char **_Value)
     * }
     */
    public static FunctionDescriptor _get_pgmptr$descriptor() {
        return _get_pgmptr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t _get_pgmptr(char **_Value)
     * }
     */
    public static MethodHandle _get_pgmptr$handle() {
        return _get_pgmptr.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * errno_t _get_pgmptr(char **_Value)
     * }
     */
    public static int _get_pgmptr(MemorySegment _Value) {
        var mh$ = _get_pgmptr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_get_pgmptr", _Value);
            }
            return (int)mh$.invokeExact(_Value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _get_wpgmptr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("_get_wpgmptr"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t _get_wpgmptr(wchar_t **_Value)
     * }
     */
    public static FunctionDescriptor _get_wpgmptr$descriptor() {
        return _get_wpgmptr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t _get_wpgmptr(wchar_t **_Value)
     * }
     */
    public static MethodHandle _get_wpgmptr$handle() {
        return _get_wpgmptr.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * errno_t _get_wpgmptr(wchar_t **_Value)
     * }
     */
    public static int _get_wpgmptr(MemorySegment _Value) {
        var mh$ = _get_wpgmptr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_get_wpgmptr", _Value);
            }
            return (int)mh$.invokeExact(_Value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _set_fmode {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("_set_fmode"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t _set_fmode(int _Mode)
     * }
     */
    public static FunctionDescriptor _set_fmode$descriptor() {
        return _set_fmode.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t _set_fmode(int _Mode)
     * }
     */
    public static MethodHandle _set_fmode$handle() {
        return _set_fmode.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * errno_t _set_fmode(int _Mode)
     * }
     */
    public static int _set_fmode(int _Mode) {
        var mh$ = _set_fmode.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_set_fmode", _Mode);
            }
            return (int)mh$.invokeExact(_Mode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _get_fmode {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("_get_fmode"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t _get_fmode(int *_PMode)
     * }
     */
    public static FunctionDescriptor _get_fmode$descriptor() {
        return _get_fmode.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t _get_fmode(int *_PMode)
     * }
     */
    public static MethodHandle _get_fmode$handle() {
        return _get_fmode.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * errno_t _get_fmode(int *_PMode)
     * }
     */
    public static int _get_fmode(MemorySegment _PMode) {
        var mh$ = _get_fmode.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_get_fmode", _PMode);
            }
            return (int)mh$.invokeExact(_PMode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class abs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("abs"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int abs(int _Number)
     * }
     */
    public static FunctionDescriptor abs$descriptor() {
        return abs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int abs(int _Number)
     * }
     */
    public static MethodHandle abs$handle() {
        return abs.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int abs(int _Number)
     * }
     */
    public static int abs(int _Number) {
        var mh$ = abs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("abs", _Number);
            }
            return (int)mh$.invokeExact(_Number);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class labs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("labs"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long labs(long _Number)
     * }
     */
    public static FunctionDescriptor labs$descriptor() {
        return labs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long labs(long _Number)
     * }
     */
    public static MethodHandle labs$handle() {
        return labs.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * long labs(long _Number)
     * }
     */
    public static int labs(int _Number) {
        var mh$ = labs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("labs", _Number);
            }
            return (int)mh$.invokeExact(_Number);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class llabs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG_LONG,
            C_LONG_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("llabs"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long long llabs(long long _Number)
     * }
     */
    public static FunctionDescriptor llabs$descriptor() {
        return llabs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long long llabs(long long _Number)
     * }
     */
    public static MethodHandle llabs$handle() {
        return llabs.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * long long llabs(long long _Number)
     * }
     */
    public static long llabs(long _Number) {
        var mh$ = llabs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("llabs", _Number);
            }
            return (long)mh$.invokeExact(_Number);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _abs64 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG_LONG,
            C_LONG_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("_abs64"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long long _abs64(long long _Number)
     * }
     */
    public static FunctionDescriptor _abs64$descriptor() {
        return _abs64.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long long _abs64(long long _Number)
     * }
     */
    public static MethodHandle _abs64$handle() {
        return _abs64.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * long long _abs64(long long _Number)
     * }
     */
    public static long _abs64(long _Number) {
        var mh$ = _abs64.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_abs64", _Number);
            }
            return (long)mh$.invokeExact(_Number);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _byteswap_ushort {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_SHORT,
            C_SHORT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("_byteswap_ushort"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned short _byteswap_ushort(unsigned short _Number)
     * }
     */
    public static FunctionDescriptor _byteswap_ushort$descriptor() {
        return _byteswap_ushort.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned short _byteswap_ushort(unsigned short _Number)
     * }
     */
    public static MethodHandle _byteswap_ushort$handle() {
        return _byteswap_ushort.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * unsigned short _byteswap_ushort(unsigned short _Number)
     * }
     */
    public static short _byteswap_ushort(short _Number) {
        var mh$ = _byteswap_ushort.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_byteswap_ushort", _Number);
            }
            return (short)mh$.invokeExact(_Number);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _byteswap_ulong {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("_byteswap_ulong"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned long _byteswap_ulong(unsigned long _Number)
     * }
     */
    public static FunctionDescriptor _byteswap_ulong$descriptor() {
        return _byteswap_ulong.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned long _byteswap_ulong(unsigned long _Number)
     * }
     */
    public static MethodHandle _byteswap_ulong$handle() {
        return _byteswap_ulong.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * unsigned long _byteswap_ulong(unsigned long _Number)
     * }
     */
    public static int _byteswap_ulong(int _Number) {
        var mh$ = _byteswap_ulong.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_byteswap_ulong", _Number);
            }
            return (int)mh$.invokeExact(_Number);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _byteswap_uint64 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG_LONG,
            C_LONG_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("_byteswap_uint64"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned long long _byteswap_uint64(unsigned long long _Number)
     * }
     */
    public static FunctionDescriptor _byteswap_uint64$descriptor() {
        return _byteswap_uint64.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned long long _byteswap_uint64(unsigned long long _Number)
     * }
     */
    public static MethodHandle _byteswap_uint64$handle() {
        return _byteswap_uint64.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * unsigned long long _byteswap_uint64(unsigned long long _Number)
     * }
     */
    public static long _byteswap_uint64(long _Number) {
        var mh$ = _byteswap_uint64.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_byteswap_uint64", _Number);
            }
            return (long)mh$.invokeExact(_Number);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class div {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            _div_t.layout(),
            C_INT,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("div"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * div_t div(int _Numerator, int _Denominator)
     * }
     */
    public static FunctionDescriptor div$descriptor() {
        return div.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * div_t div(int _Numerator, int _Denominator)
     * }
     */
    public static MethodHandle div$handle() {
        return div.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * div_t div(int _Numerator, int _Denominator)
     * }
     */
    public static MemorySegment div(SegmentAllocator allocator, int _Numerator, int _Denominator) {
        var mh$ = div.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("div", allocator, _Numerator, _Denominator);
            }
            return (MemorySegment)mh$.invokeExact(allocator, _Numerator, _Denominator);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ldiv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            _ldiv_t.layout(),
            C_LONG,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("ldiv"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ldiv_t ldiv(long _Numerator, long _Denominator)
     * }
     */
    public static FunctionDescriptor ldiv$descriptor() {
        return ldiv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ldiv_t ldiv(long _Numerator, long _Denominator)
     * }
     */
    public static MethodHandle ldiv$handle() {
        return ldiv.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * ldiv_t ldiv(long _Numerator, long _Denominator)
     * }
     */
    public static MemorySegment ldiv(SegmentAllocator allocator, int _Numerator, int _Denominator) {
        var mh$ = ldiv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ldiv", allocator, _Numerator, _Denominator);
            }
            return (MemorySegment)mh$.invokeExact(allocator, _Numerator, _Denominator);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lldiv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            _lldiv_t.layout(),
            C_LONG_LONG,
            C_LONG_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("lldiv"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * lldiv_t lldiv(long long _Numerator, long long _Denominator)
     * }
     */
    public static FunctionDescriptor lldiv$descriptor() {
        return lldiv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * lldiv_t lldiv(long long _Numerator, long long _Denominator)
     * }
     */
    public static MethodHandle lldiv$handle() {
        return lldiv.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * lldiv_t lldiv(long long _Numerator, long long _Denominator)
     * }
     */
    public static MemorySegment lldiv(SegmentAllocator allocator, long _Numerator, long _Denominator) {
        var mh$ = lldiv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lldiv", allocator, _Numerator, _Denominator);
            }
            return (MemorySegment)mh$.invokeExact(allocator, _Numerator, _Denominator);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _rotl {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_INT,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("_rotl"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int _rotl(unsigned int _Value, int _Shift)
     * }
     */
    public static FunctionDescriptor _rotl$descriptor() {
        return _rotl.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int _rotl(unsigned int _Value, int _Shift)
     * }
     */
    public static MethodHandle _rotl$handle() {
        return _rotl.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * unsigned int _rotl(unsigned int _Value, int _Shift)
     * }
     */
    public static int _rotl(int _Value, int _Shift) {
        var mh$ = _rotl.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_rotl", _Value, _Shift);
            }
            return (int)mh$.invokeExact(_Value, _Shift);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _lrotl {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_LONG,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("_lrotl"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned long _lrotl(unsigned long _Value, int _Shift)
     * }
     */
    public static FunctionDescriptor _lrotl$descriptor() {
        return _lrotl.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned long _lrotl(unsigned long _Value, int _Shift)
     * }
     */
    public static MethodHandle _lrotl$handle() {
        return _lrotl.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * unsigned long _lrotl(unsigned long _Value, int _Shift)
     * }
     */
    public static int _lrotl(int _Value, int _Shift) {
        var mh$ = _lrotl.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_lrotl", _Value, _Shift);
            }
            return (int)mh$.invokeExact(_Value, _Shift);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _rotl64 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG_LONG,
            C_LONG_LONG,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("_rotl64"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned long long _rotl64(unsigned long long _Value, int _Shift)
     * }
     */
    public static FunctionDescriptor _rotl64$descriptor() {
        return _rotl64.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned long long _rotl64(unsigned long long _Value, int _Shift)
     * }
     */
    public static MethodHandle _rotl64$handle() {
        return _rotl64.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * unsigned long long _rotl64(unsigned long long _Value, int _Shift)
     * }
     */
    public static long _rotl64(long _Value, int _Shift) {
        var mh$ = _rotl64.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_rotl64", _Value, _Shift);
            }
            return (long)mh$.invokeExact(_Value, _Shift);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _rotr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_INT,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("_rotr"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int _rotr(unsigned int _Value, int _Shift)
     * }
     */
    public static FunctionDescriptor _rotr$descriptor() {
        return _rotr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int _rotr(unsigned int _Value, int _Shift)
     * }
     */
    public static MethodHandle _rotr$handle() {
        return _rotr.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * unsigned int _rotr(unsigned int _Value, int _Shift)
     * }
     */
    public static int _rotr(int _Value, int _Shift) {
        var mh$ = _rotr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_rotr", _Value, _Shift);
            }
            return (int)mh$.invokeExact(_Value, _Shift);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _lrotr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_LONG,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("_lrotr"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned long _lrotr(unsigned long _Value, int _Shift)
     * }
     */
    public static FunctionDescriptor _lrotr$descriptor() {
        return _lrotr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned long _lrotr(unsigned long _Value, int _Shift)
     * }
     */
    public static MethodHandle _lrotr$handle() {
        return _lrotr.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * unsigned long _lrotr(unsigned long _Value, int _Shift)
     * }
     */
    public static int _lrotr(int _Value, int _Shift) {
        var mh$ = _lrotr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_lrotr", _Value, _Shift);
            }
            return (int)mh$.invokeExact(_Value, _Shift);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _rotr64 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG_LONG,
            C_LONG_LONG,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("_rotr64"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned long long _rotr64(unsigned long long _Value, int _Shift)
     * }
     */
    public static FunctionDescriptor _rotr64$descriptor() {
        return _rotr64.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned long long _rotr64(unsigned long long _Value, int _Shift)
     * }
     */
    public static MethodHandle _rotr64$handle() {
        return _rotr64.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * unsigned long long _rotr64(unsigned long long _Value, int _Shift)
     * }
     */
    public static long _rotr64(long _Value, int _Shift) {
        var mh$ = _rotr64.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_rotr64", _Value, _Shift);
            }
            return (long)mh$.invokeExact(_Value, _Shift);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class srand {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("srand"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void srand(unsigned int _Seed)
     * }
     */
    public static FunctionDescriptor srand$descriptor() {
        return srand.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void srand(unsigned int _Seed)
     * }
     */
    public static MethodHandle srand$handle() {
        return srand.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * void srand(unsigned int _Seed)
     * }
     */
    public static void srand(int _Seed) {
        var mh$ = srand.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("srand", _Seed);
            }
            mh$.invokeExact(_Seed);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rand {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT    );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("rand"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int rand()
     * }
     */
    public static FunctionDescriptor rand$descriptor() {
        return rand.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int rand()
     * }
     */
    public static MethodHandle rand$handle() {
        return rand.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int rand()
     * }
     */
    public static int rand() {
        var mh$ = rand.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rand");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class atof {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_DOUBLE,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("atof"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double atof(const char *_String)
     * }
     */
    public static FunctionDescriptor atof$descriptor() {
        return atof.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double atof(const char *_String)
     * }
     */
    public static MethodHandle atof$handle() {
        return atof.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * double atof(const char *_String)
     * }
     */
    public static double atof(MemorySegment _String) {
        var mh$ = atof.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("atof", _String);
            }
            return (double)mh$.invokeExact(_String);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class atoi {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("atoi"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int atoi(const char *_String)
     * }
     */
    public static FunctionDescriptor atoi$descriptor() {
        return atoi.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int atoi(const char *_String)
     * }
     */
    public static MethodHandle atoi$handle() {
        return atoi.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int atoi(const char *_String)
     * }
     */
    public static int atoi(MemorySegment _String) {
        var mh$ = atoi.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("atoi", _String);
            }
            return (int)mh$.invokeExact(_String);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class atol {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("atol"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long atol(const char *_String)
     * }
     */
    public static FunctionDescriptor atol$descriptor() {
        return atol.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long atol(const char *_String)
     * }
     */
    public static MethodHandle atol$handle() {
        return atol.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * long atol(const char *_String)
     * }
     */
    public static int atol(MemorySegment _String) {
        var mh$ = atol.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("atol", _String);
            }
            return (int)mh$.invokeExact(_String);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class atoll {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG_LONG,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("atoll"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long long atoll(const char *_String)
     * }
     */
    public static FunctionDescriptor atoll$descriptor() {
        return atoll.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long long atoll(const char *_String)
     * }
     */
    public static MethodHandle atoll$handle() {
        return atoll.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * long long atoll(const char *_String)
     * }
     */
    public static long atoll(MemorySegment _String) {
        var mh$ = atoll.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("atoll", _String);
            }
            return (long)mh$.invokeExact(_String);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _atoi64 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG_LONG,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("_atoi64"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long long _atoi64(const char *_String)
     * }
     */
    public static FunctionDescriptor _atoi64$descriptor() {
        return _atoi64.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long long _atoi64(const char *_String)
     * }
     */
    public static MethodHandle _atoi64$handle() {
        return _atoi64.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * long long _atoi64(const char *_String)
     * }
     */
    public static long _atoi64(MemorySegment _String) {
        var mh$ = _atoi64.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_atoi64", _String);
            }
            return (long)mh$.invokeExact(_String);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _atof_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_DOUBLE,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("_atof_l"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double _atof_l(const char *_String, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _atof_l$descriptor() {
        return _atof_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double _atof_l(const char *_String, _locale_t _Locale)
     * }
     */
    public static MethodHandle _atof_l$handle() {
        return _atof_l.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * double _atof_l(const char *_String, _locale_t _Locale)
     * }
     */
    public static double _atof_l(MemorySegment _String, MemorySegment _Locale) {
        var mh$ = _atof_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_atof_l", _String, _Locale);
            }
            return (double)mh$.invokeExact(_String, _Locale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _atoi_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("_atoi_l"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _atoi_l(const char *_String, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _atoi_l$descriptor() {
        return _atoi_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _atoi_l(const char *_String, _locale_t _Locale)
     * }
     */
    public static MethodHandle _atoi_l$handle() {
        return _atoi_l.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int _atoi_l(const char *_String, _locale_t _Locale)
     * }
     */
    public static int _atoi_l(MemorySegment _String, MemorySegment _Locale) {
        var mh$ = _atoi_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_atoi_l", _String, _Locale);
            }
            return (int)mh$.invokeExact(_String, _Locale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _atol_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("_atol_l"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long _atol_l(const char *_String, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _atol_l$descriptor() {
        return _atol_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long _atol_l(const char *_String, _locale_t _Locale)
     * }
     */
    public static MethodHandle _atol_l$handle() {
        return _atol_l.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * long _atol_l(const char *_String, _locale_t _Locale)
     * }
     */
    public static int _atol_l(MemorySegment _String, MemorySegment _Locale) {
        var mh$ = _atol_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_atol_l", _String, _Locale);
            }
            return (int)mh$.invokeExact(_String, _Locale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _atoll_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG_LONG,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("_atoll_l"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long long _atoll_l(const char *_String, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _atoll_l$descriptor() {
        return _atoll_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long long _atoll_l(const char *_String, _locale_t _Locale)
     * }
     */
    public static MethodHandle _atoll_l$handle() {
        return _atoll_l.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * long long _atoll_l(const char *_String, _locale_t _Locale)
     * }
     */
    public static long _atoll_l(MemorySegment _String, MemorySegment _Locale) {
        var mh$ = _atoll_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_atoll_l", _String, _Locale);
            }
            return (long)mh$.invokeExact(_String, _Locale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _atoi64_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG_LONG,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("_atoi64_l"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long long _atoi64_l(const char *_String, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _atoi64_l$descriptor() {
        return _atoi64_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long long _atoi64_l(const char *_String, _locale_t _Locale)
     * }
     */
    public static MethodHandle _atoi64_l$handle() {
        return _atoi64_l.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * long long _atoi64_l(const char *_String, _locale_t _Locale)
     * }
     */
    public static long _atoi64_l(MemorySegment _String, MemorySegment _Locale) {
        var mh$ = _atoi64_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_atoi64_l", _String, _Locale);
            }
            return (long)mh$.invokeExact(_String, _Locale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _atoflt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("_atoflt"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _atoflt(_CRT_FLOAT *_Result, const char *_String)
     * }
     */
    public static FunctionDescriptor _atoflt$descriptor() {
        return _atoflt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _atoflt(_CRT_FLOAT *_Result, const char *_String)
     * }
     */
    public static MethodHandle _atoflt$handle() {
        return _atoflt.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int _atoflt(_CRT_FLOAT *_Result, const char *_String)
     * }
     */
    public static int _atoflt(MemorySegment _Result, MemorySegment _String) {
        var mh$ = _atoflt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_atoflt", _Result, _String);
            }
            return (int)mh$.invokeExact(_Result, _String);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _atodbl {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("_atodbl"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _atodbl(_CRT_DOUBLE *_Result, char *_String)
     * }
     */
    public static FunctionDescriptor _atodbl$descriptor() {
        return _atodbl.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _atodbl(_CRT_DOUBLE *_Result, char *_String)
     * }
     */
    public static MethodHandle _atodbl$handle() {
        return _atodbl.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int _atodbl(_CRT_DOUBLE *_Result, char *_String)
     * }
     */
    public static int _atodbl(MemorySegment _Result, MemorySegment _String) {
        var mh$ = _atodbl.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_atodbl", _Result, _String);
            }
            return (int)mh$.invokeExact(_Result, _String);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _atoldbl {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("_atoldbl"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _atoldbl(_LDOUBLE *_Result, char *_String)
     * }
     */
    public static FunctionDescriptor _atoldbl$descriptor() {
        return _atoldbl.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _atoldbl(_LDOUBLE *_Result, char *_String)
     * }
     */
    public static MethodHandle _atoldbl$handle() {
        return _atoldbl.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int _atoldbl(_LDOUBLE *_Result, char *_String)
     * }
     */
    public static int _atoldbl(MemorySegment _Result, MemorySegment _String) {
        var mh$ = _atoldbl.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_atoldbl", _Result, _String);
            }
            return (int)mh$.invokeExact(_Result, _String);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _atoflt_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("_atoflt_l"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _atoflt_l(_CRT_FLOAT *_Result, const char *_String, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _atoflt_l$descriptor() {
        return _atoflt_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _atoflt_l(_CRT_FLOAT *_Result, const char *_String, _locale_t _Locale)
     * }
     */
    public static MethodHandle _atoflt_l$handle() {
        return _atoflt_l.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int _atoflt_l(_CRT_FLOAT *_Result, const char *_String, _locale_t _Locale)
     * }
     */
    public static int _atoflt_l(MemorySegment _Result, MemorySegment _String, MemorySegment _Locale) {
        var mh$ = _atoflt_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_atoflt_l", _Result, _String, _Locale);
            }
            return (int)mh$.invokeExact(_Result, _String, _Locale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _atodbl_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("_atodbl_l"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _atodbl_l(_CRT_DOUBLE *_Result, char *_String, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _atodbl_l$descriptor() {
        return _atodbl_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _atodbl_l(_CRT_DOUBLE *_Result, char *_String, _locale_t _Locale)
     * }
     */
    public static MethodHandle _atodbl_l$handle() {
        return _atodbl_l.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int _atodbl_l(_CRT_DOUBLE *_Result, char *_String, _locale_t _Locale)
     * }
     */
    public static int _atodbl_l(MemorySegment _Result, MemorySegment _String, MemorySegment _Locale) {
        var mh$ = _atodbl_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_atodbl_l", _Result, _String, _Locale);
            }
            return (int)mh$.invokeExact(_Result, _String, _Locale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _atoldbl_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("_atoldbl_l"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _atoldbl_l(_LDOUBLE *_Result, char *_String, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _atoldbl_l$descriptor() {
        return _atoldbl_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _atoldbl_l(_LDOUBLE *_Result, char *_String, _locale_t _Locale)
     * }
     */
    public static MethodHandle _atoldbl_l$handle() {
        return _atoldbl_l.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int _atoldbl_l(_LDOUBLE *_Result, char *_String, _locale_t _Locale)
     * }
     */
    public static int _atoldbl_l(MemorySegment _Result, MemorySegment _String, MemorySegment _Locale) {
        var mh$ = _atoldbl_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_atoldbl_l", _Result, _String, _Locale);
            }
            return (int)mh$.invokeExact(_Result, _String, _Locale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strtof {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_FLOAT,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("strtof"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float strtof(const char *_String, char **_EndPtr)
     * }
     */
    public static FunctionDescriptor strtof$descriptor() {
        return strtof.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float strtof(const char *_String, char **_EndPtr)
     * }
     */
    public static MethodHandle strtof$handle() {
        return strtof.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * float strtof(const char *_String, char **_EndPtr)
     * }
     */
    public static float strtof(MemorySegment _String, MemorySegment _EndPtr) {
        var mh$ = strtof.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strtof", _String, _EndPtr);
            }
            return (float)mh$.invokeExact(_String, _EndPtr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _strtof_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_FLOAT,
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("_strtof_l"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float _strtof_l(const char *_String, char **_EndPtr, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _strtof_l$descriptor() {
        return _strtof_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float _strtof_l(const char *_String, char **_EndPtr, _locale_t _Locale)
     * }
     */
    public static MethodHandle _strtof_l$handle() {
        return _strtof_l.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * float _strtof_l(const char *_String, char **_EndPtr, _locale_t _Locale)
     * }
     */
    public static float _strtof_l(MemorySegment _String, MemorySegment _EndPtr, MemorySegment _Locale) {
        var mh$ = _strtof_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_strtof_l", _String, _EndPtr, _Locale);
            }
            return (float)mh$.invokeExact(_String, _EndPtr, _Locale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strtod {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_DOUBLE,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("strtod"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double strtod(const char *_String, char **_EndPtr)
     * }
     */
    public static FunctionDescriptor strtod$descriptor() {
        return strtod.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double strtod(const char *_String, char **_EndPtr)
     * }
     */
    public static MethodHandle strtod$handle() {
        return strtod.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * double strtod(const char *_String, char **_EndPtr)
     * }
     */
    public static double strtod(MemorySegment _String, MemorySegment _EndPtr) {
        var mh$ = strtod.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strtod", _String, _EndPtr);
            }
            return (double)mh$.invokeExact(_String, _EndPtr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _strtod_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_DOUBLE,
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("_strtod_l"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double _strtod_l(const char *_String, char **_EndPtr, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _strtod_l$descriptor() {
        return _strtod_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double _strtod_l(const char *_String, char **_EndPtr, _locale_t _Locale)
     * }
     */
    public static MethodHandle _strtod_l$handle() {
        return _strtod_l.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * double _strtod_l(const char *_String, char **_EndPtr, _locale_t _Locale)
     * }
     */
    public static double _strtod_l(MemorySegment _String, MemorySegment _EndPtr, MemorySegment _Locale) {
        var mh$ = _strtod_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_strtod_l", _String, _EndPtr, _Locale);
            }
            return (double)mh$.invokeExact(_String, _EndPtr, _Locale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strtold {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG_DOUBLE,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("strtold"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long double strtold(const char *_String, char **_EndPtr)
     * }
     */
    public static FunctionDescriptor strtold$descriptor() {
        return strtold.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long double strtold(const char *_String, char **_EndPtr)
     * }
     */
    public static MethodHandle strtold$handle() {
        return strtold.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * long double strtold(const char *_String, char **_EndPtr)
     * }
     */
    public static double strtold(MemorySegment _String, MemorySegment _EndPtr) {
        var mh$ = strtold.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strtold", _String, _EndPtr);
            }
            return (double)mh$.invokeExact(_String, _EndPtr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _strtold_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG_DOUBLE,
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("_strtold_l"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long double _strtold_l(const char *_String, char **_EndPtr, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _strtold_l$descriptor() {
        return _strtold_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long double _strtold_l(const char *_String, char **_EndPtr, _locale_t _Locale)
     * }
     */
    public static MethodHandle _strtold_l$handle() {
        return _strtold_l.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * long double _strtold_l(const char *_String, char **_EndPtr, _locale_t _Locale)
     * }
     */
    public static double _strtold_l(MemorySegment _String, MemorySegment _EndPtr, MemorySegment _Locale) {
        var mh$ = _strtold_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_strtold_l", _String, _EndPtr, _Locale);
            }
            return (double)mh$.invokeExact(_String, _EndPtr, _Locale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strtol {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_POINTER,
            C_POINTER,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("strtol"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long strtol(const char *_String, char **_EndPtr, int _Radix)
     * }
     */
    public static FunctionDescriptor strtol$descriptor() {
        return strtol.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long strtol(const char *_String, char **_EndPtr, int _Radix)
     * }
     */
    public static MethodHandle strtol$handle() {
        return strtol.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * long strtol(const char *_String, char **_EndPtr, int _Radix)
     * }
     */
    public static int strtol(MemorySegment _String, MemorySegment _EndPtr, int _Radix) {
        var mh$ = strtol.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strtol", _String, _EndPtr, _Radix);
            }
            return (int)mh$.invokeExact(_String, _EndPtr, _Radix);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _strtol_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_POINTER,
            C_POINTER,
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("_strtol_l"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long _strtol_l(const char *_String, char **_EndPtr, int _Radix, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _strtol_l$descriptor() {
        return _strtol_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long _strtol_l(const char *_String, char **_EndPtr, int _Radix, _locale_t _Locale)
     * }
     */
    public static MethodHandle _strtol_l$handle() {
        return _strtol_l.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * long _strtol_l(const char *_String, char **_EndPtr, int _Radix, _locale_t _Locale)
     * }
     */
    public static int _strtol_l(MemorySegment _String, MemorySegment _EndPtr, int _Radix, MemorySegment _Locale) {
        var mh$ = _strtol_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_strtol_l", _String, _EndPtr, _Radix, _Locale);
            }
            return (int)mh$.invokeExact(_String, _EndPtr, _Radix, _Locale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strtoll {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG_LONG,
            C_POINTER,
            C_POINTER,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("strtoll"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long long strtoll(const char *_String, char **_EndPtr, int _Radix)
     * }
     */
    public static FunctionDescriptor strtoll$descriptor() {
        return strtoll.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long long strtoll(const char *_String, char **_EndPtr, int _Radix)
     * }
     */
    public static MethodHandle strtoll$handle() {
        return strtoll.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * long long strtoll(const char *_String, char **_EndPtr, int _Radix)
     * }
     */
    public static long strtoll(MemorySegment _String, MemorySegment _EndPtr, int _Radix) {
        var mh$ = strtoll.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strtoll", _String, _EndPtr, _Radix);
            }
            return (long)mh$.invokeExact(_String, _EndPtr, _Radix);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _strtoll_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG_LONG,
            C_POINTER,
            C_POINTER,
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("_strtoll_l"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long long _strtoll_l(const char *_String, char **_EndPtr, int _Radix, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _strtoll_l$descriptor() {
        return _strtoll_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long long _strtoll_l(const char *_String, char **_EndPtr, int _Radix, _locale_t _Locale)
     * }
     */
    public static MethodHandle _strtoll_l$handle() {
        return _strtoll_l.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * long long _strtoll_l(const char *_String, char **_EndPtr, int _Radix, _locale_t _Locale)
     * }
     */
    public static long _strtoll_l(MemorySegment _String, MemorySegment _EndPtr, int _Radix, MemorySegment _Locale) {
        var mh$ = _strtoll_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_strtoll_l", _String, _EndPtr, _Radix, _Locale);
            }
            return (long)mh$.invokeExact(_String, _EndPtr, _Radix, _Locale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strtoul {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_POINTER,
            C_POINTER,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("strtoul"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned long strtoul(const char *_String, char **_EndPtr, int _Radix)
     * }
     */
    public static FunctionDescriptor strtoul$descriptor() {
        return strtoul.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned long strtoul(const char *_String, char **_EndPtr, int _Radix)
     * }
     */
    public static MethodHandle strtoul$handle() {
        return strtoul.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * unsigned long strtoul(const char *_String, char **_EndPtr, int _Radix)
     * }
     */
    public static int strtoul(MemorySegment _String, MemorySegment _EndPtr, int _Radix) {
        var mh$ = strtoul.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strtoul", _String, _EndPtr, _Radix);
            }
            return (int)mh$.invokeExact(_String, _EndPtr, _Radix);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _strtoul_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_POINTER,
            C_POINTER,
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("_strtoul_l"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned long _strtoul_l(const char *_String, char **_EndPtr, int _Radix, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _strtoul_l$descriptor() {
        return _strtoul_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned long _strtoul_l(const char *_String, char **_EndPtr, int _Radix, _locale_t _Locale)
     * }
     */
    public static MethodHandle _strtoul_l$handle() {
        return _strtoul_l.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * unsigned long _strtoul_l(const char *_String, char **_EndPtr, int _Radix, _locale_t _Locale)
     * }
     */
    public static int _strtoul_l(MemorySegment _String, MemorySegment _EndPtr, int _Radix, MemorySegment _Locale) {
        var mh$ = _strtoul_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_strtoul_l", _String, _EndPtr, _Radix, _Locale);
            }
            return (int)mh$.invokeExact(_String, _EndPtr, _Radix, _Locale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strtoull {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG_LONG,
            C_POINTER,
            C_POINTER,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("strtoull"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned long long strtoull(const char *_String, char **_EndPtr, int _Radix)
     * }
     */
    public static FunctionDescriptor strtoull$descriptor() {
        return strtoull.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned long long strtoull(const char *_String, char **_EndPtr, int _Radix)
     * }
     */
    public static MethodHandle strtoull$handle() {
        return strtoull.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * unsigned long long strtoull(const char *_String, char **_EndPtr, int _Radix)
     * }
     */
    public static long strtoull(MemorySegment _String, MemorySegment _EndPtr, int _Radix) {
        var mh$ = strtoull.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strtoull", _String, _EndPtr, _Radix);
            }
            return (long)mh$.invokeExact(_String, _EndPtr, _Radix);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _strtoull_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG_LONG,
            C_POINTER,
            C_POINTER,
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("_strtoull_l"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned long long _strtoull_l(const char *_String, char **_EndPtr, int _Radix, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _strtoull_l$descriptor() {
        return _strtoull_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned long long _strtoull_l(const char *_String, char **_EndPtr, int _Radix, _locale_t _Locale)
     * }
     */
    public static MethodHandle _strtoull_l$handle() {
        return _strtoull_l.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * unsigned long long _strtoull_l(const char *_String, char **_EndPtr, int _Radix, _locale_t _Locale)
     * }
     */
    public static long _strtoull_l(MemorySegment _String, MemorySegment _EndPtr, int _Radix, MemorySegment _Locale) {
        var mh$ = _strtoull_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_strtoull_l", _String, _EndPtr, _Radix, _Locale);
            }
            return (long)mh$.invokeExact(_String, _EndPtr, _Radix, _Locale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _strtoi64 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG_LONG,
            C_POINTER,
            C_POINTER,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("_strtoi64"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long long _strtoi64(const char *_String, char **_EndPtr, int _Radix)
     * }
     */
    public static FunctionDescriptor _strtoi64$descriptor() {
        return _strtoi64.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long long _strtoi64(const char *_String, char **_EndPtr, int _Radix)
     * }
     */
    public static MethodHandle _strtoi64$handle() {
        return _strtoi64.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * long long _strtoi64(const char *_String, char **_EndPtr, int _Radix)
     * }
     */
    public static long _strtoi64(MemorySegment _String, MemorySegment _EndPtr, int _Radix) {
        var mh$ = _strtoi64.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_strtoi64", _String, _EndPtr, _Radix);
            }
            return (long)mh$.invokeExact(_String, _EndPtr, _Radix);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _strtoi64_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG_LONG,
            C_POINTER,
            C_POINTER,
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("_strtoi64_l"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long long _strtoi64_l(const char *_String, char **_EndPtr, int _Radix, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _strtoi64_l$descriptor() {
        return _strtoi64_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long long _strtoi64_l(const char *_String, char **_EndPtr, int _Radix, _locale_t _Locale)
     * }
     */
    public static MethodHandle _strtoi64_l$handle() {
        return _strtoi64_l.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * long long _strtoi64_l(const char *_String, char **_EndPtr, int _Radix, _locale_t _Locale)
     * }
     */
    public static long _strtoi64_l(MemorySegment _String, MemorySegment _EndPtr, int _Radix, MemorySegment _Locale) {
        var mh$ = _strtoi64_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_strtoi64_l", _String, _EndPtr, _Radix, _Locale);
            }
            return (long)mh$.invokeExact(_String, _EndPtr, _Radix, _Locale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _strtoui64 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG_LONG,
            C_POINTER,
            C_POINTER,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("_strtoui64"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned long long _strtoui64(const char *_String, char **_EndPtr, int _Radix)
     * }
     */
    public static FunctionDescriptor _strtoui64$descriptor() {
        return _strtoui64.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned long long _strtoui64(const char *_String, char **_EndPtr, int _Radix)
     * }
     */
    public static MethodHandle _strtoui64$handle() {
        return _strtoui64.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * unsigned long long _strtoui64(const char *_String, char **_EndPtr, int _Radix)
     * }
     */
    public static long _strtoui64(MemorySegment _String, MemorySegment _EndPtr, int _Radix) {
        var mh$ = _strtoui64.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_strtoui64", _String, _EndPtr, _Radix);
            }
            return (long)mh$.invokeExact(_String, _EndPtr, _Radix);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _strtoui64_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG_LONG,
            C_POINTER,
            C_POINTER,
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("_strtoui64_l"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned long long _strtoui64_l(const char *_String, char **_EndPtr, int _Radix, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _strtoui64_l$descriptor() {
        return _strtoui64_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned long long _strtoui64_l(const char *_String, char **_EndPtr, int _Radix, _locale_t _Locale)
     * }
     */
    public static MethodHandle _strtoui64_l$handle() {
        return _strtoui64_l.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * unsigned long long _strtoui64_l(const char *_String, char **_EndPtr, int _Radix, _locale_t _Locale)
     * }
     */
    public static long _strtoui64_l(MemorySegment _String, MemorySegment _EndPtr, int _Radix, MemorySegment _Locale) {
        var mh$ = _strtoui64_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_strtoui64_l", _String, _EndPtr, _Radix, _Locale);
            }
            return (long)mh$.invokeExact(_String, _EndPtr, _Radix, _Locale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _itoa_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_INT,
            C_POINTER,
            C_LONG_LONG,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("_itoa_s"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t _itoa_s(int _Value, char *_Buffer, size_t _BufferCount, int _Radix)
     * }
     */
    public static FunctionDescriptor _itoa_s$descriptor() {
        return _itoa_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t _itoa_s(int _Value, char *_Buffer, size_t _BufferCount, int _Radix)
     * }
     */
    public static MethodHandle _itoa_s$handle() {
        return _itoa_s.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * errno_t _itoa_s(int _Value, char *_Buffer, size_t _BufferCount, int _Radix)
     * }
     */
    public static int _itoa_s(int _Value, MemorySegment _Buffer, long _BufferCount, int _Radix) {
        var mh$ = _itoa_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_itoa_s", _Value, _Buffer, _BufferCount, _Radix);
            }
            return (int)mh$.invokeExact(_Value, _Buffer, _BufferCount, _Radix);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _itoa {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_INT,
            C_POINTER,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("_itoa"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *_itoa(int _Value, char *_Buffer, int _Radix)
     * }
     */
    public static FunctionDescriptor _itoa$descriptor() {
        return _itoa.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *_itoa(int _Value, char *_Buffer, int _Radix)
     * }
     */
    public static MethodHandle _itoa$handle() {
        return _itoa.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * char *_itoa(int _Value, char *_Buffer, int _Radix)
     * }
     */
    public static MemorySegment _itoa(int _Value, MemorySegment _Buffer, int _Radix) {
        var mh$ = _itoa.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_itoa", _Value, _Buffer, _Radix);
            }
            return (MemorySegment)mh$.invokeExact(_Value, _Buffer, _Radix);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _ltoa_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_LONG,
            C_POINTER,
            C_LONG_LONG,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("_ltoa_s"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t _ltoa_s(long _Value, char *_Buffer, size_t _BufferCount, int _Radix)
     * }
     */
    public static FunctionDescriptor _ltoa_s$descriptor() {
        return _ltoa_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t _ltoa_s(long _Value, char *_Buffer, size_t _BufferCount, int _Radix)
     * }
     */
    public static MethodHandle _ltoa_s$handle() {
        return _ltoa_s.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * errno_t _ltoa_s(long _Value, char *_Buffer, size_t _BufferCount, int _Radix)
     * }
     */
    public static int _ltoa_s(int _Value, MemorySegment _Buffer, long _BufferCount, int _Radix) {
        var mh$ = _ltoa_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_ltoa_s", _Value, _Buffer, _BufferCount, _Radix);
            }
            return (int)mh$.invokeExact(_Value, _Buffer, _BufferCount, _Radix);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _ltoa {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_LONG,
            C_POINTER,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("_ltoa"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *_ltoa(long _Value, char *_Buffer, int _Radix)
     * }
     */
    public static FunctionDescriptor _ltoa$descriptor() {
        return _ltoa.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *_ltoa(long _Value, char *_Buffer, int _Radix)
     * }
     */
    public static MethodHandle _ltoa$handle() {
        return _ltoa.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * char *_ltoa(long _Value, char *_Buffer, int _Radix)
     * }
     */
    public static MemorySegment _ltoa(int _Value, MemorySegment _Buffer, int _Radix) {
        var mh$ = _ltoa.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_ltoa", _Value, _Buffer, _Radix);
            }
            return (MemorySegment)mh$.invokeExact(_Value, _Buffer, _Radix);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _ultoa_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_LONG,
            C_POINTER,
            C_LONG_LONG,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("_ultoa_s"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t _ultoa_s(unsigned long _Value, char *_Buffer, size_t _BufferCount, int _Radix)
     * }
     */
    public static FunctionDescriptor _ultoa_s$descriptor() {
        return _ultoa_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t _ultoa_s(unsigned long _Value, char *_Buffer, size_t _BufferCount, int _Radix)
     * }
     */
    public static MethodHandle _ultoa_s$handle() {
        return _ultoa_s.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * errno_t _ultoa_s(unsigned long _Value, char *_Buffer, size_t _BufferCount, int _Radix)
     * }
     */
    public static int _ultoa_s(int _Value, MemorySegment _Buffer, long _BufferCount, int _Radix) {
        var mh$ = _ultoa_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_ultoa_s", _Value, _Buffer, _BufferCount, _Radix);
            }
            return (int)mh$.invokeExact(_Value, _Buffer, _BufferCount, _Radix);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _ultoa {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_LONG,
            C_POINTER,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("_ultoa"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *_ultoa(unsigned long _Value, char *_Buffer, int _Radix)
     * }
     */
    public static FunctionDescriptor _ultoa$descriptor() {
        return _ultoa.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *_ultoa(unsigned long _Value, char *_Buffer, int _Radix)
     * }
     */
    public static MethodHandle _ultoa$handle() {
        return _ultoa.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * char *_ultoa(unsigned long _Value, char *_Buffer, int _Radix)
     * }
     */
    public static MemorySegment _ultoa(int _Value, MemorySegment _Buffer, int _Radix) {
        var mh$ = _ultoa.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_ultoa", _Value, _Buffer, _Radix);
            }
            return (MemorySegment)mh$.invokeExact(_Value, _Buffer, _Radix);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _i64toa_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_LONG_LONG,
            C_POINTER,
            C_LONG_LONG,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("_i64toa_s"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t _i64toa_s(long long _Value, char *_Buffer, size_t _BufferCount, int _Radix)
     * }
     */
    public static FunctionDescriptor _i64toa_s$descriptor() {
        return _i64toa_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t _i64toa_s(long long _Value, char *_Buffer, size_t _BufferCount, int _Radix)
     * }
     */
    public static MethodHandle _i64toa_s$handle() {
        return _i64toa_s.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * errno_t _i64toa_s(long long _Value, char *_Buffer, size_t _BufferCount, int _Radix)
     * }
     */
    public static int _i64toa_s(long _Value, MemorySegment _Buffer, long _BufferCount, int _Radix) {
        var mh$ = _i64toa_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_i64toa_s", _Value, _Buffer, _BufferCount, _Radix);
            }
            return (int)mh$.invokeExact(_Value, _Buffer, _BufferCount, _Radix);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _i64toa {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_LONG_LONG,
            C_POINTER,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("_i64toa"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *_i64toa(long long _Value, char *_Buffer, int _Radix)
     * }
     */
    public static FunctionDescriptor _i64toa$descriptor() {
        return _i64toa.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *_i64toa(long long _Value, char *_Buffer, int _Radix)
     * }
     */
    public static MethodHandle _i64toa$handle() {
        return _i64toa.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * char *_i64toa(long long _Value, char *_Buffer, int _Radix)
     * }
     */
    public static MemorySegment _i64toa(long _Value, MemorySegment _Buffer, int _Radix) {
        var mh$ = _i64toa.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_i64toa", _Value, _Buffer, _Radix);
            }
            return (MemorySegment)mh$.invokeExact(_Value, _Buffer, _Radix);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _ui64toa_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_LONG_LONG,
            C_POINTER,
            C_LONG_LONG,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("_ui64toa_s"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t _ui64toa_s(unsigned long long _Value, char *_Buffer, size_t _BufferCount, int _Radix)
     * }
     */
    public static FunctionDescriptor _ui64toa_s$descriptor() {
        return _ui64toa_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t _ui64toa_s(unsigned long long _Value, char *_Buffer, size_t _BufferCount, int _Radix)
     * }
     */
    public static MethodHandle _ui64toa_s$handle() {
        return _ui64toa_s.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * errno_t _ui64toa_s(unsigned long long _Value, char *_Buffer, size_t _BufferCount, int _Radix)
     * }
     */
    public static int _ui64toa_s(long _Value, MemorySegment _Buffer, long _BufferCount, int _Radix) {
        var mh$ = _ui64toa_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_ui64toa_s", _Value, _Buffer, _BufferCount, _Radix);
            }
            return (int)mh$.invokeExact(_Value, _Buffer, _BufferCount, _Radix);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _ui64toa {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_LONG_LONG,
            C_POINTER,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("_ui64toa"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *_ui64toa(unsigned long long _Value, char *_Buffer, int _Radix)
     * }
     */
    public static FunctionDescriptor _ui64toa$descriptor() {
        return _ui64toa.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *_ui64toa(unsigned long long _Value, char *_Buffer, int _Radix)
     * }
     */
    public static MethodHandle _ui64toa$handle() {
        return _ui64toa.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * char *_ui64toa(unsigned long long _Value, char *_Buffer, int _Radix)
     * }
     */
    public static MemorySegment _ui64toa(long _Value, MemorySegment _Buffer, int _Radix) {
        var mh$ = _ui64toa.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_ui64toa", _Value, _Buffer, _Radix);
            }
            return (MemorySegment)mh$.invokeExact(_Value, _Buffer, _Radix);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _ecvt_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_LONG_LONG,
            C_DOUBLE,
            C_INT,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("_ecvt_s"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t _ecvt_s(char *_Buffer, size_t _BufferCount, double _Value, int _DigitCount, int *_PtDec, int *_PtSign)
     * }
     */
    public static FunctionDescriptor _ecvt_s$descriptor() {
        return _ecvt_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t _ecvt_s(char *_Buffer, size_t _BufferCount, double _Value, int _DigitCount, int *_PtDec, int *_PtSign)
     * }
     */
    public static MethodHandle _ecvt_s$handle() {
        return _ecvt_s.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * errno_t _ecvt_s(char *_Buffer, size_t _BufferCount, double _Value, int _DigitCount, int *_PtDec, int *_PtSign)
     * }
     */
    public static int _ecvt_s(MemorySegment _Buffer, long _BufferCount, double _Value, int _DigitCount, MemorySegment _PtDec, MemorySegment _PtSign) {
        var mh$ = _ecvt_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_ecvt_s", _Buffer, _BufferCount, _Value, _DigitCount, _PtDec, _PtSign);
            }
            return (int)mh$.invokeExact(_Buffer, _BufferCount, _Value, _DigitCount, _PtDec, _PtSign);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _ecvt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_DOUBLE,
            C_INT,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("_ecvt"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *_ecvt(double _Value, int _DigitCount, int *_PtDec, int *_PtSign)
     * }
     */
    public static FunctionDescriptor _ecvt$descriptor() {
        return _ecvt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *_ecvt(double _Value, int _DigitCount, int *_PtDec, int *_PtSign)
     * }
     */
    public static MethodHandle _ecvt$handle() {
        return _ecvt.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * char *_ecvt(double _Value, int _DigitCount, int *_PtDec, int *_PtSign)
     * }
     */
    public static MemorySegment _ecvt(double _Value, int _DigitCount, MemorySegment _PtDec, MemorySegment _PtSign) {
        var mh$ = _ecvt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_ecvt", _Value, _DigitCount, _PtDec, _PtSign);
            }
            return (MemorySegment)mh$.invokeExact(_Value, _DigitCount, _PtDec, _PtSign);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _fcvt_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_LONG_LONG,
            C_DOUBLE,
            C_INT,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("_fcvt_s"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t _fcvt_s(char *_Buffer, size_t _BufferCount, double _Value, int _FractionalDigitCount, int *_PtDec, int *_PtSign)
     * }
     */
    public static FunctionDescriptor _fcvt_s$descriptor() {
        return _fcvt_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t _fcvt_s(char *_Buffer, size_t _BufferCount, double _Value, int _FractionalDigitCount, int *_PtDec, int *_PtSign)
     * }
     */
    public static MethodHandle _fcvt_s$handle() {
        return _fcvt_s.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * errno_t _fcvt_s(char *_Buffer, size_t _BufferCount, double _Value, int _FractionalDigitCount, int *_PtDec, int *_PtSign)
     * }
     */
    public static int _fcvt_s(MemorySegment _Buffer, long _BufferCount, double _Value, int _FractionalDigitCount, MemorySegment _PtDec, MemorySegment _PtSign) {
        var mh$ = _fcvt_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_fcvt_s", _Buffer, _BufferCount, _Value, _FractionalDigitCount, _PtDec, _PtSign);
            }
            return (int)mh$.invokeExact(_Buffer, _BufferCount, _Value, _FractionalDigitCount, _PtDec, _PtSign);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _fcvt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_DOUBLE,
            C_INT,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("_fcvt"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *_fcvt(double _Value, int _FractionalDigitCount, int *_PtDec, int *_PtSign)
     * }
     */
    public static FunctionDescriptor _fcvt$descriptor() {
        return _fcvt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *_fcvt(double _Value, int _FractionalDigitCount, int *_PtDec, int *_PtSign)
     * }
     */
    public static MethodHandle _fcvt$handle() {
        return _fcvt.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * char *_fcvt(double _Value, int _FractionalDigitCount, int *_PtDec, int *_PtSign)
     * }
     */
    public static MemorySegment _fcvt(double _Value, int _FractionalDigitCount, MemorySegment _PtDec, MemorySegment _PtSign) {
        var mh$ = _fcvt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_fcvt", _Value, _FractionalDigitCount, _PtDec, _PtSign);
            }
            return (MemorySegment)mh$.invokeExact(_Value, _FractionalDigitCount, _PtDec, _PtSign);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _gcvt_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_LONG_LONG,
            C_DOUBLE,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("_gcvt_s"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t _gcvt_s(char *_Buffer, size_t _BufferCount, double _Value, int _DigitCount)
     * }
     */
    public static FunctionDescriptor _gcvt_s$descriptor() {
        return _gcvt_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t _gcvt_s(char *_Buffer, size_t _BufferCount, double _Value, int _DigitCount)
     * }
     */
    public static MethodHandle _gcvt_s$handle() {
        return _gcvt_s.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * errno_t _gcvt_s(char *_Buffer, size_t _BufferCount, double _Value, int _DigitCount)
     * }
     */
    public static int _gcvt_s(MemorySegment _Buffer, long _BufferCount, double _Value, int _DigitCount) {
        var mh$ = _gcvt_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_gcvt_s", _Buffer, _BufferCount, _Value, _DigitCount);
            }
            return (int)mh$.invokeExact(_Buffer, _BufferCount, _Value, _DigitCount);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _gcvt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_DOUBLE,
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("_gcvt"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *_gcvt(double _Value, int _DigitCount, char *_Buffer)
     * }
     */
    public static FunctionDescriptor _gcvt$descriptor() {
        return _gcvt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *_gcvt(double _Value, int _DigitCount, char *_Buffer)
     * }
     */
    public static MethodHandle _gcvt$handle() {
        return _gcvt.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * char *_gcvt(double _Value, int _DigitCount, char *_Buffer)
     * }
     */
    public static MemorySegment _gcvt(double _Value, int _DigitCount, MemorySegment _Buffer) {
        var mh$ = _gcvt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_gcvt", _Value, _DigitCount, _Buffer);
            }
            return (MemorySegment)mh$.invokeExact(_Value, _DigitCount, _Buffer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ___mb_cur_max_func {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT    );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("___mb_cur_max_func"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int ___mb_cur_max_func()
     * }
     */
    public static FunctionDescriptor ___mb_cur_max_func$descriptor() {
        return ___mb_cur_max_func.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int ___mb_cur_max_func()
     * }
     */
    public static MethodHandle ___mb_cur_max_func$handle() {
        return ___mb_cur_max_func.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int ___mb_cur_max_func()
     * }
     */
    public static int ___mb_cur_max_func() {
        var mh$ = ___mb_cur_max_func.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("___mb_cur_max_func");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ___mb_cur_max_l_func {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("___mb_cur_max_l_func"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int ___mb_cur_max_l_func(_locale_t _Locale)
     * }
     */
    public static FunctionDescriptor ___mb_cur_max_l_func$descriptor() {
        return ___mb_cur_max_l_func.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int ___mb_cur_max_l_func(_locale_t _Locale)
     * }
     */
    public static MethodHandle ___mb_cur_max_l_func$handle() {
        return ___mb_cur_max_l_func.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int ___mb_cur_max_l_func(_locale_t _Locale)
     * }
     */
    public static int ___mb_cur_max_l_func(MemorySegment _Locale) {
        var mh$ = ___mb_cur_max_l_func.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("___mb_cur_max_l_func", _Locale);
            }
            return (int)mh$.invokeExact(_Locale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mblen {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_LONG_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("mblen"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mblen(const char *_Ch, size_t _MaxCount)
     * }
     */
    public static FunctionDescriptor mblen$descriptor() {
        return mblen.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mblen(const char *_Ch, size_t _MaxCount)
     * }
     */
    public static MethodHandle mblen$handle() {
        return mblen.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int mblen(const char *_Ch, size_t _MaxCount)
     * }
     */
    public static int mblen(MemorySegment _Ch, long _MaxCount) {
        var mh$ = mblen.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mblen", _Ch, _MaxCount);
            }
            return (int)mh$.invokeExact(_Ch, _MaxCount);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _mblen_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_LONG_LONG,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("_mblen_l"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _mblen_l(const char *_Ch, size_t _MaxCount, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _mblen_l$descriptor() {
        return _mblen_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _mblen_l(const char *_Ch, size_t _MaxCount, _locale_t _Locale)
     * }
     */
    public static MethodHandle _mblen_l$handle() {
        return _mblen_l.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int _mblen_l(const char *_Ch, size_t _MaxCount, _locale_t _Locale)
     * }
     */
    public static int _mblen_l(MemorySegment _Ch, long _MaxCount, MemorySegment _Locale) {
        var mh$ = _mblen_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_mblen_l", _Ch, _MaxCount, _Locale);
            }
            return (int)mh$.invokeExact(_Ch, _MaxCount, _Locale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _mbstrlen {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG_LONG,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("_mbstrlen"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * size_t _mbstrlen(const char *_String)
     * }
     */
    public static FunctionDescriptor _mbstrlen$descriptor() {
        return _mbstrlen.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * size_t _mbstrlen(const char *_String)
     * }
     */
    public static MethodHandle _mbstrlen$handle() {
        return _mbstrlen.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * size_t _mbstrlen(const char *_String)
     * }
     */
    public static long _mbstrlen(MemorySegment _String) {
        var mh$ = _mbstrlen.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_mbstrlen", _String);
            }
            return (long)mh$.invokeExact(_String);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _mbstrlen_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG_LONG,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("_mbstrlen_l"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * size_t _mbstrlen_l(const char *_String, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _mbstrlen_l$descriptor() {
        return _mbstrlen_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * size_t _mbstrlen_l(const char *_String, _locale_t _Locale)
     * }
     */
    public static MethodHandle _mbstrlen_l$handle() {
        return _mbstrlen_l.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * size_t _mbstrlen_l(const char *_String, _locale_t _Locale)
     * }
     */
    public static long _mbstrlen_l(MemorySegment _String, MemorySegment _Locale) {
        var mh$ = _mbstrlen_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_mbstrlen_l", _String, _Locale);
            }
            return (long)mh$.invokeExact(_String, _Locale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _mbstrnlen {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG_LONG,
            C_POINTER,
            C_LONG_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("_mbstrnlen"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * size_t _mbstrnlen(const char *_String, size_t _MaxCount)
     * }
     */
    public static FunctionDescriptor _mbstrnlen$descriptor() {
        return _mbstrnlen.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * size_t _mbstrnlen(const char *_String, size_t _MaxCount)
     * }
     */
    public static MethodHandle _mbstrnlen$handle() {
        return _mbstrnlen.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * size_t _mbstrnlen(const char *_String, size_t _MaxCount)
     * }
     */
    public static long _mbstrnlen(MemorySegment _String, long _MaxCount) {
        var mh$ = _mbstrnlen.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_mbstrnlen", _String, _MaxCount);
            }
            return (long)mh$.invokeExact(_String, _MaxCount);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _mbstrnlen_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG_LONG,
            C_POINTER,
            C_LONG_LONG,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("_mbstrnlen_l"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * size_t _mbstrnlen_l(const char *_String, size_t _MaxCount, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _mbstrnlen_l$descriptor() {
        return _mbstrnlen_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * size_t _mbstrnlen_l(const char *_String, size_t _MaxCount, _locale_t _Locale)
     * }
     */
    public static MethodHandle _mbstrnlen_l$handle() {
        return _mbstrnlen_l.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * size_t _mbstrnlen_l(const char *_String, size_t _MaxCount, _locale_t _Locale)
     * }
     */
    public static long _mbstrnlen_l(MemorySegment _String, long _MaxCount, MemorySegment _Locale) {
        var mh$ = _mbstrnlen_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_mbstrnlen_l", _String, _MaxCount, _Locale);
            }
            return (long)mh$.invokeExact(_String, _MaxCount, _Locale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mbtowc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_LONG_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("mbtowc"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mbtowc(wchar_t *_DstCh, const char *_SrcCh, size_t _SrcSizeInBytes)
     * }
     */
    public static FunctionDescriptor mbtowc$descriptor() {
        return mbtowc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mbtowc(wchar_t *_DstCh, const char *_SrcCh, size_t _SrcSizeInBytes)
     * }
     */
    public static MethodHandle mbtowc$handle() {
        return mbtowc.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int mbtowc(wchar_t *_DstCh, const char *_SrcCh, size_t _SrcSizeInBytes)
     * }
     */
    public static int mbtowc(MemorySegment _DstCh, MemorySegment _SrcCh, long _SrcSizeInBytes) {
        var mh$ = mbtowc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mbtowc", _DstCh, _SrcCh, _SrcSizeInBytes);
            }
            return (int)mh$.invokeExact(_DstCh, _SrcCh, _SrcSizeInBytes);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _mbtowc_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_LONG_LONG,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("_mbtowc_l"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _mbtowc_l(wchar_t *_DstCh, const char *_SrcCh, size_t _SrcSizeInBytes, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _mbtowc_l$descriptor() {
        return _mbtowc_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _mbtowc_l(wchar_t *_DstCh, const char *_SrcCh, size_t _SrcSizeInBytes, _locale_t _Locale)
     * }
     */
    public static MethodHandle _mbtowc_l$handle() {
        return _mbtowc_l.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int _mbtowc_l(wchar_t *_DstCh, const char *_SrcCh, size_t _SrcSizeInBytes, _locale_t _Locale)
     * }
     */
    public static int _mbtowc_l(MemorySegment _DstCh, MemorySegment _SrcCh, long _SrcSizeInBytes, MemorySegment _Locale) {
        var mh$ = _mbtowc_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_mbtowc_l", _DstCh, _SrcCh, _SrcSizeInBytes, _Locale);
            }
            return (int)mh$.invokeExact(_DstCh, _SrcCh, _SrcSizeInBytes, _Locale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mbstowcs_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_LONG_LONG,
            C_POINTER,
            C_LONG_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("mbstowcs_s"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t mbstowcs_s(size_t *_PtNumOfCharConverted, wchar_t *_DstBuf, size_t _SizeInWords, const char *_SrcBuf, size_t _MaxCount)
     * }
     */
    public static FunctionDescriptor mbstowcs_s$descriptor() {
        return mbstowcs_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t mbstowcs_s(size_t *_PtNumOfCharConverted, wchar_t *_DstBuf, size_t _SizeInWords, const char *_SrcBuf, size_t _MaxCount)
     * }
     */
    public static MethodHandle mbstowcs_s$handle() {
        return mbstowcs_s.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * errno_t mbstowcs_s(size_t *_PtNumOfCharConverted, wchar_t *_DstBuf, size_t _SizeInWords, const char *_SrcBuf, size_t _MaxCount)
     * }
     */
    public static int mbstowcs_s(MemorySegment _PtNumOfCharConverted, MemorySegment _DstBuf, long _SizeInWords, MemorySegment _SrcBuf, long _MaxCount) {
        var mh$ = mbstowcs_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mbstowcs_s", _PtNumOfCharConverted, _DstBuf, _SizeInWords, _SrcBuf, _MaxCount);
            }
            return (int)mh$.invokeExact(_PtNumOfCharConverted, _DstBuf, _SizeInWords, _SrcBuf, _MaxCount);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mbstowcs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG_LONG,
            C_POINTER,
            C_POINTER,
            C_LONG_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("mbstowcs"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * size_t mbstowcs(wchar_t *_Dest, const char *_Source, size_t _MaxCount)
     * }
     */
    public static FunctionDescriptor mbstowcs$descriptor() {
        return mbstowcs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * size_t mbstowcs(wchar_t *_Dest, const char *_Source, size_t _MaxCount)
     * }
     */
    public static MethodHandle mbstowcs$handle() {
        return mbstowcs.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * size_t mbstowcs(wchar_t *_Dest, const char *_Source, size_t _MaxCount)
     * }
     */
    public static long mbstowcs(MemorySegment _Dest, MemorySegment _Source, long _MaxCount) {
        var mh$ = mbstowcs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mbstowcs", _Dest, _Source, _MaxCount);
            }
            return (long)mh$.invokeExact(_Dest, _Source, _MaxCount);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _mbstowcs_s_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_LONG_LONG,
            C_POINTER,
            C_LONG_LONG,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("_mbstowcs_s_l"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t _mbstowcs_s_l(size_t *_PtNumOfCharConverted, wchar_t *_DstBuf, size_t _SizeInWords, const char *_SrcBuf, size_t _MaxCount, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _mbstowcs_s_l$descriptor() {
        return _mbstowcs_s_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t _mbstowcs_s_l(size_t *_PtNumOfCharConverted, wchar_t *_DstBuf, size_t _SizeInWords, const char *_SrcBuf, size_t _MaxCount, _locale_t _Locale)
     * }
     */
    public static MethodHandle _mbstowcs_s_l$handle() {
        return _mbstowcs_s_l.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * errno_t _mbstowcs_s_l(size_t *_PtNumOfCharConverted, wchar_t *_DstBuf, size_t _SizeInWords, const char *_SrcBuf, size_t _MaxCount, _locale_t _Locale)
     * }
     */
    public static int _mbstowcs_s_l(MemorySegment _PtNumOfCharConverted, MemorySegment _DstBuf, long _SizeInWords, MemorySegment _SrcBuf, long _MaxCount, MemorySegment _Locale) {
        var mh$ = _mbstowcs_s_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_mbstowcs_s_l", _PtNumOfCharConverted, _DstBuf, _SizeInWords, _SrcBuf, _MaxCount, _Locale);
            }
            return (int)mh$.invokeExact(_PtNumOfCharConverted, _DstBuf, _SizeInWords, _SrcBuf, _MaxCount, _Locale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _mbstowcs_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG_LONG,
            C_POINTER,
            C_POINTER,
            C_LONG_LONG,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("_mbstowcs_l"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * size_t _mbstowcs_l(wchar_t *_Dest, const char *_Source, size_t _MaxCount, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _mbstowcs_l$descriptor() {
        return _mbstowcs_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * size_t _mbstowcs_l(wchar_t *_Dest, const char *_Source, size_t _MaxCount, _locale_t _Locale)
     * }
     */
    public static MethodHandle _mbstowcs_l$handle() {
        return _mbstowcs_l.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * size_t _mbstowcs_l(wchar_t *_Dest, const char *_Source, size_t _MaxCount, _locale_t _Locale)
     * }
     */
    public static long _mbstowcs_l(MemorySegment _Dest, MemorySegment _Source, long _MaxCount, MemorySegment _Locale) {
        var mh$ = _mbstowcs_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_mbstowcs_l", _Dest, _Source, _MaxCount, _Locale);
            }
            return (long)mh$.invokeExact(_Dest, _Source, _MaxCount, _Locale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wctomb {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_SHORT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("wctomb"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int wctomb(char *_MbCh, wchar_t _WCh)
     * }
     */
    public static FunctionDescriptor wctomb$descriptor() {
        return wctomb.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int wctomb(char *_MbCh, wchar_t _WCh)
     * }
     */
    public static MethodHandle wctomb$handle() {
        return wctomb.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int wctomb(char *_MbCh, wchar_t _WCh)
     * }
     */
    public static int wctomb(MemorySegment _MbCh, short _WCh) {
        var mh$ = wctomb.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wctomb", _MbCh, _WCh);
            }
            return (int)mh$.invokeExact(_MbCh, _WCh);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wctomb_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_SHORT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("_wctomb_l"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _wctomb_l(char *_MbCh, wchar_t _WCh, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _wctomb_l$descriptor() {
        return _wctomb_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _wctomb_l(char *_MbCh, wchar_t _WCh, _locale_t _Locale)
     * }
     */
    public static MethodHandle _wctomb_l$handle() {
        return _wctomb_l.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int _wctomb_l(char *_MbCh, wchar_t _WCh, _locale_t _Locale)
     * }
     */
    public static int _wctomb_l(MemorySegment _MbCh, short _WCh, MemorySegment _Locale) {
        var mh$ = _wctomb_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wctomb_l", _MbCh, _WCh, _Locale);
            }
            return (int)mh$.invokeExact(_MbCh, _WCh, _Locale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wctomb_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_LONG_LONG,
            C_SHORT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("wctomb_s"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t wctomb_s(int *_SizeConverted, char *_MbCh, rsize_t _SizeInBytes, wchar_t _WCh)
     * }
     */
    public static FunctionDescriptor wctomb_s$descriptor() {
        return wctomb_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t wctomb_s(int *_SizeConverted, char *_MbCh, rsize_t _SizeInBytes, wchar_t _WCh)
     * }
     */
    public static MethodHandle wctomb_s$handle() {
        return wctomb_s.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * errno_t wctomb_s(int *_SizeConverted, char *_MbCh, rsize_t _SizeInBytes, wchar_t _WCh)
     * }
     */
    public static int wctomb_s(MemorySegment _SizeConverted, MemorySegment _MbCh, long _SizeInBytes, short _WCh) {
        var mh$ = wctomb_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wctomb_s", _SizeConverted, _MbCh, _SizeInBytes, _WCh);
            }
            return (int)mh$.invokeExact(_SizeConverted, _MbCh, _SizeInBytes, _WCh);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wctomb_s_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_LONG_LONG,
            C_SHORT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("_wctomb_s_l"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t _wctomb_s_l(int *_SizeConverted, char *_MbCh, size_t _SizeInBytes, wchar_t _WCh, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _wctomb_s_l$descriptor() {
        return _wctomb_s_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t _wctomb_s_l(int *_SizeConverted, char *_MbCh, size_t _SizeInBytes, wchar_t _WCh, _locale_t _Locale)
     * }
     */
    public static MethodHandle _wctomb_s_l$handle() {
        return _wctomb_s_l.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * errno_t _wctomb_s_l(int *_SizeConverted, char *_MbCh, size_t _SizeInBytes, wchar_t _WCh, _locale_t _Locale)
     * }
     */
    public static int _wctomb_s_l(MemorySegment _SizeConverted, MemorySegment _MbCh, long _SizeInBytes, short _WCh, MemorySegment _Locale) {
        var mh$ = _wctomb_s_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wctomb_s_l", _SizeConverted, _MbCh, _SizeInBytes, _WCh, _Locale);
            }
            return (int)mh$.invokeExact(_SizeConverted, _MbCh, _SizeInBytes, _WCh, _Locale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wcstombs_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_LONG_LONG,
            C_POINTER,
            C_LONG_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("wcstombs_s"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t wcstombs_s(size_t *_PtNumOfCharConverted, char *_Dst, size_t _DstSizeInBytes, const wchar_t *_Src, size_t _MaxCountInBytes)
     * }
     */
    public static FunctionDescriptor wcstombs_s$descriptor() {
        return wcstombs_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t wcstombs_s(size_t *_PtNumOfCharConverted, char *_Dst, size_t _DstSizeInBytes, const wchar_t *_Src, size_t _MaxCountInBytes)
     * }
     */
    public static MethodHandle wcstombs_s$handle() {
        return wcstombs_s.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * errno_t wcstombs_s(size_t *_PtNumOfCharConverted, char *_Dst, size_t _DstSizeInBytes, const wchar_t *_Src, size_t _MaxCountInBytes)
     * }
     */
    public static int wcstombs_s(MemorySegment _PtNumOfCharConverted, MemorySegment _Dst, long _DstSizeInBytes, MemorySegment _Src, long _MaxCountInBytes) {
        var mh$ = wcstombs_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wcstombs_s", _PtNumOfCharConverted, _Dst, _DstSizeInBytes, _Src, _MaxCountInBytes);
            }
            return (int)mh$.invokeExact(_PtNumOfCharConverted, _Dst, _DstSizeInBytes, _Src, _MaxCountInBytes);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wcstombs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG_LONG,
            C_POINTER,
            C_POINTER,
            C_LONG_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("wcstombs"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * size_t wcstombs(char *_Dest, const wchar_t *_Source, size_t _MaxCount)
     * }
     */
    public static FunctionDescriptor wcstombs$descriptor() {
        return wcstombs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * size_t wcstombs(char *_Dest, const wchar_t *_Source, size_t _MaxCount)
     * }
     */
    public static MethodHandle wcstombs$handle() {
        return wcstombs.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * size_t wcstombs(char *_Dest, const wchar_t *_Source, size_t _MaxCount)
     * }
     */
    public static long wcstombs(MemorySegment _Dest, MemorySegment _Source, long _MaxCount) {
        var mh$ = wcstombs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wcstombs", _Dest, _Source, _MaxCount);
            }
            return (long)mh$.invokeExact(_Dest, _Source, _MaxCount);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wcstombs_s_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_LONG_LONG,
            C_POINTER,
            C_LONG_LONG,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("_wcstombs_s_l"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t _wcstombs_s_l(size_t *_PtNumOfCharConverted, char *_Dst, size_t _DstSizeInBytes, const wchar_t *_Src, size_t _MaxCountInBytes, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _wcstombs_s_l$descriptor() {
        return _wcstombs_s_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t _wcstombs_s_l(size_t *_PtNumOfCharConverted, char *_Dst, size_t _DstSizeInBytes, const wchar_t *_Src, size_t _MaxCountInBytes, _locale_t _Locale)
     * }
     */
    public static MethodHandle _wcstombs_s_l$handle() {
        return _wcstombs_s_l.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * errno_t _wcstombs_s_l(size_t *_PtNumOfCharConverted, char *_Dst, size_t _DstSizeInBytes, const wchar_t *_Src, size_t _MaxCountInBytes, _locale_t _Locale)
     * }
     */
    public static int _wcstombs_s_l(MemorySegment _PtNumOfCharConverted, MemorySegment _Dst, long _DstSizeInBytes, MemorySegment _Src, long _MaxCountInBytes, MemorySegment _Locale) {
        var mh$ = _wcstombs_s_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wcstombs_s_l", _PtNumOfCharConverted, _Dst, _DstSizeInBytes, _Src, _MaxCountInBytes, _Locale);
            }
            return (int)mh$.invokeExact(_PtNumOfCharConverted, _Dst, _DstSizeInBytes, _Src, _MaxCountInBytes, _Locale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _wcstombs_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG_LONG,
            C_POINTER,
            C_POINTER,
            C_LONG_LONG,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("_wcstombs_l"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * size_t _wcstombs_l(char *_Dest, const wchar_t *_Source, size_t _MaxCount, _locale_t _Locale)
     * }
     */
    public static FunctionDescriptor _wcstombs_l$descriptor() {
        return _wcstombs_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * size_t _wcstombs_l(char *_Dest, const wchar_t *_Source, size_t _MaxCount, _locale_t _Locale)
     * }
     */
    public static MethodHandle _wcstombs_l$handle() {
        return _wcstombs_l.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * size_t _wcstombs_l(char *_Dest, const wchar_t *_Source, size_t _MaxCount, _locale_t _Locale)
     * }
     */
    public static long _wcstombs_l(MemorySegment _Dest, MemorySegment _Source, long _MaxCount, MemorySegment _Locale) {
        var mh$ = _wcstombs_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_wcstombs_l", _Dest, _Source, _MaxCount, _Locale);
            }
            return (long)mh$.invokeExact(_Dest, _Source, _MaxCount, _Locale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _fullpath {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_LONG_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("_fullpath"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *_fullpath(char *_Buffer, const char *_Path, size_t _BufferCount)
     * }
     */
    public static FunctionDescriptor _fullpath$descriptor() {
        return _fullpath.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *_fullpath(char *_Buffer, const char *_Path, size_t _BufferCount)
     * }
     */
    public static MethodHandle _fullpath$handle() {
        return _fullpath.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * char *_fullpath(char *_Buffer, const char *_Path, size_t _BufferCount)
     * }
     */
    public static MemorySegment _fullpath(MemorySegment _Buffer, MemorySegment _Path, long _BufferCount) {
        var mh$ = _fullpath.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_fullpath", _Buffer, _Path, _BufferCount);
            }
            return (MemorySegment)mh$.invokeExact(_Buffer, _Path, _BufferCount);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _makepath_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_LONG_LONG,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("_makepath_s"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t _makepath_s(char *_Buffer, size_t _BufferCount, const char *_Drive, const char *_Dir, const char *_Filename, const char *_Ext)
     * }
     */
    public static FunctionDescriptor _makepath_s$descriptor() {
        return _makepath_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t _makepath_s(char *_Buffer, size_t _BufferCount, const char *_Drive, const char *_Dir, const char *_Filename, const char *_Ext)
     * }
     */
    public static MethodHandle _makepath_s$handle() {
        return _makepath_s.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * errno_t _makepath_s(char *_Buffer, size_t _BufferCount, const char *_Drive, const char *_Dir, const char *_Filename, const char *_Ext)
     * }
     */
    public static int _makepath_s(MemorySegment _Buffer, long _BufferCount, MemorySegment _Drive, MemorySegment _Dir, MemorySegment _Filename, MemorySegment _Ext) {
        var mh$ = _makepath_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_makepath_s", _Buffer, _BufferCount, _Drive, _Dir, _Filename, _Ext);
            }
            return (int)mh$.invokeExact(_Buffer, _BufferCount, _Drive, _Dir, _Filename, _Ext);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _makepath {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("_makepath"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void _makepath(char *_Buffer, const char *_Drive, const char *_Dir, const char *_Filename, const char *_Ext)
     * }
     */
    public static FunctionDescriptor _makepath$descriptor() {
        return _makepath.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void _makepath(char *_Buffer, const char *_Drive, const char *_Dir, const char *_Filename, const char *_Ext)
     * }
     */
    public static MethodHandle _makepath$handle() {
        return _makepath.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * void _makepath(char *_Buffer, const char *_Drive, const char *_Dir, const char *_Filename, const char *_Ext)
     * }
     */
    public static void _makepath(MemorySegment _Buffer, MemorySegment _Drive, MemorySegment _Dir, MemorySegment _Filename, MemorySegment _Ext) {
        var mh$ = _makepath.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_makepath", _Buffer, _Drive, _Dir, _Filename, _Ext);
            }
            mh$.invokeExact(_Buffer, _Drive, _Dir, _Filename, _Ext);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _splitpath {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("_splitpath"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void _splitpath(const char *_FullPath, char *_Drive, char *_Dir, char *_Filename, char *_Ext)
     * }
     */
    public static FunctionDescriptor _splitpath$descriptor() {
        return _splitpath.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void _splitpath(const char *_FullPath, char *_Drive, char *_Dir, char *_Filename, char *_Ext)
     * }
     */
    public static MethodHandle _splitpath$handle() {
        return _splitpath.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * void _splitpath(const char *_FullPath, char *_Drive, char *_Dir, char *_Filename, char *_Ext)
     * }
     */
    public static void _splitpath(MemorySegment _FullPath, MemorySegment _Drive, MemorySegment _Dir, MemorySegment _Filename, MemorySegment _Ext) {
        var mh$ = _splitpath.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_splitpath", _FullPath, _Drive, _Dir, _Filename, _Ext);
            }
            mh$.invokeExact(_FullPath, _Drive, _Dir, _Filename, _Ext);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _splitpath_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_LONG_LONG,
            C_POINTER,
            C_LONG_LONG,
            C_POINTER,
            C_LONG_LONG,
            C_POINTER,
            C_LONG_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("_splitpath_s"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t _splitpath_s(const char *_FullPath, char *_Drive, size_t _DriveCount, char *_Dir, size_t _DirCount, char *_Filename, size_t _FilenameCount, char *_Ext, size_t _ExtCount)
     * }
     */
    public static FunctionDescriptor _splitpath_s$descriptor() {
        return _splitpath_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t _splitpath_s(const char *_FullPath, char *_Drive, size_t _DriveCount, char *_Dir, size_t _DirCount, char *_Filename, size_t _FilenameCount, char *_Ext, size_t _ExtCount)
     * }
     */
    public static MethodHandle _splitpath_s$handle() {
        return _splitpath_s.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * errno_t _splitpath_s(const char *_FullPath, char *_Drive, size_t _DriveCount, char *_Dir, size_t _DirCount, char *_Filename, size_t _FilenameCount, char *_Ext, size_t _ExtCount)
     * }
     */
    public static int _splitpath_s(MemorySegment _FullPath, MemorySegment _Drive, long _DriveCount, MemorySegment _Dir, long _DirCount, MemorySegment _Filename, long _FilenameCount, MemorySegment _Ext, long _ExtCount) {
        var mh$ = _splitpath_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_splitpath_s", _FullPath, _Drive, _DriveCount, _Dir, _DirCount, _Filename, _FilenameCount, _Ext, _ExtCount);
            }
            return (int)mh$.invokeExact(_FullPath, _Drive, _DriveCount, _Dir, _DirCount, _Filename, _FilenameCount, _Ext, _ExtCount);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getenv_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_LONG_LONG,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("getenv_s"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t getenv_s(size_t *_RequiredCount, char *_Buffer, rsize_t _BufferCount, const char *_VarName)
     * }
     */
    public static FunctionDescriptor getenv_s$descriptor() {
        return getenv_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t getenv_s(size_t *_RequiredCount, char *_Buffer, rsize_t _BufferCount, const char *_VarName)
     * }
     */
    public static MethodHandle getenv_s$handle() {
        return getenv_s.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * errno_t getenv_s(size_t *_RequiredCount, char *_Buffer, rsize_t _BufferCount, const char *_VarName)
     * }
     */
    public static int getenv_s(MemorySegment _RequiredCount, MemorySegment _Buffer, long _BufferCount, MemorySegment _VarName) {
        var mh$ = getenv_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getenv_s", _RequiredCount, _Buffer, _BufferCount, _VarName);
            }
            return (int)mh$.invokeExact(_RequiredCount, _Buffer, _BufferCount, _VarName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __p___argc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER    );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("__p___argc"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int *__p___argc()
     * }
     */
    public static FunctionDescriptor __p___argc$descriptor() {
        return __p___argc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int *__p___argc()
     * }
     */
    public static MethodHandle __p___argc$handle() {
        return __p___argc.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int *__p___argc()
     * }
     */
    public static MemorySegment __p___argc() {
        var mh$ = __p___argc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__p___argc");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __p___argv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER    );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("__p___argv"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char ***__p___argv()
     * }
     */
    public static FunctionDescriptor __p___argv$descriptor() {
        return __p___argv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char ***__p___argv()
     * }
     */
    public static MethodHandle __p___argv$handle() {
        return __p___argv.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * char ***__p___argv()
     * }
     */
    public static MemorySegment __p___argv() {
        var mh$ = __p___argv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__p___argv");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __p___wargv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER    );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("__p___wargv"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wchar_t ***__p___wargv()
     * }
     */
    public static FunctionDescriptor __p___wargv$descriptor() {
        return __p___wargv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wchar_t ***__p___wargv()
     * }
     */
    public static MethodHandle __p___wargv$handle() {
        return __p___wargv.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * wchar_t ***__p___wargv()
     * }
     */
    public static MemorySegment __p___wargv() {
        var mh$ = __p___wargv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__p___wargv");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __p__environ {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER    );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("__p__environ"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char ***__p__environ()
     * }
     */
    public static FunctionDescriptor __p__environ$descriptor() {
        return __p__environ.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char ***__p__environ()
     * }
     */
    public static MethodHandle __p__environ$handle() {
        return __p__environ.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * char ***__p__environ()
     * }
     */
    public static MemorySegment __p__environ() {
        var mh$ = __p__environ.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__p__environ");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __p__wenviron {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER    );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("__p__wenviron"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * wchar_t ***__p__wenviron()
     * }
     */
    public static FunctionDescriptor __p__wenviron$descriptor() {
        return __p__wenviron.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * wchar_t ***__p__wenviron()
     * }
     */
    public static MethodHandle __p__wenviron$handle() {
        return __p__wenviron.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * wchar_t ***__p__wenviron()
     * }
     */
    public static MemorySegment __p__wenviron() {
        var mh$ = __p__wenviron.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__p__wenviron");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getenv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("getenv"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *getenv(const char *_VarName)
     * }
     */
    public static FunctionDescriptor getenv$descriptor() {
        return getenv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *getenv(const char *_VarName)
     * }
     */
    public static MethodHandle getenv$handle() {
        return getenv.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * char *getenv(const char *_VarName)
     * }
     */
    public static MemorySegment getenv(MemorySegment _VarName) {
        var mh$ = getenv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getenv", _VarName);
            }
            return (MemorySegment)mh$.invokeExact(_VarName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _dupenv_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("_dupenv_s"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t _dupenv_s(char **_Buffer, size_t *_BufferCount, const char *_VarName)
     * }
     */
    public static FunctionDescriptor _dupenv_s$descriptor() {
        return _dupenv_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t _dupenv_s(char **_Buffer, size_t *_BufferCount, const char *_VarName)
     * }
     */
    public static MethodHandle _dupenv_s$handle() {
        return _dupenv_s.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * errno_t _dupenv_s(char **_Buffer, size_t *_BufferCount, const char *_VarName)
     * }
     */
    public static int _dupenv_s(MemorySegment _Buffer, MemorySegment _BufferCount, MemorySegment _VarName) {
        var mh$ = _dupenv_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_dupenv_s", _Buffer, _BufferCount, _VarName);
            }
            return (int)mh$.invokeExact(_Buffer, _BufferCount, _VarName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class system {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("system"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int system(const char *_Command)
     * }
     */
    public static FunctionDescriptor system$descriptor() {
        return system.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int system(const char *_Command)
     * }
     */
    public static MethodHandle system$handle() {
        return system.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int system(const char *_Command)
     * }
     */
    public static int system(MemorySegment _Command) {
        var mh$ = system.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("system", _Command);
            }
            return (int)mh$.invokeExact(_Command);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _putenv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("_putenv"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _putenv(const char *_EnvString)
     * }
     */
    public static FunctionDescriptor _putenv$descriptor() {
        return _putenv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _putenv(const char *_EnvString)
     * }
     */
    public static MethodHandle _putenv$handle() {
        return _putenv.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int _putenv(const char *_EnvString)
     * }
     */
    public static int _putenv(MemorySegment _EnvString) {
        var mh$ = _putenv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_putenv", _EnvString);
            }
            return (int)mh$.invokeExact(_EnvString);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _putenv_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("_putenv_s"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t _putenv_s(const char *_Name, const char *_Value)
     * }
     */
    public static FunctionDescriptor _putenv_s$descriptor() {
        return _putenv_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t _putenv_s(const char *_Name, const char *_Value)
     * }
     */
    public static MethodHandle _putenv_s$handle() {
        return _putenv_s.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * errno_t _putenv_s(const char *_Name, const char *_Value)
     * }
     */
    public static int _putenv_s(MemorySegment _Name, MemorySegment _Value) {
        var mh$ = _putenv_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_putenv_s", _Name, _Value);
            }
            return (int)mh$.invokeExact(_Name, _Value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _searchenv_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_LONG_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("_searchenv_s"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t _searchenv_s(const char *_Filename, const char *_VarName, char *_Buffer, size_t _BufferCount)
     * }
     */
    public static FunctionDescriptor _searchenv_s$descriptor() {
        return _searchenv_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t _searchenv_s(const char *_Filename, const char *_VarName, char *_Buffer, size_t _BufferCount)
     * }
     */
    public static MethodHandle _searchenv_s$handle() {
        return _searchenv_s.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * errno_t _searchenv_s(const char *_Filename, const char *_VarName, char *_Buffer, size_t _BufferCount)
     * }
     */
    public static int _searchenv_s(MemorySegment _Filename, MemorySegment _VarName, MemorySegment _Buffer, long _BufferCount) {
        var mh$ = _searchenv_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_searchenv_s", _Filename, _VarName, _Buffer, _BufferCount);
            }
            return (int)mh$.invokeExact(_Filename, _VarName, _Buffer, _BufferCount);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _searchenv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("_searchenv"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void _searchenv(const char *_Filename, const char *_VarName, char *_Buffer)
     * }
     */
    public static FunctionDescriptor _searchenv$descriptor() {
        return _searchenv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void _searchenv(const char *_Filename, const char *_VarName, char *_Buffer)
     * }
     */
    public static MethodHandle _searchenv$handle() {
        return _searchenv.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * void _searchenv(const char *_Filename, const char *_VarName, char *_Buffer)
     * }
     */
    public static void _searchenv(MemorySegment _Filename, MemorySegment _VarName, MemorySegment _Buffer) {
        var mh$ = _searchenv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_searchenv", _Filename, _VarName, _Buffer);
            }
            mh$.invokeExact(_Filename, _VarName, _Buffer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _seterrormode {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("_seterrormode"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void _seterrormode(int _Mode)
     * }
     */
    public static FunctionDescriptor _seterrormode$descriptor() {
        return _seterrormode.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void _seterrormode(int _Mode)
     * }
     */
    public static MethodHandle _seterrormode$handle() {
        return _seterrormode.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * void _seterrormode(int _Mode)
     * }
     */
    public static void _seterrormode(int _Mode) {
        var mh$ = _seterrormode.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_seterrormode", _Mode);
            }
            mh$.invokeExact(_Mode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _beep {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C_INT,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("_beep"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void _beep(unsigned int _Frequency, unsigned int _Duration)
     * }
     */
    public static FunctionDescriptor _beep$descriptor() {
        return _beep.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void _beep(unsigned int _Frequency, unsigned int _Duration)
     * }
     */
    public static MethodHandle _beep$handle() {
        return _beep.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * void _beep(unsigned int _Frequency, unsigned int _Duration)
     * }
     */
    public static void _beep(int _Frequency, int _Duration) {
        var mh$ = _beep.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_beep", _Frequency, _Duration);
            }
            mh$.invokeExact(_Frequency, _Duration);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _sleep {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("_sleep"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void _sleep(unsigned long _Duration)
     * }
     */
    public static FunctionDescriptor _sleep$descriptor() {
        return _sleep.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void _sleep(unsigned long _Duration)
     * }
     */
    public static MethodHandle _sleep$handle() {
        return _sleep.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * void _sleep(unsigned long _Duration)
     * }
     */
    public static void _sleep(int _Duration) {
        var mh$ = _sleep.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_sleep", _Duration);
            }
            mh$.invokeExact(_Duration);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecvt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_DOUBLE,
            C_INT,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("ecvt"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *ecvt(double _Value, int _DigitCount, int *_PtDec, int *_PtSign)
     * }
     */
    public static FunctionDescriptor ecvt$descriptor() {
        return ecvt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *ecvt(double _Value, int _DigitCount, int *_PtDec, int *_PtSign)
     * }
     */
    public static MethodHandle ecvt$handle() {
        return ecvt.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * char *ecvt(double _Value, int _DigitCount, int *_PtDec, int *_PtSign)
     * }
     */
    public static MemorySegment ecvt(double _Value, int _DigitCount, MemorySegment _PtDec, MemorySegment _PtSign) {
        var mh$ = ecvt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecvt", _Value, _DigitCount, _PtDec, _PtSign);
            }
            return (MemorySegment)mh$.invokeExact(_Value, _DigitCount, _PtDec, _PtSign);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fcvt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_DOUBLE,
            C_INT,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("fcvt"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *fcvt(double _Value, int _FractionalDigitCount, int *_PtDec, int *_PtSign)
     * }
     */
    public static FunctionDescriptor fcvt$descriptor() {
        return fcvt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *fcvt(double _Value, int _FractionalDigitCount, int *_PtDec, int *_PtSign)
     * }
     */
    public static MethodHandle fcvt$handle() {
        return fcvt.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * char *fcvt(double _Value, int _FractionalDigitCount, int *_PtDec, int *_PtSign)
     * }
     */
    public static MemorySegment fcvt(double _Value, int _FractionalDigitCount, MemorySegment _PtDec, MemorySegment _PtSign) {
        var mh$ = fcvt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fcvt", _Value, _FractionalDigitCount, _PtDec, _PtSign);
            }
            return (MemorySegment)mh$.invokeExact(_Value, _FractionalDigitCount, _PtDec, _PtSign);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class gcvt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_DOUBLE,
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("gcvt"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *gcvt(double _Value, int _DigitCount, char *_DstBuf)
     * }
     */
    public static FunctionDescriptor gcvt$descriptor() {
        return gcvt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *gcvt(double _Value, int _DigitCount, char *_DstBuf)
     * }
     */
    public static MethodHandle gcvt$handle() {
        return gcvt.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * char *gcvt(double _Value, int _DigitCount, char *_DstBuf)
     * }
     */
    public static MemorySegment gcvt(double _Value, int _DigitCount, MemorySegment _DstBuf) {
        var mh$ = gcvt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("gcvt", _Value, _DigitCount, _DstBuf);
            }
            return (MemorySegment)mh$.invokeExact(_Value, _DigitCount, _DstBuf);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class itoa {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_INT,
            C_POINTER,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("itoa"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *itoa(int _Value, char *_Buffer, int _Radix)
     * }
     */
    public static FunctionDescriptor itoa$descriptor() {
        return itoa.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *itoa(int _Value, char *_Buffer, int _Radix)
     * }
     */
    public static MethodHandle itoa$handle() {
        return itoa.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * char *itoa(int _Value, char *_Buffer, int _Radix)
     * }
     */
    public static MemorySegment itoa(int _Value, MemorySegment _Buffer, int _Radix) {
        var mh$ = itoa.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("itoa", _Value, _Buffer, _Radix);
            }
            return (MemorySegment)mh$.invokeExact(_Value, _Buffer, _Radix);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ltoa {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_LONG,
            C_POINTER,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("ltoa"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *ltoa(long _Value, char *_Buffer, int _Radix)
     * }
     */
    public static FunctionDescriptor ltoa$descriptor() {
        return ltoa.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *ltoa(long _Value, char *_Buffer, int _Radix)
     * }
     */
    public static MethodHandle ltoa$handle() {
        return ltoa.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * char *ltoa(long _Value, char *_Buffer, int _Radix)
     * }
     */
    public static MemorySegment ltoa(int _Value, MemorySegment _Buffer, int _Radix) {
        var mh$ = ltoa.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ltoa", _Value, _Buffer, _Radix);
            }
            return (MemorySegment)mh$.invokeExact(_Value, _Buffer, _Radix);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class swab {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C_POINTER,
            C_POINTER,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("swab"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void swab(char *_Buf1, char *_Buf2, int _SizeInBytes)
     * }
     */
    public static FunctionDescriptor swab$descriptor() {
        return swab.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void swab(char *_Buf1, char *_Buf2, int _SizeInBytes)
     * }
     */
    public static MethodHandle swab$handle() {
        return swab.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * void swab(char *_Buf1, char *_Buf2, int _SizeInBytes)
     * }
     */
    public static void swab(MemorySegment _Buf1, MemorySegment _Buf2, int _SizeInBytes) {
        var mh$ = swab.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("swab", _Buf1, _Buf2, _SizeInBytes);
            }
            mh$.invokeExact(_Buf1, _Buf2, _SizeInBytes);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ultoa {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_LONG,
            C_POINTER,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("ultoa"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *ultoa(unsigned long _Value, char *_Buffer, int _Radix)
     * }
     */
    public static FunctionDescriptor ultoa$descriptor() {
        return ultoa.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *ultoa(unsigned long _Value, char *_Buffer, int _Radix)
     * }
     */
    public static MethodHandle ultoa$handle() {
        return ultoa.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * char *ultoa(unsigned long _Value, char *_Buffer, int _Radix)
     * }
     */
    public static MemorySegment ultoa(int _Value, MemorySegment _Buffer, int _Radix) {
        var mh$ = ultoa.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ultoa", _Value, _Buffer, _Radix);
            }
            return (MemorySegment)mh$.invokeExact(_Value, _Buffer, _Radix);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class putenv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("putenv"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int putenv(const char *_EnvString)
     * }
     */
    public static FunctionDescriptor putenv$descriptor() {
        return putenv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int putenv(const char *_EnvString)
     * }
     */
    public static MethodHandle putenv$handle() {
        return putenv.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int putenv(const char *_EnvString)
     * }
     */
    public static int putenv(MemorySegment _EnvString) {
        var mh$ = putenv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("putenv", _EnvString);
            }
            return (int)mh$.invokeExact(_EnvString);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class onexit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("onexit"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * _onexit_t onexit(_onexit_t _Func)
     * }
     */
    public static FunctionDescriptor onexit$descriptor() {
        return onexit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * _onexit_t onexit(_onexit_t _Func)
     * }
     */
    public static MethodHandle onexit$handle() {
        return onexit.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * _onexit_t onexit(_onexit_t _Func)
     * }
     */
    public static MemorySegment onexit(MemorySegment _Func) {
        var mh$ = onexit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("onexit", _Func);
            }
            return (MemorySegment)mh$.invokeExact(_Func);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _alloca {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_LONG_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("_alloca"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *_alloca(size_t _Size)
     * }
     */
    public static FunctionDescriptor _alloca$descriptor() {
        return _alloca.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *_alloca(size_t _Size)
     * }
     */
    public static MethodHandle _alloca$handle() {
        return _alloca.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * void *_alloca(size_t _Size)
     * }
     */
    public static MemorySegment _alloca(long _Size) {
        var mh$ = _alloca.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_alloca", _Size);
            }
            return (MemorySegment)mh$.invokeExact(_Size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _get_heap_handle {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG_LONG    );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("_get_heap_handle"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * intptr_t _get_heap_handle()
     * }
     */
    public static FunctionDescriptor _get_heap_handle$descriptor() {
        return _get_heap_handle.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * intptr_t _get_heap_handle()
     * }
     */
    public static MethodHandle _get_heap_handle$handle() {
        return _get_heap_handle.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * intptr_t _get_heap_handle()
     * }
     */
    public static long _get_heap_handle() {
        var mh$ = _get_heap_handle.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_get_heap_handle");
            }
            return (long)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _heapmin {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT    );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("_heapmin"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _heapmin()
     * }
     */
    public static FunctionDescriptor _heapmin$descriptor() {
        return _heapmin.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _heapmin()
     * }
     */
    public static MethodHandle _heapmin$handle() {
        return _heapmin.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int _heapmin()
     * }
     */
    public static int _heapmin() {
        var mh$ = _heapmin.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_heapmin");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _heapwalk {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("_heapwalk"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _heapwalk(_HEAPINFO *_EntryInfo)
     * }
     */
    public static FunctionDescriptor _heapwalk$descriptor() {
        return _heapwalk.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _heapwalk(_HEAPINFO *_EntryInfo)
     * }
     */
    public static MethodHandle _heapwalk$handle() {
        return _heapwalk.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int _heapwalk(_HEAPINFO *_EntryInfo)
     * }
     */
    public static int _heapwalk(MemorySegment _EntryInfo) {
        var mh$ = _heapwalk.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_heapwalk", _EntryInfo);
            }
            return (int)mh$.invokeExact(_EntryInfo);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _heapchk {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT    );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("_heapchk"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _heapchk()
     * }
     */
    public static FunctionDescriptor _heapchk$descriptor() {
        return _heapchk.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _heapchk()
     * }
     */
    public static MethodHandle _heapchk$handle() {
        return _heapchk.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int _heapchk()
     * }
     */
    public static int _heapchk() {
        var mh$ = _heapchk.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_heapchk");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _resetstkoflw {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT    );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("_resetstkoflw"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int _resetstkoflw()
     * }
     */
    public static FunctionDescriptor _resetstkoflw$descriptor() {
        return _resetstkoflw.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int _resetstkoflw()
     * }
     */
    public static MethodHandle _resetstkoflw$handle() {
        return _resetstkoflw.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int _resetstkoflw()
     * }
     */
    public static int _resetstkoflw() {
        var mh$ = _resetstkoflw.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_resetstkoflw");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _mm_sfence {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("_mm_sfence"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void _mm_sfence()
     * }
     */
    public static FunctionDescriptor _mm_sfence$descriptor() {
        return _mm_sfence.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void _mm_sfence()
     * }
     */
    public static MethodHandle _mm_sfence$handle() {
        return _mm_sfence.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * void _mm_sfence()
     * }
     */
    public static void _mm_sfence() {
        var mh$ = _mm_sfence.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_mm_sfence");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _mm_getcsr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT    );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("_mm_getcsr"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int _mm_getcsr()
     * }
     */
    public static FunctionDescriptor _mm_getcsr$descriptor() {
        return _mm_getcsr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int _mm_getcsr()
     * }
     */
    public static MethodHandle _mm_getcsr$handle() {
        return _mm_getcsr.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * unsigned int _mm_getcsr()
     * }
     */
    public static int _mm_getcsr() {
        var mh$ = _mm_getcsr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_mm_getcsr");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _mm_setcsr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("_mm_setcsr"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void _mm_setcsr(unsigned int __i)
     * }
     */
    public static FunctionDescriptor _mm_setcsr$descriptor() {
        return _mm_setcsr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void _mm_setcsr(unsigned int __i)
     * }
     */
    public static MethodHandle _mm_setcsr$handle() {
        return _mm_setcsr.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * void _mm_setcsr(unsigned int __i)
     * }
     */
    public static void _mm_setcsr(int __i) {
        var mh$ = _mm_setcsr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_mm_setcsr", __i);
            }
            mh$.invokeExact(__i);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _mm_clflush {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("_mm_clflush"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void _mm_clflush(const void *__p)
     * }
     */
    public static FunctionDescriptor _mm_clflush$descriptor() {
        return _mm_clflush.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void _mm_clflush(const void *__p)
     * }
     */
    public static MethodHandle _mm_clflush$handle() {
        return _mm_clflush.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * void _mm_clflush(const void *__p)
     * }
     */
    public static void _mm_clflush(MemorySegment __p) {
        var mh$ = _mm_clflush.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_mm_clflush", __p);
            }
            mh$.invokeExact(__p);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _mm_lfence {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("_mm_lfence"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void _mm_lfence()
     * }
     */
    public static FunctionDescriptor _mm_lfence$descriptor() {
        return _mm_lfence.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void _mm_lfence()
     * }
     */
    public static MethodHandle _mm_lfence$handle() {
        return _mm_lfence.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * void _mm_lfence()
     * }
     */
    public static void _mm_lfence() {
        var mh$ = _mm_lfence.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_mm_lfence");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _mm_mfence {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("_mm_mfence"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void _mm_mfence()
     * }
     */
    public static FunctionDescriptor _mm_mfence$descriptor() {
        return _mm_mfence.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void _mm_mfence()
     * }
     */
    public static MethodHandle _mm_mfence$handle() {
        return _mm_mfence.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * void _mm_mfence()
     * }
     */
    public static void _mm_mfence() {
        var mh$ = _mm_mfence.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_mm_mfence");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _mm_pause {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("_mm_pause"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void _mm_pause()
     * }
     */
    public static FunctionDescriptor _mm_pause$descriptor() {
        return _mm_pause.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void _mm_pause()
     * }
     */
    public static MethodHandle _mm_pause$handle() {
        return _mm_pause.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * void _mm_pause()
     * }
     */
    public static void _mm_pause() {
        var mh$ = _mm_pause.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_mm_pause");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct _cl_platform_id *cl_platform_id
     * }
     */
    public static final AddressLayout cl_platform_id = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _cl_device_id *cl_device_id
     * }
     */
    public static final AddressLayout cl_device_id = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _cl_context *cl_context
     * }
     */
    public static final AddressLayout cl_context = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _cl_command_queue *cl_command_queue
     * }
     */
    public static final AddressLayout cl_command_queue = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _cl_mem *cl_mem
     * }
     */
    public static final AddressLayout cl_mem = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _cl_program *cl_program
     * }
     */
    public static final AddressLayout cl_program = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _cl_kernel *cl_kernel
     * }
     */
    public static final AddressLayout cl_kernel = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _cl_event *cl_event
     * }
     */
    public static final AddressLayout cl_event = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _cl_sampler *cl_sampler
     * }
     */
    public static final AddressLayout cl_sampler = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef cl_uint cl_bool
     * }
     */
    public static final OfInt cl_bool = C_INT;
    /**
     * {@snippet lang=c :
     * typedef cl_ulong cl_bitfield
     * }
     */
    public static final OfLong cl_bitfield = C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef cl_ulong cl_properties
     * }
     */
    public static final OfLong cl_properties = C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef cl_bitfield cl_device_type
     * }
     */
    public static final OfLong cl_device_type = C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef cl_uint cl_platform_info
     * }
     */
    public static final OfInt cl_platform_info = C_INT;
    /**
     * {@snippet lang=c :
     * typedef cl_uint cl_device_info
     * }
     */
    public static final OfInt cl_device_info = C_INT;
    /**
     * {@snippet lang=c :
     * typedef cl_bitfield cl_device_fp_config
     * }
     */
    public static final OfLong cl_device_fp_config = C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef cl_uint cl_device_mem_cache_type
     * }
     */
    public static final OfInt cl_device_mem_cache_type = C_INT;
    /**
     * {@snippet lang=c :
     * typedef cl_uint cl_device_local_mem_type
     * }
     */
    public static final OfInt cl_device_local_mem_type = C_INT;
    /**
     * {@snippet lang=c :
     * typedef cl_bitfield cl_device_exec_capabilities
     * }
     */
    public static final OfLong cl_device_exec_capabilities = C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef cl_bitfield cl_device_svm_capabilities
     * }
     */
    public static final OfLong cl_device_svm_capabilities = C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef cl_bitfield cl_command_queue_properties
     * }
     */
    public static final OfLong cl_command_queue_properties = C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef intptr_t cl_device_partition_property
     * }
     */
    public static final OfLong cl_device_partition_property = C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef cl_bitfield cl_device_affinity_domain
     * }
     */
    public static final OfLong cl_device_affinity_domain = C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef intptr_t cl_context_properties
     * }
     */
    public static final OfLong cl_context_properties = C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef cl_uint cl_context_info
     * }
     */
    public static final OfInt cl_context_info = C_INT;
    /**
     * {@snippet lang=c :
     * typedef cl_properties cl_queue_properties
     * }
     */
    public static final OfLong cl_queue_properties = C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef cl_uint cl_command_queue_info
     * }
     */
    public static final OfInt cl_command_queue_info = C_INT;
    /**
     * {@snippet lang=c :
     * typedef cl_uint cl_channel_order
     * }
     */
    public static final OfInt cl_channel_order = C_INT;
    /**
     * {@snippet lang=c :
     * typedef cl_uint cl_channel_type
     * }
     */
    public static final OfInt cl_channel_type = C_INT;
    /**
     * {@snippet lang=c :
     * typedef cl_bitfield cl_mem_flags
     * }
     */
    public static final OfLong cl_mem_flags = C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef cl_bitfield cl_svm_mem_flags
     * }
     */
    public static final OfLong cl_svm_mem_flags = C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef cl_uint cl_mem_object_type
     * }
     */
    public static final OfInt cl_mem_object_type = C_INT;
    /**
     * {@snippet lang=c :
     * typedef cl_uint cl_mem_info
     * }
     */
    public static final OfInt cl_mem_info = C_INT;
    /**
     * {@snippet lang=c :
     * typedef cl_bitfield cl_mem_migration_flags
     * }
     */
    public static final OfLong cl_mem_migration_flags = C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef cl_uint cl_image_info
     * }
     */
    public static final OfInt cl_image_info = C_INT;
    /**
     * {@snippet lang=c :
     * typedef cl_uint cl_buffer_create_type
     * }
     */
    public static final OfInt cl_buffer_create_type = C_INT;
    /**
     * {@snippet lang=c :
     * typedef cl_uint cl_addressing_mode
     * }
     */
    public static final OfInt cl_addressing_mode = C_INT;
    /**
     * {@snippet lang=c :
     * typedef cl_uint cl_filter_mode
     * }
     */
    public static final OfInt cl_filter_mode = C_INT;
    /**
     * {@snippet lang=c :
     * typedef cl_uint cl_sampler_info
     * }
     */
    public static final OfInt cl_sampler_info = C_INT;
    /**
     * {@snippet lang=c :
     * typedef cl_bitfield cl_map_flags
     * }
     */
    public static final OfLong cl_map_flags = C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef intptr_t cl_pipe_properties
     * }
     */
    public static final OfLong cl_pipe_properties = C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef cl_uint cl_pipe_info
     * }
     */
    public static final OfInt cl_pipe_info = C_INT;
    /**
     * {@snippet lang=c :
     * typedef cl_uint cl_program_info
     * }
     */
    public static final OfInt cl_program_info = C_INT;
    /**
     * {@snippet lang=c :
     * typedef cl_uint cl_program_build_info
     * }
     */
    public static final OfInt cl_program_build_info = C_INT;
    /**
     * {@snippet lang=c :
     * typedef cl_uint cl_program_binary_type
     * }
     */
    public static final OfInt cl_program_binary_type = C_INT;
    /**
     * {@snippet lang=c :
     * typedef cl_int cl_build_status
     * }
     */
    public static final OfInt cl_build_status = C_INT;
    /**
     * {@snippet lang=c :
     * typedef cl_uint cl_kernel_info
     * }
     */
    public static final OfInt cl_kernel_info = C_INT;
    /**
     * {@snippet lang=c :
     * typedef cl_uint cl_kernel_arg_info
     * }
     */
    public static final OfInt cl_kernel_arg_info = C_INT;
    /**
     * {@snippet lang=c :
     * typedef cl_uint cl_kernel_arg_address_qualifier
     * }
     */
    public static final OfInt cl_kernel_arg_address_qualifier = C_INT;
    /**
     * {@snippet lang=c :
     * typedef cl_uint cl_kernel_arg_access_qualifier
     * }
     */
    public static final OfInt cl_kernel_arg_access_qualifier = C_INT;
    /**
     * {@snippet lang=c :
     * typedef cl_bitfield cl_kernel_arg_type_qualifier
     * }
     */
    public static final OfLong cl_kernel_arg_type_qualifier = C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef cl_uint cl_kernel_work_group_info
     * }
     */
    public static final OfInt cl_kernel_work_group_info = C_INT;
    /**
     * {@snippet lang=c :
     * typedef cl_uint cl_kernel_sub_group_info
     * }
     */
    public static final OfInt cl_kernel_sub_group_info = C_INT;
    /**
     * {@snippet lang=c :
     * typedef cl_uint cl_event_info
     * }
     */
    public static final OfInt cl_event_info = C_INT;
    /**
     * {@snippet lang=c :
     * typedef cl_uint cl_command_type
     * }
     */
    public static final OfInt cl_command_type = C_INT;
    /**
     * {@snippet lang=c :
     * typedef cl_uint cl_profiling_info
     * }
     */
    public static final OfInt cl_profiling_info = C_INT;
    /**
     * {@snippet lang=c :
     * typedef cl_properties cl_sampler_properties
     * }
     */
    public static final OfLong cl_sampler_properties = C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef cl_uint cl_kernel_exec_info
     * }
     */
    public static final OfInt cl_kernel_exec_info = C_INT;
    /**
     * {@snippet lang=c :
     * typedef cl_bitfield cl_device_atomic_capabilities
     * }
     */
    public static final OfLong cl_device_atomic_capabilities = C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef cl_bitfield cl_device_device_enqueue_capabilities
     * }
     */
    public static final OfLong cl_device_device_enqueue_capabilities = C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef cl_uint cl_khronos_vendor_id
     * }
     */
    public static final OfInt cl_khronos_vendor_id = C_INT;
    /**
     * {@snippet lang=c :
     * typedef cl_properties cl_mem_properties
     * }
     */
    public static final OfLong cl_mem_properties = C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef cl_uint cl_version
     * }
     */
    public static final OfInt cl_version = C_INT;

    private static class clGetPlatformIDs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_INT,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("clGetPlatformIDs"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern cl_int clGetPlatformIDs(cl_uint num_entries, cl_platform_id *platforms, cl_uint *num_platforms)
     * }
     */
    public static FunctionDescriptor clGetPlatformIDs$descriptor() {
        return clGetPlatformIDs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern cl_int clGetPlatformIDs(cl_uint num_entries, cl_platform_id *platforms, cl_uint *num_platforms)
     * }
     */
    public static MethodHandle clGetPlatformIDs$handle() {
        return clGetPlatformIDs.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern cl_int clGetPlatformIDs(cl_uint num_entries, cl_platform_id *platforms, cl_uint *num_platforms)
     * }
     */
    public static int clGetPlatformIDs(int num_entries, MemorySegment platforms, MemorySegment num_platforms) {
        var mh$ = clGetPlatformIDs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clGetPlatformIDs", num_entries, platforms, num_platforms);
            }
            return (int)mh$.invokeExact(num_entries, platforms, num_platforms);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clGetPlatformInfo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_INT,
            C_LONG_LONG,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("clGetPlatformInfo"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern cl_int clGetPlatformInfo(cl_platform_id platform, cl_platform_info param_name, size_t param_value_size, void *param_value, size_t *param_value_size_ret)
     * }
     */
    public static FunctionDescriptor clGetPlatformInfo$descriptor() {
        return clGetPlatformInfo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern cl_int clGetPlatformInfo(cl_platform_id platform, cl_platform_info param_name, size_t param_value_size, void *param_value, size_t *param_value_size_ret)
     * }
     */
    public static MethodHandle clGetPlatformInfo$handle() {
        return clGetPlatformInfo.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern cl_int clGetPlatformInfo(cl_platform_id platform, cl_platform_info param_name, size_t param_value_size, void *param_value, size_t *param_value_size_ret)
     * }
     */
    public static int clGetPlatformInfo(MemorySegment platform, int param_name, long param_value_size, MemorySegment param_value, MemorySegment param_value_size_ret) {
        var mh$ = clGetPlatformInfo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clGetPlatformInfo", platform, param_name, param_value_size, param_value, param_value_size_ret);
            }
            return (int)mh$.invokeExact(platform, param_name, param_value_size, param_value, param_value_size_ret);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clGetDeviceIDs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_LONG_LONG,
            C_INT,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("clGetDeviceIDs"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern cl_int clGetDeviceIDs(cl_platform_id platform, cl_device_type device_type, cl_uint num_entries, cl_device_id *devices, cl_uint *num_devices)
     * }
     */
    public static FunctionDescriptor clGetDeviceIDs$descriptor() {
        return clGetDeviceIDs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern cl_int clGetDeviceIDs(cl_platform_id platform, cl_device_type device_type, cl_uint num_entries, cl_device_id *devices, cl_uint *num_devices)
     * }
     */
    public static MethodHandle clGetDeviceIDs$handle() {
        return clGetDeviceIDs.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern cl_int clGetDeviceIDs(cl_platform_id platform, cl_device_type device_type, cl_uint num_entries, cl_device_id *devices, cl_uint *num_devices)
     * }
     */
    public static int clGetDeviceIDs(MemorySegment platform, long device_type, int num_entries, MemorySegment devices, MemorySegment num_devices) {
        var mh$ = clGetDeviceIDs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clGetDeviceIDs", platform, device_type, num_entries, devices, num_devices);
            }
            return (int)mh$.invokeExact(platform, device_type, num_entries, devices, num_devices);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clGetDeviceInfo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_INT,
            C_LONG_LONG,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("clGetDeviceInfo"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern cl_int clGetDeviceInfo(cl_device_id device, cl_device_info param_name, size_t param_value_size, void *param_value, size_t *param_value_size_ret)
     * }
     */
    public static FunctionDescriptor clGetDeviceInfo$descriptor() {
        return clGetDeviceInfo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern cl_int clGetDeviceInfo(cl_device_id device, cl_device_info param_name, size_t param_value_size, void *param_value, size_t *param_value_size_ret)
     * }
     */
    public static MethodHandle clGetDeviceInfo$handle() {
        return clGetDeviceInfo.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern cl_int clGetDeviceInfo(cl_device_id device, cl_device_info param_name, size_t param_value_size, void *param_value, size_t *param_value_size_ret)
     * }
     */
    public static int clGetDeviceInfo(MemorySegment device, int param_name, long param_value_size, MemorySegment param_value, MemorySegment param_value_size_ret) {
        var mh$ = clGetDeviceInfo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clGetDeviceInfo", device, param_name, param_value_size, param_value, param_value_size_ret);
            }
            return (int)mh$.invokeExact(device, param_name, param_value_size, param_value, param_value_size_ret);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clCreateSubDevices {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_INT,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("clCreateSubDevices"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern cl_int clCreateSubDevices(cl_device_id in_device, const cl_device_partition_property *properties, cl_uint num_devices, cl_device_id *out_devices, cl_uint *num_devices_ret)
     * }
     */
    public static FunctionDescriptor clCreateSubDevices$descriptor() {
        return clCreateSubDevices.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern cl_int clCreateSubDevices(cl_device_id in_device, const cl_device_partition_property *properties, cl_uint num_devices, cl_device_id *out_devices, cl_uint *num_devices_ret)
     * }
     */
    public static MethodHandle clCreateSubDevices$handle() {
        return clCreateSubDevices.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern cl_int clCreateSubDevices(cl_device_id in_device, const cl_device_partition_property *properties, cl_uint num_devices, cl_device_id *out_devices, cl_uint *num_devices_ret)
     * }
     */
    public static int clCreateSubDevices(MemorySegment in_device, MemorySegment properties, int num_devices, MemorySegment out_devices, MemorySegment num_devices_ret) {
        var mh$ = clCreateSubDevices.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clCreateSubDevices", in_device, properties, num_devices, out_devices, num_devices_ret);
            }
            return (int)mh$.invokeExact(in_device, properties, num_devices, out_devices, num_devices_ret);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clRetainDevice {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("clRetainDevice"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern cl_int clRetainDevice(cl_device_id device)
     * }
     */
    public static FunctionDescriptor clRetainDevice$descriptor() {
        return clRetainDevice.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern cl_int clRetainDevice(cl_device_id device)
     * }
     */
    public static MethodHandle clRetainDevice$handle() {
        return clRetainDevice.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern cl_int clRetainDevice(cl_device_id device)
     * }
     */
    public static int clRetainDevice(MemorySegment device) {
        var mh$ = clRetainDevice.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clRetainDevice", device);
            }
            return (int)mh$.invokeExact(device);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clReleaseDevice {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("clReleaseDevice"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern cl_int clReleaseDevice(cl_device_id device)
     * }
     */
    public static FunctionDescriptor clReleaseDevice$descriptor() {
        return clReleaseDevice.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern cl_int clReleaseDevice(cl_device_id device)
     * }
     */
    public static MethodHandle clReleaseDevice$handle() {
        return clReleaseDevice.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern cl_int clReleaseDevice(cl_device_id device)
     * }
     */
    public static int clReleaseDevice(MemorySegment device) {
        var mh$ = clReleaseDevice.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clReleaseDevice", device);
            }
            return (int)mh$.invokeExact(device);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clSetDefaultDeviceCommandQueue {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("clSetDefaultDeviceCommandQueue"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern cl_int clSetDefaultDeviceCommandQueue(cl_context context, cl_device_id device, cl_command_queue command_queue)
     * }
     */
    public static FunctionDescriptor clSetDefaultDeviceCommandQueue$descriptor() {
        return clSetDefaultDeviceCommandQueue.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern cl_int clSetDefaultDeviceCommandQueue(cl_context context, cl_device_id device, cl_command_queue command_queue)
     * }
     */
    public static MethodHandle clSetDefaultDeviceCommandQueue$handle() {
        return clSetDefaultDeviceCommandQueue.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern cl_int clSetDefaultDeviceCommandQueue(cl_context context, cl_device_id device, cl_command_queue command_queue)
     * }
     */
    public static int clSetDefaultDeviceCommandQueue(MemorySegment context, MemorySegment device, MemorySegment command_queue) {
        var mh$ = clSetDefaultDeviceCommandQueue.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clSetDefaultDeviceCommandQueue", context, device, command_queue);
            }
            return (int)mh$.invokeExact(context, device, command_queue);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clGetDeviceAndHostTimer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("clGetDeviceAndHostTimer"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern cl_int clGetDeviceAndHostTimer(cl_device_id device, cl_ulong *device_timestamp, cl_ulong *host_timestamp)
     * }
     */
    public static FunctionDescriptor clGetDeviceAndHostTimer$descriptor() {
        return clGetDeviceAndHostTimer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern cl_int clGetDeviceAndHostTimer(cl_device_id device, cl_ulong *device_timestamp, cl_ulong *host_timestamp)
     * }
     */
    public static MethodHandle clGetDeviceAndHostTimer$handle() {
        return clGetDeviceAndHostTimer.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern cl_int clGetDeviceAndHostTimer(cl_device_id device, cl_ulong *device_timestamp, cl_ulong *host_timestamp)
     * }
     */
    public static int clGetDeviceAndHostTimer(MemorySegment device, MemorySegment device_timestamp, MemorySegment host_timestamp) {
        var mh$ = clGetDeviceAndHostTimer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clGetDeviceAndHostTimer", device, device_timestamp, host_timestamp);
            }
            return (int)mh$.invokeExact(device, device_timestamp, host_timestamp);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clGetHostTimer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("clGetHostTimer"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern cl_int clGetHostTimer(cl_device_id device, cl_ulong *host_timestamp)
     * }
     */
    public static FunctionDescriptor clGetHostTimer$descriptor() {
        return clGetHostTimer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern cl_int clGetHostTimer(cl_device_id device, cl_ulong *host_timestamp)
     * }
     */
    public static MethodHandle clGetHostTimer$handle() {
        return clGetHostTimer.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern cl_int clGetHostTimer(cl_device_id device, cl_ulong *host_timestamp)
     * }
     */
    public static int clGetHostTimer(MemorySegment device, MemorySegment host_timestamp) {
        var mh$ = clGetHostTimer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clGetHostTimer", device, host_timestamp);
            }
            return (int)mh$.invokeExact(device, host_timestamp);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clCreateContext {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER,
            C_INT,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("clCreateContext"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern cl_context clCreateContext(const cl_context_properties *properties, cl_uint num_devices, const cl_device_id *devices, void (*pfn_notify)(const char *, const void *, size_t, void *) __attribute__((stdcall)), void *user_data, cl_int *errcode_ret)
     * }
     */
    public static FunctionDescriptor clCreateContext$descriptor() {
        return clCreateContext.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern cl_context clCreateContext(const cl_context_properties *properties, cl_uint num_devices, const cl_device_id *devices, void (*pfn_notify)(const char *, const void *, size_t, void *) __attribute__((stdcall)), void *user_data, cl_int *errcode_ret)
     * }
     */
    public static MethodHandle clCreateContext$handle() {
        return clCreateContext.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern cl_context clCreateContext(const cl_context_properties *properties, cl_uint num_devices, const cl_device_id *devices, void (*pfn_notify)(const char *, const void *, size_t, void *) __attribute__((stdcall)), void *user_data, cl_int *errcode_ret)
     * }
     */
    public static MemorySegment clCreateContext(MemorySegment properties, int num_devices, MemorySegment devices, MemorySegment pfn_notify, MemorySegment user_data, MemorySegment errcode_ret) {
        var mh$ = clCreateContext.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clCreateContext", properties, num_devices, devices, pfn_notify, user_data, errcode_ret);
            }
            return (MemorySegment)mh$.invokeExact(properties, num_devices, devices, pfn_notify, user_data, errcode_ret);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clCreateContextFromType {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER,
            C_LONG_LONG,
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("clCreateContextFromType"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern cl_context clCreateContextFromType(const cl_context_properties *properties, cl_device_type device_type, void (*pfn_notify)(const char *, const void *, size_t, void *) __attribute__((stdcall)), void *user_data, cl_int *errcode_ret)
     * }
     */
    public static FunctionDescriptor clCreateContextFromType$descriptor() {
        return clCreateContextFromType.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern cl_context clCreateContextFromType(const cl_context_properties *properties, cl_device_type device_type, void (*pfn_notify)(const char *, const void *, size_t, void *) __attribute__((stdcall)), void *user_data, cl_int *errcode_ret)
     * }
     */
    public static MethodHandle clCreateContextFromType$handle() {
        return clCreateContextFromType.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern cl_context clCreateContextFromType(const cl_context_properties *properties, cl_device_type device_type, void (*pfn_notify)(const char *, const void *, size_t, void *) __attribute__((stdcall)), void *user_data, cl_int *errcode_ret)
     * }
     */
    public static MemorySegment clCreateContextFromType(MemorySegment properties, long device_type, MemorySegment pfn_notify, MemorySegment user_data, MemorySegment errcode_ret) {
        var mh$ = clCreateContextFromType.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clCreateContextFromType", properties, device_type, pfn_notify, user_data, errcode_ret);
            }
            return (MemorySegment)mh$.invokeExact(properties, device_type, pfn_notify, user_data, errcode_ret);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clRetainContext {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("clRetainContext"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern cl_int clRetainContext(cl_context context)
     * }
     */
    public static FunctionDescriptor clRetainContext$descriptor() {
        return clRetainContext.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern cl_int clRetainContext(cl_context context)
     * }
     */
    public static MethodHandle clRetainContext$handle() {
        return clRetainContext.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern cl_int clRetainContext(cl_context context)
     * }
     */
    public static int clRetainContext(MemorySegment context) {
        var mh$ = clRetainContext.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clRetainContext", context);
            }
            return (int)mh$.invokeExact(context);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clReleaseContext {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("clReleaseContext"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern cl_int clReleaseContext(cl_context context)
     * }
     */
    public static FunctionDescriptor clReleaseContext$descriptor() {
        return clReleaseContext.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern cl_int clReleaseContext(cl_context context)
     * }
     */
    public static MethodHandle clReleaseContext$handle() {
        return clReleaseContext.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern cl_int clReleaseContext(cl_context context)
     * }
     */
    public static int clReleaseContext(MemorySegment context) {
        var mh$ = clReleaseContext.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clReleaseContext", context);
            }
            return (int)mh$.invokeExact(context);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clGetContextInfo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_INT,
            C_LONG_LONG,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("clGetContextInfo"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern cl_int clGetContextInfo(cl_context context, cl_context_info param_name, size_t param_value_size, void *param_value, size_t *param_value_size_ret)
     * }
     */
    public static FunctionDescriptor clGetContextInfo$descriptor() {
        return clGetContextInfo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern cl_int clGetContextInfo(cl_context context, cl_context_info param_name, size_t param_value_size, void *param_value, size_t *param_value_size_ret)
     * }
     */
    public static MethodHandle clGetContextInfo$handle() {
        return clGetContextInfo.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern cl_int clGetContextInfo(cl_context context, cl_context_info param_name, size_t param_value_size, void *param_value, size_t *param_value_size_ret)
     * }
     */
    public static int clGetContextInfo(MemorySegment context, int param_name, long param_value_size, MemorySegment param_value, MemorySegment param_value_size_ret) {
        var mh$ = clGetContextInfo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clGetContextInfo", context, param_name, param_value_size, param_value, param_value_size_ret);
            }
            return (int)mh$.invokeExact(context, param_name, param_value_size, param_value, param_value_size_ret);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clSetContextDestructorCallback {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("clSetContextDestructorCallback"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern cl_int clSetContextDestructorCallback(cl_context context, void (*pfn_notify)(cl_context, void *) __attribute__((stdcall)), void *user_data)
     * }
     */
    public static FunctionDescriptor clSetContextDestructorCallback$descriptor() {
        return clSetContextDestructorCallback.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern cl_int clSetContextDestructorCallback(cl_context context, void (*pfn_notify)(cl_context, void *) __attribute__((stdcall)), void *user_data)
     * }
     */
    public static MethodHandle clSetContextDestructorCallback$handle() {
        return clSetContextDestructorCallback.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern cl_int clSetContextDestructorCallback(cl_context context, void (*pfn_notify)(cl_context, void *) __attribute__((stdcall)), void *user_data)
     * }
     */
    public static int clSetContextDestructorCallback(MemorySegment context, MemorySegment pfn_notify, MemorySegment user_data) {
        var mh$ = clSetContextDestructorCallback.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clSetContextDestructorCallback", context, pfn_notify, user_data);
            }
            return (int)mh$.invokeExact(context, pfn_notify, user_data);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clCreateCommandQueueWithProperties {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("clCreateCommandQueueWithProperties"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern cl_command_queue clCreateCommandQueueWithProperties(cl_context context, cl_device_id device, const cl_queue_properties *properties, cl_int *errcode_ret)
     * }
     */
    public static FunctionDescriptor clCreateCommandQueueWithProperties$descriptor() {
        return clCreateCommandQueueWithProperties.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern cl_command_queue clCreateCommandQueueWithProperties(cl_context context, cl_device_id device, const cl_queue_properties *properties, cl_int *errcode_ret)
     * }
     */
    public static MethodHandle clCreateCommandQueueWithProperties$handle() {
        return clCreateCommandQueueWithProperties.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern cl_command_queue clCreateCommandQueueWithProperties(cl_context context, cl_device_id device, const cl_queue_properties *properties, cl_int *errcode_ret)
     * }
     */
    public static MemorySegment clCreateCommandQueueWithProperties(MemorySegment context, MemorySegment device, MemorySegment properties, MemorySegment errcode_ret) {
        var mh$ = clCreateCommandQueueWithProperties.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clCreateCommandQueueWithProperties", context, device, properties, errcode_ret);
            }
            return (MemorySegment)mh$.invokeExact(context, device, properties, errcode_ret);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clRetainCommandQueue {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("clRetainCommandQueue"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern cl_int clRetainCommandQueue(cl_command_queue command_queue)
     * }
     */
    public static FunctionDescriptor clRetainCommandQueue$descriptor() {
        return clRetainCommandQueue.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern cl_int clRetainCommandQueue(cl_command_queue command_queue)
     * }
     */
    public static MethodHandle clRetainCommandQueue$handle() {
        return clRetainCommandQueue.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern cl_int clRetainCommandQueue(cl_command_queue command_queue)
     * }
     */
    public static int clRetainCommandQueue(MemorySegment command_queue) {
        var mh$ = clRetainCommandQueue.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clRetainCommandQueue", command_queue);
            }
            return (int)mh$.invokeExact(command_queue);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clReleaseCommandQueue {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("clReleaseCommandQueue"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern cl_int clReleaseCommandQueue(cl_command_queue command_queue)
     * }
     */
    public static FunctionDescriptor clReleaseCommandQueue$descriptor() {
        return clReleaseCommandQueue.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern cl_int clReleaseCommandQueue(cl_command_queue command_queue)
     * }
     */
    public static MethodHandle clReleaseCommandQueue$handle() {
        return clReleaseCommandQueue.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern cl_int clReleaseCommandQueue(cl_command_queue command_queue)
     * }
     */
    public static int clReleaseCommandQueue(MemorySegment command_queue) {
        var mh$ = clReleaseCommandQueue.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clReleaseCommandQueue", command_queue);
            }
            return (int)mh$.invokeExact(command_queue);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clGetCommandQueueInfo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_INT,
            C_LONG_LONG,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("clGetCommandQueueInfo"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern cl_int clGetCommandQueueInfo(cl_command_queue command_queue, cl_command_queue_info param_name, size_t param_value_size, void *param_value, size_t *param_value_size_ret)
     * }
     */
    public static FunctionDescriptor clGetCommandQueueInfo$descriptor() {
        return clGetCommandQueueInfo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern cl_int clGetCommandQueueInfo(cl_command_queue command_queue, cl_command_queue_info param_name, size_t param_value_size, void *param_value, size_t *param_value_size_ret)
     * }
     */
    public static MethodHandle clGetCommandQueueInfo$handle() {
        return clGetCommandQueueInfo.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern cl_int clGetCommandQueueInfo(cl_command_queue command_queue, cl_command_queue_info param_name, size_t param_value_size, void *param_value, size_t *param_value_size_ret)
     * }
     */
    public static int clGetCommandQueueInfo(MemorySegment command_queue, int param_name, long param_value_size, MemorySegment param_value, MemorySegment param_value_size_ret) {
        var mh$ = clGetCommandQueueInfo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clGetCommandQueueInfo", command_queue, param_name, param_value_size, param_value, param_value_size_ret);
            }
            return (int)mh$.invokeExact(command_queue, param_name, param_value_size, param_value, param_value_size_ret);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clCreateBuffer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER,
            C_LONG_LONG,
            C_LONG_LONG,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("clCreateBuffer"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern cl_mem clCreateBuffer(cl_context context, cl_mem_flags flags, size_t size, void *host_ptr, cl_int *errcode_ret)
     * }
     */
    public static FunctionDescriptor clCreateBuffer$descriptor() {
        return clCreateBuffer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern cl_mem clCreateBuffer(cl_context context, cl_mem_flags flags, size_t size, void *host_ptr, cl_int *errcode_ret)
     * }
     */
    public static MethodHandle clCreateBuffer$handle() {
        return clCreateBuffer.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern cl_mem clCreateBuffer(cl_context context, cl_mem_flags flags, size_t size, void *host_ptr, cl_int *errcode_ret)
     * }
     */
    public static MemorySegment clCreateBuffer(MemorySegment context, long flags, long size, MemorySegment host_ptr, MemorySegment errcode_ret) {
        var mh$ = clCreateBuffer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clCreateBuffer", context, flags, size, host_ptr, errcode_ret);
            }
            return (MemorySegment)mh$.invokeExact(context, flags, size, host_ptr, errcode_ret);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clCreateSubBuffer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER,
            C_LONG_LONG,
            C_INT,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("clCreateSubBuffer"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern cl_mem clCreateSubBuffer(cl_mem buffer, cl_mem_flags flags, cl_buffer_create_type buffer_create_type, const void *buffer_create_info, cl_int *errcode_ret)
     * }
     */
    public static FunctionDescriptor clCreateSubBuffer$descriptor() {
        return clCreateSubBuffer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern cl_mem clCreateSubBuffer(cl_mem buffer, cl_mem_flags flags, cl_buffer_create_type buffer_create_type, const void *buffer_create_info, cl_int *errcode_ret)
     * }
     */
    public static MethodHandle clCreateSubBuffer$handle() {
        return clCreateSubBuffer.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern cl_mem clCreateSubBuffer(cl_mem buffer, cl_mem_flags flags, cl_buffer_create_type buffer_create_type, const void *buffer_create_info, cl_int *errcode_ret)
     * }
     */
    public static MemorySegment clCreateSubBuffer(MemorySegment buffer, long flags, int buffer_create_type, MemorySegment buffer_create_info, MemorySegment errcode_ret) {
        var mh$ = clCreateSubBuffer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clCreateSubBuffer", buffer, flags, buffer_create_type, buffer_create_info, errcode_ret);
            }
            return (MemorySegment)mh$.invokeExact(buffer, flags, buffer_create_type, buffer_create_info, errcode_ret);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clCreateImage {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER,
            C_LONG_LONG,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("clCreateImage"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern cl_mem clCreateImage(cl_context context, cl_mem_flags flags, const cl_image_format *image_format, const cl_image_desc *image_desc, void *host_ptr, cl_int *errcode_ret)
     * }
     */
    public static FunctionDescriptor clCreateImage$descriptor() {
        return clCreateImage.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern cl_mem clCreateImage(cl_context context, cl_mem_flags flags, const cl_image_format *image_format, const cl_image_desc *image_desc, void *host_ptr, cl_int *errcode_ret)
     * }
     */
    public static MethodHandle clCreateImage$handle() {
        return clCreateImage.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern cl_mem clCreateImage(cl_context context, cl_mem_flags flags, const cl_image_format *image_format, const cl_image_desc *image_desc, void *host_ptr, cl_int *errcode_ret)
     * }
     */
    public static MemorySegment clCreateImage(MemorySegment context, long flags, MemorySegment image_format, MemorySegment image_desc, MemorySegment host_ptr, MemorySegment errcode_ret) {
        var mh$ = clCreateImage.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clCreateImage", context, flags, image_format, image_desc, host_ptr, errcode_ret);
            }
            return (MemorySegment)mh$.invokeExact(context, flags, image_format, image_desc, host_ptr, errcode_ret);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clCreatePipe {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER,
            C_LONG_LONG,
            C_INT,
            C_INT,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("clCreatePipe"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern cl_mem clCreatePipe(cl_context context, cl_mem_flags flags, cl_uint pipe_packet_size, cl_uint pipe_max_packets, const cl_pipe_properties *properties, cl_int *errcode_ret)
     * }
     */
    public static FunctionDescriptor clCreatePipe$descriptor() {
        return clCreatePipe.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern cl_mem clCreatePipe(cl_context context, cl_mem_flags flags, cl_uint pipe_packet_size, cl_uint pipe_max_packets, const cl_pipe_properties *properties, cl_int *errcode_ret)
     * }
     */
    public static MethodHandle clCreatePipe$handle() {
        return clCreatePipe.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern cl_mem clCreatePipe(cl_context context, cl_mem_flags flags, cl_uint pipe_packet_size, cl_uint pipe_max_packets, const cl_pipe_properties *properties, cl_int *errcode_ret)
     * }
     */
    public static MemorySegment clCreatePipe(MemorySegment context, long flags, int pipe_packet_size, int pipe_max_packets, MemorySegment properties, MemorySegment errcode_ret) {
        var mh$ = clCreatePipe.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clCreatePipe", context, flags, pipe_packet_size, pipe_max_packets, properties, errcode_ret);
            }
            return (MemorySegment)mh$.invokeExact(context, flags, pipe_packet_size, pipe_max_packets, properties, errcode_ret);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clCreateBufferWithProperties {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_LONG_LONG,
            C_LONG_LONG,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("clCreateBufferWithProperties"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern cl_mem clCreateBufferWithProperties(cl_context context, const cl_mem_properties *properties, cl_mem_flags flags, size_t size, void *host_ptr, cl_int *errcode_ret)
     * }
     */
    public static FunctionDescriptor clCreateBufferWithProperties$descriptor() {
        return clCreateBufferWithProperties.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern cl_mem clCreateBufferWithProperties(cl_context context, const cl_mem_properties *properties, cl_mem_flags flags, size_t size, void *host_ptr, cl_int *errcode_ret)
     * }
     */
    public static MethodHandle clCreateBufferWithProperties$handle() {
        return clCreateBufferWithProperties.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern cl_mem clCreateBufferWithProperties(cl_context context, const cl_mem_properties *properties, cl_mem_flags flags, size_t size, void *host_ptr, cl_int *errcode_ret)
     * }
     */
    public static MemorySegment clCreateBufferWithProperties(MemorySegment context, MemorySegment properties, long flags, long size, MemorySegment host_ptr, MemorySegment errcode_ret) {
        var mh$ = clCreateBufferWithProperties.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clCreateBufferWithProperties", context, properties, flags, size, host_ptr, errcode_ret);
            }
            return (MemorySegment)mh$.invokeExact(context, properties, flags, size, host_ptr, errcode_ret);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clCreateImageWithProperties {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_LONG_LONG,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("clCreateImageWithProperties"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern cl_mem clCreateImageWithProperties(cl_context context, const cl_mem_properties *properties, cl_mem_flags flags, const cl_image_format *image_format, const cl_image_desc *image_desc, void *host_ptr, cl_int *errcode_ret)
     * }
     */
    public static FunctionDescriptor clCreateImageWithProperties$descriptor() {
        return clCreateImageWithProperties.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern cl_mem clCreateImageWithProperties(cl_context context, const cl_mem_properties *properties, cl_mem_flags flags, const cl_image_format *image_format, const cl_image_desc *image_desc, void *host_ptr, cl_int *errcode_ret)
     * }
     */
    public static MethodHandle clCreateImageWithProperties$handle() {
        return clCreateImageWithProperties.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern cl_mem clCreateImageWithProperties(cl_context context, const cl_mem_properties *properties, cl_mem_flags flags, const cl_image_format *image_format, const cl_image_desc *image_desc, void *host_ptr, cl_int *errcode_ret)
     * }
     */
    public static MemorySegment clCreateImageWithProperties(MemorySegment context, MemorySegment properties, long flags, MemorySegment image_format, MemorySegment image_desc, MemorySegment host_ptr, MemorySegment errcode_ret) {
        var mh$ = clCreateImageWithProperties.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clCreateImageWithProperties", context, properties, flags, image_format, image_desc, host_ptr, errcode_ret);
            }
            return (MemorySegment)mh$.invokeExact(context, properties, flags, image_format, image_desc, host_ptr, errcode_ret);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clRetainMemObject {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("clRetainMemObject"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern cl_int clRetainMemObject(cl_mem memobj)
     * }
     */
    public static FunctionDescriptor clRetainMemObject$descriptor() {
        return clRetainMemObject.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern cl_int clRetainMemObject(cl_mem memobj)
     * }
     */
    public static MethodHandle clRetainMemObject$handle() {
        return clRetainMemObject.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern cl_int clRetainMemObject(cl_mem memobj)
     * }
     */
    public static int clRetainMemObject(MemorySegment memobj) {
        var mh$ = clRetainMemObject.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clRetainMemObject", memobj);
            }
            return (int)mh$.invokeExact(memobj);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clReleaseMemObject {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("clReleaseMemObject"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern cl_int clReleaseMemObject(cl_mem memobj)
     * }
     */
    public static FunctionDescriptor clReleaseMemObject$descriptor() {
        return clReleaseMemObject.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern cl_int clReleaseMemObject(cl_mem memobj)
     * }
     */
    public static MethodHandle clReleaseMemObject$handle() {
        return clReleaseMemObject.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern cl_int clReleaseMemObject(cl_mem memobj)
     * }
     */
    public static int clReleaseMemObject(MemorySegment memobj) {
        var mh$ = clReleaseMemObject.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clReleaseMemObject", memobj);
            }
            return (int)mh$.invokeExact(memobj);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clGetSupportedImageFormats {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_LONG_LONG,
            C_INT,
            C_INT,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("clGetSupportedImageFormats"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern cl_int clGetSupportedImageFormats(cl_context context, cl_mem_flags flags, cl_mem_object_type image_type, cl_uint num_entries, cl_image_format *image_formats, cl_uint *num_image_formats)
     * }
     */
    public static FunctionDescriptor clGetSupportedImageFormats$descriptor() {
        return clGetSupportedImageFormats.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern cl_int clGetSupportedImageFormats(cl_context context, cl_mem_flags flags, cl_mem_object_type image_type, cl_uint num_entries, cl_image_format *image_formats, cl_uint *num_image_formats)
     * }
     */
    public static MethodHandle clGetSupportedImageFormats$handle() {
        return clGetSupportedImageFormats.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern cl_int clGetSupportedImageFormats(cl_context context, cl_mem_flags flags, cl_mem_object_type image_type, cl_uint num_entries, cl_image_format *image_formats, cl_uint *num_image_formats)
     * }
     */
    public static int clGetSupportedImageFormats(MemorySegment context, long flags, int image_type, int num_entries, MemorySegment image_formats, MemorySegment num_image_formats) {
        var mh$ = clGetSupportedImageFormats.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clGetSupportedImageFormats", context, flags, image_type, num_entries, image_formats, num_image_formats);
            }
            return (int)mh$.invokeExact(context, flags, image_type, num_entries, image_formats, num_image_formats);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clGetMemObjectInfo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_INT,
            C_LONG_LONG,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("clGetMemObjectInfo"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern cl_int clGetMemObjectInfo(cl_mem memobj, cl_mem_info param_name, size_t param_value_size, void *param_value, size_t *param_value_size_ret)
     * }
     */
    public static FunctionDescriptor clGetMemObjectInfo$descriptor() {
        return clGetMemObjectInfo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern cl_int clGetMemObjectInfo(cl_mem memobj, cl_mem_info param_name, size_t param_value_size, void *param_value, size_t *param_value_size_ret)
     * }
     */
    public static MethodHandle clGetMemObjectInfo$handle() {
        return clGetMemObjectInfo.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern cl_int clGetMemObjectInfo(cl_mem memobj, cl_mem_info param_name, size_t param_value_size, void *param_value, size_t *param_value_size_ret)
     * }
     */
    public static int clGetMemObjectInfo(MemorySegment memobj, int param_name, long param_value_size, MemorySegment param_value, MemorySegment param_value_size_ret) {
        var mh$ = clGetMemObjectInfo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clGetMemObjectInfo", memobj, param_name, param_value_size, param_value, param_value_size_ret);
            }
            return (int)mh$.invokeExact(memobj, param_name, param_value_size, param_value, param_value_size_ret);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clGetImageInfo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_INT,
            C_LONG_LONG,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("clGetImageInfo"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern cl_int clGetImageInfo(cl_mem image, cl_image_info param_name, size_t param_value_size, void *param_value, size_t *param_value_size_ret)
     * }
     */
    public static FunctionDescriptor clGetImageInfo$descriptor() {
        return clGetImageInfo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern cl_int clGetImageInfo(cl_mem image, cl_image_info param_name, size_t param_value_size, void *param_value, size_t *param_value_size_ret)
     * }
     */
    public static MethodHandle clGetImageInfo$handle() {
        return clGetImageInfo.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern cl_int clGetImageInfo(cl_mem image, cl_image_info param_name, size_t param_value_size, void *param_value, size_t *param_value_size_ret)
     * }
     */
    public static int clGetImageInfo(MemorySegment image, int param_name, long param_value_size, MemorySegment param_value, MemorySegment param_value_size_ret) {
        var mh$ = clGetImageInfo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clGetImageInfo", image, param_name, param_value_size, param_value, param_value_size_ret);
            }
            return (int)mh$.invokeExact(image, param_name, param_value_size, param_value, param_value_size_ret);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clGetPipeInfo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_INT,
            C_LONG_LONG,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("clGetPipeInfo"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern cl_int clGetPipeInfo(cl_mem pipe, cl_pipe_info param_name, size_t param_value_size, void *param_value, size_t *param_value_size_ret)
     * }
     */
    public static FunctionDescriptor clGetPipeInfo$descriptor() {
        return clGetPipeInfo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern cl_int clGetPipeInfo(cl_mem pipe, cl_pipe_info param_name, size_t param_value_size, void *param_value, size_t *param_value_size_ret)
     * }
     */
    public static MethodHandle clGetPipeInfo$handle() {
        return clGetPipeInfo.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern cl_int clGetPipeInfo(cl_mem pipe, cl_pipe_info param_name, size_t param_value_size, void *param_value, size_t *param_value_size_ret)
     * }
     */
    public static int clGetPipeInfo(MemorySegment pipe, int param_name, long param_value_size, MemorySegment param_value, MemorySegment param_value_size_ret) {
        var mh$ = clGetPipeInfo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clGetPipeInfo", pipe, param_name, param_value_size, param_value, param_value_size_ret);
            }
            return (int)mh$.invokeExact(pipe, param_name, param_value_size, param_value, param_value_size_ret);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clSetMemObjectDestructorCallback {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("clSetMemObjectDestructorCallback"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern cl_int clSetMemObjectDestructorCallback(cl_mem memobj, void (*pfn_notify)(cl_mem, void *) __attribute__((stdcall)), void *user_data)
     * }
     */
    public static FunctionDescriptor clSetMemObjectDestructorCallback$descriptor() {
        return clSetMemObjectDestructorCallback.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern cl_int clSetMemObjectDestructorCallback(cl_mem memobj, void (*pfn_notify)(cl_mem, void *) __attribute__((stdcall)), void *user_data)
     * }
     */
    public static MethodHandle clSetMemObjectDestructorCallback$handle() {
        return clSetMemObjectDestructorCallback.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern cl_int clSetMemObjectDestructorCallback(cl_mem memobj, void (*pfn_notify)(cl_mem, void *) __attribute__((stdcall)), void *user_data)
     * }
     */
    public static int clSetMemObjectDestructorCallback(MemorySegment memobj, MemorySegment pfn_notify, MemorySegment user_data) {
        var mh$ = clSetMemObjectDestructorCallback.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clSetMemObjectDestructorCallback", memobj, pfn_notify, user_data);
            }
            return (int)mh$.invokeExact(memobj, pfn_notify, user_data);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clSVMAlloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER,
            C_LONG_LONG,
            C_LONG_LONG,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("clSVMAlloc"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void *clSVMAlloc(cl_context context, cl_svm_mem_flags flags, size_t size, cl_uint alignment)
     * }
     */
    public static FunctionDescriptor clSVMAlloc$descriptor() {
        return clSVMAlloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void *clSVMAlloc(cl_context context, cl_svm_mem_flags flags, size_t size, cl_uint alignment)
     * }
     */
    public static MethodHandle clSVMAlloc$handle() {
        return clSVMAlloc.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern void *clSVMAlloc(cl_context context, cl_svm_mem_flags flags, size_t size, cl_uint alignment)
     * }
     */
    public static MemorySegment clSVMAlloc(MemorySegment context, long flags, long size, int alignment) {
        var mh$ = clSVMAlloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clSVMAlloc", context, flags, size, alignment);
            }
            return (MemorySegment)mh$.invokeExact(context, flags, size, alignment);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clSVMFree {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("clSVMFree"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void clSVMFree(cl_context context, void *svm_pointer)
     * }
     */
    public static FunctionDescriptor clSVMFree$descriptor() {
        return clSVMFree.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void clSVMFree(cl_context context, void *svm_pointer)
     * }
     */
    public static MethodHandle clSVMFree$handle() {
        return clSVMFree.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern void clSVMFree(cl_context context, void *svm_pointer)
     * }
     */
    public static void clSVMFree(MemorySegment context, MemorySegment svm_pointer) {
        var mh$ = clSVMFree.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clSVMFree", context, svm_pointer);
            }
            mh$.invokeExact(context, svm_pointer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clCreateSamplerWithProperties {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("clCreateSamplerWithProperties"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern cl_sampler clCreateSamplerWithProperties(cl_context context, const cl_sampler_properties *sampler_properties, cl_int *errcode_ret)
     * }
     */
    public static FunctionDescriptor clCreateSamplerWithProperties$descriptor() {
        return clCreateSamplerWithProperties.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern cl_sampler clCreateSamplerWithProperties(cl_context context, const cl_sampler_properties *sampler_properties, cl_int *errcode_ret)
     * }
     */
    public static MethodHandle clCreateSamplerWithProperties$handle() {
        return clCreateSamplerWithProperties.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern cl_sampler clCreateSamplerWithProperties(cl_context context, const cl_sampler_properties *sampler_properties, cl_int *errcode_ret)
     * }
     */
    public static MemorySegment clCreateSamplerWithProperties(MemorySegment context, MemorySegment sampler_properties, MemorySegment errcode_ret) {
        var mh$ = clCreateSamplerWithProperties.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clCreateSamplerWithProperties", context, sampler_properties, errcode_ret);
            }
            return (MemorySegment)mh$.invokeExact(context, sampler_properties, errcode_ret);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clRetainSampler {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("clRetainSampler"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern cl_int clRetainSampler(cl_sampler sampler)
     * }
     */
    public static FunctionDescriptor clRetainSampler$descriptor() {
        return clRetainSampler.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern cl_int clRetainSampler(cl_sampler sampler)
     * }
     */
    public static MethodHandle clRetainSampler$handle() {
        return clRetainSampler.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern cl_int clRetainSampler(cl_sampler sampler)
     * }
     */
    public static int clRetainSampler(MemorySegment sampler) {
        var mh$ = clRetainSampler.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clRetainSampler", sampler);
            }
            return (int)mh$.invokeExact(sampler);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clReleaseSampler {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("clReleaseSampler"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern cl_int clReleaseSampler(cl_sampler sampler)
     * }
     */
    public static FunctionDescriptor clReleaseSampler$descriptor() {
        return clReleaseSampler.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern cl_int clReleaseSampler(cl_sampler sampler)
     * }
     */
    public static MethodHandle clReleaseSampler$handle() {
        return clReleaseSampler.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern cl_int clReleaseSampler(cl_sampler sampler)
     * }
     */
    public static int clReleaseSampler(MemorySegment sampler) {
        var mh$ = clReleaseSampler.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clReleaseSampler", sampler);
            }
            return (int)mh$.invokeExact(sampler);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clGetSamplerInfo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_INT,
            C_LONG_LONG,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("clGetSamplerInfo"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern cl_int clGetSamplerInfo(cl_sampler sampler, cl_sampler_info param_name, size_t param_value_size, void *param_value, size_t *param_value_size_ret)
     * }
     */
    public static FunctionDescriptor clGetSamplerInfo$descriptor() {
        return clGetSamplerInfo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern cl_int clGetSamplerInfo(cl_sampler sampler, cl_sampler_info param_name, size_t param_value_size, void *param_value, size_t *param_value_size_ret)
     * }
     */
    public static MethodHandle clGetSamplerInfo$handle() {
        return clGetSamplerInfo.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern cl_int clGetSamplerInfo(cl_sampler sampler, cl_sampler_info param_name, size_t param_value_size, void *param_value, size_t *param_value_size_ret)
     * }
     */
    public static int clGetSamplerInfo(MemorySegment sampler, int param_name, long param_value_size, MemorySegment param_value, MemorySegment param_value_size_ret) {
        var mh$ = clGetSamplerInfo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clGetSamplerInfo", sampler, param_name, param_value_size, param_value, param_value_size_ret);
            }
            return (int)mh$.invokeExact(sampler, param_name, param_value_size, param_value, param_value_size_ret);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clCreateProgramWithSource {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER,
            C_INT,
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("clCreateProgramWithSource"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern cl_program clCreateProgramWithSource(cl_context context, cl_uint count, const char **strings, const size_t *lengths, cl_int *errcode_ret)
     * }
     */
    public static FunctionDescriptor clCreateProgramWithSource$descriptor() {
        return clCreateProgramWithSource.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern cl_program clCreateProgramWithSource(cl_context context, cl_uint count, const char **strings, const size_t *lengths, cl_int *errcode_ret)
     * }
     */
    public static MethodHandle clCreateProgramWithSource$handle() {
        return clCreateProgramWithSource.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern cl_program clCreateProgramWithSource(cl_context context, cl_uint count, const char **strings, const size_t *lengths, cl_int *errcode_ret)
     * }
     */
    public static MemorySegment clCreateProgramWithSource(MemorySegment context, int count, MemorySegment strings, MemorySegment lengths, MemorySegment errcode_ret) {
        var mh$ = clCreateProgramWithSource.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clCreateProgramWithSource", context, count, strings, lengths, errcode_ret);
            }
            return (MemorySegment)mh$.invokeExact(context, count, strings, lengths, errcode_ret);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clCreateProgramWithBinary {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER,
            C_INT,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("clCreateProgramWithBinary"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern cl_program clCreateProgramWithBinary(cl_context context, cl_uint num_devices, const cl_device_id *device_list, const size_t *lengths, const unsigned char **binaries, cl_int *binary_status, cl_int *errcode_ret)
     * }
     */
    public static FunctionDescriptor clCreateProgramWithBinary$descriptor() {
        return clCreateProgramWithBinary.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern cl_program clCreateProgramWithBinary(cl_context context, cl_uint num_devices, const cl_device_id *device_list, const size_t *lengths, const unsigned char **binaries, cl_int *binary_status, cl_int *errcode_ret)
     * }
     */
    public static MethodHandle clCreateProgramWithBinary$handle() {
        return clCreateProgramWithBinary.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern cl_program clCreateProgramWithBinary(cl_context context, cl_uint num_devices, const cl_device_id *device_list, const size_t *lengths, const unsigned char **binaries, cl_int *binary_status, cl_int *errcode_ret)
     * }
     */
    public static MemorySegment clCreateProgramWithBinary(MemorySegment context, int num_devices, MemorySegment device_list, MemorySegment lengths, MemorySegment binaries, MemorySegment binary_status, MemorySegment errcode_ret) {
        var mh$ = clCreateProgramWithBinary.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clCreateProgramWithBinary", context, num_devices, device_list, lengths, binaries, binary_status, errcode_ret);
            }
            return (MemorySegment)mh$.invokeExact(context, num_devices, device_list, lengths, binaries, binary_status, errcode_ret);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clCreateProgramWithBuiltInKernels {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER,
            C_INT,
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("clCreateProgramWithBuiltInKernels"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern cl_program clCreateProgramWithBuiltInKernels(cl_context context, cl_uint num_devices, const cl_device_id *device_list, const char *kernel_names, cl_int *errcode_ret)
     * }
     */
    public static FunctionDescriptor clCreateProgramWithBuiltInKernels$descriptor() {
        return clCreateProgramWithBuiltInKernels.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern cl_program clCreateProgramWithBuiltInKernels(cl_context context, cl_uint num_devices, const cl_device_id *device_list, const char *kernel_names, cl_int *errcode_ret)
     * }
     */
    public static MethodHandle clCreateProgramWithBuiltInKernels$handle() {
        return clCreateProgramWithBuiltInKernels.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern cl_program clCreateProgramWithBuiltInKernels(cl_context context, cl_uint num_devices, const cl_device_id *device_list, const char *kernel_names, cl_int *errcode_ret)
     * }
     */
    public static MemorySegment clCreateProgramWithBuiltInKernels(MemorySegment context, int num_devices, MemorySegment device_list, MemorySegment kernel_names, MemorySegment errcode_ret) {
        var mh$ = clCreateProgramWithBuiltInKernels.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clCreateProgramWithBuiltInKernels", context, num_devices, device_list, kernel_names, errcode_ret);
            }
            return (MemorySegment)mh$.invokeExact(context, num_devices, device_list, kernel_names, errcode_ret);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clCreateProgramWithIL {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_LONG_LONG,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("clCreateProgramWithIL"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern cl_program clCreateProgramWithIL(cl_context context, const void *il, size_t length, cl_int *errcode_ret)
     * }
     */
    public static FunctionDescriptor clCreateProgramWithIL$descriptor() {
        return clCreateProgramWithIL.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern cl_program clCreateProgramWithIL(cl_context context, const void *il, size_t length, cl_int *errcode_ret)
     * }
     */
    public static MethodHandle clCreateProgramWithIL$handle() {
        return clCreateProgramWithIL.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern cl_program clCreateProgramWithIL(cl_context context, const void *il, size_t length, cl_int *errcode_ret)
     * }
     */
    public static MemorySegment clCreateProgramWithIL(MemorySegment context, MemorySegment il, long length, MemorySegment errcode_ret) {
        var mh$ = clCreateProgramWithIL.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clCreateProgramWithIL", context, il, length, errcode_ret);
            }
            return (MemorySegment)mh$.invokeExact(context, il, length, errcode_ret);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clRetainProgram {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("clRetainProgram"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern cl_int clRetainProgram(cl_program program)
     * }
     */
    public static FunctionDescriptor clRetainProgram$descriptor() {
        return clRetainProgram.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern cl_int clRetainProgram(cl_program program)
     * }
     */
    public static MethodHandle clRetainProgram$handle() {
        return clRetainProgram.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern cl_int clRetainProgram(cl_program program)
     * }
     */
    public static int clRetainProgram(MemorySegment program) {
        var mh$ = clRetainProgram.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clRetainProgram", program);
            }
            return (int)mh$.invokeExact(program);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clReleaseProgram {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("clReleaseProgram"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern cl_int clReleaseProgram(cl_program program)
     * }
     */
    public static FunctionDescriptor clReleaseProgram$descriptor() {
        return clReleaseProgram.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern cl_int clReleaseProgram(cl_program program)
     * }
     */
    public static MethodHandle clReleaseProgram$handle() {
        return clReleaseProgram.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern cl_int clReleaseProgram(cl_program program)
     * }
     */
    public static int clReleaseProgram(MemorySegment program) {
        var mh$ = clReleaseProgram.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clReleaseProgram", program);
            }
            return (int)mh$.invokeExact(program);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clBuildProgram {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_INT,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("clBuildProgram"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern cl_int clBuildProgram(cl_program program, cl_uint num_devices, const cl_device_id *device_list, const char *options, void (*pfn_notify)(cl_program, void *) __attribute__((stdcall)), void *user_data)
     * }
     */
    public static FunctionDescriptor clBuildProgram$descriptor() {
        return clBuildProgram.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern cl_int clBuildProgram(cl_program program, cl_uint num_devices, const cl_device_id *device_list, const char *options, void (*pfn_notify)(cl_program, void *) __attribute__((stdcall)), void *user_data)
     * }
     */
    public static MethodHandle clBuildProgram$handle() {
        return clBuildProgram.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern cl_int clBuildProgram(cl_program program, cl_uint num_devices, const cl_device_id *device_list, const char *options, void (*pfn_notify)(cl_program, void *) __attribute__((stdcall)), void *user_data)
     * }
     */
    public static int clBuildProgram(MemorySegment program, int num_devices, MemorySegment device_list, MemorySegment options, MemorySegment pfn_notify, MemorySegment user_data) {
        var mh$ = clBuildProgram.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clBuildProgram", program, num_devices, device_list, options, pfn_notify, user_data);
            }
            return (int)mh$.invokeExact(program, num_devices, device_list, options, pfn_notify, user_data);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clCompileProgram {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_INT,
            C_POINTER,
            C_POINTER,
            C_INT,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("clCompileProgram"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern cl_int clCompileProgram(cl_program program, cl_uint num_devices, const cl_device_id *device_list, const char *options, cl_uint num_input_headers, const cl_program *input_headers, const char **header_include_names, void (*pfn_notify)(cl_program, void *) __attribute__((stdcall)), void *user_data)
     * }
     */
    public static FunctionDescriptor clCompileProgram$descriptor() {
        return clCompileProgram.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern cl_int clCompileProgram(cl_program program, cl_uint num_devices, const cl_device_id *device_list, const char *options, cl_uint num_input_headers, const cl_program *input_headers, const char **header_include_names, void (*pfn_notify)(cl_program, void *) __attribute__((stdcall)), void *user_data)
     * }
     */
    public static MethodHandle clCompileProgram$handle() {
        return clCompileProgram.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern cl_int clCompileProgram(cl_program program, cl_uint num_devices, const cl_device_id *device_list, const char *options, cl_uint num_input_headers, const cl_program *input_headers, const char **header_include_names, void (*pfn_notify)(cl_program, void *) __attribute__((stdcall)), void *user_data)
     * }
     */
    public static int clCompileProgram(MemorySegment program, int num_devices, MemorySegment device_list, MemorySegment options, int num_input_headers, MemorySegment input_headers, MemorySegment header_include_names, MemorySegment pfn_notify, MemorySegment user_data) {
        var mh$ = clCompileProgram.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clCompileProgram", program, num_devices, device_list, options, num_input_headers, input_headers, header_include_names, pfn_notify, user_data);
            }
            return (int)mh$.invokeExact(program, num_devices, device_list, options, num_input_headers, input_headers, header_include_names, pfn_notify, user_data);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clLinkProgram {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER,
            C_INT,
            C_POINTER,
            C_POINTER,
            C_INT,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("clLinkProgram"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern cl_program clLinkProgram(cl_context context, cl_uint num_devices, const cl_device_id *device_list, const char *options, cl_uint num_input_programs, const cl_program *input_programs, void (*pfn_notify)(cl_program, void *) __attribute__((stdcall)), void *user_data, cl_int *errcode_ret)
     * }
     */
    public static FunctionDescriptor clLinkProgram$descriptor() {
        return clLinkProgram.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern cl_program clLinkProgram(cl_context context, cl_uint num_devices, const cl_device_id *device_list, const char *options, cl_uint num_input_programs, const cl_program *input_programs, void (*pfn_notify)(cl_program, void *) __attribute__((stdcall)), void *user_data, cl_int *errcode_ret)
     * }
     */
    public static MethodHandle clLinkProgram$handle() {
        return clLinkProgram.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern cl_program clLinkProgram(cl_context context, cl_uint num_devices, const cl_device_id *device_list, const char *options, cl_uint num_input_programs, const cl_program *input_programs, void (*pfn_notify)(cl_program, void *) __attribute__((stdcall)), void *user_data, cl_int *errcode_ret)
     * }
     */
    public static MemorySegment clLinkProgram(MemorySegment context, int num_devices, MemorySegment device_list, MemorySegment options, int num_input_programs, MemorySegment input_programs, MemorySegment pfn_notify, MemorySegment user_data, MemorySegment errcode_ret) {
        var mh$ = clLinkProgram.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clLinkProgram", context, num_devices, device_list, options, num_input_programs, input_programs, pfn_notify, user_data, errcode_ret);
            }
            return (MemorySegment)mh$.invokeExact(context, num_devices, device_list, options, num_input_programs, input_programs, pfn_notify, user_data, errcode_ret);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clSetProgramReleaseCallback {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("clSetProgramReleaseCallback"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern cl_int clSetProgramReleaseCallback(cl_program program, void (*pfn_notify)(cl_program, void *) __attribute__((stdcall)), void *user_data)
     * }
     */
    public static FunctionDescriptor clSetProgramReleaseCallback$descriptor() {
        return clSetProgramReleaseCallback.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern cl_int clSetProgramReleaseCallback(cl_program program, void (*pfn_notify)(cl_program, void *) __attribute__((stdcall)), void *user_data)
     * }
     */
    public static MethodHandle clSetProgramReleaseCallback$handle() {
        return clSetProgramReleaseCallback.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern cl_int clSetProgramReleaseCallback(cl_program program, void (*pfn_notify)(cl_program, void *) __attribute__((stdcall)), void *user_data)
     * }
     */
    public static int clSetProgramReleaseCallback(MemorySegment program, MemorySegment pfn_notify, MemorySegment user_data) {
        var mh$ = clSetProgramReleaseCallback.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clSetProgramReleaseCallback", program, pfn_notify, user_data);
            }
            return (int)mh$.invokeExact(program, pfn_notify, user_data);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clSetProgramSpecializationConstant {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_INT,
            C_LONG_LONG,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("clSetProgramSpecializationConstant"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern cl_int clSetProgramSpecializationConstant(cl_program program, cl_uint spec_id, size_t spec_size, const void *spec_value)
     * }
     */
    public static FunctionDescriptor clSetProgramSpecializationConstant$descriptor() {
        return clSetProgramSpecializationConstant.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern cl_int clSetProgramSpecializationConstant(cl_program program, cl_uint spec_id, size_t spec_size, const void *spec_value)
     * }
     */
    public static MethodHandle clSetProgramSpecializationConstant$handle() {
        return clSetProgramSpecializationConstant.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern cl_int clSetProgramSpecializationConstant(cl_program program, cl_uint spec_id, size_t spec_size, const void *spec_value)
     * }
     */
    public static int clSetProgramSpecializationConstant(MemorySegment program, int spec_id, long spec_size, MemorySegment spec_value) {
        var mh$ = clSetProgramSpecializationConstant.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clSetProgramSpecializationConstant", program, spec_id, spec_size, spec_value);
            }
            return (int)mh$.invokeExact(program, spec_id, spec_size, spec_value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clUnloadPlatformCompiler {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("clUnloadPlatformCompiler"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern cl_int clUnloadPlatformCompiler(cl_platform_id platform)
     * }
     */
    public static FunctionDescriptor clUnloadPlatformCompiler$descriptor() {
        return clUnloadPlatformCompiler.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern cl_int clUnloadPlatformCompiler(cl_platform_id platform)
     * }
     */
    public static MethodHandle clUnloadPlatformCompiler$handle() {
        return clUnloadPlatformCompiler.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern cl_int clUnloadPlatformCompiler(cl_platform_id platform)
     * }
     */
    public static int clUnloadPlatformCompiler(MemorySegment platform) {
        var mh$ = clUnloadPlatformCompiler.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clUnloadPlatformCompiler", platform);
            }
            return (int)mh$.invokeExact(platform);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clGetProgramInfo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_INT,
            C_LONG_LONG,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("clGetProgramInfo"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern cl_int clGetProgramInfo(cl_program program, cl_program_info param_name, size_t param_value_size, void *param_value, size_t *param_value_size_ret)
     * }
     */
    public static FunctionDescriptor clGetProgramInfo$descriptor() {
        return clGetProgramInfo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern cl_int clGetProgramInfo(cl_program program, cl_program_info param_name, size_t param_value_size, void *param_value, size_t *param_value_size_ret)
     * }
     */
    public static MethodHandle clGetProgramInfo$handle() {
        return clGetProgramInfo.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern cl_int clGetProgramInfo(cl_program program, cl_program_info param_name, size_t param_value_size, void *param_value, size_t *param_value_size_ret)
     * }
     */
    public static int clGetProgramInfo(MemorySegment program, int param_name, long param_value_size, MemorySegment param_value, MemorySegment param_value_size_ret) {
        var mh$ = clGetProgramInfo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clGetProgramInfo", program, param_name, param_value_size, param_value, param_value_size_ret);
            }
            return (int)mh$.invokeExact(program, param_name, param_value_size, param_value, param_value_size_ret);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clGetProgramBuildInfo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_INT,
            C_LONG_LONG,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("clGetProgramBuildInfo"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern cl_int clGetProgramBuildInfo(cl_program program, cl_device_id device, cl_program_build_info param_name, size_t param_value_size, void *param_value, size_t *param_value_size_ret)
     * }
     */
    public static FunctionDescriptor clGetProgramBuildInfo$descriptor() {
        return clGetProgramBuildInfo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern cl_int clGetProgramBuildInfo(cl_program program, cl_device_id device, cl_program_build_info param_name, size_t param_value_size, void *param_value, size_t *param_value_size_ret)
     * }
     */
    public static MethodHandle clGetProgramBuildInfo$handle() {
        return clGetProgramBuildInfo.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern cl_int clGetProgramBuildInfo(cl_program program, cl_device_id device, cl_program_build_info param_name, size_t param_value_size, void *param_value, size_t *param_value_size_ret)
     * }
     */
    public static int clGetProgramBuildInfo(MemorySegment program, MemorySegment device, int param_name, long param_value_size, MemorySegment param_value, MemorySegment param_value_size_ret) {
        var mh$ = clGetProgramBuildInfo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clGetProgramBuildInfo", program, device, param_name, param_value_size, param_value, param_value_size_ret);
            }
            return (int)mh$.invokeExact(program, device, param_name, param_value_size, param_value, param_value_size_ret);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clCreateKernel {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("clCreateKernel"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern cl_kernel clCreateKernel(cl_program program, const char *kernel_name, cl_int *errcode_ret)
     * }
     */
    public static FunctionDescriptor clCreateKernel$descriptor() {
        return clCreateKernel.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern cl_kernel clCreateKernel(cl_program program, const char *kernel_name, cl_int *errcode_ret)
     * }
     */
    public static MethodHandle clCreateKernel$handle() {
        return clCreateKernel.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern cl_kernel clCreateKernel(cl_program program, const char *kernel_name, cl_int *errcode_ret)
     * }
     */
    public static MemorySegment clCreateKernel(MemorySegment program, MemorySegment kernel_name, MemorySegment errcode_ret) {
        var mh$ = clCreateKernel.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clCreateKernel", program, kernel_name, errcode_ret);
            }
            return (MemorySegment)mh$.invokeExact(program, kernel_name, errcode_ret);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clCreateKernelsInProgram {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_INT,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("clCreateKernelsInProgram"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern cl_int clCreateKernelsInProgram(cl_program program, cl_uint num_kernels, cl_kernel *kernels, cl_uint *num_kernels_ret)
     * }
     */
    public static FunctionDescriptor clCreateKernelsInProgram$descriptor() {
        return clCreateKernelsInProgram.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern cl_int clCreateKernelsInProgram(cl_program program, cl_uint num_kernels, cl_kernel *kernels, cl_uint *num_kernels_ret)
     * }
     */
    public static MethodHandle clCreateKernelsInProgram$handle() {
        return clCreateKernelsInProgram.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern cl_int clCreateKernelsInProgram(cl_program program, cl_uint num_kernels, cl_kernel *kernels, cl_uint *num_kernels_ret)
     * }
     */
    public static int clCreateKernelsInProgram(MemorySegment program, int num_kernels, MemorySegment kernels, MemorySegment num_kernels_ret) {
        var mh$ = clCreateKernelsInProgram.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clCreateKernelsInProgram", program, num_kernels, kernels, num_kernels_ret);
            }
            return (int)mh$.invokeExact(program, num_kernels, kernels, num_kernels_ret);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clCloneKernel {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("clCloneKernel"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern cl_kernel clCloneKernel(cl_kernel source_kernel, cl_int *errcode_ret)
     * }
     */
    public static FunctionDescriptor clCloneKernel$descriptor() {
        return clCloneKernel.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern cl_kernel clCloneKernel(cl_kernel source_kernel, cl_int *errcode_ret)
     * }
     */
    public static MethodHandle clCloneKernel$handle() {
        return clCloneKernel.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern cl_kernel clCloneKernel(cl_kernel source_kernel, cl_int *errcode_ret)
     * }
     */
    public static MemorySegment clCloneKernel(MemorySegment source_kernel, MemorySegment errcode_ret) {
        var mh$ = clCloneKernel.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clCloneKernel", source_kernel, errcode_ret);
            }
            return (MemorySegment)mh$.invokeExact(source_kernel, errcode_ret);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clRetainKernel {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("clRetainKernel"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern cl_int clRetainKernel(cl_kernel kernel)
     * }
     */
    public static FunctionDescriptor clRetainKernel$descriptor() {
        return clRetainKernel.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern cl_int clRetainKernel(cl_kernel kernel)
     * }
     */
    public static MethodHandle clRetainKernel$handle() {
        return clRetainKernel.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern cl_int clRetainKernel(cl_kernel kernel)
     * }
     */
    public static int clRetainKernel(MemorySegment kernel) {
        var mh$ = clRetainKernel.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clRetainKernel", kernel);
            }
            return (int)mh$.invokeExact(kernel);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clReleaseKernel {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("clReleaseKernel"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern cl_int clReleaseKernel(cl_kernel kernel)
     * }
     */
    public static FunctionDescriptor clReleaseKernel$descriptor() {
        return clReleaseKernel.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern cl_int clReleaseKernel(cl_kernel kernel)
     * }
     */
    public static MethodHandle clReleaseKernel$handle() {
        return clReleaseKernel.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern cl_int clReleaseKernel(cl_kernel kernel)
     * }
     */
    public static int clReleaseKernel(MemorySegment kernel) {
        var mh$ = clReleaseKernel.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clReleaseKernel", kernel);
            }
            return (int)mh$.invokeExact(kernel);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clSetKernelArg {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_INT,
            C_LONG_LONG,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("clSetKernelArg"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern cl_int clSetKernelArg(cl_kernel kernel, cl_uint arg_index, size_t arg_size, const void *arg_value)
     * }
     */
    public static FunctionDescriptor clSetKernelArg$descriptor() {
        return clSetKernelArg.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern cl_int clSetKernelArg(cl_kernel kernel, cl_uint arg_index, size_t arg_size, const void *arg_value)
     * }
     */
    public static MethodHandle clSetKernelArg$handle() {
        return clSetKernelArg.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern cl_int clSetKernelArg(cl_kernel kernel, cl_uint arg_index, size_t arg_size, const void *arg_value)
     * }
     */
    public static int clSetKernelArg(MemorySegment kernel, int arg_index, long arg_size, MemorySegment arg_value) {
        var mh$ = clSetKernelArg.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clSetKernelArg", kernel, arg_index, arg_size, arg_value);
            }
            return (int)mh$.invokeExact(kernel, arg_index, arg_size, arg_value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clSetKernelArgSVMPointer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("clSetKernelArgSVMPointer"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern cl_int clSetKernelArgSVMPointer(cl_kernel kernel, cl_uint arg_index, const void *arg_value)
     * }
     */
    public static FunctionDescriptor clSetKernelArgSVMPointer$descriptor() {
        return clSetKernelArgSVMPointer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern cl_int clSetKernelArgSVMPointer(cl_kernel kernel, cl_uint arg_index, const void *arg_value)
     * }
     */
    public static MethodHandle clSetKernelArgSVMPointer$handle() {
        return clSetKernelArgSVMPointer.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern cl_int clSetKernelArgSVMPointer(cl_kernel kernel, cl_uint arg_index, const void *arg_value)
     * }
     */
    public static int clSetKernelArgSVMPointer(MemorySegment kernel, int arg_index, MemorySegment arg_value) {
        var mh$ = clSetKernelArgSVMPointer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clSetKernelArgSVMPointer", kernel, arg_index, arg_value);
            }
            return (int)mh$.invokeExact(kernel, arg_index, arg_value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clSetKernelExecInfo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_INT,
            C_LONG_LONG,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("clSetKernelExecInfo"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern cl_int clSetKernelExecInfo(cl_kernel kernel, cl_kernel_exec_info param_name, size_t param_value_size, const void *param_value)
     * }
     */
    public static FunctionDescriptor clSetKernelExecInfo$descriptor() {
        return clSetKernelExecInfo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern cl_int clSetKernelExecInfo(cl_kernel kernel, cl_kernel_exec_info param_name, size_t param_value_size, const void *param_value)
     * }
     */
    public static MethodHandle clSetKernelExecInfo$handle() {
        return clSetKernelExecInfo.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern cl_int clSetKernelExecInfo(cl_kernel kernel, cl_kernel_exec_info param_name, size_t param_value_size, const void *param_value)
     * }
     */
    public static int clSetKernelExecInfo(MemorySegment kernel, int param_name, long param_value_size, MemorySegment param_value) {
        var mh$ = clSetKernelExecInfo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clSetKernelExecInfo", kernel, param_name, param_value_size, param_value);
            }
            return (int)mh$.invokeExact(kernel, param_name, param_value_size, param_value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clGetKernelInfo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_INT,
            C_LONG_LONG,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("clGetKernelInfo"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern cl_int clGetKernelInfo(cl_kernel kernel, cl_kernel_info param_name, size_t param_value_size, void *param_value, size_t *param_value_size_ret)
     * }
     */
    public static FunctionDescriptor clGetKernelInfo$descriptor() {
        return clGetKernelInfo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern cl_int clGetKernelInfo(cl_kernel kernel, cl_kernel_info param_name, size_t param_value_size, void *param_value, size_t *param_value_size_ret)
     * }
     */
    public static MethodHandle clGetKernelInfo$handle() {
        return clGetKernelInfo.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern cl_int clGetKernelInfo(cl_kernel kernel, cl_kernel_info param_name, size_t param_value_size, void *param_value, size_t *param_value_size_ret)
     * }
     */
    public static int clGetKernelInfo(MemorySegment kernel, int param_name, long param_value_size, MemorySegment param_value, MemorySegment param_value_size_ret) {
        var mh$ = clGetKernelInfo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clGetKernelInfo", kernel, param_name, param_value_size, param_value, param_value_size_ret);
            }
            return (int)mh$.invokeExact(kernel, param_name, param_value_size, param_value, param_value_size_ret);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clGetKernelArgInfo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_INT,
            C_INT,
            C_LONG_LONG,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("clGetKernelArgInfo"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern cl_int clGetKernelArgInfo(cl_kernel kernel, cl_uint arg_indx, cl_kernel_arg_info param_name, size_t param_value_size, void *param_value, size_t *param_value_size_ret)
     * }
     */
    public static FunctionDescriptor clGetKernelArgInfo$descriptor() {
        return clGetKernelArgInfo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern cl_int clGetKernelArgInfo(cl_kernel kernel, cl_uint arg_indx, cl_kernel_arg_info param_name, size_t param_value_size, void *param_value, size_t *param_value_size_ret)
     * }
     */
    public static MethodHandle clGetKernelArgInfo$handle() {
        return clGetKernelArgInfo.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern cl_int clGetKernelArgInfo(cl_kernel kernel, cl_uint arg_indx, cl_kernel_arg_info param_name, size_t param_value_size, void *param_value, size_t *param_value_size_ret)
     * }
     */
    public static int clGetKernelArgInfo(MemorySegment kernel, int arg_indx, int param_name, long param_value_size, MemorySegment param_value, MemorySegment param_value_size_ret) {
        var mh$ = clGetKernelArgInfo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clGetKernelArgInfo", kernel, arg_indx, param_name, param_value_size, param_value, param_value_size_ret);
            }
            return (int)mh$.invokeExact(kernel, arg_indx, param_name, param_value_size, param_value, param_value_size_ret);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clGetKernelWorkGroupInfo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_INT,
            C_LONG_LONG,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("clGetKernelWorkGroupInfo"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern cl_int clGetKernelWorkGroupInfo(cl_kernel kernel, cl_device_id device, cl_kernel_work_group_info param_name, size_t param_value_size, void *param_value, size_t *param_value_size_ret)
     * }
     */
    public static FunctionDescriptor clGetKernelWorkGroupInfo$descriptor() {
        return clGetKernelWorkGroupInfo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern cl_int clGetKernelWorkGroupInfo(cl_kernel kernel, cl_device_id device, cl_kernel_work_group_info param_name, size_t param_value_size, void *param_value, size_t *param_value_size_ret)
     * }
     */
    public static MethodHandle clGetKernelWorkGroupInfo$handle() {
        return clGetKernelWorkGroupInfo.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern cl_int clGetKernelWorkGroupInfo(cl_kernel kernel, cl_device_id device, cl_kernel_work_group_info param_name, size_t param_value_size, void *param_value, size_t *param_value_size_ret)
     * }
     */
    public static int clGetKernelWorkGroupInfo(MemorySegment kernel, MemorySegment device, int param_name, long param_value_size, MemorySegment param_value, MemorySegment param_value_size_ret) {
        var mh$ = clGetKernelWorkGroupInfo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clGetKernelWorkGroupInfo", kernel, device, param_name, param_value_size, param_value, param_value_size_ret);
            }
            return (int)mh$.invokeExact(kernel, device, param_name, param_value_size, param_value, param_value_size_ret);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clGetKernelSubGroupInfo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_INT,
            C_LONG_LONG,
            C_POINTER,
            C_LONG_LONG,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("clGetKernelSubGroupInfo"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern cl_int clGetKernelSubGroupInfo(cl_kernel kernel, cl_device_id device, cl_kernel_sub_group_info param_name, size_t input_value_size, const void *input_value, size_t param_value_size, void *param_value, size_t *param_value_size_ret)
     * }
     */
    public static FunctionDescriptor clGetKernelSubGroupInfo$descriptor() {
        return clGetKernelSubGroupInfo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern cl_int clGetKernelSubGroupInfo(cl_kernel kernel, cl_device_id device, cl_kernel_sub_group_info param_name, size_t input_value_size, const void *input_value, size_t param_value_size, void *param_value, size_t *param_value_size_ret)
     * }
     */
    public static MethodHandle clGetKernelSubGroupInfo$handle() {
        return clGetKernelSubGroupInfo.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern cl_int clGetKernelSubGroupInfo(cl_kernel kernel, cl_device_id device, cl_kernel_sub_group_info param_name, size_t input_value_size, const void *input_value, size_t param_value_size, void *param_value, size_t *param_value_size_ret)
     * }
     */
    public static int clGetKernelSubGroupInfo(MemorySegment kernel, MemorySegment device, int param_name, long input_value_size, MemorySegment input_value, long param_value_size, MemorySegment param_value, MemorySegment param_value_size_ret) {
        var mh$ = clGetKernelSubGroupInfo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clGetKernelSubGroupInfo", kernel, device, param_name, input_value_size, input_value, param_value_size, param_value, param_value_size_ret);
            }
            return (int)mh$.invokeExact(kernel, device, param_name, input_value_size, input_value, param_value_size, param_value, param_value_size_ret);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clWaitForEvents {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("clWaitForEvents"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern cl_int clWaitForEvents(cl_uint num_events, const cl_event *event_list)
     * }
     */
    public static FunctionDescriptor clWaitForEvents$descriptor() {
        return clWaitForEvents.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern cl_int clWaitForEvents(cl_uint num_events, const cl_event *event_list)
     * }
     */
    public static MethodHandle clWaitForEvents$handle() {
        return clWaitForEvents.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern cl_int clWaitForEvents(cl_uint num_events, const cl_event *event_list)
     * }
     */
    public static int clWaitForEvents(int num_events, MemorySegment event_list) {
        var mh$ = clWaitForEvents.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clWaitForEvents", num_events, event_list);
            }
            return (int)mh$.invokeExact(num_events, event_list);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clGetEventInfo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_INT,
            C_LONG_LONG,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("clGetEventInfo"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern cl_int clGetEventInfo(cl_event event, cl_event_info param_name, size_t param_value_size, void *param_value, size_t *param_value_size_ret)
     * }
     */
    public static FunctionDescriptor clGetEventInfo$descriptor() {
        return clGetEventInfo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern cl_int clGetEventInfo(cl_event event, cl_event_info param_name, size_t param_value_size, void *param_value, size_t *param_value_size_ret)
     * }
     */
    public static MethodHandle clGetEventInfo$handle() {
        return clGetEventInfo.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern cl_int clGetEventInfo(cl_event event, cl_event_info param_name, size_t param_value_size, void *param_value, size_t *param_value_size_ret)
     * }
     */
    public static int clGetEventInfo(MemorySegment event, int param_name, long param_value_size, MemorySegment param_value, MemorySegment param_value_size_ret) {
        var mh$ = clGetEventInfo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clGetEventInfo", event, param_name, param_value_size, param_value, param_value_size_ret);
            }
            return (int)mh$.invokeExact(event, param_name, param_value_size, param_value, param_value_size_ret);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clCreateUserEvent {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("clCreateUserEvent"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern cl_event clCreateUserEvent(cl_context context, cl_int *errcode_ret)
     * }
     */
    public static FunctionDescriptor clCreateUserEvent$descriptor() {
        return clCreateUserEvent.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern cl_event clCreateUserEvent(cl_context context, cl_int *errcode_ret)
     * }
     */
    public static MethodHandle clCreateUserEvent$handle() {
        return clCreateUserEvent.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern cl_event clCreateUserEvent(cl_context context, cl_int *errcode_ret)
     * }
     */
    public static MemorySegment clCreateUserEvent(MemorySegment context, MemorySegment errcode_ret) {
        var mh$ = clCreateUserEvent.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clCreateUserEvent", context, errcode_ret);
            }
            return (MemorySegment)mh$.invokeExact(context, errcode_ret);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clRetainEvent {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("clRetainEvent"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern cl_int clRetainEvent(cl_event event)
     * }
     */
    public static FunctionDescriptor clRetainEvent$descriptor() {
        return clRetainEvent.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern cl_int clRetainEvent(cl_event event)
     * }
     */
    public static MethodHandle clRetainEvent$handle() {
        return clRetainEvent.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern cl_int clRetainEvent(cl_event event)
     * }
     */
    public static int clRetainEvent(MemorySegment event) {
        var mh$ = clRetainEvent.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clRetainEvent", event);
            }
            return (int)mh$.invokeExact(event);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clReleaseEvent {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("clReleaseEvent"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern cl_int clReleaseEvent(cl_event event)
     * }
     */
    public static FunctionDescriptor clReleaseEvent$descriptor() {
        return clReleaseEvent.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern cl_int clReleaseEvent(cl_event event)
     * }
     */
    public static MethodHandle clReleaseEvent$handle() {
        return clReleaseEvent.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern cl_int clReleaseEvent(cl_event event)
     * }
     */
    public static int clReleaseEvent(MemorySegment event) {
        var mh$ = clReleaseEvent.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clReleaseEvent", event);
            }
            return (int)mh$.invokeExact(event);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clSetUserEventStatus {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("clSetUserEventStatus"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern cl_int clSetUserEventStatus(cl_event event, cl_int execution_status)
     * }
     */
    public static FunctionDescriptor clSetUserEventStatus$descriptor() {
        return clSetUserEventStatus.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern cl_int clSetUserEventStatus(cl_event event, cl_int execution_status)
     * }
     */
    public static MethodHandle clSetUserEventStatus$handle() {
        return clSetUserEventStatus.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern cl_int clSetUserEventStatus(cl_event event, cl_int execution_status)
     * }
     */
    public static int clSetUserEventStatus(MemorySegment event, int execution_status) {
        var mh$ = clSetUserEventStatus.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clSetUserEventStatus", event, execution_status);
            }
            return (int)mh$.invokeExact(event, execution_status);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clSetEventCallback {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_INT,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("clSetEventCallback"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern cl_int clSetEventCallback(cl_event event, cl_int command_exec_callback_type, void (*pfn_notify)(cl_event, cl_int, void *) __attribute__((stdcall)), void *user_data)
     * }
     */
    public static FunctionDescriptor clSetEventCallback$descriptor() {
        return clSetEventCallback.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern cl_int clSetEventCallback(cl_event event, cl_int command_exec_callback_type, void (*pfn_notify)(cl_event, cl_int, void *) __attribute__((stdcall)), void *user_data)
     * }
     */
    public static MethodHandle clSetEventCallback$handle() {
        return clSetEventCallback.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern cl_int clSetEventCallback(cl_event event, cl_int command_exec_callback_type, void (*pfn_notify)(cl_event, cl_int, void *) __attribute__((stdcall)), void *user_data)
     * }
     */
    public static int clSetEventCallback(MemorySegment event, int command_exec_callback_type, MemorySegment pfn_notify, MemorySegment user_data) {
        var mh$ = clSetEventCallback.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clSetEventCallback", event, command_exec_callback_type, pfn_notify, user_data);
            }
            return (int)mh$.invokeExact(event, command_exec_callback_type, pfn_notify, user_data);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clGetEventProfilingInfo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_INT,
            C_LONG_LONG,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("clGetEventProfilingInfo"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern cl_int clGetEventProfilingInfo(cl_event event, cl_profiling_info param_name, size_t param_value_size, void *param_value, size_t *param_value_size_ret)
     * }
     */
    public static FunctionDescriptor clGetEventProfilingInfo$descriptor() {
        return clGetEventProfilingInfo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern cl_int clGetEventProfilingInfo(cl_event event, cl_profiling_info param_name, size_t param_value_size, void *param_value, size_t *param_value_size_ret)
     * }
     */
    public static MethodHandle clGetEventProfilingInfo$handle() {
        return clGetEventProfilingInfo.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern cl_int clGetEventProfilingInfo(cl_event event, cl_profiling_info param_name, size_t param_value_size, void *param_value, size_t *param_value_size_ret)
     * }
     */
    public static int clGetEventProfilingInfo(MemorySegment event, int param_name, long param_value_size, MemorySegment param_value, MemorySegment param_value_size_ret) {
        var mh$ = clGetEventProfilingInfo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clGetEventProfilingInfo", event, param_name, param_value_size, param_value, param_value_size_ret);
            }
            return (int)mh$.invokeExact(event, param_name, param_value_size, param_value, param_value_size_ret);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clFlush {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("clFlush"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern cl_int clFlush(cl_command_queue command_queue)
     * }
     */
    public static FunctionDescriptor clFlush$descriptor() {
        return clFlush.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern cl_int clFlush(cl_command_queue command_queue)
     * }
     */
    public static MethodHandle clFlush$handle() {
        return clFlush.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern cl_int clFlush(cl_command_queue command_queue)
     * }
     */
    public static int clFlush(MemorySegment command_queue) {
        var mh$ = clFlush.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clFlush", command_queue);
            }
            return (int)mh$.invokeExact(command_queue);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clFinish {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("clFinish"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern cl_int clFinish(cl_command_queue command_queue)
     * }
     */
    public static FunctionDescriptor clFinish$descriptor() {
        return clFinish.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern cl_int clFinish(cl_command_queue command_queue)
     * }
     */
    public static MethodHandle clFinish$handle() {
        return clFinish.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern cl_int clFinish(cl_command_queue command_queue)
     * }
     */
    public static int clFinish(MemorySegment command_queue) {
        var mh$ = clFinish.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clFinish", command_queue);
            }
            return (int)mh$.invokeExact(command_queue);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clEnqueueReadBuffer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_INT,
            C_LONG_LONG,
            C_LONG_LONG,
            C_POINTER,
            C_INT,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("clEnqueueReadBuffer"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern cl_int clEnqueueReadBuffer(cl_command_queue command_queue, cl_mem buffer, cl_bool blocking_read, size_t offset, size_t size, void *ptr, cl_uint num_events_in_wait_list, const cl_event *event_wait_list, cl_event *event)
     * }
     */
    public static FunctionDescriptor clEnqueueReadBuffer$descriptor() {
        return clEnqueueReadBuffer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern cl_int clEnqueueReadBuffer(cl_command_queue command_queue, cl_mem buffer, cl_bool blocking_read, size_t offset, size_t size, void *ptr, cl_uint num_events_in_wait_list, const cl_event *event_wait_list, cl_event *event)
     * }
     */
    public static MethodHandle clEnqueueReadBuffer$handle() {
        return clEnqueueReadBuffer.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern cl_int clEnqueueReadBuffer(cl_command_queue command_queue, cl_mem buffer, cl_bool blocking_read, size_t offset, size_t size, void *ptr, cl_uint num_events_in_wait_list, const cl_event *event_wait_list, cl_event *event)
     * }
     */
    public static int clEnqueueReadBuffer(MemorySegment command_queue, MemorySegment buffer, int blocking_read, long offset, long size, MemorySegment ptr, int num_events_in_wait_list, MemorySegment event_wait_list, MemorySegment event) {
        var mh$ = clEnqueueReadBuffer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clEnqueueReadBuffer", command_queue, buffer, blocking_read, offset, size, ptr, num_events_in_wait_list, event_wait_list, event);
            }
            return (int)mh$.invokeExact(command_queue, buffer, blocking_read, offset, size, ptr, num_events_in_wait_list, event_wait_list, event);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clEnqueueReadBufferRect {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_INT,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_LONG_LONG,
            C_LONG_LONG,
            C_LONG_LONG,
            C_LONG_LONG,
            C_POINTER,
            C_INT,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("clEnqueueReadBufferRect"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern cl_int clEnqueueReadBufferRect(cl_command_queue command_queue, cl_mem buffer, cl_bool blocking_read, const size_t *buffer_origin, const size_t *host_origin, const size_t *region, size_t buffer_row_pitch, size_t buffer_slice_pitch, size_t host_row_pitch, size_t host_slice_pitch, void *ptr, cl_uint num_events_in_wait_list, const cl_event *event_wait_list, cl_event *event)
     * }
     */
    public static FunctionDescriptor clEnqueueReadBufferRect$descriptor() {
        return clEnqueueReadBufferRect.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern cl_int clEnqueueReadBufferRect(cl_command_queue command_queue, cl_mem buffer, cl_bool blocking_read, const size_t *buffer_origin, const size_t *host_origin, const size_t *region, size_t buffer_row_pitch, size_t buffer_slice_pitch, size_t host_row_pitch, size_t host_slice_pitch, void *ptr, cl_uint num_events_in_wait_list, const cl_event *event_wait_list, cl_event *event)
     * }
     */
    public static MethodHandle clEnqueueReadBufferRect$handle() {
        return clEnqueueReadBufferRect.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern cl_int clEnqueueReadBufferRect(cl_command_queue command_queue, cl_mem buffer, cl_bool blocking_read, const size_t *buffer_origin, const size_t *host_origin, const size_t *region, size_t buffer_row_pitch, size_t buffer_slice_pitch, size_t host_row_pitch, size_t host_slice_pitch, void *ptr, cl_uint num_events_in_wait_list, const cl_event *event_wait_list, cl_event *event)
     * }
     */
    public static int clEnqueueReadBufferRect(MemorySegment command_queue, MemorySegment buffer, int blocking_read, MemorySegment buffer_origin, MemorySegment host_origin, MemorySegment region, long buffer_row_pitch, long buffer_slice_pitch, long host_row_pitch, long host_slice_pitch, MemorySegment ptr, int num_events_in_wait_list, MemorySegment event_wait_list, MemorySegment event) {
        var mh$ = clEnqueueReadBufferRect.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clEnqueueReadBufferRect", command_queue, buffer, blocking_read, buffer_origin, host_origin, region, buffer_row_pitch, buffer_slice_pitch, host_row_pitch, host_slice_pitch, ptr, num_events_in_wait_list, event_wait_list, event);
            }
            return (int)mh$.invokeExact(command_queue, buffer, blocking_read, buffer_origin, host_origin, region, buffer_row_pitch, buffer_slice_pitch, host_row_pitch, host_slice_pitch, ptr, num_events_in_wait_list, event_wait_list, event);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clEnqueueWriteBuffer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_INT,
            C_LONG_LONG,
            C_LONG_LONG,
            C_POINTER,
            C_INT,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("clEnqueueWriteBuffer"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern cl_int clEnqueueWriteBuffer(cl_command_queue command_queue, cl_mem buffer, cl_bool blocking_write, size_t offset, size_t size, const void *ptr, cl_uint num_events_in_wait_list, const cl_event *event_wait_list, cl_event *event)
     * }
     */
    public static FunctionDescriptor clEnqueueWriteBuffer$descriptor() {
        return clEnqueueWriteBuffer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern cl_int clEnqueueWriteBuffer(cl_command_queue command_queue, cl_mem buffer, cl_bool blocking_write, size_t offset, size_t size, const void *ptr, cl_uint num_events_in_wait_list, const cl_event *event_wait_list, cl_event *event)
     * }
     */
    public static MethodHandle clEnqueueWriteBuffer$handle() {
        return clEnqueueWriteBuffer.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern cl_int clEnqueueWriteBuffer(cl_command_queue command_queue, cl_mem buffer, cl_bool blocking_write, size_t offset, size_t size, const void *ptr, cl_uint num_events_in_wait_list, const cl_event *event_wait_list, cl_event *event)
     * }
     */
    public static int clEnqueueWriteBuffer(MemorySegment command_queue, MemorySegment buffer, int blocking_write, long offset, long size, MemorySegment ptr, int num_events_in_wait_list, MemorySegment event_wait_list, MemorySegment event) {
        var mh$ = clEnqueueWriteBuffer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clEnqueueWriteBuffer", command_queue, buffer, blocking_write, offset, size, ptr, num_events_in_wait_list, event_wait_list, event);
            }
            return (int)mh$.invokeExact(command_queue, buffer, blocking_write, offset, size, ptr, num_events_in_wait_list, event_wait_list, event);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clEnqueueWriteBufferRect {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_INT,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_LONG_LONG,
            C_LONG_LONG,
            C_LONG_LONG,
            C_LONG_LONG,
            C_POINTER,
            C_INT,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("clEnqueueWriteBufferRect"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern cl_int clEnqueueWriteBufferRect(cl_command_queue command_queue, cl_mem buffer, cl_bool blocking_write, const size_t *buffer_origin, const size_t *host_origin, const size_t *region, size_t buffer_row_pitch, size_t buffer_slice_pitch, size_t host_row_pitch, size_t host_slice_pitch, const void *ptr, cl_uint num_events_in_wait_list, const cl_event *event_wait_list, cl_event *event)
     * }
     */
    public static FunctionDescriptor clEnqueueWriteBufferRect$descriptor() {
        return clEnqueueWriteBufferRect.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern cl_int clEnqueueWriteBufferRect(cl_command_queue command_queue, cl_mem buffer, cl_bool blocking_write, const size_t *buffer_origin, const size_t *host_origin, const size_t *region, size_t buffer_row_pitch, size_t buffer_slice_pitch, size_t host_row_pitch, size_t host_slice_pitch, const void *ptr, cl_uint num_events_in_wait_list, const cl_event *event_wait_list, cl_event *event)
     * }
     */
    public static MethodHandle clEnqueueWriteBufferRect$handle() {
        return clEnqueueWriteBufferRect.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern cl_int clEnqueueWriteBufferRect(cl_command_queue command_queue, cl_mem buffer, cl_bool blocking_write, const size_t *buffer_origin, const size_t *host_origin, const size_t *region, size_t buffer_row_pitch, size_t buffer_slice_pitch, size_t host_row_pitch, size_t host_slice_pitch, const void *ptr, cl_uint num_events_in_wait_list, const cl_event *event_wait_list, cl_event *event)
     * }
     */
    public static int clEnqueueWriteBufferRect(MemorySegment command_queue, MemorySegment buffer, int blocking_write, MemorySegment buffer_origin, MemorySegment host_origin, MemorySegment region, long buffer_row_pitch, long buffer_slice_pitch, long host_row_pitch, long host_slice_pitch, MemorySegment ptr, int num_events_in_wait_list, MemorySegment event_wait_list, MemorySegment event) {
        var mh$ = clEnqueueWriteBufferRect.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clEnqueueWriteBufferRect", command_queue, buffer, blocking_write, buffer_origin, host_origin, region, buffer_row_pitch, buffer_slice_pitch, host_row_pitch, host_slice_pitch, ptr, num_events_in_wait_list, event_wait_list, event);
            }
            return (int)mh$.invokeExact(command_queue, buffer, blocking_write, buffer_origin, host_origin, region, buffer_row_pitch, buffer_slice_pitch, host_row_pitch, host_slice_pitch, ptr, num_events_in_wait_list, event_wait_list, event);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clEnqueueFillBuffer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_LONG_LONG,
            C_LONG_LONG,
            C_LONG_LONG,
            C_INT,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("clEnqueueFillBuffer"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern cl_int clEnqueueFillBuffer(cl_command_queue command_queue, cl_mem buffer, const void *pattern, size_t pattern_size, size_t offset, size_t size, cl_uint num_events_in_wait_list, const cl_event *event_wait_list, cl_event *event)
     * }
     */
    public static FunctionDescriptor clEnqueueFillBuffer$descriptor() {
        return clEnqueueFillBuffer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern cl_int clEnqueueFillBuffer(cl_command_queue command_queue, cl_mem buffer, const void *pattern, size_t pattern_size, size_t offset, size_t size, cl_uint num_events_in_wait_list, const cl_event *event_wait_list, cl_event *event)
     * }
     */
    public static MethodHandle clEnqueueFillBuffer$handle() {
        return clEnqueueFillBuffer.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern cl_int clEnqueueFillBuffer(cl_command_queue command_queue, cl_mem buffer, const void *pattern, size_t pattern_size, size_t offset, size_t size, cl_uint num_events_in_wait_list, const cl_event *event_wait_list, cl_event *event)
     * }
     */
    public static int clEnqueueFillBuffer(MemorySegment command_queue, MemorySegment buffer, MemorySegment pattern, long pattern_size, long offset, long size, int num_events_in_wait_list, MemorySegment event_wait_list, MemorySegment event) {
        var mh$ = clEnqueueFillBuffer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clEnqueueFillBuffer", command_queue, buffer, pattern, pattern_size, offset, size, num_events_in_wait_list, event_wait_list, event);
            }
            return (int)mh$.invokeExact(command_queue, buffer, pattern, pattern_size, offset, size, num_events_in_wait_list, event_wait_list, event);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clEnqueueCopyBuffer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_LONG_LONG,
            C_LONG_LONG,
            C_LONG_LONG,
            C_INT,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("clEnqueueCopyBuffer"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern cl_int clEnqueueCopyBuffer(cl_command_queue command_queue, cl_mem src_buffer, cl_mem dst_buffer, size_t src_offset, size_t dst_offset, size_t size, cl_uint num_events_in_wait_list, const cl_event *event_wait_list, cl_event *event)
     * }
     */
    public static FunctionDescriptor clEnqueueCopyBuffer$descriptor() {
        return clEnqueueCopyBuffer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern cl_int clEnqueueCopyBuffer(cl_command_queue command_queue, cl_mem src_buffer, cl_mem dst_buffer, size_t src_offset, size_t dst_offset, size_t size, cl_uint num_events_in_wait_list, const cl_event *event_wait_list, cl_event *event)
     * }
     */
    public static MethodHandle clEnqueueCopyBuffer$handle() {
        return clEnqueueCopyBuffer.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern cl_int clEnqueueCopyBuffer(cl_command_queue command_queue, cl_mem src_buffer, cl_mem dst_buffer, size_t src_offset, size_t dst_offset, size_t size, cl_uint num_events_in_wait_list, const cl_event *event_wait_list, cl_event *event)
     * }
     */
    public static int clEnqueueCopyBuffer(MemorySegment command_queue, MemorySegment src_buffer, MemorySegment dst_buffer, long src_offset, long dst_offset, long size, int num_events_in_wait_list, MemorySegment event_wait_list, MemorySegment event) {
        var mh$ = clEnqueueCopyBuffer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clEnqueueCopyBuffer", command_queue, src_buffer, dst_buffer, src_offset, dst_offset, size, num_events_in_wait_list, event_wait_list, event);
            }
            return (int)mh$.invokeExact(command_queue, src_buffer, dst_buffer, src_offset, dst_offset, size, num_events_in_wait_list, event_wait_list, event);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clEnqueueCopyBufferRect {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_LONG_LONG,
            C_LONG_LONG,
            C_LONG_LONG,
            C_LONG_LONG,
            C_INT,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("clEnqueueCopyBufferRect"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern cl_int clEnqueueCopyBufferRect(cl_command_queue command_queue, cl_mem src_buffer, cl_mem dst_buffer, const size_t *src_origin, const size_t *dst_origin, const size_t *region, size_t src_row_pitch, size_t src_slice_pitch, size_t dst_row_pitch, size_t dst_slice_pitch, cl_uint num_events_in_wait_list, const cl_event *event_wait_list, cl_event *event)
     * }
     */
    public static FunctionDescriptor clEnqueueCopyBufferRect$descriptor() {
        return clEnqueueCopyBufferRect.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern cl_int clEnqueueCopyBufferRect(cl_command_queue command_queue, cl_mem src_buffer, cl_mem dst_buffer, const size_t *src_origin, const size_t *dst_origin, const size_t *region, size_t src_row_pitch, size_t src_slice_pitch, size_t dst_row_pitch, size_t dst_slice_pitch, cl_uint num_events_in_wait_list, const cl_event *event_wait_list, cl_event *event)
     * }
     */
    public static MethodHandle clEnqueueCopyBufferRect$handle() {
        return clEnqueueCopyBufferRect.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern cl_int clEnqueueCopyBufferRect(cl_command_queue command_queue, cl_mem src_buffer, cl_mem dst_buffer, const size_t *src_origin, const size_t *dst_origin, const size_t *region, size_t src_row_pitch, size_t src_slice_pitch, size_t dst_row_pitch, size_t dst_slice_pitch, cl_uint num_events_in_wait_list, const cl_event *event_wait_list, cl_event *event)
     * }
     */
    public static int clEnqueueCopyBufferRect(MemorySegment command_queue, MemorySegment src_buffer, MemorySegment dst_buffer, MemorySegment src_origin, MemorySegment dst_origin, MemorySegment region, long src_row_pitch, long src_slice_pitch, long dst_row_pitch, long dst_slice_pitch, int num_events_in_wait_list, MemorySegment event_wait_list, MemorySegment event) {
        var mh$ = clEnqueueCopyBufferRect.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clEnqueueCopyBufferRect", command_queue, src_buffer, dst_buffer, src_origin, dst_origin, region, src_row_pitch, src_slice_pitch, dst_row_pitch, dst_slice_pitch, num_events_in_wait_list, event_wait_list, event);
            }
            return (int)mh$.invokeExact(command_queue, src_buffer, dst_buffer, src_origin, dst_origin, region, src_row_pitch, src_slice_pitch, dst_row_pitch, dst_slice_pitch, num_events_in_wait_list, event_wait_list, event);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clEnqueueReadImage {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_INT,
            C_POINTER,
            C_POINTER,
            C_LONG_LONG,
            C_LONG_LONG,
            C_POINTER,
            C_INT,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("clEnqueueReadImage"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern cl_int clEnqueueReadImage(cl_command_queue command_queue, cl_mem image, cl_bool blocking_read, const size_t *origin, const size_t *region, size_t row_pitch, size_t slice_pitch, void *ptr, cl_uint num_events_in_wait_list, const cl_event *event_wait_list, cl_event *event)
     * }
     */
    public static FunctionDescriptor clEnqueueReadImage$descriptor() {
        return clEnqueueReadImage.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern cl_int clEnqueueReadImage(cl_command_queue command_queue, cl_mem image, cl_bool blocking_read, const size_t *origin, const size_t *region, size_t row_pitch, size_t slice_pitch, void *ptr, cl_uint num_events_in_wait_list, const cl_event *event_wait_list, cl_event *event)
     * }
     */
    public static MethodHandle clEnqueueReadImage$handle() {
        return clEnqueueReadImage.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern cl_int clEnqueueReadImage(cl_command_queue command_queue, cl_mem image, cl_bool blocking_read, const size_t *origin, const size_t *region, size_t row_pitch, size_t slice_pitch, void *ptr, cl_uint num_events_in_wait_list, const cl_event *event_wait_list, cl_event *event)
     * }
     */
    public static int clEnqueueReadImage(MemorySegment command_queue, MemorySegment image, int blocking_read, MemorySegment origin, MemorySegment region, long row_pitch, long slice_pitch, MemorySegment ptr, int num_events_in_wait_list, MemorySegment event_wait_list, MemorySegment event) {
        var mh$ = clEnqueueReadImage.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clEnqueueReadImage", command_queue, image, blocking_read, origin, region, row_pitch, slice_pitch, ptr, num_events_in_wait_list, event_wait_list, event);
            }
            return (int)mh$.invokeExact(command_queue, image, blocking_read, origin, region, row_pitch, slice_pitch, ptr, num_events_in_wait_list, event_wait_list, event);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clEnqueueWriteImage {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_INT,
            C_POINTER,
            C_POINTER,
            C_LONG_LONG,
            C_LONG_LONG,
            C_POINTER,
            C_INT,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("clEnqueueWriteImage"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern cl_int clEnqueueWriteImage(cl_command_queue command_queue, cl_mem image, cl_bool blocking_write, const size_t *origin, const size_t *region, size_t input_row_pitch, size_t input_slice_pitch, const void *ptr, cl_uint num_events_in_wait_list, const cl_event *event_wait_list, cl_event *event)
     * }
     */
    public static FunctionDescriptor clEnqueueWriteImage$descriptor() {
        return clEnqueueWriteImage.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern cl_int clEnqueueWriteImage(cl_command_queue command_queue, cl_mem image, cl_bool blocking_write, const size_t *origin, const size_t *region, size_t input_row_pitch, size_t input_slice_pitch, const void *ptr, cl_uint num_events_in_wait_list, const cl_event *event_wait_list, cl_event *event)
     * }
     */
    public static MethodHandle clEnqueueWriteImage$handle() {
        return clEnqueueWriteImage.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern cl_int clEnqueueWriteImage(cl_command_queue command_queue, cl_mem image, cl_bool blocking_write, const size_t *origin, const size_t *region, size_t input_row_pitch, size_t input_slice_pitch, const void *ptr, cl_uint num_events_in_wait_list, const cl_event *event_wait_list, cl_event *event)
     * }
     */
    public static int clEnqueueWriteImage(MemorySegment command_queue, MemorySegment image, int blocking_write, MemorySegment origin, MemorySegment region, long input_row_pitch, long input_slice_pitch, MemorySegment ptr, int num_events_in_wait_list, MemorySegment event_wait_list, MemorySegment event) {
        var mh$ = clEnqueueWriteImage.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clEnqueueWriteImage", command_queue, image, blocking_write, origin, region, input_row_pitch, input_slice_pitch, ptr, num_events_in_wait_list, event_wait_list, event);
            }
            return (int)mh$.invokeExact(command_queue, image, blocking_write, origin, region, input_row_pitch, input_slice_pitch, ptr, num_events_in_wait_list, event_wait_list, event);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clEnqueueFillImage {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_INT,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("clEnqueueFillImage"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern cl_int clEnqueueFillImage(cl_command_queue command_queue, cl_mem image, const void *fill_color, const size_t *origin, const size_t *region, cl_uint num_events_in_wait_list, const cl_event *event_wait_list, cl_event *event)
     * }
     */
    public static FunctionDescriptor clEnqueueFillImage$descriptor() {
        return clEnqueueFillImage.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern cl_int clEnqueueFillImage(cl_command_queue command_queue, cl_mem image, const void *fill_color, const size_t *origin, const size_t *region, cl_uint num_events_in_wait_list, const cl_event *event_wait_list, cl_event *event)
     * }
     */
    public static MethodHandle clEnqueueFillImage$handle() {
        return clEnqueueFillImage.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern cl_int clEnqueueFillImage(cl_command_queue command_queue, cl_mem image, const void *fill_color, const size_t *origin, const size_t *region, cl_uint num_events_in_wait_list, const cl_event *event_wait_list, cl_event *event)
     * }
     */
    public static int clEnqueueFillImage(MemorySegment command_queue, MemorySegment image, MemorySegment fill_color, MemorySegment origin, MemorySegment region, int num_events_in_wait_list, MemorySegment event_wait_list, MemorySegment event) {
        var mh$ = clEnqueueFillImage.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clEnqueueFillImage", command_queue, image, fill_color, origin, region, num_events_in_wait_list, event_wait_list, event);
            }
            return (int)mh$.invokeExact(command_queue, image, fill_color, origin, region, num_events_in_wait_list, event_wait_list, event);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clEnqueueCopyImage {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_INT,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("clEnqueueCopyImage"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern cl_int clEnqueueCopyImage(cl_command_queue command_queue, cl_mem src_image, cl_mem dst_image, const size_t *src_origin, const size_t *dst_origin, const size_t *region, cl_uint num_events_in_wait_list, const cl_event *event_wait_list, cl_event *event)
     * }
     */
    public static FunctionDescriptor clEnqueueCopyImage$descriptor() {
        return clEnqueueCopyImage.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern cl_int clEnqueueCopyImage(cl_command_queue command_queue, cl_mem src_image, cl_mem dst_image, const size_t *src_origin, const size_t *dst_origin, const size_t *region, cl_uint num_events_in_wait_list, const cl_event *event_wait_list, cl_event *event)
     * }
     */
    public static MethodHandle clEnqueueCopyImage$handle() {
        return clEnqueueCopyImage.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern cl_int clEnqueueCopyImage(cl_command_queue command_queue, cl_mem src_image, cl_mem dst_image, const size_t *src_origin, const size_t *dst_origin, const size_t *region, cl_uint num_events_in_wait_list, const cl_event *event_wait_list, cl_event *event)
     * }
     */
    public static int clEnqueueCopyImage(MemorySegment command_queue, MemorySegment src_image, MemorySegment dst_image, MemorySegment src_origin, MemorySegment dst_origin, MemorySegment region, int num_events_in_wait_list, MemorySegment event_wait_list, MemorySegment event) {
        var mh$ = clEnqueueCopyImage.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clEnqueueCopyImage", command_queue, src_image, dst_image, src_origin, dst_origin, region, num_events_in_wait_list, event_wait_list, event);
            }
            return (int)mh$.invokeExact(command_queue, src_image, dst_image, src_origin, dst_origin, region, num_events_in_wait_list, event_wait_list, event);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clEnqueueCopyImageToBuffer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_LONG_LONG,
            C_INT,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("clEnqueueCopyImageToBuffer"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern cl_int clEnqueueCopyImageToBuffer(cl_command_queue command_queue, cl_mem src_image, cl_mem dst_buffer, const size_t *src_origin, const size_t *region, size_t dst_offset, cl_uint num_events_in_wait_list, const cl_event *event_wait_list, cl_event *event)
     * }
     */
    public static FunctionDescriptor clEnqueueCopyImageToBuffer$descriptor() {
        return clEnqueueCopyImageToBuffer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern cl_int clEnqueueCopyImageToBuffer(cl_command_queue command_queue, cl_mem src_image, cl_mem dst_buffer, const size_t *src_origin, const size_t *region, size_t dst_offset, cl_uint num_events_in_wait_list, const cl_event *event_wait_list, cl_event *event)
     * }
     */
    public static MethodHandle clEnqueueCopyImageToBuffer$handle() {
        return clEnqueueCopyImageToBuffer.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern cl_int clEnqueueCopyImageToBuffer(cl_command_queue command_queue, cl_mem src_image, cl_mem dst_buffer, const size_t *src_origin, const size_t *region, size_t dst_offset, cl_uint num_events_in_wait_list, const cl_event *event_wait_list, cl_event *event)
     * }
     */
    public static int clEnqueueCopyImageToBuffer(MemorySegment command_queue, MemorySegment src_image, MemorySegment dst_buffer, MemorySegment src_origin, MemorySegment region, long dst_offset, int num_events_in_wait_list, MemorySegment event_wait_list, MemorySegment event) {
        var mh$ = clEnqueueCopyImageToBuffer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clEnqueueCopyImageToBuffer", command_queue, src_image, dst_buffer, src_origin, region, dst_offset, num_events_in_wait_list, event_wait_list, event);
            }
            return (int)mh$.invokeExact(command_queue, src_image, dst_buffer, src_origin, region, dst_offset, num_events_in_wait_list, event_wait_list, event);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clEnqueueCopyBufferToImage {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_LONG_LONG,
            C_POINTER,
            C_POINTER,
            C_INT,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("clEnqueueCopyBufferToImage"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern cl_int clEnqueueCopyBufferToImage(cl_command_queue command_queue, cl_mem src_buffer, cl_mem dst_image, size_t src_offset, const size_t *dst_origin, const size_t *region, cl_uint num_events_in_wait_list, const cl_event *event_wait_list, cl_event *event)
     * }
     */
    public static FunctionDescriptor clEnqueueCopyBufferToImage$descriptor() {
        return clEnqueueCopyBufferToImage.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern cl_int clEnqueueCopyBufferToImage(cl_command_queue command_queue, cl_mem src_buffer, cl_mem dst_image, size_t src_offset, const size_t *dst_origin, const size_t *region, cl_uint num_events_in_wait_list, const cl_event *event_wait_list, cl_event *event)
     * }
     */
    public static MethodHandle clEnqueueCopyBufferToImage$handle() {
        return clEnqueueCopyBufferToImage.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern cl_int clEnqueueCopyBufferToImage(cl_command_queue command_queue, cl_mem src_buffer, cl_mem dst_image, size_t src_offset, const size_t *dst_origin, const size_t *region, cl_uint num_events_in_wait_list, const cl_event *event_wait_list, cl_event *event)
     * }
     */
    public static int clEnqueueCopyBufferToImage(MemorySegment command_queue, MemorySegment src_buffer, MemorySegment dst_image, long src_offset, MemorySegment dst_origin, MemorySegment region, int num_events_in_wait_list, MemorySegment event_wait_list, MemorySegment event) {
        var mh$ = clEnqueueCopyBufferToImage.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clEnqueueCopyBufferToImage", command_queue, src_buffer, dst_image, src_offset, dst_origin, region, num_events_in_wait_list, event_wait_list, event);
            }
            return (int)mh$.invokeExact(command_queue, src_buffer, dst_image, src_offset, dst_origin, region, num_events_in_wait_list, event_wait_list, event);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clEnqueueMapBuffer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_INT,
            C_LONG_LONG,
            C_LONG_LONG,
            C_LONG_LONG,
            C_INT,
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("clEnqueueMapBuffer"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void *clEnqueueMapBuffer(cl_command_queue command_queue, cl_mem buffer, cl_bool blocking_map, cl_map_flags map_flags, size_t offset, size_t size, cl_uint num_events_in_wait_list, const cl_event *event_wait_list, cl_event *event, cl_int *errcode_ret)
     * }
     */
    public static FunctionDescriptor clEnqueueMapBuffer$descriptor() {
        return clEnqueueMapBuffer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void *clEnqueueMapBuffer(cl_command_queue command_queue, cl_mem buffer, cl_bool blocking_map, cl_map_flags map_flags, size_t offset, size_t size, cl_uint num_events_in_wait_list, const cl_event *event_wait_list, cl_event *event, cl_int *errcode_ret)
     * }
     */
    public static MethodHandle clEnqueueMapBuffer$handle() {
        return clEnqueueMapBuffer.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern void *clEnqueueMapBuffer(cl_command_queue command_queue, cl_mem buffer, cl_bool blocking_map, cl_map_flags map_flags, size_t offset, size_t size, cl_uint num_events_in_wait_list, const cl_event *event_wait_list, cl_event *event, cl_int *errcode_ret)
     * }
     */
    public static MemorySegment clEnqueueMapBuffer(MemorySegment command_queue, MemorySegment buffer, int blocking_map, long map_flags, long offset, long size, int num_events_in_wait_list, MemorySegment event_wait_list, MemorySegment event, MemorySegment errcode_ret) {
        var mh$ = clEnqueueMapBuffer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clEnqueueMapBuffer", command_queue, buffer, blocking_map, map_flags, offset, size, num_events_in_wait_list, event_wait_list, event, errcode_ret);
            }
            return (MemorySegment)mh$.invokeExact(command_queue, buffer, blocking_map, map_flags, offset, size, num_events_in_wait_list, event_wait_list, event, errcode_ret);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clEnqueueMapImage {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_INT,
            C_LONG_LONG,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_INT,
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("clEnqueueMapImage"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void *clEnqueueMapImage(cl_command_queue command_queue, cl_mem image, cl_bool blocking_map, cl_map_flags map_flags, const size_t *origin, const size_t *region, size_t *image_row_pitch, size_t *image_slice_pitch, cl_uint num_events_in_wait_list, const cl_event *event_wait_list, cl_event *event, cl_int *errcode_ret)
     * }
     */
    public static FunctionDescriptor clEnqueueMapImage$descriptor() {
        return clEnqueueMapImage.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void *clEnqueueMapImage(cl_command_queue command_queue, cl_mem image, cl_bool blocking_map, cl_map_flags map_flags, const size_t *origin, const size_t *region, size_t *image_row_pitch, size_t *image_slice_pitch, cl_uint num_events_in_wait_list, const cl_event *event_wait_list, cl_event *event, cl_int *errcode_ret)
     * }
     */
    public static MethodHandle clEnqueueMapImage$handle() {
        return clEnqueueMapImage.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern void *clEnqueueMapImage(cl_command_queue command_queue, cl_mem image, cl_bool blocking_map, cl_map_flags map_flags, const size_t *origin, const size_t *region, size_t *image_row_pitch, size_t *image_slice_pitch, cl_uint num_events_in_wait_list, const cl_event *event_wait_list, cl_event *event, cl_int *errcode_ret)
     * }
     */
    public static MemorySegment clEnqueueMapImage(MemorySegment command_queue, MemorySegment image, int blocking_map, long map_flags, MemorySegment origin, MemorySegment region, MemorySegment image_row_pitch, MemorySegment image_slice_pitch, int num_events_in_wait_list, MemorySegment event_wait_list, MemorySegment event, MemorySegment errcode_ret) {
        var mh$ = clEnqueueMapImage.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clEnqueueMapImage", command_queue, image, blocking_map, map_flags, origin, region, image_row_pitch, image_slice_pitch, num_events_in_wait_list, event_wait_list, event, errcode_ret);
            }
            return (MemorySegment)mh$.invokeExact(command_queue, image, blocking_map, map_flags, origin, region, image_row_pitch, image_slice_pitch, num_events_in_wait_list, event_wait_list, event, errcode_ret);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clEnqueueUnmapMemObject {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_INT,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("clEnqueueUnmapMemObject"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern cl_int clEnqueueUnmapMemObject(cl_command_queue command_queue, cl_mem memobj, void *mapped_ptr, cl_uint num_events_in_wait_list, const cl_event *event_wait_list, cl_event *event)
     * }
     */
    public static FunctionDescriptor clEnqueueUnmapMemObject$descriptor() {
        return clEnqueueUnmapMemObject.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern cl_int clEnqueueUnmapMemObject(cl_command_queue command_queue, cl_mem memobj, void *mapped_ptr, cl_uint num_events_in_wait_list, const cl_event *event_wait_list, cl_event *event)
     * }
     */
    public static MethodHandle clEnqueueUnmapMemObject$handle() {
        return clEnqueueUnmapMemObject.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern cl_int clEnqueueUnmapMemObject(cl_command_queue command_queue, cl_mem memobj, void *mapped_ptr, cl_uint num_events_in_wait_list, const cl_event *event_wait_list, cl_event *event)
     * }
     */
    public static int clEnqueueUnmapMemObject(MemorySegment command_queue, MemorySegment memobj, MemorySegment mapped_ptr, int num_events_in_wait_list, MemorySegment event_wait_list, MemorySegment event) {
        var mh$ = clEnqueueUnmapMemObject.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clEnqueueUnmapMemObject", command_queue, memobj, mapped_ptr, num_events_in_wait_list, event_wait_list, event);
            }
            return (int)mh$.invokeExact(command_queue, memobj, mapped_ptr, num_events_in_wait_list, event_wait_list, event);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clEnqueueMigrateMemObjects {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_INT,
            C_POINTER,
            C_LONG_LONG,
            C_INT,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("clEnqueueMigrateMemObjects"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern cl_int clEnqueueMigrateMemObjects(cl_command_queue command_queue, cl_uint num_mem_objects, const cl_mem *mem_objects, cl_mem_migration_flags flags, cl_uint num_events_in_wait_list, const cl_event *event_wait_list, cl_event *event)
     * }
     */
    public static FunctionDescriptor clEnqueueMigrateMemObjects$descriptor() {
        return clEnqueueMigrateMemObjects.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern cl_int clEnqueueMigrateMemObjects(cl_command_queue command_queue, cl_uint num_mem_objects, const cl_mem *mem_objects, cl_mem_migration_flags flags, cl_uint num_events_in_wait_list, const cl_event *event_wait_list, cl_event *event)
     * }
     */
    public static MethodHandle clEnqueueMigrateMemObjects$handle() {
        return clEnqueueMigrateMemObjects.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern cl_int clEnqueueMigrateMemObjects(cl_command_queue command_queue, cl_uint num_mem_objects, const cl_mem *mem_objects, cl_mem_migration_flags flags, cl_uint num_events_in_wait_list, const cl_event *event_wait_list, cl_event *event)
     * }
     */
    public static int clEnqueueMigrateMemObjects(MemorySegment command_queue, int num_mem_objects, MemorySegment mem_objects, long flags, int num_events_in_wait_list, MemorySegment event_wait_list, MemorySegment event) {
        var mh$ = clEnqueueMigrateMemObjects.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clEnqueueMigrateMemObjects", command_queue, num_mem_objects, mem_objects, flags, num_events_in_wait_list, event_wait_list, event);
            }
            return (int)mh$.invokeExact(command_queue, num_mem_objects, mem_objects, flags, num_events_in_wait_list, event_wait_list, event);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clEnqueueNDRangeKernel {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_INT,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_INT,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("clEnqueueNDRangeKernel"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern cl_int clEnqueueNDRangeKernel(cl_command_queue command_queue, cl_kernel kernel, cl_uint work_dim, const size_t *global_work_offset, const size_t *global_work_size, const size_t *local_work_size, cl_uint num_events_in_wait_list, const cl_event *event_wait_list, cl_event *event)
     * }
     */
    public static FunctionDescriptor clEnqueueNDRangeKernel$descriptor() {
        return clEnqueueNDRangeKernel.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern cl_int clEnqueueNDRangeKernel(cl_command_queue command_queue, cl_kernel kernel, cl_uint work_dim, const size_t *global_work_offset, const size_t *global_work_size, const size_t *local_work_size, cl_uint num_events_in_wait_list, const cl_event *event_wait_list, cl_event *event)
     * }
     */
    public static MethodHandle clEnqueueNDRangeKernel$handle() {
        return clEnqueueNDRangeKernel.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern cl_int clEnqueueNDRangeKernel(cl_command_queue command_queue, cl_kernel kernel, cl_uint work_dim, const size_t *global_work_offset, const size_t *global_work_size, const size_t *local_work_size, cl_uint num_events_in_wait_list, const cl_event *event_wait_list, cl_event *event)
     * }
     */
    public static int clEnqueueNDRangeKernel(MemorySegment command_queue, MemorySegment kernel, int work_dim, MemorySegment global_work_offset, MemorySegment global_work_size, MemorySegment local_work_size, int num_events_in_wait_list, MemorySegment event_wait_list, MemorySegment event) {
        var mh$ = clEnqueueNDRangeKernel.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clEnqueueNDRangeKernel", command_queue, kernel, work_dim, global_work_offset, global_work_size, local_work_size, num_events_in_wait_list, event_wait_list, event);
            }
            return (int)mh$.invokeExact(command_queue, kernel, work_dim, global_work_offset, global_work_size, local_work_size, num_events_in_wait_list, event_wait_list, event);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clEnqueueNativeKernel {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_LONG_LONG,
            C_INT,
            C_POINTER,
            C_POINTER,
            C_INT,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("clEnqueueNativeKernel"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern cl_int clEnqueueNativeKernel(cl_command_queue command_queue, void (*user_func)(void *) __attribute__((stdcall)), void *args, size_t cb_args, cl_uint num_mem_objects, const cl_mem *mem_list, const void **args_mem_loc, cl_uint num_events_in_wait_list, const cl_event *event_wait_list, cl_event *event)
     * }
     */
    public static FunctionDescriptor clEnqueueNativeKernel$descriptor() {
        return clEnqueueNativeKernel.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern cl_int clEnqueueNativeKernel(cl_command_queue command_queue, void (*user_func)(void *) __attribute__((stdcall)), void *args, size_t cb_args, cl_uint num_mem_objects, const cl_mem *mem_list, const void **args_mem_loc, cl_uint num_events_in_wait_list, const cl_event *event_wait_list, cl_event *event)
     * }
     */
    public static MethodHandle clEnqueueNativeKernel$handle() {
        return clEnqueueNativeKernel.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern cl_int clEnqueueNativeKernel(cl_command_queue command_queue, void (*user_func)(void *) __attribute__((stdcall)), void *args, size_t cb_args, cl_uint num_mem_objects, const cl_mem *mem_list, const void **args_mem_loc, cl_uint num_events_in_wait_list, const cl_event *event_wait_list, cl_event *event)
     * }
     */
    public static int clEnqueueNativeKernel(MemorySegment command_queue, MemorySegment user_func, MemorySegment args, long cb_args, int num_mem_objects, MemorySegment mem_list, MemorySegment args_mem_loc, int num_events_in_wait_list, MemorySegment event_wait_list, MemorySegment event) {
        var mh$ = clEnqueueNativeKernel.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clEnqueueNativeKernel", command_queue, user_func, args, cb_args, num_mem_objects, mem_list, args_mem_loc, num_events_in_wait_list, event_wait_list, event);
            }
            return (int)mh$.invokeExact(command_queue, user_func, args, cb_args, num_mem_objects, mem_list, args_mem_loc, num_events_in_wait_list, event_wait_list, event);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clEnqueueMarkerWithWaitList {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_INT,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("clEnqueueMarkerWithWaitList"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern cl_int clEnqueueMarkerWithWaitList(cl_command_queue command_queue, cl_uint num_events_in_wait_list, const cl_event *event_wait_list, cl_event *event)
     * }
     */
    public static FunctionDescriptor clEnqueueMarkerWithWaitList$descriptor() {
        return clEnqueueMarkerWithWaitList.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern cl_int clEnqueueMarkerWithWaitList(cl_command_queue command_queue, cl_uint num_events_in_wait_list, const cl_event *event_wait_list, cl_event *event)
     * }
     */
    public static MethodHandle clEnqueueMarkerWithWaitList$handle() {
        return clEnqueueMarkerWithWaitList.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern cl_int clEnqueueMarkerWithWaitList(cl_command_queue command_queue, cl_uint num_events_in_wait_list, const cl_event *event_wait_list, cl_event *event)
     * }
     */
    public static int clEnqueueMarkerWithWaitList(MemorySegment command_queue, int num_events_in_wait_list, MemorySegment event_wait_list, MemorySegment event) {
        var mh$ = clEnqueueMarkerWithWaitList.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clEnqueueMarkerWithWaitList", command_queue, num_events_in_wait_list, event_wait_list, event);
            }
            return (int)mh$.invokeExact(command_queue, num_events_in_wait_list, event_wait_list, event);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clEnqueueBarrierWithWaitList {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_INT,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("clEnqueueBarrierWithWaitList"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern cl_int clEnqueueBarrierWithWaitList(cl_command_queue command_queue, cl_uint num_events_in_wait_list, const cl_event *event_wait_list, cl_event *event)
     * }
     */
    public static FunctionDescriptor clEnqueueBarrierWithWaitList$descriptor() {
        return clEnqueueBarrierWithWaitList.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern cl_int clEnqueueBarrierWithWaitList(cl_command_queue command_queue, cl_uint num_events_in_wait_list, const cl_event *event_wait_list, cl_event *event)
     * }
     */
    public static MethodHandle clEnqueueBarrierWithWaitList$handle() {
        return clEnqueueBarrierWithWaitList.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern cl_int clEnqueueBarrierWithWaitList(cl_command_queue command_queue, cl_uint num_events_in_wait_list, const cl_event *event_wait_list, cl_event *event)
     * }
     */
    public static int clEnqueueBarrierWithWaitList(MemorySegment command_queue, int num_events_in_wait_list, MemorySegment event_wait_list, MemorySegment event) {
        var mh$ = clEnqueueBarrierWithWaitList.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clEnqueueBarrierWithWaitList", command_queue, num_events_in_wait_list, event_wait_list, event);
            }
            return (int)mh$.invokeExact(command_queue, num_events_in_wait_list, event_wait_list, event);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clEnqueueSVMFree {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_INT,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_INT,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("clEnqueueSVMFree"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern cl_int clEnqueueSVMFree(cl_command_queue command_queue, cl_uint num_svm_pointers, void *svm_pointers[], void (*pfn_free_func)(cl_command_queue, cl_uint, void **, void *) __attribute__((stdcall)), void *user_data, cl_uint num_events_in_wait_list, const cl_event *event_wait_list, cl_event *event)
     * }
     */
    public static FunctionDescriptor clEnqueueSVMFree$descriptor() {
        return clEnqueueSVMFree.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern cl_int clEnqueueSVMFree(cl_command_queue command_queue, cl_uint num_svm_pointers, void *svm_pointers[], void (*pfn_free_func)(cl_command_queue, cl_uint, void **, void *) __attribute__((stdcall)), void *user_data, cl_uint num_events_in_wait_list, const cl_event *event_wait_list, cl_event *event)
     * }
     */
    public static MethodHandle clEnqueueSVMFree$handle() {
        return clEnqueueSVMFree.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern cl_int clEnqueueSVMFree(cl_command_queue command_queue, cl_uint num_svm_pointers, void *svm_pointers[], void (*pfn_free_func)(cl_command_queue, cl_uint, void **, void *) __attribute__((stdcall)), void *user_data, cl_uint num_events_in_wait_list, const cl_event *event_wait_list, cl_event *event)
     * }
     */
    public static int clEnqueueSVMFree(MemorySegment command_queue, int num_svm_pointers, MemorySegment svm_pointers, MemorySegment pfn_free_func, MemorySegment user_data, int num_events_in_wait_list, MemorySegment event_wait_list, MemorySegment event) {
        var mh$ = clEnqueueSVMFree.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clEnqueueSVMFree", command_queue, num_svm_pointers, svm_pointers, pfn_free_func, user_data, num_events_in_wait_list, event_wait_list, event);
            }
            return (int)mh$.invokeExact(command_queue, num_svm_pointers, svm_pointers, pfn_free_func, user_data, num_events_in_wait_list, event_wait_list, event);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clEnqueueSVMMemcpy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_INT,
            C_POINTER,
            C_POINTER,
            C_LONG_LONG,
            C_INT,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("clEnqueueSVMMemcpy"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern cl_int clEnqueueSVMMemcpy(cl_command_queue command_queue, cl_bool blocking_copy, void *dst_ptr, const void *src_ptr, size_t size, cl_uint num_events_in_wait_list, const cl_event *event_wait_list, cl_event *event)
     * }
     */
    public static FunctionDescriptor clEnqueueSVMMemcpy$descriptor() {
        return clEnqueueSVMMemcpy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern cl_int clEnqueueSVMMemcpy(cl_command_queue command_queue, cl_bool blocking_copy, void *dst_ptr, const void *src_ptr, size_t size, cl_uint num_events_in_wait_list, const cl_event *event_wait_list, cl_event *event)
     * }
     */
    public static MethodHandle clEnqueueSVMMemcpy$handle() {
        return clEnqueueSVMMemcpy.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern cl_int clEnqueueSVMMemcpy(cl_command_queue command_queue, cl_bool blocking_copy, void *dst_ptr, const void *src_ptr, size_t size, cl_uint num_events_in_wait_list, const cl_event *event_wait_list, cl_event *event)
     * }
     */
    public static int clEnqueueSVMMemcpy(MemorySegment command_queue, int blocking_copy, MemorySegment dst_ptr, MemorySegment src_ptr, long size, int num_events_in_wait_list, MemorySegment event_wait_list, MemorySegment event) {
        var mh$ = clEnqueueSVMMemcpy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clEnqueueSVMMemcpy", command_queue, blocking_copy, dst_ptr, src_ptr, size, num_events_in_wait_list, event_wait_list, event);
            }
            return (int)mh$.invokeExact(command_queue, blocking_copy, dst_ptr, src_ptr, size, num_events_in_wait_list, event_wait_list, event);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clEnqueueSVMMemFill {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_LONG_LONG,
            C_LONG_LONG,
            C_INT,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("clEnqueueSVMMemFill"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern cl_int clEnqueueSVMMemFill(cl_command_queue command_queue, void *svm_ptr, const void *pattern, size_t pattern_size, size_t size, cl_uint num_events_in_wait_list, const cl_event *event_wait_list, cl_event *event)
     * }
     */
    public static FunctionDescriptor clEnqueueSVMMemFill$descriptor() {
        return clEnqueueSVMMemFill.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern cl_int clEnqueueSVMMemFill(cl_command_queue command_queue, void *svm_ptr, const void *pattern, size_t pattern_size, size_t size, cl_uint num_events_in_wait_list, const cl_event *event_wait_list, cl_event *event)
     * }
     */
    public static MethodHandle clEnqueueSVMMemFill$handle() {
        return clEnqueueSVMMemFill.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern cl_int clEnqueueSVMMemFill(cl_command_queue command_queue, void *svm_ptr, const void *pattern, size_t pattern_size, size_t size, cl_uint num_events_in_wait_list, const cl_event *event_wait_list, cl_event *event)
     * }
     */
    public static int clEnqueueSVMMemFill(MemorySegment command_queue, MemorySegment svm_ptr, MemorySegment pattern, long pattern_size, long size, int num_events_in_wait_list, MemorySegment event_wait_list, MemorySegment event) {
        var mh$ = clEnqueueSVMMemFill.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clEnqueueSVMMemFill", command_queue, svm_ptr, pattern, pattern_size, size, num_events_in_wait_list, event_wait_list, event);
            }
            return (int)mh$.invokeExact(command_queue, svm_ptr, pattern, pattern_size, size, num_events_in_wait_list, event_wait_list, event);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clEnqueueSVMMap {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_INT,
            C_LONG_LONG,
            C_POINTER,
            C_LONG_LONG,
            C_INT,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("clEnqueueSVMMap"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern cl_int clEnqueueSVMMap(cl_command_queue command_queue, cl_bool blocking_map, cl_map_flags flags, void *svm_ptr, size_t size, cl_uint num_events_in_wait_list, const cl_event *event_wait_list, cl_event *event)
     * }
     */
    public static FunctionDescriptor clEnqueueSVMMap$descriptor() {
        return clEnqueueSVMMap.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern cl_int clEnqueueSVMMap(cl_command_queue command_queue, cl_bool blocking_map, cl_map_flags flags, void *svm_ptr, size_t size, cl_uint num_events_in_wait_list, const cl_event *event_wait_list, cl_event *event)
     * }
     */
    public static MethodHandle clEnqueueSVMMap$handle() {
        return clEnqueueSVMMap.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern cl_int clEnqueueSVMMap(cl_command_queue command_queue, cl_bool blocking_map, cl_map_flags flags, void *svm_ptr, size_t size, cl_uint num_events_in_wait_list, const cl_event *event_wait_list, cl_event *event)
     * }
     */
    public static int clEnqueueSVMMap(MemorySegment command_queue, int blocking_map, long flags, MemorySegment svm_ptr, long size, int num_events_in_wait_list, MemorySegment event_wait_list, MemorySegment event) {
        var mh$ = clEnqueueSVMMap.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clEnqueueSVMMap", command_queue, blocking_map, flags, svm_ptr, size, num_events_in_wait_list, event_wait_list, event);
            }
            return (int)mh$.invokeExact(command_queue, blocking_map, flags, svm_ptr, size, num_events_in_wait_list, event_wait_list, event);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clEnqueueSVMUnmap {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_INT,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("clEnqueueSVMUnmap"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern cl_int clEnqueueSVMUnmap(cl_command_queue command_queue, void *svm_ptr, cl_uint num_events_in_wait_list, const cl_event *event_wait_list, cl_event *event)
     * }
     */
    public static FunctionDescriptor clEnqueueSVMUnmap$descriptor() {
        return clEnqueueSVMUnmap.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern cl_int clEnqueueSVMUnmap(cl_command_queue command_queue, void *svm_ptr, cl_uint num_events_in_wait_list, const cl_event *event_wait_list, cl_event *event)
     * }
     */
    public static MethodHandle clEnqueueSVMUnmap$handle() {
        return clEnqueueSVMUnmap.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern cl_int clEnqueueSVMUnmap(cl_command_queue command_queue, void *svm_ptr, cl_uint num_events_in_wait_list, const cl_event *event_wait_list, cl_event *event)
     * }
     */
    public static int clEnqueueSVMUnmap(MemorySegment command_queue, MemorySegment svm_ptr, int num_events_in_wait_list, MemorySegment event_wait_list, MemorySegment event) {
        var mh$ = clEnqueueSVMUnmap.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clEnqueueSVMUnmap", command_queue, svm_ptr, num_events_in_wait_list, event_wait_list, event);
            }
            return (int)mh$.invokeExact(command_queue, svm_ptr, num_events_in_wait_list, event_wait_list, event);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clEnqueueSVMMigrateMem {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_INT,
            C_POINTER,
            C_POINTER,
            C_LONG_LONG,
            C_INT,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("clEnqueueSVMMigrateMem"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern cl_int clEnqueueSVMMigrateMem(cl_command_queue command_queue, cl_uint num_svm_pointers, const void **svm_pointers, const size_t *sizes, cl_mem_migration_flags flags, cl_uint num_events_in_wait_list, const cl_event *event_wait_list, cl_event *event)
     * }
     */
    public static FunctionDescriptor clEnqueueSVMMigrateMem$descriptor() {
        return clEnqueueSVMMigrateMem.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern cl_int clEnqueueSVMMigrateMem(cl_command_queue command_queue, cl_uint num_svm_pointers, const void **svm_pointers, const size_t *sizes, cl_mem_migration_flags flags, cl_uint num_events_in_wait_list, const cl_event *event_wait_list, cl_event *event)
     * }
     */
    public static MethodHandle clEnqueueSVMMigrateMem$handle() {
        return clEnqueueSVMMigrateMem.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern cl_int clEnqueueSVMMigrateMem(cl_command_queue command_queue, cl_uint num_svm_pointers, const void **svm_pointers, const size_t *sizes, cl_mem_migration_flags flags, cl_uint num_events_in_wait_list, const cl_event *event_wait_list, cl_event *event)
     * }
     */
    public static int clEnqueueSVMMigrateMem(MemorySegment command_queue, int num_svm_pointers, MemorySegment svm_pointers, MemorySegment sizes, long flags, int num_events_in_wait_list, MemorySegment event_wait_list, MemorySegment event) {
        var mh$ = clEnqueueSVMMigrateMem.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clEnqueueSVMMigrateMem", command_queue, num_svm_pointers, svm_pointers, sizes, flags, num_events_in_wait_list, event_wait_list, event);
            }
            return (int)mh$.invokeExact(command_queue, num_svm_pointers, svm_pointers, sizes, flags, num_events_in_wait_list, event_wait_list, event);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clGetExtensionFunctionAddressForPlatform {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("clGetExtensionFunctionAddressForPlatform"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void *clGetExtensionFunctionAddressForPlatform(cl_platform_id platform, const char *func_name)
     * }
     */
    public static FunctionDescriptor clGetExtensionFunctionAddressForPlatform$descriptor() {
        return clGetExtensionFunctionAddressForPlatform.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void *clGetExtensionFunctionAddressForPlatform(cl_platform_id platform, const char *func_name)
     * }
     */
    public static MethodHandle clGetExtensionFunctionAddressForPlatform$handle() {
        return clGetExtensionFunctionAddressForPlatform.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern void *clGetExtensionFunctionAddressForPlatform(cl_platform_id platform, const char *func_name)
     * }
     */
    public static MemorySegment clGetExtensionFunctionAddressForPlatform(MemorySegment platform, MemorySegment func_name) {
        var mh$ = clGetExtensionFunctionAddressForPlatform.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clGetExtensionFunctionAddressForPlatform", platform, func_name);
            }
            return (MemorySegment)mh$.invokeExact(platform, func_name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clCreateImage2D {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER,
            C_LONG_LONG,
            C_POINTER,
            C_LONG_LONG,
            C_LONG_LONG,
            C_LONG_LONG,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("clCreateImage2D"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern cl_mem clCreateImage2D(cl_context context, cl_mem_flags flags, const cl_image_format *image_format, size_t image_width, size_t image_height, size_t image_row_pitch, void *host_ptr, cl_int *errcode_ret)
     * }
     */
    public static FunctionDescriptor clCreateImage2D$descriptor() {
        return clCreateImage2D.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern cl_mem clCreateImage2D(cl_context context, cl_mem_flags flags, const cl_image_format *image_format, size_t image_width, size_t image_height, size_t image_row_pitch, void *host_ptr, cl_int *errcode_ret)
     * }
     */
    public static MethodHandle clCreateImage2D$handle() {
        return clCreateImage2D.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern cl_mem clCreateImage2D(cl_context context, cl_mem_flags flags, const cl_image_format *image_format, size_t image_width, size_t image_height, size_t image_row_pitch, void *host_ptr, cl_int *errcode_ret)
     * }
     */
    public static MemorySegment clCreateImage2D(MemorySegment context, long flags, MemorySegment image_format, long image_width, long image_height, long image_row_pitch, MemorySegment host_ptr, MemorySegment errcode_ret) {
        var mh$ = clCreateImage2D.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clCreateImage2D", context, flags, image_format, image_width, image_height, image_row_pitch, host_ptr, errcode_ret);
            }
            return (MemorySegment)mh$.invokeExact(context, flags, image_format, image_width, image_height, image_row_pitch, host_ptr, errcode_ret);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clCreateImage3D {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER,
            C_LONG_LONG,
            C_POINTER,
            C_LONG_LONG,
            C_LONG_LONG,
            C_LONG_LONG,
            C_LONG_LONG,
            C_LONG_LONG,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("clCreateImage3D"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern cl_mem clCreateImage3D(cl_context context, cl_mem_flags flags, const cl_image_format *image_format, size_t image_width, size_t image_height, size_t image_depth, size_t image_row_pitch, size_t image_slice_pitch, void *host_ptr, cl_int *errcode_ret)
     * }
     */
    public static FunctionDescriptor clCreateImage3D$descriptor() {
        return clCreateImage3D.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern cl_mem clCreateImage3D(cl_context context, cl_mem_flags flags, const cl_image_format *image_format, size_t image_width, size_t image_height, size_t image_depth, size_t image_row_pitch, size_t image_slice_pitch, void *host_ptr, cl_int *errcode_ret)
     * }
     */
    public static MethodHandle clCreateImage3D$handle() {
        return clCreateImage3D.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern cl_mem clCreateImage3D(cl_context context, cl_mem_flags flags, const cl_image_format *image_format, size_t image_width, size_t image_height, size_t image_depth, size_t image_row_pitch, size_t image_slice_pitch, void *host_ptr, cl_int *errcode_ret)
     * }
     */
    public static MemorySegment clCreateImage3D(MemorySegment context, long flags, MemorySegment image_format, long image_width, long image_height, long image_depth, long image_row_pitch, long image_slice_pitch, MemorySegment host_ptr, MemorySegment errcode_ret) {
        var mh$ = clCreateImage3D.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clCreateImage3D", context, flags, image_format, image_width, image_height, image_depth, image_row_pitch, image_slice_pitch, host_ptr, errcode_ret);
            }
            return (MemorySegment)mh$.invokeExact(context, flags, image_format, image_width, image_height, image_depth, image_row_pitch, image_slice_pitch, host_ptr, errcode_ret);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clEnqueueMarker {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("clEnqueueMarker"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern cl_int clEnqueueMarker(cl_command_queue command_queue, cl_event *event)
     * }
     */
    public static FunctionDescriptor clEnqueueMarker$descriptor() {
        return clEnqueueMarker.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern cl_int clEnqueueMarker(cl_command_queue command_queue, cl_event *event)
     * }
     */
    public static MethodHandle clEnqueueMarker$handle() {
        return clEnqueueMarker.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern cl_int clEnqueueMarker(cl_command_queue command_queue, cl_event *event)
     * }
     */
    public static int clEnqueueMarker(MemorySegment command_queue, MemorySegment event) {
        var mh$ = clEnqueueMarker.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clEnqueueMarker", command_queue, event);
            }
            return (int)mh$.invokeExact(command_queue, event);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clEnqueueWaitForEvents {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("clEnqueueWaitForEvents"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern cl_int clEnqueueWaitForEvents(cl_command_queue command_queue, cl_uint num_events, const cl_event *event_list)
     * }
     */
    public static FunctionDescriptor clEnqueueWaitForEvents$descriptor() {
        return clEnqueueWaitForEvents.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern cl_int clEnqueueWaitForEvents(cl_command_queue command_queue, cl_uint num_events, const cl_event *event_list)
     * }
     */
    public static MethodHandle clEnqueueWaitForEvents$handle() {
        return clEnqueueWaitForEvents.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern cl_int clEnqueueWaitForEvents(cl_command_queue command_queue, cl_uint num_events, const cl_event *event_list)
     * }
     */
    public static int clEnqueueWaitForEvents(MemorySegment command_queue, int num_events, MemorySegment event_list) {
        var mh$ = clEnqueueWaitForEvents.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clEnqueueWaitForEvents", command_queue, num_events, event_list);
            }
            return (int)mh$.invokeExact(command_queue, num_events, event_list);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clEnqueueBarrier {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("clEnqueueBarrier"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern cl_int clEnqueueBarrier(cl_command_queue command_queue)
     * }
     */
    public static FunctionDescriptor clEnqueueBarrier$descriptor() {
        return clEnqueueBarrier.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern cl_int clEnqueueBarrier(cl_command_queue command_queue)
     * }
     */
    public static MethodHandle clEnqueueBarrier$handle() {
        return clEnqueueBarrier.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern cl_int clEnqueueBarrier(cl_command_queue command_queue)
     * }
     */
    public static int clEnqueueBarrier(MemorySegment command_queue) {
        var mh$ = clEnqueueBarrier.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clEnqueueBarrier", command_queue);
            }
            return (int)mh$.invokeExact(command_queue);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clUnloadCompiler {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT    );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("clUnloadCompiler"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern cl_int clUnloadCompiler()
     * }
     */
    public static FunctionDescriptor clUnloadCompiler$descriptor() {
        return clUnloadCompiler.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern cl_int clUnloadCompiler()
     * }
     */
    public static MethodHandle clUnloadCompiler$handle() {
        return clUnloadCompiler.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern cl_int clUnloadCompiler()
     * }
     */
    public static int clUnloadCompiler() {
        var mh$ = clUnloadCompiler.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clUnloadCompiler");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clGetExtensionFunctionAddress {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("clGetExtensionFunctionAddress"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void *clGetExtensionFunctionAddress(const char *func_name)
     * }
     */
    public static FunctionDescriptor clGetExtensionFunctionAddress$descriptor() {
        return clGetExtensionFunctionAddress.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void *clGetExtensionFunctionAddress(const char *func_name)
     * }
     */
    public static MethodHandle clGetExtensionFunctionAddress$handle() {
        return clGetExtensionFunctionAddress.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern void *clGetExtensionFunctionAddress(const char *func_name)
     * }
     */
    public static MemorySegment clGetExtensionFunctionAddress(MemorySegment func_name) {
        var mh$ = clGetExtensionFunctionAddress.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clGetExtensionFunctionAddress", func_name);
            }
            return (MemorySegment)mh$.invokeExact(func_name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clCreateCommandQueue {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_LONG_LONG,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("clCreateCommandQueue"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern cl_command_queue clCreateCommandQueue(cl_context context, cl_device_id device, cl_command_queue_properties properties, cl_int *errcode_ret)
     * }
     */
    public static FunctionDescriptor clCreateCommandQueue$descriptor() {
        return clCreateCommandQueue.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern cl_command_queue clCreateCommandQueue(cl_context context, cl_device_id device, cl_command_queue_properties properties, cl_int *errcode_ret)
     * }
     */
    public static MethodHandle clCreateCommandQueue$handle() {
        return clCreateCommandQueue.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern cl_command_queue clCreateCommandQueue(cl_context context, cl_device_id device, cl_command_queue_properties properties, cl_int *errcode_ret)
     * }
     */
    public static MemorySegment clCreateCommandQueue(MemorySegment context, MemorySegment device, long properties, MemorySegment errcode_ret) {
        var mh$ = clCreateCommandQueue.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clCreateCommandQueue", context, device, properties, errcode_ret);
            }
            return (MemorySegment)mh$.invokeExact(context, device, properties, errcode_ret);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clCreateSampler {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER,
            C_INT,
            C_INT,
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("clCreateSampler"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern cl_sampler clCreateSampler(cl_context context, cl_bool normalized_coords, cl_addressing_mode addressing_mode, cl_filter_mode filter_mode, cl_int *errcode_ret)
     * }
     */
    public static FunctionDescriptor clCreateSampler$descriptor() {
        return clCreateSampler.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern cl_sampler clCreateSampler(cl_context context, cl_bool normalized_coords, cl_addressing_mode addressing_mode, cl_filter_mode filter_mode, cl_int *errcode_ret)
     * }
     */
    public static MethodHandle clCreateSampler$handle() {
        return clCreateSampler.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern cl_sampler clCreateSampler(cl_context context, cl_bool normalized_coords, cl_addressing_mode addressing_mode, cl_filter_mode filter_mode, cl_int *errcode_ret)
     * }
     */
    public static MemorySegment clCreateSampler(MemorySegment context, int normalized_coords, int addressing_mode, int filter_mode, MemorySegment errcode_ret) {
        var mh$ = clCreateSampler.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clCreateSampler", context, normalized_coords, addressing_mode, filter_mode, errcode_ret);
            }
            return (MemorySegment)mh$.invokeExact(context, normalized_coords, addressing_mode, filter_mode, errcode_ret);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clEnqueueTask {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_INT,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("clEnqueueTask"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern cl_int clEnqueueTask(cl_command_queue command_queue, cl_kernel kernel, cl_uint num_events_in_wait_list, const cl_event *event_wait_list, cl_event *event)
     * }
     */
    public static FunctionDescriptor clEnqueueTask$descriptor() {
        return clEnqueueTask.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern cl_int clEnqueueTask(cl_command_queue command_queue, cl_kernel kernel, cl_uint num_events_in_wait_list, const cl_event *event_wait_list, cl_event *event)
     * }
     */
    public static MethodHandle clEnqueueTask$handle() {
        return clEnqueueTask.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern cl_int clEnqueueTask(cl_command_queue command_queue, cl_kernel kernel, cl_uint num_events_in_wait_list, const cl_event *event_wait_list, cl_event *event)
     * }
     */
    public static int clEnqueueTask(MemorySegment command_queue, MemorySegment kernel, int num_events_in_wait_list, MemorySegment event_wait_list, MemorySegment event) {
        var mh$ = clEnqueueTask.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clEnqueueTask", command_queue, kernel, num_events_in_wait_list, event_wait_list, event);
            }
            return (int)mh$.invokeExact(command_queue, kernel, num_events_in_wait_list, event_wait_list, event);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef cl_uint cl_gl_context_info
     * }
     */
    public static final OfInt cl_gl_context_info = C_INT;
    /**
     * {@snippet lang=c :
     * typedef cl_uint cl_gl_object_type
     * }
     */
    public static final OfInt cl_gl_object_type = C_INT;
    /**
     * {@snippet lang=c :
     * typedef cl_uint cl_gl_texture_info
     * }
     */
    public static final OfInt cl_gl_texture_info = C_INT;
    /**
     * {@snippet lang=c :
     * typedef cl_uint cl_gl_platform_info
     * }
     */
    public static final OfInt cl_gl_platform_info = C_INT;

    private static class clGetGLContextInfoKHR {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_INT,
            C_LONG_LONG,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("clGetGLContextInfoKHR"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern cl_int clGetGLContextInfoKHR(const cl_context_properties *properties, cl_gl_context_info param_name, size_t param_value_size, void *param_value, size_t *param_value_size_ret)
     * }
     */
    public static FunctionDescriptor clGetGLContextInfoKHR$descriptor() {
        return clGetGLContextInfoKHR.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern cl_int clGetGLContextInfoKHR(const cl_context_properties *properties, cl_gl_context_info param_name, size_t param_value_size, void *param_value, size_t *param_value_size_ret)
     * }
     */
    public static MethodHandle clGetGLContextInfoKHR$handle() {
        return clGetGLContextInfoKHR.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern cl_int clGetGLContextInfoKHR(const cl_context_properties *properties, cl_gl_context_info param_name, size_t param_value_size, void *param_value, size_t *param_value_size_ret)
     * }
     */
    public static int clGetGLContextInfoKHR(MemorySegment properties, int param_name, long param_value_size, MemorySegment param_value, MemorySegment param_value_size_ret) {
        var mh$ = clGetGLContextInfoKHR.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clGetGLContextInfoKHR", properties, param_name, param_value_size, param_value, param_value_size_ret);
            }
            return (int)mh$.invokeExact(properties, param_name, param_value_size, param_value, param_value_size_ret);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clCreateFromGLBuffer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER,
            C_LONG_LONG,
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("clCreateFromGLBuffer"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern cl_mem clCreateFromGLBuffer(cl_context context, cl_mem_flags flags, cl_GLuint bufobj, cl_int *errcode_ret)
     * }
     */
    public static FunctionDescriptor clCreateFromGLBuffer$descriptor() {
        return clCreateFromGLBuffer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern cl_mem clCreateFromGLBuffer(cl_context context, cl_mem_flags flags, cl_GLuint bufobj, cl_int *errcode_ret)
     * }
     */
    public static MethodHandle clCreateFromGLBuffer$handle() {
        return clCreateFromGLBuffer.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern cl_mem clCreateFromGLBuffer(cl_context context, cl_mem_flags flags, cl_GLuint bufobj, cl_int *errcode_ret)
     * }
     */
    public static MemorySegment clCreateFromGLBuffer(MemorySegment context, long flags, int bufobj, MemorySegment errcode_ret) {
        var mh$ = clCreateFromGLBuffer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clCreateFromGLBuffer", context, flags, bufobj, errcode_ret);
            }
            return (MemorySegment)mh$.invokeExact(context, flags, bufobj, errcode_ret);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clCreateFromGLTexture {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER,
            C_LONG_LONG,
            C_INT,
            C_INT,
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("clCreateFromGLTexture"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern cl_mem clCreateFromGLTexture(cl_context context, cl_mem_flags flags, cl_GLenum target, cl_GLint miplevel, cl_GLuint texture, cl_int *errcode_ret)
     * }
     */
    public static FunctionDescriptor clCreateFromGLTexture$descriptor() {
        return clCreateFromGLTexture.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern cl_mem clCreateFromGLTexture(cl_context context, cl_mem_flags flags, cl_GLenum target, cl_GLint miplevel, cl_GLuint texture, cl_int *errcode_ret)
     * }
     */
    public static MethodHandle clCreateFromGLTexture$handle() {
        return clCreateFromGLTexture.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern cl_mem clCreateFromGLTexture(cl_context context, cl_mem_flags flags, cl_GLenum target, cl_GLint miplevel, cl_GLuint texture, cl_int *errcode_ret)
     * }
     */
    public static MemorySegment clCreateFromGLTexture(MemorySegment context, long flags, int target, int miplevel, int texture, MemorySegment errcode_ret) {
        var mh$ = clCreateFromGLTexture.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clCreateFromGLTexture", context, flags, target, miplevel, texture, errcode_ret);
            }
            return (MemorySegment)mh$.invokeExact(context, flags, target, miplevel, texture, errcode_ret);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clCreateFromGLRenderbuffer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER,
            C_LONG_LONG,
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("clCreateFromGLRenderbuffer"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern cl_mem clCreateFromGLRenderbuffer(cl_context context, cl_mem_flags flags, cl_GLuint renderbuffer, cl_int *errcode_ret)
     * }
     */
    public static FunctionDescriptor clCreateFromGLRenderbuffer$descriptor() {
        return clCreateFromGLRenderbuffer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern cl_mem clCreateFromGLRenderbuffer(cl_context context, cl_mem_flags flags, cl_GLuint renderbuffer, cl_int *errcode_ret)
     * }
     */
    public static MethodHandle clCreateFromGLRenderbuffer$handle() {
        return clCreateFromGLRenderbuffer.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern cl_mem clCreateFromGLRenderbuffer(cl_context context, cl_mem_flags flags, cl_GLuint renderbuffer, cl_int *errcode_ret)
     * }
     */
    public static MemorySegment clCreateFromGLRenderbuffer(MemorySegment context, long flags, int renderbuffer, MemorySegment errcode_ret) {
        var mh$ = clCreateFromGLRenderbuffer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clCreateFromGLRenderbuffer", context, flags, renderbuffer, errcode_ret);
            }
            return (MemorySegment)mh$.invokeExact(context, flags, renderbuffer, errcode_ret);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clGetGLObjectInfo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("clGetGLObjectInfo"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern cl_int clGetGLObjectInfo(cl_mem memobj, cl_gl_object_type *gl_object_type, cl_GLuint *gl_object_name)
     * }
     */
    public static FunctionDescriptor clGetGLObjectInfo$descriptor() {
        return clGetGLObjectInfo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern cl_int clGetGLObjectInfo(cl_mem memobj, cl_gl_object_type *gl_object_type, cl_GLuint *gl_object_name)
     * }
     */
    public static MethodHandle clGetGLObjectInfo$handle() {
        return clGetGLObjectInfo.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern cl_int clGetGLObjectInfo(cl_mem memobj, cl_gl_object_type *gl_object_type, cl_GLuint *gl_object_name)
     * }
     */
    public static int clGetGLObjectInfo(MemorySegment memobj, MemorySegment gl_object_type, MemorySegment gl_object_name) {
        var mh$ = clGetGLObjectInfo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clGetGLObjectInfo", memobj, gl_object_type, gl_object_name);
            }
            return (int)mh$.invokeExact(memobj, gl_object_type, gl_object_name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clGetGLTextureInfo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_INT,
            C_LONG_LONG,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("clGetGLTextureInfo"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern cl_int clGetGLTextureInfo(cl_mem memobj, cl_gl_texture_info param_name, size_t param_value_size, void *param_value, size_t *param_value_size_ret)
     * }
     */
    public static FunctionDescriptor clGetGLTextureInfo$descriptor() {
        return clGetGLTextureInfo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern cl_int clGetGLTextureInfo(cl_mem memobj, cl_gl_texture_info param_name, size_t param_value_size, void *param_value, size_t *param_value_size_ret)
     * }
     */
    public static MethodHandle clGetGLTextureInfo$handle() {
        return clGetGLTextureInfo.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern cl_int clGetGLTextureInfo(cl_mem memobj, cl_gl_texture_info param_name, size_t param_value_size, void *param_value, size_t *param_value_size_ret)
     * }
     */
    public static int clGetGLTextureInfo(MemorySegment memobj, int param_name, long param_value_size, MemorySegment param_value, MemorySegment param_value_size_ret) {
        var mh$ = clGetGLTextureInfo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clGetGLTextureInfo", memobj, param_name, param_value_size, param_value, param_value_size_ret);
            }
            return (int)mh$.invokeExact(memobj, param_name, param_value_size, param_value, param_value_size_ret);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clEnqueueAcquireGLObjects {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_INT,
            C_POINTER,
            C_INT,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("clEnqueueAcquireGLObjects"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern cl_int clEnqueueAcquireGLObjects(cl_command_queue command_queue, cl_uint num_objects, const cl_mem *mem_objects, cl_uint num_events_in_wait_list, const cl_event *event_wait_list, cl_event *event)
     * }
     */
    public static FunctionDescriptor clEnqueueAcquireGLObjects$descriptor() {
        return clEnqueueAcquireGLObjects.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern cl_int clEnqueueAcquireGLObjects(cl_command_queue command_queue, cl_uint num_objects, const cl_mem *mem_objects, cl_uint num_events_in_wait_list, const cl_event *event_wait_list, cl_event *event)
     * }
     */
    public static MethodHandle clEnqueueAcquireGLObjects$handle() {
        return clEnqueueAcquireGLObjects.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern cl_int clEnqueueAcquireGLObjects(cl_command_queue command_queue, cl_uint num_objects, const cl_mem *mem_objects, cl_uint num_events_in_wait_list, const cl_event *event_wait_list, cl_event *event)
     * }
     */
    public static int clEnqueueAcquireGLObjects(MemorySegment command_queue, int num_objects, MemorySegment mem_objects, int num_events_in_wait_list, MemorySegment event_wait_list, MemorySegment event) {
        var mh$ = clEnqueueAcquireGLObjects.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clEnqueueAcquireGLObjects", command_queue, num_objects, mem_objects, num_events_in_wait_list, event_wait_list, event);
            }
            return (int)mh$.invokeExact(command_queue, num_objects, mem_objects, num_events_in_wait_list, event_wait_list, event);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clEnqueueReleaseGLObjects {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_INT,
            C_POINTER,
            C_INT,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("clEnqueueReleaseGLObjects"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern cl_int clEnqueueReleaseGLObjects(cl_command_queue command_queue, cl_uint num_objects, const cl_mem *mem_objects, cl_uint num_events_in_wait_list, const cl_event *event_wait_list, cl_event *event)
     * }
     */
    public static FunctionDescriptor clEnqueueReleaseGLObjects$descriptor() {
        return clEnqueueReleaseGLObjects.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern cl_int clEnqueueReleaseGLObjects(cl_command_queue command_queue, cl_uint num_objects, const cl_mem *mem_objects, cl_uint num_events_in_wait_list, const cl_event *event_wait_list, cl_event *event)
     * }
     */
    public static MethodHandle clEnqueueReleaseGLObjects$handle() {
        return clEnqueueReleaseGLObjects.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern cl_int clEnqueueReleaseGLObjects(cl_command_queue command_queue, cl_uint num_objects, const cl_mem *mem_objects, cl_uint num_events_in_wait_list, const cl_event *event_wait_list, cl_event *event)
     * }
     */
    public static int clEnqueueReleaseGLObjects(MemorySegment command_queue, int num_objects, MemorySegment mem_objects, int num_events_in_wait_list, MemorySegment event_wait_list, MemorySegment event) {
        var mh$ = clEnqueueReleaseGLObjects.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clEnqueueReleaseGLObjects", command_queue, num_objects, mem_objects, num_events_in_wait_list, event_wait_list, event);
            }
            return (int)mh$.invokeExact(command_queue, num_objects, mem_objects, num_events_in_wait_list, event_wait_list, event);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clCreateFromGLTexture2D {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER,
            C_LONG_LONG,
            C_INT,
            C_INT,
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("clCreateFromGLTexture2D"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern cl_mem clCreateFromGLTexture2D(cl_context context, cl_mem_flags flags, cl_GLenum target, cl_GLint miplevel, cl_GLuint texture, cl_int *errcode_ret)
     * }
     */
    public static FunctionDescriptor clCreateFromGLTexture2D$descriptor() {
        return clCreateFromGLTexture2D.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern cl_mem clCreateFromGLTexture2D(cl_context context, cl_mem_flags flags, cl_GLenum target, cl_GLint miplevel, cl_GLuint texture, cl_int *errcode_ret)
     * }
     */
    public static MethodHandle clCreateFromGLTexture2D$handle() {
        return clCreateFromGLTexture2D.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern cl_mem clCreateFromGLTexture2D(cl_context context, cl_mem_flags flags, cl_GLenum target, cl_GLint miplevel, cl_GLuint texture, cl_int *errcode_ret)
     * }
     */
    public static MemorySegment clCreateFromGLTexture2D(MemorySegment context, long flags, int target, int miplevel, int texture, MemorySegment errcode_ret) {
        var mh$ = clCreateFromGLTexture2D.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clCreateFromGLTexture2D", context, flags, target, miplevel, texture, errcode_ret);
            }
            return (MemorySegment)mh$.invokeExact(context, flags, target, miplevel, texture, errcode_ret);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clCreateFromGLTexture3D {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER,
            C_LONG_LONG,
            C_INT,
            C_INT,
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("clCreateFromGLTexture3D"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern cl_mem clCreateFromGLTexture3D(cl_context context, cl_mem_flags flags, cl_GLenum target, cl_GLint miplevel, cl_GLuint texture, cl_int *errcode_ret)
     * }
     */
    public static FunctionDescriptor clCreateFromGLTexture3D$descriptor() {
        return clCreateFromGLTexture3D.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern cl_mem clCreateFromGLTexture3D(cl_context context, cl_mem_flags flags, cl_GLenum target, cl_GLint miplevel, cl_GLuint texture, cl_int *errcode_ret)
     * }
     */
    public static MethodHandle clCreateFromGLTexture3D$handle() {
        return clCreateFromGLTexture3D.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern cl_mem clCreateFromGLTexture3D(cl_context context, cl_mem_flags flags, cl_GLenum target, cl_GLint miplevel, cl_GLuint texture, cl_int *errcode_ret)
     * }
     */
    public static MemorySegment clCreateFromGLTexture3D(MemorySegment context, long flags, int target, int miplevel, int texture, MemorySegment errcode_ret) {
        var mh$ = clCreateFromGLTexture3D.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clCreateFromGLTexture3D", context, flags, target, miplevel, texture, errcode_ret);
            }
            return (MemorySegment)mh$.invokeExact(context, flags, target, miplevel, texture, errcode_ret);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct __GLsync *cl_GLsync
     * }
     */
    public static final AddressLayout cl_GLsync = C_POINTER;

    private static class clCreateEventFromGLsyncKHR {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("clCreateEventFromGLsyncKHR"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern cl_event clCreateEventFromGLsyncKHR(cl_context context, cl_GLsync sync, cl_int *errcode_ret)
     * }
     */
    public static FunctionDescriptor clCreateEventFromGLsyncKHR$descriptor() {
        return clCreateEventFromGLsyncKHR.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern cl_event clCreateEventFromGLsyncKHR(cl_context context, cl_GLsync sync, cl_int *errcode_ret)
     * }
     */
    public static MethodHandle clCreateEventFromGLsyncKHR$handle() {
        return clCreateEventFromGLsyncKHR.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern cl_event clCreateEventFromGLsyncKHR(cl_context context, cl_GLsync sync, cl_int *errcode_ret)
     * }
     */
    public static MemorySegment clCreateEventFromGLsyncKHR(MemorySegment context, MemorySegment sync, MemorySegment errcode_ret) {
        var mh$ = clCreateEventFromGLsyncKHR.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clCreateEventFromGLsyncKHR", context, sync, errcode_ret);
            }
            return (MemorySegment)mh$.invokeExact(context, sync, errcode_ret);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clGetSupportedGLTextureFormatsINTEL {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_LONG_LONG,
            C_INT,
            C_INT,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("clGetSupportedGLTextureFormatsINTEL"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern cl_int clGetSupportedGLTextureFormatsINTEL(cl_context context, cl_mem_flags flags, cl_mem_object_type image_type, cl_uint num_entries, cl_GLenum *gl_formats, cl_uint *num_texture_formats)
     * }
     */
    public static FunctionDescriptor clGetSupportedGLTextureFormatsINTEL$descriptor() {
        return clGetSupportedGLTextureFormatsINTEL.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern cl_int clGetSupportedGLTextureFormatsINTEL(cl_context context, cl_mem_flags flags, cl_mem_object_type image_type, cl_uint num_entries, cl_GLenum *gl_formats, cl_uint *num_texture_formats)
     * }
     */
    public static MethodHandle clGetSupportedGLTextureFormatsINTEL$handle() {
        return clGetSupportedGLTextureFormatsINTEL.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern cl_int clGetSupportedGLTextureFormatsINTEL(cl_context context, cl_mem_flags flags, cl_mem_object_type image_type, cl_uint num_entries, cl_GLenum *gl_formats, cl_uint *num_texture_formats)
     * }
     */
    public static int clGetSupportedGLTextureFormatsINTEL(MemorySegment context, long flags, int image_type, int num_entries, MemorySegment gl_formats, MemorySegment num_texture_formats) {
        var mh$ = clGetSupportedGLTextureFormatsINTEL.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clGetSupportedGLTextureFormatsINTEL", context, flags, image_type, num_entries, gl_formats, num_texture_formats);
            }
            return (int)mh$.invokeExact(context, flags, image_type, num_entries, gl_formats, num_texture_formats);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef cl_bitfield cl_device_command_buffer_capabilities_khr
     * }
     */
    public static final OfLong cl_device_command_buffer_capabilities_khr = C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef struct _cl_command_buffer_khr *cl_command_buffer_khr
     * }
     */
    public static final AddressLayout cl_command_buffer_khr = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef cl_uint cl_sync_point_khr
     * }
     */
    public static final OfInt cl_sync_point_khr = C_INT;
    /**
     * {@snippet lang=c :
     * typedef cl_uint cl_command_buffer_info_khr
     * }
     */
    public static final OfInt cl_command_buffer_info_khr = C_INT;
    /**
     * {@snippet lang=c :
     * typedef cl_uint cl_command_buffer_state_khr
     * }
     */
    public static final OfInt cl_command_buffer_state_khr = C_INT;
    /**
     * {@snippet lang=c :
     * typedef cl_properties cl_command_buffer_properties_khr
     * }
     */
    public static final OfLong cl_command_buffer_properties_khr = C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef cl_bitfield cl_command_buffer_flags_khr
     * }
     */
    public static final OfLong cl_command_buffer_flags_khr = C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef cl_properties cl_ndrange_kernel_command_properties_khr
     * }
     */
    public static final OfLong cl_ndrange_kernel_command_properties_khr = C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef struct _cl_mutable_command_khr *cl_mutable_command_khr
     * }
     */
    public static final AddressLayout cl_mutable_command_khr = C_POINTER;

    private static class clCreateCommandBufferKHR {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_INT,
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("clCreateCommandBufferKHR"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern cl_command_buffer_khr clCreateCommandBufferKHR(cl_uint num_queues, const cl_command_queue *queues, const cl_command_buffer_properties_khr *properties, cl_int *errcode_ret)
     * }
     */
    public static FunctionDescriptor clCreateCommandBufferKHR$descriptor() {
        return clCreateCommandBufferKHR.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern cl_command_buffer_khr clCreateCommandBufferKHR(cl_uint num_queues, const cl_command_queue *queues, const cl_command_buffer_properties_khr *properties, cl_int *errcode_ret)
     * }
     */
    public static MethodHandle clCreateCommandBufferKHR$handle() {
        return clCreateCommandBufferKHR.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern cl_command_buffer_khr clCreateCommandBufferKHR(cl_uint num_queues, const cl_command_queue *queues, const cl_command_buffer_properties_khr *properties, cl_int *errcode_ret)
     * }
     */
    public static MemorySegment clCreateCommandBufferKHR(int num_queues, MemorySegment queues, MemorySegment properties, MemorySegment errcode_ret) {
        var mh$ = clCreateCommandBufferKHR.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clCreateCommandBufferKHR", num_queues, queues, properties, errcode_ret);
            }
            return (MemorySegment)mh$.invokeExact(num_queues, queues, properties, errcode_ret);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clFinalizeCommandBufferKHR {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("clFinalizeCommandBufferKHR"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern cl_int clFinalizeCommandBufferKHR(cl_command_buffer_khr command_buffer)
     * }
     */
    public static FunctionDescriptor clFinalizeCommandBufferKHR$descriptor() {
        return clFinalizeCommandBufferKHR.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern cl_int clFinalizeCommandBufferKHR(cl_command_buffer_khr command_buffer)
     * }
     */
    public static MethodHandle clFinalizeCommandBufferKHR$handle() {
        return clFinalizeCommandBufferKHR.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern cl_int clFinalizeCommandBufferKHR(cl_command_buffer_khr command_buffer)
     * }
     */
    public static int clFinalizeCommandBufferKHR(MemorySegment command_buffer) {
        var mh$ = clFinalizeCommandBufferKHR.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clFinalizeCommandBufferKHR", command_buffer);
            }
            return (int)mh$.invokeExact(command_buffer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clRetainCommandBufferKHR {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("clRetainCommandBufferKHR"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern cl_int clRetainCommandBufferKHR(cl_command_buffer_khr command_buffer)
     * }
     */
    public static FunctionDescriptor clRetainCommandBufferKHR$descriptor() {
        return clRetainCommandBufferKHR.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern cl_int clRetainCommandBufferKHR(cl_command_buffer_khr command_buffer)
     * }
     */
    public static MethodHandle clRetainCommandBufferKHR$handle() {
        return clRetainCommandBufferKHR.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern cl_int clRetainCommandBufferKHR(cl_command_buffer_khr command_buffer)
     * }
     */
    public static int clRetainCommandBufferKHR(MemorySegment command_buffer) {
        var mh$ = clRetainCommandBufferKHR.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clRetainCommandBufferKHR", command_buffer);
            }
            return (int)mh$.invokeExact(command_buffer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clReleaseCommandBufferKHR {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("clReleaseCommandBufferKHR"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern cl_int clReleaseCommandBufferKHR(cl_command_buffer_khr command_buffer)
     * }
     */
    public static FunctionDescriptor clReleaseCommandBufferKHR$descriptor() {
        return clReleaseCommandBufferKHR.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern cl_int clReleaseCommandBufferKHR(cl_command_buffer_khr command_buffer)
     * }
     */
    public static MethodHandle clReleaseCommandBufferKHR$handle() {
        return clReleaseCommandBufferKHR.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern cl_int clReleaseCommandBufferKHR(cl_command_buffer_khr command_buffer)
     * }
     */
    public static int clReleaseCommandBufferKHR(MemorySegment command_buffer) {
        var mh$ = clReleaseCommandBufferKHR.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clReleaseCommandBufferKHR", command_buffer);
            }
            return (int)mh$.invokeExact(command_buffer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clEnqueueCommandBufferKHR {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_INT,
            C_POINTER,
            C_POINTER,
            C_INT,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("clEnqueueCommandBufferKHR"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern cl_int clEnqueueCommandBufferKHR(cl_uint num_queues, cl_command_queue *queues, cl_command_buffer_khr command_buffer, cl_uint num_events_in_wait_list, const cl_event *event_wait_list, cl_event *event)
     * }
     */
    public static FunctionDescriptor clEnqueueCommandBufferKHR$descriptor() {
        return clEnqueueCommandBufferKHR.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern cl_int clEnqueueCommandBufferKHR(cl_uint num_queues, cl_command_queue *queues, cl_command_buffer_khr command_buffer, cl_uint num_events_in_wait_list, const cl_event *event_wait_list, cl_event *event)
     * }
     */
    public static MethodHandle clEnqueueCommandBufferKHR$handle() {
        return clEnqueueCommandBufferKHR.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern cl_int clEnqueueCommandBufferKHR(cl_uint num_queues, cl_command_queue *queues, cl_command_buffer_khr command_buffer, cl_uint num_events_in_wait_list, const cl_event *event_wait_list, cl_event *event)
     * }
     */
    public static int clEnqueueCommandBufferKHR(int num_queues, MemorySegment queues, MemorySegment command_buffer, int num_events_in_wait_list, MemorySegment event_wait_list, MemorySegment event) {
        var mh$ = clEnqueueCommandBufferKHR.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clEnqueueCommandBufferKHR", num_queues, queues, command_buffer, num_events_in_wait_list, event_wait_list, event);
            }
            return (int)mh$.invokeExact(num_queues, queues, command_buffer, num_events_in_wait_list, event_wait_list, event);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clCommandBarrierWithWaitListKHR {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_INT,
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("clCommandBarrierWithWaitListKHR"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern cl_int clCommandBarrierWithWaitListKHR(cl_command_buffer_khr command_buffer, cl_command_queue command_queue, cl_uint num_sync_points_in_wait_list, const cl_sync_point_khr *sync_point_wait_list, cl_sync_point_khr *sync_point, cl_mutable_command_khr *mutable_handle)
     * }
     */
    public static FunctionDescriptor clCommandBarrierWithWaitListKHR$descriptor() {
        return clCommandBarrierWithWaitListKHR.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern cl_int clCommandBarrierWithWaitListKHR(cl_command_buffer_khr command_buffer, cl_command_queue command_queue, cl_uint num_sync_points_in_wait_list, const cl_sync_point_khr *sync_point_wait_list, cl_sync_point_khr *sync_point, cl_mutable_command_khr *mutable_handle)
     * }
     */
    public static MethodHandle clCommandBarrierWithWaitListKHR$handle() {
        return clCommandBarrierWithWaitListKHR.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern cl_int clCommandBarrierWithWaitListKHR(cl_command_buffer_khr command_buffer, cl_command_queue command_queue, cl_uint num_sync_points_in_wait_list, const cl_sync_point_khr *sync_point_wait_list, cl_sync_point_khr *sync_point, cl_mutable_command_khr *mutable_handle)
     * }
     */
    public static int clCommandBarrierWithWaitListKHR(MemorySegment command_buffer, MemorySegment command_queue, int num_sync_points_in_wait_list, MemorySegment sync_point_wait_list, MemorySegment sync_point, MemorySegment mutable_handle) {
        var mh$ = clCommandBarrierWithWaitListKHR.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clCommandBarrierWithWaitListKHR", command_buffer, command_queue, num_sync_points_in_wait_list, sync_point_wait_list, sync_point, mutable_handle);
            }
            return (int)mh$.invokeExact(command_buffer, command_queue, num_sync_points_in_wait_list, sync_point_wait_list, sync_point, mutable_handle);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clCommandCopyBufferKHR {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_LONG_LONG,
            C_LONG_LONG,
            C_LONG_LONG,
            C_INT,
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("clCommandCopyBufferKHR"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern cl_int clCommandCopyBufferKHR(cl_command_buffer_khr command_buffer, cl_command_queue command_queue, cl_mem src_buffer, cl_mem dst_buffer, size_t src_offset, size_t dst_offset, size_t size, cl_uint num_sync_points_in_wait_list, const cl_sync_point_khr *sync_point_wait_list, cl_sync_point_khr *sync_point, cl_mutable_command_khr *mutable_handle)
     * }
     */
    public static FunctionDescriptor clCommandCopyBufferKHR$descriptor() {
        return clCommandCopyBufferKHR.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern cl_int clCommandCopyBufferKHR(cl_command_buffer_khr command_buffer, cl_command_queue command_queue, cl_mem src_buffer, cl_mem dst_buffer, size_t src_offset, size_t dst_offset, size_t size, cl_uint num_sync_points_in_wait_list, const cl_sync_point_khr *sync_point_wait_list, cl_sync_point_khr *sync_point, cl_mutable_command_khr *mutable_handle)
     * }
     */
    public static MethodHandle clCommandCopyBufferKHR$handle() {
        return clCommandCopyBufferKHR.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern cl_int clCommandCopyBufferKHR(cl_command_buffer_khr command_buffer, cl_command_queue command_queue, cl_mem src_buffer, cl_mem dst_buffer, size_t src_offset, size_t dst_offset, size_t size, cl_uint num_sync_points_in_wait_list, const cl_sync_point_khr *sync_point_wait_list, cl_sync_point_khr *sync_point, cl_mutable_command_khr *mutable_handle)
     * }
     */
    public static int clCommandCopyBufferKHR(MemorySegment command_buffer, MemorySegment command_queue, MemorySegment src_buffer, MemorySegment dst_buffer, long src_offset, long dst_offset, long size, int num_sync_points_in_wait_list, MemorySegment sync_point_wait_list, MemorySegment sync_point, MemorySegment mutable_handle) {
        var mh$ = clCommandCopyBufferKHR.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clCommandCopyBufferKHR", command_buffer, command_queue, src_buffer, dst_buffer, src_offset, dst_offset, size, num_sync_points_in_wait_list, sync_point_wait_list, sync_point, mutable_handle);
            }
            return (int)mh$.invokeExact(command_buffer, command_queue, src_buffer, dst_buffer, src_offset, dst_offset, size, num_sync_points_in_wait_list, sync_point_wait_list, sync_point, mutable_handle);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clCommandCopyBufferRectKHR {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_LONG_LONG,
            C_LONG_LONG,
            C_LONG_LONG,
            C_LONG_LONG,
            C_INT,
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("clCommandCopyBufferRectKHR"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern cl_int clCommandCopyBufferRectKHR(cl_command_buffer_khr command_buffer, cl_command_queue command_queue, cl_mem src_buffer, cl_mem dst_buffer, const size_t *src_origin, const size_t *dst_origin, const size_t *region, size_t src_row_pitch, size_t src_slice_pitch, size_t dst_row_pitch, size_t dst_slice_pitch, cl_uint num_sync_points_in_wait_list, const cl_sync_point_khr *sync_point_wait_list, cl_sync_point_khr *sync_point, cl_mutable_command_khr *mutable_handle)
     * }
     */
    public static FunctionDescriptor clCommandCopyBufferRectKHR$descriptor() {
        return clCommandCopyBufferRectKHR.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern cl_int clCommandCopyBufferRectKHR(cl_command_buffer_khr command_buffer, cl_command_queue command_queue, cl_mem src_buffer, cl_mem dst_buffer, const size_t *src_origin, const size_t *dst_origin, const size_t *region, size_t src_row_pitch, size_t src_slice_pitch, size_t dst_row_pitch, size_t dst_slice_pitch, cl_uint num_sync_points_in_wait_list, const cl_sync_point_khr *sync_point_wait_list, cl_sync_point_khr *sync_point, cl_mutable_command_khr *mutable_handle)
     * }
     */
    public static MethodHandle clCommandCopyBufferRectKHR$handle() {
        return clCommandCopyBufferRectKHR.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern cl_int clCommandCopyBufferRectKHR(cl_command_buffer_khr command_buffer, cl_command_queue command_queue, cl_mem src_buffer, cl_mem dst_buffer, const size_t *src_origin, const size_t *dst_origin, const size_t *region, size_t src_row_pitch, size_t src_slice_pitch, size_t dst_row_pitch, size_t dst_slice_pitch, cl_uint num_sync_points_in_wait_list, const cl_sync_point_khr *sync_point_wait_list, cl_sync_point_khr *sync_point, cl_mutable_command_khr *mutable_handle)
     * }
     */
    public static int clCommandCopyBufferRectKHR(MemorySegment command_buffer, MemorySegment command_queue, MemorySegment src_buffer, MemorySegment dst_buffer, MemorySegment src_origin, MemorySegment dst_origin, MemorySegment region, long src_row_pitch, long src_slice_pitch, long dst_row_pitch, long dst_slice_pitch, int num_sync_points_in_wait_list, MemorySegment sync_point_wait_list, MemorySegment sync_point, MemorySegment mutable_handle) {
        var mh$ = clCommandCopyBufferRectKHR.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clCommandCopyBufferRectKHR", command_buffer, command_queue, src_buffer, dst_buffer, src_origin, dst_origin, region, src_row_pitch, src_slice_pitch, dst_row_pitch, dst_slice_pitch, num_sync_points_in_wait_list, sync_point_wait_list, sync_point, mutable_handle);
            }
            return (int)mh$.invokeExact(command_buffer, command_queue, src_buffer, dst_buffer, src_origin, dst_origin, region, src_row_pitch, src_slice_pitch, dst_row_pitch, dst_slice_pitch, num_sync_points_in_wait_list, sync_point_wait_list, sync_point, mutable_handle);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clCommandCopyBufferToImageKHR {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_LONG_LONG,
            C_POINTER,
            C_POINTER,
            C_INT,
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("clCommandCopyBufferToImageKHR"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern cl_int clCommandCopyBufferToImageKHR(cl_command_buffer_khr command_buffer, cl_command_queue command_queue, cl_mem src_buffer, cl_mem dst_image, size_t src_offset, const size_t *dst_origin, const size_t *region, cl_uint num_sync_points_in_wait_list, const cl_sync_point_khr *sync_point_wait_list, cl_sync_point_khr *sync_point, cl_mutable_command_khr *mutable_handle)
     * }
     */
    public static FunctionDescriptor clCommandCopyBufferToImageKHR$descriptor() {
        return clCommandCopyBufferToImageKHR.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern cl_int clCommandCopyBufferToImageKHR(cl_command_buffer_khr command_buffer, cl_command_queue command_queue, cl_mem src_buffer, cl_mem dst_image, size_t src_offset, const size_t *dst_origin, const size_t *region, cl_uint num_sync_points_in_wait_list, const cl_sync_point_khr *sync_point_wait_list, cl_sync_point_khr *sync_point, cl_mutable_command_khr *mutable_handle)
     * }
     */
    public static MethodHandle clCommandCopyBufferToImageKHR$handle() {
        return clCommandCopyBufferToImageKHR.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern cl_int clCommandCopyBufferToImageKHR(cl_command_buffer_khr command_buffer, cl_command_queue command_queue, cl_mem src_buffer, cl_mem dst_image, size_t src_offset, const size_t *dst_origin, const size_t *region, cl_uint num_sync_points_in_wait_list, const cl_sync_point_khr *sync_point_wait_list, cl_sync_point_khr *sync_point, cl_mutable_command_khr *mutable_handle)
     * }
     */
    public static int clCommandCopyBufferToImageKHR(MemorySegment command_buffer, MemorySegment command_queue, MemorySegment src_buffer, MemorySegment dst_image, long src_offset, MemorySegment dst_origin, MemorySegment region, int num_sync_points_in_wait_list, MemorySegment sync_point_wait_list, MemorySegment sync_point, MemorySegment mutable_handle) {
        var mh$ = clCommandCopyBufferToImageKHR.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clCommandCopyBufferToImageKHR", command_buffer, command_queue, src_buffer, dst_image, src_offset, dst_origin, region, num_sync_points_in_wait_list, sync_point_wait_list, sync_point, mutable_handle);
            }
            return (int)mh$.invokeExact(command_buffer, command_queue, src_buffer, dst_image, src_offset, dst_origin, region, num_sync_points_in_wait_list, sync_point_wait_list, sync_point, mutable_handle);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clCommandCopyImageKHR {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_INT,
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("clCommandCopyImageKHR"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern cl_int clCommandCopyImageKHR(cl_command_buffer_khr command_buffer, cl_command_queue command_queue, cl_mem src_image, cl_mem dst_image, const size_t *src_origin, const size_t *dst_origin, const size_t *region, cl_uint num_sync_points_in_wait_list, const cl_sync_point_khr *sync_point_wait_list, cl_sync_point_khr *sync_point, cl_mutable_command_khr *mutable_handle)
     * }
     */
    public static FunctionDescriptor clCommandCopyImageKHR$descriptor() {
        return clCommandCopyImageKHR.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern cl_int clCommandCopyImageKHR(cl_command_buffer_khr command_buffer, cl_command_queue command_queue, cl_mem src_image, cl_mem dst_image, const size_t *src_origin, const size_t *dst_origin, const size_t *region, cl_uint num_sync_points_in_wait_list, const cl_sync_point_khr *sync_point_wait_list, cl_sync_point_khr *sync_point, cl_mutable_command_khr *mutable_handle)
     * }
     */
    public static MethodHandle clCommandCopyImageKHR$handle() {
        return clCommandCopyImageKHR.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern cl_int clCommandCopyImageKHR(cl_command_buffer_khr command_buffer, cl_command_queue command_queue, cl_mem src_image, cl_mem dst_image, const size_t *src_origin, const size_t *dst_origin, const size_t *region, cl_uint num_sync_points_in_wait_list, const cl_sync_point_khr *sync_point_wait_list, cl_sync_point_khr *sync_point, cl_mutable_command_khr *mutable_handle)
     * }
     */
    public static int clCommandCopyImageKHR(MemorySegment command_buffer, MemorySegment command_queue, MemorySegment src_image, MemorySegment dst_image, MemorySegment src_origin, MemorySegment dst_origin, MemorySegment region, int num_sync_points_in_wait_list, MemorySegment sync_point_wait_list, MemorySegment sync_point, MemorySegment mutable_handle) {
        var mh$ = clCommandCopyImageKHR.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clCommandCopyImageKHR", command_buffer, command_queue, src_image, dst_image, src_origin, dst_origin, region, num_sync_points_in_wait_list, sync_point_wait_list, sync_point, mutable_handle);
            }
            return (int)mh$.invokeExact(command_buffer, command_queue, src_image, dst_image, src_origin, dst_origin, region, num_sync_points_in_wait_list, sync_point_wait_list, sync_point, mutable_handle);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clCommandCopyImageToBufferKHR {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_LONG_LONG,
            C_INT,
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("clCommandCopyImageToBufferKHR"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern cl_int clCommandCopyImageToBufferKHR(cl_command_buffer_khr command_buffer, cl_command_queue command_queue, cl_mem src_image, cl_mem dst_buffer, const size_t *src_origin, const size_t *region, size_t dst_offset, cl_uint num_sync_points_in_wait_list, const cl_sync_point_khr *sync_point_wait_list, cl_sync_point_khr *sync_point, cl_mutable_command_khr *mutable_handle)
     * }
     */
    public static FunctionDescriptor clCommandCopyImageToBufferKHR$descriptor() {
        return clCommandCopyImageToBufferKHR.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern cl_int clCommandCopyImageToBufferKHR(cl_command_buffer_khr command_buffer, cl_command_queue command_queue, cl_mem src_image, cl_mem dst_buffer, const size_t *src_origin, const size_t *region, size_t dst_offset, cl_uint num_sync_points_in_wait_list, const cl_sync_point_khr *sync_point_wait_list, cl_sync_point_khr *sync_point, cl_mutable_command_khr *mutable_handle)
     * }
     */
    public static MethodHandle clCommandCopyImageToBufferKHR$handle() {
        return clCommandCopyImageToBufferKHR.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern cl_int clCommandCopyImageToBufferKHR(cl_command_buffer_khr command_buffer, cl_command_queue command_queue, cl_mem src_image, cl_mem dst_buffer, const size_t *src_origin, const size_t *region, size_t dst_offset, cl_uint num_sync_points_in_wait_list, const cl_sync_point_khr *sync_point_wait_list, cl_sync_point_khr *sync_point, cl_mutable_command_khr *mutable_handle)
     * }
     */
    public static int clCommandCopyImageToBufferKHR(MemorySegment command_buffer, MemorySegment command_queue, MemorySegment src_image, MemorySegment dst_buffer, MemorySegment src_origin, MemorySegment region, long dst_offset, int num_sync_points_in_wait_list, MemorySegment sync_point_wait_list, MemorySegment sync_point, MemorySegment mutable_handle) {
        var mh$ = clCommandCopyImageToBufferKHR.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clCommandCopyImageToBufferKHR", command_buffer, command_queue, src_image, dst_buffer, src_origin, region, dst_offset, num_sync_points_in_wait_list, sync_point_wait_list, sync_point, mutable_handle);
            }
            return (int)mh$.invokeExact(command_buffer, command_queue, src_image, dst_buffer, src_origin, region, dst_offset, num_sync_points_in_wait_list, sync_point_wait_list, sync_point, mutable_handle);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clCommandFillBufferKHR {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_LONG_LONG,
            C_LONG_LONG,
            C_LONG_LONG,
            C_INT,
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("clCommandFillBufferKHR"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern cl_int clCommandFillBufferKHR(cl_command_buffer_khr command_buffer, cl_command_queue command_queue, cl_mem buffer, const void *pattern, size_t pattern_size, size_t offset, size_t size, cl_uint num_sync_points_in_wait_list, const cl_sync_point_khr *sync_point_wait_list, cl_sync_point_khr *sync_point, cl_mutable_command_khr *mutable_handle)
     * }
     */
    public static FunctionDescriptor clCommandFillBufferKHR$descriptor() {
        return clCommandFillBufferKHR.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern cl_int clCommandFillBufferKHR(cl_command_buffer_khr command_buffer, cl_command_queue command_queue, cl_mem buffer, const void *pattern, size_t pattern_size, size_t offset, size_t size, cl_uint num_sync_points_in_wait_list, const cl_sync_point_khr *sync_point_wait_list, cl_sync_point_khr *sync_point, cl_mutable_command_khr *mutable_handle)
     * }
     */
    public static MethodHandle clCommandFillBufferKHR$handle() {
        return clCommandFillBufferKHR.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern cl_int clCommandFillBufferKHR(cl_command_buffer_khr command_buffer, cl_command_queue command_queue, cl_mem buffer, const void *pattern, size_t pattern_size, size_t offset, size_t size, cl_uint num_sync_points_in_wait_list, const cl_sync_point_khr *sync_point_wait_list, cl_sync_point_khr *sync_point, cl_mutable_command_khr *mutable_handle)
     * }
     */
    public static int clCommandFillBufferKHR(MemorySegment command_buffer, MemorySegment command_queue, MemorySegment buffer, MemorySegment pattern, long pattern_size, long offset, long size, int num_sync_points_in_wait_list, MemorySegment sync_point_wait_list, MemorySegment sync_point, MemorySegment mutable_handle) {
        var mh$ = clCommandFillBufferKHR.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clCommandFillBufferKHR", command_buffer, command_queue, buffer, pattern, pattern_size, offset, size, num_sync_points_in_wait_list, sync_point_wait_list, sync_point, mutable_handle);
            }
            return (int)mh$.invokeExact(command_buffer, command_queue, buffer, pattern, pattern_size, offset, size, num_sync_points_in_wait_list, sync_point_wait_list, sync_point, mutable_handle);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clCommandFillImageKHR {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_INT,
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("clCommandFillImageKHR"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern cl_int clCommandFillImageKHR(cl_command_buffer_khr command_buffer, cl_command_queue command_queue, cl_mem image, const void *fill_color, const size_t *origin, const size_t *region, cl_uint num_sync_points_in_wait_list, const cl_sync_point_khr *sync_point_wait_list, cl_sync_point_khr *sync_point, cl_mutable_command_khr *mutable_handle)
     * }
     */
    public static FunctionDescriptor clCommandFillImageKHR$descriptor() {
        return clCommandFillImageKHR.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern cl_int clCommandFillImageKHR(cl_command_buffer_khr command_buffer, cl_command_queue command_queue, cl_mem image, const void *fill_color, const size_t *origin, const size_t *region, cl_uint num_sync_points_in_wait_list, const cl_sync_point_khr *sync_point_wait_list, cl_sync_point_khr *sync_point, cl_mutable_command_khr *mutable_handle)
     * }
     */
    public static MethodHandle clCommandFillImageKHR$handle() {
        return clCommandFillImageKHR.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern cl_int clCommandFillImageKHR(cl_command_buffer_khr command_buffer, cl_command_queue command_queue, cl_mem image, const void *fill_color, const size_t *origin, const size_t *region, cl_uint num_sync_points_in_wait_list, const cl_sync_point_khr *sync_point_wait_list, cl_sync_point_khr *sync_point, cl_mutable_command_khr *mutable_handle)
     * }
     */
    public static int clCommandFillImageKHR(MemorySegment command_buffer, MemorySegment command_queue, MemorySegment image, MemorySegment fill_color, MemorySegment origin, MemorySegment region, int num_sync_points_in_wait_list, MemorySegment sync_point_wait_list, MemorySegment sync_point, MemorySegment mutable_handle) {
        var mh$ = clCommandFillImageKHR.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clCommandFillImageKHR", command_buffer, command_queue, image, fill_color, origin, region, num_sync_points_in_wait_list, sync_point_wait_list, sync_point, mutable_handle);
            }
            return (int)mh$.invokeExact(command_buffer, command_queue, image, fill_color, origin, region, num_sync_points_in_wait_list, sync_point_wait_list, sync_point, mutable_handle);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clCommandNDRangeKernelKHR {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_INT,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_INT,
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("clCommandNDRangeKernelKHR"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern cl_int clCommandNDRangeKernelKHR(cl_command_buffer_khr command_buffer, cl_command_queue command_queue, const cl_ndrange_kernel_command_properties_khr *properties, cl_kernel kernel, cl_uint work_dim, const size_t *global_work_offset, const size_t *global_work_size, const size_t *local_work_size, cl_uint num_sync_points_in_wait_list, const cl_sync_point_khr *sync_point_wait_list, cl_sync_point_khr *sync_point, cl_mutable_command_khr *mutable_handle)
     * }
     */
    public static FunctionDescriptor clCommandNDRangeKernelKHR$descriptor() {
        return clCommandNDRangeKernelKHR.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern cl_int clCommandNDRangeKernelKHR(cl_command_buffer_khr command_buffer, cl_command_queue command_queue, const cl_ndrange_kernel_command_properties_khr *properties, cl_kernel kernel, cl_uint work_dim, const size_t *global_work_offset, const size_t *global_work_size, const size_t *local_work_size, cl_uint num_sync_points_in_wait_list, const cl_sync_point_khr *sync_point_wait_list, cl_sync_point_khr *sync_point, cl_mutable_command_khr *mutable_handle)
     * }
     */
    public static MethodHandle clCommandNDRangeKernelKHR$handle() {
        return clCommandNDRangeKernelKHR.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern cl_int clCommandNDRangeKernelKHR(cl_command_buffer_khr command_buffer, cl_command_queue command_queue, const cl_ndrange_kernel_command_properties_khr *properties, cl_kernel kernel, cl_uint work_dim, const size_t *global_work_offset, const size_t *global_work_size, const size_t *local_work_size, cl_uint num_sync_points_in_wait_list, const cl_sync_point_khr *sync_point_wait_list, cl_sync_point_khr *sync_point, cl_mutable_command_khr *mutable_handle)
     * }
     */
    public static int clCommandNDRangeKernelKHR(MemorySegment command_buffer, MemorySegment command_queue, MemorySegment properties, MemorySegment kernel, int work_dim, MemorySegment global_work_offset, MemorySegment global_work_size, MemorySegment local_work_size, int num_sync_points_in_wait_list, MemorySegment sync_point_wait_list, MemorySegment sync_point, MemorySegment mutable_handle) {
        var mh$ = clCommandNDRangeKernelKHR.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clCommandNDRangeKernelKHR", command_buffer, command_queue, properties, kernel, work_dim, global_work_offset, global_work_size, local_work_size, num_sync_points_in_wait_list, sync_point_wait_list, sync_point, mutable_handle);
            }
            return (int)mh$.invokeExact(command_buffer, command_queue, properties, kernel, work_dim, global_work_offset, global_work_size, local_work_size, num_sync_points_in_wait_list, sync_point_wait_list, sync_point, mutable_handle);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clGetCommandBufferInfoKHR {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_INT,
            C_LONG_LONG,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("clGetCommandBufferInfoKHR"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern cl_int clGetCommandBufferInfoKHR(cl_command_buffer_khr command_buffer, cl_command_buffer_info_khr param_name, size_t param_value_size, void *param_value, size_t *param_value_size_ret)
     * }
     */
    public static FunctionDescriptor clGetCommandBufferInfoKHR$descriptor() {
        return clGetCommandBufferInfoKHR.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern cl_int clGetCommandBufferInfoKHR(cl_command_buffer_khr command_buffer, cl_command_buffer_info_khr param_name, size_t param_value_size, void *param_value, size_t *param_value_size_ret)
     * }
     */
    public static MethodHandle clGetCommandBufferInfoKHR$handle() {
        return clGetCommandBufferInfoKHR.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern cl_int clGetCommandBufferInfoKHR(cl_command_buffer_khr command_buffer, cl_command_buffer_info_khr param_name, size_t param_value_size, void *param_value, size_t *param_value_size_ret)
     * }
     */
    public static int clGetCommandBufferInfoKHR(MemorySegment command_buffer, int param_name, long param_value_size, MemorySegment param_value, MemorySegment param_value_size_ret) {
        var mh$ = clGetCommandBufferInfoKHR.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clGetCommandBufferInfoKHR", command_buffer, param_name, param_value_size, param_value, param_value_size_ret);
            }
            return (int)mh$.invokeExact(command_buffer, param_name, param_value_size, param_value, param_value_size_ret);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef cl_bitfield cl_platform_command_buffer_capabilities_khr
     * }
     */
    public static final OfLong cl_platform_command_buffer_capabilities_khr = C_LONG_LONG;

    private static class clRemapCommandBufferKHR {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER,
            C_INT,
            C_INT,
            C_POINTER,
            C_INT,
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("clRemapCommandBufferKHR"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern cl_command_buffer_khr clRemapCommandBufferKHR(cl_command_buffer_khr command_buffer, cl_bool automatic, cl_uint num_queues, const cl_command_queue *queues, cl_uint num_handles, const cl_mutable_command_khr *handles, cl_mutable_command_khr *handles_ret, cl_int *errcode_ret)
     * }
     */
    public static FunctionDescriptor clRemapCommandBufferKHR$descriptor() {
        return clRemapCommandBufferKHR.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern cl_command_buffer_khr clRemapCommandBufferKHR(cl_command_buffer_khr command_buffer, cl_bool automatic, cl_uint num_queues, const cl_command_queue *queues, cl_uint num_handles, const cl_mutable_command_khr *handles, cl_mutable_command_khr *handles_ret, cl_int *errcode_ret)
     * }
     */
    public static MethodHandle clRemapCommandBufferKHR$handle() {
        return clRemapCommandBufferKHR.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern cl_command_buffer_khr clRemapCommandBufferKHR(cl_command_buffer_khr command_buffer, cl_bool automatic, cl_uint num_queues, const cl_command_queue *queues, cl_uint num_handles, const cl_mutable_command_khr *handles, cl_mutable_command_khr *handles_ret, cl_int *errcode_ret)
     * }
     */
    public static MemorySegment clRemapCommandBufferKHR(MemorySegment command_buffer, int automatic, int num_queues, MemorySegment queues, int num_handles, MemorySegment handles, MemorySegment handles_ret, MemorySegment errcode_ret) {
        var mh$ = clRemapCommandBufferKHR.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clRemapCommandBufferKHR", command_buffer, automatic, num_queues, queues, num_handles, handles, handles_ret, errcode_ret);
            }
            return (MemorySegment)mh$.invokeExact(command_buffer, automatic, num_queues, queues, num_handles, handles, handles_ret, errcode_ret);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef cl_uint cl_command_buffer_structure_type_khr
     * }
     */
    public static final OfInt cl_command_buffer_structure_type_khr = C_INT;
    /**
     * {@snippet lang=c :
     * typedef cl_bitfield cl_mutable_dispatch_fields_khr
     * }
     */
    public static final OfLong cl_mutable_dispatch_fields_khr = C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef cl_uint cl_mutable_command_info_khr
     * }
     */
    public static final OfInt cl_mutable_command_info_khr = C_INT;

    private static class clUpdateMutableCommandsKHR {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("clUpdateMutableCommandsKHR"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern cl_int clUpdateMutableCommandsKHR(cl_command_buffer_khr command_buffer, const cl_mutable_base_config_khr *mutable_config)
     * }
     */
    public static FunctionDescriptor clUpdateMutableCommandsKHR$descriptor() {
        return clUpdateMutableCommandsKHR.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern cl_int clUpdateMutableCommandsKHR(cl_command_buffer_khr command_buffer, const cl_mutable_base_config_khr *mutable_config)
     * }
     */
    public static MethodHandle clUpdateMutableCommandsKHR$handle() {
        return clUpdateMutableCommandsKHR.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern cl_int clUpdateMutableCommandsKHR(cl_command_buffer_khr command_buffer, const cl_mutable_base_config_khr *mutable_config)
     * }
     */
    public static int clUpdateMutableCommandsKHR(MemorySegment command_buffer, MemorySegment mutable_config) {
        var mh$ = clUpdateMutableCommandsKHR.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clUpdateMutableCommandsKHR", command_buffer, mutable_config);
            }
            return (int)mh$.invokeExact(command_buffer, mutable_config);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clGetMutableCommandInfoKHR {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_INT,
            C_LONG_LONG,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("clGetMutableCommandInfoKHR"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern cl_int clGetMutableCommandInfoKHR(cl_mutable_command_khr command, cl_mutable_command_info_khr param_name, size_t param_value_size, void *param_value, size_t *param_value_size_ret)
     * }
     */
    public static FunctionDescriptor clGetMutableCommandInfoKHR$descriptor() {
        return clGetMutableCommandInfoKHR.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern cl_int clGetMutableCommandInfoKHR(cl_mutable_command_khr command, cl_mutable_command_info_khr param_name, size_t param_value_size, void *param_value, size_t *param_value_size_ret)
     * }
     */
    public static MethodHandle clGetMutableCommandInfoKHR$handle() {
        return clGetMutableCommandInfoKHR.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern cl_int clGetMutableCommandInfoKHR(cl_mutable_command_khr command, cl_mutable_command_info_khr param_name, size_t param_value_size, void *param_value, size_t *param_value_size_ret)
     * }
     */
    public static int clGetMutableCommandInfoKHR(MemorySegment command, int param_name, long param_value_size, MemorySegment param_value, MemorySegment param_value_size_ret) {
        var mh$ = clGetMutableCommandInfoKHR.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clGetMutableCommandInfoKHR", command, param_name, param_value_size, param_value, param_value_size_ret);
            }
            return (int)mh$.invokeExact(command, param_name, param_value_size, param_value, param_value_size_ret);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clSetMemObjectDestructorAPPLE {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("clSetMemObjectDestructorAPPLE"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern cl_int clSetMemObjectDestructorAPPLE(cl_mem memobj, void (*pfn_notify)(cl_mem, void *) __attribute__((stdcall)), void *user_data)
     * }
     */
    public static FunctionDescriptor clSetMemObjectDestructorAPPLE$descriptor() {
        return clSetMemObjectDestructorAPPLE.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern cl_int clSetMemObjectDestructorAPPLE(cl_mem memobj, void (*pfn_notify)(cl_mem, void *) __attribute__((stdcall)), void *user_data)
     * }
     */
    public static MethodHandle clSetMemObjectDestructorAPPLE$handle() {
        return clSetMemObjectDestructorAPPLE.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern cl_int clSetMemObjectDestructorAPPLE(cl_mem memobj, void (*pfn_notify)(cl_mem, void *) __attribute__((stdcall)), void *user_data)
     * }
     */
    public static int clSetMemObjectDestructorAPPLE(MemorySegment memobj, MemorySegment pfn_notify, MemorySegment user_data) {
        var mh$ = clSetMemObjectDestructorAPPLE.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clSetMemObjectDestructorAPPLE", memobj, pfn_notify, user_data);
            }
            return (int)mh$.invokeExact(memobj, pfn_notify, user_data);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clLogMessagesToSystemLogAPPLE {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C_POINTER,
            C_POINTER,
            C_LONG_LONG,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("clLogMessagesToSystemLogAPPLE"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void clLogMessagesToSystemLogAPPLE(const char *errstr, const void *private_info, size_t cb, void *user_data)
     * }
     */
    public static FunctionDescriptor clLogMessagesToSystemLogAPPLE$descriptor() {
        return clLogMessagesToSystemLogAPPLE.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void clLogMessagesToSystemLogAPPLE(const char *errstr, const void *private_info, size_t cb, void *user_data)
     * }
     */
    public static MethodHandle clLogMessagesToSystemLogAPPLE$handle() {
        return clLogMessagesToSystemLogAPPLE.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern void clLogMessagesToSystemLogAPPLE(const char *errstr, const void *private_info, size_t cb, void *user_data)
     * }
     */
    public static void clLogMessagesToSystemLogAPPLE(MemorySegment errstr, MemorySegment private_info, long cb, MemorySegment user_data) {
        var mh$ = clLogMessagesToSystemLogAPPLE.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clLogMessagesToSystemLogAPPLE", errstr, private_info, cb, user_data);
            }
            mh$.invokeExact(errstr, private_info, cb, user_data);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clLogMessagesToStdoutAPPLE {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C_POINTER,
            C_POINTER,
            C_LONG_LONG,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("clLogMessagesToStdoutAPPLE"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void clLogMessagesToStdoutAPPLE(const char *errstr, const void *private_info, size_t cb, void *user_data)
     * }
     */
    public static FunctionDescriptor clLogMessagesToStdoutAPPLE$descriptor() {
        return clLogMessagesToStdoutAPPLE.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void clLogMessagesToStdoutAPPLE(const char *errstr, const void *private_info, size_t cb, void *user_data)
     * }
     */
    public static MethodHandle clLogMessagesToStdoutAPPLE$handle() {
        return clLogMessagesToStdoutAPPLE.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern void clLogMessagesToStdoutAPPLE(const char *errstr, const void *private_info, size_t cb, void *user_data)
     * }
     */
    public static void clLogMessagesToStdoutAPPLE(MemorySegment errstr, MemorySegment private_info, long cb, MemorySegment user_data) {
        var mh$ = clLogMessagesToStdoutAPPLE.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clLogMessagesToStdoutAPPLE", errstr, private_info, cb, user_data);
            }
            mh$.invokeExact(errstr, private_info, cb, user_data);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clLogMessagesToStderrAPPLE {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C_POINTER,
            C_POINTER,
            C_LONG_LONG,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("clLogMessagesToStderrAPPLE"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void clLogMessagesToStderrAPPLE(const char *errstr, const void *private_info, size_t cb, void *user_data)
     * }
     */
    public static FunctionDescriptor clLogMessagesToStderrAPPLE$descriptor() {
        return clLogMessagesToStderrAPPLE.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void clLogMessagesToStderrAPPLE(const char *errstr, const void *private_info, size_t cb, void *user_data)
     * }
     */
    public static MethodHandle clLogMessagesToStderrAPPLE$handle() {
        return clLogMessagesToStderrAPPLE.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern void clLogMessagesToStderrAPPLE(const char *errstr, const void *private_info, size_t cb, void *user_data)
     * }
     */
    public static void clLogMessagesToStderrAPPLE(MemorySegment errstr, MemorySegment private_info, long cb, MemorySegment user_data) {
        var mh$ = clLogMessagesToStderrAPPLE.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clLogMessagesToStderrAPPLE", errstr, private_info, cb, user_data);
            }
            mh$.invokeExact(errstr, private_info, cb, user_data);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clIcdGetPlatformIDsKHR {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_INT,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("clIcdGetPlatformIDsKHR"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern cl_int clIcdGetPlatformIDsKHR(cl_uint num_entries, cl_platform_id *platforms, cl_uint *num_platforms)
     * }
     */
    public static FunctionDescriptor clIcdGetPlatformIDsKHR$descriptor() {
        return clIcdGetPlatformIDsKHR.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern cl_int clIcdGetPlatformIDsKHR(cl_uint num_entries, cl_platform_id *platforms, cl_uint *num_platforms)
     * }
     */
    public static MethodHandle clIcdGetPlatformIDsKHR$handle() {
        return clIcdGetPlatformIDsKHR.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern cl_int clIcdGetPlatformIDsKHR(cl_uint num_entries, cl_platform_id *platforms, cl_uint *num_platforms)
     * }
     */
    public static int clIcdGetPlatformIDsKHR(int num_entries, MemorySegment platforms, MemorySegment num_platforms) {
        var mh$ = clIcdGetPlatformIDsKHR.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clIcdGetPlatformIDsKHR", num_entries, platforms, num_platforms);
            }
            return (int)mh$.invokeExact(num_entries, platforms, num_platforms);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clCreateProgramWithILKHR {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_LONG_LONG,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("clCreateProgramWithILKHR"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern cl_program clCreateProgramWithILKHR(cl_context context, const void *il, size_t length, cl_int *errcode_ret)
     * }
     */
    public static FunctionDescriptor clCreateProgramWithILKHR$descriptor() {
        return clCreateProgramWithILKHR.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern cl_program clCreateProgramWithILKHR(cl_context context, const void *il, size_t length, cl_int *errcode_ret)
     * }
     */
    public static MethodHandle clCreateProgramWithILKHR$handle() {
        return clCreateProgramWithILKHR.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern cl_program clCreateProgramWithILKHR(cl_context context, const void *il, size_t length, cl_int *errcode_ret)
     * }
     */
    public static MemorySegment clCreateProgramWithILKHR(MemorySegment context, MemorySegment il, long length, MemorySegment errcode_ret) {
        var mh$ = clCreateProgramWithILKHR.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clCreateProgramWithILKHR", context, il, length, errcode_ret);
            }
            return (MemorySegment)mh$.invokeExact(context, il, length, errcode_ret);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef cl_bitfield cl_device_terminate_capability_khr
     * }
     */
    public static final OfLong cl_device_terminate_capability_khr = C_LONG_LONG;

    private static class clTerminateContextKHR {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("clTerminateContextKHR"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern cl_int clTerminateContextKHR(cl_context context)
     * }
     */
    public static FunctionDescriptor clTerminateContextKHR$descriptor() {
        return clTerminateContextKHR.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern cl_int clTerminateContextKHR(cl_context context)
     * }
     */
    public static MethodHandle clTerminateContextKHR$handle() {
        return clTerminateContextKHR.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern cl_int clTerminateContextKHR(cl_context context)
     * }
     */
    public static int clTerminateContextKHR(MemorySegment context) {
        var mh$ = clTerminateContextKHR.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clTerminateContextKHR", context);
            }
            return (int)mh$.invokeExact(context);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef cl_properties cl_queue_properties_khr
     * }
     */
    public static final OfLong cl_queue_properties_khr = C_LONG_LONG;

    private static class clCreateCommandQueueWithPropertiesKHR {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("clCreateCommandQueueWithPropertiesKHR"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern cl_command_queue clCreateCommandQueueWithPropertiesKHR(cl_context context, cl_device_id device, const cl_queue_properties_khr *properties, cl_int *errcode_ret)
     * }
     */
    public static FunctionDescriptor clCreateCommandQueueWithPropertiesKHR$descriptor() {
        return clCreateCommandQueueWithPropertiesKHR.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern cl_command_queue clCreateCommandQueueWithPropertiesKHR(cl_context context, cl_device_id device, const cl_queue_properties_khr *properties, cl_int *errcode_ret)
     * }
     */
    public static MethodHandle clCreateCommandQueueWithPropertiesKHR$handle() {
        return clCreateCommandQueueWithPropertiesKHR.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern cl_command_queue clCreateCommandQueueWithPropertiesKHR(cl_context context, cl_device_id device, const cl_queue_properties_khr *properties, cl_int *errcode_ret)
     * }
     */
    public static MemorySegment clCreateCommandQueueWithPropertiesKHR(MemorySegment context, MemorySegment device, MemorySegment properties, MemorySegment errcode_ret) {
        var mh$ = clCreateCommandQueueWithPropertiesKHR.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clCreateCommandQueueWithPropertiesKHR", context, device, properties, errcode_ret);
            }
            return (MemorySegment)mh$.invokeExact(context, device, properties, errcode_ret);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef cl_ulong cl_device_partition_property_ext
     * }
     */
    public static final OfLong cl_device_partition_property_ext = C_LONG_LONG;

    private static class clReleaseDeviceEXT {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("clReleaseDeviceEXT"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern cl_int clReleaseDeviceEXT(cl_device_id device)
     * }
     */
    public static FunctionDescriptor clReleaseDeviceEXT$descriptor() {
        return clReleaseDeviceEXT.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern cl_int clReleaseDeviceEXT(cl_device_id device)
     * }
     */
    public static MethodHandle clReleaseDeviceEXT$handle() {
        return clReleaseDeviceEXT.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern cl_int clReleaseDeviceEXT(cl_device_id device)
     * }
     */
    public static int clReleaseDeviceEXT(MemorySegment device) {
        var mh$ = clReleaseDeviceEXT.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clReleaseDeviceEXT", device);
            }
            return (int)mh$.invokeExact(device);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clRetainDeviceEXT {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("clRetainDeviceEXT"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern cl_int clRetainDeviceEXT(cl_device_id device)
     * }
     */
    public static FunctionDescriptor clRetainDeviceEXT$descriptor() {
        return clRetainDeviceEXT.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern cl_int clRetainDeviceEXT(cl_device_id device)
     * }
     */
    public static MethodHandle clRetainDeviceEXT$handle() {
        return clRetainDeviceEXT.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern cl_int clRetainDeviceEXT(cl_device_id device)
     * }
     */
    public static int clRetainDeviceEXT(MemorySegment device) {
        var mh$ = clRetainDeviceEXT.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clRetainDeviceEXT", device);
            }
            return (int)mh$.invokeExact(device);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clCreateSubDevicesEXT {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_INT,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("clCreateSubDevicesEXT"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern cl_int clCreateSubDevicesEXT(cl_device_id in_device, const cl_device_partition_property_ext *properties, cl_uint num_entries, cl_device_id *out_devices, cl_uint *num_devices)
     * }
     */
    public static FunctionDescriptor clCreateSubDevicesEXT$descriptor() {
        return clCreateSubDevicesEXT.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern cl_int clCreateSubDevicesEXT(cl_device_id in_device, const cl_device_partition_property_ext *properties, cl_uint num_entries, cl_device_id *out_devices, cl_uint *num_devices)
     * }
     */
    public static MethodHandle clCreateSubDevicesEXT$handle() {
        return clCreateSubDevicesEXT.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern cl_int clCreateSubDevicesEXT(cl_device_id in_device, const cl_device_partition_property_ext *properties, cl_uint num_entries, cl_device_id *out_devices, cl_uint *num_devices)
     * }
     */
    public static int clCreateSubDevicesEXT(MemorySegment in_device, MemorySegment properties, int num_entries, MemorySegment out_devices, MemorySegment num_devices) {
        var mh$ = clCreateSubDevicesEXT.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clCreateSubDevicesEXT", in_device, properties, num_entries, out_devices, num_devices);
            }
            return (int)mh$.invokeExact(in_device, properties, num_entries, out_devices, num_devices);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef cl_bitfield cl_mem_migration_flags_ext
     * }
     */
    public static final OfLong cl_mem_migration_flags_ext = C_LONG_LONG;

    private static class clEnqueueMigrateMemObjectEXT {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_INT,
            C_POINTER,
            C_LONG_LONG,
            C_INT,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("clEnqueueMigrateMemObjectEXT"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern cl_int clEnqueueMigrateMemObjectEXT(cl_command_queue command_queue, cl_uint num_mem_objects, const cl_mem *mem_objects, cl_mem_migration_flags_ext flags, cl_uint num_events_in_wait_list, const cl_event *event_wait_list, cl_event *event)
     * }
     */
    public static FunctionDescriptor clEnqueueMigrateMemObjectEXT$descriptor() {
        return clEnqueueMigrateMemObjectEXT.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern cl_int clEnqueueMigrateMemObjectEXT(cl_command_queue command_queue, cl_uint num_mem_objects, const cl_mem *mem_objects, cl_mem_migration_flags_ext flags, cl_uint num_events_in_wait_list, const cl_event *event_wait_list, cl_event *event)
     * }
     */
    public static MethodHandle clEnqueueMigrateMemObjectEXT$handle() {
        return clEnqueueMigrateMemObjectEXT.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern cl_int clEnqueueMigrateMemObjectEXT(cl_command_queue command_queue, cl_uint num_mem_objects, const cl_mem *mem_objects, cl_mem_migration_flags_ext flags, cl_uint num_events_in_wait_list, const cl_event *event_wait_list, cl_event *event)
     * }
     */
    public static int clEnqueueMigrateMemObjectEXT(MemorySegment command_queue, int num_mem_objects, MemorySegment mem_objects, long flags, int num_events_in_wait_list, MemorySegment event_wait_list, MemorySegment event) {
        var mh$ = clEnqueueMigrateMemObjectEXT.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clEnqueueMigrateMemObjectEXT", command_queue, num_mem_objects, mem_objects, flags, num_events_in_wait_list, event_wait_list, event);
            }
            return (int)mh$.invokeExact(command_queue, num_mem_objects, mem_objects, flags, num_events_in_wait_list, event_wait_list, event);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef cl_uint cl_image_pitch_info_qcom
     * }
     */
    public static final OfInt cl_image_pitch_info_qcom = C_INT;

    private static class clGetDeviceImageInfoQCOM {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_LONG_LONG,
            C_LONG_LONG,
            C_POINTER,
            C_INT,
            C_LONG_LONG,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("clGetDeviceImageInfoQCOM"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern cl_int clGetDeviceImageInfoQCOM(cl_device_id device, size_t image_width, size_t image_height, const cl_image_format *image_format, cl_image_pitch_info_qcom param_name, size_t param_value_size, void *param_value, size_t *param_value_size_ret)
     * }
     */
    public static FunctionDescriptor clGetDeviceImageInfoQCOM$descriptor() {
        return clGetDeviceImageInfoQCOM.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern cl_int clGetDeviceImageInfoQCOM(cl_device_id device, size_t image_width, size_t image_height, const cl_image_format *image_format, cl_image_pitch_info_qcom param_name, size_t param_value_size, void *param_value, size_t *param_value_size_ret)
     * }
     */
    public static MethodHandle clGetDeviceImageInfoQCOM$handle() {
        return clGetDeviceImageInfoQCOM.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern cl_int clGetDeviceImageInfoQCOM(cl_device_id device, size_t image_width, size_t image_height, const cl_image_format *image_format, cl_image_pitch_info_qcom param_name, size_t param_value_size, void *param_value, size_t *param_value_size_ret)
     * }
     */
    public static int clGetDeviceImageInfoQCOM(MemorySegment device, long image_width, long image_height, MemorySegment image_format, int param_name, long param_value_size, MemorySegment param_value, MemorySegment param_value_size_ret) {
        var mh$ = clGetDeviceImageInfoQCOM.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clGetDeviceImageInfoQCOM", device, image_width, image_height, image_format, param_name, param_value_size, param_value, param_value_size_ret);
            }
            return (int)mh$.invokeExact(device, image_width, image_height, image_format, param_name, param_value_size, param_value, param_value_size_ret);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clEnqueueAcquireGrallocObjectsIMG {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_INT,
            C_POINTER,
            C_INT,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("clEnqueueAcquireGrallocObjectsIMG"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern cl_int clEnqueueAcquireGrallocObjectsIMG(cl_command_queue command_queue, cl_uint num_objects, const cl_mem *mem_objects, cl_uint num_events_in_wait_list, const cl_event *event_wait_list, cl_event *event)
     * }
     */
    public static FunctionDescriptor clEnqueueAcquireGrallocObjectsIMG$descriptor() {
        return clEnqueueAcquireGrallocObjectsIMG.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern cl_int clEnqueueAcquireGrallocObjectsIMG(cl_command_queue command_queue, cl_uint num_objects, const cl_mem *mem_objects, cl_uint num_events_in_wait_list, const cl_event *event_wait_list, cl_event *event)
     * }
     */
    public static MethodHandle clEnqueueAcquireGrallocObjectsIMG$handle() {
        return clEnqueueAcquireGrallocObjectsIMG.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern cl_int clEnqueueAcquireGrallocObjectsIMG(cl_command_queue command_queue, cl_uint num_objects, const cl_mem *mem_objects, cl_uint num_events_in_wait_list, const cl_event *event_wait_list, cl_event *event)
     * }
     */
    public static int clEnqueueAcquireGrallocObjectsIMG(MemorySegment command_queue, int num_objects, MemorySegment mem_objects, int num_events_in_wait_list, MemorySegment event_wait_list, MemorySegment event) {
        var mh$ = clEnqueueAcquireGrallocObjectsIMG.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clEnqueueAcquireGrallocObjectsIMG", command_queue, num_objects, mem_objects, num_events_in_wait_list, event_wait_list, event);
            }
            return (int)mh$.invokeExact(command_queue, num_objects, mem_objects, num_events_in_wait_list, event_wait_list, event);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clEnqueueReleaseGrallocObjectsIMG {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_INT,
            C_POINTER,
            C_INT,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("clEnqueueReleaseGrallocObjectsIMG"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern cl_int clEnqueueReleaseGrallocObjectsIMG(cl_command_queue command_queue, cl_uint num_objects, const cl_mem *mem_objects, cl_uint num_events_in_wait_list, const cl_event *event_wait_list, cl_event *event)
     * }
     */
    public static FunctionDescriptor clEnqueueReleaseGrallocObjectsIMG$descriptor() {
        return clEnqueueReleaseGrallocObjectsIMG.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern cl_int clEnqueueReleaseGrallocObjectsIMG(cl_command_queue command_queue, cl_uint num_objects, const cl_mem *mem_objects, cl_uint num_events_in_wait_list, const cl_event *event_wait_list, cl_event *event)
     * }
     */
    public static MethodHandle clEnqueueReleaseGrallocObjectsIMG$handle() {
        return clEnqueueReleaseGrallocObjectsIMG.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern cl_int clEnqueueReleaseGrallocObjectsIMG(cl_command_queue command_queue, cl_uint num_objects, const cl_mem *mem_objects, cl_uint num_events_in_wait_list, const cl_event *event_wait_list, cl_event *event)
     * }
     */
    public static int clEnqueueReleaseGrallocObjectsIMG(MemorySegment command_queue, int num_objects, MemorySegment mem_objects, int num_events_in_wait_list, MemorySegment event_wait_list, MemorySegment event) {
        var mh$ = clEnqueueReleaseGrallocObjectsIMG.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clEnqueueReleaseGrallocObjectsIMG", command_queue, num_objects, mem_objects, num_events_in_wait_list, event_wait_list, event);
            }
            return (int)mh$.invokeExact(command_queue, num_objects, mem_objects, num_events_in_wait_list, event_wait_list, event);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef cl_uint cl_mipmap_filter_mode_img
     * }
     */
    public static final OfInt cl_mipmap_filter_mode_img = C_INT;

    private static class clEnqueueGenerateMipmapIMG {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_INT,
            C_POINTER,
            C_POINTER,
            C_INT,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("clEnqueueGenerateMipmapIMG"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern cl_int clEnqueueGenerateMipmapIMG(cl_command_queue command_queue, cl_mem src_image, cl_mem dst_image, cl_mipmap_filter_mode_img mipmap_filter_mode, const size_t *array_region, const size_t *mip_region, cl_uint num_events_in_wait_list, const cl_event *event_wait_list, cl_event *event)
     * }
     */
    public static FunctionDescriptor clEnqueueGenerateMipmapIMG$descriptor() {
        return clEnqueueGenerateMipmapIMG.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern cl_int clEnqueueGenerateMipmapIMG(cl_command_queue command_queue, cl_mem src_image, cl_mem dst_image, cl_mipmap_filter_mode_img mipmap_filter_mode, const size_t *array_region, const size_t *mip_region, cl_uint num_events_in_wait_list, const cl_event *event_wait_list, cl_event *event)
     * }
     */
    public static MethodHandle clEnqueueGenerateMipmapIMG$handle() {
        return clEnqueueGenerateMipmapIMG.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern cl_int clEnqueueGenerateMipmapIMG(cl_command_queue command_queue, cl_mem src_image, cl_mem dst_image, cl_mipmap_filter_mode_img mipmap_filter_mode, const size_t *array_region, const size_t *mip_region, cl_uint num_events_in_wait_list, const cl_event *event_wait_list, cl_event *event)
     * }
     */
    public static int clEnqueueGenerateMipmapIMG(MemorySegment command_queue, MemorySegment src_image, MemorySegment dst_image, int mipmap_filter_mode, MemorySegment array_region, MemorySegment mip_region, int num_events_in_wait_list, MemorySegment event_wait_list, MemorySegment event) {
        var mh$ = clEnqueueGenerateMipmapIMG.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clEnqueueGenerateMipmapIMG", command_queue, src_image, dst_image, mipmap_filter_mode, array_region, mip_region, num_events_in_wait_list, event_wait_list, event);
            }
            return (int)mh$.invokeExact(command_queue, src_image, dst_image, mipmap_filter_mode, array_region, mip_region, num_events_in_wait_list, event_wait_list, event);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clGetKernelSubGroupInfoKHR {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_INT,
            C_LONG_LONG,
            C_POINTER,
            C_LONG_LONG,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("clGetKernelSubGroupInfoKHR"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern cl_int clGetKernelSubGroupInfoKHR(cl_kernel in_kernel, cl_device_id in_device, cl_kernel_sub_group_info param_name, size_t input_value_size, const void *input_value, size_t param_value_size, void *param_value, size_t *param_value_size_ret)
     * }
     */
    public static FunctionDescriptor clGetKernelSubGroupInfoKHR$descriptor() {
        return clGetKernelSubGroupInfoKHR.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern cl_int clGetKernelSubGroupInfoKHR(cl_kernel in_kernel, cl_device_id in_device, cl_kernel_sub_group_info param_name, size_t input_value_size, const void *input_value, size_t param_value_size, void *param_value, size_t *param_value_size_ret)
     * }
     */
    public static MethodHandle clGetKernelSubGroupInfoKHR$handle() {
        return clGetKernelSubGroupInfoKHR.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern cl_int clGetKernelSubGroupInfoKHR(cl_kernel in_kernel, cl_device_id in_device, cl_kernel_sub_group_info param_name, size_t input_value_size, const void *input_value, size_t param_value_size, void *param_value, size_t *param_value_size_ret)
     * }
     */
    public static int clGetKernelSubGroupInfoKHR(MemorySegment in_kernel, MemorySegment in_device, int param_name, long input_value_size, MemorySegment input_value, long param_value_size, MemorySegment param_value, MemorySegment param_value_size_ret) {
        var mh$ = clGetKernelSubGroupInfoKHR.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clGetKernelSubGroupInfoKHR", in_kernel, in_device, param_name, input_value_size, input_value, param_value_size, param_value, param_value_size_ret);
            }
            return (int)mh$.invokeExact(in_kernel, in_device, param_name, input_value_size, input_value, param_value_size, param_value, param_value_size_ret);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef cl_uint cl_queue_priority_khr
     * }
     */
    public static final OfInt cl_queue_priority_khr = C_INT;
    /**
     * {@snippet lang=c :
     * typedef cl_uint cl_queue_throttle_khr
     * }
     */
    public static final OfInt cl_queue_throttle_khr = C_INT;
    /**
     * {@snippet lang=c :
     * typedef cl_uint cl_version_khr
     * }
     */
    public static final OfInt cl_version_khr = C_INT;

    private static class clGetKernelSuggestedLocalWorkSizeKHR {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_INT,
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("clGetKernelSuggestedLocalWorkSizeKHR"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern cl_int clGetKernelSuggestedLocalWorkSizeKHR(cl_command_queue command_queue, cl_kernel kernel, cl_uint work_dim, const size_t *global_work_offset, const size_t *global_work_size, size_t *suggested_local_work_size)
     * }
     */
    public static FunctionDescriptor clGetKernelSuggestedLocalWorkSizeKHR$descriptor() {
        return clGetKernelSuggestedLocalWorkSizeKHR.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern cl_int clGetKernelSuggestedLocalWorkSizeKHR(cl_command_queue command_queue, cl_kernel kernel, cl_uint work_dim, const size_t *global_work_offset, const size_t *global_work_size, size_t *suggested_local_work_size)
     * }
     */
    public static MethodHandle clGetKernelSuggestedLocalWorkSizeKHR$handle() {
        return clGetKernelSuggestedLocalWorkSizeKHR.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern cl_int clGetKernelSuggestedLocalWorkSizeKHR(cl_command_queue command_queue, cl_kernel kernel, cl_uint work_dim, const size_t *global_work_offset, const size_t *global_work_size, size_t *suggested_local_work_size)
     * }
     */
    public static int clGetKernelSuggestedLocalWorkSizeKHR(MemorySegment command_queue, MemorySegment kernel, int work_dim, MemorySegment global_work_offset, MemorySegment global_work_size, MemorySegment suggested_local_work_size) {
        var mh$ = clGetKernelSuggestedLocalWorkSizeKHR.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clGetKernelSuggestedLocalWorkSizeKHR", command_queue, kernel, work_dim, global_work_offset, global_work_size, suggested_local_work_size);
            }
            return (int)mh$.invokeExact(command_queue, kernel, work_dim, global_work_offset, global_work_size, suggested_local_work_size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef cl_bitfield cl_device_integer_dot_product_capabilities_khr
     * }
     */
    public static final OfLong cl_device_integer_dot_product_capabilities_khr = C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef cl_uint cl_external_memory_handle_type_khr
     * }
     */
    public static final OfInt cl_external_memory_handle_type_khr = C_INT;

    private static class clEnqueueAcquireExternalMemObjectsKHR {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_INT,
            C_POINTER,
            C_INT,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("clEnqueueAcquireExternalMemObjectsKHR"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern cl_int clEnqueueAcquireExternalMemObjectsKHR(cl_command_queue command_queue, cl_uint num_mem_objects, const cl_mem *mem_objects, cl_uint num_events_in_wait_list, const cl_event *event_wait_list, cl_event *event)
     * }
     */
    public static FunctionDescriptor clEnqueueAcquireExternalMemObjectsKHR$descriptor() {
        return clEnqueueAcquireExternalMemObjectsKHR.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern cl_int clEnqueueAcquireExternalMemObjectsKHR(cl_command_queue command_queue, cl_uint num_mem_objects, const cl_mem *mem_objects, cl_uint num_events_in_wait_list, const cl_event *event_wait_list, cl_event *event)
     * }
     */
    public static MethodHandle clEnqueueAcquireExternalMemObjectsKHR$handle() {
        return clEnqueueAcquireExternalMemObjectsKHR.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern cl_int clEnqueueAcquireExternalMemObjectsKHR(cl_command_queue command_queue, cl_uint num_mem_objects, const cl_mem *mem_objects, cl_uint num_events_in_wait_list, const cl_event *event_wait_list, cl_event *event)
     * }
     */
    public static int clEnqueueAcquireExternalMemObjectsKHR(MemorySegment command_queue, int num_mem_objects, MemorySegment mem_objects, int num_events_in_wait_list, MemorySegment event_wait_list, MemorySegment event) {
        var mh$ = clEnqueueAcquireExternalMemObjectsKHR.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clEnqueueAcquireExternalMemObjectsKHR", command_queue, num_mem_objects, mem_objects, num_events_in_wait_list, event_wait_list, event);
            }
            return (int)mh$.invokeExact(command_queue, num_mem_objects, mem_objects, num_events_in_wait_list, event_wait_list, event);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clEnqueueReleaseExternalMemObjectsKHR {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_INT,
            C_POINTER,
            C_INT,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("clEnqueueReleaseExternalMemObjectsKHR"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern cl_int clEnqueueReleaseExternalMemObjectsKHR(cl_command_queue command_queue, cl_uint num_mem_objects, const cl_mem *mem_objects, cl_uint num_events_in_wait_list, const cl_event *event_wait_list, cl_event *event)
     * }
     */
    public static FunctionDescriptor clEnqueueReleaseExternalMemObjectsKHR$descriptor() {
        return clEnqueueReleaseExternalMemObjectsKHR.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern cl_int clEnqueueReleaseExternalMemObjectsKHR(cl_command_queue command_queue, cl_uint num_mem_objects, const cl_mem *mem_objects, cl_uint num_events_in_wait_list, const cl_event *event_wait_list, cl_event *event)
     * }
     */
    public static MethodHandle clEnqueueReleaseExternalMemObjectsKHR$handle() {
        return clEnqueueReleaseExternalMemObjectsKHR.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern cl_int clEnqueueReleaseExternalMemObjectsKHR(cl_command_queue command_queue, cl_uint num_mem_objects, const cl_mem *mem_objects, cl_uint num_events_in_wait_list, const cl_event *event_wait_list, cl_event *event)
     * }
     */
    public static int clEnqueueReleaseExternalMemObjectsKHR(MemorySegment command_queue, int num_mem_objects, MemorySegment mem_objects, int num_events_in_wait_list, MemorySegment event_wait_list, MemorySegment event) {
        var mh$ = clEnqueueReleaseExternalMemObjectsKHR.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clEnqueueReleaseExternalMemObjectsKHR", command_queue, num_mem_objects, mem_objects, num_events_in_wait_list, event_wait_list, event);
            }
            return (int)mh$.invokeExact(command_queue, num_mem_objects, mem_objects, num_events_in_wait_list, event_wait_list, event);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct _cl_semaphore_khr *cl_semaphore_khr
     * }
     */
    public static final AddressLayout cl_semaphore_khr = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef cl_uint cl_external_semaphore_handle_type_khr
     * }
     */
    public static final OfInt cl_external_semaphore_handle_type_khr = C_INT;

    private static class clGetSemaphoreHandleForTypeKHR {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_INT,
            C_LONG_LONG,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("clGetSemaphoreHandleForTypeKHR"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern cl_int clGetSemaphoreHandleForTypeKHR(cl_semaphore_khr sema_object, cl_device_id device, cl_external_semaphore_handle_type_khr handle_type, size_t handle_size, void *handle_ptr, size_t *handle_size_ret)
     * }
     */
    public static FunctionDescriptor clGetSemaphoreHandleForTypeKHR$descriptor() {
        return clGetSemaphoreHandleForTypeKHR.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern cl_int clGetSemaphoreHandleForTypeKHR(cl_semaphore_khr sema_object, cl_device_id device, cl_external_semaphore_handle_type_khr handle_type, size_t handle_size, void *handle_ptr, size_t *handle_size_ret)
     * }
     */
    public static MethodHandle clGetSemaphoreHandleForTypeKHR$handle() {
        return clGetSemaphoreHandleForTypeKHR.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern cl_int clGetSemaphoreHandleForTypeKHR(cl_semaphore_khr sema_object, cl_device_id device, cl_external_semaphore_handle_type_khr handle_type, size_t handle_size, void *handle_ptr, size_t *handle_size_ret)
     * }
     */
    public static int clGetSemaphoreHandleForTypeKHR(MemorySegment sema_object, MemorySegment device, int handle_type, long handle_size, MemorySegment handle_ptr, MemorySegment handle_size_ret) {
        var mh$ = clGetSemaphoreHandleForTypeKHR.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clGetSemaphoreHandleForTypeKHR", sema_object, device, handle_type, handle_size, handle_ptr, handle_size_ret);
            }
            return (int)mh$.invokeExact(sema_object, device, handle_type, handle_size, handle_ptr, handle_size_ret);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef cl_properties cl_semaphore_properties_khr
     * }
     */
    public static final OfLong cl_semaphore_properties_khr = C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef cl_uint cl_semaphore_info_khr
     * }
     */
    public static final OfInt cl_semaphore_info_khr = C_INT;
    /**
     * {@snippet lang=c :
     * typedef cl_uint cl_semaphore_type_khr
     * }
     */
    public static final OfInt cl_semaphore_type_khr = C_INT;
    /**
     * {@snippet lang=c :
     * typedef cl_ulong cl_semaphore_payload_khr
     * }
     */
    public static final OfLong cl_semaphore_payload_khr = C_LONG_LONG;

    private static class clCreateSemaphoreWithPropertiesKHR {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("clCreateSemaphoreWithPropertiesKHR"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern cl_semaphore_khr clCreateSemaphoreWithPropertiesKHR(cl_context context, const cl_semaphore_properties_khr *sema_props, cl_int *errcode_ret)
     * }
     */
    public static FunctionDescriptor clCreateSemaphoreWithPropertiesKHR$descriptor() {
        return clCreateSemaphoreWithPropertiesKHR.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern cl_semaphore_khr clCreateSemaphoreWithPropertiesKHR(cl_context context, const cl_semaphore_properties_khr *sema_props, cl_int *errcode_ret)
     * }
     */
    public static MethodHandle clCreateSemaphoreWithPropertiesKHR$handle() {
        return clCreateSemaphoreWithPropertiesKHR.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern cl_semaphore_khr clCreateSemaphoreWithPropertiesKHR(cl_context context, const cl_semaphore_properties_khr *sema_props, cl_int *errcode_ret)
     * }
     */
    public static MemorySegment clCreateSemaphoreWithPropertiesKHR(MemorySegment context, MemorySegment sema_props, MemorySegment errcode_ret) {
        var mh$ = clCreateSemaphoreWithPropertiesKHR.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clCreateSemaphoreWithPropertiesKHR", context, sema_props, errcode_ret);
            }
            return (MemorySegment)mh$.invokeExact(context, sema_props, errcode_ret);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clEnqueueWaitSemaphoresKHR {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_INT,
            C_POINTER,
            C_POINTER,
            C_INT,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("clEnqueueWaitSemaphoresKHR"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern cl_int clEnqueueWaitSemaphoresKHR(cl_command_queue command_queue, cl_uint num_sema_objects, const cl_semaphore_khr *sema_objects, const cl_semaphore_payload_khr *sema_payload_list, cl_uint num_events_in_wait_list, const cl_event *event_wait_list, cl_event *event)
     * }
     */
    public static FunctionDescriptor clEnqueueWaitSemaphoresKHR$descriptor() {
        return clEnqueueWaitSemaphoresKHR.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern cl_int clEnqueueWaitSemaphoresKHR(cl_command_queue command_queue, cl_uint num_sema_objects, const cl_semaphore_khr *sema_objects, const cl_semaphore_payload_khr *sema_payload_list, cl_uint num_events_in_wait_list, const cl_event *event_wait_list, cl_event *event)
     * }
     */
    public static MethodHandle clEnqueueWaitSemaphoresKHR$handle() {
        return clEnqueueWaitSemaphoresKHR.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern cl_int clEnqueueWaitSemaphoresKHR(cl_command_queue command_queue, cl_uint num_sema_objects, const cl_semaphore_khr *sema_objects, const cl_semaphore_payload_khr *sema_payload_list, cl_uint num_events_in_wait_list, const cl_event *event_wait_list, cl_event *event)
     * }
     */
    public static int clEnqueueWaitSemaphoresKHR(MemorySegment command_queue, int num_sema_objects, MemorySegment sema_objects, MemorySegment sema_payload_list, int num_events_in_wait_list, MemorySegment event_wait_list, MemorySegment event) {
        var mh$ = clEnqueueWaitSemaphoresKHR.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clEnqueueWaitSemaphoresKHR", command_queue, num_sema_objects, sema_objects, sema_payload_list, num_events_in_wait_list, event_wait_list, event);
            }
            return (int)mh$.invokeExact(command_queue, num_sema_objects, sema_objects, sema_payload_list, num_events_in_wait_list, event_wait_list, event);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clEnqueueSignalSemaphoresKHR {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_INT,
            C_POINTER,
            C_POINTER,
            C_INT,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("clEnqueueSignalSemaphoresKHR"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern cl_int clEnqueueSignalSemaphoresKHR(cl_command_queue command_queue, cl_uint num_sema_objects, const cl_semaphore_khr *sema_objects, const cl_semaphore_payload_khr *sema_payload_list, cl_uint num_events_in_wait_list, const cl_event *event_wait_list, cl_event *event)
     * }
     */
    public static FunctionDescriptor clEnqueueSignalSemaphoresKHR$descriptor() {
        return clEnqueueSignalSemaphoresKHR.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern cl_int clEnqueueSignalSemaphoresKHR(cl_command_queue command_queue, cl_uint num_sema_objects, const cl_semaphore_khr *sema_objects, const cl_semaphore_payload_khr *sema_payload_list, cl_uint num_events_in_wait_list, const cl_event *event_wait_list, cl_event *event)
     * }
     */
    public static MethodHandle clEnqueueSignalSemaphoresKHR$handle() {
        return clEnqueueSignalSemaphoresKHR.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern cl_int clEnqueueSignalSemaphoresKHR(cl_command_queue command_queue, cl_uint num_sema_objects, const cl_semaphore_khr *sema_objects, const cl_semaphore_payload_khr *sema_payload_list, cl_uint num_events_in_wait_list, const cl_event *event_wait_list, cl_event *event)
     * }
     */
    public static int clEnqueueSignalSemaphoresKHR(MemorySegment command_queue, int num_sema_objects, MemorySegment sema_objects, MemorySegment sema_payload_list, int num_events_in_wait_list, MemorySegment event_wait_list, MemorySegment event) {
        var mh$ = clEnqueueSignalSemaphoresKHR.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clEnqueueSignalSemaphoresKHR", command_queue, num_sema_objects, sema_objects, sema_payload_list, num_events_in_wait_list, event_wait_list, event);
            }
            return (int)mh$.invokeExact(command_queue, num_sema_objects, sema_objects, sema_payload_list, num_events_in_wait_list, event_wait_list, event);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clGetSemaphoreInfoKHR {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_INT,
            C_LONG_LONG,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("clGetSemaphoreInfoKHR"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern cl_int clGetSemaphoreInfoKHR(cl_semaphore_khr sema_object, cl_semaphore_info_khr param_name, size_t param_value_size, void *param_value, size_t *param_value_size_ret)
     * }
     */
    public static FunctionDescriptor clGetSemaphoreInfoKHR$descriptor() {
        return clGetSemaphoreInfoKHR.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern cl_int clGetSemaphoreInfoKHR(cl_semaphore_khr sema_object, cl_semaphore_info_khr param_name, size_t param_value_size, void *param_value, size_t *param_value_size_ret)
     * }
     */
    public static MethodHandle clGetSemaphoreInfoKHR$handle() {
        return clGetSemaphoreInfoKHR.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern cl_int clGetSemaphoreInfoKHR(cl_semaphore_khr sema_object, cl_semaphore_info_khr param_name, size_t param_value_size, void *param_value, size_t *param_value_size_ret)
     * }
     */
    public static int clGetSemaphoreInfoKHR(MemorySegment sema_object, int param_name, long param_value_size, MemorySegment param_value, MemorySegment param_value_size_ret) {
        var mh$ = clGetSemaphoreInfoKHR.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clGetSemaphoreInfoKHR", sema_object, param_name, param_value_size, param_value, param_value_size_ret);
            }
            return (int)mh$.invokeExact(sema_object, param_name, param_value_size, param_value, param_value_size_ret);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clReleaseSemaphoreKHR {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("clReleaseSemaphoreKHR"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern cl_int clReleaseSemaphoreKHR(cl_semaphore_khr sema_object)
     * }
     */
    public static FunctionDescriptor clReleaseSemaphoreKHR$descriptor() {
        return clReleaseSemaphoreKHR.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern cl_int clReleaseSemaphoreKHR(cl_semaphore_khr sema_object)
     * }
     */
    public static MethodHandle clReleaseSemaphoreKHR$handle() {
        return clReleaseSemaphoreKHR.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern cl_int clReleaseSemaphoreKHR(cl_semaphore_khr sema_object)
     * }
     */
    public static int clReleaseSemaphoreKHR(MemorySegment sema_object) {
        var mh$ = clReleaseSemaphoreKHR.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clReleaseSemaphoreKHR", sema_object);
            }
            return (int)mh$.invokeExact(sema_object);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clRetainSemaphoreKHR {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("clRetainSemaphoreKHR"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern cl_int clRetainSemaphoreKHR(cl_semaphore_khr sema_object)
     * }
     */
    public static FunctionDescriptor clRetainSemaphoreKHR$descriptor() {
        return clRetainSemaphoreKHR.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern cl_int clRetainSemaphoreKHR(cl_semaphore_khr sema_object)
     * }
     */
    public static MethodHandle clRetainSemaphoreKHR$handle() {
        return clRetainSemaphoreKHR.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern cl_int clRetainSemaphoreKHR(cl_semaphore_khr sema_object)
     * }
     */
    public static int clRetainSemaphoreKHR(MemorySegment sema_object) {
        var mh$ = clRetainSemaphoreKHR.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clRetainSemaphoreKHR", sema_object);
            }
            return (int)mh$.invokeExact(sema_object);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef intptr_t cl_import_properties_arm
     * }
     */
    public static final OfLong cl_import_properties_arm = C_LONG_LONG;

    private static class clImportMemoryARM {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER,
            C_LONG_LONG,
            C_POINTER,
            C_POINTER,
            C_LONG_LONG,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("clImportMemoryARM"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern cl_mem clImportMemoryARM(cl_context context, cl_mem_flags flags, const cl_import_properties_arm *properties, void *memory, size_t size, cl_int *errcode_ret)
     * }
     */
    public static FunctionDescriptor clImportMemoryARM$descriptor() {
        return clImportMemoryARM.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern cl_mem clImportMemoryARM(cl_context context, cl_mem_flags flags, const cl_import_properties_arm *properties, void *memory, size_t size, cl_int *errcode_ret)
     * }
     */
    public static MethodHandle clImportMemoryARM$handle() {
        return clImportMemoryARM.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern cl_mem clImportMemoryARM(cl_context context, cl_mem_flags flags, const cl_import_properties_arm *properties, void *memory, size_t size, cl_int *errcode_ret)
     * }
     */
    public static MemorySegment clImportMemoryARM(MemorySegment context, long flags, MemorySegment properties, MemorySegment memory, long size, MemorySegment errcode_ret) {
        var mh$ = clImportMemoryARM.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clImportMemoryARM", context, flags, properties, memory, size, errcode_ret);
            }
            return (MemorySegment)mh$.invokeExact(context, flags, properties, memory, size, errcode_ret);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef cl_bitfield cl_svm_mem_flags_arm
     * }
     */
    public static final OfLong cl_svm_mem_flags_arm = C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef cl_uint cl_kernel_exec_info_arm
     * }
     */
    public static final OfInt cl_kernel_exec_info_arm = C_INT;
    /**
     * {@snippet lang=c :
     * typedef cl_bitfield cl_device_svm_capabilities_arm
     * }
     */
    public static final OfLong cl_device_svm_capabilities_arm = C_LONG_LONG;

    private static class clSVMAllocARM {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER,
            C_LONG_LONG,
            C_LONG_LONG,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("clSVMAllocARM"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void *clSVMAllocARM(cl_context context, cl_svm_mem_flags_arm flags, size_t size, cl_uint alignment)
     * }
     */
    public static FunctionDescriptor clSVMAllocARM$descriptor() {
        return clSVMAllocARM.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void *clSVMAllocARM(cl_context context, cl_svm_mem_flags_arm flags, size_t size, cl_uint alignment)
     * }
     */
    public static MethodHandle clSVMAllocARM$handle() {
        return clSVMAllocARM.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern void *clSVMAllocARM(cl_context context, cl_svm_mem_flags_arm flags, size_t size, cl_uint alignment)
     * }
     */
    public static MemorySegment clSVMAllocARM(MemorySegment context, long flags, long size, int alignment) {
        var mh$ = clSVMAllocARM.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clSVMAllocARM", context, flags, size, alignment);
            }
            return (MemorySegment)mh$.invokeExact(context, flags, size, alignment);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clSVMFreeARM {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("clSVMFreeARM"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void clSVMFreeARM(cl_context context, void *svm_pointer)
     * }
     */
    public static FunctionDescriptor clSVMFreeARM$descriptor() {
        return clSVMFreeARM.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void clSVMFreeARM(cl_context context, void *svm_pointer)
     * }
     */
    public static MethodHandle clSVMFreeARM$handle() {
        return clSVMFreeARM.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern void clSVMFreeARM(cl_context context, void *svm_pointer)
     * }
     */
    public static void clSVMFreeARM(MemorySegment context, MemorySegment svm_pointer) {
        var mh$ = clSVMFreeARM.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clSVMFreeARM", context, svm_pointer);
            }
            mh$.invokeExact(context, svm_pointer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clEnqueueSVMFreeARM {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_INT,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_INT,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("clEnqueueSVMFreeARM"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern cl_int clEnqueueSVMFreeARM(cl_command_queue command_queue, cl_uint num_svm_pointers, void *svm_pointers[], void (*pfn_free_func)(cl_command_queue, cl_uint, void **, void *) __attribute__((stdcall)), void *user_data, cl_uint num_events_in_wait_list, const cl_event *event_wait_list, cl_event *event)
     * }
     */
    public static FunctionDescriptor clEnqueueSVMFreeARM$descriptor() {
        return clEnqueueSVMFreeARM.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern cl_int clEnqueueSVMFreeARM(cl_command_queue command_queue, cl_uint num_svm_pointers, void *svm_pointers[], void (*pfn_free_func)(cl_command_queue, cl_uint, void **, void *) __attribute__((stdcall)), void *user_data, cl_uint num_events_in_wait_list, const cl_event *event_wait_list, cl_event *event)
     * }
     */
    public static MethodHandle clEnqueueSVMFreeARM$handle() {
        return clEnqueueSVMFreeARM.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern cl_int clEnqueueSVMFreeARM(cl_command_queue command_queue, cl_uint num_svm_pointers, void *svm_pointers[], void (*pfn_free_func)(cl_command_queue, cl_uint, void **, void *) __attribute__((stdcall)), void *user_data, cl_uint num_events_in_wait_list, const cl_event *event_wait_list, cl_event *event)
     * }
     */
    public static int clEnqueueSVMFreeARM(MemorySegment command_queue, int num_svm_pointers, MemorySegment svm_pointers, MemorySegment pfn_free_func, MemorySegment user_data, int num_events_in_wait_list, MemorySegment event_wait_list, MemorySegment event) {
        var mh$ = clEnqueueSVMFreeARM.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clEnqueueSVMFreeARM", command_queue, num_svm_pointers, svm_pointers, pfn_free_func, user_data, num_events_in_wait_list, event_wait_list, event);
            }
            return (int)mh$.invokeExact(command_queue, num_svm_pointers, svm_pointers, pfn_free_func, user_data, num_events_in_wait_list, event_wait_list, event);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clEnqueueSVMMemcpyARM {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_INT,
            C_POINTER,
            C_POINTER,
            C_LONG_LONG,
            C_INT,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("clEnqueueSVMMemcpyARM"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern cl_int clEnqueueSVMMemcpyARM(cl_command_queue command_queue, cl_bool blocking_copy, void *dst_ptr, const void *src_ptr, size_t size, cl_uint num_events_in_wait_list, const cl_event *event_wait_list, cl_event *event)
     * }
     */
    public static FunctionDescriptor clEnqueueSVMMemcpyARM$descriptor() {
        return clEnqueueSVMMemcpyARM.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern cl_int clEnqueueSVMMemcpyARM(cl_command_queue command_queue, cl_bool blocking_copy, void *dst_ptr, const void *src_ptr, size_t size, cl_uint num_events_in_wait_list, const cl_event *event_wait_list, cl_event *event)
     * }
     */
    public static MethodHandle clEnqueueSVMMemcpyARM$handle() {
        return clEnqueueSVMMemcpyARM.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern cl_int clEnqueueSVMMemcpyARM(cl_command_queue command_queue, cl_bool blocking_copy, void *dst_ptr, const void *src_ptr, size_t size, cl_uint num_events_in_wait_list, const cl_event *event_wait_list, cl_event *event)
     * }
     */
    public static int clEnqueueSVMMemcpyARM(MemorySegment command_queue, int blocking_copy, MemorySegment dst_ptr, MemorySegment src_ptr, long size, int num_events_in_wait_list, MemorySegment event_wait_list, MemorySegment event) {
        var mh$ = clEnqueueSVMMemcpyARM.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clEnqueueSVMMemcpyARM", command_queue, blocking_copy, dst_ptr, src_ptr, size, num_events_in_wait_list, event_wait_list, event);
            }
            return (int)mh$.invokeExact(command_queue, blocking_copy, dst_ptr, src_ptr, size, num_events_in_wait_list, event_wait_list, event);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clEnqueueSVMMemFillARM {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_LONG_LONG,
            C_LONG_LONG,
            C_INT,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("clEnqueueSVMMemFillARM"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern cl_int clEnqueueSVMMemFillARM(cl_command_queue command_queue, void *svm_ptr, const void *pattern, size_t pattern_size, size_t size, cl_uint num_events_in_wait_list, const cl_event *event_wait_list, cl_event *event)
     * }
     */
    public static FunctionDescriptor clEnqueueSVMMemFillARM$descriptor() {
        return clEnqueueSVMMemFillARM.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern cl_int clEnqueueSVMMemFillARM(cl_command_queue command_queue, void *svm_ptr, const void *pattern, size_t pattern_size, size_t size, cl_uint num_events_in_wait_list, const cl_event *event_wait_list, cl_event *event)
     * }
     */
    public static MethodHandle clEnqueueSVMMemFillARM$handle() {
        return clEnqueueSVMMemFillARM.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern cl_int clEnqueueSVMMemFillARM(cl_command_queue command_queue, void *svm_ptr, const void *pattern, size_t pattern_size, size_t size, cl_uint num_events_in_wait_list, const cl_event *event_wait_list, cl_event *event)
     * }
     */
    public static int clEnqueueSVMMemFillARM(MemorySegment command_queue, MemorySegment svm_ptr, MemorySegment pattern, long pattern_size, long size, int num_events_in_wait_list, MemorySegment event_wait_list, MemorySegment event) {
        var mh$ = clEnqueueSVMMemFillARM.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clEnqueueSVMMemFillARM", command_queue, svm_ptr, pattern, pattern_size, size, num_events_in_wait_list, event_wait_list, event);
            }
            return (int)mh$.invokeExact(command_queue, svm_ptr, pattern, pattern_size, size, num_events_in_wait_list, event_wait_list, event);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clEnqueueSVMMapARM {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_INT,
            C_LONG_LONG,
            C_POINTER,
            C_LONG_LONG,
            C_INT,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("clEnqueueSVMMapARM"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern cl_int clEnqueueSVMMapARM(cl_command_queue command_queue, cl_bool blocking_map, cl_map_flags flags, void *svm_ptr, size_t size, cl_uint num_events_in_wait_list, const cl_event *event_wait_list, cl_event *event)
     * }
     */
    public static FunctionDescriptor clEnqueueSVMMapARM$descriptor() {
        return clEnqueueSVMMapARM.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern cl_int clEnqueueSVMMapARM(cl_command_queue command_queue, cl_bool blocking_map, cl_map_flags flags, void *svm_ptr, size_t size, cl_uint num_events_in_wait_list, const cl_event *event_wait_list, cl_event *event)
     * }
     */
    public static MethodHandle clEnqueueSVMMapARM$handle() {
        return clEnqueueSVMMapARM.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern cl_int clEnqueueSVMMapARM(cl_command_queue command_queue, cl_bool blocking_map, cl_map_flags flags, void *svm_ptr, size_t size, cl_uint num_events_in_wait_list, const cl_event *event_wait_list, cl_event *event)
     * }
     */
    public static int clEnqueueSVMMapARM(MemorySegment command_queue, int blocking_map, long flags, MemorySegment svm_ptr, long size, int num_events_in_wait_list, MemorySegment event_wait_list, MemorySegment event) {
        var mh$ = clEnqueueSVMMapARM.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clEnqueueSVMMapARM", command_queue, blocking_map, flags, svm_ptr, size, num_events_in_wait_list, event_wait_list, event);
            }
            return (int)mh$.invokeExact(command_queue, blocking_map, flags, svm_ptr, size, num_events_in_wait_list, event_wait_list, event);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clEnqueueSVMUnmapARM {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_INT,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("clEnqueueSVMUnmapARM"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern cl_int clEnqueueSVMUnmapARM(cl_command_queue command_queue, void *svm_ptr, cl_uint num_events_in_wait_list, const cl_event *event_wait_list, cl_event *event)
     * }
     */
    public static FunctionDescriptor clEnqueueSVMUnmapARM$descriptor() {
        return clEnqueueSVMUnmapARM.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern cl_int clEnqueueSVMUnmapARM(cl_command_queue command_queue, void *svm_ptr, cl_uint num_events_in_wait_list, const cl_event *event_wait_list, cl_event *event)
     * }
     */
    public static MethodHandle clEnqueueSVMUnmapARM$handle() {
        return clEnqueueSVMUnmapARM.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern cl_int clEnqueueSVMUnmapARM(cl_command_queue command_queue, void *svm_ptr, cl_uint num_events_in_wait_list, const cl_event *event_wait_list, cl_event *event)
     * }
     */
    public static int clEnqueueSVMUnmapARM(MemorySegment command_queue, MemorySegment svm_ptr, int num_events_in_wait_list, MemorySegment event_wait_list, MemorySegment event) {
        var mh$ = clEnqueueSVMUnmapARM.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clEnqueueSVMUnmapARM", command_queue, svm_ptr, num_events_in_wait_list, event_wait_list, event);
            }
            return (int)mh$.invokeExact(command_queue, svm_ptr, num_events_in_wait_list, event_wait_list, event);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clSetKernelArgSVMPointerARM {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("clSetKernelArgSVMPointerARM"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern cl_int clSetKernelArgSVMPointerARM(cl_kernel kernel, cl_uint arg_index, const void *arg_value)
     * }
     */
    public static FunctionDescriptor clSetKernelArgSVMPointerARM$descriptor() {
        return clSetKernelArgSVMPointerARM.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern cl_int clSetKernelArgSVMPointerARM(cl_kernel kernel, cl_uint arg_index, const void *arg_value)
     * }
     */
    public static MethodHandle clSetKernelArgSVMPointerARM$handle() {
        return clSetKernelArgSVMPointerARM.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern cl_int clSetKernelArgSVMPointerARM(cl_kernel kernel, cl_uint arg_index, const void *arg_value)
     * }
     */
    public static int clSetKernelArgSVMPointerARM(MemorySegment kernel, int arg_index, MemorySegment arg_value) {
        var mh$ = clSetKernelArgSVMPointerARM.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clSetKernelArgSVMPointerARM", kernel, arg_index, arg_value);
            }
            return (int)mh$.invokeExact(kernel, arg_index, arg_value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clSetKernelExecInfoARM {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_INT,
            C_LONG_LONG,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("clSetKernelExecInfoARM"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern cl_int clSetKernelExecInfoARM(cl_kernel kernel, cl_kernel_exec_info_arm param_name, size_t param_value_size, const void *param_value)
     * }
     */
    public static FunctionDescriptor clSetKernelExecInfoARM$descriptor() {
        return clSetKernelExecInfoARM.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern cl_int clSetKernelExecInfoARM(cl_kernel kernel, cl_kernel_exec_info_arm param_name, size_t param_value_size, const void *param_value)
     * }
     */
    public static MethodHandle clSetKernelExecInfoARM$handle() {
        return clSetKernelExecInfoARM.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern cl_int clSetKernelExecInfoARM(cl_kernel kernel, cl_kernel_exec_info_arm param_name, size_t param_value_size, const void *param_value)
     * }
     */
    public static int clSetKernelExecInfoARM(MemorySegment kernel, int param_name, long param_value_size, MemorySegment param_value) {
        var mh$ = clSetKernelExecInfoARM.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clSetKernelExecInfoARM", kernel, param_name, param_value_size, param_value);
            }
            return (int)mh$.invokeExact(kernel, param_name, param_value_size, param_value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef cl_bitfield cl_device_scheduling_controls_capabilities_arm
     * }
     */
    public static final OfLong cl_device_scheduling_controls_capabilities_arm = C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef cl_bitfield cl_device_controlled_termination_capabilities_arm
     * }
     */
    public static final OfLong cl_device_controlled_termination_capabilities_arm = C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef cl_bitfield cl_device_feature_capabilities_intel
     * }
     */
    public static final OfLong cl_device_feature_capabilities_intel = C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef struct _cl_accelerator_intel *cl_accelerator_intel
     * }
     */
    public static final AddressLayout cl_accelerator_intel = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef cl_uint cl_accelerator_type_intel
     * }
     */
    public static final OfInt cl_accelerator_type_intel = C_INT;
    /**
     * {@snippet lang=c :
     * typedef cl_uint cl_accelerator_info_intel
     * }
     */
    public static final OfInt cl_accelerator_info_intel = C_INT;

    private static class clCreateAcceleratorINTEL {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER,
            C_INT,
            C_LONG_LONG,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("clCreateAcceleratorINTEL"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern cl_accelerator_intel clCreateAcceleratorINTEL(cl_context context, cl_accelerator_type_intel accelerator_type, size_t descriptor_size, const void *descriptor, cl_int *errcode_ret)
     * }
     */
    public static FunctionDescriptor clCreateAcceleratorINTEL$descriptor() {
        return clCreateAcceleratorINTEL.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern cl_accelerator_intel clCreateAcceleratorINTEL(cl_context context, cl_accelerator_type_intel accelerator_type, size_t descriptor_size, const void *descriptor, cl_int *errcode_ret)
     * }
     */
    public static MethodHandle clCreateAcceleratorINTEL$handle() {
        return clCreateAcceleratorINTEL.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern cl_accelerator_intel clCreateAcceleratorINTEL(cl_context context, cl_accelerator_type_intel accelerator_type, size_t descriptor_size, const void *descriptor, cl_int *errcode_ret)
     * }
     */
    public static MemorySegment clCreateAcceleratorINTEL(MemorySegment context, int accelerator_type, long descriptor_size, MemorySegment descriptor, MemorySegment errcode_ret) {
        var mh$ = clCreateAcceleratorINTEL.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clCreateAcceleratorINTEL", context, accelerator_type, descriptor_size, descriptor, errcode_ret);
            }
            return (MemorySegment)mh$.invokeExact(context, accelerator_type, descriptor_size, descriptor, errcode_ret);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clGetAcceleratorInfoINTEL {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_INT,
            C_LONG_LONG,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("clGetAcceleratorInfoINTEL"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern cl_int clGetAcceleratorInfoINTEL(cl_accelerator_intel accelerator, cl_accelerator_info_intel param_name, size_t param_value_size, void *param_value, size_t *param_value_size_ret)
     * }
     */
    public static FunctionDescriptor clGetAcceleratorInfoINTEL$descriptor() {
        return clGetAcceleratorInfoINTEL.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern cl_int clGetAcceleratorInfoINTEL(cl_accelerator_intel accelerator, cl_accelerator_info_intel param_name, size_t param_value_size, void *param_value, size_t *param_value_size_ret)
     * }
     */
    public static MethodHandle clGetAcceleratorInfoINTEL$handle() {
        return clGetAcceleratorInfoINTEL.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern cl_int clGetAcceleratorInfoINTEL(cl_accelerator_intel accelerator, cl_accelerator_info_intel param_name, size_t param_value_size, void *param_value, size_t *param_value_size_ret)
     * }
     */
    public static int clGetAcceleratorInfoINTEL(MemorySegment accelerator, int param_name, long param_value_size, MemorySegment param_value, MemorySegment param_value_size_ret) {
        var mh$ = clGetAcceleratorInfoINTEL.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clGetAcceleratorInfoINTEL", accelerator, param_name, param_value_size, param_value, param_value_size_ret);
            }
            return (int)mh$.invokeExact(accelerator, param_name, param_value_size, param_value, param_value_size_ret);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clRetainAcceleratorINTEL {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("clRetainAcceleratorINTEL"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern cl_int clRetainAcceleratorINTEL(cl_accelerator_intel accelerator)
     * }
     */
    public static FunctionDescriptor clRetainAcceleratorINTEL$descriptor() {
        return clRetainAcceleratorINTEL.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern cl_int clRetainAcceleratorINTEL(cl_accelerator_intel accelerator)
     * }
     */
    public static MethodHandle clRetainAcceleratorINTEL$handle() {
        return clRetainAcceleratorINTEL.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern cl_int clRetainAcceleratorINTEL(cl_accelerator_intel accelerator)
     * }
     */
    public static int clRetainAcceleratorINTEL(MemorySegment accelerator) {
        var mh$ = clRetainAcceleratorINTEL.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clRetainAcceleratorINTEL", accelerator);
            }
            return (int)mh$.invokeExact(accelerator);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clReleaseAcceleratorINTEL {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("clReleaseAcceleratorINTEL"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern cl_int clReleaseAcceleratorINTEL(cl_accelerator_intel accelerator)
     * }
     */
    public static FunctionDescriptor clReleaseAcceleratorINTEL$descriptor() {
        return clReleaseAcceleratorINTEL.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern cl_int clReleaseAcceleratorINTEL(cl_accelerator_intel accelerator)
     * }
     */
    public static MethodHandle clReleaseAcceleratorINTEL$handle() {
        return clReleaseAcceleratorINTEL.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern cl_int clReleaseAcceleratorINTEL(cl_accelerator_intel accelerator)
     * }
     */
    public static int clReleaseAcceleratorINTEL(MemorySegment accelerator) {
        var mh$ = clReleaseAcceleratorINTEL.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clReleaseAcceleratorINTEL", accelerator);
            }
            return (int)mh$.invokeExact(accelerator);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef cl_uint cl_diagnostics_verbose_level
     * }
     */
    public static final OfInt cl_diagnostics_verbose_level = C_INT;
    /**
     * {@snippet lang=c :
     * typedef cl_bitfield cl_device_unified_shared_memory_capabilities_intel
     * }
     */
    public static final OfLong cl_device_unified_shared_memory_capabilities_intel = C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef cl_properties cl_mem_properties_intel
     * }
     */
    public static final OfLong cl_mem_properties_intel = C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef cl_bitfield cl_mem_alloc_flags_intel
     * }
     */
    public static final OfLong cl_mem_alloc_flags_intel = C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef cl_uint cl_mem_info_intel
     * }
     */
    public static final OfInt cl_mem_info_intel = C_INT;
    /**
     * {@snippet lang=c :
     * typedef cl_uint cl_unified_shared_memory_type_intel
     * }
     */
    public static final OfInt cl_unified_shared_memory_type_intel = C_INT;
    /**
     * {@snippet lang=c :
     * typedef cl_uint cl_mem_advice_intel
     * }
     */
    public static final OfInt cl_mem_advice_intel = C_INT;

    private static class clHostMemAllocINTEL {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_LONG_LONG,
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("clHostMemAllocINTEL"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void *clHostMemAllocINTEL(cl_context context, const cl_mem_properties_intel *properties, size_t size, cl_uint alignment, cl_int *errcode_ret)
     * }
     */
    public static FunctionDescriptor clHostMemAllocINTEL$descriptor() {
        return clHostMemAllocINTEL.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void *clHostMemAllocINTEL(cl_context context, const cl_mem_properties_intel *properties, size_t size, cl_uint alignment, cl_int *errcode_ret)
     * }
     */
    public static MethodHandle clHostMemAllocINTEL$handle() {
        return clHostMemAllocINTEL.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern void *clHostMemAllocINTEL(cl_context context, const cl_mem_properties_intel *properties, size_t size, cl_uint alignment, cl_int *errcode_ret)
     * }
     */
    public static MemorySegment clHostMemAllocINTEL(MemorySegment context, MemorySegment properties, long size, int alignment, MemorySegment errcode_ret) {
        var mh$ = clHostMemAllocINTEL.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clHostMemAllocINTEL", context, properties, size, alignment, errcode_ret);
            }
            return (MemorySegment)mh$.invokeExact(context, properties, size, alignment, errcode_ret);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clDeviceMemAllocINTEL {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_LONG_LONG,
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("clDeviceMemAllocINTEL"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void *clDeviceMemAllocINTEL(cl_context context, cl_device_id device, const cl_mem_properties_intel *properties, size_t size, cl_uint alignment, cl_int *errcode_ret)
     * }
     */
    public static FunctionDescriptor clDeviceMemAllocINTEL$descriptor() {
        return clDeviceMemAllocINTEL.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void *clDeviceMemAllocINTEL(cl_context context, cl_device_id device, const cl_mem_properties_intel *properties, size_t size, cl_uint alignment, cl_int *errcode_ret)
     * }
     */
    public static MethodHandle clDeviceMemAllocINTEL$handle() {
        return clDeviceMemAllocINTEL.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern void *clDeviceMemAllocINTEL(cl_context context, cl_device_id device, const cl_mem_properties_intel *properties, size_t size, cl_uint alignment, cl_int *errcode_ret)
     * }
     */
    public static MemorySegment clDeviceMemAllocINTEL(MemorySegment context, MemorySegment device, MemorySegment properties, long size, int alignment, MemorySegment errcode_ret) {
        var mh$ = clDeviceMemAllocINTEL.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clDeviceMemAllocINTEL", context, device, properties, size, alignment, errcode_ret);
            }
            return (MemorySegment)mh$.invokeExact(context, device, properties, size, alignment, errcode_ret);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clSharedMemAllocINTEL {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_LONG_LONG,
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("clSharedMemAllocINTEL"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void *clSharedMemAllocINTEL(cl_context context, cl_device_id device, const cl_mem_properties_intel *properties, size_t size, cl_uint alignment, cl_int *errcode_ret)
     * }
     */
    public static FunctionDescriptor clSharedMemAllocINTEL$descriptor() {
        return clSharedMemAllocINTEL.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void *clSharedMemAllocINTEL(cl_context context, cl_device_id device, const cl_mem_properties_intel *properties, size_t size, cl_uint alignment, cl_int *errcode_ret)
     * }
     */
    public static MethodHandle clSharedMemAllocINTEL$handle() {
        return clSharedMemAllocINTEL.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern void *clSharedMemAllocINTEL(cl_context context, cl_device_id device, const cl_mem_properties_intel *properties, size_t size, cl_uint alignment, cl_int *errcode_ret)
     * }
     */
    public static MemorySegment clSharedMemAllocINTEL(MemorySegment context, MemorySegment device, MemorySegment properties, long size, int alignment, MemorySegment errcode_ret) {
        var mh$ = clSharedMemAllocINTEL.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clSharedMemAllocINTEL", context, device, properties, size, alignment, errcode_ret);
            }
            return (MemorySegment)mh$.invokeExact(context, device, properties, size, alignment, errcode_ret);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clMemFreeINTEL {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("clMemFreeINTEL"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern cl_int clMemFreeINTEL(cl_context context, void *ptr)
     * }
     */
    public static FunctionDescriptor clMemFreeINTEL$descriptor() {
        return clMemFreeINTEL.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern cl_int clMemFreeINTEL(cl_context context, void *ptr)
     * }
     */
    public static MethodHandle clMemFreeINTEL$handle() {
        return clMemFreeINTEL.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern cl_int clMemFreeINTEL(cl_context context, void *ptr)
     * }
     */
    public static int clMemFreeINTEL(MemorySegment context, MemorySegment ptr) {
        var mh$ = clMemFreeINTEL.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clMemFreeINTEL", context, ptr);
            }
            return (int)mh$.invokeExact(context, ptr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clMemBlockingFreeINTEL {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("clMemBlockingFreeINTEL"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern cl_int clMemBlockingFreeINTEL(cl_context context, void *ptr)
     * }
     */
    public static FunctionDescriptor clMemBlockingFreeINTEL$descriptor() {
        return clMemBlockingFreeINTEL.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern cl_int clMemBlockingFreeINTEL(cl_context context, void *ptr)
     * }
     */
    public static MethodHandle clMemBlockingFreeINTEL$handle() {
        return clMemBlockingFreeINTEL.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern cl_int clMemBlockingFreeINTEL(cl_context context, void *ptr)
     * }
     */
    public static int clMemBlockingFreeINTEL(MemorySegment context, MemorySegment ptr) {
        var mh$ = clMemBlockingFreeINTEL.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clMemBlockingFreeINTEL", context, ptr);
            }
            return (int)mh$.invokeExact(context, ptr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clGetMemAllocInfoINTEL {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_INT,
            C_LONG_LONG,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("clGetMemAllocInfoINTEL"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern cl_int clGetMemAllocInfoINTEL(cl_context context, const void *ptr, cl_mem_info_intel param_name, size_t param_value_size, void *param_value, size_t *param_value_size_ret)
     * }
     */
    public static FunctionDescriptor clGetMemAllocInfoINTEL$descriptor() {
        return clGetMemAllocInfoINTEL.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern cl_int clGetMemAllocInfoINTEL(cl_context context, const void *ptr, cl_mem_info_intel param_name, size_t param_value_size, void *param_value, size_t *param_value_size_ret)
     * }
     */
    public static MethodHandle clGetMemAllocInfoINTEL$handle() {
        return clGetMemAllocInfoINTEL.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern cl_int clGetMemAllocInfoINTEL(cl_context context, const void *ptr, cl_mem_info_intel param_name, size_t param_value_size, void *param_value, size_t *param_value_size_ret)
     * }
     */
    public static int clGetMemAllocInfoINTEL(MemorySegment context, MemorySegment ptr, int param_name, long param_value_size, MemorySegment param_value, MemorySegment param_value_size_ret) {
        var mh$ = clGetMemAllocInfoINTEL.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clGetMemAllocInfoINTEL", context, ptr, param_name, param_value_size, param_value, param_value_size_ret);
            }
            return (int)mh$.invokeExact(context, ptr, param_name, param_value_size, param_value, param_value_size_ret);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clSetKernelArgMemPointerINTEL {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("clSetKernelArgMemPointerINTEL"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern cl_int clSetKernelArgMemPointerINTEL(cl_kernel kernel, cl_uint arg_index, const void *arg_value)
     * }
     */
    public static FunctionDescriptor clSetKernelArgMemPointerINTEL$descriptor() {
        return clSetKernelArgMemPointerINTEL.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern cl_int clSetKernelArgMemPointerINTEL(cl_kernel kernel, cl_uint arg_index, const void *arg_value)
     * }
     */
    public static MethodHandle clSetKernelArgMemPointerINTEL$handle() {
        return clSetKernelArgMemPointerINTEL.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern cl_int clSetKernelArgMemPointerINTEL(cl_kernel kernel, cl_uint arg_index, const void *arg_value)
     * }
     */
    public static int clSetKernelArgMemPointerINTEL(MemorySegment kernel, int arg_index, MemorySegment arg_value) {
        var mh$ = clSetKernelArgMemPointerINTEL.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clSetKernelArgMemPointerINTEL", kernel, arg_index, arg_value);
            }
            return (int)mh$.invokeExact(kernel, arg_index, arg_value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clEnqueueMemFillINTEL {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_LONG_LONG,
            C_LONG_LONG,
            C_INT,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("clEnqueueMemFillINTEL"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern cl_int clEnqueueMemFillINTEL(cl_command_queue command_queue, void *dst_ptr, const void *pattern, size_t pattern_size, size_t size, cl_uint num_events_in_wait_list, const cl_event *event_wait_list, cl_event *event)
     * }
     */
    public static FunctionDescriptor clEnqueueMemFillINTEL$descriptor() {
        return clEnqueueMemFillINTEL.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern cl_int clEnqueueMemFillINTEL(cl_command_queue command_queue, void *dst_ptr, const void *pattern, size_t pattern_size, size_t size, cl_uint num_events_in_wait_list, const cl_event *event_wait_list, cl_event *event)
     * }
     */
    public static MethodHandle clEnqueueMemFillINTEL$handle() {
        return clEnqueueMemFillINTEL.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern cl_int clEnqueueMemFillINTEL(cl_command_queue command_queue, void *dst_ptr, const void *pattern, size_t pattern_size, size_t size, cl_uint num_events_in_wait_list, const cl_event *event_wait_list, cl_event *event)
     * }
     */
    public static int clEnqueueMemFillINTEL(MemorySegment command_queue, MemorySegment dst_ptr, MemorySegment pattern, long pattern_size, long size, int num_events_in_wait_list, MemorySegment event_wait_list, MemorySegment event) {
        var mh$ = clEnqueueMemFillINTEL.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clEnqueueMemFillINTEL", command_queue, dst_ptr, pattern, pattern_size, size, num_events_in_wait_list, event_wait_list, event);
            }
            return (int)mh$.invokeExact(command_queue, dst_ptr, pattern, pattern_size, size, num_events_in_wait_list, event_wait_list, event);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clEnqueueMemcpyINTEL {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_INT,
            C_POINTER,
            C_POINTER,
            C_LONG_LONG,
            C_INT,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("clEnqueueMemcpyINTEL"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern cl_int clEnqueueMemcpyINTEL(cl_command_queue command_queue, cl_bool blocking, void *dst_ptr, const void *src_ptr, size_t size, cl_uint num_events_in_wait_list, const cl_event *event_wait_list, cl_event *event)
     * }
     */
    public static FunctionDescriptor clEnqueueMemcpyINTEL$descriptor() {
        return clEnqueueMemcpyINTEL.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern cl_int clEnqueueMemcpyINTEL(cl_command_queue command_queue, cl_bool blocking, void *dst_ptr, const void *src_ptr, size_t size, cl_uint num_events_in_wait_list, const cl_event *event_wait_list, cl_event *event)
     * }
     */
    public static MethodHandle clEnqueueMemcpyINTEL$handle() {
        return clEnqueueMemcpyINTEL.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern cl_int clEnqueueMemcpyINTEL(cl_command_queue command_queue, cl_bool blocking, void *dst_ptr, const void *src_ptr, size_t size, cl_uint num_events_in_wait_list, const cl_event *event_wait_list, cl_event *event)
     * }
     */
    public static int clEnqueueMemcpyINTEL(MemorySegment command_queue, int blocking, MemorySegment dst_ptr, MemorySegment src_ptr, long size, int num_events_in_wait_list, MemorySegment event_wait_list, MemorySegment event) {
        var mh$ = clEnqueueMemcpyINTEL.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clEnqueueMemcpyINTEL", command_queue, blocking, dst_ptr, src_ptr, size, num_events_in_wait_list, event_wait_list, event);
            }
            return (int)mh$.invokeExact(command_queue, blocking, dst_ptr, src_ptr, size, num_events_in_wait_list, event_wait_list, event);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clEnqueueMemAdviseINTEL {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_LONG_LONG,
            C_INT,
            C_INT,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("clEnqueueMemAdviseINTEL"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern cl_int clEnqueueMemAdviseINTEL(cl_command_queue command_queue, const void *ptr, size_t size, cl_mem_advice_intel advice, cl_uint num_events_in_wait_list, const cl_event *event_wait_list, cl_event *event)
     * }
     */
    public static FunctionDescriptor clEnqueueMemAdviseINTEL$descriptor() {
        return clEnqueueMemAdviseINTEL.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern cl_int clEnqueueMemAdviseINTEL(cl_command_queue command_queue, const void *ptr, size_t size, cl_mem_advice_intel advice, cl_uint num_events_in_wait_list, const cl_event *event_wait_list, cl_event *event)
     * }
     */
    public static MethodHandle clEnqueueMemAdviseINTEL$handle() {
        return clEnqueueMemAdviseINTEL.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern cl_int clEnqueueMemAdviseINTEL(cl_command_queue command_queue, const void *ptr, size_t size, cl_mem_advice_intel advice, cl_uint num_events_in_wait_list, const cl_event *event_wait_list, cl_event *event)
     * }
     */
    public static int clEnqueueMemAdviseINTEL(MemorySegment command_queue, MemorySegment ptr, long size, int advice, int num_events_in_wait_list, MemorySegment event_wait_list, MemorySegment event) {
        var mh$ = clEnqueueMemAdviseINTEL.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clEnqueueMemAdviseINTEL", command_queue, ptr, size, advice, num_events_in_wait_list, event_wait_list, event);
            }
            return (int)mh$.invokeExact(command_queue, ptr, size, advice, num_events_in_wait_list, event_wait_list, event);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clEnqueueMigrateMemINTEL {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_LONG_LONG,
            C_LONG_LONG,
            C_INT,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("clEnqueueMigrateMemINTEL"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern cl_int clEnqueueMigrateMemINTEL(cl_command_queue command_queue, const void *ptr, size_t size, cl_mem_migration_flags flags, cl_uint num_events_in_wait_list, const cl_event *event_wait_list, cl_event *event)
     * }
     */
    public static FunctionDescriptor clEnqueueMigrateMemINTEL$descriptor() {
        return clEnqueueMigrateMemINTEL.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern cl_int clEnqueueMigrateMemINTEL(cl_command_queue command_queue, const void *ptr, size_t size, cl_mem_migration_flags flags, cl_uint num_events_in_wait_list, const cl_event *event_wait_list, cl_event *event)
     * }
     */
    public static MethodHandle clEnqueueMigrateMemINTEL$handle() {
        return clEnqueueMigrateMemINTEL.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern cl_int clEnqueueMigrateMemINTEL(cl_command_queue command_queue, const void *ptr, size_t size, cl_mem_migration_flags flags, cl_uint num_events_in_wait_list, const cl_event *event_wait_list, cl_event *event)
     * }
     */
    public static int clEnqueueMigrateMemINTEL(MemorySegment command_queue, MemorySegment ptr, long size, long flags, int num_events_in_wait_list, MemorySegment event_wait_list, MemorySegment event) {
        var mh$ = clEnqueueMigrateMemINTEL.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clEnqueueMigrateMemINTEL", command_queue, ptr, size, flags, num_events_in_wait_list, event_wait_list, event);
            }
            return (int)mh$.invokeExact(command_queue, ptr, size, flags, num_events_in_wait_list, event_wait_list, event);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clEnqueueMemsetINTEL {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_INT,
            C_LONG_LONG,
            C_INT,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("clEnqueueMemsetINTEL"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern cl_int clEnqueueMemsetINTEL(cl_command_queue command_queue, void *dst_ptr, cl_int value, size_t size, cl_uint num_events_in_wait_list, const cl_event *event_wait_list, cl_event *event)
     * }
     */
    public static FunctionDescriptor clEnqueueMemsetINTEL$descriptor() {
        return clEnqueueMemsetINTEL.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern cl_int clEnqueueMemsetINTEL(cl_command_queue command_queue, void *dst_ptr, cl_int value, size_t size, cl_uint num_events_in_wait_list, const cl_event *event_wait_list, cl_event *event)
     * }
     */
    public static MethodHandle clEnqueueMemsetINTEL$handle() {
        return clEnqueueMemsetINTEL.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern cl_int clEnqueueMemsetINTEL(cl_command_queue command_queue, void *dst_ptr, cl_int value, size_t size, cl_uint num_events_in_wait_list, const cl_event *event_wait_list, cl_event *event)
     * }
     */
    public static int clEnqueueMemsetINTEL(MemorySegment command_queue, MemorySegment dst_ptr, int value, long size, int num_events_in_wait_list, MemorySegment event_wait_list, MemorySegment event) {
        var mh$ = clEnqueueMemsetINTEL.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clEnqueueMemsetINTEL", command_queue, dst_ptr, value, size, num_events_in_wait_list, event_wait_list, event);
            }
            return (int)mh$.invokeExact(command_queue, dst_ptr, value, size, num_events_in_wait_list, event_wait_list, event);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clCreateBufferWithPropertiesINTEL {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_LONG_LONG,
            C_LONG_LONG,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("clCreateBufferWithPropertiesINTEL"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern cl_mem clCreateBufferWithPropertiesINTEL(cl_context context, const cl_mem_properties_intel *properties, cl_mem_flags flags, size_t size, void *host_ptr, cl_int *errcode_ret)
     * }
     */
    public static FunctionDescriptor clCreateBufferWithPropertiesINTEL$descriptor() {
        return clCreateBufferWithPropertiesINTEL.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern cl_mem clCreateBufferWithPropertiesINTEL(cl_context context, const cl_mem_properties_intel *properties, cl_mem_flags flags, size_t size, void *host_ptr, cl_int *errcode_ret)
     * }
     */
    public static MethodHandle clCreateBufferWithPropertiesINTEL$handle() {
        return clCreateBufferWithPropertiesINTEL.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern cl_mem clCreateBufferWithPropertiesINTEL(cl_context context, const cl_mem_properties_intel *properties, cl_mem_flags flags, size_t size, void *host_ptr, cl_int *errcode_ret)
     * }
     */
    public static MemorySegment clCreateBufferWithPropertiesINTEL(MemorySegment context, MemorySegment properties, long flags, long size, MemorySegment host_ptr, MemorySegment errcode_ret) {
        var mh$ = clCreateBufferWithPropertiesINTEL.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clCreateBufferWithPropertiesINTEL", context, properties, flags, size, host_ptr, errcode_ret);
            }
            return (MemorySegment)mh$.invokeExact(context, properties, flags, size, host_ptr, errcode_ret);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clEnqueueReadHostPipeINTEL {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_INT,
            C_POINTER,
            C_LONG_LONG,
            C_INT,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("clEnqueueReadHostPipeINTEL"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern cl_int clEnqueueReadHostPipeINTEL(cl_command_queue command_queue, cl_program program, const char *pipe_symbol, cl_bool blocking_read, void *ptr, size_t size, cl_uint num_events_in_wait_list, const cl_event *event_wait_list, cl_event *event)
     * }
     */
    public static FunctionDescriptor clEnqueueReadHostPipeINTEL$descriptor() {
        return clEnqueueReadHostPipeINTEL.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern cl_int clEnqueueReadHostPipeINTEL(cl_command_queue command_queue, cl_program program, const char *pipe_symbol, cl_bool blocking_read, void *ptr, size_t size, cl_uint num_events_in_wait_list, const cl_event *event_wait_list, cl_event *event)
     * }
     */
    public static MethodHandle clEnqueueReadHostPipeINTEL$handle() {
        return clEnqueueReadHostPipeINTEL.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern cl_int clEnqueueReadHostPipeINTEL(cl_command_queue command_queue, cl_program program, const char *pipe_symbol, cl_bool blocking_read, void *ptr, size_t size, cl_uint num_events_in_wait_list, const cl_event *event_wait_list, cl_event *event)
     * }
     */
    public static int clEnqueueReadHostPipeINTEL(MemorySegment command_queue, MemorySegment program, MemorySegment pipe_symbol, int blocking_read, MemorySegment ptr, long size, int num_events_in_wait_list, MemorySegment event_wait_list, MemorySegment event) {
        var mh$ = clEnqueueReadHostPipeINTEL.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clEnqueueReadHostPipeINTEL", command_queue, program, pipe_symbol, blocking_read, ptr, size, num_events_in_wait_list, event_wait_list, event);
            }
            return (int)mh$.invokeExact(command_queue, program, pipe_symbol, blocking_read, ptr, size, num_events_in_wait_list, event_wait_list, event);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clEnqueueWriteHostPipeINTEL {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_INT,
            C_POINTER,
            C_LONG_LONG,
            C_INT,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("clEnqueueWriteHostPipeINTEL"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern cl_int clEnqueueWriteHostPipeINTEL(cl_command_queue command_queue, cl_program program, const char *pipe_symbol, cl_bool blocking_write, const void *ptr, size_t size, cl_uint num_events_in_wait_list, const cl_event *event_wait_list, cl_event *event)
     * }
     */
    public static FunctionDescriptor clEnqueueWriteHostPipeINTEL$descriptor() {
        return clEnqueueWriteHostPipeINTEL.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern cl_int clEnqueueWriteHostPipeINTEL(cl_command_queue command_queue, cl_program program, const char *pipe_symbol, cl_bool blocking_write, const void *ptr, size_t size, cl_uint num_events_in_wait_list, const cl_event *event_wait_list, cl_event *event)
     * }
     */
    public static MethodHandle clEnqueueWriteHostPipeINTEL$handle() {
        return clEnqueueWriteHostPipeINTEL.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern cl_int clEnqueueWriteHostPipeINTEL(cl_command_queue command_queue, cl_program program, const char *pipe_symbol, cl_bool blocking_write, const void *ptr, size_t size, cl_uint num_events_in_wait_list, const cl_event *event_wait_list, cl_event *event)
     * }
     */
    public static int clEnqueueWriteHostPipeINTEL(MemorySegment command_queue, MemorySegment program, MemorySegment pipe_symbol, int blocking_write, MemorySegment ptr, long size, int num_events_in_wait_list, MemorySegment event_wait_list, MemorySegment event) {
        var mh$ = clEnqueueWriteHostPipeINTEL.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clEnqueueWriteHostPipeINTEL", command_queue, program, pipe_symbol, blocking_write, ptr, size, num_events_in_wait_list, event_wait_list, event);
            }
            return (int)mh$.invokeExact(command_queue, program, pipe_symbol, blocking_write, ptr, size, num_events_in_wait_list, event_wait_list, event);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef cl_bitfield cl_command_queue_capabilities_intel
     * }
     */
    public static final OfLong cl_command_queue_capabilities_intel = C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef cl_uint cl_image_requirements_info_ext
     * }
     */
    public static final OfInt cl_image_requirements_info_ext = C_INT;

    private static class clGetImageRequirementsInfoEXT {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_LONG_LONG,
            C_POINTER,
            C_POINTER,
            C_INT,
            C_LONG_LONG,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("clGetImageRequirementsInfoEXT"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern cl_int clGetImageRequirementsInfoEXT(cl_context context, const cl_mem_properties *properties, cl_mem_flags flags, const cl_image_format *image_format, const cl_image_desc *image_desc, cl_image_requirements_info_ext param_name, size_t param_value_size, void *param_value, size_t *param_value_size_ret)
     * }
     */
    public static FunctionDescriptor clGetImageRequirementsInfoEXT$descriptor() {
        return clGetImageRequirementsInfoEXT.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern cl_int clGetImageRequirementsInfoEXT(cl_context context, const cl_mem_properties *properties, cl_mem_flags flags, const cl_image_format *image_format, const cl_image_desc *image_desc, cl_image_requirements_info_ext param_name, size_t param_value_size, void *param_value, size_t *param_value_size_ret)
     * }
     */
    public static MethodHandle clGetImageRequirementsInfoEXT$handle() {
        return clGetImageRequirementsInfoEXT.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern cl_int clGetImageRequirementsInfoEXT(cl_context context, const cl_mem_properties *properties, cl_mem_flags flags, const cl_image_format *image_format, const cl_image_desc *image_desc, cl_image_requirements_info_ext param_name, size_t param_value_size, void *param_value, size_t *param_value_size_ret)
     * }
     */
    public static int clGetImageRequirementsInfoEXT(MemorySegment context, MemorySegment properties, long flags, MemorySegment image_format, MemorySegment image_desc, int param_name, long param_value_size, MemorySegment param_value, MemorySegment param_value_size_ret) {
        var mh$ = clGetImageRequirementsInfoEXT.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clGetImageRequirementsInfoEXT", context, properties, flags, image_format, image_desc, param_name, param_value_size, param_value, param_value_size_ret);
            }
            return (int)mh$.invokeExact(context, properties, flags, image_format, image_desc, param_name, param_value_size, param_value, param_value_size_ret);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef cl_uint cl_icdl_info
     * }
     */
    public static final OfInt cl_icdl_info = C_INT;

    private static class clGetICDLoaderInfoOCLICD {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_INT,
            C_LONG_LONG,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("clGetICDLoaderInfoOCLICD"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern cl_int clGetICDLoaderInfoOCLICD(cl_icdl_info param_name, size_t param_value_size, void *param_value, size_t *param_value_size_ret)
     * }
     */
    public static FunctionDescriptor clGetICDLoaderInfoOCLICD$descriptor() {
        return clGetICDLoaderInfoOCLICD.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern cl_int clGetICDLoaderInfoOCLICD(cl_icdl_info param_name, size_t param_value_size, void *param_value, size_t *param_value_size_ret)
     * }
     */
    public static MethodHandle clGetICDLoaderInfoOCLICD$handle() {
        return clGetICDLoaderInfoOCLICD.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern cl_int clGetICDLoaderInfoOCLICD(cl_icdl_info param_name, size_t param_value_size, void *param_value, size_t *param_value_size_ret)
     * }
     */
    public static int clGetICDLoaderInfoOCLICD(int param_name, long param_value_size, MemorySegment param_value, MemorySegment param_value_size_ret) {
        var mh$ = clGetICDLoaderInfoOCLICD.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clGetICDLoaderInfoOCLICD", param_name, param_value_size, param_value, param_value_size_ret);
            }
            return (int)mh$.invokeExact(param_name, param_value_size, param_value, param_value_size_ret);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef cl_bitfield cl_device_fp_atomic_capabilities_ext
     * }
     */
    public static final OfLong cl_device_fp_atomic_capabilities_ext = C_LONG_LONG;

    private static class clSetContentSizeBufferPoCL {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("clSetContentSizeBufferPoCL"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern cl_int clSetContentSizeBufferPoCL(cl_mem buffer, cl_mem content_size_buffer)
     * }
     */
    public static FunctionDescriptor clSetContentSizeBufferPoCL$descriptor() {
        return clSetContentSizeBufferPoCL.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern cl_int clSetContentSizeBufferPoCL(cl_mem buffer, cl_mem content_size_buffer)
     * }
     */
    public static MethodHandle clSetContentSizeBufferPoCL$handle() {
        return clSetContentSizeBufferPoCL.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern cl_int clSetContentSizeBufferPoCL(cl_mem buffer, cl_mem content_size_buffer)
     * }
     */
    public static int clSetContentSizeBufferPoCL(MemorySegment buffer, MemorySegment content_size_buffer) {
        var mh$ = clSetContentSizeBufferPoCL.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clSetContentSizeBufferPoCL", buffer, content_size_buffer);
            }
            return (int)mh$.invokeExact(buffer, content_size_buffer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int _VCRUNTIME_DISABLED_WARNINGS = (int)4514L;
    /**
     * {@snippet lang=c :
     * #define _VCRUNTIME_DISABLED_WARNINGS 4514
     * }
     */
    public static int _VCRUNTIME_DISABLED_WARNINGS() {
        return _VCRUNTIME_DISABLED_WARNINGS;
    }
    private static final MemorySegment NULL = MemorySegment.ofAddress(0L);
    /**
     * {@snippet lang=c :
     * #define NULL (void*) 0
     * }
     */
    public static MemorySegment NULL() {
        return NULL;
    }
    private static final int INT8_MIN = (int)-128L;
    /**
     * {@snippet lang=c :
     * #define INT8_MIN -128
     * }
     */
    public static int INT8_MIN() {
        return INT8_MIN;
    }
    private static final int INT16_MIN = (int)-32768L;
    /**
     * {@snippet lang=c :
     * #define INT16_MIN -32768
     * }
     */
    public static int INT16_MIN() {
        return INT16_MIN;
    }
    private static final int INT32_MIN = (int)-2147483648L;
    /**
     * {@snippet lang=c :
     * #define INT32_MIN -2147483648
     * }
     */
    public static int INT32_MIN() {
        return INT32_MIN;
    }
    private static final long INT64_MIN = -9223372036854775808L;
    /**
     * {@snippet lang=c :
     * #define INT64_MIN -9223372036854775808
     * }
     */
    public static long INT64_MIN() {
        return INT64_MIN;
    }
    private static final byte INT8_MAX = (byte)127L;
    /**
     * {@snippet lang=c :
     * #define INT8_MAX 127
     * }
     */
    public static byte INT8_MAX() {
        return INT8_MAX;
    }
    private static final short INT16_MAX = (short)32767L;
    /**
     * {@snippet lang=c :
     * #define INT16_MAX 32767
     * }
     */
    public static short INT16_MAX() {
        return INT16_MAX;
    }
    private static final int INT32_MAX = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * #define INT32_MAX 2147483647
     * }
     */
    public static int INT32_MAX() {
        return INT32_MAX;
    }
    private static final long INT64_MAX = 9223372036854775807L;
    /**
     * {@snippet lang=c :
     * #define INT64_MAX 9223372036854775807
     * }
     */
    public static long INT64_MAX() {
        return INT64_MAX;
    }
    private static final byte UINT8_MAX = (byte)255L;
    /**
     * {@snippet lang=c :
     * #define UINT8_MAX 255
     * }
     */
    public static byte UINT8_MAX() {
        return UINT8_MAX;
    }
    private static final short UINT16_MAX = (short)65535L;
    /**
     * {@snippet lang=c :
     * #define UINT16_MAX 65535
     * }
     */
    public static short UINT16_MAX() {
        return UINT16_MAX;
    }
    private static final int UINT32_MAX = (int)4294967295L;
    /**
     * {@snippet lang=c :
     * #define UINT32_MAX 4294967295
     * }
     */
    public static int UINT32_MAX() {
        return UINT32_MAX;
    }
    private static final long UINT64_MAX = -1L;
    /**
     * {@snippet lang=c :
     * #define UINT64_MAX -1
     * }
     */
    public static long UINT64_MAX() {
        return UINT64_MAX;
    }
    private static final int INT_LEAST8_MIN = (int)-128L;
    /**
     * {@snippet lang=c :
     * #define INT_LEAST8_MIN -128
     * }
     */
    public static int INT_LEAST8_MIN() {
        return INT_LEAST8_MIN;
    }
    private static final int INT_LEAST16_MIN = (int)-32768L;
    /**
     * {@snippet lang=c :
     * #define INT_LEAST16_MIN -32768
     * }
     */
    public static int INT_LEAST16_MIN() {
        return INT_LEAST16_MIN;
    }
    private static final int INT_LEAST32_MIN = (int)-2147483648L;
    /**
     * {@snippet lang=c :
     * #define INT_LEAST32_MIN -2147483648
     * }
     */
    public static int INT_LEAST32_MIN() {
        return INT_LEAST32_MIN;
    }
    private static final long INT_LEAST64_MIN = -9223372036854775808L;
    /**
     * {@snippet lang=c :
     * #define INT_LEAST64_MIN -9223372036854775808
     * }
     */
    public static long INT_LEAST64_MIN() {
        return INT_LEAST64_MIN;
    }
    private static final byte INT_LEAST8_MAX = (byte)127L;
    /**
     * {@snippet lang=c :
     * #define INT_LEAST8_MAX 127
     * }
     */
    public static byte INT_LEAST8_MAX() {
        return INT_LEAST8_MAX;
    }
    private static final short INT_LEAST16_MAX = (short)32767L;
    /**
     * {@snippet lang=c :
     * #define INT_LEAST16_MAX 32767
     * }
     */
    public static short INT_LEAST16_MAX() {
        return INT_LEAST16_MAX;
    }
    private static final int INT_LEAST32_MAX = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * #define INT_LEAST32_MAX 2147483647
     * }
     */
    public static int INT_LEAST32_MAX() {
        return INT_LEAST32_MAX;
    }
    private static final long INT_LEAST64_MAX = 9223372036854775807L;
    /**
     * {@snippet lang=c :
     * #define INT_LEAST64_MAX 9223372036854775807
     * }
     */
    public static long INT_LEAST64_MAX() {
        return INT_LEAST64_MAX;
    }
    private static final byte UINT_LEAST8_MAX = (byte)255L;
    /**
     * {@snippet lang=c :
     * #define UINT_LEAST8_MAX 255
     * }
     */
    public static byte UINT_LEAST8_MAX() {
        return UINT_LEAST8_MAX;
    }
    private static final short UINT_LEAST16_MAX = (short)65535L;
    /**
     * {@snippet lang=c :
     * #define UINT_LEAST16_MAX 65535
     * }
     */
    public static short UINT_LEAST16_MAX() {
        return UINT_LEAST16_MAX;
    }
    private static final int UINT_LEAST32_MAX = (int)4294967295L;
    /**
     * {@snippet lang=c :
     * #define UINT_LEAST32_MAX 4294967295
     * }
     */
    public static int UINT_LEAST32_MAX() {
        return UINT_LEAST32_MAX;
    }
    private static final long UINT_LEAST64_MAX = -1L;
    /**
     * {@snippet lang=c :
     * #define UINT_LEAST64_MAX -1
     * }
     */
    public static long UINT_LEAST64_MAX() {
        return UINT_LEAST64_MAX;
    }
    private static final int INT_FAST8_MIN = (int)-128L;
    /**
     * {@snippet lang=c :
     * #define INT_FAST8_MIN -128
     * }
     */
    public static int INT_FAST8_MIN() {
        return INT_FAST8_MIN;
    }
    private static final int INT_FAST16_MIN = (int)-2147483648L;
    /**
     * {@snippet lang=c :
     * #define INT_FAST16_MIN -2147483648
     * }
     */
    public static int INT_FAST16_MIN() {
        return INT_FAST16_MIN;
    }
    private static final int INT_FAST32_MIN = (int)-2147483648L;
    /**
     * {@snippet lang=c :
     * #define INT_FAST32_MIN -2147483648
     * }
     */
    public static int INT_FAST32_MIN() {
        return INT_FAST32_MIN;
    }
    private static final long INT_FAST64_MIN = -9223372036854775808L;
    /**
     * {@snippet lang=c :
     * #define INT_FAST64_MIN -9223372036854775808
     * }
     */
    public static long INT_FAST64_MIN() {
        return INT_FAST64_MIN;
    }
    private static final byte INT_FAST8_MAX = (byte)127L;
    /**
     * {@snippet lang=c :
     * #define INT_FAST8_MAX 127
     * }
     */
    public static byte INT_FAST8_MAX() {
        return INT_FAST8_MAX;
    }
    private static final int INT_FAST16_MAX = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * #define INT_FAST16_MAX 2147483647
     * }
     */
    public static int INT_FAST16_MAX() {
        return INT_FAST16_MAX;
    }
    private static final int INT_FAST32_MAX = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * #define INT_FAST32_MAX 2147483647
     * }
     */
    public static int INT_FAST32_MAX() {
        return INT_FAST32_MAX;
    }
    private static final long INT_FAST64_MAX = 9223372036854775807L;
    /**
     * {@snippet lang=c :
     * #define INT_FAST64_MAX 9223372036854775807
     * }
     */
    public static long INT_FAST64_MAX() {
        return INT_FAST64_MAX;
    }
    private static final byte UINT_FAST8_MAX = (byte)255L;
    /**
     * {@snippet lang=c :
     * #define UINT_FAST8_MAX 255
     * }
     */
    public static byte UINT_FAST8_MAX() {
        return UINT_FAST8_MAX;
    }
    private static final int UINT_FAST16_MAX = (int)4294967295L;
    /**
     * {@snippet lang=c :
     * #define UINT_FAST16_MAX 4294967295
     * }
     */
    public static int UINT_FAST16_MAX() {
        return UINT_FAST16_MAX;
    }
    private static final int UINT_FAST32_MAX = (int)4294967295L;
    /**
     * {@snippet lang=c :
     * #define UINT_FAST32_MAX 4294967295
     * }
     */
    public static int UINT_FAST32_MAX() {
        return UINT_FAST32_MAX;
    }
    private static final long UINT_FAST64_MAX = -1L;
    /**
     * {@snippet lang=c :
     * #define UINT_FAST64_MAX -1
     * }
     */
    public static long UINT_FAST64_MAX() {
        return UINT_FAST64_MAX;
    }
    private static final long INTPTR_MIN = -9223372036854775808L;
    /**
     * {@snippet lang=c :
     * #define INTPTR_MIN -9223372036854775808
     * }
     */
    public static long INTPTR_MIN() {
        return INTPTR_MIN;
    }
    private static final long INTPTR_MAX = 9223372036854775807L;
    /**
     * {@snippet lang=c :
     * #define INTPTR_MAX 9223372036854775807
     * }
     */
    public static long INTPTR_MAX() {
        return INTPTR_MAX;
    }
    private static final long UINTPTR_MAX = -1L;
    /**
     * {@snippet lang=c :
     * #define UINTPTR_MAX -1
     * }
     */
    public static long UINTPTR_MAX() {
        return UINTPTR_MAX;
    }
    private static final long INTMAX_MIN = -9223372036854775808L;
    /**
     * {@snippet lang=c :
     * #define INTMAX_MIN -9223372036854775808
     * }
     */
    public static long INTMAX_MIN() {
        return INTMAX_MIN;
    }
    private static final long INTMAX_MAX = 9223372036854775807L;
    /**
     * {@snippet lang=c :
     * #define INTMAX_MAX 9223372036854775807
     * }
     */
    public static long INTMAX_MAX() {
        return INTMAX_MAX;
    }
    private static final long UINTMAX_MAX = -1L;
    /**
     * {@snippet lang=c :
     * #define UINTMAX_MAX -1
     * }
     */
    public static long UINTMAX_MAX() {
        return UINTMAX_MAX;
    }
    private static final long PTRDIFF_MIN = -9223372036854775808L;
    /**
     * {@snippet lang=c :
     * #define PTRDIFF_MIN -9223372036854775808
     * }
     */
    public static long PTRDIFF_MIN() {
        return PTRDIFF_MIN;
    }
    private static final long PTRDIFF_MAX = 9223372036854775807L;
    /**
     * {@snippet lang=c :
     * #define PTRDIFF_MAX 9223372036854775807
     * }
     */
    public static long PTRDIFF_MAX() {
        return PTRDIFF_MAX;
    }
    private static final long SIZE_MAX = -1L;
    /**
     * {@snippet lang=c :
     * #define SIZE_MAX -1
     * }
     */
    public static long SIZE_MAX() {
        return SIZE_MAX;
    }
    private static final int SIG_ATOMIC_MIN = (int)-2147483648L;
    /**
     * {@snippet lang=c :
     * #define SIG_ATOMIC_MIN -2147483648
     * }
     */
    public static int SIG_ATOMIC_MIN() {
        return SIG_ATOMIC_MIN;
    }
    private static final int SIG_ATOMIC_MAX = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * #define SIG_ATOMIC_MAX 2147483647
     * }
     */
    public static int SIG_ATOMIC_MAX() {
        return SIG_ATOMIC_MAX;
    }
    private static final int CL_SCHAR_MIN = (int)-128L;
    /**
     * {@snippet lang=c :
     * #define CL_SCHAR_MIN -128
     * }
     */
    public static int CL_SCHAR_MIN() {
        return CL_SCHAR_MIN;
    }
    private static final int CL_CHAR_MAX = (int)127L;
    /**
     * {@snippet lang=c :
     * #define CL_CHAR_MAX 127
     * }
     */
    public static int CL_CHAR_MAX() {
        return CL_CHAR_MAX;
    }
    private static final int CL_CHAR_MIN = (int)-128L;
    /**
     * {@snippet lang=c :
     * #define CL_CHAR_MIN -128
     * }
     */
    public static int CL_CHAR_MIN() {
        return CL_CHAR_MIN;
    }
    private static final int CL_SHRT_MIN = (int)-32768L;
    /**
     * {@snippet lang=c :
     * #define CL_SHRT_MIN -32768
     * }
     */
    public static int CL_SHRT_MIN() {
        return CL_SHRT_MIN;
    }
    private static final int CL_INT_MIN = (int)-2147483648L;
    /**
     * {@snippet lang=c :
     * #define CL_INT_MIN -2147483648
     * }
     */
    public static int CL_INT_MIN() {
        return CL_INT_MIN;
    }
    private static final int CL_UINT_MAX = (int)4294967295L;
    /**
     * {@snippet lang=c :
     * #define CL_UINT_MAX 4294967295
     * }
     */
    public static int CL_UINT_MAX() {
        return CL_UINT_MAX;
    }
    private static final long CL_LONG_MAX = 9223372036854775807L;
    /**
     * {@snippet lang=c :
     * #define CL_LONG_MAX 9223372036854775807
     * }
     */
    public static long CL_LONG_MAX() {
        return CL_LONG_MAX;
    }
    private static final long CL_LONG_MIN = -9223372036854775808L;
    /**
     * {@snippet lang=c :
     * #define CL_LONG_MIN -9223372036854775808
     * }
     */
    public static long CL_LONG_MIN() {
        return CL_LONG_MIN;
    }
    private static final long CL_ULONG_MAX = -1L;
    /**
     * {@snippet lang=c :
     * #define CL_ULONG_MAX -1
     * }
     */
    public static long CL_ULONG_MAX() {
        return CL_ULONG_MAX;
    }
    private static final int CL_FLT_MAX_10_EXP = (int)38L;
    /**
     * {@snippet lang=c :
     * #define CL_FLT_MAX_10_EXP 38
     * }
     */
    public static int CL_FLT_MAX_10_EXP() {
        return CL_FLT_MAX_10_EXP;
    }
    private static final int CL_FLT_MAX_EXP = (int)128L;
    /**
     * {@snippet lang=c :
     * #define CL_FLT_MAX_EXP 128
     * }
     */
    public static int CL_FLT_MAX_EXP() {
        return CL_FLT_MAX_EXP;
    }
    private static final int CL_FLT_MIN_10_EXP = (int)-37L;
    /**
     * {@snippet lang=c :
     * #define CL_FLT_MIN_10_EXP -37
     * }
     */
    public static int CL_FLT_MIN_10_EXP() {
        return CL_FLT_MIN_10_EXP;
    }
    private static final int CL_FLT_MIN_EXP = (int)-125L;
    /**
     * {@snippet lang=c :
     * #define CL_FLT_MIN_EXP -125
     * }
     */
    public static int CL_FLT_MIN_EXP() {
        return CL_FLT_MIN_EXP;
    }
    private static final float CL_FLT_MAX = 3.4028234663852886E38f;
    /**
     * {@snippet lang=c :
     * #define CL_FLT_MAX 3.4028234663852886E38
     * }
     */
    public static float CL_FLT_MAX() {
        return CL_FLT_MAX;
    }
    private static final float CL_FLT_MIN = 1.1754943508222875E-38f;
    /**
     * {@snippet lang=c :
     * #define CL_FLT_MIN 1.1754943508222875E-38
     * }
     */
    public static float CL_FLT_MIN() {
        return CL_FLT_MIN;
    }
    private static final float CL_FLT_EPSILON = 1.1920928955078125E-7f;
    /**
     * {@snippet lang=c :
     * #define CL_FLT_EPSILON 1.1920928955078125E-7
     * }
     */
    public static float CL_FLT_EPSILON() {
        return CL_FLT_EPSILON;
    }
    private static final int CL_HALF_MAX_10_EXP = (int)4L;
    /**
     * {@snippet lang=c :
     * #define CL_HALF_MAX_10_EXP 4
     * }
     */
    public static int CL_HALF_MAX_10_EXP() {
        return CL_HALF_MAX_10_EXP;
    }
    private static final int CL_HALF_MAX_EXP = (int)16L;
    /**
     * {@snippet lang=c :
     * #define CL_HALF_MAX_EXP 16
     * }
     */
    public static int CL_HALF_MAX_EXP() {
        return CL_HALF_MAX_EXP;
    }
    private static final int CL_HALF_MIN_10_EXP = (int)-4L;
    /**
     * {@snippet lang=c :
     * #define CL_HALF_MIN_10_EXP -4
     * }
     */
    public static int CL_HALF_MIN_10_EXP() {
        return CL_HALF_MIN_10_EXP;
    }
    private static final int CL_HALF_MIN_EXP = (int)-13L;
    /**
     * {@snippet lang=c :
     * #define CL_HALF_MIN_EXP -13
     * }
     */
    public static int CL_HALF_MIN_EXP() {
        return CL_HALF_MIN_EXP;
    }
    private static final float CL_HALF_MAX = 65504.0f;
    /**
     * {@snippet lang=c :
     * #define CL_HALF_MAX 65504.0
     * }
     */
    public static float CL_HALF_MAX() {
        return CL_HALF_MAX;
    }
    private static final float CL_HALF_MIN = 6.103515625E-5f;
    /**
     * {@snippet lang=c :
     * #define CL_HALF_MIN 6.103515625E-5
     * }
     */
    public static float CL_HALF_MIN() {
        return CL_HALF_MIN;
    }
    private static final float CL_HALF_EPSILON = 9.765625E-4f;
    /**
     * {@snippet lang=c :
     * #define CL_HALF_EPSILON 9.765625E-4
     * }
     */
    public static float CL_HALF_EPSILON() {
        return CL_HALF_EPSILON;
    }
    private static final int CL_DBL_MAX_10_EXP = (int)308L;
    /**
     * {@snippet lang=c :
     * #define CL_DBL_MAX_10_EXP 308
     * }
     */
    public static int CL_DBL_MAX_10_EXP() {
        return CL_DBL_MAX_10_EXP;
    }
    private static final int CL_DBL_MAX_EXP = (int)1024L;
    /**
     * {@snippet lang=c :
     * #define CL_DBL_MAX_EXP 1024
     * }
     */
    public static int CL_DBL_MAX_EXP() {
        return CL_DBL_MAX_EXP;
    }
    private static final int CL_DBL_MIN_10_EXP = (int)-307L;
    /**
     * {@snippet lang=c :
     * #define CL_DBL_MIN_10_EXP -307
     * }
     */
    public static int CL_DBL_MIN_10_EXP() {
        return CL_DBL_MIN_10_EXP;
    }
    private static final int CL_DBL_MIN_EXP = (int)-1021L;
    /**
     * {@snippet lang=c :
     * #define CL_DBL_MIN_EXP -1021
     * }
     */
    public static int CL_DBL_MIN_EXP() {
        return CL_DBL_MIN_EXP;
    }
    private static final double CL_DBL_MAX = 1.7976931348623157E308d;
    /**
     * {@snippet lang=c :
     * #define CL_DBL_MAX 1.7976931348623157E308
     * }
     */
    public static double CL_DBL_MAX() {
        return CL_DBL_MAX;
    }
    private static final double CL_DBL_MIN = 2.2250738585072014E-308d;
    /**
     * {@snippet lang=c :
     * #define CL_DBL_MIN 2.2250738585072014E-308
     * }
     */
    public static double CL_DBL_MIN() {
        return CL_DBL_MIN;
    }
    private static final double CL_DBL_EPSILON = 2.220446049250313E-16d;
    /**
     * {@snippet lang=c :
     * #define CL_DBL_EPSILON 2.220446049250313E-16
     * }
     */
    public static double CL_DBL_EPSILON() {
        return CL_DBL_EPSILON;
    }
    private static final double CL_M_E = 2.718281828459045d;
    /**
     * {@snippet lang=c :
     * #define CL_M_E 2.718281828459045
     * }
     */
    public static double CL_M_E() {
        return CL_M_E;
    }
    private static final double CL_M_LOG2E = 1.4426950408889634d;
    /**
     * {@snippet lang=c :
     * #define CL_M_LOG2E 1.4426950408889634
     * }
     */
    public static double CL_M_LOG2E() {
        return CL_M_LOG2E;
    }
    private static final double CL_M_LOG10E = 0.4342944819032518d;
    /**
     * {@snippet lang=c :
     * #define CL_M_LOG10E 0.4342944819032518
     * }
     */
    public static double CL_M_LOG10E() {
        return CL_M_LOG10E;
    }
    private static final double CL_M_LN2 = 0.6931471805599453d;
    /**
     * {@snippet lang=c :
     * #define CL_M_LN2 0.6931471805599453
     * }
     */
    public static double CL_M_LN2() {
        return CL_M_LN2;
    }
    private static final double CL_M_LN10 = 2.302585092994046d;
    /**
     * {@snippet lang=c :
     * #define CL_M_LN10 2.302585092994046
     * }
     */
    public static double CL_M_LN10() {
        return CL_M_LN10;
    }
    private static final double CL_M_PI = 3.141592653589793d;
    /**
     * {@snippet lang=c :
     * #define CL_M_PI 3.141592653589793
     * }
     */
    public static double CL_M_PI() {
        return CL_M_PI;
    }
    private static final double CL_M_PI_2 = 1.5707963267948966d;
    /**
     * {@snippet lang=c :
     * #define CL_M_PI_2 1.5707963267948966
     * }
     */
    public static double CL_M_PI_2() {
        return CL_M_PI_2;
    }
    private static final double CL_M_PI_4 = 0.7853981633974483d;
    /**
     * {@snippet lang=c :
     * #define CL_M_PI_4 0.7853981633974483
     * }
     */
    public static double CL_M_PI_4() {
        return CL_M_PI_4;
    }
    private static final double CL_M_1_PI = 0.3183098861837907d;
    /**
     * {@snippet lang=c :
     * #define CL_M_1_PI 0.3183098861837907
     * }
     */
    public static double CL_M_1_PI() {
        return CL_M_1_PI;
    }
    private static final double CL_M_2_PI = 0.6366197723675814d;
    /**
     * {@snippet lang=c :
     * #define CL_M_2_PI 0.6366197723675814
     * }
     */
    public static double CL_M_2_PI() {
        return CL_M_2_PI;
    }
    private static final double CL_M_2_SQRTPI = 1.1283791670955126d;
    /**
     * {@snippet lang=c :
     * #define CL_M_2_SQRTPI 1.1283791670955126
     * }
     */
    public static double CL_M_2_SQRTPI() {
        return CL_M_2_SQRTPI;
    }
    private static final double CL_M_SQRT2 = 1.4142135623730951d;
    /**
     * {@snippet lang=c :
     * #define CL_M_SQRT2 1.4142135623730951
     * }
     */
    public static double CL_M_SQRT2() {
        return CL_M_SQRT2;
    }
    private static final double CL_M_SQRT1_2 = 0.7071067811865476d;
    /**
     * {@snippet lang=c :
     * #define CL_M_SQRT1_2 0.7071067811865476
     * }
     */
    public static double CL_M_SQRT1_2() {
        return CL_M_SQRT1_2;
    }
    private static final float CL_M_E_F = 2.7182817459106445f;
    /**
     * {@snippet lang=c :
     * #define CL_M_E_F 2.7182817459106445
     * }
     */
    public static float CL_M_E_F() {
        return CL_M_E_F;
    }
    private static final float CL_M_LOG2E_F = 1.4426950216293335f;
    /**
     * {@snippet lang=c :
     * #define CL_M_LOG2E_F 1.4426950216293335
     * }
     */
    public static float CL_M_LOG2E_F() {
        return CL_M_LOG2E_F;
    }
    private static final float CL_M_LOG10E_F = 0.4342944920063019f;
    /**
     * {@snippet lang=c :
     * #define CL_M_LOG10E_F 0.4342944920063019
     * }
     */
    public static float CL_M_LOG10E_F() {
        return CL_M_LOG10E_F;
    }
    private static final float CL_M_LN2_F = 0.6931471824645996f;
    /**
     * {@snippet lang=c :
     * #define CL_M_LN2_F 0.6931471824645996
     * }
     */
    public static float CL_M_LN2_F() {
        return CL_M_LN2_F;
    }
    private static final float CL_M_LN10_F = 2.3025851249694824f;
    /**
     * {@snippet lang=c :
     * #define CL_M_LN10_F 2.3025851249694824
     * }
     */
    public static float CL_M_LN10_F() {
        return CL_M_LN10_F;
    }
    private static final float CL_M_PI_F = 3.1415927410125732f;
    /**
     * {@snippet lang=c :
     * #define CL_M_PI_F 3.1415927410125732
     * }
     */
    public static float CL_M_PI_F() {
        return CL_M_PI_F;
    }
    private static final float CL_M_PI_2_F = 1.5707963705062866f;
    /**
     * {@snippet lang=c :
     * #define CL_M_PI_2_F 1.5707963705062866
     * }
     */
    public static float CL_M_PI_2_F() {
        return CL_M_PI_2_F;
    }
    private static final float CL_M_PI_4_F = 0.7853981852531433f;
    /**
     * {@snippet lang=c :
     * #define CL_M_PI_4_F 0.7853981852531433
     * }
     */
    public static float CL_M_PI_4_F() {
        return CL_M_PI_4_F;
    }
    private static final float CL_M_1_PI_F = 0.31830987334251404f;
    /**
     * {@snippet lang=c :
     * #define CL_M_1_PI_F 0.31830987334251404
     * }
     */
    public static float CL_M_1_PI_F() {
        return CL_M_1_PI_F;
    }
    private static final float CL_M_2_PI_F = 0.6366197466850281f;
    /**
     * {@snippet lang=c :
     * #define CL_M_2_PI_F 0.6366197466850281
     * }
     */
    public static float CL_M_2_PI_F() {
        return CL_M_2_PI_F;
    }
    private static final float CL_M_2_SQRTPI_F = 1.128379225730896f;
    /**
     * {@snippet lang=c :
     * #define CL_M_2_SQRTPI_F 1.128379225730896
     * }
     */
    public static float CL_M_2_SQRTPI_F() {
        return CL_M_2_SQRTPI_F;
    }
    private static final float CL_M_SQRT2_F = 1.4142135381698608f;
    /**
     * {@snippet lang=c :
     * #define CL_M_SQRT2_F 1.4142135381698608
     * }
     */
    public static float CL_M_SQRT2_F() {
        return CL_M_SQRT2_F;
    }
    private static final float CL_M_SQRT1_2_F = 0.7071067690849304f;
    /**
     * {@snippet lang=c :
     * #define CL_M_SQRT1_2_F 0.7071067690849304
     * }
     */
    public static float CL_M_SQRT1_2_F() {
        return CL_M_SQRT1_2_F;
    }
    private static final float CL_NAN = Float.parseFloat("NaN");
    /**
     * {@snippet lang=c :
     * #define CL_NAN NaN
     * }
     */
    public static float CL_NAN() {
        return CL_NAN;
    }
    private static final float CL_HUGE_VALF = Float.parseFloat("Infinity");
    /**
     * {@snippet lang=c :
     * #define CL_HUGE_VALF Infinity
     * }
     */
    public static float CL_HUGE_VALF() {
        return CL_HUGE_VALF;
    }
    private static final double CL_HUGE_VAL = Double.parseDouble("Infinity");
    /**
     * {@snippet lang=c :
     * #define CL_HUGE_VAL Infinity
     * }
     */
    public static double CL_HUGE_VAL() {
        return CL_HUGE_VAL;
    }
    private static final float CL_MAXFLOAT = 3.4028234663852886E38f;
    /**
     * {@snippet lang=c :
     * #define CL_MAXFLOAT 3.4028234663852886E38
     * }
     */
    public static float CL_MAXFLOAT() {
        return CL_MAXFLOAT;
    }
    private static final float CL_INFINITY = Float.parseFloat("Infinity");
    /**
     * {@snippet lang=c :
     * #define CL_INFINITY Infinity
     * }
     */
    public static float CL_INFINITY() {
        return CL_INFINITY;
    }
    private static final int _UCRT_DISABLED_WARNINGS = (int)4324L;
    /**
     * {@snippet lang=c :
     * #define _UCRT_DISABLED_WARNINGS 4324
     * }
     */
    public static int _UCRT_DISABLED_WARNINGS() {
        return _UCRT_DISABLED_WARNINGS;
    }
    private static final long _TRUNCATE = -1L;
    /**
     * {@snippet lang=c :
     * #define _TRUNCATE -1
     * }
     */
    public static long _TRUNCATE() {
        return _TRUNCATE;
    }
    private static final long _CRT_SIZE_MAX = -1L;
    /**
     * {@snippet lang=c :
     * #define _CRT_SIZE_MAX -1
     * }
     */
    public static long _CRT_SIZE_MAX() {
        return _CRT_SIZE_MAX;
    }
    /**
     * {@snippet lang=c :
     * #define __FILEW__ "C"
     * }
     */
    public static MemorySegment __FILEW__() {
        class Holder {
            static final MemorySegment __FILEW__
                = LIBRARY_ARENA.allocateFrom("C");
        }
        return Holder.__FILEW__;
    }
    private static final int __STDC_SECURE_LIB__ = (int)200411L;
    /**
     * {@snippet lang=c :
     * #define __STDC_SECURE_LIB__ 200411
     * }
     */
    public static int __STDC_SECURE_LIB__() {
        return __STDC_SECURE_LIB__;
    }
    private static final int __GOT_SECURE_LIB__ = (int)200411L;
    /**
     * {@snippet lang=c :
     * #define __GOT_SECURE_LIB__ 200411
     * }
     */
    public static int __GOT_SECURE_LIB__() {
        return __GOT_SECURE_LIB__;
    }
    private static final int _MAX_ITOSTR_BASE16_COUNT = (int)9L;
    /**
     * {@snippet lang=c :
     * #define _MAX_ITOSTR_BASE16_COUNT 9
     * }
     */
    public static int _MAX_ITOSTR_BASE16_COUNT() {
        return _MAX_ITOSTR_BASE16_COUNT;
    }
    private static final int _MAX_ITOSTR_BASE10_COUNT = (int)12L;
    /**
     * {@snippet lang=c :
     * #define _MAX_ITOSTR_BASE10_COUNT 12
     * }
     */
    public static int _MAX_ITOSTR_BASE10_COUNT() {
        return _MAX_ITOSTR_BASE10_COUNT;
    }
    private static final int _MAX_ITOSTR_BASE8_COUNT = (int)12L;
    /**
     * {@snippet lang=c :
     * #define _MAX_ITOSTR_BASE8_COUNT 12
     * }
     */
    public static int _MAX_ITOSTR_BASE8_COUNT() {
        return _MAX_ITOSTR_BASE8_COUNT;
    }
    private static final int _MAX_ITOSTR_BASE2_COUNT = (int)33L;
    /**
     * {@snippet lang=c :
     * #define _MAX_ITOSTR_BASE2_COUNT 33
     * }
     */
    public static int _MAX_ITOSTR_BASE2_COUNT() {
        return _MAX_ITOSTR_BASE2_COUNT;
    }
    private static final int _MAX_LTOSTR_BASE16_COUNT = (int)9L;
    /**
     * {@snippet lang=c :
     * #define _MAX_LTOSTR_BASE16_COUNT 9
     * }
     */
    public static int _MAX_LTOSTR_BASE16_COUNT() {
        return _MAX_LTOSTR_BASE16_COUNT;
    }
    private static final int _MAX_LTOSTR_BASE10_COUNT = (int)12L;
    /**
     * {@snippet lang=c :
     * #define _MAX_LTOSTR_BASE10_COUNT 12
     * }
     */
    public static int _MAX_LTOSTR_BASE10_COUNT() {
        return _MAX_LTOSTR_BASE10_COUNT;
    }
    private static final int _MAX_LTOSTR_BASE8_COUNT = (int)12L;
    /**
     * {@snippet lang=c :
     * #define _MAX_LTOSTR_BASE8_COUNT 12
     * }
     */
    public static int _MAX_LTOSTR_BASE8_COUNT() {
        return _MAX_LTOSTR_BASE8_COUNT;
    }
    private static final int _MAX_LTOSTR_BASE2_COUNT = (int)33L;
    /**
     * {@snippet lang=c :
     * #define _MAX_LTOSTR_BASE2_COUNT 33
     * }
     */
    public static int _MAX_LTOSTR_BASE2_COUNT() {
        return _MAX_LTOSTR_BASE2_COUNT;
    }
    private static final int _MAX_ULTOSTR_BASE16_COUNT = (int)9L;
    /**
     * {@snippet lang=c :
     * #define _MAX_ULTOSTR_BASE16_COUNT 9
     * }
     */
    public static int _MAX_ULTOSTR_BASE16_COUNT() {
        return _MAX_ULTOSTR_BASE16_COUNT;
    }
    private static final int _MAX_ULTOSTR_BASE10_COUNT = (int)11L;
    /**
     * {@snippet lang=c :
     * #define _MAX_ULTOSTR_BASE10_COUNT 11
     * }
     */
    public static int _MAX_ULTOSTR_BASE10_COUNT() {
        return _MAX_ULTOSTR_BASE10_COUNT;
    }
    private static final int _MAX_ULTOSTR_BASE8_COUNT = (int)12L;
    /**
     * {@snippet lang=c :
     * #define _MAX_ULTOSTR_BASE8_COUNT 12
     * }
     */
    public static int _MAX_ULTOSTR_BASE8_COUNT() {
        return _MAX_ULTOSTR_BASE8_COUNT;
    }
    private static final int _MAX_ULTOSTR_BASE2_COUNT = (int)33L;
    /**
     * {@snippet lang=c :
     * #define _MAX_ULTOSTR_BASE2_COUNT 33
     * }
     */
    public static int _MAX_ULTOSTR_BASE2_COUNT() {
        return _MAX_ULTOSTR_BASE2_COUNT;
    }
    private static final int _MAX_I64TOSTR_BASE16_COUNT = (int)17L;
    /**
     * {@snippet lang=c :
     * #define _MAX_I64TOSTR_BASE16_COUNT 17
     * }
     */
    public static int _MAX_I64TOSTR_BASE16_COUNT() {
        return _MAX_I64TOSTR_BASE16_COUNT;
    }
    private static final int _MAX_I64TOSTR_BASE10_COUNT = (int)21L;
    /**
     * {@snippet lang=c :
     * #define _MAX_I64TOSTR_BASE10_COUNT 21
     * }
     */
    public static int _MAX_I64TOSTR_BASE10_COUNT() {
        return _MAX_I64TOSTR_BASE10_COUNT;
    }
    private static final int _MAX_I64TOSTR_BASE8_COUNT = (int)23L;
    /**
     * {@snippet lang=c :
     * #define _MAX_I64TOSTR_BASE8_COUNT 23
     * }
     */
    public static int _MAX_I64TOSTR_BASE8_COUNT() {
        return _MAX_I64TOSTR_BASE8_COUNT;
    }
    private static final int _MAX_I64TOSTR_BASE2_COUNT = (int)65L;
    /**
     * {@snippet lang=c :
     * #define _MAX_I64TOSTR_BASE2_COUNT 65
     * }
     */
    public static int _MAX_I64TOSTR_BASE2_COUNT() {
        return _MAX_I64TOSTR_BASE2_COUNT;
    }
    private static final int _MAX_U64TOSTR_BASE16_COUNT = (int)17L;
    /**
     * {@snippet lang=c :
     * #define _MAX_U64TOSTR_BASE16_COUNT 17
     * }
     */
    public static int _MAX_U64TOSTR_BASE16_COUNT() {
        return _MAX_U64TOSTR_BASE16_COUNT;
    }
    private static final int _MAX_U64TOSTR_BASE10_COUNT = (int)21L;
    /**
     * {@snippet lang=c :
     * #define _MAX_U64TOSTR_BASE10_COUNT 21
     * }
     */
    public static int _MAX_U64TOSTR_BASE10_COUNT() {
        return _MAX_U64TOSTR_BASE10_COUNT;
    }
    private static final int _MAX_U64TOSTR_BASE8_COUNT = (int)23L;
    /**
     * {@snippet lang=c :
     * #define _MAX_U64TOSTR_BASE8_COUNT 23
     * }
     */
    public static int _MAX_U64TOSTR_BASE8_COUNT() {
        return _MAX_U64TOSTR_BASE8_COUNT;
    }
    private static final int _MAX_U64TOSTR_BASE2_COUNT = (int)65L;
    /**
     * {@snippet lang=c :
     * #define _MAX_U64TOSTR_BASE2_COUNT 65
     * }
     */
    public static int _MAX_U64TOSTR_BASE2_COUNT() {
        return _MAX_U64TOSTR_BASE2_COUNT;
    }
    private static final int SCHAR_MIN = (int)-128L;
    /**
     * {@snippet lang=c :
     * #define SCHAR_MIN -128
     * }
     */
    public static int SCHAR_MIN() {
        return SCHAR_MIN;
    }
    private static final int CHAR_MIN = (int)-128L;
    /**
     * {@snippet lang=c :
     * #define CHAR_MIN -128
     * }
     */
    public static int CHAR_MIN() {
        return CHAR_MIN;
    }
    private static final int CHAR_MAX = (int)127L;
    /**
     * {@snippet lang=c :
     * #define CHAR_MAX 127
     * }
     */
    public static int CHAR_MAX() {
        return CHAR_MAX;
    }
    private static final int SHRT_MIN = (int)-32768L;
    /**
     * {@snippet lang=c :
     * #define SHRT_MIN -32768
     * }
     */
    public static int SHRT_MIN() {
        return SHRT_MIN;
    }
    private static final int INT_MIN = (int)-2147483648L;
    /**
     * {@snippet lang=c :
     * #define INT_MIN -2147483648
     * }
     */
    public static int INT_MIN() {
        return INT_MIN;
    }
    private static final int UINT_MAX = (int)4294967295L;
    /**
     * {@snippet lang=c :
     * #define UINT_MAX 4294967295
     * }
     */
    public static int UINT_MAX() {
        return UINT_MAX;
    }
    private static final int LONG_MIN = (int)-2147483648L;
    /**
     * {@snippet lang=c :
     * #define LONG_MIN -2147483648
     * }
     */
    public static int LONG_MIN() {
        return LONG_MIN;
    }
    private static final int LONG_MAX = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * #define LONG_MAX 2147483647
     * }
     */
    public static int LONG_MAX() {
        return LONG_MAX;
    }
    private static final int ULONG_MAX = (int)4294967295L;
    /**
     * {@snippet lang=c :
     * #define ULONG_MAX 4294967295
     * }
     */
    public static int ULONG_MAX() {
        return ULONG_MAX;
    }
    private static final long LLONG_MAX = 9223372036854775807L;
    /**
     * {@snippet lang=c :
     * #define LLONG_MAX 9223372036854775807
     * }
     */
    public static long LLONG_MAX() {
        return LLONG_MAX;
    }
    private static final long LLONG_MIN = -9223372036854775808L;
    /**
     * {@snippet lang=c :
     * #define LLONG_MIN -9223372036854775808
     * }
     */
    public static long LLONG_MIN() {
        return LLONG_MIN;
    }
    private static final long ULLONG_MAX = -1L;
    /**
     * {@snippet lang=c :
     * #define ULLONG_MAX -1
     * }
     */
    public static long ULLONG_MAX() {
        return ULLONG_MAX;
    }
    private static final int _I8_MIN = (int)-128L;
    /**
     * {@snippet lang=c :
     * #define _I8_MIN -128
     * }
     */
    public static int _I8_MIN() {
        return _I8_MIN;
    }
    private static final byte _I8_MAX = (byte)127L;
    /**
     * {@snippet lang=c :
     * #define _I8_MAX 127
     * }
     */
    public static byte _I8_MAX() {
        return _I8_MAX;
    }
    private static final byte _UI8_MAX = (byte)255L;
    /**
     * {@snippet lang=c :
     * #define _UI8_MAX 255
     * }
     */
    public static byte _UI8_MAX() {
        return _UI8_MAX;
    }
    private static final int _I16_MIN = (int)-32768L;
    /**
     * {@snippet lang=c :
     * #define _I16_MIN -32768
     * }
     */
    public static int _I16_MIN() {
        return _I16_MIN;
    }
    private static final short _I16_MAX = (short)32767L;
    /**
     * {@snippet lang=c :
     * #define _I16_MAX 32767
     * }
     */
    public static short _I16_MAX() {
        return _I16_MAX;
    }
    private static final short _UI16_MAX = (short)65535L;
    /**
     * {@snippet lang=c :
     * #define _UI16_MAX 65535
     * }
     */
    public static short _UI16_MAX() {
        return _UI16_MAX;
    }
    private static final int _I32_MIN = (int)-2147483648L;
    /**
     * {@snippet lang=c :
     * #define _I32_MIN -2147483648
     * }
     */
    public static int _I32_MIN() {
        return _I32_MIN;
    }
    private static final int _I32_MAX = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * #define _I32_MAX 2147483647
     * }
     */
    public static int _I32_MAX() {
        return _I32_MAX;
    }
    private static final int _UI32_MAX = (int)4294967295L;
    /**
     * {@snippet lang=c :
     * #define _UI32_MAX 4294967295
     * }
     */
    public static int _UI32_MAX() {
        return _UI32_MAX;
    }
    private static final long _I64_MIN = -9223372036854775808L;
    /**
     * {@snippet lang=c :
     * #define _I64_MIN -9223372036854775808
     * }
     */
    public static long _I64_MIN() {
        return _I64_MIN;
    }
    private static final long _I64_MAX = 9223372036854775807L;
    /**
     * {@snippet lang=c :
     * #define _I64_MAX 9223372036854775807
     * }
     */
    public static long _I64_MAX() {
        return _I64_MAX;
    }
    private static final long _UI64_MAX = -1L;
    /**
     * {@snippet lang=c :
     * #define _UI64_MAX -1
     * }
     */
    public static long _UI64_MAX() {
        return _UI64_MAX;
    }
    private static final long RSIZE_MAX = 9223372036854775807L;
    /**
     * {@snippet lang=c :
     * #define RSIZE_MAX 9223372036854775807
     * }
     */
    public static long RSIZE_MAX() {
        return RSIZE_MAX;
    }
    private static final long LONG_LONG_MAX = 9223372036854775807L;
    /**
     * {@snippet lang=c :
     * #define LONG_LONG_MAX 9223372036854775807
     * }
     */
    public static long LONG_LONG_MAX() {
        return LONG_LONG_MAX;
    }
    private static final long LONG_LONG_MIN = -9223372036854775808L;
    /**
     * {@snippet lang=c :
     * #define LONG_LONG_MIN -9223372036854775808
     * }
     */
    public static long LONG_LONG_MIN() {
        return LONG_LONG_MIN;
    }
    private static final long ULONG_LONG_MAX = -1L;
    /**
     * {@snippet lang=c :
     * #define ULONG_LONG_MAX -1
     * }
     */
    public static long ULONG_LONG_MAX() {
        return ULONG_LONG_MAX;
    }
    private static final int _CVTBUFSIZE = (int)349L;
    /**
     * {@snippet lang=c :
     * #define _CVTBUFSIZE 349
     * }
     */
    public static int _CVTBUFSIZE() {
        return _CVTBUFSIZE;
    }
    private static final long _HEAP_MAXREQ = -32L;
    /**
     * {@snippet lang=c :
     * #define _HEAP_MAXREQ -32
     * }
     */
    public static long _HEAP_MAXREQ() {
        return _HEAP_MAXREQ;
    }
    private static final int _HEAPEMPTY = (int)-1L;
    /**
     * {@snippet lang=c :
     * #define _HEAPEMPTY -1
     * }
     */
    public static int _HEAPEMPTY() {
        return _HEAPEMPTY;
    }
    private static final int _HEAPOK = (int)-2L;
    /**
     * {@snippet lang=c :
     * #define _HEAPOK -2
     * }
     */
    public static int _HEAPOK() {
        return _HEAPOK;
    }
    private static final int _HEAPBADBEGIN = (int)-3L;
    /**
     * {@snippet lang=c :
     * #define _HEAPBADBEGIN -3
     * }
     */
    public static int _HEAPBADBEGIN() {
        return _HEAPBADBEGIN;
    }
    private static final int _HEAPBADNODE = (int)-4L;
    /**
     * {@snippet lang=c :
     * #define _HEAPBADNODE -4
     * }
     */
    public static int _HEAPBADNODE() {
        return _HEAPBADNODE;
    }
    private static final int _HEAPEND = (int)-5L;
    /**
     * {@snippet lang=c :
     * #define _HEAPEND -5
     * }
     */
    public static int _HEAPEND() {
        return _HEAPEND;
    }
    private static final int _HEAPBADPTR = (int)-6L;
    /**
     * {@snippet lang=c :
     * #define _HEAPBADPTR -6
     * }
     */
    public static int _HEAPBADPTR() {
        return _HEAPBADPTR;
    }
    private static final int _MM_EXCEPT_INVALID = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _MM_EXCEPT_INVALID 1
     * }
     */
    public static int _MM_EXCEPT_INVALID() {
        return _MM_EXCEPT_INVALID;
    }
    private static final int _MM_EXCEPT_DENORM = (int)2L;
    /**
     * {@snippet lang=c :
     * #define _MM_EXCEPT_DENORM 2
     * }
     */
    public static int _MM_EXCEPT_DENORM() {
        return _MM_EXCEPT_DENORM;
    }
    private static final int _MM_EXCEPT_DIV_ZERO = (int)4L;
    /**
     * {@snippet lang=c :
     * #define _MM_EXCEPT_DIV_ZERO 4
     * }
     */
    public static int _MM_EXCEPT_DIV_ZERO() {
        return _MM_EXCEPT_DIV_ZERO;
    }
    private static final int _MM_EXCEPT_OVERFLOW = (int)8L;
    /**
     * {@snippet lang=c :
     * #define _MM_EXCEPT_OVERFLOW 8
     * }
     */
    public static int _MM_EXCEPT_OVERFLOW() {
        return _MM_EXCEPT_OVERFLOW;
    }
    private static final int _MM_EXCEPT_UNDERFLOW = (int)16L;
    /**
     * {@snippet lang=c :
     * #define _MM_EXCEPT_UNDERFLOW 16
     * }
     */
    public static int _MM_EXCEPT_UNDERFLOW() {
        return _MM_EXCEPT_UNDERFLOW;
    }
    private static final int _MM_EXCEPT_INEXACT = (int)32L;
    /**
     * {@snippet lang=c :
     * #define _MM_EXCEPT_INEXACT 32
     * }
     */
    public static int _MM_EXCEPT_INEXACT() {
        return _MM_EXCEPT_INEXACT;
    }
    private static final int _MM_EXCEPT_MASK = (int)63L;
    /**
     * {@snippet lang=c :
     * #define _MM_EXCEPT_MASK 63
     * }
     */
    public static int _MM_EXCEPT_MASK() {
        return _MM_EXCEPT_MASK;
    }
    private static final int _MM_MASK_INVALID = (int)128L;
    /**
     * {@snippet lang=c :
     * #define _MM_MASK_INVALID 128
     * }
     */
    public static int _MM_MASK_INVALID() {
        return _MM_MASK_INVALID;
    }
    private static final int _MM_MASK_DENORM = (int)256L;
    /**
     * {@snippet lang=c :
     * #define _MM_MASK_DENORM 256
     * }
     */
    public static int _MM_MASK_DENORM() {
        return _MM_MASK_DENORM;
    }
    private static final int _MM_MASK_DIV_ZERO = (int)512L;
    /**
     * {@snippet lang=c :
     * #define _MM_MASK_DIV_ZERO 512
     * }
     */
    public static int _MM_MASK_DIV_ZERO() {
        return _MM_MASK_DIV_ZERO;
    }
    private static final int _MM_MASK_OVERFLOW = (int)1024L;
    /**
     * {@snippet lang=c :
     * #define _MM_MASK_OVERFLOW 1024
     * }
     */
    public static int _MM_MASK_OVERFLOW() {
        return _MM_MASK_OVERFLOW;
    }
    private static final int _MM_MASK_UNDERFLOW = (int)2048L;
    /**
     * {@snippet lang=c :
     * #define _MM_MASK_UNDERFLOW 2048
     * }
     */
    public static int _MM_MASK_UNDERFLOW() {
        return _MM_MASK_UNDERFLOW;
    }
    private static final int _MM_MASK_INEXACT = (int)4096L;
    /**
     * {@snippet lang=c :
     * #define _MM_MASK_INEXACT 4096
     * }
     */
    public static int _MM_MASK_INEXACT() {
        return _MM_MASK_INEXACT;
    }
    private static final int _MM_MASK_MASK = (int)8064L;
    /**
     * {@snippet lang=c :
     * #define _MM_MASK_MASK 8064
     * }
     */
    public static int _MM_MASK_MASK() {
        return _MM_MASK_MASK;
    }
    private static final int _MM_ROUND_NEAREST = (int)0L;
    /**
     * {@snippet lang=c :
     * #define _MM_ROUND_NEAREST 0
     * }
     */
    public static int _MM_ROUND_NEAREST() {
        return _MM_ROUND_NEAREST;
    }
    private static final int _MM_ROUND_DOWN = (int)8192L;
    /**
     * {@snippet lang=c :
     * #define _MM_ROUND_DOWN 8192
     * }
     */
    public static int _MM_ROUND_DOWN() {
        return _MM_ROUND_DOWN;
    }
    private static final int _MM_ROUND_UP = (int)16384L;
    /**
     * {@snippet lang=c :
     * #define _MM_ROUND_UP 16384
     * }
     */
    public static int _MM_ROUND_UP() {
        return _MM_ROUND_UP;
    }
    private static final int _MM_ROUND_TOWARD_ZERO = (int)24576L;
    /**
     * {@snippet lang=c :
     * #define _MM_ROUND_TOWARD_ZERO 24576
     * }
     */
    public static int _MM_ROUND_TOWARD_ZERO() {
        return _MM_ROUND_TOWARD_ZERO;
    }
    private static final int _MM_ROUND_MASK = (int)24576L;
    /**
     * {@snippet lang=c :
     * #define _MM_ROUND_MASK 24576
     * }
     */
    public static int _MM_ROUND_MASK() {
        return _MM_ROUND_MASK;
    }
    private static final int _MM_FLUSH_ZERO_MASK = (int)32768L;
    /**
     * {@snippet lang=c :
     * #define _MM_FLUSH_ZERO_MASK 32768
     * }
     */
    public static int _MM_FLUSH_ZERO_MASK() {
        return _MM_FLUSH_ZERO_MASK;
    }
    private static final int _MM_FLUSH_ZERO_ON = (int)32768L;
    /**
     * {@snippet lang=c :
     * #define _MM_FLUSH_ZERO_ON 32768
     * }
     */
    public static int _MM_FLUSH_ZERO_ON() {
        return _MM_FLUSH_ZERO_ON;
    }
    private static final int _MM_FLUSH_ZERO_OFF = (int)0L;
    /**
     * {@snippet lang=c :
     * #define _MM_FLUSH_ZERO_OFF 0
     * }
     */
    public static int _MM_FLUSH_ZERO_OFF() {
        return _MM_FLUSH_ZERO_OFF;
    }
    private static final int _MM_DENORMALS_ZERO_ON = (int)64L;
    /**
     * {@snippet lang=c :
     * #define _MM_DENORMALS_ZERO_ON 64
     * }
     */
    public static int _MM_DENORMALS_ZERO_ON() {
        return _MM_DENORMALS_ZERO_ON;
    }
    private static final int _MM_DENORMALS_ZERO_OFF = (int)0L;
    /**
     * {@snippet lang=c :
     * #define _MM_DENORMALS_ZERO_OFF 0
     * }
     */
    public static int _MM_DENORMALS_ZERO_OFF() {
        return _MM_DENORMALS_ZERO_OFF;
    }
    private static final int _MM_DENORMALS_ZERO_MASK = (int)64L;
    /**
     * {@snippet lang=c :
     * #define _MM_DENORMALS_ZERO_MASK 64
     * }
     */
    public static int _MM_DENORMALS_ZERO_MASK() {
        return _MM_DENORMALS_ZERO_MASK;
    }
    /**
     * {@snippet lang=c :
     * #define CL_PROGRAM_STRING_DEBUG_INFO "#line 668 "C:\Users\terut\AppData\Local\Temp\jextract$12990948806193480910.h" 
     * 
     * "
     * }
     */
    public static MemorySegment CL_PROGRAM_STRING_DEBUG_INFO() {
        class Holder {
            static final MemorySegment CL_PROGRAM_STRING_DEBUG_INFO
                = LIBRARY_ARENA.allocateFrom("#line 668 \"C:\\Users\\terut\\AppData\\Local\\Temp\\jextract$12990948806193480910.h\" \n\n");
        }
        return Holder.CL_PROGRAM_STRING_DEBUG_INFO;
    }
    private static final int CL_DEVICE_NOT_FOUND = (int)-1L;
    /**
     * {@snippet lang=c :
     * #define CL_DEVICE_NOT_FOUND -1
     * }
     */
    public static int CL_DEVICE_NOT_FOUND() {
        return CL_DEVICE_NOT_FOUND;
    }
    private static final int CL_DEVICE_NOT_AVAILABLE = (int)-2L;
    /**
     * {@snippet lang=c :
     * #define CL_DEVICE_NOT_AVAILABLE -2
     * }
     */
    public static int CL_DEVICE_NOT_AVAILABLE() {
        return CL_DEVICE_NOT_AVAILABLE;
    }
    private static final int CL_COMPILER_NOT_AVAILABLE = (int)-3L;
    /**
     * {@snippet lang=c :
     * #define CL_COMPILER_NOT_AVAILABLE -3
     * }
     */
    public static int CL_COMPILER_NOT_AVAILABLE() {
        return CL_COMPILER_NOT_AVAILABLE;
    }
    private static final int CL_MEM_OBJECT_ALLOCATION_FAILURE = (int)-4L;
    /**
     * {@snippet lang=c :
     * #define CL_MEM_OBJECT_ALLOCATION_FAILURE -4
     * }
     */
    public static int CL_MEM_OBJECT_ALLOCATION_FAILURE() {
        return CL_MEM_OBJECT_ALLOCATION_FAILURE;
    }
    private static final int CL_OUT_OF_RESOURCES = (int)-5L;
    /**
     * {@snippet lang=c :
     * #define CL_OUT_OF_RESOURCES -5
     * }
     */
    public static int CL_OUT_OF_RESOURCES() {
        return CL_OUT_OF_RESOURCES;
    }
    private static final int CL_OUT_OF_HOST_MEMORY = (int)-6L;
    /**
     * {@snippet lang=c :
     * #define CL_OUT_OF_HOST_MEMORY -6
     * }
     */
    public static int CL_OUT_OF_HOST_MEMORY() {
        return CL_OUT_OF_HOST_MEMORY;
    }
    private static final int CL_PROFILING_INFO_NOT_AVAILABLE = (int)-7L;
    /**
     * {@snippet lang=c :
     * #define CL_PROFILING_INFO_NOT_AVAILABLE -7
     * }
     */
    public static int CL_PROFILING_INFO_NOT_AVAILABLE() {
        return CL_PROFILING_INFO_NOT_AVAILABLE;
    }
    private static final int CL_MEM_COPY_OVERLAP = (int)-8L;
    /**
     * {@snippet lang=c :
     * #define CL_MEM_COPY_OVERLAP -8
     * }
     */
    public static int CL_MEM_COPY_OVERLAP() {
        return CL_MEM_COPY_OVERLAP;
    }
    private static final int CL_IMAGE_FORMAT_MISMATCH = (int)-9L;
    /**
     * {@snippet lang=c :
     * #define CL_IMAGE_FORMAT_MISMATCH -9
     * }
     */
    public static int CL_IMAGE_FORMAT_MISMATCH() {
        return CL_IMAGE_FORMAT_MISMATCH;
    }
    private static final int CL_IMAGE_FORMAT_NOT_SUPPORTED = (int)-10L;
    /**
     * {@snippet lang=c :
     * #define CL_IMAGE_FORMAT_NOT_SUPPORTED -10
     * }
     */
    public static int CL_IMAGE_FORMAT_NOT_SUPPORTED() {
        return CL_IMAGE_FORMAT_NOT_SUPPORTED;
    }
    private static final int CL_BUILD_PROGRAM_FAILURE = (int)-11L;
    /**
     * {@snippet lang=c :
     * #define CL_BUILD_PROGRAM_FAILURE -11
     * }
     */
    public static int CL_BUILD_PROGRAM_FAILURE() {
        return CL_BUILD_PROGRAM_FAILURE;
    }
    private static final int CL_MAP_FAILURE = (int)-12L;
    /**
     * {@snippet lang=c :
     * #define CL_MAP_FAILURE -12
     * }
     */
    public static int CL_MAP_FAILURE() {
        return CL_MAP_FAILURE;
    }
    private static final int CL_MISALIGNED_SUB_BUFFER_OFFSET = (int)-13L;
    /**
     * {@snippet lang=c :
     * #define CL_MISALIGNED_SUB_BUFFER_OFFSET -13
     * }
     */
    public static int CL_MISALIGNED_SUB_BUFFER_OFFSET() {
        return CL_MISALIGNED_SUB_BUFFER_OFFSET;
    }
    private static final int CL_EXEC_STATUS_ERROR_FOR_EVENTS_IN_WAIT_LIST = (int)-14L;
    /**
     * {@snippet lang=c :
     * #define CL_EXEC_STATUS_ERROR_FOR_EVENTS_IN_WAIT_LIST -14
     * }
     */
    public static int CL_EXEC_STATUS_ERROR_FOR_EVENTS_IN_WAIT_LIST() {
        return CL_EXEC_STATUS_ERROR_FOR_EVENTS_IN_WAIT_LIST;
    }
    private static final int CL_COMPILE_PROGRAM_FAILURE = (int)-15L;
    /**
     * {@snippet lang=c :
     * #define CL_COMPILE_PROGRAM_FAILURE -15
     * }
     */
    public static int CL_COMPILE_PROGRAM_FAILURE() {
        return CL_COMPILE_PROGRAM_FAILURE;
    }
    private static final int CL_LINKER_NOT_AVAILABLE = (int)-16L;
    /**
     * {@snippet lang=c :
     * #define CL_LINKER_NOT_AVAILABLE -16
     * }
     */
    public static int CL_LINKER_NOT_AVAILABLE() {
        return CL_LINKER_NOT_AVAILABLE;
    }
    private static final int CL_LINK_PROGRAM_FAILURE = (int)-17L;
    /**
     * {@snippet lang=c :
     * #define CL_LINK_PROGRAM_FAILURE -17
     * }
     */
    public static int CL_LINK_PROGRAM_FAILURE() {
        return CL_LINK_PROGRAM_FAILURE;
    }
    private static final int CL_DEVICE_PARTITION_FAILED = (int)-18L;
    /**
     * {@snippet lang=c :
     * #define CL_DEVICE_PARTITION_FAILED -18
     * }
     */
    public static int CL_DEVICE_PARTITION_FAILED() {
        return CL_DEVICE_PARTITION_FAILED;
    }
    private static final int CL_KERNEL_ARG_INFO_NOT_AVAILABLE = (int)-19L;
    /**
     * {@snippet lang=c :
     * #define CL_KERNEL_ARG_INFO_NOT_AVAILABLE -19
     * }
     */
    public static int CL_KERNEL_ARG_INFO_NOT_AVAILABLE() {
        return CL_KERNEL_ARG_INFO_NOT_AVAILABLE;
    }
    private static final int CL_INVALID_VALUE = (int)-30L;
    /**
     * {@snippet lang=c :
     * #define CL_INVALID_VALUE -30
     * }
     */
    public static int CL_INVALID_VALUE() {
        return CL_INVALID_VALUE;
    }
    private static final int CL_INVALID_DEVICE_TYPE = (int)-31L;
    /**
     * {@snippet lang=c :
     * #define CL_INVALID_DEVICE_TYPE -31
     * }
     */
    public static int CL_INVALID_DEVICE_TYPE() {
        return CL_INVALID_DEVICE_TYPE;
    }
    private static final int CL_INVALID_PLATFORM = (int)-32L;
    /**
     * {@snippet lang=c :
     * #define CL_INVALID_PLATFORM -32
     * }
     */
    public static int CL_INVALID_PLATFORM() {
        return CL_INVALID_PLATFORM;
    }
    private static final int CL_INVALID_DEVICE = (int)-33L;
    /**
     * {@snippet lang=c :
     * #define CL_INVALID_DEVICE -33
     * }
     */
    public static int CL_INVALID_DEVICE() {
        return CL_INVALID_DEVICE;
    }
    private static final int CL_INVALID_CONTEXT = (int)-34L;
    /**
     * {@snippet lang=c :
     * #define CL_INVALID_CONTEXT -34
     * }
     */
    public static int CL_INVALID_CONTEXT() {
        return CL_INVALID_CONTEXT;
    }
    private static final int CL_INVALID_QUEUE_PROPERTIES = (int)-35L;
    /**
     * {@snippet lang=c :
     * #define CL_INVALID_QUEUE_PROPERTIES -35
     * }
     */
    public static int CL_INVALID_QUEUE_PROPERTIES() {
        return CL_INVALID_QUEUE_PROPERTIES;
    }
    private static final int CL_INVALID_COMMAND_QUEUE = (int)-36L;
    /**
     * {@snippet lang=c :
     * #define CL_INVALID_COMMAND_QUEUE -36
     * }
     */
    public static int CL_INVALID_COMMAND_QUEUE() {
        return CL_INVALID_COMMAND_QUEUE;
    }
    private static final int CL_INVALID_HOST_PTR = (int)-37L;
    /**
     * {@snippet lang=c :
     * #define CL_INVALID_HOST_PTR -37
     * }
     */
    public static int CL_INVALID_HOST_PTR() {
        return CL_INVALID_HOST_PTR;
    }
    private static final int CL_INVALID_MEM_OBJECT = (int)-38L;
    /**
     * {@snippet lang=c :
     * #define CL_INVALID_MEM_OBJECT -38
     * }
     */
    public static int CL_INVALID_MEM_OBJECT() {
        return CL_INVALID_MEM_OBJECT;
    }
    private static final int CL_INVALID_IMAGE_FORMAT_DESCRIPTOR = (int)-39L;
    /**
     * {@snippet lang=c :
     * #define CL_INVALID_IMAGE_FORMAT_DESCRIPTOR -39
     * }
     */
    public static int CL_INVALID_IMAGE_FORMAT_DESCRIPTOR() {
        return CL_INVALID_IMAGE_FORMAT_DESCRIPTOR;
    }
    private static final int CL_INVALID_IMAGE_SIZE = (int)-40L;
    /**
     * {@snippet lang=c :
     * #define CL_INVALID_IMAGE_SIZE -40
     * }
     */
    public static int CL_INVALID_IMAGE_SIZE() {
        return CL_INVALID_IMAGE_SIZE;
    }
    private static final int CL_INVALID_SAMPLER = (int)-41L;
    /**
     * {@snippet lang=c :
     * #define CL_INVALID_SAMPLER -41
     * }
     */
    public static int CL_INVALID_SAMPLER() {
        return CL_INVALID_SAMPLER;
    }
    private static final int CL_INVALID_BINARY = (int)-42L;
    /**
     * {@snippet lang=c :
     * #define CL_INVALID_BINARY -42
     * }
     */
    public static int CL_INVALID_BINARY() {
        return CL_INVALID_BINARY;
    }
    private static final int CL_INVALID_BUILD_OPTIONS = (int)-43L;
    /**
     * {@snippet lang=c :
     * #define CL_INVALID_BUILD_OPTIONS -43
     * }
     */
    public static int CL_INVALID_BUILD_OPTIONS() {
        return CL_INVALID_BUILD_OPTIONS;
    }
    private static final int CL_INVALID_PROGRAM = (int)-44L;
    /**
     * {@snippet lang=c :
     * #define CL_INVALID_PROGRAM -44
     * }
     */
    public static int CL_INVALID_PROGRAM() {
        return CL_INVALID_PROGRAM;
    }
    private static final int CL_INVALID_PROGRAM_EXECUTABLE = (int)-45L;
    /**
     * {@snippet lang=c :
     * #define CL_INVALID_PROGRAM_EXECUTABLE -45
     * }
     */
    public static int CL_INVALID_PROGRAM_EXECUTABLE() {
        return CL_INVALID_PROGRAM_EXECUTABLE;
    }
    private static final int CL_INVALID_KERNEL_NAME = (int)-46L;
    /**
     * {@snippet lang=c :
     * #define CL_INVALID_KERNEL_NAME -46
     * }
     */
    public static int CL_INVALID_KERNEL_NAME() {
        return CL_INVALID_KERNEL_NAME;
    }
    private static final int CL_INVALID_KERNEL_DEFINITION = (int)-47L;
    /**
     * {@snippet lang=c :
     * #define CL_INVALID_KERNEL_DEFINITION -47
     * }
     */
    public static int CL_INVALID_KERNEL_DEFINITION() {
        return CL_INVALID_KERNEL_DEFINITION;
    }
    private static final int CL_INVALID_KERNEL = (int)-48L;
    /**
     * {@snippet lang=c :
     * #define CL_INVALID_KERNEL -48
     * }
     */
    public static int CL_INVALID_KERNEL() {
        return CL_INVALID_KERNEL;
    }
    private static final int CL_INVALID_ARG_INDEX = (int)-49L;
    /**
     * {@snippet lang=c :
     * #define CL_INVALID_ARG_INDEX -49
     * }
     */
    public static int CL_INVALID_ARG_INDEX() {
        return CL_INVALID_ARG_INDEX;
    }
    private static final int CL_INVALID_ARG_VALUE = (int)-50L;
    /**
     * {@snippet lang=c :
     * #define CL_INVALID_ARG_VALUE -50
     * }
     */
    public static int CL_INVALID_ARG_VALUE() {
        return CL_INVALID_ARG_VALUE;
    }
    private static final int CL_INVALID_ARG_SIZE = (int)-51L;
    /**
     * {@snippet lang=c :
     * #define CL_INVALID_ARG_SIZE -51
     * }
     */
    public static int CL_INVALID_ARG_SIZE() {
        return CL_INVALID_ARG_SIZE;
    }
    private static final int CL_INVALID_KERNEL_ARGS = (int)-52L;
    /**
     * {@snippet lang=c :
     * #define CL_INVALID_KERNEL_ARGS -52
     * }
     */
    public static int CL_INVALID_KERNEL_ARGS() {
        return CL_INVALID_KERNEL_ARGS;
    }
    private static final int CL_INVALID_WORK_DIMENSION = (int)-53L;
    /**
     * {@snippet lang=c :
     * #define CL_INVALID_WORK_DIMENSION -53
     * }
     */
    public static int CL_INVALID_WORK_DIMENSION() {
        return CL_INVALID_WORK_DIMENSION;
    }
    private static final int CL_INVALID_WORK_GROUP_SIZE = (int)-54L;
    /**
     * {@snippet lang=c :
     * #define CL_INVALID_WORK_GROUP_SIZE -54
     * }
     */
    public static int CL_INVALID_WORK_GROUP_SIZE() {
        return CL_INVALID_WORK_GROUP_SIZE;
    }
    private static final int CL_INVALID_WORK_ITEM_SIZE = (int)-55L;
    /**
     * {@snippet lang=c :
     * #define CL_INVALID_WORK_ITEM_SIZE -55
     * }
     */
    public static int CL_INVALID_WORK_ITEM_SIZE() {
        return CL_INVALID_WORK_ITEM_SIZE;
    }
    private static final int CL_INVALID_GLOBAL_OFFSET = (int)-56L;
    /**
     * {@snippet lang=c :
     * #define CL_INVALID_GLOBAL_OFFSET -56
     * }
     */
    public static int CL_INVALID_GLOBAL_OFFSET() {
        return CL_INVALID_GLOBAL_OFFSET;
    }
    private static final int CL_INVALID_EVENT_WAIT_LIST = (int)-57L;
    /**
     * {@snippet lang=c :
     * #define CL_INVALID_EVENT_WAIT_LIST -57
     * }
     */
    public static int CL_INVALID_EVENT_WAIT_LIST() {
        return CL_INVALID_EVENT_WAIT_LIST;
    }
    private static final int CL_INVALID_EVENT = (int)-58L;
    /**
     * {@snippet lang=c :
     * #define CL_INVALID_EVENT -58
     * }
     */
    public static int CL_INVALID_EVENT() {
        return CL_INVALID_EVENT;
    }
    private static final int CL_INVALID_OPERATION = (int)-59L;
    /**
     * {@snippet lang=c :
     * #define CL_INVALID_OPERATION -59
     * }
     */
    public static int CL_INVALID_OPERATION() {
        return CL_INVALID_OPERATION;
    }
    private static final int CL_INVALID_GL_OBJECT = (int)-60L;
    /**
     * {@snippet lang=c :
     * #define CL_INVALID_GL_OBJECT -60
     * }
     */
    public static int CL_INVALID_GL_OBJECT() {
        return CL_INVALID_GL_OBJECT;
    }
    private static final int CL_INVALID_BUFFER_SIZE = (int)-61L;
    /**
     * {@snippet lang=c :
     * #define CL_INVALID_BUFFER_SIZE -61
     * }
     */
    public static int CL_INVALID_BUFFER_SIZE() {
        return CL_INVALID_BUFFER_SIZE;
    }
    private static final int CL_INVALID_MIP_LEVEL = (int)-62L;
    /**
     * {@snippet lang=c :
     * #define CL_INVALID_MIP_LEVEL -62
     * }
     */
    public static int CL_INVALID_MIP_LEVEL() {
        return CL_INVALID_MIP_LEVEL;
    }
    private static final int CL_INVALID_GLOBAL_WORK_SIZE = (int)-63L;
    /**
     * {@snippet lang=c :
     * #define CL_INVALID_GLOBAL_WORK_SIZE -63
     * }
     */
    public static int CL_INVALID_GLOBAL_WORK_SIZE() {
        return CL_INVALID_GLOBAL_WORK_SIZE;
    }
    private static final int CL_INVALID_PROPERTY = (int)-64L;
    /**
     * {@snippet lang=c :
     * #define CL_INVALID_PROPERTY -64
     * }
     */
    public static int CL_INVALID_PROPERTY() {
        return CL_INVALID_PROPERTY;
    }
    private static final int CL_INVALID_IMAGE_DESCRIPTOR = (int)-65L;
    /**
     * {@snippet lang=c :
     * #define CL_INVALID_IMAGE_DESCRIPTOR -65
     * }
     */
    public static int CL_INVALID_IMAGE_DESCRIPTOR() {
        return CL_INVALID_IMAGE_DESCRIPTOR;
    }
    private static final int CL_INVALID_COMPILER_OPTIONS = (int)-66L;
    /**
     * {@snippet lang=c :
     * #define CL_INVALID_COMPILER_OPTIONS -66
     * }
     */
    public static int CL_INVALID_COMPILER_OPTIONS() {
        return CL_INVALID_COMPILER_OPTIONS;
    }
    private static final int CL_INVALID_LINKER_OPTIONS = (int)-67L;
    /**
     * {@snippet lang=c :
     * #define CL_INVALID_LINKER_OPTIONS -67
     * }
     */
    public static int CL_INVALID_LINKER_OPTIONS() {
        return CL_INVALID_LINKER_OPTIONS;
    }
    private static final int CL_INVALID_DEVICE_PARTITION_COUNT = (int)-68L;
    /**
     * {@snippet lang=c :
     * #define CL_INVALID_DEVICE_PARTITION_COUNT -68
     * }
     */
    public static int CL_INVALID_DEVICE_PARTITION_COUNT() {
        return CL_INVALID_DEVICE_PARTITION_COUNT;
    }
    private static final int CL_INVALID_PIPE_SIZE = (int)-69L;
    /**
     * {@snippet lang=c :
     * #define CL_INVALID_PIPE_SIZE -69
     * }
     */
    public static int CL_INVALID_PIPE_SIZE() {
        return CL_INVALID_PIPE_SIZE;
    }
    private static final int CL_INVALID_DEVICE_QUEUE = (int)-70L;
    /**
     * {@snippet lang=c :
     * #define CL_INVALID_DEVICE_QUEUE -70
     * }
     */
    public static int CL_INVALID_DEVICE_QUEUE() {
        return CL_INVALID_DEVICE_QUEUE;
    }
    private static final int CL_INVALID_SPEC_ID = (int)-71L;
    /**
     * {@snippet lang=c :
     * #define CL_INVALID_SPEC_ID -71
     * }
     */
    public static int CL_INVALID_SPEC_ID() {
        return CL_INVALID_SPEC_ID;
    }
    private static final int CL_MAX_SIZE_RESTRICTION_EXCEEDED = (int)-72L;
    /**
     * {@snippet lang=c :
     * #define CL_MAX_SIZE_RESTRICTION_EXCEEDED -72
     * }
     */
    public static int CL_MAX_SIZE_RESTRICTION_EXCEEDED() {
        return CL_MAX_SIZE_RESTRICTION_EXCEEDED;
    }
    private static final int CL_BLOCKING = (int)1L;
    /**
     * {@snippet lang=c :
     * #define CL_BLOCKING 1
     * }
     */
    public static int CL_BLOCKING() {
        return CL_BLOCKING;
    }
    private static final int CL_NON_BLOCKING = (int)0L;
    /**
     * {@snippet lang=c :
     * #define CL_NON_BLOCKING 0
     * }
     */
    public static int CL_NON_BLOCKING() {
        return CL_NON_BLOCKING;
    }
    private static final int CL_DEVICE_TYPE_DEFAULT = (int)1L;
    /**
     * {@snippet lang=c :
     * #define CL_DEVICE_TYPE_DEFAULT 1
     * }
     */
    public static int CL_DEVICE_TYPE_DEFAULT() {
        return CL_DEVICE_TYPE_DEFAULT;
    }
    private static final int CL_DEVICE_TYPE_CPU = (int)2L;
    /**
     * {@snippet lang=c :
     * #define CL_DEVICE_TYPE_CPU 2
     * }
     */
    public static int CL_DEVICE_TYPE_CPU() {
        return CL_DEVICE_TYPE_CPU;
    }
    private static final int CL_DEVICE_TYPE_GPU = (int)4L;
    /**
     * {@snippet lang=c :
     * #define CL_DEVICE_TYPE_GPU 4
     * }
     */
    public static int CL_DEVICE_TYPE_GPU() {
        return CL_DEVICE_TYPE_GPU;
    }
    private static final int CL_DEVICE_TYPE_ACCELERATOR = (int)8L;
    /**
     * {@snippet lang=c :
     * #define CL_DEVICE_TYPE_ACCELERATOR 8
     * }
     */
    public static int CL_DEVICE_TYPE_ACCELERATOR() {
        return CL_DEVICE_TYPE_ACCELERATOR;
    }
    private static final int CL_DEVICE_TYPE_CUSTOM = (int)16L;
    /**
     * {@snippet lang=c :
     * #define CL_DEVICE_TYPE_CUSTOM 16
     * }
     */
    public static int CL_DEVICE_TYPE_CUSTOM() {
        return CL_DEVICE_TYPE_CUSTOM;
    }
    private static final int CL_DEVICE_TYPE_ALL = (int)4294967295L;
    /**
     * {@snippet lang=c :
     * #define CL_DEVICE_TYPE_ALL 4294967295
     * }
     */
    public static int CL_DEVICE_TYPE_ALL() {
        return CL_DEVICE_TYPE_ALL;
    }
    private static final int CL_FP_DENORM = (int)1L;
    /**
     * {@snippet lang=c :
     * #define CL_FP_DENORM 1
     * }
     */
    public static int CL_FP_DENORM() {
        return CL_FP_DENORM;
    }
    private static final int CL_FP_INF_NAN = (int)2L;
    /**
     * {@snippet lang=c :
     * #define CL_FP_INF_NAN 2
     * }
     */
    public static int CL_FP_INF_NAN() {
        return CL_FP_INF_NAN;
    }
    private static final int CL_FP_ROUND_TO_NEAREST = (int)4L;
    /**
     * {@snippet lang=c :
     * #define CL_FP_ROUND_TO_NEAREST 4
     * }
     */
    public static int CL_FP_ROUND_TO_NEAREST() {
        return CL_FP_ROUND_TO_NEAREST;
    }
    private static final int CL_FP_ROUND_TO_ZERO = (int)8L;
    /**
     * {@snippet lang=c :
     * #define CL_FP_ROUND_TO_ZERO 8
     * }
     */
    public static int CL_FP_ROUND_TO_ZERO() {
        return CL_FP_ROUND_TO_ZERO;
    }
    private static final int CL_FP_ROUND_TO_INF = (int)16L;
    /**
     * {@snippet lang=c :
     * #define CL_FP_ROUND_TO_INF 16
     * }
     */
    public static int CL_FP_ROUND_TO_INF() {
        return CL_FP_ROUND_TO_INF;
    }
    private static final int CL_FP_FMA = (int)32L;
    /**
     * {@snippet lang=c :
     * #define CL_FP_FMA 32
     * }
     */
    public static int CL_FP_FMA() {
        return CL_FP_FMA;
    }
    private static final int CL_FP_SOFT_FLOAT = (int)64L;
    /**
     * {@snippet lang=c :
     * #define CL_FP_SOFT_FLOAT 64
     * }
     */
    public static int CL_FP_SOFT_FLOAT() {
        return CL_FP_SOFT_FLOAT;
    }
    private static final int CL_FP_CORRECTLY_ROUNDED_DIVIDE_SQRT = (int)128L;
    /**
     * {@snippet lang=c :
     * #define CL_FP_CORRECTLY_ROUNDED_DIVIDE_SQRT 128
     * }
     */
    public static int CL_FP_CORRECTLY_ROUNDED_DIVIDE_SQRT() {
        return CL_FP_CORRECTLY_ROUNDED_DIVIDE_SQRT;
    }
    private static final int CL_EXEC_KERNEL = (int)1L;
    /**
     * {@snippet lang=c :
     * #define CL_EXEC_KERNEL 1
     * }
     */
    public static int CL_EXEC_KERNEL() {
        return CL_EXEC_KERNEL;
    }
    private static final int CL_EXEC_NATIVE_KERNEL = (int)2L;
    /**
     * {@snippet lang=c :
     * #define CL_EXEC_NATIVE_KERNEL 2
     * }
     */
    public static int CL_EXEC_NATIVE_KERNEL() {
        return CL_EXEC_NATIVE_KERNEL;
    }
    private static final int CL_QUEUE_OUT_OF_ORDER_EXEC_MODE_ENABLE = (int)1L;
    /**
     * {@snippet lang=c :
     * #define CL_QUEUE_OUT_OF_ORDER_EXEC_MODE_ENABLE 1
     * }
     */
    public static int CL_QUEUE_OUT_OF_ORDER_EXEC_MODE_ENABLE() {
        return CL_QUEUE_OUT_OF_ORDER_EXEC_MODE_ENABLE;
    }
    private static final int CL_QUEUE_PROFILING_ENABLE = (int)2L;
    /**
     * {@snippet lang=c :
     * #define CL_QUEUE_PROFILING_ENABLE 2
     * }
     */
    public static int CL_QUEUE_PROFILING_ENABLE() {
        return CL_QUEUE_PROFILING_ENABLE;
    }
    private static final int CL_QUEUE_ON_DEVICE = (int)4L;
    /**
     * {@snippet lang=c :
     * #define CL_QUEUE_ON_DEVICE 4
     * }
     */
    public static int CL_QUEUE_ON_DEVICE() {
        return CL_QUEUE_ON_DEVICE;
    }
    private static final int CL_QUEUE_ON_DEVICE_DEFAULT = (int)8L;
    /**
     * {@snippet lang=c :
     * #define CL_QUEUE_ON_DEVICE_DEFAULT 8
     * }
     */
    public static int CL_QUEUE_ON_DEVICE_DEFAULT() {
        return CL_QUEUE_ON_DEVICE_DEFAULT;
    }
    private static final int CL_DEVICE_AFFINITY_DOMAIN_NUMA = (int)1L;
    /**
     * {@snippet lang=c :
     * #define CL_DEVICE_AFFINITY_DOMAIN_NUMA 1
     * }
     */
    public static int CL_DEVICE_AFFINITY_DOMAIN_NUMA() {
        return CL_DEVICE_AFFINITY_DOMAIN_NUMA;
    }
    private static final int CL_DEVICE_AFFINITY_DOMAIN_L4_CACHE = (int)2L;
    /**
     * {@snippet lang=c :
     * #define CL_DEVICE_AFFINITY_DOMAIN_L4_CACHE 2
     * }
     */
    public static int CL_DEVICE_AFFINITY_DOMAIN_L4_CACHE() {
        return CL_DEVICE_AFFINITY_DOMAIN_L4_CACHE;
    }
    private static final int CL_DEVICE_AFFINITY_DOMAIN_L3_CACHE = (int)4L;
    /**
     * {@snippet lang=c :
     * #define CL_DEVICE_AFFINITY_DOMAIN_L3_CACHE 4
     * }
     */
    public static int CL_DEVICE_AFFINITY_DOMAIN_L3_CACHE() {
        return CL_DEVICE_AFFINITY_DOMAIN_L3_CACHE;
    }
    private static final int CL_DEVICE_AFFINITY_DOMAIN_L2_CACHE = (int)8L;
    /**
     * {@snippet lang=c :
     * #define CL_DEVICE_AFFINITY_DOMAIN_L2_CACHE 8
     * }
     */
    public static int CL_DEVICE_AFFINITY_DOMAIN_L2_CACHE() {
        return CL_DEVICE_AFFINITY_DOMAIN_L2_CACHE;
    }
    private static final int CL_DEVICE_AFFINITY_DOMAIN_L1_CACHE = (int)16L;
    /**
     * {@snippet lang=c :
     * #define CL_DEVICE_AFFINITY_DOMAIN_L1_CACHE 16
     * }
     */
    public static int CL_DEVICE_AFFINITY_DOMAIN_L1_CACHE() {
        return CL_DEVICE_AFFINITY_DOMAIN_L1_CACHE;
    }
    private static final int CL_DEVICE_AFFINITY_DOMAIN_NEXT_PARTITIONABLE = (int)32L;
    /**
     * {@snippet lang=c :
     * #define CL_DEVICE_AFFINITY_DOMAIN_NEXT_PARTITIONABLE 32
     * }
     */
    public static int CL_DEVICE_AFFINITY_DOMAIN_NEXT_PARTITIONABLE() {
        return CL_DEVICE_AFFINITY_DOMAIN_NEXT_PARTITIONABLE;
    }
    private static final int CL_DEVICE_SVM_COARSE_GRAIN_BUFFER = (int)1L;
    /**
     * {@snippet lang=c :
     * #define CL_DEVICE_SVM_COARSE_GRAIN_BUFFER 1
     * }
     */
    public static int CL_DEVICE_SVM_COARSE_GRAIN_BUFFER() {
        return CL_DEVICE_SVM_COARSE_GRAIN_BUFFER;
    }
    private static final int CL_DEVICE_SVM_FINE_GRAIN_BUFFER = (int)2L;
    /**
     * {@snippet lang=c :
     * #define CL_DEVICE_SVM_FINE_GRAIN_BUFFER 2
     * }
     */
    public static int CL_DEVICE_SVM_FINE_GRAIN_BUFFER() {
        return CL_DEVICE_SVM_FINE_GRAIN_BUFFER;
    }
    private static final int CL_DEVICE_SVM_FINE_GRAIN_SYSTEM = (int)4L;
    /**
     * {@snippet lang=c :
     * #define CL_DEVICE_SVM_FINE_GRAIN_SYSTEM 4
     * }
     */
    public static int CL_DEVICE_SVM_FINE_GRAIN_SYSTEM() {
        return CL_DEVICE_SVM_FINE_GRAIN_SYSTEM;
    }
    private static final int CL_DEVICE_SVM_ATOMICS = (int)8L;
    /**
     * {@snippet lang=c :
     * #define CL_DEVICE_SVM_ATOMICS 8
     * }
     */
    public static int CL_DEVICE_SVM_ATOMICS() {
        return CL_DEVICE_SVM_ATOMICS;
    }
    private static final int CL_MEM_READ_WRITE = (int)1L;
    /**
     * {@snippet lang=c :
     * #define CL_MEM_READ_WRITE 1
     * }
     */
    public static int CL_MEM_READ_WRITE() {
        return CL_MEM_READ_WRITE;
    }
    private static final int CL_MEM_WRITE_ONLY = (int)2L;
    /**
     * {@snippet lang=c :
     * #define CL_MEM_WRITE_ONLY 2
     * }
     */
    public static int CL_MEM_WRITE_ONLY() {
        return CL_MEM_WRITE_ONLY;
    }
    private static final int CL_MEM_READ_ONLY = (int)4L;
    /**
     * {@snippet lang=c :
     * #define CL_MEM_READ_ONLY 4
     * }
     */
    public static int CL_MEM_READ_ONLY() {
        return CL_MEM_READ_ONLY;
    }
    private static final int CL_MEM_USE_HOST_PTR = (int)8L;
    /**
     * {@snippet lang=c :
     * #define CL_MEM_USE_HOST_PTR 8
     * }
     */
    public static int CL_MEM_USE_HOST_PTR() {
        return CL_MEM_USE_HOST_PTR;
    }
    private static final int CL_MEM_ALLOC_HOST_PTR = (int)16L;
    /**
     * {@snippet lang=c :
     * #define CL_MEM_ALLOC_HOST_PTR 16
     * }
     */
    public static int CL_MEM_ALLOC_HOST_PTR() {
        return CL_MEM_ALLOC_HOST_PTR;
    }
    private static final int CL_MEM_COPY_HOST_PTR = (int)32L;
    /**
     * {@snippet lang=c :
     * #define CL_MEM_COPY_HOST_PTR 32
     * }
     */
    public static int CL_MEM_COPY_HOST_PTR() {
        return CL_MEM_COPY_HOST_PTR;
    }
    private static final int CL_MEM_HOST_WRITE_ONLY = (int)128L;
    /**
     * {@snippet lang=c :
     * #define CL_MEM_HOST_WRITE_ONLY 128
     * }
     */
    public static int CL_MEM_HOST_WRITE_ONLY() {
        return CL_MEM_HOST_WRITE_ONLY;
    }
    private static final int CL_MEM_HOST_READ_ONLY = (int)256L;
    /**
     * {@snippet lang=c :
     * #define CL_MEM_HOST_READ_ONLY 256
     * }
     */
    public static int CL_MEM_HOST_READ_ONLY() {
        return CL_MEM_HOST_READ_ONLY;
    }
    private static final int CL_MEM_HOST_NO_ACCESS = (int)512L;
    /**
     * {@snippet lang=c :
     * #define CL_MEM_HOST_NO_ACCESS 512
     * }
     */
    public static int CL_MEM_HOST_NO_ACCESS() {
        return CL_MEM_HOST_NO_ACCESS;
    }
    private static final int CL_MEM_SVM_FINE_GRAIN_BUFFER = (int)1024L;
    /**
     * {@snippet lang=c :
     * #define CL_MEM_SVM_FINE_GRAIN_BUFFER 1024
     * }
     */
    public static int CL_MEM_SVM_FINE_GRAIN_BUFFER() {
        return CL_MEM_SVM_FINE_GRAIN_BUFFER;
    }
    private static final int CL_MEM_SVM_ATOMICS = (int)2048L;
    /**
     * {@snippet lang=c :
     * #define CL_MEM_SVM_ATOMICS 2048
     * }
     */
    public static int CL_MEM_SVM_ATOMICS() {
        return CL_MEM_SVM_ATOMICS;
    }
    private static final int CL_MEM_KERNEL_READ_AND_WRITE = (int)4096L;
    /**
     * {@snippet lang=c :
     * #define CL_MEM_KERNEL_READ_AND_WRITE 4096
     * }
     */
    public static int CL_MEM_KERNEL_READ_AND_WRITE() {
        return CL_MEM_KERNEL_READ_AND_WRITE;
    }
    private static final int CL_MIGRATE_MEM_OBJECT_HOST = (int)1L;
    /**
     * {@snippet lang=c :
     * #define CL_MIGRATE_MEM_OBJECT_HOST 1
     * }
     */
    public static int CL_MIGRATE_MEM_OBJECT_HOST() {
        return CL_MIGRATE_MEM_OBJECT_HOST;
    }
    private static final int CL_MIGRATE_MEM_OBJECT_CONTENT_UNDEFINED = (int)2L;
    /**
     * {@snippet lang=c :
     * #define CL_MIGRATE_MEM_OBJECT_CONTENT_UNDEFINED 2
     * }
     */
    public static int CL_MIGRATE_MEM_OBJECT_CONTENT_UNDEFINED() {
        return CL_MIGRATE_MEM_OBJECT_CONTENT_UNDEFINED;
    }
    private static final int CL_MAP_READ = (int)1L;
    /**
     * {@snippet lang=c :
     * #define CL_MAP_READ 1
     * }
     */
    public static int CL_MAP_READ() {
        return CL_MAP_READ;
    }
    private static final int CL_MAP_WRITE = (int)2L;
    /**
     * {@snippet lang=c :
     * #define CL_MAP_WRITE 2
     * }
     */
    public static int CL_MAP_WRITE() {
        return CL_MAP_WRITE;
    }
    private static final int CL_MAP_WRITE_INVALIDATE_REGION = (int)4L;
    /**
     * {@snippet lang=c :
     * #define CL_MAP_WRITE_INVALIDATE_REGION 4
     * }
     */
    public static int CL_MAP_WRITE_INVALIDATE_REGION() {
        return CL_MAP_WRITE_INVALIDATE_REGION;
    }
    private static final int CL_BUILD_NONE = (int)-1L;
    /**
     * {@snippet lang=c :
     * #define CL_BUILD_NONE -1
     * }
     */
    public static int CL_BUILD_NONE() {
        return CL_BUILD_NONE;
    }
    private static final int CL_BUILD_ERROR = (int)-2L;
    /**
     * {@snippet lang=c :
     * #define CL_BUILD_ERROR -2
     * }
     */
    public static int CL_BUILD_ERROR() {
        return CL_BUILD_ERROR;
    }
    private static final int CL_BUILD_IN_PROGRESS = (int)-3L;
    /**
     * {@snippet lang=c :
     * #define CL_BUILD_IN_PROGRESS -3
     * }
     */
    public static int CL_BUILD_IN_PROGRESS() {
        return CL_BUILD_IN_PROGRESS;
    }
    private static final int CL_KERNEL_ARG_TYPE_CONST = (int)1L;
    /**
     * {@snippet lang=c :
     * #define CL_KERNEL_ARG_TYPE_CONST 1
     * }
     */
    public static int CL_KERNEL_ARG_TYPE_CONST() {
        return CL_KERNEL_ARG_TYPE_CONST;
    }
    private static final int CL_KERNEL_ARG_TYPE_RESTRICT = (int)2L;
    /**
     * {@snippet lang=c :
     * #define CL_KERNEL_ARG_TYPE_RESTRICT 2
     * }
     */
    public static int CL_KERNEL_ARG_TYPE_RESTRICT() {
        return CL_KERNEL_ARG_TYPE_RESTRICT;
    }
    private static final int CL_KERNEL_ARG_TYPE_VOLATILE = (int)4L;
    /**
     * {@snippet lang=c :
     * #define CL_KERNEL_ARG_TYPE_VOLATILE 4
     * }
     */
    public static int CL_KERNEL_ARG_TYPE_VOLATILE() {
        return CL_KERNEL_ARG_TYPE_VOLATILE;
    }
    private static final int CL_KERNEL_ARG_TYPE_PIPE = (int)8L;
    /**
     * {@snippet lang=c :
     * #define CL_KERNEL_ARG_TYPE_PIPE 8
     * }
     */
    public static int CL_KERNEL_ARG_TYPE_PIPE() {
        return CL_KERNEL_ARG_TYPE_PIPE;
    }
    private static final int CL_DEVICE_ATOMIC_ORDER_RELAXED = (int)1L;
    /**
     * {@snippet lang=c :
     * #define CL_DEVICE_ATOMIC_ORDER_RELAXED 1
     * }
     */
    public static int CL_DEVICE_ATOMIC_ORDER_RELAXED() {
        return CL_DEVICE_ATOMIC_ORDER_RELAXED;
    }
    private static final int CL_DEVICE_ATOMIC_ORDER_ACQ_REL = (int)2L;
    /**
     * {@snippet lang=c :
     * #define CL_DEVICE_ATOMIC_ORDER_ACQ_REL 2
     * }
     */
    public static int CL_DEVICE_ATOMIC_ORDER_ACQ_REL() {
        return CL_DEVICE_ATOMIC_ORDER_ACQ_REL;
    }
    private static final int CL_DEVICE_ATOMIC_ORDER_SEQ_CST = (int)4L;
    /**
     * {@snippet lang=c :
     * #define CL_DEVICE_ATOMIC_ORDER_SEQ_CST 4
     * }
     */
    public static int CL_DEVICE_ATOMIC_ORDER_SEQ_CST() {
        return CL_DEVICE_ATOMIC_ORDER_SEQ_CST;
    }
    private static final int CL_DEVICE_ATOMIC_SCOPE_WORK_ITEM = (int)8L;
    /**
     * {@snippet lang=c :
     * #define CL_DEVICE_ATOMIC_SCOPE_WORK_ITEM 8
     * }
     */
    public static int CL_DEVICE_ATOMIC_SCOPE_WORK_ITEM() {
        return CL_DEVICE_ATOMIC_SCOPE_WORK_ITEM;
    }
    private static final int CL_DEVICE_ATOMIC_SCOPE_WORK_GROUP = (int)16L;
    /**
     * {@snippet lang=c :
     * #define CL_DEVICE_ATOMIC_SCOPE_WORK_GROUP 16
     * }
     */
    public static int CL_DEVICE_ATOMIC_SCOPE_WORK_GROUP() {
        return CL_DEVICE_ATOMIC_SCOPE_WORK_GROUP;
    }
    private static final int CL_DEVICE_ATOMIC_SCOPE_DEVICE = (int)32L;
    /**
     * {@snippet lang=c :
     * #define CL_DEVICE_ATOMIC_SCOPE_DEVICE 32
     * }
     */
    public static int CL_DEVICE_ATOMIC_SCOPE_DEVICE() {
        return CL_DEVICE_ATOMIC_SCOPE_DEVICE;
    }
    private static final int CL_DEVICE_ATOMIC_SCOPE_ALL_DEVICES = (int)64L;
    /**
     * {@snippet lang=c :
     * #define CL_DEVICE_ATOMIC_SCOPE_ALL_DEVICES 64
     * }
     */
    public static int CL_DEVICE_ATOMIC_SCOPE_ALL_DEVICES() {
        return CL_DEVICE_ATOMIC_SCOPE_ALL_DEVICES;
    }
    private static final int CL_DEVICE_QUEUE_SUPPORTED = (int)1L;
    /**
     * {@snippet lang=c :
     * #define CL_DEVICE_QUEUE_SUPPORTED 1
     * }
     */
    public static int CL_DEVICE_QUEUE_SUPPORTED() {
        return CL_DEVICE_QUEUE_SUPPORTED;
    }
    private static final int CL_DEVICE_QUEUE_REPLACEABLE_DEFAULT = (int)2L;
    /**
     * {@snippet lang=c :
     * #define CL_DEVICE_QUEUE_REPLACEABLE_DEFAULT 2
     * }
     */
    public static int CL_DEVICE_QUEUE_REPLACEABLE_DEFAULT() {
        return CL_DEVICE_QUEUE_REPLACEABLE_DEFAULT;
    }
    private static final int CL_VERSION_MAJOR_BITS = (int)10L;
    /**
     * {@snippet lang=c :
     * #define CL_VERSION_MAJOR_BITS 10
     * }
     */
    public static int CL_VERSION_MAJOR_BITS() {
        return CL_VERSION_MAJOR_BITS;
    }
    private static final int CL_VERSION_MINOR_BITS = (int)10L;
    /**
     * {@snippet lang=c :
     * #define CL_VERSION_MINOR_BITS 10
     * }
     */
    public static int CL_VERSION_MINOR_BITS() {
        return CL_VERSION_MINOR_BITS;
    }
    private static final int CL_VERSION_PATCH_BITS = (int)12L;
    /**
     * {@snippet lang=c :
     * #define CL_VERSION_PATCH_BITS 12
     * }
     */
    public static int CL_VERSION_PATCH_BITS() {
        return CL_VERSION_PATCH_BITS;
    }
    private static final int CL_VERSION_MAJOR_MASK = (int)1023L;
    /**
     * {@snippet lang=c :
     * #define CL_VERSION_MAJOR_MASK 1023
     * }
     */
    public static int CL_VERSION_MAJOR_MASK() {
        return CL_VERSION_MAJOR_MASK;
    }
    private static final int CL_VERSION_MINOR_MASK = (int)1023L;
    /**
     * {@snippet lang=c :
     * #define CL_VERSION_MINOR_MASK 1023
     * }
     */
    public static int CL_VERSION_MINOR_MASK() {
        return CL_VERSION_MINOR_MASK;
    }
    private static final int CL_VERSION_PATCH_MASK = (int)4095L;
    /**
     * {@snippet lang=c :
     * #define CL_VERSION_PATCH_MASK 4095
     * }
     */
    public static int CL_VERSION_PATCH_MASK() {
        return CL_VERSION_PATCH_MASK;
    }
    /**
     * {@snippet lang=c :
     * #define CL_KHR_GL_SHARING_EXTENSION_NAME "cl_khr_gl_sharing"
     * }
     */
    public static MemorySegment CL_KHR_GL_SHARING_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment CL_KHR_GL_SHARING_EXTENSION_NAME
                = LIBRARY_ARENA.allocateFrom("cl_khr_gl_sharing");
        }
        return Holder.CL_KHR_GL_SHARING_EXTENSION_NAME;
    }
    private static final int CL_INVALID_GL_SHAREGROUP_REFERENCE_KHR = (int)-1000L;
    /**
     * {@snippet lang=c :
     * #define CL_INVALID_GL_SHAREGROUP_REFERENCE_KHR -1000
     * }
     */
    public static int CL_INVALID_GL_SHAREGROUP_REFERENCE_KHR() {
        return CL_INVALID_GL_SHAREGROUP_REFERENCE_KHR;
    }
    /**
     * {@snippet lang=c :
     * #define CL_KHR_GL_EVENT_EXTENSION_NAME "cl_khr_gl_event"
     * }
     */
    public static MemorySegment CL_KHR_GL_EVENT_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment CL_KHR_GL_EVENT_EXTENSION_NAME
                = LIBRARY_ARENA.allocateFrom("cl_khr_gl_event");
        }
        return Holder.CL_KHR_GL_EVENT_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define CL_KHR_GL_DEPTH_IMAGES_EXTENSION_NAME "cl_khr_gl_depth_images"
     * }
     */
    public static MemorySegment CL_KHR_GL_DEPTH_IMAGES_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment CL_KHR_GL_DEPTH_IMAGES_EXTENSION_NAME
                = LIBRARY_ARENA.allocateFrom("cl_khr_gl_depth_images");
        }
        return Holder.CL_KHR_GL_DEPTH_IMAGES_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define CL_KHR_GL_MSAA_SHARING_EXTENSION_NAME "cl_khr_gl_msaa_sharing"
     * }
     */
    public static MemorySegment CL_KHR_GL_MSAA_SHARING_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment CL_KHR_GL_MSAA_SHARING_EXTENSION_NAME
                = LIBRARY_ARENA.allocateFrom("cl_khr_gl_msaa_sharing");
        }
        return Holder.CL_KHR_GL_MSAA_SHARING_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define CL_INTEL_SHARING_FORMAT_QUERY_GL_EXTENSION_NAME "cl_intel_sharing_format_query_gl"
     * }
     */
    public static MemorySegment CL_INTEL_SHARING_FORMAT_QUERY_GL_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment CL_INTEL_SHARING_FORMAT_QUERY_GL_EXTENSION_NAME
                = LIBRARY_ARENA.allocateFrom("cl_intel_sharing_format_query_gl");
        }
        return Holder.CL_INTEL_SHARING_FORMAT_QUERY_GL_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define CL_KHR_COMMAND_BUFFER_EXTENSION_NAME "cl_khr_command_buffer"
     * }
     */
    public static MemorySegment CL_KHR_COMMAND_BUFFER_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment CL_KHR_COMMAND_BUFFER_EXTENSION_NAME
                = LIBRARY_ARENA.allocateFrom("cl_khr_command_buffer");
        }
        return Holder.CL_KHR_COMMAND_BUFFER_EXTENSION_NAME;
    }
    private static final int CL_COMMAND_BUFFER_CAPABILITY_KERNEL_PRINTF_KHR = (int)1L;
    /**
     * {@snippet lang=c :
     * #define CL_COMMAND_BUFFER_CAPABILITY_KERNEL_PRINTF_KHR 1
     * }
     */
    public static int CL_COMMAND_BUFFER_CAPABILITY_KERNEL_PRINTF_KHR() {
        return CL_COMMAND_BUFFER_CAPABILITY_KERNEL_PRINTF_KHR;
    }
    private static final int CL_COMMAND_BUFFER_CAPABILITY_DEVICE_SIDE_ENQUEUE_KHR = (int)2L;
    /**
     * {@snippet lang=c :
     * #define CL_COMMAND_BUFFER_CAPABILITY_DEVICE_SIDE_ENQUEUE_KHR 2
     * }
     */
    public static int CL_COMMAND_BUFFER_CAPABILITY_DEVICE_SIDE_ENQUEUE_KHR() {
        return CL_COMMAND_BUFFER_CAPABILITY_DEVICE_SIDE_ENQUEUE_KHR;
    }
    private static final int CL_COMMAND_BUFFER_CAPABILITY_SIMULTANEOUS_USE_KHR = (int)4L;
    /**
     * {@snippet lang=c :
     * #define CL_COMMAND_BUFFER_CAPABILITY_SIMULTANEOUS_USE_KHR 4
     * }
     */
    public static int CL_COMMAND_BUFFER_CAPABILITY_SIMULTANEOUS_USE_KHR() {
        return CL_COMMAND_BUFFER_CAPABILITY_SIMULTANEOUS_USE_KHR;
    }
    private static final int CL_COMMAND_BUFFER_CAPABILITY_OUT_OF_ORDER_KHR = (int)8L;
    /**
     * {@snippet lang=c :
     * #define CL_COMMAND_BUFFER_CAPABILITY_OUT_OF_ORDER_KHR 8
     * }
     */
    public static int CL_COMMAND_BUFFER_CAPABILITY_OUT_OF_ORDER_KHR() {
        return CL_COMMAND_BUFFER_CAPABILITY_OUT_OF_ORDER_KHR;
    }
    private static final int CL_COMMAND_BUFFER_SIMULTANEOUS_USE_KHR = (int)1L;
    /**
     * {@snippet lang=c :
     * #define CL_COMMAND_BUFFER_SIMULTANEOUS_USE_KHR 1
     * }
     */
    public static int CL_COMMAND_BUFFER_SIMULTANEOUS_USE_KHR() {
        return CL_COMMAND_BUFFER_SIMULTANEOUS_USE_KHR;
    }
    private static final int CL_INVALID_COMMAND_BUFFER_KHR = (int)-1138L;
    /**
     * {@snippet lang=c :
     * #define CL_INVALID_COMMAND_BUFFER_KHR -1138
     * }
     */
    public static int CL_INVALID_COMMAND_BUFFER_KHR() {
        return CL_INVALID_COMMAND_BUFFER_KHR;
    }
    private static final int CL_INVALID_SYNC_POINT_WAIT_LIST_KHR = (int)-1139L;
    /**
     * {@snippet lang=c :
     * #define CL_INVALID_SYNC_POINT_WAIT_LIST_KHR -1139
     * }
     */
    public static int CL_INVALID_SYNC_POINT_WAIT_LIST_KHR() {
        return CL_INVALID_SYNC_POINT_WAIT_LIST_KHR;
    }
    private static final int CL_INCOMPATIBLE_COMMAND_QUEUE_KHR = (int)-1140L;
    /**
     * {@snippet lang=c :
     * #define CL_INCOMPATIBLE_COMMAND_QUEUE_KHR -1140
     * }
     */
    public static int CL_INCOMPATIBLE_COMMAND_QUEUE_KHR() {
        return CL_INCOMPATIBLE_COMMAND_QUEUE_KHR;
    }
    /**
     * {@snippet lang=c :
     * #define CL_KHR_COMMAND_BUFFER_MULTI_DEVICE_EXTENSION_NAME "cl_khr_command_buffer_multi_device"
     * }
     */
    public static MemorySegment CL_KHR_COMMAND_BUFFER_MULTI_DEVICE_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment CL_KHR_COMMAND_BUFFER_MULTI_DEVICE_EXTENSION_NAME
                = LIBRARY_ARENA.allocateFrom("cl_khr_command_buffer_multi_device");
        }
        return Holder.CL_KHR_COMMAND_BUFFER_MULTI_DEVICE_EXTENSION_NAME;
    }
    private static final int CL_COMMAND_BUFFER_PLATFORM_UNIVERSAL_SYNC_KHR = (int)1L;
    /**
     * {@snippet lang=c :
     * #define CL_COMMAND_BUFFER_PLATFORM_UNIVERSAL_SYNC_KHR 1
     * }
     */
    public static int CL_COMMAND_BUFFER_PLATFORM_UNIVERSAL_SYNC_KHR() {
        return CL_COMMAND_BUFFER_PLATFORM_UNIVERSAL_SYNC_KHR;
    }
    private static final int CL_COMMAND_BUFFER_PLATFORM_REMAP_QUEUES_KHR = (int)2L;
    /**
     * {@snippet lang=c :
     * #define CL_COMMAND_BUFFER_PLATFORM_REMAP_QUEUES_KHR 2
     * }
     */
    public static int CL_COMMAND_BUFFER_PLATFORM_REMAP_QUEUES_KHR() {
        return CL_COMMAND_BUFFER_PLATFORM_REMAP_QUEUES_KHR;
    }
    private static final int CL_COMMAND_BUFFER_PLATFORM_AUTOMATIC_REMAP_KHR = (int)4L;
    /**
     * {@snippet lang=c :
     * #define CL_COMMAND_BUFFER_PLATFORM_AUTOMATIC_REMAP_KHR 4
     * }
     */
    public static int CL_COMMAND_BUFFER_PLATFORM_AUTOMATIC_REMAP_KHR() {
        return CL_COMMAND_BUFFER_PLATFORM_AUTOMATIC_REMAP_KHR;
    }
    private static final int CL_COMMAND_BUFFER_CAPABILITY_MULTIPLE_QUEUE_KHR = (int)16L;
    /**
     * {@snippet lang=c :
     * #define CL_COMMAND_BUFFER_CAPABILITY_MULTIPLE_QUEUE_KHR 16
     * }
     */
    public static int CL_COMMAND_BUFFER_CAPABILITY_MULTIPLE_QUEUE_KHR() {
        return CL_COMMAND_BUFFER_CAPABILITY_MULTIPLE_QUEUE_KHR;
    }
    private static final int CL_COMMAND_BUFFER_DEVICE_SIDE_SYNC_KHR = (int)4L;
    /**
     * {@snippet lang=c :
     * #define CL_COMMAND_BUFFER_DEVICE_SIDE_SYNC_KHR 4
     * }
     */
    public static int CL_COMMAND_BUFFER_DEVICE_SIDE_SYNC_KHR() {
        return CL_COMMAND_BUFFER_DEVICE_SIDE_SYNC_KHR;
    }
    /**
     * {@snippet lang=c :
     * #define CL_KHR_COMMAND_BUFFER_MUTABLE_DISPATCH_EXTENSION_NAME "cl_khr_command_buffer_mutable_dispatch"
     * }
     */
    public static MemorySegment CL_KHR_COMMAND_BUFFER_MUTABLE_DISPATCH_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment CL_KHR_COMMAND_BUFFER_MUTABLE_DISPATCH_EXTENSION_NAME
                = LIBRARY_ARENA.allocateFrom("cl_khr_command_buffer_mutable_dispatch");
        }
        return Holder.CL_KHR_COMMAND_BUFFER_MUTABLE_DISPATCH_EXTENSION_NAME;
    }
    private static final int CL_COMMAND_BUFFER_MUTABLE_KHR = (int)2L;
    /**
     * {@snippet lang=c :
     * #define CL_COMMAND_BUFFER_MUTABLE_KHR 2
     * }
     */
    public static int CL_COMMAND_BUFFER_MUTABLE_KHR() {
        return CL_COMMAND_BUFFER_MUTABLE_KHR;
    }
    private static final int CL_INVALID_MUTABLE_COMMAND_KHR = (int)-1141L;
    /**
     * {@snippet lang=c :
     * #define CL_INVALID_MUTABLE_COMMAND_KHR -1141
     * }
     */
    public static int CL_INVALID_MUTABLE_COMMAND_KHR() {
        return CL_INVALID_MUTABLE_COMMAND_KHR;
    }
    private static final int CL_MUTABLE_DISPATCH_GLOBAL_OFFSET_KHR = (int)1L;
    /**
     * {@snippet lang=c :
     * #define CL_MUTABLE_DISPATCH_GLOBAL_OFFSET_KHR 1
     * }
     */
    public static int CL_MUTABLE_DISPATCH_GLOBAL_OFFSET_KHR() {
        return CL_MUTABLE_DISPATCH_GLOBAL_OFFSET_KHR;
    }
    private static final int CL_MUTABLE_DISPATCH_GLOBAL_SIZE_KHR = (int)2L;
    /**
     * {@snippet lang=c :
     * #define CL_MUTABLE_DISPATCH_GLOBAL_SIZE_KHR 2
     * }
     */
    public static int CL_MUTABLE_DISPATCH_GLOBAL_SIZE_KHR() {
        return CL_MUTABLE_DISPATCH_GLOBAL_SIZE_KHR;
    }
    private static final int CL_MUTABLE_DISPATCH_LOCAL_SIZE_KHR = (int)4L;
    /**
     * {@snippet lang=c :
     * #define CL_MUTABLE_DISPATCH_LOCAL_SIZE_KHR 4
     * }
     */
    public static int CL_MUTABLE_DISPATCH_LOCAL_SIZE_KHR() {
        return CL_MUTABLE_DISPATCH_LOCAL_SIZE_KHR;
    }
    private static final int CL_MUTABLE_DISPATCH_ARGUMENTS_KHR = (int)8L;
    /**
     * {@snippet lang=c :
     * #define CL_MUTABLE_DISPATCH_ARGUMENTS_KHR 8
     * }
     */
    public static int CL_MUTABLE_DISPATCH_ARGUMENTS_KHR() {
        return CL_MUTABLE_DISPATCH_ARGUMENTS_KHR;
    }
    private static final int CL_MUTABLE_DISPATCH_EXEC_INFO_KHR = (int)16L;
    /**
     * {@snippet lang=c :
     * #define CL_MUTABLE_DISPATCH_EXEC_INFO_KHR 16
     * }
     */
    public static int CL_MUTABLE_DISPATCH_EXEC_INFO_KHR() {
        return CL_MUTABLE_DISPATCH_EXEC_INFO_KHR;
    }
    /**
     * {@snippet lang=c :
     * #define CL_KHR_FP64_EXTENSION_NAME "cl_khr_fp64"
     * }
     */
    public static MemorySegment CL_KHR_FP64_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment CL_KHR_FP64_EXTENSION_NAME
                = LIBRARY_ARENA.allocateFrom("cl_khr_fp64");
        }
        return Holder.CL_KHR_FP64_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define CL_KHR_FP16_EXTENSION_NAME "cl_khr_fp16"
     * }
     */
    public static MemorySegment CL_KHR_FP16_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment CL_KHR_FP16_EXTENSION_NAME
                = LIBRARY_ARENA.allocateFrom("cl_khr_fp16");
        }
        return Holder.CL_KHR_FP16_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define CL_APPLE_SETMEMOBJECTDESTRUCTOR_EXTENSION_NAME "cl_APPLE_SetMemObjectDestructor"
     * }
     */
    public static MemorySegment CL_APPLE_SETMEMOBJECTDESTRUCTOR_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment CL_APPLE_SETMEMOBJECTDESTRUCTOR_EXTENSION_NAME
                = LIBRARY_ARENA.allocateFrom("cl_APPLE_SetMemObjectDestructor");
        }
        return Holder.CL_APPLE_SETMEMOBJECTDESTRUCTOR_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define CL_APPLE_CONTEXTLOGGINGFUNCTIONS_EXTENSION_NAME "cl_APPLE_ContextLoggingFunctions"
     * }
     */
    public static MemorySegment CL_APPLE_CONTEXTLOGGINGFUNCTIONS_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment CL_APPLE_CONTEXTLOGGINGFUNCTIONS_EXTENSION_NAME
                = LIBRARY_ARENA.allocateFrom("cl_APPLE_ContextLoggingFunctions");
        }
        return Holder.CL_APPLE_CONTEXTLOGGINGFUNCTIONS_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define CL_KHR_ICD_EXTENSION_NAME "cl_khr_icd"
     * }
     */
    public static MemorySegment CL_KHR_ICD_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment CL_KHR_ICD_EXTENSION_NAME
                = LIBRARY_ARENA.allocateFrom("cl_khr_icd");
        }
        return Holder.CL_KHR_ICD_EXTENSION_NAME;
    }
    private static final int CL_PLATFORM_NOT_FOUND_KHR = (int)-1001L;
    /**
     * {@snippet lang=c :
     * #define CL_PLATFORM_NOT_FOUND_KHR -1001
     * }
     */
    public static int CL_PLATFORM_NOT_FOUND_KHR() {
        return CL_PLATFORM_NOT_FOUND_KHR;
    }
    /**
     * {@snippet lang=c :
     * #define CL_KHR_IL_PROGRAM_EXTENSION_NAME "cl_khr_il_program"
     * }
     */
    public static MemorySegment CL_KHR_IL_PROGRAM_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment CL_KHR_IL_PROGRAM_EXTENSION_NAME
                = LIBRARY_ARENA.allocateFrom("cl_khr_il_program");
        }
        return Holder.CL_KHR_IL_PROGRAM_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define CL_KHR_IMAGE2D_FROM_BUFFER_EXTENSION_NAME "cl_khr_image2d_from_buffer"
     * }
     */
    public static MemorySegment CL_KHR_IMAGE2D_FROM_BUFFER_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment CL_KHR_IMAGE2D_FROM_BUFFER_EXTENSION_NAME
                = LIBRARY_ARENA.allocateFrom("cl_khr_image2d_from_buffer");
        }
        return Holder.CL_KHR_IMAGE2D_FROM_BUFFER_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define CL_KHR_INITIALIZE_MEMORY_EXTENSION_NAME "cl_khr_initialize_memory"
     * }
     */
    public static MemorySegment CL_KHR_INITIALIZE_MEMORY_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment CL_KHR_INITIALIZE_MEMORY_EXTENSION_NAME
                = LIBRARY_ARENA.allocateFrom("cl_khr_initialize_memory");
        }
        return Holder.CL_KHR_INITIALIZE_MEMORY_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define CL_KHR_TERMINATE_CONTEXT_EXTENSION_NAME "cl_khr_terminate_context"
     * }
     */
    public static MemorySegment CL_KHR_TERMINATE_CONTEXT_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment CL_KHR_TERMINATE_CONTEXT_EXTENSION_NAME
                = LIBRARY_ARENA.allocateFrom("cl_khr_terminate_context");
        }
        return Holder.CL_KHR_TERMINATE_CONTEXT_EXTENSION_NAME;
    }
    private static final int CL_DEVICE_TERMINATE_CAPABILITY_CONTEXT_KHR = (int)1L;
    /**
     * {@snippet lang=c :
     * #define CL_DEVICE_TERMINATE_CAPABILITY_CONTEXT_KHR 1
     * }
     */
    public static int CL_DEVICE_TERMINATE_CAPABILITY_CONTEXT_KHR() {
        return CL_DEVICE_TERMINATE_CAPABILITY_CONTEXT_KHR;
    }
    private static final int CL_CONTEXT_TERMINATED_KHR = (int)-1121L;
    /**
     * {@snippet lang=c :
     * #define CL_CONTEXT_TERMINATED_KHR -1121
     * }
     */
    public static int CL_CONTEXT_TERMINATED_KHR() {
        return CL_CONTEXT_TERMINATED_KHR;
    }
    /**
     * {@snippet lang=c :
     * #define CL_KHR_SPIR_EXTENSION_NAME "cl_khr_spir"
     * }
     */
    public static MemorySegment CL_KHR_SPIR_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment CL_KHR_SPIR_EXTENSION_NAME
                = LIBRARY_ARENA.allocateFrom("cl_khr_spir");
        }
        return Holder.CL_KHR_SPIR_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define CL_KHR_CREATE_COMMAND_QUEUE_EXTENSION_NAME "cl_khr_create_command_queue"
     * }
     */
    public static MemorySegment CL_KHR_CREATE_COMMAND_QUEUE_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment CL_KHR_CREATE_COMMAND_QUEUE_EXTENSION_NAME
                = LIBRARY_ARENA.allocateFrom("cl_khr_create_command_queue");
        }
        return Holder.CL_KHR_CREATE_COMMAND_QUEUE_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define CL_NV_DEVICE_ATTRIBUTE_QUERY_EXTENSION_NAME "cl_nv_device_attribute_query"
     * }
     */
    public static MemorySegment CL_NV_DEVICE_ATTRIBUTE_QUERY_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment CL_NV_DEVICE_ATTRIBUTE_QUERY_EXTENSION_NAME
                = LIBRARY_ARENA.allocateFrom("cl_nv_device_attribute_query");
        }
        return Holder.CL_NV_DEVICE_ATTRIBUTE_QUERY_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define CL_AMD_DEVICE_ATTRIBUTE_QUERY_EXTENSION_NAME "cl_amd_device_attribute_query"
     * }
     */
    public static MemorySegment CL_AMD_DEVICE_ATTRIBUTE_QUERY_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment CL_AMD_DEVICE_ATTRIBUTE_QUERY_EXTENSION_NAME
                = LIBRARY_ARENA.allocateFrom("cl_amd_device_attribute_query");
        }
        return Holder.CL_AMD_DEVICE_ATTRIBUTE_QUERY_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define CL_ARM_PRINTF_EXTENSION_NAME "cl_arm_printf"
     * }
     */
    public static MemorySegment CL_ARM_PRINTF_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment CL_ARM_PRINTF_EXTENSION_NAME
                = LIBRARY_ARENA.allocateFrom("cl_arm_printf");
        }
        return Holder.CL_ARM_PRINTF_EXTENSION_NAME;
    }
    /**
     * {@snippet lang=c :
     * #define CL_EXT_DEVICE_FISSION_EXTENSION_NAME "cl_ext_device_fission"
     * }
     */
    public static MemorySegment CL_EXT_DEVICE_FISSION_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment CL_EXT_DEVICE_FISSION_EXTENSION_NAME
                = LIBRARY_ARENA.allocateFrom("cl_ext_device_fission");
        }
        return Holder.CL_EXT_DEVICE_FISSION_EXTENSION_NAME;
    }
    private static final int CL_DEVICE_PARTITION_FAILED_EXT = (int)-1057L;
    /**
     * {@snippet lang=c :
     * #define CL_DEVICE_PARTITION_FAILED_EXT -1057
     * }
     */
    public static int CL_DEVICE_PARTITION_FAILED_EXT() {
        return CL_DEVICE_PARTITION_FAILED_EXT;
    }
    private static final int CL_INVALID_PARTITION_COUNT_EXT = (int)-1058L;
    /**
     * {@snippet lang=c :
     * #define CL_INVALID_PARTITION_COUNT_EXT -1058
     * }
     */
    public static int CL_INVALID_PARTITION_COUNT_EXT() {
        return CL_INVALID_PARTITION_COUNT_EXT;
    }
    private static final int CL_INVALID_PARTITION_NAME_EXT = (int)-1059L;
    /**
     * {@snippet lang=c :
     * #define CL_INVALID_PARTITION_NAME_EXT -1059
     * }
     */
    public static int CL_INVALID_PARTITION_NAME_EXT() {
        return CL_INVALID_PARTITION_NAME_EXT;
    }
    private static final long CL_PROPERTIES_LIST_END_EXT = 0L;
    /**
     * {@snippet lang=c :
     * #define CL_PROPERTIES_LIST_END_EXT 0
     * }
     */
    public static long CL_PROPERTIES_LIST_END_EXT() {
        return CL_PROPERTIES_LIST_END_EXT;
    }
    private static final long CL_PARTITION_BY_COUNTS_LIST_END_EXT = 0L;
    /**
     * {@snippet lang=c :
     * #define CL_PARTITION_BY_COUNTS_LIST_END_EXT 0
     * }
     */
    public static long CL_PARTITION_BY_COUNTS_LIST_END_EXT() {
        return CL_PARTITION_BY_COUNTS_LIST_END_EXT;
    }
    private static final long CL_PARTITION_BY_NAMES_LIST_END_EXT = -1L;
    /**
     * {@snippet lang=c :
     * #define CL_PARTITION_BY_NAMES_LIST_END_EXT -1
     * }
     */
    public static long CL_PARTITION_BY_NAMES_LIST_END_EXT() {
        return CL_PARTITION_BY_NAMES_LIST_END_EXT;
    }
    /**
     * {@snippet lang=c :
     * #define CL_EXT_MIGRATE_MEMOBJECT_EXTENSION_NAME "cl_ext_migrate_memobject"
     * }
     */
    public static MemorySegment CL_EXT_MIGRATE_MEMOBJECT_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment CL_EXT_MIGRATE_MEMOBJECT_EXTENSION_NAME
                = LIBRARY_ARENA.allocateFrom("cl_ext_migrate_memobject");
        }
        return Holder.CL_EXT_MIGRATE_MEMOBJECT_EXTENSION_NAME;
    }
    private static final int CL_MIGRATE_MEM_OBJECT_HOST_EXT = (int)1L;
    /**
     * {@snippet lang=c :
     * #define CL_MIGRATE_MEM_OBJECT_HOST_EXT 1
     * }
     */
    public static int CL_MIGRATE_MEM_OBJECT_HOST_EXT() {
        return CL_MIGRATE_MEM_OBJECT_HOST_EXT;
    }
    /**
     * {@snippet lang=c :
     * #define CL_EXT_CXX_FOR_OPENCL_EXTENSION_NAME "cl_ext_cxx_for_opencl"
     * }
     */
    public static MemorySegment CL_EXT_CXX_FOR_OPENCL_EXTENSION_NAME() {
        class Holder {
            static final MemorySegment CL_EXT_CXX_FOR_OPENCL_EXTENSION_NAME
                = LIBRARY_ARENA.allocateFrom("cl_ext_cxx_for_opencl");
        }
        return Holder.CL_EXT_CXX_FOR_OPENCL_EXTENSION_NAME;
    }
}

