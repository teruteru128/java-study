// Generated by jextract

package com.github.teruteru128.foreign.windows;

import java.lang.invoke.*;
import java.lang.foreign.*;
import java.nio.ByteOrder;
import java.util.*;
import java.util.function.*;
import java.util.stream.*;

import static java.lang.foreign.ValueLayout.*;
import static java.lang.foreign.MemoryLayout.PathElement.*;

public class Windows_h_24 extends Windows_h_25 {

    Windows_h_24() {
        // Should not be called directly
    }

    private static class Wow64SetThreadContext {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("Wow64SetThreadContext"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL Wow64SetThreadContext(HANDLE hThread, const WOW64_CONTEXT *lpContext)
     * }
     */
    public static FunctionDescriptor Wow64SetThreadContext$descriptor() {
        return Wow64SetThreadContext.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL Wow64SetThreadContext(HANDLE hThread, const WOW64_CONTEXT *lpContext)
     * }
     */
    public static MethodHandle Wow64SetThreadContext$handle() {
        return Wow64SetThreadContext.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL Wow64SetThreadContext(HANDLE hThread, const WOW64_CONTEXT *lpContext)
     * }
     */
    public static int Wow64SetThreadContext(MemorySegment hThread, MemorySegment lpContext) {
        var mh$ = Wow64SetThreadContext.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Wow64SetThreadContext", hThread, lpContext);
            }
            return (int)mh$.invokeExact(hThread, lpContext);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Wow64SuspendThread {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("Wow64SuspendThread"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD Wow64SuspendThread(HANDLE hThread)
     * }
     */
    public static FunctionDescriptor Wow64SuspendThread$descriptor() {
        return Wow64SuspendThread.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD Wow64SuspendThread(HANDLE hThread)
     * }
     */
    public static MethodHandle Wow64SuspendThread$handle() {
        return Wow64SuspendThread.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * DWORD Wow64SuspendThread(HANDLE hThread)
     * }
     */
    public static int Wow64SuspendThread(MemorySegment hThread) {
        var mh$ = Wow64SuspendThread.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Wow64SuspendThread", hThread);
            }
            return (int)mh$.invokeExact(hThread);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct tagENUMUILANG {
     *     ULONG NumOfEnumUILang;
     *     ULONG SizeOfEnumUIBuffer;
     *     LANGID *pEnumUIBuffer;
     * } *PENUMUILANG
     * }
     */
    public static final AddressLayout PENUMUILANG = C_POINTER;

    private static class DisableThreadLibraryCalls {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("DisableThreadLibraryCalls"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL DisableThreadLibraryCalls(HMODULE hLibModule)
     * }
     */
    public static FunctionDescriptor DisableThreadLibraryCalls$descriptor() {
        return DisableThreadLibraryCalls.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL DisableThreadLibraryCalls(HMODULE hLibModule)
     * }
     */
    public static MethodHandle DisableThreadLibraryCalls$handle() {
        return DisableThreadLibraryCalls.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL DisableThreadLibraryCalls(HMODULE hLibModule)
     * }
     */
    public static int DisableThreadLibraryCalls(MemorySegment hLibModule) {
        var mh$ = DisableThreadLibraryCalls.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DisableThreadLibraryCalls", hLibModule);
            }
            return (int)mh$.invokeExact(hLibModule);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FindResourceExW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_SHORT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("FindResourceExW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HRSRC FindResourceExW(HMODULE hModule, LPCWSTR lpType, LPCWSTR lpName, WORD wLanguage)
     * }
     */
    public static FunctionDescriptor FindResourceExW$descriptor() {
        return FindResourceExW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HRSRC FindResourceExW(HMODULE hModule, LPCWSTR lpType, LPCWSTR lpName, WORD wLanguage)
     * }
     */
    public static MethodHandle FindResourceExW$handle() {
        return FindResourceExW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * HRSRC FindResourceExW(HMODULE hModule, LPCWSTR lpType, LPCWSTR lpName, WORD wLanguage)
     * }
     */
    public static MemorySegment FindResourceExW(MemorySegment hModule, MemorySegment lpType, MemorySegment lpName, short wLanguage) {
        var mh$ = FindResourceExW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FindResourceExW", hModule, lpType, lpName, wLanguage);
            }
            return (MemorySegment)mh$.invokeExact(hModule, lpType, lpName, wLanguage);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FindStringOrdinal {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_LONG,
            C_POINTER,
            C_INT,
            C_POINTER,
            C_INT,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("FindStringOrdinal"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int FindStringOrdinal(DWORD dwFindStringOrdinalFlags, LPCWSTR lpStringSource, int cchSource, LPCWSTR lpStringValue, int cchValue, BOOL bIgnoreCase)
     * }
     */
    public static FunctionDescriptor FindStringOrdinal$descriptor() {
        return FindStringOrdinal.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int FindStringOrdinal(DWORD dwFindStringOrdinalFlags, LPCWSTR lpStringSource, int cchSource, LPCWSTR lpStringValue, int cchValue, BOOL bIgnoreCase)
     * }
     */
    public static MethodHandle FindStringOrdinal$handle() {
        return FindStringOrdinal.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int FindStringOrdinal(DWORD dwFindStringOrdinalFlags, LPCWSTR lpStringSource, int cchSource, LPCWSTR lpStringValue, int cchValue, BOOL bIgnoreCase)
     * }
     */
    public static int FindStringOrdinal(int dwFindStringOrdinalFlags, MemorySegment lpStringSource, int cchSource, MemorySegment lpStringValue, int cchValue, int bIgnoreCase) {
        var mh$ = FindStringOrdinal.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FindStringOrdinal", dwFindStringOrdinalFlags, lpStringSource, cchSource, lpStringValue, cchValue, bIgnoreCase);
            }
            return (int)mh$.invokeExact(dwFindStringOrdinalFlags, lpStringSource, cchSource, lpStringValue, cchValue, bIgnoreCase);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FreeLibrary {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("FreeLibrary"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL FreeLibrary(HMODULE hLibModule)
     * }
     */
    public static FunctionDescriptor FreeLibrary$descriptor() {
        return FreeLibrary.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL FreeLibrary(HMODULE hLibModule)
     * }
     */
    public static MethodHandle FreeLibrary$handle() {
        return FreeLibrary.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL FreeLibrary(HMODULE hLibModule)
     * }
     */
    public static int FreeLibrary(MemorySegment hLibModule) {
        var mh$ = FreeLibrary.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FreeLibrary", hLibModule);
            }
            return (int)mh$.invokeExact(hLibModule);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FreeLibraryAndExitThread {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C_POINTER,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("FreeLibraryAndExitThread"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void FreeLibraryAndExitThread(HMODULE hLibModule, DWORD dwExitCode)
     * }
     */
    public static FunctionDescriptor FreeLibraryAndExitThread$descriptor() {
        return FreeLibraryAndExitThread.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void FreeLibraryAndExitThread(HMODULE hLibModule, DWORD dwExitCode)
     * }
     */
    public static MethodHandle FreeLibraryAndExitThread$handle() {
        return FreeLibraryAndExitThread.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * void FreeLibraryAndExitThread(HMODULE hLibModule, DWORD dwExitCode)
     * }
     */
    public static void FreeLibraryAndExitThread(MemorySegment hLibModule, int dwExitCode) {
        var mh$ = FreeLibraryAndExitThread.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FreeLibraryAndExitThread", hLibModule, dwExitCode);
            }
            mh$.invokeExact(hLibModule, dwExitCode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FreeResource {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("FreeResource"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL FreeResource(HGLOBAL hResData)
     * }
     */
    public static FunctionDescriptor FreeResource$descriptor() {
        return FreeResource.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL FreeResource(HGLOBAL hResData)
     * }
     */
    public static MethodHandle FreeResource$handle() {
        return FreeResource.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL FreeResource(HGLOBAL hResData)
     * }
     */
    public static int FreeResource(MemorySegment hResData) {
        var mh$ = FreeResource.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FreeResource", hResData);
            }
            return (int)mh$.invokeExact(hResData);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetModuleFileNameA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_POINTER,
            C_POINTER,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetModuleFileNameA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetModuleFileNameA(HMODULE hModule, LPSTR lpFilename, DWORD nSize)
     * }
     */
    public static FunctionDescriptor GetModuleFileNameA$descriptor() {
        return GetModuleFileNameA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetModuleFileNameA(HMODULE hModule, LPSTR lpFilename, DWORD nSize)
     * }
     */
    public static MethodHandle GetModuleFileNameA$handle() {
        return GetModuleFileNameA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * DWORD GetModuleFileNameA(HMODULE hModule, LPSTR lpFilename, DWORD nSize)
     * }
     */
    public static int GetModuleFileNameA(MemorySegment hModule, MemorySegment lpFilename, int nSize) {
        var mh$ = GetModuleFileNameA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetModuleFileNameA", hModule, lpFilename, nSize);
            }
            return (int)mh$.invokeExact(hModule, lpFilename, nSize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetModuleFileNameW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_POINTER,
            C_POINTER,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetModuleFileNameW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetModuleFileNameW(HMODULE hModule, LPWSTR lpFilename, DWORD nSize)
     * }
     */
    public static FunctionDescriptor GetModuleFileNameW$descriptor() {
        return GetModuleFileNameW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetModuleFileNameW(HMODULE hModule, LPWSTR lpFilename, DWORD nSize)
     * }
     */
    public static MethodHandle GetModuleFileNameW$handle() {
        return GetModuleFileNameW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * DWORD GetModuleFileNameW(HMODULE hModule, LPWSTR lpFilename, DWORD nSize)
     * }
     */
    public static int GetModuleFileNameW(MemorySegment hModule, MemorySegment lpFilename, int nSize) {
        var mh$ = GetModuleFileNameW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetModuleFileNameW", hModule, lpFilename, nSize);
            }
            return (int)mh$.invokeExact(hModule, lpFilename, nSize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetModuleHandleA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetModuleHandleA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HMODULE GetModuleHandleA(LPCSTR lpModuleName)
     * }
     */
    public static FunctionDescriptor GetModuleHandleA$descriptor() {
        return GetModuleHandleA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HMODULE GetModuleHandleA(LPCSTR lpModuleName)
     * }
     */
    public static MethodHandle GetModuleHandleA$handle() {
        return GetModuleHandleA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * HMODULE GetModuleHandleA(LPCSTR lpModuleName)
     * }
     */
    public static MemorySegment GetModuleHandleA(MemorySegment lpModuleName) {
        var mh$ = GetModuleHandleA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetModuleHandleA", lpModuleName);
            }
            return (MemorySegment)mh$.invokeExact(lpModuleName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetModuleHandleW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetModuleHandleW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HMODULE GetModuleHandleW(LPCWSTR lpModuleName)
     * }
     */
    public static FunctionDescriptor GetModuleHandleW$descriptor() {
        return GetModuleHandleW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HMODULE GetModuleHandleW(LPCWSTR lpModuleName)
     * }
     */
    public static MethodHandle GetModuleHandleW$handle() {
        return GetModuleHandleW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * HMODULE GetModuleHandleW(LPCWSTR lpModuleName)
     * }
     */
    public static MemorySegment GetModuleHandleW(MemorySegment lpModuleName) {
        var mh$ = GetModuleHandleW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetModuleHandleW", lpModuleName);
            }
            return (MemorySegment)mh$.invokeExact(lpModuleName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetModuleHandleExA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_LONG,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetModuleHandleExA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetModuleHandleExA(DWORD dwFlags, LPCSTR lpModuleName, HMODULE *phModule)
     * }
     */
    public static FunctionDescriptor GetModuleHandleExA$descriptor() {
        return GetModuleHandleExA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetModuleHandleExA(DWORD dwFlags, LPCSTR lpModuleName, HMODULE *phModule)
     * }
     */
    public static MethodHandle GetModuleHandleExA$handle() {
        return GetModuleHandleExA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL GetModuleHandleExA(DWORD dwFlags, LPCSTR lpModuleName, HMODULE *phModule)
     * }
     */
    public static int GetModuleHandleExA(int dwFlags, MemorySegment lpModuleName, MemorySegment phModule) {
        var mh$ = GetModuleHandleExA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetModuleHandleExA", dwFlags, lpModuleName, phModule);
            }
            return (int)mh$.invokeExact(dwFlags, lpModuleName, phModule);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetModuleHandleExW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_LONG,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetModuleHandleExW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetModuleHandleExW(DWORD dwFlags, LPCWSTR lpModuleName, HMODULE *phModule)
     * }
     */
    public static FunctionDescriptor GetModuleHandleExW$descriptor() {
        return GetModuleHandleExW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetModuleHandleExW(DWORD dwFlags, LPCWSTR lpModuleName, HMODULE *phModule)
     * }
     */
    public static MethodHandle GetModuleHandleExW$handle() {
        return GetModuleHandleExW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL GetModuleHandleExW(DWORD dwFlags, LPCWSTR lpModuleName, HMODULE *phModule)
     * }
     */
    public static int GetModuleHandleExW(int dwFlags, MemorySegment lpModuleName, MemorySegment phModule) {
        var mh$ = GetModuleHandleExW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetModuleHandleExW", dwFlags, lpModuleName, phModule);
            }
            return (int)mh$.invokeExact(dwFlags, lpModuleName, phModule);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetProcAddress {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetProcAddress"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * FARPROC GetProcAddress(HMODULE hModule, LPCSTR lpProcName)
     * }
     */
    public static FunctionDescriptor GetProcAddress$descriptor() {
        return GetProcAddress.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * FARPROC GetProcAddress(HMODULE hModule, LPCSTR lpProcName)
     * }
     */
    public static MethodHandle GetProcAddress$handle() {
        return GetProcAddress.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * FARPROC GetProcAddress(HMODULE hModule, LPCSTR lpProcName)
     * }
     */
    public static MemorySegment GetProcAddress(MemorySegment hModule, MemorySegment lpProcName) {
        var mh$ = GetProcAddress.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetProcAddress", hModule, lpProcName);
            }
            return (MemorySegment)mh$.invokeExact(hModule, lpProcName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct _REDIRECTION_FUNCTION_DESCRIPTOR {
     *     PCSTR DllName;
     *     PCSTR FunctionName;
     *     PVOID RedirectionTarget;
     * } *PREDIRECTION_FUNCTION_DESCRIPTOR
     * }
     */
    public static final AddressLayout PREDIRECTION_FUNCTION_DESCRIPTOR = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef const REDIRECTION_FUNCTION_DESCRIPTOR *PCREDIRECTION_FUNCTION_DESCRIPTOR
     * }
     */
    public static final AddressLayout PCREDIRECTION_FUNCTION_DESCRIPTOR = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _REDIRECTION_DESCRIPTOR {
     *     ULONG Version;
     *     ULONG FunctionCount;
     *     PCREDIRECTION_FUNCTION_DESCRIPTOR Redirections;
     * } *PREDIRECTION_DESCRIPTOR
     * }
     */
    public static final AddressLayout PREDIRECTION_DESCRIPTOR = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef const REDIRECTION_DESCRIPTOR *PCREDIRECTION_DESCRIPTOR
     * }
     */
    public static final AddressLayout PCREDIRECTION_DESCRIPTOR = C_POINTER;

    private static class LoadLibraryExA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("LoadLibraryExA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HMODULE LoadLibraryExA(LPCSTR lpLibFileName, HANDLE hFile, DWORD dwFlags)
     * }
     */
    public static FunctionDescriptor LoadLibraryExA$descriptor() {
        return LoadLibraryExA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HMODULE LoadLibraryExA(LPCSTR lpLibFileName, HANDLE hFile, DWORD dwFlags)
     * }
     */
    public static MethodHandle LoadLibraryExA$handle() {
        return LoadLibraryExA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * HMODULE LoadLibraryExA(LPCSTR lpLibFileName, HANDLE hFile, DWORD dwFlags)
     * }
     */
    public static MemorySegment LoadLibraryExA(MemorySegment lpLibFileName, MemorySegment hFile, int dwFlags) {
        var mh$ = LoadLibraryExA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LoadLibraryExA", lpLibFileName, hFile, dwFlags);
            }
            return (MemorySegment)mh$.invokeExact(lpLibFileName, hFile, dwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LoadLibraryExW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("LoadLibraryExW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HMODULE LoadLibraryExW(LPCWSTR lpLibFileName, HANDLE hFile, DWORD dwFlags)
     * }
     */
    public static FunctionDescriptor LoadLibraryExW$descriptor() {
        return LoadLibraryExW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HMODULE LoadLibraryExW(LPCWSTR lpLibFileName, HANDLE hFile, DWORD dwFlags)
     * }
     */
    public static MethodHandle LoadLibraryExW$handle() {
        return LoadLibraryExW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * HMODULE LoadLibraryExW(LPCWSTR lpLibFileName, HANDLE hFile, DWORD dwFlags)
     * }
     */
    public static MemorySegment LoadLibraryExW(MemorySegment lpLibFileName, MemorySegment hFile, int dwFlags) {
        var mh$ = LoadLibraryExW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LoadLibraryExW", lpLibFileName, hFile, dwFlags);
            }
            return (MemorySegment)mh$.invokeExact(lpLibFileName, hFile, dwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LoadResource {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("LoadResource"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HGLOBAL LoadResource(HMODULE hModule, HRSRC hResInfo)
     * }
     */
    public static FunctionDescriptor LoadResource$descriptor() {
        return LoadResource.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HGLOBAL LoadResource(HMODULE hModule, HRSRC hResInfo)
     * }
     */
    public static MethodHandle LoadResource$handle() {
        return LoadResource.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * HGLOBAL LoadResource(HMODULE hModule, HRSRC hResInfo)
     * }
     */
    public static MemorySegment LoadResource(MemorySegment hModule, MemorySegment hResInfo) {
        var mh$ = LoadResource.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LoadResource", hModule, hResInfo);
            }
            return (MemorySegment)mh$.invokeExact(hModule, hResInfo);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LoadStringA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_INT,
            C_POINTER,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("LoadStringA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LoadStringA(HINSTANCE hInstance, UINT uID, LPSTR lpBuffer, int cchBufferMax)
     * }
     */
    public static FunctionDescriptor LoadStringA$descriptor() {
        return LoadStringA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LoadStringA(HINSTANCE hInstance, UINT uID, LPSTR lpBuffer, int cchBufferMax)
     * }
     */
    public static MethodHandle LoadStringA$handle() {
        return LoadStringA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int LoadStringA(HINSTANCE hInstance, UINT uID, LPSTR lpBuffer, int cchBufferMax)
     * }
     */
    public static int LoadStringA(MemorySegment hInstance, int uID, MemorySegment lpBuffer, int cchBufferMax) {
        var mh$ = LoadStringA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LoadStringA", hInstance, uID, lpBuffer, cchBufferMax);
            }
            return (int)mh$.invokeExact(hInstance, uID, lpBuffer, cchBufferMax);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LoadStringW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_INT,
            C_POINTER,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("LoadStringW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LoadStringW(HINSTANCE hInstance, UINT uID, LPWSTR lpBuffer, int cchBufferMax)
     * }
     */
    public static FunctionDescriptor LoadStringW$descriptor() {
        return LoadStringW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LoadStringW(HINSTANCE hInstance, UINT uID, LPWSTR lpBuffer, int cchBufferMax)
     * }
     */
    public static MethodHandle LoadStringW$handle() {
        return LoadStringW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int LoadStringW(HINSTANCE hInstance, UINT uID, LPWSTR lpBuffer, int cchBufferMax)
     * }
     */
    public static int LoadStringW(MemorySegment hInstance, int uID, MemorySegment lpBuffer, int cchBufferMax) {
        var mh$ = LoadStringW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LoadStringW", hInstance, uID, lpBuffer, cchBufferMax);
            }
            return (int)mh$.invokeExact(hInstance, uID, lpBuffer, cchBufferMax);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LockResource {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("LockResource"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LPVOID LockResource(HGLOBAL hResData)
     * }
     */
    public static FunctionDescriptor LockResource$descriptor() {
        return LockResource.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LPVOID LockResource(HGLOBAL hResData)
     * }
     */
    public static MethodHandle LockResource$handle() {
        return LockResource.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * LPVOID LockResource(HGLOBAL hResData)
     * }
     */
    public static MemorySegment LockResource(MemorySegment hResData) {
        var mh$ = LockResource.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LockResource", hResData);
            }
            return (MemorySegment)mh$.invokeExact(hResData);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SizeofResource {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("SizeofResource"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD SizeofResource(HMODULE hModule, HRSRC hResInfo)
     * }
     */
    public static FunctionDescriptor SizeofResource$descriptor() {
        return SizeofResource.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD SizeofResource(HMODULE hModule, HRSRC hResInfo)
     * }
     */
    public static MethodHandle SizeofResource$handle() {
        return SizeofResource.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * DWORD SizeofResource(HMODULE hModule, HRSRC hResInfo)
     * }
     */
    public static int SizeofResource(MemorySegment hModule, MemorySegment hResInfo) {
        var mh$ = SizeofResource.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SizeofResource", hModule, hResInfo);
            }
            return (int)mh$.invokeExact(hModule, hResInfo);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef PVOID DLL_DIRECTORY_COOKIE
     * }
     */
    public static final AddressLayout DLL_DIRECTORY_COOKIE = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef PVOID *PDLL_DIRECTORY_COOKIE
     * }
     */
    public static final AddressLayout PDLL_DIRECTORY_COOKIE = C_POINTER;

    private static class AddDllDirectory {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("AddDllDirectory"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DLL_DIRECTORY_COOKIE AddDllDirectory(PCWSTR NewDirectory)
     * }
     */
    public static FunctionDescriptor AddDllDirectory$descriptor() {
        return AddDllDirectory.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DLL_DIRECTORY_COOKIE AddDllDirectory(PCWSTR NewDirectory)
     * }
     */
    public static MethodHandle AddDllDirectory$handle() {
        return AddDllDirectory.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * DLL_DIRECTORY_COOKIE AddDllDirectory(PCWSTR NewDirectory)
     * }
     */
    public static MemorySegment AddDllDirectory(MemorySegment NewDirectory) {
        var mh$ = AddDllDirectory.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("AddDllDirectory", NewDirectory);
            }
            return (MemorySegment)mh$.invokeExact(NewDirectory);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RemoveDllDirectory {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("RemoveDllDirectory"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL RemoveDllDirectory(DLL_DIRECTORY_COOKIE Cookie)
     * }
     */
    public static FunctionDescriptor RemoveDllDirectory$descriptor() {
        return RemoveDllDirectory.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL RemoveDllDirectory(DLL_DIRECTORY_COOKIE Cookie)
     * }
     */
    public static MethodHandle RemoveDllDirectory$handle() {
        return RemoveDllDirectory.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL RemoveDllDirectory(DLL_DIRECTORY_COOKIE Cookie)
     * }
     */
    public static int RemoveDllDirectory(MemorySegment Cookie) {
        var mh$ = RemoveDllDirectory.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RemoveDllDirectory", Cookie);
            }
            return (int)mh$.invokeExact(Cookie);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetDefaultDllDirectories {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("SetDefaultDllDirectories"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetDefaultDllDirectories(DWORD DirectoryFlags)
     * }
     */
    public static FunctionDescriptor SetDefaultDllDirectories$descriptor() {
        return SetDefaultDllDirectories.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetDefaultDllDirectories(DWORD DirectoryFlags)
     * }
     */
    public static MethodHandle SetDefaultDllDirectories$handle() {
        return SetDefaultDllDirectories.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL SetDefaultDllDirectories(DWORD DirectoryFlags)
     * }
     */
    public static int SetDefaultDllDirectories(int DirectoryFlags) {
        var mh$ = SetDefaultDllDirectories.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetDefaultDllDirectories", DirectoryFlags);
            }
            return (int)mh$.invokeExact(DirectoryFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class EnumResourceLanguagesExA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_LONG_LONG,
            C_LONG,
            C_SHORT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("EnumResourceLanguagesExA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL EnumResourceLanguagesExA(HMODULE hModule, LPCSTR lpType, LPCSTR lpName, ENUMRESLANGPROCA lpEnumFunc, LONG_PTR lParam, DWORD dwFlags, LANGID LangId)
     * }
     */
    public static FunctionDescriptor EnumResourceLanguagesExA$descriptor() {
        return EnumResourceLanguagesExA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL EnumResourceLanguagesExA(HMODULE hModule, LPCSTR lpType, LPCSTR lpName, ENUMRESLANGPROCA lpEnumFunc, LONG_PTR lParam, DWORD dwFlags, LANGID LangId)
     * }
     */
    public static MethodHandle EnumResourceLanguagesExA$handle() {
        return EnumResourceLanguagesExA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL EnumResourceLanguagesExA(HMODULE hModule, LPCSTR lpType, LPCSTR lpName, ENUMRESLANGPROCA lpEnumFunc, LONG_PTR lParam, DWORD dwFlags, LANGID LangId)
     * }
     */
    public static int EnumResourceLanguagesExA(MemorySegment hModule, MemorySegment lpType, MemorySegment lpName, MemorySegment lpEnumFunc, long lParam, int dwFlags, short LangId) {
        var mh$ = EnumResourceLanguagesExA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("EnumResourceLanguagesExA", hModule, lpType, lpName, lpEnumFunc, lParam, dwFlags, LangId);
            }
            return (int)mh$.invokeExact(hModule, lpType, lpName, lpEnumFunc, lParam, dwFlags, LangId);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class EnumResourceLanguagesExW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_LONG_LONG,
            C_LONG,
            C_SHORT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("EnumResourceLanguagesExW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL EnumResourceLanguagesExW(HMODULE hModule, LPCWSTR lpType, LPCWSTR lpName, ENUMRESLANGPROCW lpEnumFunc, LONG_PTR lParam, DWORD dwFlags, LANGID LangId)
     * }
     */
    public static FunctionDescriptor EnumResourceLanguagesExW$descriptor() {
        return EnumResourceLanguagesExW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL EnumResourceLanguagesExW(HMODULE hModule, LPCWSTR lpType, LPCWSTR lpName, ENUMRESLANGPROCW lpEnumFunc, LONG_PTR lParam, DWORD dwFlags, LANGID LangId)
     * }
     */
    public static MethodHandle EnumResourceLanguagesExW$handle() {
        return EnumResourceLanguagesExW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL EnumResourceLanguagesExW(HMODULE hModule, LPCWSTR lpType, LPCWSTR lpName, ENUMRESLANGPROCW lpEnumFunc, LONG_PTR lParam, DWORD dwFlags, LANGID LangId)
     * }
     */
    public static int EnumResourceLanguagesExW(MemorySegment hModule, MemorySegment lpType, MemorySegment lpName, MemorySegment lpEnumFunc, long lParam, int dwFlags, short LangId) {
        var mh$ = EnumResourceLanguagesExW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("EnumResourceLanguagesExW", hModule, lpType, lpName, lpEnumFunc, lParam, dwFlags, LangId);
            }
            return (int)mh$.invokeExact(hModule, lpType, lpName, lpEnumFunc, lParam, dwFlags, LangId);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class EnumResourceNamesExA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_LONG_LONG,
            C_LONG,
            C_SHORT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("EnumResourceNamesExA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL EnumResourceNamesExA(HMODULE hModule, LPCSTR lpType, ENUMRESNAMEPROCA lpEnumFunc, LONG_PTR lParam, DWORD dwFlags, LANGID LangId)
     * }
     */
    public static FunctionDescriptor EnumResourceNamesExA$descriptor() {
        return EnumResourceNamesExA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL EnumResourceNamesExA(HMODULE hModule, LPCSTR lpType, ENUMRESNAMEPROCA lpEnumFunc, LONG_PTR lParam, DWORD dwFlags, LANGID LangId)
     * }
     */
    public static MethodHandle EnumResourceNamesExA$handle() {
        return EnumResourceNamesExA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL EnumResourceNamesExA(HMODULE hModule, LPCSTR lpType, ENUMRESNAMEPROCA lpEnumFunc, LONG_PTR lParam, DWORD dwFlags, LANGID LangId)
     * }
     */
    public static int EnumResourceNamesExA(MemorySegment hModule, MemorySegment lpType, MemorySegment lpEnumFunc, long lParam, int dwFlags, short LangId) {
        var mh$ = EnumResourceNamesExA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("EnumResourceNamesExA", hModule, lpType, lpEnumFunc, lParam, dwFlags, LangId);
            }
            return (int)mh$.invokeExact(hModule, lpType, lpEnumFunc, lParam, dwFlags, LangId);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class EnumResourceNamesExW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_LONG_LONG,
            C_LONG,
            C_SHORT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("EnumResourceNamesExW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL EnumResourceNamesExW(HMODULE hModule, LPCWSTR lpType, ENUMRESNAMEPROCW lpEnumFunc, LONG_PTR lParam, DWORD dwFlags, LANGID LangId)
     * }
     */
    public static FunctionDescriptor EnumResourceNamesExW$descriptor() {
        return EnumResourceNamesExW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL EnumResourceNamesExW(HMODULE hModule, LPCWSTR lpType, ENUMRESNAMEPROCW lpEnumFunc, LONG_PTR lParam, DWORD dwFlags, LANGID LangId)
     * }
     */
    public static MethodHandle EnumResourceNamesExW$handle() {
        return EnumResourceNamesExW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL EnumResourceNamesExW(HMODULE hModule, LPCWSTR lpType, ENUMRESNAMEPROCW lpEnumFunc, LONG_PTR lParam, DWORD dwFlags, LANGID LangId)
     * }
     */
    public static int EnumResourceNamesExW(MemorySegment hModule, MemorySegment lpType, MemorySegment lpEnumFunc, long lParam, int dwFlags, short LangId) {
        var mh$ = EnumResourceNamesExW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("EnumResourceNamesExW", hModule, lpType, lpEnumFunc, lParam, dwFlags, LangId);
            }
            return (int)mh$.invokeExact(hModule, lpType, lpEnumFunc, lParam, dwFlags, LangId);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class EnumResourceTypesExA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_LONG_LONG,
            C_LONG,
            C_SHORT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("EnumResourceTypesExA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL EnumResourceTypesExA(HMODULE hModule, ENUMRESTYPEPROCA lpEnumFunc, LONG_PTR lParam, DWORD dwFlags, LANGID LangId)
     * }
     */
    public static FunctionDescriptor EnumResourceTypesExA$descriptor() {
        return EnumResourceTypesExA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL EnumResourceTypesExA(HMODULE hModule, ENUMRESTYPEPROCA lpEnumFunc, LONG_PTR lParam, DWORD dwFlags, LANGID LangId)
     * }
     */
    public static MethodHandle EnumResourceTypesExA$handle() {
        return EnumResourceTypesExA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL EnumResourceTypesExA(HMODULE hModule, ENUMRESTYPEPROCA lpEnumFunc, LONG_PTR lParam, DWORD dwFlags, LANGID LangId)
     * }
     */
    public static int EnumResourceTypesExA(MemorySegment hModule, MemorySegment lpEnumFunc, long lParam, int dwFlags, short LangId) {
        var mh$ = EnumResourceTypesExA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("EnumResourceTypesExA", hModule, lpEnumFunc, lParam, dwFlags, LangId);
            }
            return (int)mh$.invokeExact(hModule, lpEnumFunc, lParam, dwFlags, LangId);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class EnumResourceTypesExW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_LONG_LONG,
            C_LONG,
            C_SHORT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("EnumResourceTypesExW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL EnumResourceTypesExW(HMODULE hModule, ENUMRESTYPEPROCW lpEnumFunc, LONG_PTR lParam, DWORD dwFlags, LANGID LangId)
     * }
     */
    public static FunctionDescriptor EnumResourceTypesExW$descriptor() {
        return EnumResourceTypesExW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL EnumResourceTypesExW(HMODULE hModule, ENUMRESTYPEPROCW lpEnumFunc, LONG_PTR lParam, DWORD dwFlags, LANGID LangId)
     * }
     */
    public static MethodHandle EnumResourceTypesExW$handle() {
        return EnumResourceTypesExW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL EnumResourceTypesExW(HMODULE hModule, ENUMRESTYPEPROCW lpEnumFunc, LONG_PTR lParam, DWORD dwFlags, LANGID LangId)
     * }
     */
    public static int EnumResourceTypesExW(MemorySegment hModule, MemorySegment lpEnumFunc, long lParam, int dwFlags, short LangId) {
        var mh$ = EnumResourceTypesExW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("EnumResourceTypesExW", hModule, lpEnumFunc, lParam, dwFlags, LangId);
            }
            return (int)mh$.invokeExact(hModule, lpEnumFunc, lParam, dwFlags, LangId);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FindResourceW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("FindResourceW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HRSRC FindResourceW(HMODULE hModule, LPCWSTR lpName, LPCWSTR lpType)
     * }
     */
    public static FunctionDescriptor FindResourceW$descriptor() {
        return FindResourceW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HRSRC FindResourceW(HMODULE hModule, LPCWSTR lpName, LPCWSTR lpType)
     * }
     */
    public static MethodHandle FindResourceW$handle() {
        return FindResourceW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * HRSRC FindResourceW(HMODULE hModule, LPCWSTR lpName, LPCWSTR lpType)
     * }
     */
    public static MemorySegment FindResourceW(MemorySegment hModule, MemorySegment lpName, MemorySegment lpType) {
        var mh$ = FindResourceW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FindResourceW", hModule, lpName, lpType);
            }
            return (MemorySegment)mh$.invokeExact(hModule, lpName, lpType);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LoadLibraryA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("LoadLibraryA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HMODULE LoadLibraryA(LPCSTR lpLibFileName)
     * }
     */
    public static FunctionDescriptor LoadLibraryA$descriptor() {
        return LoadLibraryA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HMODULE LoadLibraryA(LPCSTR lpLibFileName)
     * }
     */
    public static MethodHandle LoadLibraryA$handle() {
        return LoadLibraryA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * HMODULE LoadLibraryA(LPCSTR lpLibFileName)
     * }
     */
    public static MemorySegment LoadLibraryA(MemorySegment lpLibFileName) {
        var mh$ = LoadLibraryA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LoadLibraryA", lpLibFileName);
            }
            return (MemorySegment)mh$.invokeExact(lpLibFileName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LoadLibraryW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("LoadLibraryW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HMODULE LoadLibraryW(LPCWSTR lpLibFileName)
     * }
     */
    public static FunctionDescriptor LoadLibraryW$descriptor() {
        return LoadLibraryW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HMODULE LoadLibraryW(LPCWSTR lpLibFileName)
     * }
     */
    public static MethodHandle LoadLibraryW$handle() {
        return LoadLibraryW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * HMODULE LoadLibraryW(LPCWSTR lpLibFileName)
     * }
     */
    public static MemorySegment LoadLibraryW(MemorySegment lpLibFileName) {
        var mh$ = LoadLibraryW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LoadLibraryW", lpLibFileName);
            }
            return (MemorySegment)mh$.invokeExact(lpLibFileName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class EnumResourceNamesW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_LONG_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("EnumResourceNamesW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL EnumResourceNamesW(HMODULE hModule, LPCWSTR lpType, ENUMRESNAMEPROCW lpEnumFunc, LONG_PTR lParam)
     * }
     */
    public static FunctionDescriptor EnumResourceNamesW$descriptor() {
        return EnumResourceNamesW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL EnumResourceNamesW(HMODULE hModule, LPCWSTR lpType, ENUMRESNAMEPROCW lpEnumFunc, LONG_PTR lParam)
     * }
     */
    public static MethodHandle EnumResourceNamesW$handle() {
        return EnumResourceNamesW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL EnumResourceNamesW(HMODULE hModule, LPCWSTR lpType, ENUMRESNAMEPROCW lpEnumFunc, LONG_PTR lParam)
     * }
     */
    public static int EnumResourceNamesW(MemorySegment hModule, MemorySegment lpType, MemorySegment lpEnumFunc, long lParam) {
        var mh$ = EnumResourceNamesW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("EnumResourceNamesW", hModule, lpType, lpEnumFunc, lParam);
            }
            return (int)mh$.invokeExact(hModule, lpType, lpEnumFunc, lParam);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class EnumResourceNamesA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_LONG_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("EnumResourceNamesA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL EnumResourceNamesA(HMODULE hModule, LPCSTR lpType, ENUMRESNAMEPROCA lpEnumFunc, LONG_PTR lParam)
     * }
     */
    public static FunctionDescriptor EnumResourceNamesA$descriptor() {
        return EnumResourceNamesA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL EnumResourceNamesA(HMODULE hModule, LPCSTR lpType, ENUMRESNAMEPROCA lpEnumFunc, LONG_PTR lParam)
     * }
     */
    public static MethodHandle EnumResourceNamesA$handle() {
        return EnumResourceNamesA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL EnumResourceNamesA(HMODULE hModule, LPCSTR lpType, ENUMRESNAMEPROCA lpEnumFunc, LONG_PTR lParam)
     * }
     */
    public static int EnumResourceNamesA(MemorySegment hModule, MemorySegment lpType, MemorySegment lpEnumFunc, long lParam) {
        var mh$ = EnumResourceNamesA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("EnumResourceNamesA", hModule, lpType, lpEnumFunc, lParam);
            }
            return (int)mh$.invokeExact(hModule, lpType, lpEnumFunc, lParam);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class AccessCheck {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_LONG,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("AccessCheck"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL AccessCheck(PSECURITY_DESCRIPTOR pSecurityDescriptor, HANDLE ClientToken, DWORD DesiredAccess, PGENERIC_MAPPING GenericMapping, PPRIVILEGE_SET PrivilegeSet, LPDWORD PrivilegeSetLength, LPDWORD GrantedAccess, LPBOOL AccessStatus)
     * }
     */
    public static FunctionDescriptor AccessCheck$descriptor() {
        return AccessCheck.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL AccessCheck(PSECURITY_DESCRIPTOR pSecurityDescriptor, HANDLE ClientToken, DWORD DesiredAccess, PGENERIC_MAPPING GenericMapping, PPRIVILEGE_SET PrivilegeSet, LPDWORD PrivilegeSetLength, LPDWORD GrantedAccess, LPBOOL AccessStatus)
     * }
     */
    public static MethodHandle AccessCheck$handle() {
        return AccessCheck.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL AccessCheck(PSECURITY_DESCRIPTOR pSecurityDescriptor, HANDLE ClientToken, DWORD DesiredAccess, PGENERIC_MAPPING GenericMapping, PPRIVILEGE_SET PrivilegeSet, LPDWORD PrivilegeSetLength, LPDWORD GrantedAccess, LPBOOL AccessStatus)
     * }
     */
    public static int AccessCheck(MemorySegment pSecurityDescriptor, MemorySegment ClientToken, int DesiredAccess, MemorySegment GenericMapping, MemorySegment PrivilegeSet, MemorySegment PrivilegeSetLength, MemorySegment GrantedAccess, MemorySegment AccessStatus) {
        var mh$ = AccessCheck.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("AccessCheck", pSecurityDescriptor, ClientToken, DesiredAccess, GenericMapping, PrivilegeSet, PrivilegeSetLength, GrantedAccess, AccessStatus);
            }
            return (int)mh$.invokeExact(pSecurityDescriptor, ClientToken, DesiredAccess, GenericMapping, PrivilegeSet, PrivilegeSetLength, GrantedAccess, AccessStatus);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class AccessCheckAndAuditAlarmW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_LONG,
            C_POINTER,
            C_INT,
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("AccessCheckAndAuditAlarmW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL AccessCheckAndAuditAlarmW(LPCWSTR SubsystemName, LPVOID HandleId, LPWSTR ObjectTypeName, LPWSTR ObjectName, PSECURITY_DESCRIPTOR SecurityDescriptor, DWORD DesiredAccess, PGENERIC_MAPPING GenericMapping, BOOL ObjectCreation, LPDWORD GrantedAccess, LPBOOL AccessStatus, LPBOOL pfGenerateOnClose)
     * }
     */
    public static FunctionDescriptor AccessCheckAndAuditAlarmW$descriptor() {
        return AccessCheckAndAuditAlarmW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL AccessCheckAndAuditAlarmW(LPCWSTR SubsystemName, LPVOID HandleId, LPWSTR ObjectTypeName, LPWSTR ObjectName, PSECURITY_DESCRIPTOR SecurityDescriptor, DWORD DesiredAccess, PGENERIC_MAPPING GenericMapping, BOOL ObjectCreation, LPDWORD GrantedAccess, LPBOOL AccessStatus, LPBOOL pfGenerateOnClose)
     * }
     */
    public static MethodHandle AccessCheckAndAuditAlarmW$handle() {
        return AccessCheckAndAuditAlarmW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL AccessCheckAndAuditAlarmW(LPCWSTR SubsystemName, LPVOID HandleId, LPWSTR ObjectTypeName, LPWSTR ObjectName, PSECURITY_DESCRIPTOR SecurityDescriptor, DWORD DesiredAccess, PGENERIC_MAPPING GenericMapping, BOOL ObjectCreation, LPDWORD GrantedAccess, LPBOOL AccessStatus, LPBOOL pfGenerateOnClose)
     * }
     */
    public static int AccessCheckAndAuditAlarmW(MemorySegment SubsystemName, MemorySegment HandleId, MemorySegment ObjectTypeName, MemorySegment ObjectName, MemorySegment SecurityDescriptor, int DesiredAccess, MemorySegment GenericMapping, int ObjectCreation, MemorySegment GrantedAccess, MemorySegment AccessStatus, MemorySegment pfGenerateOnClose) {
        var mh$ = AccessCheckAndAuditAlarmW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("AccessCheckAndAuditAlarmW", SubsystemName, HandleId, ObjectTypeName, ObjectName, SecurityDescriptor, DesiredAccess, GenericMapping, ObjectCreation, GrantedAccess, AccessStatus, pfGenerateOnClose);
            }
            return (int)mh$.invokeExact(SubsystemName, HandleId, ObjectTypeName, ObjectName, SecurityDescriptor, DesiredAccess, GenericMapping, ObjectCreation, GrantedAccess, AccessStatus, pfGenerateOnClose);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class AccessCheckByType {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_LONG,
            C_POINTER,
            C_LONG,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("AccessCheckByType"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL AccessCheckByType(PSECURITY_DESCRIPTOR pSecurityDescriptor, PSID PrincipalSelfSid, HANDLE ClientToken, DWORD DesiredAccess, POBJECT_TYPE_LIST ObjectTypeList, DWORD ObjectTypeListLength, PGENERIC_MAPPING GenericMapping, PPRIVILEGE_SET PrivilegeSet, LPDWORD PrivilegeSetLength, LPDWORD GrantedAccess, LPBOOL AccessStatus)
     * }
     */
    public static FunctionDescriptor AccessCheckByType$descriptor() {
        return AccessCheckByType.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL AccessCheckByType(PSECURITY_DESCRIPTOR pSecurityDescriptor, PSID PrincipalSelfSid, HANDLE ClientToken, DWORD DesiredAccess, POBJECT_TYPE_LIST ObjectTypeList, DWORD ObjectTypeListLength, PGENERIC_MAPPING GenericMapping, PPRIVILEGE_SET PrivilegeSet, LPDWORD PrivilegeSetLength, LPDWORD GrantedAccess, LPBOOL AccessStatus)
     * }
     */
    public static MethodHandle AccessCheckByType$handle() {
        return AccessCheckByType.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL AccessCheckByType(PSECURITY_DESCRIPTOR pSecurityDescriptor, PSID PrincipalSelfSid, HANDLE ClientToken, DWORD DesiredAccess, POBJECT_TYPE_LIST ObjectTypeList, DWORD ObjectTypeListLength, PGENERIC_MAPPING GenericMapping, PPRIVILEGE_SET PrivilegeSet, LPDWORD PrivilegeSetLength, LPDWORD GrantedAccess, LPBOOL AccessStatus)
     * }
     */
    public static int AccessCheckByType(MemorySegment pSecurityDescriptor, MemorySegment PrincipalSelfSid, MemorySegment ClientToken, int DesiredAccess, MemorySegment ObjectTypeList, int ObjectTypeListLength, MemorySegment GenericMapping, MemorySegment PrivilegeSet, MemorySegment PrivilegeSetLength, MemorySegment GrantedAccess, MemorySegment AccessStatus) {
        var mh$ = AccessCheckByType.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("AccessCheckByType", pSecurityDescriptor, PrincipalSelfSid, ClientToken, DesiredAccess, ObjectTypeList, ObjectTypeListLength, GenericMapping, PrivilegeSet, PrivilegeSetLength, GrantedAccess, AccessStatus);
            }
            return (int)mh$.invokeExact(pSecurityDescriptor, PrincipalSelfSid, ClientToken, DesiredAccess, ObjectTypeList, ObjectTypeListLength, GenericMapping, PrivilegeSet, PrivilegeSetLength, GrantedAccess, AccessStatus);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class AccessCheckByTypeResultList {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_LONG,
            C_POINTER,
            C_LONG,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("AccessCheckByTypeResultList"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL AccessCheckByTypeResultList(PSECURITY_DESCRIPTOR pSecurityDescriptor, PSID PrincipalSelfSid, HANDLE ClientToken, DWORD DesiredAccess, POBJECT_TYPE_LIST ObjectTypeList, DWORD ObjectTypeListLength, PGENERIC_MAPPING GenericMapping, PPRIVILEGE_SET PrivilegeSet, LPDWORD PrivilegeSetLength, LPDWORD GrantedAccessList, LPDWORD AccessStatusList)
     * }
     */
    public static FunctionDescriptor AccessCheckByTypeResultList$descriptor() {
        return AccessCheckByTypeResultList.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL AccessCheckByTypeResultList(PSECURITY_DESCRIPTOR pSecurityDescriptor, PSID PrincipalSelfSid, HANDLE ClientToken, DWORD DesiredAccess, POBJECT_TYPE_LIST ObjectTypeList, DWORD ObjectTypeListLength, PGENERIC_MAPPING GenericMapping, PPRIVILEGE_SET PrivilegeSet, LPDWORD PrivilegeSetLength, LPDWORD GrantedAccessList, LPDWORD AccessStatusList)
     * }
     */
    public static MethodHandle AccessCheckByTypeResultList$handle() {
        return AccessCheckByTypeResultList.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL AccessCheckByTypeResultList(PSECURITY_DESCRIPTOR pSecurityDescriptor, PSID PrincipalSelfSid, HANDLE ClientToken, DWORD DesiredAccess, POBJECT_TYPE_LIST ObjectTypeList, DWORD ObjectTypeListLength, PGENERIC_MAPPING GenericMapping, PPRIVILEGE_SET PrivilegeSet, LPDWORD PrivilegeSetLength, LPDWORD GrantedAccessList, LPDWORD AccessStatusList)
     * }
     */
    public static int AccessCheckByTypeResultList(MemorySegment pSecurityDescriptor, MemorySegment PrincipalSelfSid, MemorySegment ClientToken, int DesiredAccess, MemorySegment ObjectTypeList, int ObjectTypeListLength, MemorySegment GenericMapping, MemorySegment PrivilegeSet, MemorySegment PrivilegeSetLength, MemorySegment GrantedAccessList, MemorySegment AccessStatusList) {
        var mh$ = AccessCheckByTypeResultList.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("AccessCheckByTypeResultList", pSecurityDescriptor, PrincipalSelfSid, ClientToken, DesiredAccess, ObjectTypeList, ObjectTypeListLength, GenericMapping, PrivilegeSet, PrivilegeSetLength, GrantedAccessList, AccessStatusList);
            }
            return (int)mh$.invokeExact(pSecurityDescriptor, PrincipalSelfSid, ClientToken, DesiredAccess, ObjectTypeList, ObjectTypeListLength, GenericMapping, PrivilegeSet, PrivilegeSetLength, GrantedAccessList, AccessStatusList);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class AccessCheckByTypeAndAuditAlarmW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_LONG,
            C_INT,
            C_LONG,
            C_POINTER,
            C_LONG,
            C_POINTER,
            C_INT,
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("AccessCheckByTypeAndAuditAlarmW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL AccessCheckByTypeAndAuditAlarmW(LPCWSTR SubsystemName, LPVOID HandleId, LPCWSTR ObjectTypeName, LPCWSTR ObjectName, PSECURITY_DESCRIPTOR SecurityDescriptor, PSID PrincipalSelfSid, DWORD DesiredAccess, AUDIT_EVENT_TYPE AuditType, DWORD Flags, POBJECT_TYPE_LIST ObjectTypeList, DWORD ObjectTypeListLength, PGENERIC_MAPPING GenericMapping, BOOL ObjectCreation, LPDWORD GrantedAccess, LPBOOL AccessStatus, LPBOOL pfGenerateOnClose)
     * }
     */
    public static FunctionDescriptor AccessCheckByTypeAndAuditAlarmW$descriptor() {
        return AccessCheckByTypeAndAuditAlarmW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL AccessCheckByTypeAndAuditAlarmW(LPCWSTR SubsystemName, LPVOID HandleId, LPCWSTR ObjectTypeName, LPCWSTR ObjectName, PSECURITY_DESCRIPTOR SecurityDescriptor, PSID PrincipalSelfSid, DWORD DesiredAccess, AUDIT_EVENT_TYPE AuditType, DWORD Flags, POBJECT_TYPE_LIST ObjectTypeList, DWORD ObjectTypeListLength, PGENERIC_MAPPING GenericMapping, BOOL ObjectCreation, LPDWORD GrantedAccess, LPBOOL AccessStatus, LPBOOL pfGenerateOnClose)
     * }
     */
    public static MethodHandle AccessCheckByTypeAndAuditAlarmW$handle() {
        return AccessCheckByTypeAndAuditAlarmW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL AccessCheckByTypeAndAuditAlarmW(LPCWSTR SubsystemName, LPVOID HandleId, LPCWSTR ObjectTypeName, LPCWSTR ObjectName, PSECURITY_DESCRIPTOR SecurityDescriptor, PSID PrincipalSelfSid, DWORD DesiredAccess, AUDIT_EVENT_TYPE AuditType, DWORD Flags, POBJECT_TYPE_LIST ObjectTypeList, DWORD ObjectTypeListLength, PGENERIC_MAPPING GenericMapping, BOOL ObjectCreation, LPDWORD GrantedAccess, LPBOOL AccessStatus, LPBOOL pfGenerateOnClose)
     * }
     */
    public static int AccessCheckByTypeAndAuditAlarmW(MemorySegment SubsystemName, MemorySegment HandleId, MemorySegment ObjectTypeName, MemorySegment ObjectName, MemorySegment SecurityDescriptor, MemorySegment PrincipalSelfSid, int DesiredAccess, int AuditType, int Flags, MemorySegment ObjectTypeList, int ObjectTypeListLength, MemorySegment GenericMapping, int ObjectCreation, MemorySegment GrantedAccess, MemorySegment AccessStatus, MemorySegment pfGenerateOnClose) {
        var mh$ = AccessCheckByTypeAndAuditAlarmW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("AccessCheckByTypeAndAuditAlarmW", SubsystemName, HandleId, ObjectTypeName, ObjectName, SecurityDescriptor, PrincipalSelfSid, DesiredAccess, AuditType, Flags, ObjectTypeList, ObjectTypeListLength, GenericMapping, ObjectCreation, GrantedAccess, AccessStatus, pfGenerateOnClose);
            }
            return (int)mh$.invokeExact(SubsystemName, HandleId, ObjectTypeName, ObjectName, SecurityDescriptor, PrincipalSelfSid, DesiredAccess, AuditType, Flags, ObjectTypeList, ObjectTypeListLength, GenericMapping, ObjectCreation, GrantedAccess, AccessStatus, pfGenerateOnClose);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class AccessCheckByTypeResultListAndAuditAlarmW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_LONG,
            C_INT,
            C_LONG,
            C_POINTER,
            C_LONG,
            C_POINTER,
            C_INT,
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("AccessCheckByTypeResultListAndAuditAlarmW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL AccessCheckByTypeResultListAndAuditAlarmW(LPCWSTR SubsystemName, LPVOID HandleId, LPCWSTR ObjectTypeName, LPCWSTR ObjectName, PSECURITY_DESCRIPTOR SecurityDescriptor, PSID PrincipalSelfSid, DWORD DesiredAccess, AUDIT_EVENT_TYPE AuditType, DWORD Flags, POBJECT_TYPE_LIST ObjectTypeList, DWORD ObjectTypeListLength, PGENERIC_MAPPING GenericMapping, BOOL ObjectCreation, LPDWORD GrantedAccessList, LPDWORD AccessStatusList, LPBOOL pfGenerateOnClose)
     * }
     */
    public static FunctionDescriptor AccessCheckByTypeResultListAndAuditAlarmW$descriptor() {
        return AccessCheckByTypeResultListAndAuditAlarmW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL AccessCheckByTypeResultListAndAuditAlarmW(LPCWSTR SubsystemName, LPVOID HandleId, LPCWSTR ObjectTypeName, LPCWSTR ObjectName, PSECURITY_DESCRIPTOR SecurityDescriptor, PSID PrincipalSelfSid, DWORD DesiredAccess, AUDIT_EVENT_TYPE AuditType, DWORD Flags, POBJECT_TYPE_LIST ObjectTypeList, DWORD ObjectTypeListLength, PGENERIC_MAPPING GenericMapping, BOOL ObjectCreation, LPDWORD GrantedAccessList, LPDWORD AccessStatusList, LPBOOL pfGenerateOnClose)
     * }
     */
    public static MethodHandle AccessCheckByTypeResultListAndAuditAlarmW$handle() {
        return AccessCheckByTypeResultListAndAuditAlarmW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL AccessCheckByTypeResultListAndAuditAlarmW(LPCWSTR SubsystemName, LPVOID HandleId, LPCWSTR ObjectTypeName, LPCWSTR ObjectName, PSECURITY_DESCRIPTOR SecurityDescriptor, PSID PrincipalSelfSid, DWORD DesiredAccess, AUDIT_EVENT_TYPE AuditType, DWORD Flags, POBJECT_TYPE_LIST ObjectTypeList, DWORD ObjectTypeListLength, PGENERIC_MAPPING GenericMapping, BOOL ObjectCreation, LPDWORD GrantedAccessList, LPDWORD AccessStatusList, LPBOOL pfGenerateOnClose)
     * }
     */
    public static int AccessCheckByTypeResultListAndAuditAlarmW(MemorySegment SubsystemName, MemorySegment HandleId, MemorySegment ObjectTypeName, MemorySegment ObjectName, MemorySegment SecurityDescriptor, MemorySegment PrincipalSelfSid, int DesiredAccess, int AuditType, int Flags, MemorySegment ObjectTypeList, int ObjectTypeListLength, MemorySegment GenericMapping, int ObjectCreation, MemorySegment GrantedAccessList, MemorySegment AccessStatusList, MemorySegment pfGenerateOnClose) {
        var mh$ = AccessCheckByTypeResultListAndAuditAlarmW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("AccessCheckByTypeResultListAndAuditAlarmW", SubsystemName, HandleId, ObjectTypeName, ObjectName, SecurityDescriptor, PrincipalSelfSid, DesiredAccess, AuditType, Flags, ObjectTypeList, ObjectTypeListLength, GenericMapping, ObjectCreation, GrantedAccessList, AccessStatusList, pfGenerateOnClose);
            }
            return (int)mh$.invokeExact(SubsystemName, HandleId, ObjectTypeName, ObjectName, SecurityDescriptor, PrincipalSelfSid, DesiredAccess, AuditType, Flags, ObjectTypeList, ObjectTypeListLength, GenericMapping, ObjectCreation, GrantedAccessList, AccessStatusList, pfGenerateOnClose);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class AccessCheckByTypeResultListAndAuditAlarmByHandleW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_LONG,
            C_INT,
            C_LONG,
            C_POINTER,
            C_LONG,
            C_POINTER,
            C_INT,
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("AccessCheckByTypeResultListAndAuditAlarmByHandleW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL AccessCheckByTypeResultListAndAuditAlarmByHandleW(LPCWSTR SubsystemName, LPVOID HandleId, HANDLE ClientToken, LPCWSTR ObjectTypeName, LPCWSTR ObjectName, PSECURITY_DESCRIPTOR SecurityDescriptor, PSID PrincipalSelfSid, DWORD DesiredAccess, AUDIT_EVENT_TYPE AuditType, DWORD Flags, POBJECT_TYPE_LIST ObjectTypeList, DWORD ObjectTypeListLength, PGENERIC_MAPPING GenericMapping, BOOL ObjectCreation, LPDWORD GrantedAccessList, LPDWORD AccessStatusList, LPBOOL pfGenerateOnClose)
     * }
     */
    public static FunctionDescriptor AccessCheckByTypeResultListAndAuditAlarmByHandleW$descriptor() {
        return AccessCheckByTypeResultListAndAuditAlarmByHandleW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL AccessCheckByTypeResultListAndAuditAlarmByHandleW(LPCWSTR SubsystemName, LPVOID HandleId, HANDLE ClientToken, LPCWSTR ObjectTypeName, LPCWSTR ObjectName, PSECURITY_DESCRIPTOR SecurityDescriptor, PSID PrincipalSelfSid, DWORD DesiredAccess, AUDIT_EVENT_TYPE AuditType, DWORD Flags, POBJECT_TYPE_LIST ObjectTypeList, DWORD ObjectTypeListLength, PGENERIC_MAPPING GenericMapping, BOOL ObjectCreation, LPDWORD GrantedAccessList, LPDWORD AccessStatusList, LPBOOL pfGenerateOnClose)
     * }
     */
    public static MethodHandle AccessCheckByTypeResultListAndAuditAlarmByHandleW$handle() {
        return AccessCheckByTypeResultListAndAuditAlarmByHandleW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL AccessCheckByTypeResultListAndAuditAlarmByHandleW(LPCWSTR SubsystemName, LPVOID HandleId, HANDLE ClientToken, LPCWSTR ObjectTypeName, LPCWSTR ObjectName, PSECURITY_DESCRIPTOR SecurityDescriptor, PSID PrincipalSelfSid, DWORD DesiredAccess, AUDIT_EVENT_TYPE AuditType, DWORD Flags, POBJECT_TYPE_LIST ObjectTypeList, DWORD ObjectTypeListLength, PGENERIC_MAPPING GenericMapping, BOOL ObjectCreation, LPDWORD GrantedAccessList, LPDWORD AccessStatusList, LPBOOL pfGenerateOnClose)
     * }
     */
    public static int AccessCheckByTypeResultListAndAuditAlarmByHandleW(MemorySegment SubsystemName, MemorySegment HandleId, MemorySegment ClientToken, MemorySegment ObjectTypeName, MemorySegment ObjectName, MemorySegment SecurityDescriptor, MemorySegment PrincipalSelfSid, int DesiredAccess, int AuditType, int Flags, MemorySegment ObjectTypeList, int ObjectTypeListLength, MemorySegment GenericMapping, int ObjectCreation, MemorySegment GrantedAccessList, MemorySegment AccessStatusList, MemorySegment pfGenerateOnClose) {
        var mh$ = AccessCheckByTypeResultListAndAuditAlarmByHandleW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("AccessCheckByTypeResultListAndAuditAlarmByHandleW", SubsystemName, HandleId, ClientToken, ObjectTypeName, ObjectName, SecurityDescriptor, PrincipalSelfSid, DesiredAccess, AuditType, Flags, ObjectTypeList, ObjectTypeListLength, GenericMapping, ObjectCreation, GrantedAccessList, AccessStatusList, pfGenerateOnClose);
            }
            return (int)mh$.invokeExact(SubsystemName, HandleId, ClientToken, ObjectTypeName, ObjectName, SecurityDescriptor, PrincipalSelfSid, DesiredAccess, AuditType, Flags, ObjectTypeList, ObjectTypeListLength, GenericMapping, ObjectCreation, GrantedAccessList, AccessStatusList, pfGenerateOnClose);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class AddAccessAllowedAce {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_LONG,
            C_LONG,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("AddAccessAllowedAce"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL AddAccessAllowedAce(PACL pAcl, DWORD dwAceRevision, DWORD AccessMask, PSID pSid)
     * }
     */
    public static FunctionDescriptor AddAccessAllowedAce$descriptor() {
        return AddAccessAllowedAce.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL AddAccessAllowedAce(PACL pAcl, DWORD dwAceRevision, DWORD AccessMask, PSID pSid)
     * }
     */
    public static MethodHandle AddAccessAllowedAce$handle() {
        return AddAccessAllowedAce.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL AddAccessAllowedAce(PACL pAcl, DWORD dwAceRevision, DWORD AccessMask, PSID pSid)
     * }
     */
    public static int AddAccessAllowedAce(MemorySegment pAcl, int dwAceRevision, int AccessMask, MemorySegment pSid) {
        var mh$ = AddAccessAllowedAce.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("AddAccessAllowedAce", pAcl, dwAceRevision, AccessMask, pSid);
            }
            return (int)mh$.invokeExact(pAcl, dwAceRevision, AccessMask, pSid);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class AddAccessAllowedAceEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_LONG,
            C_LONG,
            C_LONG,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("AddAccessAllowedAceEx"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL AddAccessAllowedAceEx(PACL pAcl, DWORD dwAceRevision, DWORD AceFlags, DWORD AccessMask, PSID pSid)
     * }
     */
    public static FunctionDescriptor AddAccessAllowedAceEx$descriptor() {
        return AddAccessAllowedAceEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL AddAccessAllowedAceEx(PACL pAcl, DWORD dwAceRevision, DWORD AceFlags, DWORD AccessMask, PSID pSid)
     * }
     */
    public static MethodHandle AddAccessAllowedAceEx$handle() {
        return AddAccessAllowedAceEx.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL AddAccessAllowedAceEx(PACL pAcl, DWORD dwAceRevision, DWORD AceFlags, DWORD AccessMask, PSID pSid)
     * }
     */
    public static int AddAccessAllowedAceEx(MemorySegment pAcl, int dwAceRevision, int AceFlags, int AccessMask, MemorySegment pSid) {
        var mh$ = AddAccessAllowedAceEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("AddAccessAllowedAceEx", pAcl, dwAceRevision, AceFlags, AccessMask, pSid);
            }
            return (int)mh$.invokeExact(pAcl, dwAceRevision, AceFlags, AccessMask, pSid);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class AddAccessAllowedObjectAce {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_LONG,
            C_LONG,
            C_LONG,
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("AddAccessAllowedObjectAce"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL AddAccessAllowedObjectAce(PACL pAcl, DWORD dwAceRevision, DWORD AceFlags, DWORD AccessMask, GUID *ObjectTypeGuid, GUID *InheritedObjectTypeGuid, PSID pSid)
     * }
     */
    public static FunctionDescriptor AddAccessAllowedObjectAce$descriptor() {
        return AddAccessAllowedObjectAce.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL AddAccessAllowedObjectAce(PACL pAcl, DWORD dwAceRevision, DWORD AceFlags, DWORD AccessMask, GUID *ObjectTypeGuid, GUID *InheritedObjectTypeGuid, PSID pSid)
     * }
     */
    public static MethodHandle AddAccessAllowedObjectAce$handle() {
        return AddAccessAllowedObjectAce.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL AddAccessAllowedObjectAce(PACL pAcl, DWORD dwAceRevision, DWORD AceFlags, DWORD AccessMask, GUID *ObjectTypeGuid, GUID *InheritedObjectTypeGuid, PSID pSid)
     * }
     */
    public static int AddAccessAllowedObjectAce(MemorySegment pAcl, int dwAceRevision, int AceFlags, int AccessMask, MemorySegment ObjectTypeGuid, MemorySegment InheritedObjectTypeGuid, MemorySegment pSid) {
        var mh$ = AddAccessAllowedObjectAce.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("AddAccessAllowedObjectAce", pAcl, dwAceRevision, AceFlags, AccessMask, ObjectTypeGuid, InheritedObjectTypeGuid, pSid);
            }
            return (int)mh$.invokeExact(pAcl, dwAceRevision, AceFlags, AccessMask, ObjectTypeGuid, InheritedObjectTypeGuid, pSid);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class AddAccessDeniedAce {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_LONG,
            C_LONG,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("AddAccessDeniedAce"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL AddAccessDeniedAce(PACL pAcl, DWORD dwAceRevision, DWORD AccessMask, PSID pSid)
     * }
     */
    public static FunctionDescriptor AddAccessDeniedAce$descriptor() {
        return AddAccessDeniedAce.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL AddAccessDeniedAce(PACL pAcl, DWORD dwAceRevision, DWORD AccessMask, PSID pSid)
     * }
     */
    public static MethodHandle AddAccessDeniedAce$handle() {
        return AddAccessDeniedAce.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL AddAccessDeniedAce(PACL pAcl, DWORD dwAceRevision, DWORD AccessMask, PSID pSid)
     * }
     */
    public static int AddAccessDeniedAce(MemorySegment pAcl, int dwAceRevision, int AccessMask, MemorySegment pSid) {
        var mh$ = AddAccessDeniedAce.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("AddAccessDeniedAce", pAcl, dwAceRevision, AccessMask, pSid);
            }
            return (int)mh$.invokeExact(pAcl, dwAceRevision, AccessMask, pSid);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class AddAccessDeniedAceEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_LONG,
            C_LONG,
            C_LONG,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("AddAccessDeniedAceEx"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL AddAccessDeniedAceEx(PACL pAcl, DWORD dwAceRevision, DWORD AceFlags, DWORD AccessMask, PSID pSid)
     * }
     */
    public static FunctionDescriptor AddAccessDeniedAceEx$descriptor() {
        return AddAccessDeniedAceEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL AddAccessDeniedAceEx(PACL pAcl, DWORD dwAceRevision, DWORD AceFlags, DWORD AccessMask, PSID pSid)
     * }
     */
    public static MethodHandle AddAccessDeniedAceEx$handle() {
        return AddAccessDeniedAceEx.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL AddAccessDeniedAceEx(PACL pAcl, DWORD dwAceRevision, DWORD AceFlags, DWORD AccessMask, PSID pSid)
     * }
     */
    public static int AddAccessDeniedAceEx(MemorySegment pAcl, int dwAceRevision, int AceFlags, int AccessMask, MemorySegment pSid) {
        var mh$ = AddAccessDeniedAceEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("AddAccessDeniedAceEx", pAcl, dwAceRevision, AceFlags, AccessMask, pSid);
            }
            return (int)mh$.invokeExact(pAcl, dwAceRevision, AceFlags, AccessMask, pSid);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class AddAccessDeniedObjectAce {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_LONG,
            C_LONG,
            C_LONG,
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("AddAccessDeniedObjectAce"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL AddAccessDeniedObjectAce(PACL pAcl, DWORD dwAceRevision, DWORD AceFlags, DWORD AccessMask, GUID *ObjectTypeGuid, GUID *InheritedObjectTypeGuid, PSID pSid)
     * }
     */
    public static FunctionDescriptor AddAccessDeniedObjectAce$descriptor() {
        return AddAccessDeniedObjectAce.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL AddAccessDeniedObjectAce(PACL pAcl, DWORD dwAceRevision, DWORD AceFlags, DWORD AccessMask, GUID *ObjectTypeGuid, GUID *InheritedObjectTypeGuid, PSID pSid)
     * }
     */
    public static MethodHandle AddAccessDeniedObjectAce$handle() {
        return AddAccessDeniedObjectAce.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL AddAccessDeniedObjectAce(PACL pAcl, DWORD dwAceRevision, DWORD AceFlags, DWORD AccessMask, GUID *ObjectTypeGuid, GUID *InheritedObjectTypeGuid, PSID pSid)
     * }
     */
    public static int AddAccessDeniedObjectAce(MemorySegment pAcl, int dwAceRevision, int AceFlags, int AccessMask, MemorySegment ObjectTypeGuid, MemorySegment InheritedObjectTypeGuid, MemorySegment pSid) {
        var mh$ = AddAccessDeniedObjectAce.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("AddAccessDeniedObjectAce", pAcl, dwAceRevision, AceFlags, AccessMask, ObjectTypeGuid, InheritedObjectTypeGuid, pSid);
            }
            return (int)mh$.invokeExact(pAcl, dwAceRevision, AceFlags, AccessMask, ObjectTypeGuid, InheritedObjectTypeGuid, pSid);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class AddAce {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_LONG,
            C_LONG,
            C_POINTER,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("AddAce"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL AddAce(PACL pAcl, DWORD dwAceRevision, DWORD dwStartingAceIndex, LPVOID pAceList, DWORD nAceListLength)
     * }
     */
    public static FunctionDescriptor AddAce$descriptor() {
        return AddAce.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL AddAce(PACL pAcl, DWORD dwAceRevision, DWORD dwStartingAceIndex, LPVOID pAceList, DWORD nAceListLength)
     * }
     */
    public static MethodHandle AddAce$handle() {
        return AddAce.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL AddAce(PACL pAcl, DWORD dwAceRevision, DWORD dwStartingAceIndex, LPVOID pAceList, DWORD nAceListLength)
     * }
     */
    public static int AddAce(MemorySegment pAcl, int dwAceRevision, int dwStartingAceIndex, MemorySegment pAceList, int nAceListLength) {
        var mh$ = AddAce.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("AddAce", pAcl, dwAceRevision, dwStartingAceIndex, pAceList, nAceListLength);
            }
            return (int)mh$.invokeExact(pAcl, dwAceRevision, dwStartingAceIndex, pAceList, nAceListLength);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class AddAuditAccessAce {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_LONG,
            C_LONG,
            C_POINTER,
            C_INT,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("AddAuditAccessAce"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL AddAuditAccessAce(PACL pAcl, DWORD dwAceRevision, DWORD dwAccessMask, PSID pSid, BOOL bAuditSuccess, BOOL bAuditFailure)
     * }
     */
    public static FunctionDescriptor AddAuditAccessAce$descriptor() {
        return AddAuditAccessAce.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL AddAuditAccessAce(PACL pAcl, DWORD dwAceRevision, DWORD dwAccessMask, PSID pSid, BOOL bAuditSuccess, BOOL bAuditFailure)
     * }
     */
    public static MethodHandle AddAuditAccessAce$handle() {
        return AddAuditAccessAce.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL AddAuditAccessAce(PACL pAcl, DWORD dwAceRevision, DWORD dwAccessMask, PSID pSid, BOOL bAuditSuccess, BOOL bAuditFailure)
     * }
     */
    public static int AddAuditAccessAce(MemorySegment pAcl, int dwAceRevision, int dwAccessMask, MemorySegment pSid, int bAuditSuccess, int bAuditFailure) {
        var mh$ = AddAuditAccessAce.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("AddAuditAccessAce", pAcl, dwAceRevision, dwAccessMask, pSid, bAuditSuccess, bAuditFailure);
            }
            return (int)mh$.invokeExact(pAcl, dwAceRevision, dwAccessMask, pSid, bAuditSuccess, bAuditFailure);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class AddAuditAccessAceEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_LONG,
            C_LONG,
            C_LONG,
            C_POINTER,
            C_INT,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("AddAuditAccessAceEx"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL AddAuditAccessAceEx(PACL pAcl, DWORD dwAceRevision, DWORD AceFlags, DWORD dwAccessMask, PSID pSid, BOOL bAuditSuccess, BOOL bAuditFailure)
     * }
     */
    public static FunctionDescriptor AddAuditAccessAceEx$descriptor() {
        return AddAuditAccessAceEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL AddAuditAccessAceEx(PACL pAcl, DWORD dwAceRevision, DWORD AceFlags, DWORD dwAccessMask, PSID pSid, BOOL bAuditSuccess, BOOL bAuditFailure)
     * }
     */
    public static MethodHandle AddAuditAccessAceEx$handle() {
        return AddAuditAccessAceEx.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL AddAuditAccessAceEx(PACL pAcl, DWORD dwAceRevision, DWORD AceFlags, DWORD dwAccessMask, PSID pSid, BOOL bAuditSuccess, BOOL bAuditFailure)
     * }
     */
    public static int AddAuditAccessAceEx(MemorySegment pAcl, int dwAceRevision, int AceFlags, int dwAccessMask, MemorySegment pSid, int bAuditSuccess, int bAuditFailure) {
        var mh$ = AddAuditAccessAceEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("AddAuditAccessAceEx", pAcl, dwAceRevision, AceFlags, dwAccessMask, pSid, bAuditSuccess, bAuditFailure);
            }
            return (int)mh$.invokeExact(pAcl, dwAceRevision, AceFlags, dwAccessMask, pSid, bAuditSuccess, bAuditFailure);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class AddAuditAccessObjectAce {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_LONG,
            C_LONG,
            C_LONG,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_INT,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("AddAuditAccessObjectAce"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL AddAuditAccessObjectAce(PACL pAcl, DWORD dwAceRevision, DWORD AceFlags, DWORD AccessMask, GUID *ObjectTypeGuid, GUID *InheritedObjectTypeGuid, PSID pSid, BOOL bAuditSuccess, BOOL bAuditFailure)
     * }
     */
    public static FunctionDescriptor AddAuditAccessObjectAce$descriptor() {
        return AddAuditAccessObjectAce.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL AddAuditAccessObjectAce(PACL pAcl, DWORD dwAceRevision, DWORD AceFlags, DWORD AccessMask, GUID *ObjectTypeGuid, GUID *InheritedObjectTypeGuid, PSID pSid, BOOL bAuditSuccess, BOOL bAuditFailure)
     * }
     */
    public static MethodHandle AddAuditAccessObjectAce$handle() {
        return AddAuditAccessObjectAce.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL AddAuditAccessObjectAce(PACL pAcl, DWORD dwAceRevision, DWORD AceFlags, DWORD AccessMask, GUID *ObjectTypeGuid, GUID *InheritedObjectTypeGuid, PSID pSid, BOOL bAuditSuccess, BOOL bAuditFailure)
     * }
     */
    public static int AddAuditAccessObjectAce(MemorySegment pAcl, int dwAceRevision, int AceFlags, int AccessMask, MemorySegment ObjectTypeGuid, MemorySegment InheritedObjectTypeGuid, MemorySegment pSid, int bAuditSuccess, int bAuditFailure) {
        var mh$ = AddAuditAccessObjectAce.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("AddAuditAccessObjectAce", pAcl, dwAceRevision, AceFlags, AccessMask, ObjectTypeGuid, InheritedObjectTypeGuid, pSid, bAuditSuccess, bAuditFailure);
            }
            return (int)mh$.invokeExact(pAcl, dwAceRevision, AceFlags, AccessMask, ObjectTypeGuid, InheritedObjectTypeGuid, pSid, bAuditSuccess, bAuditFailure);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class AddMandatoryAce {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_LONG,
            C_LONG,
            C_LONG,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("AddMandatoryAce"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL AddMandatoryAce(PACL pAcl, DWORD dwAceRevision, DWORD AceFlags, DWORD MandatoryPolicy, PSID pLabelSid)
     * }
     */
    public static FunctionDescriptor AddMandatoryAce$descriptor() {
        return AddMandatoryAce.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL AddMandatoryAce(PACL pAcl, DWORD dwAceRevision, DWORD AceFlags, DWORD MandatoryPolicy, PSID pLabelSid)
     * }
     */
    public static MethodHandle AddMandatoryAce$handle() {
        return AddMandatoryAce.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL AddMandatoryAce(PACL pAcl, DWORD dwAceRevision, DWORD AceFlags, DWORD MandatoryPolicy, PSID pLabelSid)
     * }
     */
    public static int AddMandatoryAce(MemorySegment pAcl, int dwAceRevision, int AceFlags, int MandatoryPolicy, MemorySegment pLabelSid) {
        var mh$ = AddMandatoryAce.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("AddMandatoryAce", pAcl, dwAceRevision, AceFlags, MandatoryPolicy, pLabelSid);
            }
            return (int)mh$.invokeExact(pAcl, dwAceRevision, AceFlags, MandatoryPolicy, pLabelSid);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class AddResourceAttributeAce {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_LONG,
            C_LONG,
            C_LONG,
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("AddResourceAttributeAce"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL AddResourceAttributeAce(PACL pAcl, DWORD dwAceRevision, DWORD AceFlags, DWORD AccessMask, PSID pSid, PCLAIM_SECURITY_ATTRIBUTES_INFORMATION pAttributeInfo, PDWORD pReturnLength)
     * }
     */
    public static FunctionDescriptor AddResourceAttributeAce$descriptor() {
        return AddResourceAttributeAce.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL AddResourceAttributeAce(PACL pAcl, DWORD dwAceRevision, DWORD AceFlags, DWORD AccessMask, PSID pSid, PCLAIM_SECURITY_ATTRIBUTES_INFORMATION pAttributeInfo, PDWORD pReturnLength)
     * }
     */
    public static MethodHandle AddResourceAttributeAce$handle() {
        return AddResourceAttributeAce.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL AddResourceAttributeAce(PACL pAcl, DWORD dwAceRevision, DWORD AceFlags, DWORD AccessMask, PSID pSid, PCLAIM_SECURITY_ATTRIBUTES_INFORMATION pAttributeInfo, PDWORD pReturnLength)
     * }
     */
    public static int AddResourceAttributeAce(MemorySegment pAcl, int dwAceRevision, int AceFlags, int AccessMask, MemorySegment pSid, MemorySegment pAttributeInfo, MemorySegment pReturnLength) {
        var mh$ = AddResourceAttributeAce.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("AddResourceAttributeAce", pAcl, dwAceRevision, AceFlags, AccessMask, pSid, pAttributeInfo, pReturnLength);
            }
            return (int)mh$.invokeExact(pAcl, dwAceRevision, AceFlags, AccessMask, pSid, pAttributeInfo, pReturnLength);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class AddScopedPolicyIDAce {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_LONG,
            C_LONG,
            C_LONG,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("AddScopedPolicyIDAce"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL AddScopedPolicyIDAce(PACL pAcl, DWORD dwAceRevision, DWORD AceFlags, DWORD AccessMask, PSID pSid)
     * }
     */
    public static FunctionDescriptor AddScopedPolicyIDAce$descriptor() {
        return AddScopedPolicyIDAce.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL AddScopedPolicyIDAce(PACL pAcl, DWORD dwAceRevision, DWORD AceFlags, DWORD AccessMask, PSID pSid)
     * }
     */
    public static MethodHandle AddScopedPolicyIDAce$handle() {
        return AddScopedPolicyIDAce.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL AddScopedPolicyIDAce(PACL pAcl, DWORD dwAceRevision, DWORD AceFlags, DWORD AccessMask, PSID pSid)
     * }
     */
    public static int AddScopedPolicyIDAce(MemorySegment pAcl, int dwAceRevision, int AceFlags, int AccessMask, MemorySegment pSid) {
        var mh$ = AddScopedPolicyIDAce.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("AddScopedPolicyIDAce", pAcl, dwAceRevision, AceFlags, AccessMask, pSid);
            }
            return (int)mh$.invokeExact(pAcl, dwAceRevision, AceFlags, AccessMask, pSid);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class AdjustTokenGroups {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_INT,
            C_POINTER,
            C_LONG,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("AdjustTokenGroups"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL AdjustTokenGroups(HANDLE TokenHandle, BOOL ResetToDefault, PTOKEN_GROUPS NewState, DWORD BufferLength, PTOKEN_GROUPS PreviousState, PDWORD ReturnLength)
     * }
     */
    public static FunctionDescriptor AdjustTokenGroups$descriptor() {
        return AdjustTokenGroups.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL AdjustTokenGroups(HANDLE TokenHandle, BOOL ResetToDefault, PTOKEN_GROUPS NewState, DWORD BufferLength, PTOKEN_GROUPS PreviousState, PDWORD ReturnLength)
     * }
     */
    public static MethodHandle AdjustTokenGroups$handle() {
        return AdjustTokenGroups.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL AdjustTokenGroups(HANDLE TokenHandle, BOOL ResetToDefault, PTOKEN_GROUPS NewState, DWORD BufferLength, PTOKEN_GROUPS PreviousState, PDWORD ReturnLength)
     * }
     */
    public static int AdjustTokenGroups(MemorySegment TokenHandle, int ResetToDefault, MemorySegment NewState, int BufferLength, MemorySegment PreviousState, MemorySegment ReturnLength) {
        var mh$ = AdjustTokenGroups.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("AdjustTokenGroups", TokenHandle, ResetToDefault, NewState, BufferLength, PreviousState, ReturnLength);
            }
            return (int)mh$.invokeExact(TokenHandle, ResetToDefault, NewState, BufferLength, PreviousState, ReturnLength);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class AdjustTokenPrivileges {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_INT,
            C_POINTER,
            C_LONG,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("AdjustTokenPrivileges"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL AdjustTokenPrivileges(HANDLE TokenHandle, BOOL DisableAllPrivileges, PTOKEN_PRIVILEGES NewState, DWORD BufferLength, PTOKEN_PRIVILEGES PreviousState, PDWORD ReturnLength)
     * }
     */
    public static FunctionDescriptor AdjustTokenPrivileges$descriptor() {
        return AdjustTokenPrivileges.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL AdjustTokenPrivileges(HANDLE TokenHandle, BOOL DisableAllPrivileges, PTOKEN_PRIVILEGES NewState, DWORD BufferLength, PTOKEN_PRIVILEGES PreviousState, PDWORD ReturnLength)
     * }
     */
    public static MethodHandle AdjustTokenPrivileges$handle() {
        return AdjustTokenPrivileges.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL AdjustTokenPrivileges(HANDLE TokenHandle, BOOL DisableAllPrivileges, PTOKEN_PRIVILEGES NewState, DWORD BufferLength, PTOKEN_PRIVILEGES PreviousState, PDWORD ReturnLength)
     * }
     */
    public static int AdjustTokenPrivileges(MemorySegment TokenHandle, int DisableAllPrivileges, MemorySegment NewState, int BufferLength, MemorySegment PreviousState, MemorySegment ReturnLength) {
        var mh$ = AdjustTokenPrivileges.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("AdjustTokenPrivileges", TokenHandle, DisableAllPrivileges, NewState, BufferLength, PreviousState, ReturnLength);
            }
            return (int)mh$.invokeExact(TokenHandle, DisableAllPrivileges, NewState, BufferLength, PreviousState, ReturnLength);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class AllocateAndInitializeSid {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_CHAR,
            C_LONG,
            C_LONG,
            C_LONG,
            C_LONG,
            C_LONG,
            C_LONG,
            C_LONG,
            C_LONG,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("AllocateAndInitializeSid"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL AllocateAndInitializeSid(PSID_IDENTIFIER_AUTHORITY pIdentifierAuthority, BYTE nSubAuthorityCount, DWORD nSubAuthority0, DWORD nSubAuthority1, DWORD nSubAuthority2, DWORD nSubAuthority3, DWORD nSubAuthority4, DWORD nSubAuthority5, DWORD nSubAuthority6, DWORD nSubAuthority7, PSID *pSid)
     * }
     */
    public static FunctionDescriptor AllocateAndInitializeSid$descriptor() {
        return AllocateAndInitializeSid.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL AllocateAndInitializeSid(PSID_IDENTIFIER_AUTHORITY pIdentifierAuthority, BYTE nSubAuthorityCount, DWORD nSubAuthority0, DWORD nSubAuthority1, DWORD nSubAuthority2, DWORD nSubAuthority3, DWORD nSubAuthority4, DWORD nSubAuthority5, DWORD nSubAuthority6, DWORD nSubAuthority7, PSID *pSid)
     * }
     */
    public static MethodHandle AllocateAndInitializeSid$handle() {
        return AllocateAndInitializeSid.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL AllocateAndInitializeSid(PSID_IDENTIFIER_AUTHORITY pIdentifierAuthority, BYTE nSubAuthorityCount, DWORD nSubAuthority0, DWORD nSubAuthority1, DWORD nSubAuthority2, DWORD nSubAuthority3, DWORD nSubAuthority4, DWORD nSubAuthority5, DWORD nSubAuthority6, DWORD nSubAuthority7, PSID *pSid)
     * }
     */
    public static int AllocateAndInitializeSid(MemorySegment pIdentifierAuthority, byte nSubAuthorityCount, int nSubAuthority0, int nSubAuthority1, int nSubAuthority2, int nSubAuthority3, int nSubAuthority4, int nSubAuthority5, int nSubAuthority6, int nSubAuthority7, MemorySegment pSid) {
        var mh$ = AllocateAndInitializeSid.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("AllocateAndInitializeSid", pIdentifierAuthority, nSubAuthorityCount, nSubAuthority0, nSubAuthority1, nSubAuthority2, nSubAuthority3, nSubAuthority4, nSubAuthority5, nSubAuthority6, nSubAuthority7, pSid);
            }
            return (int)mh$.invokeExact(pIdentifierAuthority, nSubAuthorityCount, nSubAuthority0, nSubAuthority1, nSubAuthority2, nSubAuthority3, nSubAuthority4, nSubAuthority5, nSubAuthority6, nSubAuthority7, pSid);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class AllocateLocallyUniqueId {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("AllocateLocallyUniqueId"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL AllocateLocallyUniqueId(PLUID Luid)
     * }
     */
    public static FunctionDescriptor AllocateLocallyUniqueId$descriptor() {
        return AllocateLocallyUniqueId.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL AllocateLocallyUniqueId(PLUID Luid)
     * }
     */
    public static MethodHandle AllocateLocallyUniqueId$handle() {
        return AllocateLocallyUniqueId.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL AllocateLocallyUniqueId(PLUID Luid)
     * }
     */
    public static int AllocateLocallyUniqueId(MemorySegment Luid) {
        var mh$ = AllocateLocallyUniqueId.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("AllocateLocallyUniqueId", Luid);
            }
            return (int)mh$.invokeExact(Luid);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class AreAllAccessesGranted {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_LONG,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("AreAllAccessesGranted"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL AreAllAccessesGranted(DWORD GrantedAccess, DWORD DesiredAccess)
     * }
     */
    public static FunctionDescriptor AreAllAccessesGranted$descriptor() {
        return AreAllAccessesGranted.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL AreAllAccessesGranted(DWORD GrantedAccess, DWORD DesiredAccess)
     * }
     */
    public static MethodHandle AreAllAccessesGranted$handle() {
        return AreAllAccessesGranted.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL AreAllAccessesGranted(DWORD GrantedAccess, DWORD DesiredAccess)
     * }
     */
    public static int AreAllAccessesGranted(int GrantedAccess, int DesiredAccess) {
        var mh$ = AreAllAccessesGranted.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("AreAllAccessesGranted", GrantedAccess, DesiredAccess);
            }
            return (int)mh$.invokeExact(GrantedAccess, DesiredAccess);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class AreAnyAccessesGranted {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_LONG,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("AreAnyAccessesGranted"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL AreAnyAccessesGranted(DWORD GrantedAccess, DWORD DesiredAccess)
     * }
     */
    public static FunctionDescriptor AreAnyAccessesGranted$descriptor() {
        return AreAnyAccessesGranted.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL AreAnyAccessesGranted(DWORD GrantedAccess, DWORD DesiredAccess)
     * }
     */
    public static MethodHandle AreAnyAccessesGranted$handle() {
        return AreAnyAccessesGranted.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL AreAnyAccessesGranted(DWORD GrantedAccess, DWORD DesiredAccess)
     * }
     */
    public static int AreAnyAccessesGranted(int GrantedAccess, int DesiredAccess) {
        var mh$ = AreAnyAccessesGranted.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("AreAnyAccessesGranted", GrantedAccess, DesiredAccess);
            }
            return (int)mh$.invokeExact(GrantedAccess, DesiredAccess);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CheckTokenMembership {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CheckTokenMembership"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CheckTokenMembership(HANDLE TokenHandle, PSID SidToCheck, PBOOL IsMember)
     * }
     */
    public static FunctionDescriptor CheckTokenMembership$descriptor() {
        return CheckTokenMembership.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CheckTokenMembership(HANDLE TokenHandle, PSID SidToCheck, PBOOL IsMember)
     * }
     */
    public static MethodHandle CheckTokenMembership$handle() {
        return CheckTokenMembership.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL CheckTokenMembership(HANDLE TokenHandle, PSID SidToCheck, PBOOL IsMember)
     * }
     */
    public static int CheckTokenMembership(MemorySegment TokenHandle, MemorySegment SidToCheck, MemorySegment IsMember) {
        var mh$ = CheckTokenMembership.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CheckTokenMembership", TokenHandle, SidToCheck, IsMember);
            }
            return (int)mh$.invokeExact(TokenHandle, SidToCheck, IsMember);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CheckTokenCapability {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CheckTokenCapability"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CheckTokenCapability(HANDLE TokenHandle, PSID CapabilitySidToCheck, PBOOL HasCapability)
     * }
     */
    public static FunctionDescriptor CheckTokenCapability$descriptor() {
        return CheckTokenCapability.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CheckTokenCapability(HANDLE TokenHandle, PSID CapabilitySidToCheck, PBOOL HasCapability)
     * }
     */
    public static MethodHandle CheckTokenCapability$handle() {
        return CheckTokenCapability.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL CheckTokenCapability(HANDLE TokenHandle, PSID CapabilitySidToCheck, PBOOL HasCapability)
     * }
     */
    public static int CheckTokenCapability(MemorySegment TokenHandle, MemorySegment CapabilitySidToCheck, MemorySegment HasCapability) {
        var mh$ = CheckTokenCapability.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CheckTokenCapability", TokenHandle, CapabilitySidToCheck, HasCapability);
            }
            return (int)mh$.invokeExact(TokenHandle, CapabilitySidToCheck, HasCapability);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetAppContainerAce {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_LONG,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetAppContainerAce"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetAppContainerAce(PACL Acl, DWORD StartingAceIndex, PVOID *AppContainerAce, DWORD *AppContainerAceIndex)
     * }
     */
    public static FunctionDescriptor GetAppContainerAce$descriptor() {
        return GetAppContainerAce.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetAppContainerAce(PACL Acl, DWORD StartingAceIndex, PVOID *AppContainerAce, DWORD *AppContainerAceIndex)
     * }
     */
    public static MethodHandle GetAppContainerAce$handle() {
        return GetAppContainerAce.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL GetAppContainerAce(PACL Acl, DWORD StartingAceIndex, PVOID *AppContainerAce, DWORD *AppContainerAceIndex)
     * }
     */
    public static int GetAppContainerAce(MemorySegment Acl, int StartingAceIndex, MemorySegment AppContainerAce, MemorySegment AppContainerAceIndex) {
        var mh$ = GetAppContainerAce.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetAppContainerAce", Acl, StartingAceIndex, AppContainerAce, AppContainerAceIndex);
            }
            return (int)mh$.invokeExact(Acl, StartingAceIndex, AppContainerAce, AppContainerAceIndex);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CheckTokenMembershipEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_LONG,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CheckTokenMembershipEx"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CheckTokenMembershipEx(HANDLE TokenHandle, PSID SidToCheck, DWORD Flags, PBOOL IsMember)
     * }
     */
    public static FunctionDescriptor CheckTokenMembershipEx$descriptor() {
        return CheckTokenMembershipEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CheckTokenMembershipEx(HANDLE TokenHandle, PSID SidToCheck, DWORD Flags, PBOOL IsMember)
     * }
     */
    public static MethodHandle CheckTokenMembershipEx$handle() {
        return CheckTokenMembershipEx.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL CheckTokenMembershipEx(HANDLE TokenHandle, PSID SidToCheck, DWORD Flags, PBOOL IsMember)
     * }
     */
    public static int CheckTokenMembershipEx(MemorySegment TokenHandle, MemorySegment SidToCheck, int Flags, MemorySegment IsMember) {
        var mh$ = CheckTokenMembershipEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CheckTokenMembershipEx", TokenHandle, SidToCheck, Flags, IsMember);
            }
            return (int)mh$.invokeExact(TokenHandle, SidToCheck, Flags, IsMember);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ConvertToAutoInheritPrivateObjectSecurity {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_CHAR,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("ConvertToAutoInheritPrivateObjectSecurity"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL ConvertToAutoInheritPrivateObjectSecurity(PSECURITY_DESCRIPTOR ParentDescriptor, PSECURITY_DESCRIPTOR CurrentSecurityDescriptor, PSECURITY_DESCRIPTOR *NewSecurityDescriptor, GUID *ObjectType, BOOLEAN IsDirectoryObject, PGENERIC_MAPPING GenericMapping)
     * }
     */
    public static FunctionDescriptor ConvertToAutoInheritPrivateObjectSecurity$descriptor() {
        return ConvertToAutoInheritPrivateObjectSecurity.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL ConvertToAutoInheritPrivateObjectSecurity(PSECURITY_DESCRIPTOR ParentDescriptor, PSECURITY_DESCRIPTOR CurrentSecurityDescriptor, PSECURITY_DESCRIPTOR *NewSecurityDescriptor, GUID *ObjectType, BOOLEAN IsDirectoryObject, PGENERIC_MAPPING GenericMapping)
     * }
     */
    public static MethodHandle ConvertToAutoInheritPrivateObjectSecurity$handle() {
        return ConvertToAutoInheritPrivateObjectSecurity.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL ConvertToAutoInheritPrivateObjectSecurity(PSECURITY_DESCRIPTOR ParentDescriptor, PSECURITY_DESCRIPTOR CurrentSecurityDescriptor, PSECURITY_DESCRIPTOR *NewSecurityDescriptor, GUID *ObjectType, BOOLEAN IsDirectoryObject, PGENERIC_MAPPING GenericMapping)
     * }
     */
    public static int ConvertToAutoInheritPrivateObjectSecurity(MemorySegment ParentDescriptor, MemorySegment CurrentSecurityDescriptor, MemorySegment NewSecurityDescriptor, MemorySegment ObjectType, byte IsDirectoryObject, MemorySegment GenericMapping) {
        var mh$ = ConvertToAutoInheritPrivateObjectSecurity.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ConvertToAutoInheritPrivateObjectSecurity", ParentDescriptor, CurrentSecurityDescriptor, NewSecurityDescriptor, ObjectType, IsDirectoryObject, GenericMapping);
            }
            return (int)mh$.invokeExact(ParentDescriptor, CurrentSecurityDescriptor, NewSecurityDescriptor, ObjectType, IsDirectoryObject, GenericMapping);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CopySid {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_LONG,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CopySid"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CopySid(DWORD nDestinationSidLength, PSID pDestinationSid, PSID pSourceSid)
     * }
     */
    public static FunctionDescriptor CopySid$descriptor() {
        return CopySid.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CopySid(DWORD nDestinationSidLength, PSID pDestinationSid, PSID pSourceSid)
     * }
     */
    public static MethodHandle CopySid$handle() {
        return CopySid.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL CopySid(DWORD nDestinationSidLength, PSID pDestinationSid, PSID pSourceSid)
     * }
     */
    public static int CopySid(int nDestinationSidLength, MemorySegment pDestinationSid, MemorySegment pSourceSid) {
        var mh$ = CopySid.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CopySid", nDestinationSidLength, pDestinationSid, pSourceSid);
            }
            return (int)mh$.invokeExact(nDestinationSidLength, pDestinationSid, pSourceSid);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreatePrivateObjectSecurity {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_INT,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CreatePrivateObjectSecurity"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CreatePrivateObjectSecurity(PSECURITY_DESCRIPTOR ParentDescriptor, PSECURITY_DESCRIPTOR CreatorDescriptor, PSECURITY_DESCRIPTOR *NewDescriptor, BOOL IsDirectoryObject, HANDLE Token, PGENERIC_MAPPING GenericMapping)
     * }
     */
    public static FunctionDescriptor CreatePrivateObjectSecurity$descriptor() {
        return CreatePrivateObjectSecurity.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CreatePrivateObjectSecurity(PSECURITY_DESCRIPTOR ParentDescriptor, PSECURITY_DESCRIPTOR CreatorDescriptor, PSECURITY_DESCRIPTOR *NewDescriptor, BOOL IsDirectoryObject, HANDLE Token, PGENERIC_MAPPING GenericMapping)
     * }
     */
    public static MethodHandle CreatePrivateObjectSecurity$handle() {
        return CreatePrivateObjectSecurity.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL CreatePrivateObjectSecurity(PSECURITY_DESCRIPTOR ParentDescriptor, PSECURITY_DESCRIPTOR CreatorDescriptor, PSECURITY_DESCRIPTOR *NewDescriptor, BOOL IsDirectoryObject, HANDLE Token, PGENERIC_MAPPING GenericMapping)
     * }
     */
    public static int CreatePrivateObjectSecurity(MemorySegment ParentDescriptor, MemorySegment CreatorDescriptor, MemorySegment NewDescriptor, int IsDirectoryObject, MemorySegment Token, MemorySegment GenericMapping) {
        var mh$ = CreatePrivateObjectSecurity.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreatePrivateObjectSecurity", ParentDescriptor, CreatorDescriptor, NewDescriptor, IsDirectoryObject, Token, GenericMapping);
            }
            return (int)mh$.invokeExact(ParentDescriptor, CreatorDescriptor, NewDescriptor, IsDirectoryObject, Token, GenericMapping);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreatePrivateObjectSecurityEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_INT,
            C_LONG,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CreatePrivateObjectSecurityEx"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CreatePrivateObjectSecurityEx(PSECURITY_DESCRIPTOR ParentDescriptor, PSECURITY_DESCRIPTOR CreatorDescriptor, PSECURITY_DESCRIPTOR *NewDescriptor, GUID *ObjectType, BOOL IsContainerObject, ULONG AutoInheritFlags, HANDLE Token, PGENERIC_MAPPING GenericMapping)
     * }
     */
    public static FunctionDescriptor CreatePrivateObjectSecurityEx$descriptor() {
        return CreatePrivateObjectSecurityEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CreatePrivateObjectSecurityEx(PSECURITY_DESCRIPTOR ParentDescriptor, PSECURITY_DESCRIPTOR CreatorDescriptor, PSECURITY_DESCRIPTOR *NewDescriptor, GUID *ObjectType, BOOL IsContainerObject, ULONG AutoInheritFlags, HANDLE Token, PGENERIC_MAPPING GenericMapping)
     * }
     */
    public static MethodHandle CreatePrivateObjectSecurityEx$handle() {
        return CreatePrivateObjectSecurityEx.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL CreatePrivateObjectSecurityEx(PSECURITY_DESCRIPTOR ParentDescriptor, PSECURITY_DESCRIPTOR CreatorDescriptor, PSECURITY_DESCRIPTOR *NewDescriptor, GUID *ObjectType, BOOL IsContainerObject, ULONG AutoInheritFlags, HANDLE Token, PGENERIC_MAPPING GenericMapping)
     * }
     */
    public static int CreatePrivateObjectSecurityEx(MemorySegment ParentDescriptor, MemorySegment CreatorDescriptor, MemorySegment NewDescriptor, MemorySegment ObjectType, int IsContainerObject, int AutoInheritFlags, MemorySegment Token, MemorySegment GenericMapping) {
        var mh$ = CreatePrivateObjectSecurityEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreatePrivateObjectSecurityEx", ParentDescriptor, CreatorDescriptor, NewDescriptor, ObjectType, IsContainerObject, AutoInheritFlags, Token, GenericMapping);
            }
            return (int)mh$.invokeExact(ParentDescriptor, CreatorDescriptor, NewDescriptor, ObjectType, IsContainerObject, AutoInheritFlags, Token, GenericMapping);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreatePrivateObjectSecurityWithMultipleInheritance {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_LONG,
            C_INT,
            C_LONG,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CreatePrivateObjectSecurityWithMultipleInheritance"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CreatePrivateObjectSecurityWithMultipleInheritance(PSECURITY_DESCRIPTOR ParentDescriptor, PSECURITY_DESCRIPTOR CreatorDescriptor, PSECURITY_DESCRIPTOR *NewDescriptor, GUID **ObjectTypes, ULONG GuidCount, BOOL IsContainerObject, ULONG AutoInheritFlags, HANDLE Token, PGENERIC_MAPPING GenericMapping)
     * }
     */
    public static FunctionDescriptor CreatePrivateObjectSecurityWithMultipleInheritance$descriptor() {
        return CreatePrivateObjectSecurityWithMultipleInheritance.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CreatePrivateObjectSecurityWithMultipleInheritance(PSECURITY_DESCRIPTOR ParentDescriptor, PSECURITY_DESCRIPTOR CreatorDescriptor, PSECURITY_DESCRIPTOR *NewDescriptor, GUID **ObjectTypes, ULONG GuidCount, BOOL IsContainerObject, ULONG AutoInheritFlags, HANDLE Token, PGENERIC_MAPPING GenericMapping)
     * }
     */
    public static MethodHandle CreatePrivateObjectSecurityWithMultipleInheritance$handle() {
        return CreatePrivateObjectSecurityWithMultipleInheritance.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL CreatePrivateObjectSecurityWithMultipleInheritance(PSECURITY_DESCRIPTOR ParentDescriptor, PSECURITY_DESCRIPTOR CreatorDescriptor, PSECURITY_DESCRIPTOR *NewDescriptor, GUID **ObjectTypes, ULONG GuidCount, BOOL IsContainerObject, ULONG AutoInheritFlags, HANDLE Token, PGENERIC_MAPPING GenericMapping)
     * }
     */
    public static int CreatePrivateObjectSecurityWithMultipleInheritance(MemorySegment ParentDescriptor, MemorySegment CreatorDescriptor, MemorySegment NewDescriptor, MemorySegment ObjectTypes, int GuidCount, int IsContainerObject, int AutoInheritFlags, MemorySegment Token, MemorySegment GenericMapping) {
        var mh$ = CreatePrivateObjectSecurityWithMultipleInheritance.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreatePrivateObjectSecurityWithMultipleInheritance", ParentDescriptor, CreatorDescriptor, NewDescriptor, ObjectTypes, GuidCount, IsContainerObject, AutoInheritFlags, Token, GenericMapping);
            }
            return (int)mh$.invokeExact(ParentDescriptor, CreatorDescriptor, NewDescriptor, ObjectTypes, GuidCount, IsContainerObject, AutoInheritFlags, Token, GenericMapping);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateRestrictedToken {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_LONG,
            C_LONG,
            C_POINTER,
            C_LONG,
            C_POINTER,
            C_LONG,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CreateRestrictedToken"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CreateRestrictedToken(HANDLE ExistingTokenHandle, DWORD Flags, DWORD DisableSidCount, PSID_AND_ATTRIBUTES SidsToDisable, DWORD DeletePrivilegeCount, PLUID_AND_ATTRIBUTES PrivilegesToDelete, DWORD RestrictedSidCount, PSID_AND_ATTRIBUTES SidsToRestrict, PHANDLE NewTokenHandle)
     * }
     */
    public static FunctionDescriptor CreateRestrictedToken$descriptor() {
        return CreateRestrictedToken.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CreateRestrictedToken(HANDLE ExistingTokenHandle, DWORD Flags, DWORD DisableSidCount, PSID_AND_ATTRIBUTES SidsToDisable, DWORD DeletePrivilegeCount, PLUID_AND_ATTRIBUTES PrivilegesToDelete, DWORD RestrictedSidCount, PSID_AND_ATTRIBUTES SidsToRestrict, PHANDLE NewTokenHandle)
     * }
     */
    public static MethodHandle CreateRestrictedToken$handle() {
        return CreateRestrictedToken.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL CreateRestrictedToken(HANDLE ExistingTokenHandle, DWORD Flags, DWORD DisableSidCount, PSID_AND_ATTRIBUTES SidsToDisable, DWORD DeletePrivilegeCount, PLUID_AND_ATTRIBUTES PrivilegesToDelete, DWORD RestrictedSidCount, PSID_AND_ATTRIBUTES SidsToRestrict, PHANDLE NewTokenHandle)
     * }
     */
    public static int CreateRestrictedToken(MemorySegment ExistingTokenHandle, int Flags, int DisableSidCount, MemorySegment SidsToDisable, int DeletePrivilegeCount, MemorySegment PrivilegesToDelete, int RestrictedSidCount, MemorySegment SidsToRestrict, MemorySegment NewTokenHandle) {
        var mh$ = CreateRestrictedToken.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateRestrictedToken", ExistingTokenHandle, Flags, DisableSidCount, SidsToDisable, DeletePrivilegeCount, PrivilegesToDelete, RestrictedSidCount, SidsToRestrict, NewTokenHandle);
            }
            return (int)mh$.invokeExact(ExistingTokenHandle, Flags, DisableSidCount, SidsToDisable, DeletePrivilegeCount, PrivilegesToDelete, RestrictedSidCount, SidsToRestrict, NewTokenHandle);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateWellKnownSid {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_INT,
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CreateWellKnownSid"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CreateWellKnownSid(WELL_KNOWN_SID_TYPE WellKnownSidType, PSID DomainSid, PSID pSid, DWORD *cbSid)
     * }
     */
    public static FunctionDescriptor CreateWellKnownSid$descriptor() {
        return CreateWellKnownSid.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CreateWellKnownSid(WELL_KNOWN_SID_TYPE WellKnownSidType, PSID DomainSid, PSID pSid, DWORD *cbSid)
     * }
     */
    public static MethodHandle CreateWellKnownSid$handle() {
        return CreateWellKnownSid.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL CreateWellKnownSid(WELL_KNOWN_SID_TYPE WellKnownSidType, PSID DomainSid, PSID pSid, DWORD *cbSid)
     * }
     */
    public static int CreateWellKnownSid(int WellKnownSidType, MemorySegment DomainSid, MemorySegment pSid, MemorySegment cbSid) {
        var mh$ = CreateWellKnownSid.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateWellKnownSid", WellKnownSidType, DomainSid, pSid, cbSid);
            }
            return (int)mh$.invokeExact(WellKnownSidType, DomainSid, pSid, cbSid);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class EqualDomainSid {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("EqualDomainSid"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL EqualDomainSid(PSID pSid1, PSID pSid2, BOOL *pfEqual)
     * }
     */
    public static FunctionDescriptor EqualDomainSid$descriptor() {
        return EqualDomainSid.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL EqualDomainSid(PSID pSid1, PSID pSid2, BOOL *pfEqual)
     * }
     */
    public static MethodHandle EqualDomainSid$handle() {
        return EqualDomainSid.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL EqualDomainSid(PSID pSid1, PSID pSid2, BOOL *pfEqual)
     * }
     */
    public static int EqualDomainSid(MemorySegment pSid1, MemorySegment pSid2, MemorySegment pfEqual) {
        var mh$ = EqualDomainSid.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("EqualDomainSid", pSid1, pSid2, pfEqual);
            }
            return (int)mh$.invokeExact(pSid1, pSid2, pfEqual);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DeleteAce {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("DeleteAce"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL DeleteAce(PACL pAcl, DWORD dwAceIndex)
     * }
     */
    public static FunctionDescriptor DeleteAce$descriptor() {
        return DeleteAce.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL DeleteAce(PACL pAcl, DWORD dwAceIndex)
     * }
     */
    public static MethodHandle DeleteAce$handle() {
        return DeleteAce.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL DeleteAce(PACL pAcl, DWORD dwAceIndex)
     * }
     */
    public static int DeleteAce(MemorySegment pAcl, int dwAceIndex) {
        var mh$ = DeleteAce.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DeleteAce", pAcl, dwAceIndex);
            }
            return (int)mh$.invokeExact(pAcl, dwAceIndex);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DestroyPrivateObjectSecurity {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("DestroyPrivateObjectSecurity"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL DestroyPrivateObjectSecurity(PSECURITY_DESCRIPTOR *ObjectDescriptor)
     * }
     */
    public static FunctionDescriptor DestroyPrivateObjectSecurity$descriptor() {
        return DestroyPrivateObjectSecurity.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL DestroyPrivateObjectSecurity(PSECURITY_DESCRIPTOR *ObjectDescriptor)
     * }
     */
    public static MethodHandle DestroyPrivateObjectSecurity$handle() {
        return DestroyPrivateObjectSecurity.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL DestroyPrivateObjectSecurity(PSECURITY_DESCRIPTOR *ObjectDescriptor)
     * }
     */
    public static int DestroyPrivateObjectSecurity(MemorySegment ObjectDescriptor) {
        var mh$ = DestroyPrivateObjectSecurity.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DestroyPrivateObjectSecurity", ObjectDescriptor);
            }
            return (int)mh$.invokeExact(ObjectDescriptor);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DuplicateToken {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("DuplicateToken"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL DuplicateToken(HANDLE ExistingTokenHandle, SECURITY_IMPERSONATION_LEVEL ImpersonationLevel, PHANDLE DuplicateTokenHandle)
     * }
     */
    public static FunctionDescriptor DuplicateToken$descriptor() {
        return DuplicateToken.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL DuplicateToken(HANDLE ExistingTokenHandle, SECURITY_IMPERSONATION_LEVEL ImpersonationLevel, PHANDLE DuplicateTokenHandle)
     * }
     */
    public static MethodHandle DuplicateToken$handle() {
        return DuplicateToken.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL DuplicateToken(HANDLE ExistingTokenHandle, SECURITY_IMPERSONATION_LEVEL ImpersonationLevel, PHANDLE DuplicateTokenHandle)
     * }
     */
    public static int DuplicateToken(MemorySegment ExistingTokenHandle, int ImpersonationLevel, MemorySegment DuplicateTokenHandle) {
        var mh$ = DuplicateToken.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DuplicateToken", ExistingTokenHandle, ImpersonationLevel, DuplicateTokenHandle);
            }
            return (int)mh$.invokeExact(ExistingTokenHandle, ImpersonationLevel, DuplicateTokenHandle);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DuplicateTokenEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_LONG,
            C_POINTER,
            C_INT,
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("DuplicateTokenEx"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL DuplicateTokenEx(HANDLE hExistingToken, DWORD dwDesiredAccess, LPSECURITY_ATTRIBUTES lpTokenAttributes, SECURITY_IMPERSONATION_LEVEL ImpersonationLevel, TOKEN_TYPE TokenType, PHANDLE phNewToken)
     * }
     */
    public static FunctionDescriptor DuplicateTokenEx$descriptor() {
        return DuplicateTokenEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL DuplicateTokenEx(HANDLE hExistingToken, DWORD dwDesiredAccess, LPSECURITY_ATTRIBUTES lpTokenAttributes, SECURITY_IMPERSONATION_LEVEL ImpersonationLevel, TOKEN_TYPE TokenType, PHANDLE phNewToken)
     * }
     */
    public static MethodHandle DuplicateTokenEx$handle() {
        return DuplicateTokenEx.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL DuplicateTokenEx(HANDLE hExistingToken, DWORD dwDesiredAccess, LPSECURITY_ATTRIBUTES lpTokenAttributes, SECURITY_IMPERSONATION_LEVEL ImpersonationLevel, TOKEN_TYPE TokenType, PHANDLE phNewToken)
     * }
     */
    public static int DuplicateTokenEx(MemorySegment hExistingToken, int dwDesiredAccess, MemorySegment lpTokenAttributes, int ImpersonationLevel, int TokenType, MemorySegment phNewToken) {
        var mh$ = DuplicateTokenEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DuplicateTokenEx", hExistingToken, dwDesiredAccess, lpTokenAttributes, ImpersonationLevel, TokenType, phNewToken);
            }
            return (int)mh$.invokeExact(hExistingToken, dwDesiredAccess, lpTokenAttributes, ImpersonationLevel, TokenType, phNewToken);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class EqualPrefixSid {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("EqualPrefixSid"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL EqualPrefixSid(PSID pSid1, PSID pSid2)
     * }
     */
    public static FunctionDescriptor EqualPrefixSid$descriptor() {
        return EqualPrefixSid.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL EqualPrefixSid(PSID pSid1, PSID pSid2)
     * }
     */
    public static MethodHandle EqualPrefixSid$handle() {
        return EqualPrefixSid.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL EqualPrefixSid(PSID pSid1, PSID pSid2)
     * }
     */
    public static int EqualPrefixSid(MemorySegment pSid1, MemorySegment pSid2) {
        var mh$ = EqualPrefixSid.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("EqualPrefixSid", pSid1, pSid2);
            }
            return (int)mh$.invokeExact(pSid1, pSid2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class EqualSid {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("EqualSid"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL EqualSid(PSID pSid1, PSID pSid2)
     * }
     */
    public static FunctionDescriptor EqualSid$descriptor() {
        return EqualSid.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL EqualSid(PSID pSid1, PSID pSid2)
     * }
     */
    public static MethodHandle EqualSid$handle() {
        return EqualSid.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL EqualSid(PSID pSid1, PSID pSid2)
     * }
     */
    public static int EqualSid(MemorySegment pSid1, MemorySegment pSid2) {
        var mh$ = EqualSid.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("EqualSid", pSid1, pSid2);
            }
            return (int)mh$.invokeExact(pSid1, pSid2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FindFirstFreeAce {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("FindFirstFreeAce"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL FindFirstFreeAce(PACL pAcl, LPVOID *pAce)
     * }
     */
    public static FunctionDescriptor FindFirstFreeAce$descriptor() {
        return FindFirstFreeAce.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL FindFirstFreeAce(PACL pAcl, LPVOID *pAce)
     * }
     */
    public static MethodHandle FindFirstFreeAce$handle() {
        return FindFirstFreeAce.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL FindFirstFreeAce(PACL pAcl, LPVOID *pAce)
     * }
     */
    public static int FindFirstFreeAce(MemorySegment pAcl, MemorySegment pAce) {
        var mh$ = FindFirstFreeAce.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FindFirstFreeAce", pAcl, pAce);
            }
            return (int)mh$.invokeExact(pAcl, pAce);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FreeSid {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("FreeSid"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PVOID FreeSid(PSID pSid)
     * }
     */
    public static FunctionDescriptor FreeSid$descriptor() {
        return FreeSid.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PVOID FreeSid(PSID pSid)
     * }
     */
    public static MethodHandle FreeSid$handle() {
        return FreeSid.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * PVOID FreeSid(PSID pSid)
     * }
     */
    public static MemorySegment FreeSid(MemorySegment pSid) {
        var mh$ = FreeSid.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FreeSid", pSid);
            }
            return (MemorySegment)mh$.invokeExact(pSid);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetAce {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_LONG,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetAce"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetAce(PACL pAcl, DWORD dwAceIndex, LPVOID *pAce)
     * }
     */
    public static FunctionDescriptor GetAce$descriptor() {
        return GetAce.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetAce(PACL pAcl, DWORD dwAceIndex, LPVOID *pAce)
     * }
     */
    public static MethodHandle GetAce$handle() {
        return GetAce.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL GetAce(PACL pAcl, DWORD dwAceIndex, LPVOID *pAce)
     * }
     */
    public static int GetAce(MemorySegment pAcl, int dwAceIndex, MemorySegment pAce) {
        var mh$ = GetAce.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetAce", pAcl, dwAceIndex, pAce);
            }
            return (int)mh$.invokeExact(pAcl, dwAceIndex, pAce);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetAclInformation {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_LONG,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetAclInformation"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetAclInformation(PACL pAcl, LPVOID pAclInformation, DWORD nAclInformationLength, ACL_INFORMATION_CLASS dwAclInformationClass)
     * }
     */
    public static FunctionDescriptor GetAclInformation$descriptor() {
        return GetAclInformation.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetAclInformation(PACL pAcl, LPVOID pAclInformation, DWORD nAclInformationLength, ACL_INFORMATION_CLASS dwAclInformationClass)
     * }
     */
    public static MethodHandle GetAclInformation$handle() {
        return GetAclInformation.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL GetAclInformation(PACL pAcl, LPVOID pAclInformation, DWORD nAclInformationLength, ACL_INFORMATION_CLASS dwAclInformationClass)
     * }
     */
    public static int GetAclInformation(MemorySegment pAcl, MemorySegment pAclInformation, int nAclInformationLength, int dwAclInformationClass) {
        var mh$ = GetAclInformation.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetAclInformation", pAcl, pAclInformation, nAclInformationLength, dwAclInformationClass);
            }
            return (int)mh$.invokeExact(pAcl, pAclInformation, nAclInformationLength, dwAclInformationClass);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetFileSecurityW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_LONG,
            C_POINTER,
            C_LONG,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetFileSecurityW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetFileSecurityW(LPCWSTR lpFileName, SECURITY_INFORMATION RequestedInformation, PSECURITY_DESCRIPTOR pSecurityDescriptor, DWORD nLength, LPDWORD lpnLengthNeeded)
     * }
     */
    public static FunctionDescriptor GetFileSecurityW$descriptor() {
        return GetFileSecurityW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetFileSecurityW(LPCWSTR lpFileName, SECURITY_INFORMATION RequestedInformation, PSECURITY_DESCRIPTOR pSecurityDescriptor, DWORD nLength, LPDWORD lpnLengthNeeded)
     * }
     */
    public static MethodHandle GetFileSecurityW$handle() {
        return GetFileSecurityW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL GetFileSecurityW(LPCWSTR lpFileName, SECURITY_INFORMATION RequestedInformation, PSECURITY_DESCRIPTOR pSecurityDescriptor, DWORD nLength, LPDWORD lpnLengthNeeded)
     * }
     */
    public static int GetFileSecurityW(MemorySegment lpFileName, int RequestedInformation, MemorySegment pSecurityDescriptor, int nLength, MemorySegment lpnLengthNeeded) {
        var mh$ = GetFileSecurityW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetFileSecurityW", lpFileName, RequestedInformation, pSecurityDescriptor, nLength, lpnLengthNeeded);
            }
            return (int)mh$.invokeExact(lpFileName, RequestedInformation, pSecurityDescriptor, nLength, lpnLengthNeeded);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetKernelObjectSecurity {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_LONG,
            C_POINTER,
            C_LONG,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetKernelObjectSecurity"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetKernelObjectSecurity(HANDLE Handle, SECURITY_INFORMATION RequestedInformation, PSECURITY_DESCRIPTOR pSecurityDescriptor, DWORD nLength, LPDWORD lpnLengthNeeded)
     * }
     */
    public static FunctionDescriptor GetKernelObjectSecurity$descriptor() {
        return GetKernelObjectSecurity.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetKernelObjectSecurity(HANDLE Handle, SECURITY_INFORMATION RequestedInformation, PSECURITY_DESCRIPTOR pSecurityDescriptor, DWORD nLength, LPDWORD lpnLengthNeeded)
     * }
     */
    public static MethodHandle GetKernelObjectSecurity$handle() {
        return GetKernelObjectSecurity.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL GetKernelObjectSecurity(HANDLE Handle, SECURITY_INFORMATION RequestedInformation, PSECURITY_DESCRIPTOR pSecurityDescriptor, DWORD nLength, LPDWORD lpnLengthNeeded)
     * }
     */
    public static int GetKernelObjectSecurity(MemorySegment Handle, int RequestedInformation, MemorySegment pSecurityDescriptor, int nLength, MemorySegment lpnLengthNeeded) {
        var mh$ = GetKernelObjectSecurity.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetKernelObjectSecurity", Handle, RequestedInformation, pSecurityDescriptor, nLength, lpnLengthNeeded);
            }
            return (int)mh$.invokeExact(Handle, RequestedInformation, pSecurityDescriptor, nLength, lpnLengthNeeded);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetLengthSid {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetLengthSid"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetLengthSid(PSID pSid)
     * }
     */
    public static FunctionDescriptor GetLengthSid$descriptor() {
        return GetLengthSid.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetLengthSid(PSID pSid)
     * }
     */
    public static MethodHandle GetLengthSid$handle() {
        return GetLengthSid.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * DWORD GetLengthSid(PSID pSid)
     * }
     */
    public static int GetLengthSid(MemorySegment pSid) {
        var mh$ = GetLengthSid.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetLengthSid", pSid);
            }
            return (int)mh$.invokeExact(pSid);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetPrivateObjectSecurity {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_LONG,
            C_POINTER,
            C_LONG,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetPrivateObjectSecurity"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetPrivateObjectSecurity(PSECURITY_DESCRIPTOR ObjectDescriptor, SECURITY_INFORMATION SecurityInformation, PSECURITY_DESCRIPTOR ResultantDescriptor, DWORD DescriptorLength, PDWORD ReturnLength)
     * }
     */
    public static FunctionDescriptor GetPrivateObjectSecurity$descriptor() {
        return GetPrivateObjectSecurity.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetPrivateObjectSecurity(PSECURITY_DESCRIPTOR ObjectDescriptor, SECURITY_INFORMATION SecurityInformation, PSECURITY_DESCRIPTOR ResultantDescriptor, DWORD DescriptorLength, PDWORD ReturnLength)
     * }
     */
    public static MethodHandle GetPrivateObjectSecurity$handle() {
        return GetPrivateObjectSecurity.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL GetPrivateObjectSecurity(PSECURITY_DESCRIPTOR ObjectDescriptor, SECURITY_INFORMATION SecurityInformation, PSECURITY_DESCRIPTOR ResultantDescriptor, DWORD DescriptorLength, PDWORD ReturnLength)
     * }
     */
    public static int GetPrivateObjectSecurity(MemorySegment ObjectDescriptor, int SecurityInformation, MemorySegment ResultantDescriptor, int DescriptorLength, MemorySegment ReturnLength) {
        var mh$ = GetPrivateObjectSecurity.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetPrivateObjectSecurity", ObjectDescriptor, SecurityInformation, ResultantDescriptor, DescriptorLength, ReturnLength);
            }
            return (int)mh$.invokeExact(ObjectDescriptor, SecurityInformation, ResultantDescriptor, DescriptorLength, ReturnLength);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetSecurityDescriptorControl {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetSecurityDescriptorControl"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetSecurityDescriptorControl(PSECURITY_DESCRIPTOR pSecurityDescriptor, PSECURITY_DESCRIPTOR_CONTROL pControl, LPDWORD lpdwRevision)
     * }
     */
    public static FunctionDescriptor GetSecurityDescriptorControl$descriptor() {
        return GetSecurityDescriptorControl.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetSecurityDescriptorControl(PSECURITY_DESCRIPTOR pSecurityDescriptor, PSECURITY_DESCRIPTOR_CONTROL pControl, LPDWORD lpdwRevision)
     * }
     */
    public static MethodHandle GetSecurityDescriptorControl$handle() {
        return GetSecurityDescriptorControl.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL GetSecurityDescriptorControl(PSECURITY_DESCRIPTOR pSecurityDescriptor, PSECURITY_DESCRIPTOR_CONTROL pControl, LPDWORD lpdwRevision)
     * }
     */
    public static int GetSecurityDescriptorControl(MemorySegment pSecurityDescriptor, MemorySegment pControl, MemorySegment lpdwRevision) {
        var mh$ = GetSecurityDescriptorControl.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetSecurityDescriptorControl", pSecurityDescriptor, pControl, lpdwRevision);
            }
            return (int)mh$.invokeExact(pSecurityDescriptor, pControl, lpdwRevision);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetSecurityDescriptorDacl {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetSecurityDescriptorDacl"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetSecurityDescriptorDacl(PSECURITY_DESCRIPTOR pSecurityDescriptor, LPBOOL lpbDaclPresent, PACL *pDacl, LPBOOL lpbDaclDefaulted)
     * }
     */
    public static FunctionDescriptor GetSecurityDescriptorDacl$descriptor() {
        return GetSecurityDescriptorDacl.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetSecurityDescriptorDacl(PSECURITY_DESCRIPTOR pSecurityDescriptor, LPBOOL lpbDaclPresent, PACL *pDacl, LPBOOL lpbDaclDefaulted)
     * }
     */
    public static MethodHandle GetSecurityDescriptorDacl$handle() {
        return GetSecurityDescriptorDacl.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL GetSecurityDescriptorDacl(PSECURITY_DESCRIPTOR pSecurityDescriptor, LPBOOL lpbDaclPresent, PACL *pDacl, LPBOOL lpbDaclDefaulted)
     * }
     */
    public static int GetSecurityDescriptorDacl(MemorySegment pSecurityDescriptor, MemorySegment lpbDaclPresent, MemorySegment pDacl, MemorySegment lpbDaclDefaulted) {
        var mh$ = GetSecurityDescriptorDacl.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetSecurityDescriptorDacl", pSecurityDescriptor, lpbDaclPresent, pDacl, lpbDaclDefaulted);
            }
            return (int)mh$.invokeExact(pSecurityDescriptor, lpbDaclPresent, pDacl, lpbDaclDefaulted);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetSecurityDescriptorGroup {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetSecurityDescriptorGroup"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetSecurityDescriptorGroup(PSECURITY_DESCRIPTOR pSecurityDescriptor, PSID *pGroup, LPBOOL lpbGroupDefaulted)
     * }
     */
    public static FunctionDescriptor GetSecurityDescriptorGroup$descriptor() {
        return GetSecurityDescriptorGroup.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetSecurityDescriptorGroup(PSECURITY_DESCRIPTOR pSecurityDescriptor, PSID *pGroup, LPBOOL lpbGroupDefaulted)
     * }
     */
    public static MethodHandle GetSecurityDescriptorGroup$handle() {
        return GetSecurityDescriptorGroup.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL GetSecurityDescriptorGroup(PSECURITY_DESCRIPTOR pSecurityDescriptor, PSID *pGroup, LPBOOL lpbGroupDefaulted)
     * }
     */
    public static int GetSecurityDescriptorGroup(MemorySegment pSecurityDescriptor, MemorySegment pGroup, MemorySegment lpbGroupDefaulted) {
        var mh$ = GetSecurityDescriptorGroup.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetSecurityDescriptorGroup", pSecurityDescriptor, pGroup, lpbGroupDefaulted);
            }
            return (int)mh$.invokeExact(pSecurityDescriptor, pGroup, lpbGroupDefaulted);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetSecurityDescriptorLength {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetSecurityDescriptorLength"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetSecurityDescriptorLength(PSECURITY_DESCRIPTOR pSecurityDescriptor)
     * }
     */
    public static FunctionDescriptor GetSecurityDescriptorLength$descriptor() {
        return GetSecurityDescriptorLength.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetSecurityDescriptorLength(PSECURITY_DESCRIPTOR pSecurityDescriptor)
     * }
     */
    public static MethodHandle GetSecurityDescriptorLength$handle() {
        return GetSecurityDescriptorLength.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * DWORD GetSecurityDescriptorLength(PSECURITY_DESCRIPTOR pSecurityDescriptor)
     * }
     */
    public static int GetSecurityDescriptorLength(MemorySegment pSecurityDescriptor) {
        var mh$ = GetSecurityDescriptorLength.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetSecurityDescriptorLength", pSecurityDescriptor);
            }
            return (int)mh$.invokeExact(pSecurityDescriptor);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetSecurityDescriptorOwner {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetSecurityDescriptorOwner"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetSecurityDescriptorOwner(PSECURITY_DESCRIPTOR pSecurityDescriptor, PSID *pOwner, LPBOOL lpbOwnerDefaulted)
     * }
     */
    public static FunctionDescriptor GetSecurityDescriptorOwner$descriptor() {
        return GetSecurityDescriptorOwner.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetSecurityDescriptorOwner(PSECURITY_DESCRIPTOR pSecurityDescriptor, PSID *pOwner, LPBOOL lpbOwnerDefaulted)
     * }
     */
    public static MethodHandle GetSecurityDescriptorOwner$handle() {
        return GetSecurityDescriptorOwner.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL GetSecurityDescriptorOwner(PSECURITY_DESCRIPTOR pSecurityDescriptor, PSID *pOwner, LPBOOL lpbOwnerDefaulted)
     * }
     */
    public static int GetSecurityDescriptorOwner(MemorySegment pSecurityDescriptor, MemorySegment pOwner, MemorySegment lpbOwnerDefaulted) {
        var mh$ = GetSecurityDescriptorOwner.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetSecurityDescriptorOwner", pSecurityDescriptor, pOwner, lpbOwnerDefaulted);
            }
            return (int)mh$.invokeExact(pSecurityDescriptor, pOwner, lpbOwnerDefaulted);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetSecurityDescriptorRMControl {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetSecurityDescriptorRMControl"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetSecurityDescriptorRMControl(PSECURITY_DESCRIPTOR SecurityDescriptor, PUCHAR RMControl)
     * }
     */
    public static FunctionDescriptor GetSecurityDescriptorRMControl$descriptor() {
        return GetSecurityDescriptorRMControl.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetSecurityDescriptorRMControl(PSECURITY_DESCRIPTOR SecurityDescriptor, PUCHAR RMControl)
     * }
     */
    public static MethodHandle GetSecurityDescriptorRMControl$handle() {
        return GetSecurityDescriptorRMControl.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * DWORD GetSecurityDescriptorRMControl(PSECURITY_DESCRIPTOR SecurityDescriptor, PUCHAR RMControl)
     * }
     */
    public static int GetSecurityDescriptorRMControl(MemorySegment SecurityDescriptor, MemorySegment RMControl) {
        var mh$ = GetSecurityDescriptorRMControl.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetSecurityDescriptorRMControl", SecurityDescriptor, RMControl);
            }
            return (int)mh$.invokeExact(SecurityDescriptor, RMControl);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetSecurityDescriptorSacl {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetSecurityDescriptorSacl"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetSecurityDescriptorSacl(PSECURITY_DESCRIPTOR pSecurityDescriptor, LPBOOL lpbSaclPresent, PACL *pSacl, LPBOOL lpbSaclDefaulted)
     * }
     */
    public static FunctionDescriptor GetSecurityDescriptorSacl$descriptor() {
        return GetSecurityDescriptorSacl.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetSecurityDescriptorSacl(PSECURITY_DESCRIPTOR pSecurityDescriptor, LPBOOL lpbSaclPresent, PACL *pSacl, LPBOOL lpbSaclDefaulted)
     * }
     */
    public static MethodHandle GetSecurityDescriptorSacl$handle() {
        return GetSecurityDescriptorSacl.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL GetSecurityDescriptorSacl(PSECURITY_DESCRIPTOR pSecurityDescriptor, LPBOOL lpbSaclPresent, PACL *pSacl, LPBOOL lpbSaclDefaulted)
     * }
     */
    public static int GetSecurityDescriptorSacl(MemorySegment pSecurityDescriptor, MemorySegment lpbSaclPresent, MemorySegment pSacl, MemorySegment lpbSaclDefaulted) {
        var mh$ = GetSecurityDescriptorSacl.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetSecurityDescriptorSacl", pSecurityDescriptor, lpbSaclPresent, pSacl, lpbSaclDefaulted);
            }
            return (int)mh$.invokeExact(pSecurityDescriptor, lpbSaclPresent, pSacl, lpbSaclDefaulted);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetSidIdentifierAuthority {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetSidIdentifierAuthority"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PSID_IDENTIFIER_AUTHORITY GetSidIdentifierAuthority(PSID pSid)
     * }
     */
    public static FunctionDescriptor GetSidIdentifierAuthority$descriptor() {
        return GetSidIdentifierAuthority.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PSID_IDENTIFIER_AUTHORITY GetSidIdentifierAuthority(PSID pSid)
     * }
     */
    public static MethodHandle GetSidIdentifierAuthority$handle() {
        return GetSidIdentifierAuthority.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * PSID_IDENTIFIER_AUTHORITY GetSidIdentifierAuthority(PSID pSid)
     * }
     */
    public static MemorySegment GetSidIdentifierAuthority(MemorySegment pSid) {
        var mh$ = GetSidIdentifierAuthority.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetSidIdentifierAuthority", pSid);
            }
            return (MemorySegment)mh$.invokeExact(pSid);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetSidLengthRequired {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_CHAR
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetSidLengthRequired"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetSidLengthRequired(UCHAR nSubAuthorityCount)
     * }
     */
    public static FunctionDescriptor GetSidLengthRequired$descriptor() {
        return GetSidLengthRequired.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetSidLengthRequired(UCHAR nSubAuthorityCount)
     * }
     */
    public static MethodHandle GetSidLengthRequired$handle() {
        return GetSidLengthRequired.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * DWORD GetSidLengthRequired(UCHAR nSubAuthorityCount)
     * }
     */
    public static int GetSidLengthRequired(byte nSubAuthorityCount) {
        var mh$ = GetSidLengthRequired.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetSidLengthRequired", nSubAuthorityCount);
            }
            return (int)mh$.invokeExact(nSubAuthorityCount);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetSidSubAuthority {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetSidSubAuthority"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PDWORD GetSidSubAuthority(PSID pSid, DWORD nSubAuthority)
     * }
     */
    public static FunctionDescriptor GetSidSubAuthority$descriptor() {
        return GetSidSubAuthority.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PDWORD GetSidSubAuthority(PSID pSid, DWORD nSubAuthority)
     * }
     */
    public static MethodHandle GetSidSubAuthority$handle() {
        return GetSidSubAuthority.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * PDWORD GetSidSubAuthority(PSID pSid, DWORD nSubAuthority)
     * }
     */
    public static MemorySegment GetSidSubAuthority(MemorySegment pSid, int nSubAuthority) {
        var mh$ = GetSidSubAuthority.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetSidSubAuthority", pSid, nSubAuthority);
            }
            return (MemorySegment)mh$.invokeExact(pSid, nSubAuthority);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetSidSubAuthorityCount {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetSidSubAuthorityCount"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PUCHAR GetSidSubAuthorityCount(PSID pSid)
     * }
     */
    public static FunctionDescriptor GetSidSubAuthorityCount$descriptor() {
        return GetSidSubAuthorityCount.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PUCHAR GetSidSubAuthorityCount(PSID pSid)
     * }
     */
    public static MethodHandle GetSidSubAuthorityCount$handle() {
        return GetSidSubAuthorityCount.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * PUCHAR GetSidSubAuthorityCount(PSID pSid)
     * }
     */
    public static MemorySegment GetSidSubAuthorityCount(MemorySegment pSid) {
        var mh$ = GetSidSubAuthorityCount.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetSidSubAuthorityCount", pSid);
            }
            return (MemorySegment)mh$.invokeExact(pSid);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetTokenInformation {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_INT,
            C_POINTER,
            C_LONG,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetTokenInformation"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetTokenInformation(HANDLE TokenHandle, TOKEN_INFORMATION_CLASS TokenInformationClass, LPVOID TokenInformation, DWORD TokenInformationLength, PDWORD ReturnLength)
     * }
     */
    public static FunctionDescriptor GetTokenInformation$descriptor() {
        return GetTokenInformation.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetTokenInformation(HANDLE TokenHandle, TOKEN_INFORMATION_CLASS TokenInformationClass, LPVOID TokenInformation, DWORD TokenInformationLength, PDWORD ReturnLength)
     * }
     */
    public static MethodHandle GetTokenInformation$handle() {
        return GetTokenInformation.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL GetTokenInformation(HANDLE TokenHandle, TOKEN_INFORMATION_CLASS TokenInformationClass, LPVOID TokenInformation, DWORD TokenInformationLength, PDWORD ReturnLength)
     * }
     */
    public static int GetTokenInformation(MemorySegment TokenHandle, int TokenInformationClass, MemorySegment TokenInformation, int TokenInformationLength, MemorySegment ReturnLength) {
        var mh$ = GetTokenInformation.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetTokenInformation", TokenHandle, TokenInformationClass, TokenInformation, TokenInformationLength, ReturnLength);
            }
            return (int)mh$.invokeExact(TokenHandle, TokenInformationClass, TokenInformation, TokenInformationLength, ReturnLength);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetWindowsAccountDomainSid {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetWindowsAccountDomainSid"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetWindowsAccountDomainSid(PSID pSid, PSID pDomainSid, DWORD *cbDomainSid)
     * }
     */
    public static FunctionDescriptor GetWindowsAccountDomainSid$descriptor() {
        return GetWindowsAccountDomainSid.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetWindowsAccountDomainSid(PSID pSid, PSID pDomainSid, DWORD *cbDomainSid)
     * }
     */
    public static MethodHandle GetWindowsAccountDomainSid$handle() {
        return GetWindowsAccountDomainSid.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL GetWindowsAccountDomainSid(PSID pSid, PSID pDomainSid, DWORD *cbDomainSid)
     * }
     */
    public static int GetWindowsAccountDomainSid(MemorySegment pSid, MemorySegment pDomainSid, MemorySegment cbDomainSid) {
        var mh$ = GetWindowsAccountDomainSid.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetWindowsAccountDomainSid", pSid, pDomainSid, cbDomainSid);
            }
            return (int)mh$.invokeExact(pSid, pDomainSid, cbDomainSid);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ImpersonateAnonymousToken {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("ImpersonateAnonymousToken"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL ImpersonateAnonymousToken(HANDLE ThreadHandle)
     * }
     */
    public static FunctionDescriptor ImpersonateAnonymousToken$descriptor() {
        return ImpersonateAnonymousToken.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL ImpersonateAnonymousToken(HANDLE ThreadHandle)
     * }
     */
    public static MethodHandle ImpersonateAnonymousToken$handle() {
        return ImpersonateAnonymousToken.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL ImpersonateAnonymousToken(HANDLE ThreadHandle)
     * }
     */
    public static int ImpersonateAnonymousToken(MemorySegment ThreadHandle) {
        var mh$ = ImpersonateAnonymousToken.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ImpersonateAnonymousToken", ThreadHandle);
            }
            return (int)mh$.invokeExact(ThreadHandle);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ImpersonateLoggedOnUser {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("ImpersonateLoggedOnUser"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL ImpersonateLoggedOnUser(HANDLE hToken)
     * }
     */
    public static FunctionDescriptor ImpersonateLoggedOnUser$descriptor() {
        return ImpersonateLoggedOnUser.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL ImpersonateLoggedOnUser(HANDLE hToken)
     * }
     */
    public static MethodHandle ImpersonateLoggedOnUser$handle() {
        return ImpersonateLoggedOnUser.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL ImpersonateLoggedOnUser(HANDLE hToken)
     * }
     */
    public static int ImpersonateLoggedOnUser(MemorySegment hToken) {
        var mh$ = ImpersonateLoggedOnUser.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ImpersonateLoggedOnUser", hToken);
            }
            return (int)mh$.invokeExact(hToken);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ImpersonateSelf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("ImpersonateSelf"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL ImpersonateSelf(SECURITY_IMPERSONATION_LEVEL ImpersonationLevel)
     * }
     */
    public static FunctionDescriptor ImpersonateSelf$descriptor() {
        return ImpersonateSelf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL ImpersonateSelf(SECURITY_IMPERSONATION_LEVEL ImpersonationLevel)
     * }
     */
    public static MethodHandle ImpersonateSelf$handle() {
        return ImpersonateSelf.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL ImpersonateSelf(SECURITY_IMPERSONATION_LEVEL ImpersonationLevel)
     * }
     */
    public static int ImpersonateSelf(int ImpersonationLevel) {
        var mh$ = ImpersonateSelf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ImpersonateSelf", ImpersonationLevel);
            }
            return (int)mh$.invokeExact(ImpersonationLevel);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class InitializeAcl {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_LONG,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("InitializeAcl"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL InitializeAcl(PACL pAcl, DWORD nAclLength, DWORD dwAclRevision)
     * }
     */
    public static FunctionDescriptor InitializeAcl$descriptor() {
        return InitializeAcl.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL InitializeAcl(PACL pAcl, DWORD nAclLength, DWORD dwAclRevision)
     * }
     */
    public static MethodHandle InitializeAcl$handle() {
        return InitializeAcl.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL InitializeAcl(PACL pAcl, DWORD nAclLength, DWORD dwAclRevision)
     * }
     */
    public static int InitializeAcl(MemorySegment pAcl, int nAclLength, int dwAclRevision) {
        var mh$ = InitializeAcl.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("InitializeAcl", pAcl, nAclLength, dwAclRevision);
            }
            return (int)mh$.invokeExact(pAcl, nAclLength, dwAclRevision);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class InitializeSecurityDescriptor {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("InitializeSecurityDescriptor"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL InitializeSecurityDescriptor(PSECURITY_DESCRIPTOR pSecurityDescriptor, DWORD dwRevision)
     * }
     */
    public static FunctionDescriptor InitializeSecurityDescriptor$descriptor() {
        return InitializeSecurityDescriptor.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL InitializeSecurityDescriptor(PSECURITY_DESCRIPTOR pSecurityDescriptor, DWORD dwRevision)
     * }
     */
    public static MethodHandle InitializeSecurityDescriptor$handle() {
        return InitializeSecurityDescriptor.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL InitializeSecurityDescriptor(PSECURITY_DESCRIPTOR pSecurityDescriptor, DWORD dwRevision)
     * }
     */
    public static int InitializeSecurityDescriptor(MemorySegment pSecurityDescriptor, int dwRevision) {
        var mh$ = InitializeSecurityDescriptor.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("InitializeSecurityDescriptor", pSecurityDescriptor, dwRevision);
            }
            return (int)mh$.invokeExact(pSecurityDescriptor, dwRevision);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class InitializeSid {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_CHAR
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("InitializeSid"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL InitializeSid(PSID Sid, PSID_IDENTIFIER_AUTHORITY pIdentifierAuthority, BYTE nSubAuthorityCount)
     * }
     */
    public static FunctionDescriptor InitializeSid$descriptor() {
        return InitializeSid.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL InitializeSid(PSID Sid, PSID_IDENTIFIER_AUTHORITY pIdentifierAuthority, BYTE nSubAuthorityCount)
     * }
     */
    public static MethodHandle InitializeSid$handle() {
        return InitializeSid.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL InitializeSid(PSID Sid, PSID_IDENTIFIER_AUTHORITY pIdentifierAuthority, BYTE nSubAuthorityCount)
     * }
     */
    public static int InitializeSid(MemorySegment Sid, MemorySegment pIdentifierAuthority, byte nSubAuthorityCount) {
        var mh$ = InitializeSid.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("InitializeSid", Sid, pIdentifierAuthority, nSubAuthorityCount);
            }
            return (int)mh$.invokeExact(Sid, pIdentifierAuthority, nSubAuthorityCount);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class IsTokenRestricted {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("IsTokenRestricted"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL IsTokenRestricted(HANDLE TokenHandle)
     * }
     */
    public static FunctionDescriptor IsTokenRestricted$descriptor() {
        return IsTokenRestricted.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL IsTokenRestricted(HANDLE TokenHandle)
     * }
     */
    public static MethodHandle IsTokenRestricted$handle() {
        return IsTokenRestricted.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL IsTokenRestricted(HANDLE TokenHandle)
     * }
     */
    public static int IsTokenRestricted(MemorySegment TokenHandle) {
        var mh$ = IsTokenRestricted.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("IsTokenRestricted", TokenHandle);
            }
            return (int)mh$.invokeExact(TokenHandle);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class IsValidAcl {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("IsValidAcl"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL IsValidAcl(PACL pAcl)
     * }
     */
    public static FunctionDescriptor IsValidAcl$descriptor() {
        return IsValidAcl.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL IsValidAcl(PACL pAcl)
     * }
     */
    public static MethodHandle IsValidAcl$handle() {
        return IsValidAcl.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL IsValidAcl(PACL pAcl)
     * }
     */
    public static int IsValidAcl(MemorySegment pAcl) {
        var mh$ = IsValidAcl.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("IsValidAcl", pAcl);
            }
            return (int)mh$.invokeExact(pAcl);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class IsValidSecurityDescriptor {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("IsValidSecurityDescriptor"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL IsValidSecurityDescriptor(PSECURITY_DESCRIPTOR pSecurityDescriptor)
     * }
     */
    public static FunctionDescriptor IsValidSecurityDescriptor$descriptor() {
        return IsValidSecurityDescriptor.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL IsValidSecurityDescriptor(PSECURITY_DESCRIPTOR pSecurityDescriptor)
     * }
     */
    public static MethodHandle IsValidSecurityDescriptor$handle() {
        return IsValidSecurityDescriptor.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL IsValidSecurityDescriptor(PSECURITY_DESCRIPTOR pSecurityDescriptor)
     * }
     */
    public static int IsValidSecurityDescriptor(MemorySegment pSecurityDescriptor) {
        var mh$ = IsValidSecurityDescriptor.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("IsValidSecurityDescriptor", pSecurityDescriptor);
            }
            return (int)mh$.invokeExact(pSecurityDescriptor);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class IsValidSid {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("IsValidSid"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL IsValidSid(PSID pSid)
     * }
     */
    public static FunctionDescriptor IsValidSid$descriptor() {
        return IsValidSid.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL IsValidSid(PSID pSid)
     * }
     */
    public static MethodHandle IsValidSid$handle() {
        return IsValidSid.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL IsValidSid(PSID pSid)
     * }
     */
    public static int IsValidSid(MemorySegment pSid) {
        var mh$ = IsValidSid.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("IsValidSid", pSid);
            }
            return (int)mh$.invokeExact(pSid);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class IsWellKnownSid {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("IsWellKnownSid"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL IsWellKnownSid(PSID pSid, WELL_KNOWN_SID_TYPE WellKnownSidType)
     * }
     */
    public static FunctionDescriptor IsWellKnownSid$descriptor() {
        return IsWellKnownSid.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL IsWellKnownSid(PSID pSid, WELL_KNOWN_SID_TYPE WellKnownSidType)
     * }
     */
    public static MethodHandle IsWellKnownSid$handle() {
        return IsWellKnownSid.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL IsWellKnownSid(PSID pSid, WELL_KNOWN_SID_TYPE WellKnownSidType)
     * }
     */
    public static int IsWellKnownSid(MemorySegment pSid, int WellKnownSidType) {
        var mh$ = IsWellKnownSid.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("IsWellKnownSid", pSid, WellKnownSidType);
            }
            return (int)mh$.invokeExact(pSid, WellKnownSidType);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MakeAbsoluteSD {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("MakeAbsoluteSD"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL MakeAbsoluteSD(PSECURITY_DESCRIPTOR pSelfRelativeSecurityDescriptor, PSECURITY_DESCRIPTOR pAbsoluteSecurityDescriptor, LPDWORD lpdwAbsoluteSecurityDescriptorSize, PACL pDacl, LPDWORD lpdwDaclSize, PACL pSacl, LPDWORD lpdwSaclSize, PSID pOwner, LPDWORD lpdwOwnerSize, PSID pPrimaryGroup, LPDWORD lpdwPrimaryGroupSize)
     * }
     */
    public static FunctionDescriptor MakeAbsoluteSD$descriptor() {
        return MakeAbsoluteSD.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL MakeAbsoluteSD(PSECURITY_DESCRIPTOR pSelfRelativeSecurityDescriptor, PSECURITY_DESCRIPTOR pAbsoluteSecurityDescriptor, LPDWORD lpdwAbsoluteSecurityDescriptorSize, PACL pDacl, LPDWORD lpdwDaclSize, PACL pSacl, LPDWORD lpdwSaclSize, PSID pOwner, LPDWORD lpdwOwnerSize, PSID pPrimaryGroup, LPDWORD lpdwPrimaryGroupSize)
     * }
     */
    public static MethodHandle MakeAbsoluteSD$handle() {
        return MakeAbsoluteSD.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL MakeAbsoluteSD(PSECURITY_DESCRIPTOR pSelfRelativeSecurityDescriptor, PSECURITY_DESCRIPTOR pAbsoluteSecurityDescriptor, LPDWORD lpdwAbsoluteSecurityDescriptorSize, PACL pDacl, LPDWORD lpdwDaclSize, PACL pSacl, LPDWORD lpdwSaclSize, PSID pOwner, LPDWORD lpdwOwnerSize, PSID pPrimaryGroup, LPDWORD lpdwPrimaryGroupSize)
     * }
     */
    public static int MakeAbsoluteSD(MemorySegment pSelfRelativeSecurityDescriptor, MemorySegment pAbsoluteSecurityDescriptor, MemorySegment lpdwAbsoluteSecurityDescriptorSize, MemorySegment pDacl, MemorySegment lpdwDaclSize, MemorySegment pSacl, MemorySegment lpdwSaclSize, MemorySegment pOwner, MemorySegment lpdwOwnerSize, MemorySegment pPrimaryGroup, MemorySegment lpdwPrimaryGroupSize) {
        var mh$ = MakeAbsoluteSD.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MakeAbsoluteSD", pSelfRelativeSecurityDescriptor, pAbsoluteSecurityDescriptor, lpdwAbsoluteSecurityDescriptorSize, pDacl, lpdwDaclSize, pSacl, lpdwSaclSize, pOwner, lpdwOwnerSize, pPrimaryGroup, lpdwPrimaryGroupSize);
            }
            return (int)mh$.invokeExact(pSelfRelativeSecurityDescriptor, pAbsoluteSecurityDescriptor, lpdwAbsoluteSecurityDescriptorSize, pDacl, lpdwDaclSize, pSacl, lpdwSaclSize, pOwner, lpdwOwnerSize, pPrimaryGroup, lpdwPrimaryGroupSize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MakeSelfRelativeSD {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("MakeSelfRelativeSD"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL MakeSelfRelativeSD(PSECURITY_DESCRIPTOR pAbsoluteSecurityDescriptor, PSECURITY_DESCRIPTOR pSelfRelativeSecurityDescriptor, LPDWORD lpdwBufferLength)
     * }
     */
    public static FunctionDescriptor MakeSelfRelativeSD$descriptor() {
        return MakeSelfRelativeSD.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL MakeSelfRelativeSD(PSECURITY_DESCRIPTOR pAbsoluteSecurityDescriptor, PSECURITY_DESCRIPTOR pSelfRelativeSecurityDescriptor, LPDWORD lpdwBufferLength)
     * }
     */
    public static MethodHandle MakeSelfRelativeSD$handle() {
        return MakeSelfRelativeSD.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL MakeSelfRelativeSD(PSECURITY_DESCRIPTOR pAbsoluteSecurityDescriptor, PSECURITY_DESCRIPTOR pSelfRelativeSecurityDescriptor, LPDWORD lpdwBufferLength)
     * }
     */
    public static int MakeSelfRelativeSD(MemorySegment pAbsoluteSecurityDescriptor, MemorySegment pSelfRelativeSecurityDescriptor, MemorySegment lpdwBufferLength) {
        var mh$ = MakeSelfRelativeSD.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MakeSelfRelativeSD", pAbsoluteSecurityDescriptor, pSelfRelativeSecurityDescriptor, lpdwBufferLength);
            }
            return (int)mh$.invokeExact(pAbsoluteSecurityDescriptor, pSelfRelativeSecurityDescriptor, lpdwBufferLength);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MapGenericMask {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("MapGenericMask"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void MapGenericMask(PDWORD AccessMask, PGENERIC_MAPPING GenericMapping)
     * }
     */
    public static FunctionDescriptor MapGenericMask$descriptor() {
        return MapGenericMask.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void MapGenericMask(PDWORD AccessMask, PGENERIC_MAPPING GenericMapping)
     * }
     */
    public static MethodHandle MapGenericMask$handle() {
        return MapGenericMask.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * void MapGenericMask(PDWORD AccessMask, PGENERIC_MAPPING GenericMapping)
     * }
     */
    public static void MapGenericMask(MemorySegment AccessMask, MemorySegment GenericMapping) {
        var mh$ = MapGenericMask.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MapGenericMask", AccessMask, GenericMapping);
            }
            mh$.invokeExact(AccessMask, GenericMapping);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ObjectCloseAuditAlarmW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("ObjectCloseAuditAlarmW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL ObjectCloseAuditAlarmW(LPCWSTR SubsystemName, LPVOID HandleId, BOOL GenerateOnClose)
     * }
     */
    public static FunctionDescriptor ObjectCloseAuditAlarmW$descriptor() {
        return ObjectCloseAuditAlarmW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL ObjectCloseAuditAlarmW(LPCWSTR SubsystemName, LPVOID HandleId, BOOL GenerateOnClose)
     * }
     */
    public static MethodHandle ObjectCloseAuditAlarmW$handle() {
        return ObjectCloseAuditAlarmW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL ObjectCloseAuditAlarmW(LPCWSTR SubsystemName, LPVOID HandleId, BOOL GenerateOnClose)
     * }
     */
    public static int ObjectCloseAuditAlarmW(MemorySegment SubsystemName, MemorySegment HandleId, int GenerateOnClose) {
        var mh$ = ObjectCloseAuditAlarmW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ObjectCloseAuditAlarmW", SubsystemName, HandleId, GenerateOnClose);
            }
            return (int)mh$.invokeExact(SubsystemName, HandleId, GenerateOnClose);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ObjectDeleteAuditAlarmW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("ObjectDeleteAuditAlarmW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL ObjectDeleteAuditAlarmW(LPCWSTR SubsystemName, LPVOID HandleId, BOOL GenerateOnClose)
     * }
     */
    public static FunctionDescriptor ObjectDeleteAuditAlarmW$descriptor() {
        return ObjectDeleteAuditAlarmW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL ObjectDeleteAuditAlarmW(LPCWSTR SubsystemName, LPVOID HandleId, BOOL GenerateOnClose)
     * }
     */
    public static MethodHandle ObjectDeleteAuditAlarmW$handle() {
        return ObjectDeleteAuditAlarmW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL ObjectDeleteAuditAlarmW(LPCWSTR SubsystemName, LPVOID HandleId, BOOL GenerateOnClose)
     * }
     */
    public static int ObjectDeleteAuditAlarmW(MemorySegment SubsystemName, MemorySegment HandleId, int GenerateOnClose) {
        var mh$ = ObjectDeleteAuditAlarmW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ObjectDeleteAuditAlarmW", SubsystemName, HandleId, GenerateOnClose);
            }
            return (int)mh$.invokeExact(SubsystemName, HandleId, GenerateOnClose);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ObjectOpenAuditAlarmW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_LONG,
            C_LONG,
            C_POINTER,
            C_INT,
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("ObjectOpenAuditAlarmW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL ObjectOpenAuditAlarmW(LPCWSTR SubsystemName, LPVOID HandleId, LPWSTR ObjectTypeName, LPWSTR ObjectName, PSECURITY_DESCRIPTOR pSecurityDescriptor, HANDLE ClientToken, DWORD DesiredAccess, DWORD GrantedAccess, PPRIVILEGE_SET Privileges, BOOL ObjectCreation, BOOL AccessGranted, LPBOOL GenerateOnClose)
     * }
     */
    public static FunctionDescriptor ObjectOpenAuditAlarmW$descriptor() {
        return ObjectOpenAuditAlarmW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL ObjectOpenAuditAlarmW(LPCWSTR SubsystemName, LPVOID HandleId, LPWSTR ObjectTypeName, LPWSTR ObjectName, PSECURITY_DESCRIPTOR pSecurityDescriptor, HANDLE ClientToken, DWORD DesiredAccess, DWORD GrantedAccess, PPRIVILEGE_SET Privileges, BOOL ObjectCreation, BOOL AccessGranted, LPBOOL GenerateOnClose)
     * }
     */
    public static MethodHandle ObjectOpenAuditAlarmW$handle() {
        return ObjectOpenAuditAlarmW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL ObjectOpenAuditAlarmW(LPCWSTR SubsystemName, LPVOID HandleId, LPWSTR ObjectTypeName, LPWSTR ObjectName, PSECURITY_DESCRIPTOR pSecurityDescriptor, HANDLE ClientToken, DWORD DesiredAccess, DWORD GrantedAccess, PPRIVILEGE_SET Privileges, BOOL ObjectCreation, BOOL AccessGranted, LPBOOL GenerateOnClose)
     * }
     */
    public static int ObjectOpenAuditAlarmW(MemorySegment SubsystemName, MemorySegment HandleId, MemorySegment ObjectTypeName, MemorySegment ObjectName, MemorySegment pSecurityDescriptor, MemorySegment ClientToken, int DesiredAccess, int GrantedAccess, MemorySegment Privileges, int ObjectCreation, int AccessGranted, MemorySegment GenerateOnClose) {
        var mh$ = ObjectOpenAuditAlarmW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ObjectOpenAuditAlarmW", SubsystemName, HandleId, ObjectTypeName, ObjectName, pSecurityDescriptor, ClientToken, DesiredAccess, GrantedAccess, Privileges, ObjectCreation, AccessGranted, GenerateOnClose);
            }
            return (int)mh$.invokeExact(SubsystemName, HandleId, ObjectTypeName, ObjectName, pSecurityDescriptor, ClientToken, DesiredAccess, GrantedAccess, Privileges, ObjectCreation, AccessGranted, GenerateOnClose);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ObjectPrivilegeAuditAlarmW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_LONG,
            C_POINTER,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("ObjectPrivilegeAuditAlarmW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL ObjectPrivilegeAuditAlarmW(LPCWSTR SubsystemName, LPVOID HandleId, HANDLE ClientToken, DWORD DesiredAccess, PPRIVILEGE_SET Privileges, BOOL AccessGranted)
     * }
     */
    public static FunctionDescriptor ObjectPrivilegeAuditAlarmW$descriptor() {
        return ObjectPrivilegeAuditAlarmW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL ObjectPrivilegeAuditAlarmW(LPCWSTR SubsystemName, LPVOID HandleId, HANDLE ClientToken, DWORD DesiredAccess, PPRIVILEGE_SET Privileges, BOOL AccessGranted)
     * }
     */
    public static MethodHandle ObjectPrivilegeAuditAlarmW$handle() {
        return ObjectPrivilegeAuditAlarmW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL ObjectPrivilegeAuditAlarmW(LPCWSTR SubsystemName, LPVOID HandleId, HANDLE ClientToken, DWORD DesiredAccess, PPRIVILEGE_SET Privileges, BOOL AccessGranted)
     * }
     */
    public static int ObjectPrivilegeAuditAlarmW(MemorySegment SubsystemName, MemorySegment HandleId, MemorySegment ClientToken, int DesiredAccess, MemorySegment Privileges, int AccessGranted) {
        var mh$ = ObjectPrivilegeAuditAlarmW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ObjectPrivilegeAuditAlarmW", SubsystemName, HandleId, ClientToken, DesiredAccess, Privileges, AccessGranted);
            }
            return (int)mh$.invokeExact(SubsystemName, HandleId, ClientToken, DesiredAccess, Privileges, AccessGranted);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PrivilegeCheck {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("PrivilegeCheck"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL PrivilegeCheck(HANDLE ClientToken, PPRIVILEGE_SET RequiredPrivileges, LPBOOL pfResult)
     * }
     */
    public static FunctionDescriptor PrivilegeCheck$descriptor() {
        return PrivilegeCheck.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL PrivilegeCheck(HANDLE ClientToken, PPRIVILEGE_SET RequiredPrivileges, LPBOOL pfResult)
     * }
     */
    public static MethodHandle PrivilegeCheck$handle() {
        return PrivilegeCheck.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL PrivilegeCheck(HANDLE ClientToken, PPRIVILEGE_SET RequiredPrivileges, LPBOOL pfResult)
     * }
     */
    public static int PrivilegeCheck(MemorySegment ClientToken, MemorySegment RequiredPrivileges, MemorySegment pfResult) {
        var mh$ = PrivilegeCheck.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PrivilegeCheck", ClientToken, RequiredPrivileges, pfResult);
            }
            return (int)mh$.invokeExact(ClientToken, RequiredPrivileges, pfResult);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PrivilegedServiceAuditAlarmW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("PrivilegedServiceAuditAlarmW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL PrivilegedServiceAuditAlarmW(LPCWSTR SubsystemName, LPCWSTR ServiceName, HANDLE ClientToken, PPRIVILEGE_SET Privileges, BOOL AccessGranted)
     * }
     */
    public static FunctionDescriptor PrivilegedServiceAuditAlarmW$descriptor() {
        return PrivilegedServiceAuditAlarmW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL PrivilegedServiceAuditAlarmW(LPCWSTR SubsystemName, LPCWSTR ServiceName, HANDLE ClientToken, PPRIVILEGE_SET Privileges, BOOL AccessGranted)
     * }
     */
    public static MethodHandle PrivilegedServiceAuditAlarmW$handle() {
        return PrivilegedServiceAuditAlarmW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL PrivilegedServiceAuditAlarmW(LPCWSTR SubsystemName, LPCWSTR ServiceName, HANDLE ClientToken, PPRIVILEGE_SET Privileges, BOOL AccessGranted)
     * }
     */
    public static int PrivilegedServiceAuditAlarmW(MemorySegment SubsystemName, MemorySegment ServiceName, MemorySegment ClientToken, MemorySegment Privileges, int AccessGranted) {
        var mh$ = PrivilegedServiceAuditAlarmW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PrivilegedServiceAuditAlarmW", SubsystemName, ServiceName, ClientToken, Privileges, AccessGranted);
            }
            return (int)mh$.invokeExact(SubsystemName, ServiceName, ClientToken, Privileges, AccessGranted);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class QuerySecurityAccessMask {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C_LONG,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("QuerySecurityAccessMask"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void QuerySecurityAccessMask(SECURITY_INFORMATION SecurityInformation, LPDWORD DesiredAccess)
     * }
     */
    public static FunctionDescriptor QuerySecurityAccessMask$descriptor() {
        return QuerySecurityAccessMask.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void QuerySecurityAccessMask(SECURITY_INFORMATION SecurityInformation, LPDWORD DesiredAccess)
     * }
     */
    public static MethodHandle QuerySecurityAccessMask$handle() {
        return QuerySecurityAccessMask.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * void QuerySecurityAccessMask(SECURITY_INFORMATION SecurityInformation, LPDWORD DesiredAccess)
     * }
     */
    public static void QuerySecurityAccessMask(int SecurityInformation, MemorySegment DesiredAccess) {
        var mh$ = QuerySecurityAccessMask.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("QuerySecurityAccessMask", SecurityInformation, DesiredAccess);
            }
            mh$.invokeExact(SecurityInformation, DesiredAccess);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RevertToSelf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT    );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("RevertToSelf"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL RevertToSelf()
     * }
     */
    public static FunctionDescriptor RevertToSelf$descriptor() {
        return RevertToSelf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL RevertToSelf()
     * }
     */
    public static MethodHandle RevertToSelf$handle() {
        return RevertToSelf.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL RevertToSelf()
     * }
     */
    public static int RevertToSelf() {
        var mh$ = RevertToSelf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RevertToSelf");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetAclInformation {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_LONG,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("SetAclInformation"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetAclInformation(PACL pAcl, LPVOID pAclInformation, DWORD nAclInformationLength, ACL_INFORMATION_CLASS dwAclInformationClass)
     * }
     */
    public static FunctionDescriptor SetAclInformation$descriptor() {
        return SetAclInformation.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetAclInformation(PACL pAcl, LPVOID pAclInformation, DWORD nAclInformationLength, ACL_INFORMATION_CLASS dwAclInformationClass)
     * }
     */
    public static MethodHandle SetAclInformation$handle() {
        return SetAclInformation.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL SetAclInformation(PACL pAcl, LPVOID pAclInformation, DWORD nAclInformationLength, ACL_INFORMATION_CLASS dwAclInformationClass)
     * }
     */
    public static int SetAclInformation(MemorySegment pAcl, MemorySegment pAclInformation, int nAclInformationLength, int dwAclInformationClass) {
        var mh$ = SetAclInformation.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetAclInformation", pAcl, pAclInformation, nAclInformationLength, dwAclInformationClass);
            }
            return (int)mh$.invokeExact(pAcl, pAclInformation, nAclInformationLength, dwAclInformationClass);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetFileSecurityW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_LONG,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("SetFileSecurityW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetFileSecurityW(LPCWSTR lpFileName, SECURITY_INFORMATION SecurityInformation, PSECURITY_DESCRIPTOR pSecurityDescriptor)
     * }
     */
    public static FunctionDescriptor SetFileSecurityW$descriptor() {
        return SetFileSecurityW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetFileSecurityW(LPCWSTR lpFileName, SECURITY_INFORMATION SecurityInformation, PSECURITY_DESCRIPTOR pSecurityDescriptor)
     * }
     */
    public static MethodHandle SetFileSecurityW$handle() {
        return SetFileSecurityW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL SetFileSecurityW(LPCWSTR lpFileName, SECURITY_INFORMATION SecurityInformation, PSECURITY_DESCRIPTOR pSecurityDescriptor)
     * }
     */
    public static int SetFileSecurityW(MemorySegment lpFileName, int SecurityInformation, MemorySegment pSecurityDescriptor) {
        var mh$ = SetFileSecurityW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetFileSecurityW", lpFileName, SecurityInformation, pSecurityDescriptor);
            }
            return (int)mh$.invokeExact(lpFileName, SecurityInformation, pSecurityDescriptor);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetKernelObjectSecurity {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_LONG,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("SetKernelObjectSecurity"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetKernelObjectSecurity(HANDLE Handle, SECURITY_INFORMATION SecurityInformation, PSECURITY_DESCRIPTOR SecurityDescriptor)
     * }
     */
    public static FunctionDescriptor SetKernelObjectSecurity$descriptor() {
        return SetKernelObjectSecurity.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetKernelObjectSecurity(HANDLE Handle, SECURITY_INFORMATION SecurityInformation, PSECURITY_DESCRIPTOR SecurityDescriptor)
     * }
     */
    public static MethodHandle SetKernelObjectSecurity$handle() {
        return SetKernelObjectSecurity.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL SetKernelObjectSecurity(HANDLE Handle, SECURITY_INFORMATION SecurityInformation, PSECURITY_DESCRIPTOR SecurityDescriptor)
     * }
     */
    public static int SetKernelObjectSecurity(MemorySegment Handle, int SecurityInformation, MemorySegment SecurityDescriptor) {
        var mh$ = SetKernelObjectSecurity.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetKernelObjectSecurity", Handle, SecurityInformation, SecurityDescriptor);
            }
            return (int)mh$.invokeExact(Handle, SecurityInformation, SecurityDescriptor);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetPrivateObjectSecurity {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_LONG,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("SetPrivateObjectSecurity"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetPrivateObjectSecurity(SECURITY_INFORMATION SecurityInformation, PSECURITY_DESCRIPTOR ModificationDescriptor, PSECURITY_DESCRIPTOR *ObjectsSecurityDescriptor, PGENERIC_MAPPING GenericMapping, HANDLE Token)
     * }
     */
    public static FunctionDescriptor SetPrivateObjectSecurity$descriptor() {
        return SetPrivateObjectSecurity.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetPrivateObjectSecurity(SECURITY_INFORMATION SecurityInformation, PSECURITY_DESCRIPTOR ModificationDescriptor, PSECURITY_DESCRIPTOR *ObjectsSecurityDescriptor, PGENERIC_MAPPING GenericMapping, HANDLE Token)
     * }
     */
    public static MethodHandle SetPrivateObjectSecurity$handle() {
        return SetPrivateObjectSecurity.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL SetPrivateObjectSecurity(SECURITY_INFORMATION SecurityInformation, PSECURITY_DESCRIPTOR ModificationDescriptor, PSECURITY_DESCRIPTOR *ObjectsSecurityDescriptor, PGENERIC_MAPPING GenericMapping, HANDLE Token)
     * }
     */
    public static int SetPrivateObjectSecurity(int SecurityInformation, MemorySegment ModificationDescriptor, MemorySegment ObjectsSecurityDescriptor, MemorySegment GenericMapping, MemorySegment Token) {
        var mh$ = SetPrivateObjectSecurity.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetPrivateObjectSecurity", SecurityInformation, ModificationDescriptor, ObjectsSecurityDescriptor, GenericMapping, Token);
            }
            return (int)mh$.invokeExact(SecurityInformation, ModificationDescriptor, ObjectsSecurityDescriptor, GenericMapping, Token);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetPrivateObjectSecurityEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_LONG,
            C_POINTER,
            C_POINTER,
            C_LONG,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("SetPrivateObjectSecurityEx"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetPrivateObjectSecurityEx(SECURITY_INFORMATION SecurityInformation, PSECURITY_DESCRIPTOR ModificationDescriptor, PSECURITY_DESCRIPTOR *ObjectsSecurityDescriptor, ULONG AutoInheritFlags, PGENERIC_MAPPING GenericMapping, HANDLE Token)
     * }
     */
    public static FunctionDescriptor SetPrivateObjectSecurityEx$descriptor() {
        return SetPrivateObjectSecurityEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetPrivateObjectSecurityEx(SECURITY_INFORMATION SecurityInformation, PSECURITY_DESCRIPTOR ModificationDescriptor, PSECURITY_DESCRIPTOR *ObjectsSecurityDescriptor, ULONG AutoInheritFlags, PGENERIC_MAPPING GenericMapping, HANDLE Token)
     * }
     */
    public static MethodHandle SetPrivateObjectSecurityEx$handle() {
        return SetPrivateObjectSecurityEx.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL SetPrivateObjectSecurityEx(SECURITY_INFORMATION SecurityInformation, PSECURITY_DESCRIPTOR ModificationDescriptor, PSECURITY_DESCRIPTOR *ObjectsSecurityDescriptor, ULONG AutoInheritFlags, PGENERIC_MAPPING GenericMapping, HANDLE Token)
     * }
     */
    public static int SetPrivateObjectSecurityEx(int SecurityInformation, MemorySegment ModificationDescriptor, MemorySegment ObjectsSecurityDescriptor, int AutoInheritFlags, MemorySegment GenericMapping, MemorySegment Token) {
        var mh$ = SetPrivateObjectSecurityEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetPrivateObjectSecurityEx", SecurityInformation, ModificationDescriptor, ObjectsSecurityDescriptor, AutoInheritFlags, GenericMapping, Token);
            }
            return (int)mh$.invokeExact(SecurityInformation, ModificationDescriptor, ObjectsSecurityDescriptor, AutoInheritFlags, GenericMapping, Token);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetSecurityAccessMask {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C_LONG,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("SetSecurityAccessMask"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SetSecurityAccessMask(SECURITY_INFORMATION SecurityInformation, LPDWORD DesiredAccess)
     * }
     */
    public static FunctionDescriptor SetSecurityAccessMask$descriptor() {
        return SetSecurityAccessMask.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SetSecurityAccessMask(SECURITY_INFORMATION SecurityInformation, LPDWORD DesiredAccess)
     * }
     */
    public static MethodHandle SetSecurityAccessMask$handle() {
        return SetSecurityAccessMask.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * void SetSecurityAccessMask(SECURITY_INFORMATION SecurityInformation, LPDWORD DesiredAccess)
     * }
     */
    public static void SetSecurityAccessMask(int SecurityInformation, MemorySegment DesiredAccess) {
        var mh$ = SetSecurityAccessMask.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetSecurityAccessMask", SecurityInformation, DesiredAccess);
            }
            mh$.invokeExact(SecurityInformation, DesiredAccess);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetSecurityDescriptorControl {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_SHORT,
            C_SHORT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("SetSecurityDescriptorControl"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetSecurityDescriptorControl(PSECURITY_DESCRIPTOR pSecurityDescriptor, SECURITY_DESCRIPTOR_CONTROL ControlBitsOfInterest, SECURITY_DESCRIPTOR_CONTROL ControlBitsToSet)
     * }
     */
    public static FunctionDescriptor SetSecurityDescriptorControl$descriptor() {
        return SetSecurityDescriptorControl.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetSecurityDescriptorControl(PSECURITY_DESCRIPTOR pSecurityDescriptor, SECURITY_DESCRIPTOR_CONTROL ControlBitsOfInterest, SECURITY_DESCRIPTOR_CONTROL ControlBitsToSet)
     * }
     */
    public static MethodHandle SetSecurityDescriptorControl$handle() {
        return SetSecurityDescriptorControl.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL SetSecurityDescriptorControl(PSECURITY_DESCRIPTOR pSecurityDescriptor, SECURITY_DESCRIPTOR_CONTROL ControlBitsOfInterest, SECURITY_DESCRIPTOR_CONTROL ControlBitsToSet)
     * }
     */
    public static int SetSecurityDescriptorControl(MemorySegment pSecurityDescriptor, short ControlBitsOfInterest, short ControlBitsToSet) {
        var mh$ = SetSecurityDescriptorControl.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetSecurityDescriptorControl", pSecurityDescriptor, ControlBitsOfInterest, ControlBitsToSet);
            }
            return (int)mh$.invokeExact(pSecurityDescriptor, ControlBitsOfInterest, ControlBitsToSet);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetSecurityDescriptorDacl {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_INT,
            C_POINTER,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("SetSecurityDescriptorDacl"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetSecurityDescriptorDacl(PSECURITY_DESCRIPTOR pSecurityDescriptor, BOOL bDaclPresent, PACL pDacl, BOOL bDaclDefaulted)
     * }
     */
    public static FunctionDescriptor SetSecurityDescriptorDacl$descriptor() {
        return SetSecurityDescriptorDacl.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetSecurityDescriptorDacl(PSECURITY_DESCRIPTOR pSecurityDescriptor, BOOL bDaclPresent, PACL pDacl, BOOL bDaclDefaulted)
     * }
     */
    public static MethodHandle SetSecurityDescriptorDacl$handle() {
        return SetSecurityDescriptorDacl.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL SetSecurityDescriptorDacl(PSECURITY_DESCRIPTOR pSecurityDescriptor, BOOL bDaclPresent, PACL pDacl, BOOL bDaclDefaulted)
     * }
     */
    public static int SetSecurityDescriptorDacl(MemorySegment pSecurityDescriptor, int bDaclPresent, MemorySegment pDacl, int bDaclDefaulted) {
        var mh$ = SetSecurityDescriptorDacl.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetSecurityDescriptorDacl", pSecurityDescriptor, bDaclPresent, pDacl, bDaclDefaulted);
            }
            return (int)mh$.invokeExact(pSecurityDescriptor, bDaclPresent, pDacl, bDaclDefaulted);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetSecurityDescriptorGroup {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("SetSecurityDescriptorGroup"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetSecurityDescriptorGroup(PSECURITY_DESCRIPTOR pSecurityDescriptor, PSID pGroup, BOOL bGroupDefaulted)
     * }
     */
    public static FunctionDescriptor SetSecurityDescriptorGroup$descriptor() {
        return SetSecurityDescriptorGroup.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetSecurityDescriptorGroup(PSECURITY_DESCRIPTOR pSecurityDescriptor, PSID pGroup, BOOL bGroupDefaulted)
     * }
     */
    public static MethodHandle SetSecurityDescriptorGroup$handle() {
        return SetSecurityDescriptorGroup.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL SetSecurityDescriptorGroup(PSECURITY_DESCRIPTOR pSecurityDescriptor, PSID pGroup, BOOL bGroupDefaulted)
     * }
     */
    public static int SetSecurityDescriptorGroup(MemorySegment pSecurityDescriptor, MemorySegment pGroup, int bGroupDefaulted) {
        var mh$ = SetSecurityDescriptorGroup.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetSecurityDescriptorGroup", pSecurityDescriptor, pGroup, bGroupDefaulted);
            }
            return (int)mh$.invokeExact(pSecurityDescriptor, pGroup, bGroupDefaulted);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetSecurityDescriptorOwner {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("SetSecurityDescriptorOwner"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetSecurityDescriptorOwner(PSECURITY_DESCRIPTOR pSecurityDescriptor, PSID pOwner, BOOL bOwnerDefaulted)
     * }
     */
    public static FunctionDescriptor SetSecurityDescriptorOwner$descriptor() {
        return SetSecurityDescriptorOwner.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetSecurityDescriptorOwner(PSECURITY_DESCRIPTOR pSecurityDescriptor, PSID pOwner, BOOL bOwnerDefaulted)
     * }
     */
    public static MethodHandle SetSecurityDescriptorOwner$handle() {
        return SetSecurityDescriptorOwner.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL SetSecurityDescriptorOwner(PSECURITY_DESCRIPTOR pSecurityDescriptor, PSID pOwner, BOOL bOwnerDefaulted)
     * }
     */
    public static int SetSecurityDescriptorOwner(MemorySegment pSecurityDescriptor, MemorySegment pOwner, int bOwnerDefaulted) {
        var mh$ = SetSecurityDescriptorOwner.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetSecurityDescriptorOwner", pSecurityDescriptor, pOwner, bOwnerDefaulted);
            }
            return (int)mh$.invokeExact(pSecurityDescriptor, pOwner, bOwnerDefaulted);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetSecurityDescriptorRMControl {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("SetSecurityDescriptorRMControl"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD SetSecurityDescriptorRMControl(PSECURITY_DESCRIPTOR SecurityDescriptor, PUCHAR RMControl)
     * }
     */
    public static FunctionDescriptor SetSecurityDescriptorRMControl$descriptor() {
        return SetSecurityDescriptorRMControl.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD SetSecurityDescriptorRMControl(PSECURITY_DESCRIPTOR SecurityDescriptor, PUCHAR RMControl)
     * }
     */
    public static MethodHandle SetSecurityDescriptorRMControl$handle() {
        return SetSecurityDescriptorRMControl.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * DWORD SetSecurityDescriptorRMControl(PSECURITY_DESCRIPTOR SecurityDescriptor, PUCHAR RMControl)
     * }
     */
    public static int SetSecurityDescriptorRMControl(MemorySegment SecurityDescriptor, MemorySegment RMControl) {
        var mh$ = SetSecurityDescriptorRMControl.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetSecurityDescriptorRMControl", SecurityDescriptor, RMControl);
            }
            return (int)mh$.invokeExact(SecurityDescriptor, RMControl);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetSecurityDescriptorSacl {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_INT,
            C_POINTER,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("SetSecurityDescriptorSacl"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetSecurityDescriptorSacl(PSECURITY_DESCRIPTOR pSecurityDescriptor, BOOL bSaclPresent, PACL pSacl, BOOL bSaclDefaulted)
     * }
     */
    public static FunctionDescriptor SetSecurityDescriptorSacl$descriptor() {
        return SetSecurityDescriptorSacl.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetSecurityDescriptorSacl(PSECURITY_DESCRIPTOR pSecurityDescriptor, BOOL bSaclPresent, PACL pSacl, BOOL bSaclDefaulted)
     * }
     */
    public static MethodHandle SetSecurityDescriptorSacl$handle() {
        return SetSecurityDescriptorSacl.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL SetSecurityDescriptorSacl(PSECURITY_DESCRIPTOR pSecurityDescriptor, BOOL bSaclPresent, PACL pSacl, BOOL bSaclDefaulted)
     * }
     */
    public static int SetSecurityDescriptorSacl(MemorySegment pSecurityDescriptor, int bSaclPresent, MemorySegment pSacl, int bSaclDefaulted) {
        var mh$ = SetSecurityDescriptorSacl.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetSecurityDescriptorSacl", pSecurityDescriptor, bSaclPresent, pSacl, bSaclDefaulted);
            }
            return (int)mh$.invokeExact(pSecurityDescriptor, bSaclPresent, pSacl, bSaclDefaulted);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetTokenInformation {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_INT,
            C_POINTER,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("SetTokenInformation"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetTokenInformation(HANDLE TokenHandle, TOKEN_INFORMATION_CLASS TokenInformationClass, LPVOID TokenInformation, DWORD TokenInformationLength)
     * }
     */
    public static FunctionDescriptor SetTokenInformation$descriptor() {
        return SetTokenInformation.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetTokenInformation(HANDLE TokenHandle, TOKEN_INFORMATION_CLASS TokenInformationClass, LPVOID TokenInformation, DWORD TokenInformationLength)
     * }
     */
    public static MethodHandle SetTokenInformation$handle() {
        return SetTokenInformation.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL SetTokenInformation(HANDLE TokenHandle, TOKEN_INFORMATION_CLASS TokenInformationClass, LPVOID TokenInformation, DWORD TokenInformationLength)
     * }
     */
    public static int SetTokenInformation(MemorySegment TokenHandle, int TokenInformationClass, MemorySegment TokenInformation, int TokenInformationLength) {
        var mh$ = SetTokenInformation.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetTokenInformation", TokenHandle, TokenInformationClass, TokenInformation, TokenInformationLength);
            }
            return (int)mh$.invokeExact(TokenHandle, TokenInformationClass, TokenInformation, TokenInformationLength);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetCachedSigningLevel {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_LONG,
            C_LONG,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("SetCachedSigningLevel"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetCachedSigningLevel(PHANDLE SourceFiles, ULONG SourceFileCount, ULONG Flags, HANDLE TargetFile)
     * }
     */
    public static FunctionDescriptor SetCachedSigningLevel$descriptor() {
        return SetCachedSigningLevel.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetCachedSigningLevel(PHANDLE SourceFiles, ULONG SourceFileCount, ULONG Flags, HANDLE TargetFile)
     * }
     */
    public static MethodHandle SetCachedSigningLevel$handle() {
        return SetCachedSigningLevel.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL SetCachedSigningLevel(PHANDLE SourceFiles, ULONG SourceFileCount, ULONG Flags, HANDLE TargetFile)
     * }
     */
    public static int SetCachedSigningLevel(MemorySegment SourceFiles, int SourceFileCount, int Flags, MemorySegment TargetFile) {
        var mh$ = SetCachedSigningLevel.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetCachedSigningLevel", SourceFiles, SourceFileCount, Flags, TargetFile);
            }
            return (int)mh$.invokeExact(SourceFiles, SourceFileCount, Flags, TargetFile);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetCachedSigningLevel {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetCachedSigningLevel"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetCachedSigningLevel(HANDLE File, PULONG Flags, PULONG SigningLevel, PUCHAR Thumbprint, PULONG ThumbprintSize, PULONG ThumbprintAlgorithm)
     * }
     */
    public static FunctionDescriptor GetCachedSigningLevel$descriptor() {
        return GetCachedSigningLevel.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetCachedSigningLevel(HANDLE File, PULONG Flags, PULONG SigningLevel, PUCHAR Thumbprint, PULONG ThumbprintSize, PULONG ThumbprintAlgorithm)
     * }
     */
    public static MethodHandle GetCachedSigningLevel$handle() {
        return GetCachedSigningLevel.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL GetCachedSigningLevel(HANDLE File, PULONG Flags, PULONG SigningLevel, PUCHAR Thumbprint, PULONG ThumbprintSize, PULONG ThumbprintAlgorithm)
     * }
     */
    public static int GetCachedSigningLevel(MemorySegment File, MemorySegment Flags, MemorySegment SigningLevel, MemorySegment Thumbprint, MemorySegment ThumbprintSize, MemorySegment ThumbprintAlgorithm) {
        var mh$ = GetCachedSigningLevel.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetCachedSigningLevel", File, Flags, SigningLevel, Thumbprint, ThumbprintSize, ThumbprintAlgorithm);
            }
            return (int)mh$.invokeExact(File, Flags, SigningLevel, Thumbprint, ThumbprintSize, ThumbprintAlgorithm);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CveEventWrite {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CveEventWrite"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LONG CveEventWrite(PCWSTR CveId, PCWSTR AdditionalDetails)
     * }
     */
    public static FunctionDescriptor CveEventWrite$descriptor() {
        return CveEventWrite.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LONG CveEventWrite(PCWSTR CveId, PCWSTR AdditionalDetails)
     * }
     */
    public static MethodHandle CveEventWrite$handle() {
        return CveEventWrite.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * LONG CveEventWrite(PCWSTR CveId, PCWSTR AdditionalDetails)
     * }
     */
    public static int CveEventWrite(MemorySegment CveId, MemorySegment AdditionalDetails) {
        var mh$ = CveEventWrite.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CveEventWrite", CveId, AdditionalDetails);
            }
            return (int)mh$.invokeExact(CveId, AdditionalDetails);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DeriveCapabilitySidsFromName {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("DeriveCapabilitySidsFromName"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL DeriveCapabilitySidsFromName(LPCWSTR CapName, PSID **CapabilityGroupSids, DWORD *CapabilityGroupSidCount, PSID **CapabilitySids, DWORD *CapabilitySidCount)
     * }
     */
    public static FunctionDescriptor DeriveCapabilitySidsFromName$descriptor() {
        return DeriveCapabilitySidsFromName.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL DeriveCapabilitySidsFromName(LPCWSTR CapName, PSID **CapabilityGroupSids, DWORD *CapabilityGroupSidCount, PSID **CapabilitySids, DWORD *CapabilitySidCount)
     * }
     */
    public static MethodHandle DeriveCapabilitySidsFromName$handle() {
        return DeriveCapabilitySidsFromName.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL DeriveCapabilitySidsFromName(LPCWSTR CapName, PSID **CapabilityGroupSids, DWORD *CapabilityGroupSidCount, PSID **CapabilitySids, DWORD *CapabilitySidCount)
     * }
     */
    public static int DeriveCapabilitySidsFromName(MemorySegment CapName, MemorySegment CapabilityGroupSids, MemorySegment CapabilityGroupSidCount, MemorySegment CapabilitySids, MemorySegment CapabilitySidCount) {
        var mh$ = DeriveCapabilitySidsFromName.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DeriveCapabilitySidsFromName", CapName, CapabilityGroupSids, CapabilityGroupSidCount, CapabilitySids, CapabilitySidCount);
            }
            return (int)mh$.invokeExact(CapName, CapabilityGroupSids, CapabilityGroupSidCount, CapabilitySids, CapabilitySidCount);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreatePrivateNamespaceW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CreatePrivateNamespaceW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HANDLE CreatePrivateNamespaceW(LPSECURITY_ATTRIBUTES lpPrivateNamespaceAttributes, LPVOID lpBoundaryDescriptor, LPCWSTR lpAliasPrefix)
     * }
     */
    public static FunctionDescriptor CreatePrivateNamespaceW$descriptor() {
        return CreatePrivateNamespaceW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HANDLE CreatePrivateNamespaceW(LPSECURITY_ATTRIBUTES lpPrivateNamespaceAttributes, LPVOID lpBoundaryDescriptor, LPCWSTR lpAliasPrefix)
     * }
     */
    public static MethodHandle CreatePrivateNamespaceW$handle() {
        return CreatePrivateNamespaceW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * HANDLE CreatePrivateNamespaceW(LPSECURITY_ATTRIBUTES lpPrivateNamespaceAttributes, LPVOID lpBoundaryDescriptor, LPCWSTR lpAliasPrefix)
     * }
     */
    public static MemorySegment CreatePrivateNamespaceW(MemorySegment lpPrivateNamespaceAttributes, MemorySegment lpBoundaryDescriptor, MemorySegment lpAliasPrefix) {
        var mh$ = CreatePrivateNamespaceW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreatePrivateNamespaceW", lpPrivateNamespaceAttributes, lpBoundaryDescriptor, lpAliasPrefix);
            }
            return (MemorySegment)mh$.invokeExact(lpPrivateNamespaceAttributes, lpBoundaryDescriptor, lpAliasPrefix);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class OpenPrivateNamespaceW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("OpenPrivateNamespaceW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HANDLE OpenPrivateNamespaceW(LPVOID lpBoundaryDescriptor, LPCWSTR lpAliasPrefix)
     * }
     */
    public static FunctionDescriptor OpenPrivateNamespaceW$descriptor() {
        return OpenPrivateNamespaceW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HANDLE OpenPrivateNamespaceW(LPVOID lpBoundaryDescriptor, LPCWSTR lpAliasPrefix)
     * }
     */
    public static MethodHandle OpenPrivateNamespaceW$handle() {
        return OpenPrivateNamespaceW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * HANDLE OpenPrivateNamespaceW(LPVOID lpBoundaryDescriptor, LPCWSTR lpAliasPrefix)
     * }
     */
    public static MemorySegment OpenPrivateNamespaceW(MemorySegment lpBoundaryDescriptor, MemorySegment lpAliasPrefix) {
        var mh$ = OpenPrivateNamespaceW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("OpenPrivateNamespaceW", lpBoundaryDescriptor, lpAliasPrefix);
            }
            return (MemorySegment)mh$.invokeExact(lpBoundaryDescriptor, lpAliasPrefix);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ClosePrivateNamespace {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_CHAR,
            C_POINTER,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("ClosePrivateNamespace"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOLEAN ClosePrivateNamespace(HANDLE Handle, ULONG Flags)
     * }
     */
    public static FunctionDescriptor ClosePrivateNamespace$descriptor() {
        return ClosePrivateNamespace.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOLEAN ClosePrivateNamespace(HANDLE Handle, ULONG Flags)
     * }
     */
    public static MethodHandle ClosePrivateNamespace$handle() {
        return ClosePrivateNamespace.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOLEAN ClosePrivateNamespace(HANDLE Handle, ULONG Flags)
     * }
     */
    public static byte ClosePrivateNamespace(MemorySegment Handle, int Flags) {
        var mh$ = ClosePrivateNamespace.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ClosePrivateNamespace", Handle, Flags);
            }
            return (byte)mh$.invokeExact(Handle, Flags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateBoundaryDescriptorW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CreateBoundaryDescriptorW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HANDLE CreateBoundaryDescriptorW(LPCWSTR Name, ULONG Flags)
     * }
     */
    public static FunctionDescriptor CreateBoundaryDescriptorW$descriptor() {
        return CreateBoundaryDescriptorW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HANDLE CreateBoundaryDescriptorW(LPCWSTR Name, ULONG Flags)
     * }
     */
    public static MethodHandle CreateBoundaryDescriptorW$handle() {
        return CreateBoundaryDescriptorW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * HANDLE CreateBoundaryDescriptorW(LPCWSTR Name, ULONG Flags)
     * }
     */
    public static MemorySegment CreateBoundaryDescriptorW(MemorySegment Name, int Flags) {
        var mh$ = CreateBoundaryDescriptorW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateBoundaryDescriptorW", Name, Flags);
            }
            return (MemorySegment)mh$.invokeExact(Name, Flags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class AddSIDToBoundaryDescriptor {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("AddSIDToBoundaryDescriptor"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL AddSIDToBoundaryDescriptor(HANDLE *BoundaryDescriptor, PSID RequiredSid)
     * }
     */
    public static FunctionDescriptor AddSIDToBoundaryDescriptor$descriptor() {
        return AddSIDToBoundaryDescriptor.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL AddSIDToBoundaryDescriptor(HANDLE *BoundaryDescriptor, PSID RequiredSid)
     * }
     */
    public static MethodHandle AddSIDToBoundaryDescriptor$handle() {
        return AddSIDToBoundaryDescriptor.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL AddSIDToBoundaryDescriptor(HANDLE *BoundaryDescriptor, PSID RequiredSid)
     * }
     */
    public static int AddSIDToBoundaryDescriptor(MemorySegment BoundaryDescriptor, MemorySegment RequiredSid) {
        var mh$ = AddSIDToBoundaryDescriptor.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("AddSIDToBoundaryDescriptor", BoundaryDescriptor, RequiredSid);
            }
            return (int)mh$.invokeExact(BoundaryDescriptor, RequiredSid);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DeleteBoundaryDescriptor {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("DeleteBoundaryDescriptor"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void DeleteBoundaryDescriptor(HANDLE BoundaryDescriptor)
     * }
     */
    public static FunctionDescriptor DeleteBoundaryDescriptor$descriptor() {
        return DeleteBoundaryDescriptor.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void DeleteBoundaryDescriptor(HANDLE BoundaryDescriptor)
     * }
     */
    public static MethodHandle DeleteBoundaryDescriptor$handle() {
        return DeleteBoundaryDescriptor.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * void DeleteBoundaryDescriptor(HANDLE BoundaryDescriptor)
     * }
     */
    public static void DeleteBoundaryDescriptor(MemorySegment BoundaryDescriptor) {
        var mh$ = DeleteBoundaryDescriptor.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DeleteBoundaryDescriptor", BoundaryDescriptor);
            }
            mh$.invokeExact(BoundaryDescriptor);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetNumaHighestNodeNumber {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetNumaHighestNodeNumber"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetNumaHighestNodeNumber(PULONG HighestNodeNumber)
     * }
     */
    public static FunctionDescriptor GetNumaHighestNodeNumber$descriptor() {
        return GetNumaHighestNodeNumber.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetNumaHighestNodeNumber(PULONG HighestNodeNumber)
     * }
     */
    public static MethodHandle GetNumaHighestNodeNumber$handle() {
        return GetNumaHighestNodeNumber.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL GetNumaHighestNodeNumber(PULONG HighestNodeNumber)
     * }
     */
    public static int GetNumaHighestNodeNumber(MemorySegment HighestNodeNumber) {
        var mh$ = GetNumaHighestNodeNumber.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetNumaHighestNodeNumber", HighestNodeNumber);
            }
            return (int)mh$.invokeExact(HighestNodeNumber);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetNumaNodeProcessorMaskEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_SHORT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetNumaNodeProcessorMaskEx"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetNumaNodeProcessorMaskEx(USHORT Node, PGROUP_AFFINITY ProcessorMask)
     * }
     */
    public static FunctionDescriptor GetNumaNodeProcessorMaskEx$descriptor() {
        return GetNumaNodeProcessorMaskEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetNumaNodeProcessorMaskEx(USHORT Node, PGROUP_AFFINITY ProcessorMask)
     * }
     */
    public static MethodHandle GetNumaNodeProcessorMaskEx$handle() {
        return GetNumaNodeProcessorMaskEx.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL GetNumaNodeProcessorMaskEx(USHORT Node, PGROUP_AFFINITY ProcessorMask)
     * }
     */
    public static int GetNumaNodeProcessorMaskEx(short Node, MemorySegment ProcessorMask) {
        var mh$ = GetNumaNodeProcessorMaskEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetNumaNodeProcessorMaskEx", Node, ProcessorMask);
            }
            return (int)mh$.invokeExact(Node, ProcessorMask);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetNumaNodeProcessorMask2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_SHORT,
            C_POINTER,
            C_SHORT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetNumaNodeProcessorMask2"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetNumaNodeProcessorMask2(USHORT NodeNumber, PGROUP_AFFINITY ProcessorMasks, USHORT ProcessorMaskCount, PUSHORT RequiredMaskCount)
     * }
     */
    public static FunctionDescriptor GetNumaNodeProcessorMask2$descriptor() {
        return GetNumaNodeProcessorMask2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetNumaNodeProcessorMask2(USHORT NodeNumber, PGROUP_AFFINITY ProcessorMasks, USHORT ProcessorMaskCount, PUSHORT RequiredMaskCount)
     * }
     */
    public static MethodHandle GetNumaNodeProcessorMask2$handle() {
        return GetNumaNodeProcessorMask2.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL GetNumaNodeProcessorMask2(USHORT NodeNumber, PGROUP_AFFINITY ProcessorMasks, USHORT ProcessorMaskCount, PUSHORT RequiredMaskCount)
     * }
     */
    public static int GetNumaNodeProcessorMask2(short NodeNumber, MemorySegment ProcessorMasks, short ProcessorMaskCount, MemorySegment RequiredMaskCount) {
        var mh$ = GetNumaNodeProcessorMask2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetNumaNodeProcessorMask2", NodeNumber, ProcessorMasks, ProcessorMaskCount, RequiredMaskCount);
            }
            return (int)mh$.invokeExact(NodeNumber, ProcessorMasks, ProcessorMaskCount, RequiredMaskCount);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetNumaProximityNodeEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_LONG,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetNumaProximityNodeEx"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetNumaProximityNodeEx(ULONG ProximityId, PUSHORT NodeNumber)
     * }
     */
    public static FunctionDescriptor GetNumaProximityNodeEx$descriptor() {
        return GetNumaProximityNodeEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetNumaProximityNodeEx(ULONG ProximityId, PUSHORT NodeNumber)
     * }
     */
    public static MethodHandle GetNumaProximityNodeEx$handle() {
        return GetNumaProximityNodeEx.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL GetNumaProximityNodeEx(ULONG ProximityId, PUSHORT NodeNumber)
     * }
     */
    public static int GetNumaProximityNodeEx(int ProximityId, MemorySegment NodeNumber) {
        var mh$ = GetNumaProximityNodeEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetNumaProximityNodeEx", ProximityId, NodeNumber);
            }
            return (int)mh$.invokeExact(ProximityId, NodeNumber);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetProcessGroupAffinity {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetProcessGroupAffinity"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetProcessGroupAffinity(HANDLE hProcess, PUSHORT GroupCount, PUSHORT GroupArray)
     * }
     */
    public static FunctionDescriptor GetProcessGroupAffinity$descriptor() {
        return GetProcessGroupAffinity.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetProcessGroupAffinity(HANDLE hProcess, PUSHORT GroupCount, PUSHORT GroupArray)
     * }
     */
    public static MethodHandle GetProcessGroupAffinity$handle() {
        return GetProcessGroupAffinity.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL GetProcessGroupAffinity(HANDLE hProcess, PUSHORT GroupCount, PUSHORT GroupArray)
     * }
     */
    public static int GetProcessGroupAffinity(MemorySegment hProcess, MemorySegment GroupCount, MemorySegment GroupArray) {
        var mh$ = GetProcessGroupAffinity.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetProcessGroupAffinity", hProcess, GroupCount, GroupArray);
            }
            return (int)mh$.invokeExact(hProcess, GroupCount, GroupArray);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetThreadGroupAffinity {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetThreadGroupAffinity"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetThreadGroupAffinity(HANDLE hThread, PGROUP_AFFINITY GroupAffinity)
     * }
     */
    public static FunctionDescriptor GetThreadGroupAffinity$descriptor() {
        return GetThreadGroupAffinity.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetThreadGroupAffinity(HANDLE hThread, PGROUP_AFFINITY GroupAffinity)
     * }
     */
    public static MethodHandle GetThreadGroupAffinity$handle() {
        return GetThreadGroupAffinity.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL GetThreadGroupAffinity(HANDLE hThread, PGROUP_AFFINITY GroupAffinity)
     * }
     */
    public static int GetThreadGroupAffinity(MemorySegment hThread, MemorySegment GroupAffinity) {
        var mh$ = GetThreadGroupAffinity.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetThreadGroupAffinity", hThread, GroupAffinity);
            }
            return (int)mh$.invokeExact(hThread, GroupAffinity);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetThreadGroupAffinity {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("SetThreadGroupAffinity"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetThreadGroupAffinity(HANDLE hThread, const GROUP_AFFINITY *GroupAffinity, PGROUP_AFFINITY PreviousGroupAffinity)
     * }
     */
    public static FunctionDescriptor SetThreadGroupAffinity$descriptor() {
        return SetThreadGroupAffinity.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetThreadGroupAffinity(HANDLE hThread, const GROUP_AFFINITY *GroupAffinity, PGROUP_AFFINITY PreviousGroupAffinity)
     * }
     */
    public static MethodHandle SetThreadGroupAffinity$handle() {
        return SetThreadGroupAffinity.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL SetThreadGroupAffinity(HANDLE hThread, const GROUP_AFFINITY *GroupAffinity, PGROUP_AFFINITY PreviousGroupAffinity)
     * }
     */
    public static int SetThreadGroupAffinity(MemorySegment hThread, MemorySegment GroupAffinity, MemorySegment PreviousGroupAffinity) {
        var mh$ = SetThreadGroupAffinity.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetThreadGroupAffinity", hThread, GroupAffinity, PreviousGroupAffinity);
            }
            return (int)mh$.invokeExact(hThread, GroupAffinity, PreviousGroupAffinity);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetAppContainerNamedObjectPath {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_LONG,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetAppContainerNamedObjectPath"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetAppContainerNamedObjectPath(HANDLE Token, PSID AppContainerSid, ULONG ObjectPathLength, LPWSTR ObjectPath, PULONG ReturnLength)
     * }
     */
    public static FunctionDescriptor GetAppContainerNamedObjectPath$descriptor() {
        return GetAppContainerNamedObjectPath.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetAppContainerNamedObjectPath(HANDLE Token, PSID AppContainerSid, ULONG ObjectPathLength, LPWSTR ObjectPath, PULONG ReturnLength)
     * }
     */
    public static MethodHandle GetAppContainerNamedObjectPath$handle() {
        return GetAppContainerNamedObjectPath.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL GetAppContainerNamedObjectPath(HANDLE Token, PSID AppContainerSid, ULONG ObjectPathLength, LPWSTR ObjectPath, PULONG ReturnLength)
     * }
     */
    public static int GetAppContainerNamedObjectPath(MemorySegment Token, MemorySegment AppContainerSid, int ObjectPathLength, MemorySegment ObjectPath, MemorySegment ReturnLength) {
        var mh$ = GetAppContainerNamedObjectPath.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetAppContainerNamedObjectPath", Token, AppContainerSid, ObjectPathLength, ObjectPath, ReturnLength);
            }
            return (int)mh$.invokeExact(Token, AppContainerSid, ObjectPathLength, ObjectPath, ReturnLength);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class QueryThreadCycleTime {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("QueryThreadCycleTime"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL QueryThreadCycleTime(HANDLE ThreadHandle, PULONG64 CycleTime)
     * }
     */
    public static FunctionDescriptor QueryThreadCycleTime$descriptor() {
        return QueryThreadCycleTime.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL QueryThreadCycleTime(HANDLE ThreadHandle, PULONG64 CycleTime)
     * }
     */
    public static MethodHandle QueryThreadCycleTime$handle() {
        return QueryThreadCycleTime.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL QueryThreadCycleTime(HANDLE ThreadHandle, PULONG64 CycleTime)
     * }
     */
    public static int QueryThreadCycleTime(MemorySegment ThreadHandle, MemorySegment CycleTime) {
        var mh$ = QueryThreadCycleTime.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("QueryThreadCycleTime", ThreadHandle, CycleTime);
            }
            return (int)mh$.invokeExact(ThreadHandle, CycleTime);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class QueryProcessCycleTime {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("QueryProcessCycleTime"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL QueryProcessCycleTime(HANDLE ProcessHandle, PULONG64 CycleTime)
     * }
     */
    public static FunctionDescriptor QueryProcessCycleTime$descriptor() {
        return QueryProcessCycleTime.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL QueryProcessCycleTime(HANDLE ProcessHandle, PULONG64 CycleTime)
     * }
     */
    public static MethodHandle QueryProcessCycleTime$handle() {
        return QueryProcessCycleTime.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL QueryProcessCycleTime(HANDLE ProcessHandle, PULONG64 CycleTime)
     * }
     */
    public static int QueryProcessCycleTime(MemorySegment ProcessHandle, MemorySegment CycleTime) {
        var mh$ = QueryProcessCycleTime.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("QueryProcessCycleTime", ProcessHandle, CycleTime);
            }
            return (int)mh$.invokeExact(ProcessHandle, CycleTime);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class QueryIdleProcessorCycleTime {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("QueryIdleProcessorCycleTime"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL QueryIdleProcessorCycleTime(PULONG BufferLength, PULONG64 ProcessorIdleCycleTime)
     * }
     */
    public static FunctionDescriptor QueryIdleProcessorCycleTime$descriptor() {
        return QueryIdleProcessorCycleTime.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL QueryIdleProcessorCycleTime(PULONG BufferLength, PULONG64 ProcessorIdleCycleTime)
     * }
     */
    public static MethodHandle QueryIdleProcessorCycleTime$handle() {
        return QueryIdleProcessorCycleTime.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL QueryIdleProcessorCycleTime(PULONG BufferLength, PULONG64 ProcessorIdleCycleTime)
     * }
     */
    public static int QueryIdleProcessorCycleTime(MemorySegment BufferLength, MemorySegment ProcessorIdleCycleTime) {
        var mh$ = QueryIdleProcessorCycleTime.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("QueryIdleProcessorCycleTime", BufferLength, ProcessorIdleCycleTime);
            }
            return (int)mh$.invokeExact(BufferLength, ProcessorIdleCycleTime);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class QueryIdleProcessorCycleTimeEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_SHORT,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("QueryIdleProcessorCycleTimeEx"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL QueryIdleProcessorCycleTimeEx(USHORT Group, PULONG BufferLength, PULONG64 ProcessorIdleCycleTime)
     * }
     */
    public static FunctionDescriptor QueryIdleProcessorCycleTimeEx$descriptor() {
        return QueryIdleProcessorCycleTimeEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL QueryIdleProcessorCycleTimeEx(USHORT Group, PULONG BufferLength, PULONG64 ProcessorIdleCycleTime)
     * }
     */
    public static MethodHandle QueryIdleProcessorCycleTimeEx$handle() {
        return QueryIdleProcessorCycleTimeEx.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL QueryIdleProcessorCycleTimeEx(USHORT Group, PULONG BufferLength, PULONG64 ProcessorIdleCycleTime)
     * }
     */
    public static int QueryIdleProcessorCycleTimeEx(short Group, MemorySegment BufferLength, MemorySegment ProcessorIdleCycleTime) {
        var mh$ = QueryIdleProcessorCycleTimeEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("QueryIdleProcessorCycleTimeEx", Group, BufferLength, ProcessorIdleCycleTime);
            }
            return (int)mh$.invokeExact(Group, BufferLength, ProcessorIdleCycleTime);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class QueryInterruptTimePrecise {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("QueryInterruptTimePrecise"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void QueryInterruptTimePrecise(PULONGLONG lpInterruptTimePrecise)
     * }
     */
    public static FunctionDescriptor QueryInterruptTimePrecise$descriptor() {
        return QueryInterruptTimePrecise.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void QueryInterruptTimePrecise(PULONGLONG lpInterruptTimePrecise)
     * }
     */
    public static MethodHandle QueryInterruptTimePrecise$handle() {
        return QueryInterruptTimePrecise.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * void QueryInterruptTimePrecise(PULONGLONG lpInterruptTimePrecise)
     * }
     */
    public static void QueryInterruptTimePrecise(MemorySegment lpInterruptTimePrecise) {
        var mh$ = QueryInterruptTimePrecise.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("QueryInterruptTimePrecise", lpInterruptTimePrecise);
            }
            mh$.invokeExact(lpInterruptTimePrecise);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class QueryUnbiasedInterruptTimePrecise {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("QueryUnbiasedInterruptTimePrecise"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void QueryUnbiasedInterruptTimePrecise(PULONGLONG lpUnbiasedInterruptTimePrecise)
     * }
     */
    public static FunctionDescriptor QueryUnbiasedInterruptTimePrecise$descriptor() {
        return QueryUnbiasedInterruptTimePrecise.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void QueryUnbiasedInterruptTimePrecise(PULONGLONG lpUnbiasedInterruptTimePrecise)
     * }
     */
    public static MethodHandle QueryUnbiasedInterruptTimePrecise$handle() {
        return QueryUnbiasedInterruptTimePrecise.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * void QueryUnbiasedInterruptTimePrecise(PULONGLONG lpUnbiasedInterruptTimePrecise)
     * }
     */
    public static void QueryUnbiasedInterruptTimePrecise(MemorySegment lpUnbiasedInterruptTimePrecise) {
        var mh$ = QueryUnbiasedInterruptTimePrecise.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("QueryUnbiasedInterruptTimePrecise", lpUnbiasedInterruptTimePrecise);
            }
            mh$.invokeExact(lpUnbiasedInterruptTimePrecise);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class QueryInterruptTime {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("QueryInterruptTime"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void QueryInterruptTime(PULONGLONG lpInterruptTime)
     * }
     */
    public static FunctionDescriptor QueryInterruptTime$descriptor() {
        return QueryInterruptTime.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void QueryInterruptTime(PULONGLONG lpInterruptTime)
     * }
     */
    public static MethodHandle QueryInterruptTime$handle() {
        return QueryInterruptTime.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * void QueryInterruptTime(PULONGLONG lpInterruptTime)
     * }
     */
    public static void QueryInterruptTime(MemorySegment lpInterruptTime) {
        var mh$ = QueryInterruptTime.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("QueryInterruptTime", lpInterruptTime);
            }
            mh$.invokeExact(lpInterruptTime);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class QueryUnbiasedInterruptTime {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("QueryUnbiasedInterruptTime"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL QueryUnbiasedInterruptTime(PULONGLONG UnbiasedTime)
     * }
     */
    public static FunctionDescriptor QueryUnbiasedInterruptTime$descriptor() {
        return QueryUnbiasedInterruptTime.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL QueryUnbiasedInterruptTime(PULONGLONG UnbiasedTime)
     * }
     */
    public static MethodHandle QueryUnbiasedInterruptTime$handle() {
        return QueryUnbiasedInterruptTime.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL QueryUnbiasedInterruptTime(PULONGLONG UnbiasedTime)
     * }
     */
    public static int QueryUnbiasedInterruptTime(MemorySegment UnbiasedTime) {
        var mh$ = QueryUnbiasedInterruptTime.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("QueryUnbiasedInterruptTime", UnbiasedTime);
            }
            return (int)mh$.invokeExact(UnbiasedTime);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class QueryAuxiliaryCounterFrequency {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("QueryAuxiliaryCounterFrequency"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HRESULT QueryAuxiliaryCounterFrequency(PULONGLONG lpAuxiliaryCounterFrequency)
     * }
     */
    public static FunctionDescriptor QueryAuxiliaryCounterFrequency$descriptor() {
        return QueryAuxiliaryCounterFrequency.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HRESULT QueryAuxiliaryCounterFrequency(PULONGLONG lpAuxiliaryCounterFrequency)
     * }
     */
    public static MethodHandle QueryAuxiliaryCounterFrequency$handle() {
        return QueryAuxiliaryCounterFrequency.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * HRESULT QueryAuxiliaryCounterFrequency(PULONGLONG lpAuxiliaryCounterFrequency)
     * }
     */
    public static int QueryAuxiliaryCounterFrequency(MemorySegment lpAuxiliaryCounterFrequency) {
        var mh$ = QueryAuxiliaryCounterFrequency.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("QueryAuxiliaryCounterFrequency", lpAuxiliaryCounterFrequency);
            }
            return (int)mh$.invokeExact(lpAuxiliaryCounterFrequency);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ConvertAuxiliaryCounterToPerformanceCounter {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_LONG_LONG,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("ConvertAuxiliaryCounterToPerformanceCounter"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HRESULT ConvertAuxiliaryCounterToPerformanceCounter(ULONGLONG ullAuxiliaryCounterValue, PULONGLONG lpPerformanceCounterValue, PULONGLONG lpConversionError)
     * }
     */
    public static FunctionDescriptor ConvertAuxiliaryCounterToPerformanceCounter$descriptor() {
        return ConvertAuxiliaryCounterToPerformanceCounter.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HRESULT ConvertAuxiliaryCounterToPerformanceCounter(ULONGLONG ullAuxiliaryCounterValue, PULONGLONG lpPerformanceCounterValue, PULONGLONG lpConversionError)
     * }
     */
    public static MethodHandle ConvertAuxiliaryCounterToPerformanceCounter$handle() {
        return ConvertAuxiliaryCounterToPerformanceCounter.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * HRESULT ConvertAuxiliaryCounterToPerformanceCounter(ULONGLONG ullAuxiliaryCounterValue, PULONGLONG lpPerformanceCounterValue, PULONGLONG lpConversionError)
     * }
     */
    public static int ConvertAuxiliaryCounterToPerformanceCounter(long ullAuxiliaryCounterValue, MemorySegment lpPerformanceCounterValue, MemorySegment lpConversionError) {
        var mh$ = ConvertAuxiliaryCounterToPerformanceCounter.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ConvertAuxiliaryCounterToPerformanceCounter", ullAuxiliaryCounterValue, lpPerformanceCounterValue, lpConversionError);
            }
            return (int)mh$.invokeExact(ullAuxiliaryCounterValue, lpPerformanceCounterValue, lpConversionError);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ConvertPerformanceCounterToAuxiliaryCounter {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_LONG_LONG,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("ConvertPerformanceCounterToAuxiliaryCounter"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HRESULT ConvertPerformanceCounterToAuxiliaryCounter(ULONGLONG ullPerformanceCounterValue, PULONGLONG lpAuxiliaryCounterValue, PULONGLONG lpConversionError)
     * }
     */
    public static FunctionDescriptor ConvertPerformanceCounterToAuxiliaryCounter$descriptor() {
        return ConvertPerformanceCounterToAuxiliaryCounter.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HRESULT ConvertPerformanceCounterToAuxiliaryCounter(ULONGLONG ullPerformanceCounterValue, PULONGLONG lpAuxiliaryCounterValue, PULONGLONG lpConversionError)
     * }
     */
    public static MethodHandle ConvertPerformanceCounterToAuxiliaryCounter$handle() {
        return ConvertPerformanceCounterToAuxiliaryCounter.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * HRESULT ConvertPerformanceCounterToAuxiliaryCounter(ULONGLONG ullPerformanceCounterValue, PULONGLONG lpAuxiliaryCounterValue, PULONGLONG lpConversionError)
     * }
     */
    public static int ConvertPerformanceCounterToAuxiliaryCounter(long ullPerformanceCounterValue, MemorySegment lpAuxiliaryCounterValue, MemorySegment lpConversionError) {
        var mh$ = ConvertPerformanceCounterToAuxiliaryCounter.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ConvertPerformanceCounterToAuxiliaryCounter", ullPerformanceCounterValue, lpAuxiliaryCounterValue, lpConversionError);
            }
            return (int)mh$.invokeExact(ullPerformanceCounterValue, lpAuxiliaryCounterValue, lpConversionError);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef LPVOID LPLDT_ENTRY
     * }
     */
    public static final AddressLayout LPLDT_ENTRY = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _COMMPROP {
     *     WORD wPacketLength;
     *     WORD wPacketVersion;
     *     DWORD dwServiceMask;
     *     DWORD dwReserved1;
     *     DWORD dwMaxTxQueue;
     *     DWORD dwMaxRxQueue;
     *     DWORD dwMaxBaud;
     *     DWORD dwProvSubType;
     *     DWORD dwProvCapabilities;
     *     DWORD dwSettableParams;
     *     DWORD dwSettableBaud;
     *     WORD wSettableData;
     *     WORD wSettableStopParity;
     *     DWORD dwCurrentTxQueue;
     *     DWORD dwCurrentRxQueue;
     *     DWORD dwProvSpec1;
     *     DWORD dwProvSpec2;
     *     WCHAR wcProvChar[1];
     * } *LPCOMMPROP
     * }
     */
    public static final AddressLayout LPCOMMPROP = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _COMSTAT {
     *     DWORD fCtsHold : 1;
     *     DWORD fDsrHold : 1;
     *     DWORD fRlsdHold : 1;
     *     DWORD fXoffHold : 1;
     *     DWORD fXoffSent : 1;
     *     DWORD fEof : 1;
     *     DWORD fTxim : 1;
     *     DWORD fReserved : 25;
     *     DWORD cbInQue;
     *     DWORD cbOutQue;
     * } *LPCOMSTAT
     * }
     */
    public static final AddressLayout LPCOMSTAT = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _DCB {
     *     DWORD DCBlength;
     *     DWORD BaudRate;
     *     DWORD fBinary : 1;
     *     DWORD fParity : 1;
     *     DWORD fOutxCtsFlow : 1;
     *     DWORD fOutxDsrFlow : 1;
     *     DWORD fDtrControl : 2;
     *     DWORD fDsrSensitivity : 1;
     *     DWORD fTXContinueOnXoff : 1;
     *     DWORD fOutX : 1;
     *     DWORD fInX : 1;
     *     DWORD fErrorChar : 1;
     *     DWORD fNull : 1;
     *     DWORD fRtsControl : 2;
     *     DWORD fAbortOnError : 1;
     *     DWORD fDummy2 : 17;
     *     WORD wReserved;
     *     WORD XonLim;
     *     WORD XoffLim;
     *     BYTE ByteSize;
     *     BYTE Parity;
     *     BYTE StopBits;
     *     char XonChar;
     *     char XoffChar;
     *     char ErrorChar;
     *     char EofChar;
     *     char EvtChar;
     *     WORD wReserved1;
     * } *LPDCB
     * }
     */
    public static final AddressLayout LPDCB = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _COMMTIMEOUTS {
     *     DWORD ReadIntervalTimeout;
     *     DWORD ReadTotalTimeoutMultiplier;
     *     DWORD ReadTotalTimeoutConstant;
     *     DWORD WriteTotalTimeoutMultiplier;
     *     DWORD WriteTotalTimeoutConstant;
     * } *LPCOMMTIMEOUTS
     * }
     */
    public static final AddressLayout LPCOMMTIMEOUTS = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _COMMCONFIG {
     *     DWORD dwSize;
     *     WORD wVersion;
     *     WORD wReserved;
     *     DCB dcb;
     *     DWORD dwProviderSubType;
     *     DWORD dwProviderOffset;
     *     DWORD dwProviderSize;
     *     WCHAR wcProviderData[1];
     * } *LPCOMMCONFIG
     * }
     */
    public static final AddressLayout LPCOMMCONFIG = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _MEMORYSTATUS {
     *     DWORD dwLength;
     *     DWORD dwMemoryLoad;
     *     SIZE_T dwTotalPhys;
     *     SIZE_T dwAvailPhys;
     *     SIZE_T dwTotalPageFile;
     *     SIZE_T dwAvailPageFile;
     *     SIZE_T dwTotalVirtual;
     *     SIZE_T dwAvailVirtual;
     * } *LPMEMORYSTATUS
     * }
     */
    public static final AddressLayout LPMEMORYSTATUS = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _JIT_DEBUG_INFO {
     *     DWORD dwSize;
     *     DWORD dwProcessorArchitecture;
     *     DWORD dwThreadID;
     *     DWORD dwReserved0;
     *     ULONG64 lpExceptionAddress;
     *     ULONG64 lpExceptionRecord;
     *     ULONG64 lpContextRecord;
     * } *LPJIT_DEBUG_INFO
     * }
     */
    public static final AddressLayout LPJIT_DEBUG_INFO = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef JIT_DEBUG_INFO *LPJIT_DEBUG_INFO32
     * }
     */
    public static final AddressLayout LPJIT_DEBUG_INFO32 = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef JIT_DEBUG_INFO *LPJIT_DEBUG_INFO64
     * }
     */
    public static final AddressLayout LPJIT_DEBUG_INFO64 = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef PEXCEPTION_RECORD LPEXCEPTION_RECORD
     * }
     */
    public static final AddressLayout LPEXCEPTION_RECORD = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef PEXCEPTION_POINTERS LPEXCEPTION_POINTERS
     * }
     */
    public static final AddressLayout LPEXCEPTION_POINTERS = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _OFSTRUCT {
     *     BYTE cBytes;
     *     BYTE fFixedDisk;
     *     WORD nErrCode;
     *     WORD Reserved1;
     *     WORD Reserved2;
     *     CHAR szPathName[128];
     * } *LPOFSTRUCT
     * }
     */
    public static final AddressLayout LPOFSTRUCT = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _OFSTRUCT {
     *     BYTE cBytes;
     *     BYTE fFixedDisk;
     *     WORD nErrCode;
     *     WORD Reserved1;
     *     WORD Reserved2;
     *     CHAR szPathName[128];
     * } *POFSTRUCT
     * }
     */
    public static final AddressLayout POFSTRUCT = C_POINTER;

    private static class WinMain {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("WinMain"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nShowCmd)
     * }
     */
    public static FunctionDescriptor WinMain$descriptor() {
        return WinMain.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nShowCmd)
     * }
     */
    public static MethodHandle WinMain$handle() {
        return WinMain.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nShowCmd)
     * }
     */
    public static int WinMain(MemorySegment hInstance, MemorySegment hPrevInstance, MemorySegment lpCmdLine, int nShowCmd) {
        var mh$ = WinMain.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WinMain", hInstance, hPrevInstance, lpCmdLine, nShowCmd);
            }
            return (int)mh$.invokeExact(hInstance, hPrevInstance, lpCmdLine, nShowCmd);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wWinMain {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("wWinMain"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int wWinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPWSTR lpCmdLine, int nShowCmd)
     * }
     */
    public static FunctionDescriptor wWinMain$descriptor() {
        return wWinMain.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int wWinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPWSTR lpCmdLine, int nShowCmd)
     * }
     */
    public static MethodHandle wWinMain$handle() {
        return wWinMain.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int wWinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPWSTR lpCmdLine, int nShowCmd)
     * }
     */
    public static int wWinMain(MemorySegment hInstance, MemorySegment hPrevInstance, MemorySegment lpCmdLine, int nShowCmd) {
        var mh$ = wWinMain.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wWinMain", hInstance, hPrevInstance, lpCmdLine, nShowCmd);
            }
            return (int)mh$.invokeExact(hInstance, hPrevInstance, lpCmdLine, nShowCmd);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GlobalAlloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_INT,
            C_LONG_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GlobalAlloc"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HGLOBAL GlobalAlloc(UINT uFlags, SIZE_T dwBytes)
     * }
     */
    public static FunctionDescriptor GlobalAlloc$descriptor() {
        return GlobalAlloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HGLOBAL GlobalAlloc(UINT uFlags, SIZE_T dwBytes)
     * }
     */
    public static MethodHandle GlobalAlloc$handle() {
        return GlobalAlloc.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * HGLOBAL GlobalAlloc(UINT uFlags, SIZE_T dwBytes)
     * }
     */
    public static MemorySegment GlobalAlloc(int uFlags, long dwBytes) {
        var mh$ = GlobalAlloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GlobalAlloc", uFlags, dwBytes);
            }
            return (MemorySegment)mh$.invokeExact(uFlags, dwBytes);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GlobalReAlloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER,
            C_LONG_LONG,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GlobalReAlloc"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HGLOBAL GlobalReAlloc(HGLOBAL hMem, SIZE_T dwBytes, UINT uFlags)
     * }
     */
    public static FunctionDescriptor GlobalReAlloc$descriptor() {
        return GlobalReAlloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HGLOBAL GlobalReAlloc(HGLOBAL hMem, SIZE_T dwBytes, UINT uFlags)
     * }
     */
    public static MethodHandle GlobalReAlloc$handle() {
        return GlobalReAlloc.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * HGLOBAL GlobalReAlloc(HGLOBAL hMem, SIZE_T dwBytes, UINT uFlags)
     * }
     */
    public static MemorySegment GlobalReAlloc(MemorySegment hMem, long dwBytes, int uFlags) {
        var mh$ = GlobalReAlloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GlobalReAlloc", hMem, dwBytes, uFlags);
            }
            return (MemorySegment)mh$.invokeExact(hMem, dwBytes, uFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GlobalSize {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG_LONG,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GlobalSize"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SIZE_T GlobalSize(HGLOBAL hMem)
     * }
     */
    public static FunctionDescriptor GlobalSize$descriptor() {
        return GlobalSize.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SIZE_T GlobalSize(HGLOBAL hMem)
     * }
     */
    public static MethodHandle GlobalSize$handle() {
        return GlobalSize.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * SIZE_T GlobalSize(HGLOBAL hMem)
     * }
     */
    public static long GlobalSize(MemorySegment hMem) {
        var mh$ = GlobalSize.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GlobalSize", hMem);
            }
            return (long)mh$.invokeExact(hMem);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GlobalUnlock {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GlobalUnlock"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GlobalUnlock(HGLOBAL hMem)
     * }
     */
    public static FunctionDescriptor GlobalUnlock$descriptor() {
        return GlobalUnlock.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GlobalUnlock(HGLOBAL hMem)
     * }
     */
    public static MethodHandle GlobalUnlock$handle() {
        return GlobalUnlock.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL GlobalUnlock(HGLOBAL hMem)
     * }
     */
    public static int GlobalUnlock(MemorySegment hMem) {
        var mh$ = GlobalUnlock.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GlobalUnlock", hMem);
            }
            return (int)mh$.invokeExact(hMem);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GlobalLock {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GlobalLock"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LPVOID GlobalLock(HGLOBAL hMem)
     * }
     */
    public static FunctionDescriptor GlobalLock$descriptor() {
        return GlobalLock.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LPVOID GlobalLock(HGLOBAL hMem)
     * }
     */
    public static MethodHandle GlobalLock$handle() {
        return GlobalLock.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * LPVOID GlobalLock(HGLOBAL hMem)
     * }
     */
    public static MemorySegment GlobalLock(MemorySegment hMem) {
        var mh$ = GlobalLock.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GlobalLock", hMem);
            }
            return (MemorySegment)mh$.invokeExact(hMem);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GlobalFlags {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GlobalFlags"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * UINT GlobalFlags(HGLOBAL hMem)
     * }
     */
    public static FunctionDescriptor GlobalFlags$descriptor() {
        return GlobalFlags.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * UINT GlobalFlags(HGLOBAL hMem)
     * }
     */
    public static MethodHandle GlobalFlags$handle() {
        return GlobalFlags.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * UINT GlobalFlags(HGLOBAL hMem)
     * }
     */
    public static int GlobalFlags(MemorySegment hMem) {
        var mh$ = GlobalFlags.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GlobalFlags", hMem);
            }
            return (int)mh$.invokeExact(hMem);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GlobalHandle {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GlobalHandle"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HGLOBAL GlobalHandle(LPCVOID pMem)
     * }
     */
    public static FunctionDescriptor GlobalHandle$descriptor() {
        return GlobalHandle.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HGLOBAL GlobalHandle(LPCVOID pMem)
     * }
     */
    public static MethodHandle GlobalHandle$handle() {
        return GlobalHandle.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * HGLOBAL GlobalHandle(LPCVOID pMem)
     * }
     */
    public static MemorySegment GlobalHandle(MemorySegment pMem) {
        var mh$ = GlobalHandle.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GlobalHandle", pMem);
            }
            return (MemorySegment)mh$.invokeExact(pMem);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GlobalFree {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GlobalFree"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HGLOBAL GlobalFree(HGLOBAL hMem)
     * }
     */
    public static FunctionDescriptor GlobalFree$descriptor() {
        return GlobalFree.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HGLOBAL GlobalFree(HGLOBAL hMem)
     * }
     */
    public static MethodHandle GlobalFree$handle() {
        return GlobalFree.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * HGLOBAL GlobalFree(HGLOBAL hMem)
     * }
     */
    public static MemorySegment GlobalFree(MemorySegment hMem) {
        var mh$ = GlobalFree.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GlobalFree", hMem);
            }
            return (MemorySegment)mh$.invokeExact(hMem);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GlobalCompact {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG_LONG,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GlobalCompact"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SIZE_T GlobalCompact(DWORD dwMinFree)
     * }
     */
    public static FunctionDescriptor GlobalCompact$descriptor() {
        return GlobalCompact.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SIZE_T GlobalCompact(DWORD dwMinFree)
     * }
     */
    public static MethodHandle GlobalCompact$handle() {
        return GlobalCompact.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * SIZE_T GlobalCompact(DWORD dwMinFree)
     * }
     */
    public static long GlobalCompact(int dwMinFree) {
        var mh$ = GlobalCompact.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GlobalCompact", dwMinFree);
            }
            return (long)mh$.invokeExact(dwMinFree);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GlobalFix {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GlobalFix"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void GlobalFix(HGLOBAL hMem)
     * }
     */
    public static FunctionDescriptor GlobalFix$descriptor() {
        return GlobalFix.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void GlobalFix(HGLOBAL hMem)
     * }
     */
    public static MethodHandle GlobalFix$handle() {
        return GlobalFix.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * void GlobalFix(HGLOBAL hMem)
     * }
     */
    public static void GlobalFix(MemorySegment hMem) {
        var mh$ = GlobalFix.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GlobalFix", hMem);
            }
            mh$.invokeExact(hMem);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GlobalUnfix {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GlobalUnfix"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void GlobalUnfix(HGLOBAL hMem)
     * }
     */
    public static FunctionDescriptor GlobalUnfix$descriptor() {
        return GlobalUnfix.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void GlobalUnfix(HGLOBAL hMem)
     * }
     */
    public static MethodHandle GlobalUnfix$handle() {
        return GlobalUnfix.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * void GlobalUnfix(HGLOBAL hMem)
     * }
     */
    public static void GlobalUnfix(MemorySegment hMem) {
        var mh$ = GlobalUnfix.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GlobalUnfix", hMem);
            }
            mh$.invokeExact(hMem);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GlobalWire {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GlobalWire"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LPVOID GlobalWire(HGLOBAL hMem)
     * }
     */
    public static FunctionDescriptor GlobalWire$descriptor() {
        return GlobalWire.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LPVOID GlobalWire(HGLOBAL hMem)
     * }
     */
    public static MethodHandle GlobalWire$handle() {
        return GlobalWire.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * LPVOID GlobalWire(HGLOBAL hMem)
     * }
     */
    public static MemorySegment GlobalWire(MemorySegment hMem) {
        var mh$ = GlobalWire.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GlobalWire", hMem);
            }
            return (MemorySegment)mh$.invokeExact(hMem);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GlobalUnWire {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GlobalUnWire"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GlobalUnWire(HGLOBAL hMem)
     * }
     */
    public static FunctionDescriptor GlobalUnWire$descriptor() {
        return GlobalUnWire.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GlobalUnWire(HGLOBAL hMem)
     * }
     */
    public static MethodHandle GlobalUnWire$handle() {
        return GlobalUnWire.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL GlobalUnWire(HGLOBAL hMem)
     * }
     */
    public static int GlobalUnWire(MemorySegment hMem) {
        var mh$ = GlobalUnWire.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GlobalUnWire", hMem);
            }
            return (int)mh$.invokeExact(hMem);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GlobalMemoryStatus {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GlobalMemoryStatus"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void GlobalMemoryStatus(LPMEMORYSTATUS lpBuffer)
     * }
     */
    public static FunctionDescriptor GlobalMemoryStatus$descriptor() {
        return GlobalMemoryStatus.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void GlobalMemoryStatus(LPMEMORYSTATUS lpBuffer)
     * }
     */
    public static MethodHandle GlobalMemoryStatus$handle() {
        return GlobalMemoryStatus.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * void GlobalMemoryStatus(LPMEMORYSTATUS lpBuffer)
     * }
     */
    public static void GlobalMemoryStatus(MemorySegment lpBuffer) {
        var mh$ = GlobalMemoryStatus.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GlobalMemoryStatus", lpBuffer);
            }
            mh$.invokeExact(lpBuffer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LocalAlloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_INT,
            C_LONG_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("LocalAlloc"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HLOCAL LocalAlloc(UINT uFlags, SIZE_T uBytes)
     * }
     */
    public static FunctionDescriptor LocalAlloc$descriptor() {
        return LocalAlloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HLOCAL LocalAlloc(UINT uFlags, SIZE_T uBytes)
     * }
     */
    public static MethodHandle LocalAlloc$handle() {
        return LocalAlloc.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * HLOCAL LocalAlloc(UINT uFlags, SIZE_T uBytes)
     * }
     */
    public static MemorySegment LocalAlloc(int uFlags, long uBytes) {
        var mh$ = LocalAlloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LocalAlloc", uFlags, uBytes);
            }
            return (MemorySegment)mh$.invokeExact(uFlags, uBytes);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LocalReAlloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER,
            C_LONG_LONG,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("LocalReAlloc"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HLOCAL LocalReAlloc(HLOCAL hMem, SIZE_T uBytes, UINT uFlags)
     * }
     */
    public static FunctionDescriptor LocalReAlloc$descriptor() {
        return LocalReAlloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HLOCAL LocalReAlloc(HLOCAL hMem, SIZE_T uBytes, UINT uFlags)
     * }
     */
    public static MethodHandle LocalReAlloc$handle() {
        return LocalReAlloc.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * HLOCAL LocalReAlloc(HLOCAL hMem, SIZE_T uBytes, UINT uFlags)
     * }
     */
    public static MemorySegment LocalReAlloc(MemorySegment hMem, long uBytes, int uFlags) {
        var mh$ = LocalReAlloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LocalReAlloc", hMem, uBytes, uFlags);
            }
            return (MemorySegment)mh$.invokeExact(hMem, uBytes, uFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LocalLock {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("LocalLock"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LPVOID LocalLock(HLOCAL hMem)
     * }
     */
    public static FunctionDescriptor LocalLock$descriptor() {
        return LocalLock.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LPVOID LocalLock(HLOCAL hMem)
     * }
     */
    public static MethodHandle LocalLock$handle() {
        return LocalLock.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * LPVOID LocalLock(HLOCAL hMem)
     * }
     */
    public static MemorySegment LocalLock(MemorySegment hMem) {
        var mh$ = LocalLock.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LocalLock", hMem);
            }
            return (MemorySegment)mh$.invokeExact(hMem);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LocalHandle {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("LocalHandle"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HLOCAL LocalHandle(LPCVOID pMem)
     * }
     */
    public static FunctionDescriptor LocalHandle$descriptor() {
        return LocalHandle.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HLOCAL LocalHandle(LPCVOID pMem)
     * }
     */
    public static MethodHandle LocalHandle$handle() {
        return LocalHandle.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * HLOCAL LocalHandle(LPCVOID pMem)
     * }
     */
    public static MemorySegment LocalHandle(MemorySegment pMem) {
        var mh$ = LocalHandle.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LocalHandle", pMem);
            }
            return (MemorySegment)mh$.invokeExact(pMem);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LocalUnlock {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("LocalUnlock"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL LocalUnlock(HLOCAL hMem)
     * }
     */
    public static FunctionDescriptor LocalUnlock$descriptor() {
        return LocalUnlock.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL LocalUnlock(HLOCAL hMem)
     * }
     */
    public static MethodHandle LocalUnlock$handle() {
        return LocalUnlock.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL LocalUnlock(HLOCAL hMem)
     * }
     */
    public static int LocalUnlock(MemorySegment hMem) {
        var mh$ = LocalUnlock.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LocalUnlock", hMem);
            }
            return (int)mh$.invokeExact(hMem);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LocalSize {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG_LONG,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("LocalSize"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SIZE_T LocalSize(HLOCAL hMem)
     * }
     */
    public static FunctionDescriptor LocalSize$descriptor() {
        return LocalSize.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SIZE_T LocalSize(HLOCAL hMem)
     * }
     */
    public static MethodHandle LocalSize$handle() {
        return LocalSize.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * SIZE_T LocalSize(HLOCAL hMem)
     * }
     */
    public static long LocalSize(MemorySegment hMem) {
        var mh$ = LocalSize.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LocalSize", hMem);
            }
            return (long)mh$.invokeExact(hMem);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LocalFlags {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("LocalFlags"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * UINT LocalFlags(HLOCAL hMem)
     * }
     */
    public static FunctionDescriptor LocalFlags$descriptor() {
        return LocalFlags.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * UINT LocalFlags(HLOCAL hMem)
     * }
     */
    public static MethodHandle LocalFlags$handle() {
        return LocalFlags.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * UINT LocalFlags(HLOCAL hMem)
     * }
     */
    public static int LocalFlags(MemorySegment hMem) {
        var mh$ = LocalFlags.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LocalFlags", hMem);
            }
            return (int)mh$.invokeExact(hMem);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LocalFree {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("LocalFree"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HLOCAL LocalFree(HLOCAL hMem)
     * }
     */
    public static FunctionDescriptor LocalFree$descriptor() {
        return LocalFree.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HLOCAL LocalFree(HLOCAL hMem)
     * }
     */
    public static MethodHandle LocalFree$handle() {
        return LocalFree.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * HLOCAL LocalFree(HLOCAL hMem)
     * }
     */
    public static MemorySegment LocalFree(MemorySegment hMem) {
        var mh$ = LocalFree.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LocalFree", hMem);
            }
            return (MemorySegment)mh$.invokeExact(hMem);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LocalShrink {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG_LONG,
            C_POINTER,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("LocalShrink"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SIZE_T LocalShrink(HLOCAL hMem, UINT cbNewSize)
     * }
     */
    public static FunctionDescriptor LocalShrink$descriptor() {
        return LocalShrink.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SIZE_T LocalShrink(HLOCAL hMem, UINT cbNewSize)
     * }
     */
    public static MethodHandle LocalShrink$handle() {
        return LocalShrink.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * SIZE_T LocalShrink(HLOCAL hMem, UINT cbNewSize)
     * }
     */
    public static long LocalShrink(MemorySegment hMem, int cbNewSize) {
        var mh$ = LocalShrink.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LocalShrink", hMem, cbNewSize);
            }
            return (long)mh$.invokeExact(hMem, cbNewSize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LocalCompact {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG_LONG,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("LocalCompact"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SIZE_T LocalCompact(UINT uMinFree)
     * }
     */
    public static FunctionDescriptor LocalCompact$descriptor() {
        return LocalCompact.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SIZE_T LocalCompact(UINT uMinFree)
     * }
     */
    public static MethodHandle LocalCompact$handle() {
        return LocalCompact.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * SIZE_T LocalCompact(UINT uMinFree)
     * }
     */
    public static long LocalCompact(int uMinFree) {
        var mh$ = LocalCompact.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LocalCompact", uMinFree);
            }
            return (long)mh$.invokeExact(uMinFree);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetBinaryTypeA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetBinaryTypeA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetBinaryTypeA(LPCSTR lpApplicationName, LPDWORD lpBinaryType)
     * }
     */
    public static FunctionDescriptor GetBinaryTypeA$descriptor() {
        return GetBinaryTypeA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetBinaryTypeA(LPCSTR lpApplicationName, LPDWORD lpBinaryType)
     * }
     */
    public static MethodHandle GetBinaryTypeA$handle() {
        return GetBinaryTypeA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL GetBinaryTypeA(LPCSTR lpApplicationName, LPDWORD lpBinaryType)
     * }
     */
    public static int GetBinaryTypeA(MemorySegment lpApplicationName, MemorySegment lpBinaryType) {
        var mh$ = GetBinaryTypeA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetBinaryTypeA", lpApplicationName, lpBinaryType);
            }
            return (int)mh$.invokeExact(lpApplicationName, lpBinaryType);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetBinaryTypeW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetBinaryTypeW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetBinaryTypeW(LPCWSTR lpApplicationName, LPDWORD lpBinaryType)
     * }
     */
    public static FunctionDescriptor GetBinaryTypeW$descriptor() {
        return GetBinaryTypeW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetBinaryTypeW(LPCWSTR lpApplicationName, LPDWORD lpBinaryType)
     * }
     */
    public static MethodHandle GetBinaryTypeW$handle() {
        return GetBinaryTypeW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL GetBinaryTypeW(LPCWSTR lpApplicationName, LPDWORD lpBinaryType)
     * }
     */
    public static int GetBinaryTypeW(MemorySegment lpApplicationName, MemorySegment lpBinaryType) {
        var mh$ = GetBinaryTypeW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetBinaryTypeW", lpApplicationName, lpBinaryType);
            }
            return (int)mh$.invokeExact(lpApplicationName, lpBinaryType);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetShortPathNameA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_POINTER,
            C_POINTER,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetShortPathNameA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetShortPathNameA(LPCSTR lpszLongPath, LPSTR lpszShortPath, DWORD cchBuffer)
     * }
     */
    public static FunctionDescriptor GetShortPathNameA$descriptor() {
        return GetShortPathNameA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetShortPathNameA(LPCSTR lpszLongPath, LPSTR lpszShortPath, DWORD cchBuffer)
     * }
     */
    public static MethodHandle GetShortPathNameA$handle() {
        return GetShortPathNameA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * DWORD GetShortPathNameA(LPCSTR lpszLongPath, LPSTR lpszShortPath, DWORD cchBuffer)
     * }
     */
    public static int GetShortPathNameA(MemorySegment lpszLongPath, MemorySegment lpszShortPath, int cchBuffer) {
        var mh$ = GetShortPathNameA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetShortPathNameA", lpszLongPath, lpszShortPath, cchBuffer);
            }
            return (int)mh$.invokeExact(lpszLongPath, lpszShortPath, cchBuffer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetLongPathNameTransactedA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_POINTER,
            C_POINTER,
            C_LONG,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetLongPathNameTransactedA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetLongPathNameTransactedA(LPCSTR lpszShortPath, LPSTR lpszLongPath, DWORD cchBuffer, HANDLE hTransaction)
     * }
     */
    public static FunctionDescriptor GetLongPathNameTransactedA$descriptor() {
        return GetLongPathNameTransactedA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetLongPathNameTransactedA(LPCSTR lpszShortPath, LPSTR lpszLongPath, DWORD cchBuffer, HANDLE hTransaction)
     * }
     */
    public static MethodHandle GetLongPathNameTransactedA$handle() {
        return GetLongPathNameTransactedA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * DWORD GetLongPathNameTransactedA(LPCSTR lpszShortPath, LPSTR lpszLongPath, DWORD cchBuffer, HANDLE hTransaction)
     * }
     */
    public static int GetLongPathNameTransactedA(MemorySegment lpszShortPath, MemorySegment lpszLongPath, int cchBuffer, MemorySegment hTransaction) {
        var mh$ = GetLongPathNameTransactedA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetLongPathNameTransactedA", lpszShortPath, lpszLongPath, cchBuffer, hTransaction);
            }
            return (int)mh$.invokeExact(lpszShortPath, lpszLongPath, cchBuffer, hTransaction);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetLongPathNameTransactedW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_POINTER,
            C_POINTER,
            C_LONG,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetLongPathNameTransactedW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetLongPathNameTransactedW(LPCWSTR lpszShortPath, LPWSTR lpszLongPath, DWORD cchBuffer, HANDLE hTransaction)
     * }
     */
    public static FunctionDescriptor GetLongPathNameTransactedW$descriptor() {
        return GetLongPathNameTransactedW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetLongPathNameTransactedW(LPCWSTR lpszShortPath, LPWSTR lpszLongPath, DWORD cchBuffer, HANDLE hTransaction)
     * }
     */
    public static MethodHandle GetLongPathNameTransactedW$handle() {
        return GetLongPathNameTransactedW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * DWORD GetLongPathNameTransactedW(LPCWSTR lpszShortPath, LPWSTR lpszLongPath, DWORD cchBuffer, HANDLE hTransaction)
     * }
     */
    public static int GetLongPathNameTransactedW(MemorySegment lpszShortPath, MemorySegment lpszLongPath, int cchBuffer, MemorySegment hTransaction) {
        var mh$ = GetLongPathNameTransactedW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetLongPathNameTransactedW", lpszShortPath, lpszLongPath, cchBuffer, hTransaction);
            }
            return (int)mh$.invokeExact(lpszShortPath, lpszLongPath, cchBuffer, hTransaction);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetProcessAffinityMask {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetProcessAffinityMask"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetProcessAffinityMask(HANDLE hProcess, PDWORD_PTR lpProcessAffinityMask, PDWORD_PTR lpSystemAffinityMask)
     * }
     */
    public static FunctionDescriptor GetProcessAffinityMask$descriptor() {
        return GetProcessAffinityMask.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetProcessAffinityMask(HANDLE hProcess, PDWORD_PTR lpProcessAffinityMask, PDWORD_PTR lpSystemAffinityMask)
     * }
     */
    public static MethodHandle GetProcessAffinityMask$handle() {
        return GetProcessAffinityMask.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL GetProcessAffinityMask(HANDLE hProcess, PDWORD_PTR lpProcessAffinityMask, PDWORD_PTR lpSystemAffinityMask)
     * }
     */
    public static int GetProcessAffinityMask(MemorySegment hProcess, MemorySegment lpProcessAffinityMask, MemorySegment lpSystemAffinityMask) {
        var mh$ = GetProcessAffinityMask.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetProcessAffinityMask", hProcess, lpProcessAffinityMask, lpSystemAffinityMask);
            }
            return (int)mh$.invokeExact(hProcess, lpProcessAffinityMask, lpSystemAffinityMask);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetProcessAffinityMask {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_LONG_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("SetProcessAffinityMask"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetProcessAffinityMask(HANDLE hProcess, DWORD_PTR dwProcessAffinityMask)
     * }
     */
    public static FunctionDescriptor SetProcessAffinityMask$descriptor() {
        return SetProcessAffinityMask.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetProcessAffinityMask(HANDLE hProcess, DWORD_PTR dwProcessAffinityMask)
     * }
     */
    public static MethodHandle SetProcessAffinityMask$handle() {
        return SetProcessAffinityMask.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL SetProcessAffinityMask(HANDLE hProcess, DWORD_PTR dwProcessAffinityMask)
     * }
     */
    public static int SetProcessAffinityMask(MemorySegment hProcess, long dwProcessAffinityMask) {
        var mh$ = SetProcessAffinityMask.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetProcessAffinityMask", hProcess, dwProcessAffinityMask);
            }
            return (int)mh$.invokeExact(hProcess, dwProcessAffinityMask);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetProcessIoCounters {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetProcessIoCounters"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetProcessIoCounters(HANDLE hProcess, PIO_COUNTERS lpIoCounters)
     * }
     */
    public static FunctionDescriptor GetProcessIoCounters$descriptor() {
        return GetProcessIoCounters.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetProcessIoCounters(HANDLE hProcess, PIO_COUNTERS lpIoCounters)
     * }
     */
    public static MethodHandle GetProcessIoCounters$handle() {
        return GetProcessIoCounters.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL GetProcessIoCounters(HANDLE hProcess, PIO_COUNTERS lpIoCounters)
     * }
     */
    public static int GetProcessIoCounters(MemorySegment hProcess, MemorySegment lpIoCounters) {
        var mh$ = GetProcessIoCounters.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetProcessIoCounters", hProcess, lpIoCounters);
            }
            return (int)mh$.invokeExact(hProcess, lpIoCounters);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FatalExit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("FatalExit"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void FatalExit(int ExitCode)
     * }
     */
    public static FunctionDescriptor FatalExit$descriptor() {
        return FatalExit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void FatalExit(int ExitCode)
     * }
     */
    public static MethodHandle FatalExit$handle() {
        return FatalExit.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * void FatalExit(int ExitCode)
     * }
     */
    public static void FatalExit(int ExitCode) {
        var mh$ = FatalExit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FatalExit", ExitCode);
            }
            mh$.invokeExact(ExitCode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetEnvironmentStringsA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("SetEnvironmentStringsA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetEnvironmentStringsA(LPCH NewEnvironment)
     * }
     */
    public static FunctionDescriptor SetEnvironmentStringsA$descriptor() {
        return SetEnvironmentStringsA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetEnvironmentStringsA(LPCH NewEnvironment)
     * }
     */
    public static MethodHandle SetEnvironmentStringsA$handle() {
        return SetEnvironmentStringsA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL SetEnvironmentStringsA(LPCH NewEnvironment)
     * }
     */
    public static int SetEnvironmentStringsA(MemorySegment NewEnvironment) {
        var mh$ = SetEnvironmentStringsA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetEnvironmentStringsA", NewEnvironment);
            }
            return (int)mh$.invokeExact(NewEnvironment);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SwitchToFiber {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("SwitchToFiber"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SwitchToFiber(LPVOID lpFiber)
     * }
     */
    public static FunctionDescriptor SwitchToFiber$descriptor() {
        return SwitchToFiber.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SwitchToFiber(LPVOID lpFiber)
     * }
     */
    public static MethodHandle SwitchToFiber$handle() {
        return SwitchToFiber.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * void SwitchToFiber(LPVOID lpFiber)
     * }
     */
    public static void SwitchToFiber(MemorySegment lpFiber) {
        var mh$ = SwitchToFiber.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SwitchToFiber", lpFiber);
            }
            mh$.invokeExact(lpFiber);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DeleteFiber {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("DeleteFiber"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void DeleteFiber(LPVOID lpFiber)
     * }
     */
    public static FunctionDescriptor DeleteFiber$descriptor() {
        return DeleteFiber.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void DeleteFiber(LPVOID lpFiber)
     * }
     */
    public static MethodHandle DeleteFiber$handle() {
        return DeleteFiber.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * void DeleteFiber(LPVOID lpFiber)
     * }
     */
    public static void DeleteFiber(MemorySegment lpFiber) {
        var mh$ = DeleteFiber.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DeleteFiber", lpFiber);
            }
            mh$.invokeExact(lpFiber);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ConvertFiberToThread {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT    );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("ConvertFiberToThread"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL ConvertFiberToThread()
     * }
     */
    public static FunctionDescriptor ConvertFiberToThread$descriptor() {
        return ConvertFiberToThread.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL ConvertFiberToThread()
     * }
     */
    public static MethodHandle ConvertFiberToThread$handle() {
        return ConvertFiberToThread.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL ConvertFiberToThread()
     * }
     */
    public static int ConvertFiberToThread() {
        var mh$ = ConvertFiberToThread.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ConvertFiberToThread");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateFiberEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_LONG_LONG,
            C_LONG_LONG,
            C_LONG,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CreateFiberEx"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LPVOID CreateFiberEx(SIZE_T dwStackCommitSize, SIZE_T dwStackReserveSize, DWORD dwFlags, LPFIBER_START_ROUTINE lpStartAddress, LPVOID lpParameter)
     * }
     */
    public static FunctionDescriptor CreateFiberEx$descriptor() {
        return CreateFiberEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LPVOID CreateFiberEx(SIZE_T dwStackCommitSize, SIZE_T dwStackReserveSize, DWORD dwFlags, LPFIBER_START_ROUTINE lpStartAddress, LPVOID lpParameter)
     * }
     */
    public static MethodHandle CreateFiberEx$handle() {
        return CreateFiberEx.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * LPVOID CreateFiberEx(SIZE_T dwStackCommitSize, SIZE_T dwStackReserveSize, DWORD dwFlags, LPFIBER_START_ROUTINE lpStartAddress, LPVOID lpParameter)
     * }
     */
    public static MemorySegment CreateFiberEx(long dwStackCommitSize, long dwStackReserveSize, int dwFlags, MemorySegment lpStartAddress, MemorySegment lpParameter) {
        var mh$ = CreateFiberEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateFiberEx", dwStackCommitSize, dwStackReserveSize, dwFlags, lpStartAddress, lpParameter);
            }
            return (MemorySegment)mh$.invokeExact(dwStackCommitSize, dwStackReserveSize, dwFlags, lpStartAddress, lpParameter);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ConvertThreadToFiberEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("ConvertThreadToFiberEx"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LPVOID ConvertThreadToFiberEx(LPVOID lpParameter, DWORD dwFlags)
     * }
     */
    public static FunctionDescriptor ConvertThreadToFiberEx$descriptor() {
        return ConvertThreadToFiberEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LPVOID ConvertThreadToFiberEx(LPVOID lpParameter, DWORD dwFlags)
     * }
     */
    public static MethodHandle ConvertThreadToFiberEx$handle() {
        return ConvertThreadToFiberEx.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * LPVOID ConvertThreadToFiberEx(LPVOID lpParameter, DWORD dwFlags)
     * }
     */
    public static MemorySegment ConvertThreadToFiberEx(MemorySegment lpParameter, int dwFlags) {
        var mh$ = ConvertThreadToFiberEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ConvertThreadToFiberEx", lpParameter, dwFlags);
            }
            return (MemorySegment)mh$.invokeExact(lpParameter, dwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateFiber {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_LONG_LONG,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CreateFiber"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LPVOID CreateFiber(SIZE_T dwStackSize, LPFIBER_START_ROUTINE lpStartAddress, LPVOID lpParameter)
     * }
     */
    public static FunctionDescriptor CreateFiber$descriptor() {
        return CreateFiber.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LPVOID CreateFiber(SIZE_T dwStackSize, LPFIBER_START_ROUTINE lpStartAddress, LPVOID lpParameter)
     * }
     */
    public static MethodHandle CreateFiber$handle() {
        return CreateFiber.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * LPVOID CreateFiber(SIZE_T dwStackSize, LPFIBER_START_ROUTINE lpStartAddress, LPVOID lpParameter)
     * }
     */
    public static MemorySegment CreateFiber(long dwStackSize, MemorySegment lpStartAddress, MemorySegment lpParameter) {
        var mh$ = CreateFiber.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateFiber", dwStackSize, lpStartAddress, lpParameter);
            }
            return (MemorySegment)mh$.invokeExact(dwStackSize, lpStartAddress, lpParameter);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ConvertThreadToFiber {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("ConvertThreadToFiber"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LPVOID ConvertThreadToFiber(LPVOID lpParameter)
     * }
     */
    public static FunctionDescriptor ConvertThreadToFiber$descriptor() {
        return ConvertThreadToFiber.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LPVOID ConvertThreadToFiber(LPVOID lpParameter)
     * }
     */
    public static MethodHandle ConvertThreadToFiber$handle() {
        return ConvertThreadToFiber.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * LPVOID ConvertThreadToFiber(LPVOID lpParameter)
     * }
     */
    public static MemorySegment ConvertThreadToFiber(MemorySegment lpParameter) {
        var mh$ = ConvertThreadToFiber.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ConvertThreadToFiber", lpParameter);
            }
            return (MemorySegment)mh$.invokeExact(lpParameter);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef void *PUMS_CONTEXT
     * }
     */
    public static final AddressLayout PUMS_CONTEXT = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef void *PUMS_COMPLETION_LIST
     * }
     */
    public static final AddressLayout PUMS_COMPLETION_LIST = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef enum _RTL_UMS_THREAD_INFO_CLASS {
     *     UmsThreadInvalidInfoClass = 0,
     *     UmsThreadUserContext,
     *     UmsThreadPriority,
     *     UmsThreadAffinity,
     *     UmsThreadTeb,
     *     UmsThreadIsSuspended,
     *     UmsThreadIsTerminated,
     *     UmsThreadMaxInfoClass
     * } *PUMS_THREAD_INFO_CLASS
     * }
     */
    public static final AddressLayout PUMS_THREAD_INFO_CLASS = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _UMS_SCHEDULER_STARTUP_INFO {
     *     ULONG UmsVersion;
     *     PUMS_COMPLETION_LIST CompletionList;
     *     PUMS_SCHEDULER_ENTRY_POINT SchedulerProc;
     *     PVOID SchedulerParam;
     * } *PUMS_SCHEDULER_STARTUP_INFO
     * }
     */
    public static final AddressLayout PUMS_SCHEDULER_STARTUP_INFO = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _UMS_SYSTEM_THREAD_INFORMATION {
     *     ULONG UmsVersion;
     *     union {
     *         struct {
     *             ULONG IsUmsSchedulerThread : 1;
     *             ULONG IsUmsWorkerThread : 1;
     *         };
     *         ULONG ThreadUmsFlags;
     *     };
     * } *PUMS_SYSTEM_THREAD_INFORMATION
     * }
     */
    public static final AddressLayout PUMS_SYSTEM_THREAD_INFORMATION = C_POINTER;

    private static class CreateUmsCompletionList {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CreateUmsCompletionList"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CreateUmsCompletionList(PUMS_COMPLETION_LIST *UmsCompletionList)
     * }
     */
    public static FunctionDescriptor CreateUmsCompletionList$descriptor() {
        return CreateUmsCompletionList.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CreateUmsCompletionList(PUMS_COMPLETION_LIST *UmsCompletionList)
     * }
     */
    public static MethodHandle CreateUmsCompletionList$handle() {
        return CreateUmsCompletionList.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL CreateUmsCompletionList(PUMS_COMPLETION_LIST *UmsCompletionList)
     * }
     */
    public static int CreateUmsCompletionList(MemorySegment UmsCompletionList) {
        var mh$ = CreateUmsCompletionList.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateUmsCompletionList", UmsCompletionList);
            }
            return (int)mh$.invokeExact(UmsCompletionList);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DequeueUmsCompletionListItems {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_LONG,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("DequeueUmsCompletionListItems"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL DequeueUmsCompletionListItems(PUMS_COMPLETION_LIST UmsCompletionList, DWORD WaitTimeOut, PUMS_CONTEXT *UmsThreadList)
     * }
     */
    public static FunctionDescriptor DequeueUmsCompletionListItems$descriptor() {
        return DequeueUmsCompletionListItems.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL DequeueUmsCompletionListItems(PUMS_COMPLETION_LIST UmsCompletionList, DWORD WaitTimeOut, PUMS_CONTEXT *UmsThreadList)
     * }
     */
    public static MethodHandle DequeueUmsCompletionListItems$handle() {
        return DequeueUmsCompletionListItems.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL DequeueUmsCompletionListItems(PUMS_COMPLETION_LIST UmsCompletionList, DWORD WaitTimeOut, PUMS_CONTEXT *UmsThreadList)
     * }
     */
    public static int DequeueUmsCompletionListItems(MemorySegment UmsCompletionList, int WaitTimeOut, MemorySegment UmsThreadList) {
        var mh$ = DequeueUmsCompletionListItems.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DequeueUmsCompletionListItems", UmsCompletionList, WaitTimeOut, UmsThreadList);
            }
            return (int)mh$.invokeExact(UmsCompletionList, WaitTimeOut, UmsThreadList);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetUmsCompletionListEvent {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetUmsCompletionListEvent"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetUmsCompletionListEvent(PUMS_COMPLETION_LIST UmsCompletionList, PHANDLE UmsCompletionEvent)
     * }
     */
    public static FunctionDescriptor GetUmsCompletionListEvent$descriptor() {
        return GetUmsCompletionListEvent.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetUmsCompletionListEvent(PUMS_COMPLETION_LIST UmsCompletionList, PHANDLE UmsCompletionEvent)
     * }
     */
    public static MethodHandle GetUmsCompletionListEvent$handle() {
        return GetUmsCompletionListEvent.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL GetUmsCompletionListEvent(PUMS_COMPLETION_LIST UmsCompletionList, PHANDLE UmsCompletionEvent)
     * }
     */
    public static int GetUmsCompletionListEvent(MemorySegment UmsCompletionList, MemorySegment UmsCompletionEvent) {
        var mh$ = GetUmsCompletionListEvent.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetUmsCompletionListEvent", UmsCompletionList, UmsCompletionEvent);
            }
            return (int)mh$.invokeExact(UmsCompletionList, UmsCompletionEvent);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ExecuteUmsThread {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("ExecuteUmsThread"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL ExecuteUmsThread(PUMS_CONTEXT UmsThread)
     * }
     */
    public static FunctionDescriptor ExecuteUmsThread$descriptor() {
        return ExecuteUmsThread.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL ExecuteUmsThread(PUMS_CONTEXT UmsThread)
     * }
     */
    public static MethodHandle ExecuteUmsThread$handle() {
        return ExecuteUmsThread.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL ExecuteUmsThread(PUMS_CONTEXT UmsThread)
     * }
     */
    public static int ExecuteUmsThread(MemorySegment UmsThread) {
        var mh$ = ExecuteUmsThread.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ExecuteUmsThread", UmsThread);
            }
            return (int)mh$.invokeExact(UmsThread);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class UmsThreadYield {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("UmsThreadYield"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL UmsThreadYield(PVOID SchedulerParam)
     * }
     */
    public static FunctionDescriptor UmsThreadYield$descriptor() {
        return UmsThreadYield.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL UmsThreadYield(PVOID SchedulerParam)
     * }
     */
    public static MethodHandle UmsThreadYield$handle() {
        return UmsThreadYield.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL UmsThreadYield(PVOID SchedulerParam)
     * }
     */
    public static int UmsThreadYield(MemorySegment SchedulerParam) {
        var mh$ = UmsThreadYield.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("UmsThreadYield", SchedulerParam);
            }
            return (int)mh$.invokeExact(SchedulerParam);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DeleteUmsCompletionList {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("DeleteUmsCompletionList"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL DeleteUmsCompletionList(PUMS_COMPLETION_LIST UmsCompletionList)
     * }
     */
    public static FunctionDescriptor DeleteUmsCompletionList$descriptor() {
        return DeleteUmsCompletionList.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL DeleteUmsCompletionList(PUMS_COMPLETION_LIST UmsCompletionList)
     * }
     */
    public static MethodHandle DeleteUmsCompletionList$handle() {
        return DeleteUmsCompletionList.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL DeleteUmsCompletionList(PUMS_COMPLETION_LIST UmsCompletionList)
     * }
     */
    public static int DeleteUmsCompletionList(MemorySegment UmsCompletionList) {
        var mh$ = DeleteUmsCompletionList.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DeleteUmsCompletionList", UmsCompletionList);
            }
            return (int)mh$.invokeExact(UmsCompletionList);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetCurrentUmsThread {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER    );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetCurrentUmsThread"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PUMS_CONTEXT GetCurrentUmsThread()
     * }
     */
    public static FunctionDescriptor GetCurrentUmsThread$descriptor() {
        return GetCurrentUmsThread.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PUMS_CONTEXT GetCurrentUmsThread()
     * }
     */
    public static MethodHandle GetCurrentUmsThread$handle() {
        return GetCurrentUmsThread.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * PUMS_CONTEXT GetCurrentUmsThread()
     * }
     */
    public static MemorySegment GetCurrentUmsThread() {
        var mh$ = GetCurrentUmsThread.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetCurrentUmsThread");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetNextUmsListItem {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetNextUmsListItem"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PUMS_CONTEXT GetNextUmsListItem(PUMS_CONTEXT UmsContext)
     * }
     */
    public static FunctionDescriptor GetNextUmsListItem$descriptor() {
        return GetNextUmsListItem.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PUMS_CONTEXT GetNextUmsListItem(PUMS_CONTEXT UmsContext)
     * }
     */
    public static MethodHandle GetNextUmsListItem$handle() {
        return GetNextUmsListItem.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * PUMS_CONTEXT GetNextUmsListItem(PUMS_CONTEXT UmsContext)
     * }
     */
    public static MemorySegment GetNextUmsListItem(MemorySegment UmsContext) {
        var mh$ = GetNextUmsListItem.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetNextUmsListItem", UmsContext);
            }
            return (MemorySegment)mh$.invokeExact(UmsContext);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class QueryUmsThreadInformation {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_INT,
            C_POINTER,
            C_LONG,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("QueryUmsThreadInformation"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL QueryUmsThreadInformation(PUMS_CONTEXT UmsThread, UMS_THREAD_INFO_CLASS UmsThreadInfoClass, PVOID UmsThreadInformation, ULONG UmsThreadInformationLength, PULONG ReturnLength)
     * }
     */
    public static FunctionDescriptor QueryUmsThreadInformation$descriptor() {
        return QueryUmsThreadInformation.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL QueryUmsThreadInformation(PUMS_CONTEXT UmsThread, UMS_THREAD_INFO_CLASS UmsThreadInfoClass, PVOID UmsThreadInformation, ULONG UmsThreadInformationLength, PULONG ReturnLength)
     * }
     */
    public static MethodHandle QueryUmsThreadInformation$handle() {
        return QueryUmsThreadInformation.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL QueryUmsThreadInformation(PUMS_CONTEXT UmsThread, UMS_THREAD_INFO_CLASS UmsThreadInfoClass, PVOID UmsThreadInformation, ULONG UmsThreadInformationLength, PULONG ReturnLength)
     * }
     */
    public static int QueryUmsThreadInformation(MemorySegment UmsThread, int UmsThreadInfoClass, MemorySegment UmsThreadInformation, int UmsThreadInformationLength, MemorySegment ReturnLength) {
        var mh$ = QueryUmsThreadInformation.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("QueryUmsThreadInformation", UmsThread, UmsThreadInfoClass, UmsThreadInformation, UmsThreadInformationLength, ReturnLength);
            }
            return (int)mh$.invokeExact(UmsThread, UmsThreadInfoClass, UmsThreadInformation, UmsThreadInformationLength, ReturnLength);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetUmsThreadInformation {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_INT,
            C_POINTER,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("SetUmsThreadInformation"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetUmsThreadInformation(PUMS_CONTEXT UmsThread, UMS_THREAD_INFO_CLASS UmsThreadInfoClass, PVOID UmsThreadInformation, ULONG UmsThreadInformationLength)
     * }
     */
    public static FunctionDescriptor SetUmsThreadInformation$descriptor() {
        return SetUmsThreadInformation.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetUmsThreadInformation(PUMS_CONTEXT UmsThread, UMS_THREAD_INFO_CLASS UmsThreadInfoClass, PVOID UmsThreadInformation, ULONG UmsThreadInformationLength)
     * }
     */
    public static MethodHandle SetUmsThreadInformation$handle() {
        return SetUmsThreadInformation.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL SetUmsThreadInformation(PUMS_CONTEXT UmsThread, UMS_THREAD_INFO_CLASS UmsThreadInfoClass, PVOID UmsThreadInformation, ULONG UmsThreadInformationLength)
     * }
     */
    public static int SetUmsThreadInformation(MemorySegment UmsThread, int UmsThreadInfoClass, MemorySegment UmsThreadInformation, int UmsThreadInformationLength) {
        var mh$ = SetUmsThreadInformation.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetUmsThreadInformation", UmsThread, UmsThreadInfoClass, UmsThreadInformation, UmsThreadInformationLength);
            }
            return (int)mh$.invokeExact(UmsThread, UmsThreadInfoClass, UmsThreadInformation, UmsThreadInformationLength);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DeleteUmsThreadContext {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("DeleteUmsThreadContext"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL DeleteUmsThreadContext(PUMS_CONTEXT UmsThread)
     * }
     */
    public static FunctionDescriptor DeleteUmsThreadContext$descriptor() {
        return DeleteUmsThreadContext.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL DeleteUmsThreadContext(PUMS_CONTEXT UmsThread)
     * }
     */
    public static MethodHandle DeleteUmsThreadContext$handle() {
        return DeleteUmsThreadContext.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL DeleteUmsThreadContext(PUMS_CONTEXT UmsThread)
     * }
     */
    public static int DeleteUmsThreadContext(MemorySegment UmsThread) {
        var mh$ = DeleteUmsThreadContext.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DeleteUmsThreadContext", UmsThread);
            }
            return (int)mh$.invokeExact(UmsThread);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateUmsThreadContext {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CreateUmsThreadContext"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CreateUmsThreadContext(PUMS_CONTEXT *lpUmsThread)
     * }
     */
    public static FunctionDescriptor CreateUmsThreadContext$descriptor() {
        return CreateUmsThreadContext.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CreateUmsThreadContext(PUMS_CONTEXT *lpUmsThread)
     * }
     */
    public static MethodHandle CreateUmsThreadContext$handle() {
        return CreateUmsThreadContext.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL CreateUmsThreadContext(PUMS_CONTEXT *lpUmsThread)
     * }
     */
    public static int CreateUmsThreadContext(MemorySegment lpUmsThread) {
        var mh$ = CreateUmsThreadContext.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateUmsThreadContext", lpUmsThread);
            }
            return (int)mh$.invokeExact(lpUmsThread);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class EnterUmsSchedulingMode {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("EnterUmsSchedulingMode"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL EnterUmsSchedulingMode(PUMS_SCHEDULER_STARTUP_INFO SchedulerStartupInfo)
     * }
     */
    public static FunctionDescriptor EnterUmsSchedulingMode$descriptor() {
        return EnterUmsSchedulingMode.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL EnterUmsSchedulingMode(PUMS_SCHEDULER_STARTUP_INFO SchedulerStartupInfo)
     * }
     */
    public static MethodHandle EnterUmsSchedulingMode$handle() {
        return EnterUmsSchedulingMode.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL EnterUmsSchedulingMode(PUMS_SCHEDULER_STARTUP_INFO SchedulerStartupInfo)
     * }
     */
    public static int EnterUmsSchedulingMode(MemorySegment SchedulerStartupInfo) {
        var mh$ = EnterUmsSchedulingMode.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("EnterUmsSchedulingMode", SchedulerStartupInfo);
            }
            return (int)mh$.invokeExact(SchedulerStartupInfo);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetUmsSystemThreadInformation {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetUmsSystemThreadInformation"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetUmsSystemThreadInformation(HANDLE ThreadHandle, PUMS_SYSTEM_THREAD_INFORMATION SystemThreadInfo)
     * }
     */
    public static FunctionDescriptor GetUmsSystemThreadInformation$descriptor() {
        return GetUmsSystemThreadInformation.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetUmsSystemThreadInformation(HANDLE ThreadHandle, PUMS_SYSTEM_THREAD_INFORMATION SystemThreadInfo)
     * }
     */
    public static MethodHandle GetUmsSystemThreadInformation$handle() {
        return GetUmsSystemThreadInformation.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL GetUmsSystemThreadInformation(HANDLE ThreadHandle, PUMS_SYSTEM_THREAD_INFORMATION SystemThreadInfo)
     * }
     */
    public static int GetUmsSystemThreadInformation(MemorySegment ThreadHandle, MemorySegment SystemThreadInfo) {
        var mh$ = GetUmsSystemThreadInformation.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetUmsSystemThreadInformation", ThreadHandle, SystemThreadInfo);
            }
            return (int)mh$.invokeExact(ThreadHandle, SystemThreadInfo);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetThreadAffinityMask {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG_LONG,
            C_POINTER,
            C_LONG_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("SetThreadAffinityMask"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD_PTR SetThreadAffinityMask(HANDLE hThread, DWORD_PTR dwThreadAffinityMask)
     * }
     */
    public static FunctionDescriptor SetThreadAffinityMask$descriptor() {
        return SetThreadAffinityMask.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD_PTR SetThreadAffinityMask(HANDLE hThread, DWORD_PTR dwThreadAffinityMask)
     * }
     */
    public static MethodHandle SetThreadAffinityMask$handle() {
        return SetThreadAffinityMask.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * DWORD_PTR SetThreadAffinityMask(HANDLE hThread, DWORD_PTR dwThreadAffinityMask)
     * }
     */
    public static long SetThreadAffinityMask(MemorySegment hThread, long dwThreadAffinityMask) {
        var mh$ = SetThreadAffinityMask.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetThreadAffinityMask", hThread, dwThreadAffinityMask);
            }
            return (long)mh$.invokeExact(hThread, dwThreadAffinityMask);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetProcessDEPPolicy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("SetProcessDEPPolicy"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetProcessDEPPolicy(DWORD dwFlags)
     * }
     */
    public static FunctionDescriptor SetProcessDEPPolicy$descriptor() {
        return SetProcessDEPPolicy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetProcessDEPPolicy(DWORD dwFlags)
     * }
     */
    public static MethodHandle SetProcessDEPPolicy$handle() {
        return SetProcessDEPPolicy.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL SetProcessDEPPolicy(DWORD dwFlags)
     * }
     */
    public static int SetProcessDEPPolicy(int dwFlags) {
        var mh$ = SetProcessDEPPolicy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetProcessDEPPolicy", dwFlags);
            }
            return (int)mh$.invokeExact(dwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetProcessDEPPolicy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetProcessDEPPolicy"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetProcessDEPPolicy(HANDLE hProcess, LPDWORD lpFlags, PBOOL lpPermanent)
     * }
     */
    public static FunctionDescriptor GetProcessDEPPolicy$descriptor() {
        return GetProcessDEPPolicy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetProcessDEPPolicy(HANDLE hProcess, LPDWORD lpFlags, PBOOL lpPermanent)
     * }
     */
    public static MethodHandle GetProcessDEPPolicy$handle() {
        return GetProcessDEPPolicy.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL GetProcessDEPPolicy(HANDLE hProcess, LPDWORD lpFlags, PBOOL lpPermanent)
     * }
     */
    public static int GetProcessDEPPolicy(MemorySegment hProcess, MemorySegment lpFlags, MemorySegment lpPermanent) {
        var mh$ = GetProcessDEPPolicy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetProcessDEPPolicy", hProcess, lpFlags, lpPermanent);
            }
            return (int)mh$.invokeExact(hProcess, lpFlags, lpPermanent);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RequestWakeupLatency {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("RequestWakeupLatency"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL RequestWakeupLatency(LATENCY_TIME latency)
     * }
     */
    public static FunctionDescriptor RequestWakeupLatency$descriptor() {
        return RequestWakeupLatency.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL RequestWakeupLatency(LATENCY_TIME latency)
     * }
     */
    public static MethodHandle RequestWakeupLatency$handle() {
        return RequestWakeupLatency.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL RequestWakeupLatency(LATENCY_TIME latency)
     * }
     */
    public static int RequestWakeupLatency(int latency) {
        var mh$ = RequestWakeupLatency.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RequestWakeupLatency", latency);
            }
            return (int)mh$.invokeExact(latency);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class IsSystemResumeAutomatic {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT    );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("IsSystemResumeAutomatic"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL IsSystemResumeAutomatic()
     * }
     */
    public static FunctionDescriptor IsSystemResumeAutomatic$descriptor() {
        return IsSystemResumeAutomatic.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL IsSystemResumeAutomatic()
     * }
     */
    public static MethodHandle IsSystemResumeAutomatic$handle() {
        return IsSystemResumeAutomatic.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL IsSystemResumeAutomatic()
     * }
     */
    public static int IsSystemResumeAutomatic() {
        var mh$ = IsSystemResumeAutomatic.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("IsSystemResumeAutomatic");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetThreadSelectorEntry {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_LONG,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetThreadSelectorEntry"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetThreadSelectorEntry(HANDLE hThread, DWORD dwSelector, LPLDT_ENTRY lpSelectorEntry)
     * }
     */
    public static FunctionDescriptor GetThreadSelectorEntry$descriptor() {
        return GetThreadSelectorEntry.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetThreadSelectorEntry(HANDLE hThread, DWORD dwSelector, LPLDT_ENTRY lpSelectorEntry)
     * }
     */
    public static MethodHandle GetThreadSelectorEntry$handle() {
        return GetThreadSelectorEntry.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL GetThreadSelectorEntry(HANDLE hThread, DWORD dwSelector, LPLDT_ENTRY lpSelectorEntry)
     * }
     */
    public static int GetThreadSelectorEntry(MemorySegment hThread, int dwSelector, MemorySegment lpSelectorEntry) {
        var mh$ = GetThreadSelectorEntry.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetThreadSelectorEntry", hThread, dwSelector, lpSelectorEntry);
            }
            return (int)mh$.invokeExact(hThread, dwSelector, lpSelectorEntry);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetThreadExecutionState {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("SetThreadExecutionState"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * EXECUTION_STATE SetThreadExecutionState(EXECUTION_STATE esFlags)
     * }
     */
    public static FunctionDescriptor SetThreadExecutionState$descriptor() {
        return SetThreadExecutionState.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * EXECUTION_STATE SetThreadExecutionState(EXECUTION_STATE esFlags)
     * }
     */
    public static MethodHandle SetThreadExecutionState$handle() {
        return SetThreadExecutionState.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * EXECUTION_STATE SetThreadExecutionState(EXECUTION_STATE esFlags)
     * }
     */
    public static int SetThreadExecutionState(int esFlags) {
        var mh$ = SetThreadExecutionState.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetThreadExecutionState", esFlags);
            }
            return (int)mh$.invokeExact(esFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef REASON_CONTEXT *PPOWER_REQUEST_CONTEXT
     * }
     */
    public static final AddressLayout PPOWER_REQUEST_CONTEXT = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef REASON_CONTEXT *LPPOWER_REQUEST_CONTEXT
     * }
     */
    public static final AddressLayout LPPOWER_REQUEST_CONTEXT = C_POINTER;

    private static class PowerCreateRequest {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("PowerCreateRequest"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HANDLE PowerCreateRequest(PREASON_CONTEXT Context)
     * }
     */
    public static FunctionDescriptor PowerCreateRequest$descriptor() {
        return PowerCreateRequest.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HANDLE PowerCreateRequest(PREASON_CONTEXT Context)
     * }
     */
    public static MethodHandle PowerCreateRequest$handle() {
        return PowerCreateRequest.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * HANDLE PowerCreateRequest(PREASON_CONTEXT Context)
     * }
     */
    public static MemorySegment PowerCreateRequest(MemorySegment Context) {
        var mh$ = PowerCreateRequest.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PowerCreateRequest", Context);
            }
            return (MemorySegment)mh$.invokeExact(Context);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PowerSetRequest {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("PowerSetRequest"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL PowerSetRequest(HANDLE PowerRequest, POWER_REQUEST_TYPE RequestType)
     * }
     */
    public static FunctionDescriptor PowerSetRequest$descriptor() {
        return PowerSetRequest.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL PowerSetRequest(HANDLE PowerRequest, POWER_REQUEST_TYPE RequestType)
     * }
     */
    public static MethodHandle PowerSetRequest$handle() {
        return PowerSetRequest.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL PowerSetRequest(HANDLE PowerRequest, POWER_REQUEST_TYPE RequestType)
     * }
     */
    public static int PowerSetRequest(MemorySegment PowerRequest, int RequestType) {
        var mh$ = PowerSetRequest.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PowerSetRequest", PowerRequest, RequestType);
            }
            return (int)mh$.invokeExact(PowerRequest, RequestType);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PowerClearRequest {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("PowerClearRequest"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL PowerClearRequest(HANDLE PowerRequest, POWER_REQUEST_TYPE RequestType)
     * }
     */
    public static FunctionDescriptor PowerClearRequest$descriptor() {
        return PowerClearRequest.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL PowerClearRequest(HANDLE PowerRequest, POWER_REQUEST_TYPE RequestType)
     * }
     */
    public static MethodHandle PowerClearRequest$handle() {
        return PowerClearRequest.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL PowerClearRequest(HANDLE PowerRequest, POWER_REQUEST_TYPE RequestType)
     * }
     */
    public static int PowerClearRequest(MemorySegment PowerRequest, int RequestType) {
        var mh$ = PowerClearRequest.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PowerClearRequest", PowerRequest, RequestType);
            }
            return (int)mh$.invokeExact(PowerRequest, RequestType);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetFileCompletionNotificationModes {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_CHAR
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("SetFileCompletionNotificationModes"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetFileCompletionNotificationModes(HANDLE FileHandle, UCHAR Flags)
     * }
     */
    public static FunctionDescriptor SetFileCompletionNotificationModes$descriptor() {
        return SetFileCompletionNotificationModes.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetFileCompletionNotificationModes(HANDLE FileHandle, UCHAR Flags)
     * }
     */
    public static MethodHandle SetFileCompletionNotificationModes$handle() {
        return SetFileCompletionNotificationModes.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL SetFileCompletionNotificationModes(HANDLE FileHandle, UCHAR Flags)
     * }
     */
    public static int SetFileCompletionNotificationModes(MemorySegment FileHandle, byte Flags) {
        var mh$ = SetFileCompletionNotificationModes.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetFileCompletionNotificationModes", FileHandle, Flags);
            }
            return (int)mh$.invokeExact(FileHandle, Flags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Wow64GetThreadSelectorEntry {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_LONG,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("Wow64GetThreadSelectorEntry"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL Wow64GetThreadSelectorEntry(HANDLE hThread, DWORD dwSelector, PWOW64_LDT_ENTRY lpSelectorEntry)
     * }
     */
    public static FunctionDescriptor Wow64GetThreadSelectorEntry$descriptor() {
        return Wow64GetThreadSelectorEntry.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL Wow64GetThreadSelectorEntry(HANDLE hThread, DWORD dwSelector, PWOW64_LDT_ENTRY lpSelectorEntry)
     * }
     */
    public static MethodHandle Wow64GetThreadSelectorEntry$handle() {
        return Wow64GetThreadSelectorEntry.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL Wow64GetThreadSelectorEntry(HANDLE hThread, DWORD dwSelector, PWOW64_LDT_ENTRY lpSelectorEntry)
     * }
     */
    public static int Wow64GetThreadSelectorEntry(MemorySegment hThread, int dwSelector, MemorySegment lpSelectorEntry) {
        var mh$ = Wow64GetThreadSelectorEntry.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Wow64GetThreadSelectorEntry", hThread, dwSelector, lpSelectorEntry);
            }
            return (int)mh$.invokeExact(hThread, dwSelector, lpSelectorEntry);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DebugSetProcessKillOnExit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("DebugSetProcessKillOnExit"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL DebugSetProcessKillOnExit(BOOL KillOnExit)
     * }
     */
    public static FunctionDescriptor DebugSetProcessKillOnExit$descriptor() {
        return DebugSetProcessKillOnExit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL DebugSetProcessKillOnExit(BOOL KillOnExit)
     * }
     */
    public static MethodHandle DebugSetProcessKillOnExit$handle() {
        return DebugSetProcessKillOnExit.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL DebugSetProcessKillOnExit(BOOL KillOnExit)
     * }
     */
    public static int DebugSetProcessKillOnExit(int KillOnExit) {
        var mh$ = DebugSetProcessKillOnExit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DebugSetProcessKillOnExit", KillOnExit);
            }
            return (int)mh$.invokeExact(KillOnExit);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DebugBreakProcess {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("DebugBreakProcess"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL DebugBreakProcess(HANDLE Process)
     * }
     */
    public static FunctionDescriptor DebugBreakProcess$descriptor() {
        return DebugBreakProcess.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL DebugBreakProcess(HANDLE Process)
     * }
     */
    public static MethodHandle DebugBreakProcess$handle() {
        return DebugBreakProcess.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL DebugBreakProcess(HANDLE Process)
     * }
     */
    public static int DebugBreakProcess(MemorySegment Process) {
        var mh$ = DebugBreakProcess.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DebugBreakProcess", Process);
            }
            return (int)mh$.invokeExact(Process);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PulseEvent {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("PulseEvent"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL PulseEvent(HANDLE hEvent)
     * }
     */
    public static FunctionDescriptor PulseEvent$descriptor() {
        return PulseEvent.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL PulseEvent(HANDLE hEvent)
     * }
     */
    public static MethodHandle PulseEvent$handle() {
        return PulseEvent.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL PulseEvent(HANDLE hEvent)
     * }
     */
    public static int PulseEvent(MemorySegment hEvent) {
        var mh$ = PulseEvent.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PulseEvent", hEvent);
            }
            return (int)mh$.invokeExact(hEvent);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GlobalDeleteAtom {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_SHORT,
            C_SHORT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GlobalDeleteAtom"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ATOM GlobalDeleteAtom(ATOM nAtom)
     * }
     */
    public static FunctionDescriptor GlobalDeleteAtom$descriptor() {
        return GlobalDeleteAtom.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ATOM GlobalDeleteAtom(ATOM nAtom)
     * }
     */
    public static MethodHandle GlobalDeleteAtom$handle() {
        return GlobalDeleteAtom.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * ATOM GlobalDeleteAtom(ATOM nAtom)
     * }
     */
    public static short GlobalDeleteAtom(short nAtom) {
        var mh$ = GlobalDeleteAtom.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GlobalDeleteAtom", nAtom);
            }
            return (short)mh$.invokeExact(nAtom);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class InitAtomTable {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("InitAtomTable"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL InitAtomTable(DWORD nSize)
     * }
     */
    public static FunctionDescriptor InitAtomTable$descriptor() {
        return InitAtomTable.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL InitAtomTable(DWORD nSize)
     * }
     */
    public static MethodHandle InitAtomTable$handle() {
        return InitAtomTable.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL InitAtomTable(DWORD nSize)
     * }
     */
    public static int InitAtomTable(int nSize) {
        var mh$ = InitAtomTable.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("InitAtomTable", nSize);
            }
            return (int)mh$.invokeExact(nSize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DeleteAtom {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_SHORT,
            C_SHORT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("DeleteAtom"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ATOM DeleteAtom(ATOM nAtom)
     * }
     */
    public static FunctionDescriptor DeleteAtom$descriptor() {
        return DeleteAtom.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ATOM DeleteAtom(ATOM nAtom)
     * }
     */
    public static MethodHandle DeleteAtom$handle() {
        return DeleteAtom.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * ATOM DeleteAtom(ATOM nAtom)
     * }
     */
    public static short DeleteAtom(short nAtom) {
        var mh$ = DeleteAtom.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DeleteAtom", nAtom);
            }
            return (short)mh$.invokeExact(nAtom);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetHandleCount {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("SetHandleCount"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * UINT SetHandleCount(UINT uNumber)
     * }
     */
    public static FunctionDescriptor SetHandleCount$descriptor() {
        return SetHandleCount.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * UINT SetHandleCount(UINT uNumber)
     * }
     */
    public static MethodHandle SetHandleCount$handle() {
        return SetHandleCount.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * UINT SetHandleCount(UINT uNumber)
     * }
     */
    public static int SetHandleCount(int uNumber) {
        var mh$ = SetHandleCount.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetHandleCount", uNumber);
            }
            return (int)mh$.invokeExact(uNumber);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RequestDeviceWakeup {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("RequestDeviceWakeup"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL RequestDeviceWakeup(HANDLE hDevice)
     * }
     */
    public static FunctionDescriptor RequestDeviceWakeup$descriptor() {
        return RequestDeviceWakeup.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL RequestDeviceWakeup(HANDLE hDevice)
     * }
     */
    public static MethodHandle RequestDeviceWakeup$handle() {
        return RequestDeviceWakeup.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL RequestDeviceWakeup(HANDLE hDevice)
     * }
     */
    public static int RequestDeviceWakeup(MemorySegment hDevice) {
        var mh$ = RequestDeviceWakeup.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RequestDeviceWakeup", hDevice);
            }
            return (int)mh$.invokeExact(hDevice);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CancelDeviceWakeupRequest {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CancelDeviceWakeupRequest"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CancelDeviceWakeupRequest(HANDLE hDevice)
     * }
     */
    public static FunctionDescriptor CancelDeviceWakeupRequest$descriptor() {
        return CancelDeviceWakeupRequest.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CancelDeviceWakeupRequest(HANDLE hDevice)
     * }
     */
    public static MethodHandle CancelDeviceWakeupRequest$handle() {
        return CancelDeviceWakeupRequest.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL CancelDeviceWakeupRequest(HANDLE hDevice)
     * }
     */
    public static int CancelDeviceWakeupRequest(MemorySegment hDevice) {
        var mh$ = CancelDeviceWakeupRequest.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CancelDeviceWakeupRequest", hDevice);
            }
            return (int)mh$.invokeExact(hDevice);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetDevicePowerState {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetDevicePowerState"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetDevicePowerState(HANDLE hDevice, BOOL *pfOn)
     * }
     */
    public static FunctionDescriptor GetDevicePowerState$descriptor() {
        return GetDevicePowerState.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetDevicePowerState(HANDLE hDevice, BOOL *pfOn)
     * }
     */
    public static MethodHandle GetDevicePowerState$handle() {
        return GetDevicePowerState.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL GetDevicePowerState(HANDLE hDevice, BOOL *pfOn)
     * }
     */
    public static int GetDevicePowerState(MemorySegment hDevice, MemorySegment pfOn) {
        var mh$ = GetDevicePowerState.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetDevicePowerState", hDevice, pfOn);
            }
            return (int)mh$.invokeExact(hDevice, pfOn);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetMessageWaitingIndicator {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("SetMessageWaitingIndicator"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetMessageWaitingIndicator(HANDLE hMsgIndicator, ULONG ulMsgCount)
     * }
     */
    public static FunctionDescriptor SetMessageWaitingIndicator$descriptor() {
        return SetMessageWaitingIndicator.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetMessageWaitingIndicator(HANDLE hMsgIndicator, ULONG ulMsgCount)
     * }
     */
    public static MethodHandle SetMessageWaitingIndicator$handle() {
        return SetMessageWaitingIndicator.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL SetMessageWaitingIndicator(HANDLE hMsgIndicator, ULONG ulMsgCount)
     * }
     */
    public static int SetMessageWaitingIndicator(MemorySegment hMsgIndicator, int ulMsgCount) {
        var mh$ = SetMessageWaitingIndicator.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetMessageWaitingIndicator", hMsgIndicator, ulMsgCount);
            }
            return (int)mh$.invokeExact(hMsgIndicator, ulMsgCount);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetFileShortNameA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("SetFileShortNameA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetFileShortNameA(HANDLE hFile, LPCSTR lpShortName)
     * }
     */
    public static FunctionDescriptor SetFileShortNameA$descriptor() {
        return SetFileShortNameA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetFileShortNameA(HANDLE hFile, LPCSTR lpShortName)
     * }
     */
    public static MethodHandle SetFileShortNameA$handle() {
        return SetFileShortNameA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL SetFileShortNameA(HANDLE hFile, LPCSTR lpShortName)
     * }
     */
    public static int SetFileShortNameA(MemorySegment hFile, MemorySegment lpShortName) {
        var mh$ = SetFileShortNameA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetFileShortNameA", hFile, lpShortName);
            }
            return (int)mh$.invokeExact(hFile, lpShortName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetFileShortNameW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("SetFileShortNameW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetFileShortNameW(HANDLE hFile, LPCWSTR lpShortName)
     * }
     */
    public static FunctionDescriptor SetFileShortNameW$descriptor() {
        return SetFileShortNameW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetFileShortNameW(HANDLE hFile, LPCWSTR lpShortName)
     * }
     */
    public static MethodHandle SetFileShortNameW$handle() {
        return SetFileShortNameW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL SetFileShortNameW(HANDLE hFile, LPCWSTR lpShortName)
     * }
     */
    public static int SetFileShortNameW(MemorySegment hFile, MemorySegment lpShortName) {
        var mh$ = SetFileShortNameW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetFileShortNameW", hFile, lpShortName);
            }
            return (int)mh$.invokeExact(hFile, lpShortName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LoadModule {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("LoadModule"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD LoadModule(LPCSTR lpModuleName, LPVOID lpParameterBlock)
     * }
     */
    public static FunctionDescriptor LoadModule$descriptor() {
        return LoadModule.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD LoadModule(LPCSTR lpModuleName, LPVOID lpParameterBlock)
     * }
     */
    public static MethodHandle LoadModule$handle() {
        return LoadModule.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * DWORD LoadModule(LPCSTR lpModuleName, LPVOID lpParameterBlock)
     * }
     */
    public static int LoadModule(MemorySegment lpModuleName, MemorySegment lpParameterBlock) {
        var mh$ = LoadModule.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LoadModule", lpModuleName, lpParameterBlock);
            }
            return (int)mh$.invokeExact(lpModuleName, lpParameterBlock);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class WinExec {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("WinExec"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * UINT WinExec(LPCSTR lpCmdLine, UINT uCmdShow)
     * }
     */
    public static FunctionDescriptor WinExec$descriptor() {
        return WinExec.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * UINT WinExec(LPCSTR lpCmdLine, UINT uCmdShow)
     * }
     */
    public static MethodHandle WinExec$handle() {
        return WinExec.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * UINT WinExec(LPCSTR lpCmdLine, UINT uCmdShow)
     * }
     */
    public static int WinExec(MemorySegment lpCmdLine, int uCmdShow) {
        var mh$ = WinExec.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WinExec", lpCmdLine, uCmdShow);
            }
            return (int)mh$.invokeExact(lpCmdLine, uCmdShow);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ClearCommBreak {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("ClearCommBreak"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL ClearCommBreak(HANDLE hFile)
     * }
     */
    public static FunctionDescriptor ClearCommBreak$descriptor() {
        return ClearCommBreak.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL ClearCommBreak(HANDLE hFile)
     * }
     */
    public static MethodHandle ClearCommBreak$handle() {
        return ClearCommBreak.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL ClearCommBreak(HANDLE hFile)
     * }
     */
    public static int ClearCommBreak(MemorySegment hFile) {
        var mh$ = ClearCommBreak.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ClearCommBreak", hFile);
            }
            return (int)mh$.invokeExact(hFile);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ClearCommError {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("ClearCommError"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL ClearCommError(HANDLE hFile, LPDWORD lpErrors, LPCOMSTAT lpStat)
     * }
     */
    public static FunctionDescriptor ClearCommError$descriptor() {
        return ClearCommError.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL ClearCommError(HANDLE hFile, LPDWORD lpErrors, LPCOMSTAT lpStat)
     * }
     */
    public static MethodHandle ClearCommError$handle() {
        return ClearCommError.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL ClearCommError(HANDLE hFile, LPDWORD lpErrors, LPCOMSTAT lpStat)
     * }
     */
    public static int ClearCommError(MemorySegment hFile, MemorySegment lpErrors, MemorySegment lpStat) {
        var mh$ = ClearCommError.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ClearCommError", hFile, lpErrors, lpStat);
            }
            return (int)mh$.invokeExact(hFile, lpErrors, lpStat);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetupComm {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_LONG,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("SetupComm"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetupComm(HANDLE hFile, DWORD dwInQueue, DWORD dwOutQueue)
     * }
     */
    public static FunctionDescriptor SetupComm$descriptor() {
        return SetupComm.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetupComm(HANDLE hFile, DWORD dwInQueue, DWORD dwOutQueue)
     * }
     */
    public static MethodHandle SetupComm$handle() {
        return SetupComm.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL SetupComm(HANDLE hFile, DWORD dwInQueue, DWORD dwOutQueue)
     * }
     */
    public static int SetupComm(MemorySegment hFile, int dwInQueue, int dwOutQueue) {
        var mh$ = SetupComm.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetupComm", hFile, dwInQueue, dwOutQueue);
            }
            return (int)mh$.invokeExact(hFile, dwInQueue, dwOutQueue);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class EscapeCommFunction {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("EscapeCommFunction"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL EscapeCommFunction(HANDLE hFile, DWORD dwFunc)
     * }
     */
    public static FunctionDescriptor EscapeCommFunction$descriptor() {
        return EscapeCommFunction.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL EscapeCommFunction(HANDLE hFile, DWORD dwFunc)
     * }
     */
    public static MethodHandle EscapeCommFunction$handle() {
        return EscapeCommFunction.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL EscapeCommFunction(HANDLE hFile, DWORD dwFunc)
     * }
     */
    public static int EscapeCommFunction(MemorySegment hFile, int dwFunc) {
        var mh$ = EscapeCommFunction.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("EscapeCommFunction", hFile, dwFunc);
            }
            return (int)mh$.invokeExact(hFile, dwFunc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetCommConfig {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetCommConfig"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetCommConfig(HANDLE hCommDev, LPCOMMCONFIG lpCC, LPDWORD lpdwSize)
     * }
     */
    public static FunctionDescriptor GetCommConfig$descriptor() {
        return GetCommConfig.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetCommConfig(HANDLE hCommDev, LPCOMMCONFIG lpCC, LPDWORD lpdwSize)
     * }
     */
    public static MethodHandle GetCommConfig$handle() {
        return GetCommConfig.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL GetCommConfig(HANDLE hCommDev, LPCOMMCONFIG lpCC, LPDWORD lpdwSize)
     * }
     */
    public static int GetCommConfig(MemorySegment hCommDev, MemorySegment lpCC, MemorySegment lpdwSize) {
        var mh$ = GetCommConfig.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetCommConfig", hCommDev, lpCC, lpdwSize);
            }
            return (int)mh$.invokeExact(hCommDev, lpCC, lpdwSize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetCommMask {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetCommMask"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetCommMask(HANDLE hFile, LPDWORD lpEvtMask)
     * }
     */
    public static FunctionDescriptor GetCommMask$descriptor() {
        return GetCommMask.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetCommMask(HANDLE hFile, LPDWORD lpEvtMask)
     * }
     */
    public static MethodHandle GetCommMask$handle() {
        return GetCommMask.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL GetCommMask(HANDLE hFile, LPDWORD lpEvtMask)
     * }
     */
    public static int GetCommMask(MemorySegment hFile, MemorySegment lpEvtMask) {
        var mh$ = GetCommMask.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetCommMask", hFile, lpEvtMask);
            }
            return (int)mh$.invokeExact(hFile, lpEvtMask);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetCommProperties {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetCommProperties"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetCommProperties(HANDLE hFile, LPCOMMPROP lpCommProp)
     * }
     */
    public static FunctionDescriptor GetCommProperties$descriptor() {
        return GetCommProperties.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetCommProperties(HANDLE hFile, LPCOMMPROP lpCommProp)
     * }
     */
    public static MethodHandle GetCommProperties$handle() {
        return GetCommProperties.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL GetCommProperties(HANDLE hFile, LPCOMMPROP lpCommProp)
     * }
     */
    public static int GetCommProperties(MemorySegment hFile, MemorySegment lpCommProp) {
        var mh$ = GetCommProperties.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetCommProperties", hFile, lpCommProp);
            }
            return (int)mh$.invokeExact(hFile, lpCommProp);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetCommModemStatus {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetCommModemStatus"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetCommModemStatus(HANDLE hFile, LPDWORD lpModemStat)
     * }
     */
    public static FunctionDescriptor GetCommModemStatus$descriptor() {
        return GetCommModemStatus.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetCommModemStatus(HANDLE hFile, LPDWORD lpModemStat)
     * }
     */
    public static MethodHandle GetCommModemStatus$handle() {
        return GetCommModemStatus.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL GetCommModemStatus(HANDLE hFile, LPDWORD lpModemStat)
     * }
     */
    public static int GetCommModemStatus(MemorySegment hFile, MemorySegment lpModemStat) {
        var mh$ = GetCommModemStatus.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetCommModemStatus", hFile, lpModemStat);
            }
            return (int)mh$.invokeExact(hFile, lpModemStat);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetCommState {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetCommState"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetCommState(HANDLE hFile, LPDCB lpDCB)
     * }
     */
    public static FunctionDescriptor GetCommState$descriptor() {
        return GetCommState.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetCommState(HANDLE hFile, LPDCB lpDCB)
     * }
     */
    public static MethodHandle GetCommState$handle() {
        return GetCommState.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL GetCommState(HANDLE hFile, LPDCB lpDCB)
     * }
     */
    public static int GetCommState(MemorySegment hFile, MemorySegment lpDCB) {
        var mh$ = GetCommState.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetCommState", hFile, lpDCB);
            }
            return (int)mh$.invokeExact(hFile, lpDCB);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetCommTimeouts {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetCommTimeouts"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetCommTimeouts(HANDLE hFile, LPCOMMTIMEOUTS lpCommTimeouts)
     * }
     */
    public static FunctionDescriptor GetCommTimeouts$descriptor() {
        return GetCommTimeouts.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetCommTimeouts(HANDLE hFile, LPCOMMTIMEOUTS lpCommTimeouts)
     * }
     */
    public static MethodHandle GetCommTimeouts$handle() {
        return GetCommTimeouts.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL GetCommTimeouts(HANDLE hFile, LPCOMMTIMEOUTS lpCommTimeouts)
     * }
     */
    public static int GetCommTimeouts(MemorySegment hFile, MemorySegment lpCommTimeouts) {
        var mh$ = GetCommTimeouts.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetCommTimeouts", hFile, lpCommTimeouts);
            }
            return (int)mh$.invokeExact(hFile, lpCommTimeouts);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PurgeComm {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("PurgeComm"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL PurgeComm(HANDLE hFile, DWORD dwFlags)
     * }
     */
    public static FunctionDescriptor PurgeComm$descriptor() {
        return PurgeComm.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL PurgeComm(HANDLE hFile, DWORD dwFlags)
     * }
     */
    public static MethodHandle PurgeComm$handle() {
        return PurgeComm.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL PurgeComm(HANDLE hFile, DWORD dwFlags)
     * }
     */
    public static int PurgeComm(MemorySegment hFile, int dwFlags) {
        var mh$ = PurgeComm.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PurgeComm", hFile, dwFlags);
            }
            return (int)mh$.invokeExact(hFile, dwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetCommBreak {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("SetCommBreak"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetCommBreak(HANDLE hFile)
     * }
     */
    public static FunctionDescriptor SetCommBreak$descriptor() {
        return SetCommBreak.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetCommBreak(HANDLE hFile)
     * }
     */
    public static MethodHandle SetCommBreak$handle() {
        return SetCommBreak.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL SetCommBreak(HANDLE hFile)
     * }
     */
    public static int SetCommBreak(MemorySegment hFile) {
        var mh$ = SetCommBreak.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetCommBreak", hFile);
            }
            return (int)mh$.invokeExact(hFile);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetCommConfig {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("SetCommConfig"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetCommConfig(HANDLE hCommDev, LPCOMMCONFIG lpCC, DWORD dwSize)
     * }
     */
    public static FunctionDescriptor SetCommConfig$descriptor() {
        return SetCommConfig.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetCommConfig(HANDLE hCommDev, LPCOMMCONFIG lpCC, DWORD dwSize)
     * }
     */
    public static MethodHandle SetCommConfig$handle() {
        return SetCommConfig.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL SetCommConfig(HANDLE hCommDev, LPCOMMCONFIG lpCC, DWORD dwSize)
     * }
     */
    public static int SetCommConfig(MemorySegment hCommDev, MemorySegment lpCC, int dwSize) {
        var mh$ = SetCommConfig.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetCommConfig", hCommDev, lpCC, dwSize);
            }
            return (int)mh$.invokeExact(hCommDev, lpCC, dwSize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetCommMask {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("SetCommMask"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetCommMask(HANDLE hFile, DWORD dwEvtMask)
     * }
     */
    public static FunctionDescriptor SetCommMask$descriptor() {
        return SetCommMask.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetCommMask(HANDLE hFile, DWORD dwEvtMask)
     * }
     */
    public static MethodHandle SetCommMask$handle() {
        return SetCommMask.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL SetCommMask(HANDLE hFile, DWORD dwEvtMask)
     * }
     */
    public static int SetCommMask(MemorySegment hFile, int dwEvtMask) {
        var mh$ = SetCommMask.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetCommMask", hFile, dwEvtMask);
            }
            return (int)mh$.invokeExact(hFile, dwEvtMask);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetCommState {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("SetCommState"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetCommState(HANDLE hFile, LPDCB lpDCB)
     * }
     */
    public static FunctionDescriptor SetCommState$descriptor() {
        return SetCommState.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetCommState(HANDLE hFile, LPDCB lpDCB)
     * }
     */
    public static MethodHandle SetCommState$handle() {
        return SetCommState.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL SetCommState(HANDLE hFile, LPDCB lpDCB)
     * }
     */
    public static int SetCommState(MemorySegment hFile, MemorySegment lpDCB) {
        var mh$ = SetCommState.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetCommState", hFile, lpDCB);
            }
            return (int)mh$.invokeExact(hFile, lpDCB);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetCommTimeouts {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("SetCommTimeouts"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetCommTimeouts(HANDLE hFile, LPCOMMTIMEOUTS lpCommTimeouts)
     * }
     */
    public static FunctionDescriptor SetCommTimeouts$descriptor() {
        return SetCommTimeouts.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetCommTimeouts(HANDLE hFile, LPCOMMTIMEOUTS lpCommTimeouts)
     * }
     */
    public static MethodHandle SetCommTimeouts$handle() {
        return SetCommTimeouts.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL SetCommTimeouts(HANDLE hFile, LPCOMMTIMEOUTS lpCommTimeouts)
     * }
     */
    public static int SetCommTimeouts(MemorySegment hFile, MemorySegment lpCommTimeouts) {
        var mh$ = SetCommTimeouts.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetCommTimeouts", hFile, lpCommTimeouts);
            }
            return (int)mh$.invokeExact(hFile, lpCommTimeouts);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TransmitCommChar {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_CHAR
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("TransmitCommChar"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL TransmitCommChar(HANDLE hFile, char cChar)
     * }
     */
    public static FunctionDescriptor TransmitCommChar$descriptor() {
        return TransmitCommChar.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL TransmitCommChar(HANDLE hFile, char cChar)
     * }
     */
    public static MethodHandle TransmitCommChar$handle() {
        return TransmitCommChar.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL TransmitCommChar(HANDLE hFile, char cChar)
     * }
     */
    public static int TransmitCommChar(MemorySegment hFile, byte cChar) {
        var mh$ = TransmitCommChar.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TransmitCommChar", hFile, cChar);
            }
            return (int)mh$.invokeExact(hFile, cChar);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class WaitCommEvent {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("WaitCommEvent"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL WaitCommEvent(HANDLE hFile, LPDWORD lpEvtMask, LPOVERLAPPED lpOverlapped)
     * }
     */
    public static FunctionDescriptor WaitCommEvent$descriptor() {
        return WaitCommEvent.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL WaitCommEvent(HANDLE hFile, LPDWORD lpEvtMask, LPOVERLAPPED lpOverlapped)
     * }
     */
    public static MethodHandle WaitCommEvent$handle() {
        return WaitCommEvent.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL WaitCommEvent(HANDLE hFile, LPDWORD lpEvtMask, LPOVERLAPPED lpOverlapped)
     * }
     */
    public static int WaitCommEvent(MemorySegment hFile, MemorySegment lpEvtMask, MemorySegment lpOverlapped) {
        var mh$ = WaitCommEvent.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WaitCommEvent", hFile, lpEvtMask, lpOverlapped);
            }
            return (int)mh$.invokeExact(hFile, lpEvtMask, lpOverlapped);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class OpenCommPort {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_LONG,
            C_LONG,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("OpenCommPort"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HANDLE OpenCommPort(ULONG uPortNumber, DWORD dwDesiredAccess, DWORD dwFlagsAndAttributes)
     * }
     */
    public static FunctionDescriptor OpenCommPort$descriptor() {
        return OpenCommPort.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HANDLE OpenCommPort(ULONG uPortNumber, DWORD dwDesiredAccess, DWORD dwFlagsAndAttributes)
     * }
     */
    public static MethodHandle OpenCommPort$handle() {
        return OpenCommPort.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * HANDLE OpenCommPort(ULONG uPortNumber, DWORD dwDesiredAccess, DWORD dwFlagsAndAttributes)
     * }
     */
    public static MemorySegment OpenCommPort(int uPortNumber, int dwDesiredAccess, int dwFlagsAndAttributes) {
        var mh$ = OpenCommPort.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("OpenCommPort", uPortNumber, dwDesiredAccess, dwFlagsAndAttributes);
            }
            return (MemorySegment)mh$.invokeExact(uPortNumber, dwDesiredAccess, dwFlagsAndAttributes);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetCommPorts {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_POINTER,
            C_LONG,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetCommPorts"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ULONG GetCommPorts(PULONG lpPortNumbers, ULONG uPortNumbersCount, PULONG puPortNumbersFound)
     * }
     */
    public static FunctionDescriptor GetCommPorts$descriptor() {
        return GetCommPorts.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ULONG GetCommPorts(PULONG lpPortNumbers, ULONG uPortNumbersCount, PULONG puPortNumbersFound)
     * }
     */
    public static MethodHandle GetCommPorts$handle() {
        return GetCommPorts.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * ULONG GetCommPorts(PULONG lpPortNumbers, ULONG uPortNumbersCount, PULONG puPortNumbersFound)
     * }
     */
    public static int GetCommPorts(MemorySegment lpPortNumbers, int uPortNumbersCount, MemorySegment puPortNumbersFound) {
        var mh$ = GetCommPorts.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetCommPorts", lpPortNumbers, uPortNumbersCount, puPortNumbersFound);
            }
            return (int)mh$.invokeExact(lpPortNumbers, uPortNumbersCount, puPortNumbersFound);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetTapePosition {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_POINTER,
            C_LONG,
            C_LONG,
            C_LONG,
            C_LONG,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("SetTapePosition"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD SetTapePosition(HANDLE hDevice, DWORD dwPositionMethod, DWORD dwPartition, DWORD dwOffsetLow, DWORD dwOffsetHigh, BOOL bImmediate)
     * }
     */
    public static FunctionDescriptor SetTapePosition$descriptor() {
        return SetTapePosition.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD SetTapePosition(HANDLE hDevice, DWORD dwPositionMethod, DWORD dwPartition, DWORD dwOffsetLow, DWORD dwOffsetHigh, BOOL bImmediate)
     * }
     */
    public static MethodHandle SetTapePosition$handle() {
        return SetTapePosition.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * DWORD SetTapePosition(HANDLE hDevice, DWORD dwPositionMethod, DWORD dwPartition, DWORD dwOffsetLow, DWORD dwOffsetHigh, BOOL bImmediate)
     * }
     */
    public static int SetTapePosition(MemorySegment hDevice, int dwPositionMethod, int dwPartition, int dwOffsetLow, int dwOffsetHigh, int bImmediate) {
        var mh$ = SetTapePosition.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetTapePosition", hDevice, dwPositionMethod, dwPartition, dwOffsetLow, dwOffsetHigh, bImmediate);
            }
            return (int)mh$.invokeExact(hDevice, dwPositionMethod, dwPartition, dwOffsetLow, dwOffsetHigh, bImmediate);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetTapePosition {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_POINTER,
            C_LONG,
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetTapePosition"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetTapePosition(HANDLE hDevice, DWORD dwPositionType, LPDWORD lpdwPartition, LPDWORD lpdwOffsetLow, LPDWORD lpdwOffsetHigh)
     * }
     */
    public static FunctionDescriptor GetTapePosition$descriptor() {
        return GetTapePosition.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetTapePosition(HANDLE hDevice, DWORD dwPositionType, LPDWORD lpdwPartition, LPDWORD lpdwOffsetLow, LPDWORD lpdwOffsetHigh)
     * }
     */
    public static MethodHandle GetTapePosition$handle() {
        return GetTapePosition.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * DWORD GetTapePosition(HANDLE hDevice, DWORD dwPositionType, LPDWORD lpdwPartition, LPDWORD lpdwOffsetLow, LPDWORD lpdwOffsetHigh)
     * }
     */
    public static int GetTapePosition(MemorySegment hDevice, int dwPositionType, MemorySegment lpdwPartition, MemorySegment lpdwOffsetLow, MemorySegment lpdwOffsetHigh) {
        var mh$ = GetTapePosition.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetTapePosition", hDevice, dwPositionType, lpdwPartition, lpdwOffsetLow, lpdwOffsetHigh);
            }
            return (int)mh$.invokeExact(hDevice, dwPositionType, lpdwPartition, lpdwOffsetLow, lpdwOffsetHigh);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PrepareTape {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_POINTER,
            C_LONG,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("PrepareTape"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD PrepareTape(HANDLE hDevice, DWORD dwOperation, BOOL bImmediate)
     * }
     */
    public static FunctionDescriptor PrepareTape$descriptor() {
        return PrepareTape.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD PrepareTape(HANDLE hDevice, DWORD dwOperation, BOOL bImmediate)
     * }
     */
    public static MethodHandle PrepareTape$handle() {
        return PrepareTape.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * DWORD PrepareTape(HANDLE hDevice, DWORD dwOperation, BOOL bImmediate)
     * }
     */
    public static int PrepareTape(MemorySegment hDevice, int dwOperation, int bImmediate) {
        var mh$ = PrepareTape.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PrepareTape", hDevice, dwOperation, bImmediate);
            }
            return (int)mh$.invokeExact(hDevice, dwOperation, bImmediate);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class EraseTape {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_POINTER,
            C_LONG,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("EraseTape"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD EraseTape(HANDLE hDevice, DWORD dwEraseType, BOOL bImmediate)
     * }
     */
    public static FunctionDescriptor EraseTape$descriptor() {
        return EraseTape.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD EraseTape(HANDLE hDevice, DWORD dwEraseType, BOOL bImmediate)
     * }
     */
    public static MethodHandle EraseTape$handle() {
        return EraseTape.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * DWORD EraseTape(HANDLE hDevice, DWORD dwEraseType, BOOL bImmediate)
     * }
     */
    public static int EraseTape(MemorySegment hDevice, int dwEraseType, int bImmediate) {
        var mh$ = EraseTape.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("EraseTape", hDevice, dwEraseType, bImmediate);
            }
            return (int)mh$.invokeExact(hDevice, dwEraseType, bImmediate);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateTapePartition {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_POINTER,
            C_LONG,
            C_LONG,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CreateTapePartition"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD CreateTapePartition(HANDLE hDevice, DWORD dwPartitionMethod, DWORD dwCount, DWORD dwSize)
     * }
     */
    public static FunctionDescriptor CreateTapePartition$descriptor() {
        return CreateTapePartition.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD CreateTapePartition(HANDLE hDevice, DWORD dwPartitionMethod, DWORD dwCount, DWORD dwSize)
     * }
     */
    public static MethodHandle CreateTapePartition$handle() {
        return CreateTapePartition.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * DWORD CreateTapePartition(HANDLE hDevice, DWORD dwPartitionMethod, DWORD dwCount, DWORD dwSize)
     * }
     */
    public static int CreateTapePartition(MemorySegment hDevice, int dwPartitionMethod, int dwCount, int dwSize) {
        var mh$ = CreateTapePartition.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateTapePartition", hDevice, dwPartitionMethod, dwCount, dwSize);
            }
            return (int)mh$.invokeExact(hDevice, dwPartitionMethod, dwCount, dwSize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class WriteTapemark {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_POINTER,
            C_LONG,
            C_LONG,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("WriteTapemark"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD WriteTapemark(HANDLE hDevice, DWORD dwTapemarkType, DWORD dwTapemarkCount, BOOL bImmediate)
     * }
     */
    public static FunctionDescriptor WriteTapemark$descriptor() {
        return WriteTapemark.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD WriteTapemark(HANDLE hDevice, DWORD dwTapemarkType, DWORD dwTapemarkCount, BOOL bImmediate)
     * }
     */
    public static MethodHandle WriteTapemark$handle() {
        return WriteTapemark.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * DWORD WriteTapemark(HANDLE hDevice, DWORD dwTapemarkType, DWORD dwTapemarkCount, BOOL bImmediate)
     * }
     */
    public static int WriteTapemark(MemorySegment hDevice, int dwTapemarkType, int dwTapemarkCount, int bImmediate) {
        var mh$ = WriteTapemark.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WriteTapemark", hDevice, dwTapemarkType, dwTapemarkCount, bImmediate);
            }
            return (int)mh$.invokeExact(hDevice, dwTapemarkType, dwTapemarkCount, bImmediate);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetTapeStatus {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetTapeStatus"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetTapeStatus(HANDLE hDevice)
     * }
     */
    public static FunctionDescriptor GetTapeStatus$descriptor() {
        return GetTapeStatus.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetTapeStatus(HANDLE hDevice)
     * }
     */
    public static MethodHandle GetTapeStatus$handle() {
        return GetTapeStatus.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * DWORD GetTapeStatus(HANDLE hDevice)
     * }
     */
    public static int GetTapeStatus(MemorySegment hDevice) {
        var mh$ = GetTapeStatus.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetTapeStatus", hDevice);
            }
            return (int)mh$.invokeExact(hDevice);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetTapeParameters {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_POINTER,
            C_LONG,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetTapeParameters"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetTapeParameters(HANDLE hDevice, DWORD dwOperation, LPDWORD lpdwSize, LPVOID lpTapeInformation)
     * }
     */
    public static FunctionDescriptor GetTapeParameters$descriptor() {
        return GetTapeParameters.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetTapeParameters(HANDLE hDevice, DWORD dwOperation, LPDWORD lpdwSize, LPVOID lpTapeInformation)
     * }
     */
    public static MethodHandle GetTapeParameters$handle() {
        return GetTapeParameters.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * DWORD GetTapeParameters(HANDLE hDevice, DWORD dwOperation, LPDWORD lpdwSize, LPVOID lpTapeInformation)
     * }
     */
    public static int GetTapeParameters(MemorySegment hDevice, int dwOperation, MemorySegment lpdwSize, MemorySegment lpTapeInformation) {
        var mh$ = GetTapeParameters.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetTapeParameters", hDevice, dwOperation, lpdwSize, lpTapeInformation);
            }
            return (int)mh$.invokeExact(hDevice, dwOperation, lpdwSize, lpTapeInformation);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetTapeParameters {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_POINTER,
            C_LONG,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("SetTapeParameters"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD SetTapeParameters(HANDLE hDevice, DWORD dwOperation, LPVOID lpTapeInformation)
     * }
     */
    public static FunctionDescriptor SetTapeParameters$descriptor() {
        return SetTapeParameters.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD SetTapeParameters(HANDLE hDevice, DWORD dwOperation, LPVOID lpTapeInformation)
     * }
     */
    public static MethodHandle SetTapeParameters$handle() {
        return SetTapeParameters.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * DWORD SetTapeParameters(HANDLE hDevice, DWORD dwOperation, LPVOID lpTapeInformation)
     * }
     */
    public static int SetTapeParameters(MemorySegment hDevice, int dwOperation, MemorySegment lpTapeInformation) {
        var mh$ = SetTapeParameters.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetTapeParameters", hDevice, dwOperation, lpTapeInformation);
            }
            return (int)mh$.invokeExact(hDevice, dwOperation, lpTapeInformation);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MulDiv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_INT,
            C_INT,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("MulDiv"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int MulDiv(int nNumber, int nNumerator, int nDenominator)
     * }
     */
    public static FunctionDescriptor MulDiv$descriptor() {
        return MulDiv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int MulDiv(int nNumber, int nNumerator, int nDenominator)
     * }
     */
    public static MethodHandle MulDiv$handle() {
        return MulDiv.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int MulDiv(int nNumber, int nNumerator, int nDenominator)
     * }
     */
    public static int MulDiv(int nNumber, int nNumerator, int nDenominator) {
        var mh$ = MulDiv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MulDiv", nNumber, nNumerator, nDenominator);
            }
            return (int)mh$.invokeExact(nNumber, nNumerator, nDenominator);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int DEPPolicyAlwaysOff = (int)0L;
    /**
     * {@snippet lang=c :
     * enum _DEP_SYSTEM_POLICY_TYPE.DEPPolicyAlwaysOff = 0
     * }
     */
    public static int DEPPolicyAlwaysOff() {
        return DEPPolicyAlwaysOff;
    }
    private static final int DEPPolicyAlwaysOn = (int)1L;
    /**
     * {@snippet lang=c :
     * enum _DEP_SYSTEM_POLICY_TYPE.DEPPolicyAlwaysOn = 1
     * }
     */
    public static int DEPPolicyAlwaysOn() {
        return DEPPolicyAlwaysOn;
    }
    private static final int DEPPolicyOptIn = (int)2L;
    /**
     * {@snippet lang=c :
     * enum _DEP_SYSTEM_POLICY_TYPE.DEPPolicyOptIn = 2
     * }
     */
    public static int DEPPolicyOptIn() {
        return DEPPolicyOptIn;
    }
    private static final int DEPPolicyOptOut = (int)3L;
    /**
     * {@snippet lang=c :
     * enum _DEP_SYSTEM_POLICY_TYPE.DEPPolicyOptOut = 3
     * }
     */
    public static int DEPPolicyOptOut() {
        return DEPPolicyOptOut;
    }
    private static final int DEPTotalPolicyCount = (int)4L;
    /**
     * {@snippet lang=c :
     * enum _DEP_SYSTEM_POLICY_TYPE.DEPTotalPolicyCount = 4
     * }
     */
    public static int DEPTotalPolicyCount() {
        return DEPTotalPolicyCount;
    }

    private static class GetSystemDEPPolicy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT    );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetSystemDEPPolicy"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DEP_SYSTEM_POLICY_TYPE GetSystemDEPPolicy()
     * }
     */
    public static FunctionDescriptor GetSystemDEPPolicy$descriptor() {
        return GetSystemDEPPolicy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DEP_SYSTEM_POLICY_TYPE GetSystemDEPPolicy()
     * }
     */
    public static MethodHandle GetSystemDEPPolicy$handle() {
        return GetSystemDEPPolicy.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * DEP_SYSTEM_POLICY_TYPE GetSystemDEPPolicy()
     * }
     */
    public static int GetSystemDEPPolicy() {
        var mh$ = GetSystemDEPPolicy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetSystemDEPPolicy");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetSystemRegistryQuota {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetSystemRegistryQuota"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetSystemRegistryQuota(PDWORD pdwQuotaAllowed, PDWORD pdwQuotaUsed)
     * }
     */
    public static FunctionDescriptor GetSystemRegistryQuota$descriptor() {
        return GetSystemRegistryQuota.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetSystemRegistryQuota(PDWORD pdwQuotaAllowed, PDWORD pdwQuotaUsed)
     * }
     */
    public static MethodHandle GetSystemRegistryQuota$handle() {
        return GetSystemRegistryQuota.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL GetSystemRegistryQuota(PDWORD pdwQuotaAllowed, PDWORD pdwQuotaUsed)
     * }
     */
    public static int GetSystemRegistryQuota(MemorySegment pdwQuotaAllowed, MemorySegment pdwQuotaUsed) {
        var mh$ = GetSystemRegistryQuota.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetSystemRegistryQuota", pdwQuotaAllowed, pdwQuotaUsed);
            }
            return (int)mh$.invokeExact(pdwQuotaAllowed, pdwQuotaUsed);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FileTimeToDosDateTime {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("FileTimeToDosDateTime"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL FileTimeToDosDateTime(const FILETIME *lpFileTime, LPWORD lpFatDate, LPWORD lpFatTime)
     * }
     */
    public static FunctionDescriptor FileTimeToDosDateTime$descriptor() {
        return FileTimeToDosDateTime.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL FileTimeToDosDateTime(const FILETIME *lpFileTime, LPWORD lpFatDate, LPWORD lpFatTime)
     * }
     */
    public static MethodHandle FileTimeToDosDateTime$handle() {
        return FileTimeToDosDateTime.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL FileTimeToDosDateTime(const FILETIME *lpFileTime, LPWORD lpFatDate, LPWORD lpFatTime)
     * }
     */
    public static int FileTimeToDosDateTime(MemorySegment lpFileTime, MemorySegment lpFatDate, MemorySegment lpFatTime) {
        var mh$ = FileTimeToDosDateTime.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FileTimeToDosDateTime", lpFileTime, lpFatDate, lpFatTime);
            }
            return (int)mh$.invokeExact(lpFileTime, lpFatDate, lpFatTime);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DosDateTimeToFileTime {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_SHORT,
            C_SHORT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("DosDateTimeToFileTime"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL DosDateTimeToFileTime(WORD wFatDate, WORD wFatTime, LPFILETIME lpFileTime)
     * }
     */
    public static FunctionDescriptor DosDateTimeToFileTime$descriptor() {
        return DosDateTimeToFileTime.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL DosDateTimeToFileTime(WORD wFatDate, WORD wFatTime, LPFILETIME lpFileTime)
     * }
     */
    public static MethodHandle DosDateTimeToFileTime$handle() {
        return DosDateTimeToFileTime.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL DosDateTimeToFileTime(WORD wFatDate, WORD wFatTime, LPFILETIME lpFileTime)
     * }
     */
    public static int DosDateTimeToFileTime(short wFatDate, short wFatTime, MemorySegment lpFileTime) {
        var mh$ = DosDateTimeToFileTime.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DosDateTimeToFileTime", wFatDate, wFatTime, lpFileTime);
            }
            return (int)mh$.invokeExact(wFatDate, wFatTime, lpFileTime);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FormatMessageA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_LONG,
            C_POINTER,
            C_LONG,
            C_LONG,
            C_POINTER,
            C_LONG,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("FormatMessageA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD FormatMessageA(DWORD dwFlags, LPCVOID lpSource, DWORD dwMessageId, DWORD dwLanguageId, LPSTR lpBuffer, DWORD nSize, va_list *Arguments)
     * }
     */
    public static FunctionDescriptor FormatMessageA$descriptor() {
        return FormatMessageA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD FormatMessageA(DWORD dwFlags, LPCVOID lpSource, DWORD dwMessageId, DWORD dwLanguageId, LPSTR lpBuffer, DWORD nSize, va_list *Arguments)
     * }
     */
    public static MethodHandle FormatMessageA$handle() {
        return FormatMessageA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * DWORD FormatMessageA(DWORD dwFlags, LPCVOID lpSource, DWORD dwMessageId, DWORD dwLanguageId, LPSTR lpBuffer, DWORD nSize, va_list *Arguments)
     * }
     */
    public static int FormatMessageA(int dwFlags, MemorySegment lpSource, int dwMessageId, int dwLanguageId, MemorySegment lpBuffer, int nSize, MemorySegment Arguments) {
        var mh$ = FormatMessageA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FormatMessageA", dwFlags, lpSource, dwMessageId, dwLanguageId, lpBuffer, nSize, Arguments);
            }
            return (int)mh$.invokeExact(dwFlags, lpSource, dwMessageId, dwLanguageId, lpBuffer, nSize, Arguments);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FormatMessageW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_LONG,
            C_POINTER,
            C_LONG,
            C_LONG,
            C_POINTER,
            C_LONG,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("FormatMessageW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD FormatMessageW(DWORD dwFlags, LPCVOID lpSource, DWORD dwMessageId, DWORD dwLanguageId, LPWSTR lpBuffer, DWORD nSize, va_list *Arguments)
     * }
     */
    public static FunctionDescriptor FormatMessageW$descriptor() {
        return FormatMessageW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD FormatMessageW(DWORD dwFlags, LPCVOID lpSource, DWORD dwMessageId, DWORD dwLanguageId, LPWSTR lpBuffer, DWORD nSize, va_list *Arguments)
     * }
     */
    public static MethodHandle FormatMessageW$handle() {
        return FormatMessageW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * DWORD FormatMessageW(DWORD dwFlags, LPCVOID lpSource, DWORD dwMessageId, DWORD dwLanguageId, LPWSTR lpBuffer, DWORD nSize, va_list *Arguments)
     * }
     */
    public static int FormatMessageW(int dwFlags, MemorySegment lpSource, int dwMessageId, int dwLanguageId, MemorySegment lpBuffer, int nSize, MemorySegment Arguments) {
        var mh$ = FormatMessageW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FormatMessageW", dwFlags, lpSource, dwMessageId, dwLanguageId, lpBuffer, nSize, Arguments);
            }
            return (int)mh$.invokeExact(dwFlags, lpSource, dwMessageId, dwLanguageId, lpBuffer, nSize, Arguments);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateMailslotA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER,
            C_LONG,
            C_LONG,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CreateMailslotA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HANDLE CreateMailslotA(LPCSTR lpName, DWORD nMaxMessageSize, DWORD lReadTimeout, LPSECURITY_ATTRIBUTES lpSecurityAttributes)
     * }
     */
    public static FunctionDescriptor CreateMailslotA$descriptor() {
        return CreateMailslotA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HANDLE CreateMailslotA(LPCSTR lpName, DWORD nMaxMessageSize, DWORD lReadTimeout, LPSECURITY_ATTRIBUTES lpSecurityAttributes)
     * }
     */
    public static MethodHandle CreateMailslotA$handle() {
        return CreateMailslotA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * HANDLE CreateMailslotA(LPCSTR lpName, DWORD nMaxMessageSize, DWORD lReadTimeout, LPSECURITY_ATTRIBUTES lpSecurityAttributes)
     * }
     */
    public static MemorySegment CreateMailslotA(MemorySegment lpName, int nMaxMessageSize, int lReadTimeout, MemorySegment lpSecurityAttributes) {
        var mh$ = CreateMailslotA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateMailslotA", lpName, nMaxMessageSize, lReadTimeout, lpSecurityAttributes);
            }
            return (MemorySegment)mh$.invokeExact(lpName, nMaxMessageSize, lReadTimeout, lpSecurityAttributes);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateMailslotW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER,
            C_LONG,
            C_LONG,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CreateMailslotW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HANDLE CreateMailslotW(LPCWSTR lpName, DWORD nMaxMessageSize, DWORD lReadTimeout, LPSECURITY_ATTRIBUTES lpSecurityAttributes)
     * }
     */
    public static FunctionDescriptor CreateMailslotW$descriptor() {
        return CreateMailslotW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HANDLE CreateMailslotW(LPCWSTR lpName, DWORD nMaxMessageSize, DWORD lReadTimeout, LPSECURITY_ATTRIBUTES lpSecurityAttributes)
     * }
     */
    public static MethodHandle CreateMailslotW$handle() {
        return CreateMailslotW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * HANDLE CreateMailslotW(LPCWSTR lpName, DWORD nMaxMessageSize, DWORD lReadTimeout, LPSECURITY_ATTRIBUTES lpSecurityAttributes)
     * }
     */
    public static MemorySegment CreateMailslotW(MemorySegment lpName, int nMaxMessageSize, int lReadTimeout, MemorySegment lpSecurityAttributes) {
        var mh$ = CreateMailslotW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateMailslotW", lpName, nMaxMessageSize, lReadTimeout, lpSecurityAttributes);
            }
            return (MemorySegment)mh$.invokeExact(lpName, nMaxMessageSize, lReadTimeout, lpSecurityAttributes);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetMailslotInfo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetMailslotInfo"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetMailslotInfo(HANDLE hMailslot, LPDWORD lpMaxMessageSize, LPDWORD lpNextSize, LPDWORD lpMessageCount, LPDWORD lpReadTimeout)
     * }
     */
    public static FunctionDescriptor GetMailslotInfo$descriptor() {
        return GetMailslotInfo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetMailslotInfo(HANDLE hMailslot, LPDWORD lpMaxMessageSize, LPDWORD lpNextSize, LPDWORD lpMessageCount, LPDWORD lpReadTimeout)
     * }
     */
    public static MethodHandle GetMailslotInfo$handle() {
        return GetMailslotInfo.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL GetMailslotInfo(HANDLE hMailslot, LPDWORD lpMaxMessageSize, LPDWORD lpNextSize, LPDWORD lpMessageCount, LPDWORD lpReadTimeout)
     * }
     */
    public static int GetMailslotInfo(MemorySegment hMailslot, MemorySegment lpMaxMessageSize, MemorySegment lpNextSize, MemorySegment lpMessageCount, MemorySegment lpReadTimeout) {
        var mh$ = GetMailslotInfo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetMailslotInfo", hMailslot, lpMaxMessageSize, lpNextSize, lpMessageCount, lpReadTimeout);
            }
            return (int)mh$.invokeExact(hMailslot, lpMaxMessageSize, lpNextSize, lpMessageCount, lpReadTimeout);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetMailslotInfo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("SetMailslotInfo"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetMailslotInfo(HANDLE hMailslot, DWORD lReadTimeout)
     * }
     */
    public static FunctionDescriptor SetMailslotInfo$descriptor() {
        return SetMailslotInfo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetMailslotInfo(HANDLE hMailslot, DWORD lReadTimeout)
     * }
     */
    public static MethodHandle SetMailslotInfo$handle() {
        return SetMailslotInfo.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL SetMailslotInfo(HANDLE hMailslot, DWORD lReadTimeout)
     * }
     */
    public static int SetMailslotInfo(MemorySegment hMailslot, int lReadTimeout) {
        var mh$ = SetMailslotInfo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetMailslotInfo", hMailslot, lReadTimeout);
            }
            return (int)mh$.invokeExact(hMailslot, lReadTimeout);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class EncryptFileA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("EncryptFileA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL EncryptFileA(LPCSTR lpFileName)
     * }
     */
    public static FunctionDescriptor EncryptFileA$descriptor() {
        return EncryptFileA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL EncryptFileA(LPCSTR lpFileName)
     * }
     */
    public static MethodHandle EncryptFileA$handle() {
        return EncryptFileA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL EncryptFileA(LPCSTR lpFileName)
     * }
     */
    public static int EncryptFileA(MemorySegment lpFileName) {
        var mh$ = EncryptFileA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("EncryptFileA", lpFileName);
            }
            return (int)mh$.invokeExact(lpFileName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class EncryptFileW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("EncryptFileW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL EncryptFileW(LPCWSTR lpFileName)
     * }
     */
    public static FunctionDescriptor EncryptFileW$descriptor() {
        return EncryptFileW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL EncryptFileW(LPCWSTR lpFileName)
     * }
     */
    public static MethodHandle EncryptFileW$handle() {
        return EncryptFileW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL EncryptFileW(LPCWSTR lpFileName)
     * }
     */
    public static int EncryptFileW(MemorySegment lpFileName) {
        var mh$ = EncryptFileW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("EncryptFileW", lpFileName);
            }
            return (int)mh$.invokeExact(lpFileName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DecryptFileA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("DecryptFileA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL DecryptFileA(LPCSTR lpFileName, DWORD dwReserved)
     * }
     */
    public static FunctionDescriptor DecryptFileA$descriptor() {
        return DecryptFileA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL DecryptFileA(LPCSTR lpFileName, DWORD dwReserved)
     * }
     */
    public static MethodHandle DecryptFileA$handle() {
        return DecryptFileA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL DecryptFileA(LPCSTR lpFileName, DWORD dwReserved)
     * }
     */
    public static int DecryptFileA(MemorySegment lpFileName, int dwReserved) {
        var mh$ = DecryptFileA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DecryptFileA", lpFileName, dwReserved);
            }
            return (int)mh$.invokeExact(lpFileName, dwReserved);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DecryptFileW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("DecryptFileW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL DecryptFileW(LPCWSTR lpFileName, DWORD dwReserved)
     * }
     */
    public static FunctionDescriptor DecryptFileW$descriptor() {
        return DecryptFileW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL DecryptFileW(LPCWSTR lpFileName, DWORD dwReserved)
     * }
     */
    public static MethodHandle DecryptFileW$handle() {
        return DecryptFileW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL DecryptFileW(LPCWSTR lpFileName, DWORD dwReserved)
     * }
     */
    public static int DecryptFileW(MemorySegment lpFileName, int dwReserved) {
        var mh$ = DecryptFileW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DecryptFileW", lpFileName, dwReserved);
            }
            return (int)mh$.invokeExact(lpFileName, dwReserved);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FileEncryptionStatusA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("FileEncryptionStatusA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL FileEncryptionStatusA(LPCSTR lpFileName, LPDWORD lpStatus)
     * }
     */
    public static FunctionDescriptor FileEncryptionStatusA$descriptor() {
        return FileEncryptionStatusA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL FileEncryptionStatusA(LPCSTR lpFileName, LPDWORD lpStatus)
     * }
     */
    public static MethodHandle FileEncryptionStatusA$handle() {
        return FileEncryptionStatusA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL FileEncryptionStatusA(LPCSTR lpFileName, LPDWORD lpStatus)
     * }
     */
    public static int FileEncryptionStatusA(MemorySegment lpFileName, MemorySegment lpStatus) {
        var mh$ = FileEncryptionStatusA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FileEncryptionStatusA", lpFileName, lpStatus);
            }
            return (int)mh$.invokeExact(lpFileName, lpStatus);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FileEncryptionStatusW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("FileEncryptionStatusW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL FileEncryptionStatusW(LPCWSTR lpFileName, LPDWORD lpStatus)
     * }
     */
    public static FunctionDescriptor FileEncryptionStatusW$descriptor() {
        return FileEncryptionStatusW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL FileEncryptionStatusW(LPCWSTR lpFileName, LPDWORD lpStatus)
     * }
     */
    public static MethodHandle FileEncryptionStatusW$handle() {
        return FileEncryptionStatusW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL FileEncryptionStatusW(LPCWSTR lpFileName, LPDWORD lpStatus)
     * }
     */
    public static int FileEncryptionStatusW(MemorySegment lpFileName, MemorySegment lpStatus) {
        var mh$ = FileEncryptionStatusW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FileEncryptionStatusW", lpFileName, lpStatus);
            }
            return (int)mh$.invokeExact(lpFileName, lpStatus);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class OpenEncryptedFileRawA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_POINTER,
            C_LONG,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("OpenEncryptedFileRawA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD OpenEncryptedFileRawA(LPCSTR lpFileName, ULONG ulFlags, PVOID *pvContext)
     * }
     */
    public static FunctionDescriptor OpenEncryptedFileRawA$descriptor() {
        return OpenEncryptedFileRawA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD OpenEncryptedFileRawA(LPCSTR lpFileName, ULONG ulFlags, PVOID *pvContext)
     * }
     */
    public static MethodHandle OpenEncryptedFileRawA$handle() {
        return OpenEncryptedFileRawA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * DWORD OpenEncryptedFileRawA(LPCSTR lpFileName, ULONG ulFlags, PVOID *pvContext)
     * }
     */
    public static int OpenEncryptedFileRawA(MemorySegment lpFileName, int ulFlags, MemorySegment pvContext) {
        var mh$ = OpenEncryptedFileRawA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("OpenEncryptedFileRawA", lpFileName, ulFlags, pvContext);
            }
            return (int)mh$.invokeExact(lpFileName, ulFlags, pvContext);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class OpenEncryptedFileRawW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_POINTER,
            C_LONG,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("OpenEncryptedFileRawW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD OpenEncryptedFileRawW(LPCWSTR lpFileName, ULONG ulFlags, PVOID *pvContext)
     * }
     */
    public static FunctionDescriptor OpenEncryptedFileRawW$descriptor() {
        return OpenEncryptedFileRawW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD OpenEncryptedFileRawW(LPCWSTR lpFileName, ULONG ulFlags, PVOID *pvContext)
     * }
     */
    public static MethodHandle OpenEncryptedFileRawW$handle() {
        return OpenEncryptedFileRawW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * DWORD OpenEncryptedFileRawW(LPCWSTR lpFileName, ULONG ulFlags, PVOID *pvContext)
     * }
     */
    public static int OpenEncryptedFileRawW(MemorySegment lpFileName, int ulFlags, MemorySegment pvContext) {
        var mh$ = OpenEncryptedFileRawW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("OpenEncryptedFileRawW", lpFileName, ulFlags, pvContext);
            }
            return (int)mh$.invokeExact(lpFileName, ulFlags, pvContext);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ReadEncryptedFileRaw {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("ReadEncryptedFileRaw"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD ReadEncryptedFileRaw(PFE_EXPORT_FUNC pfExportCallback, PVOID pvCallbackContext, PVOID pvContext)
     * }
     */
    public static FunctionDescriptor ReadEncryptedFileRaw$descriptor() {
        return ReadEncryptedFileRaw.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD ReadEncryptedFileRaw(PFE_EXPORT_FUNC pfExportCallback, PVOID pvCallbackContext, PVOID pvContext)
     * }
     */
    public static MethodHandle ReadEncryptedFileRaw$handle() {
        return ReadEncryptedFileRaw.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * DWORD ReadEncryptedFileRaw(PFE_EXPORT_FUNC pfExportCallback, PVOID pvCallbackContext, PVOID pvContext)
     * }
     */
    public static int ReadEncryptedFileRaw(MemorySegment pfExportCallback, MemorySegment pvCallbackContext, MemorySegment pvContext) {
        var mh$ = ReadEncryptedFileRaw.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ReadEncryptedFileRaw", pfExportCallback, pvCallbackContext, pvContext);
            }
            return (int)mh$.invokeExact(pfExportCallback, pvCallbackContext, pvContext);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class WriteEncryptedFileRaw {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("WriteEncryptedFileRaw"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD WriteEncryptedFileRaw(PFE_IMPORT_FUNC pfImportCallback, PVOID pvCallbackContext, PVOID pvContext)
     * }
     */
    public static FunctionDescriptor WriteEncryptedFileRaw$descriptor() {
        return WriteEncryptedFileRaw.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD WriteEncryptedFileRaw(PFE_IMPORT_FUNC pfImportCallback, PVOID pvCallbackContext, PVOID pvContext)
     * }
     */
    public static MethodHandle WriteEncryptedFileRaw$handle() {
        return WriteEncryptedFileRaw.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * DWORD WriteEncryptedFileRaw(PFE_IMPORT_FUNC pfImportCallback, PVOID pvCallbackContext, PVOID pvContext)
     * }
     */
    public static int WriteEncryptedFileRaw(MemorySegment pfImportCallback, MemorySegment pvCallbackContext, MemorySegment pvContext) {
        var mh$ = WriteEncryptedFileRaw.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WriteEncryptedFileRaw", pfImportCallback, pvCallbackContext, pvContext);
            }
            return (int)mh$.invokeExact(pfImportCallback, pvCallbackContext, pvContext);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CloseEncryptedFileRaw {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CloseEncryptedFileRaw"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void CloseEncryptedFileRaw(PVOID pvContext)
     * }
     */
    public static FunctionDescriptor CloseEncryptedFileRaw$descriptor() {
        return CloseEncryptedFileRaw.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void CloseEncryptedFileRaw(PVOID pvContext)
     * }
     */
    public static MethodHandle CloseEncryptedFileRaw$handle() {
        return CloseEncryptedFileRaw.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * void CloseEncryptedFileRaw(PVOID pvContext)
     * }
     */
    public static void CloseEncryptedFileRaw(MemorySegment pvContext) {
        var mh$ = CloseEncryptedFileRaw.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CloseEncryptedFileRaw", pvContext);
            }
            mh$.invokeExact(pvContext);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lstrcmpA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("lstrcmpA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int lstrcmpA(LPCSTR lpString1, LPCSTR lpString2)
     * }
     */
    public static FunctionDescriptor lstrcmpA$descriptor() {
        return lstrcmpA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int lstrcmpA(LPCSTR lpString1, LPCSTR lpString2)
     * }
     */
    public static MethodHandle lstrcmpA$handle() {
        return lstrcmpA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int lstrcmpA(LPCSTR lpString1, LPCSTR lpString2)
     * }
     */
    public static int lstrcmpA(MemorySegment lpString1, MemorySegment lpString2) {
        var mh$ = lstrcmpA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lstrcmpA", lpString1, lpString2);
            }
            return (int)mh$.invokeExact(lpString1, lpString2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lstrcmpW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("lstrcmpW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int lstrcmpW(LPCWSTR lpString1, LPCWSTR lpString2)
     * }
     */
    public static FunctionDescriptor lstrcmpW$descriptor() {
        return lstrcmpW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int lstrcmpW(LPCWSTR lpString1, LPCWSTR lpString2)
     * }
     */
    public static MethodHandle lstrcmpW$handle() {
        return lstrcmpW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int lstrcmpW(LPCWSTR lpString1, LPCWSTR lpString2)
     * }
     */
    public static int lstrcmpW(MemorySegment lpString1, MemorySegment lpString2) {
        var mh$ = lstrcmpW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lstrcmpW", lpString1, lpString2);
            }
            return (int)mh$.invokeExact(lpString1, lpString2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lstrcmpiA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("lstrcmpiA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int lstrcmpiA(LPCSTR lpString1, LPCSTR lpString2)
     * }
     */
    public static FunctionDescriptor lstrcmpiA$descriptor() {
        return lstrcmpiA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int lstrcmpiA(LPCSTR lpString1, LPCSTR lpString2)
     * }
     */
    public static MethodHandle lstrcmpiA$handle() {
        return lstrcmpiA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int lstrcmpiA(LPCSTR lpString1, LPCSTR lpString2)
     * }
     */
    public static int lstrcmpiA(MemorySegment lpString1, MemorySegment lpString2) {
        var mh$ = lstrcmpiA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lstrcmpiA", lpString1, lpString2);
            }
            return (int)mh$.invokeExact(lpString1, lpString2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lstrcmpiW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("lstrcmpiW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int lstrcmpiW(LPCWSTR lpString1, LPCWSTR lpString2)
     * }
     */
    public static FunctionDescriptor lstrcmpiW$descriptor() {
        return lstrcmpiW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int lstrcmpiW(LPCWSTR lpString1, LPCWSTR lpString2)
     * }
     */
    public static MethodHandle lstrcmpiW$handle() {
        return lstrcmpiW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int lstrcmpiW(LPCWSTR lpString1, LPCWSTR lpString2)
     * }
     */
    public static int lstrcmpiW(MemorySegment lpString1, MemorySegment lpString2) {
        var mh$ = lstrcmpiW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lstrcmpiW", lpString1, lpString2);
            }
            return (int)mh$.invokeExact(lpString1, lpString2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lstrcpynA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("lstrcpynA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LPSTR lstrcpynA(LPSTR lpString1, LPCSTR lpString2, int iMaxLength)
     * }
     */
    public static FunctionDescriptor lstrcpynA$descriptor() {
        return lstrcpynA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LPSTR lstrcpynA(LPSTR lpString1, LPCSTR lpString2, int iMaxLength)
     * }
     */
    public static MethodHandle lstrcpynA$handle() {
        return lstrcpynA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * LPSTR lstrcpynA(LPSTR lpString1, LPCSTR lpString2, int iMaxLength)
     * }
     */
    public static MemorySegment lstrcpynA(MemorySegment lpString1, MemorySegment lpString2, int iMaxLength) {
        var mh$ = lstrcpynA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lstrcpynA", lpString1, lpString2, iMaxLength);
            }
            return (MemorySegment)mh$.invokeExact(lpString1, lpString2, iMaxLength);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lstrcpynW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("lstrcpynW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LPWSTR lstrcpynW(LPWSTR lpString1, LPCWSTR lpString2, int iMaxLength)
     * }
     */
    public static FunctionDescriptor lstrcpynW$descriptor() {
        return lstrcpynW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LPWSTR lstrcpynW(LPWSTR lpString1, LPCWSTR lpString2, int iMaxLength)
     * }
     */
    public static MethodHandle lstrcpynW$handle() {
        return lstrcpynW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * LPWSTR lstrcpynW(LPWSTR lpString1, LPCWSTR lpString2, int iMaxLength)
     * }
     */
    public static MemorySegment lstrcpynW(MemorySegment lpString1, MemorySegment lpString2, int iMaxLength) {
        var mh$ = lstrcpynW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lstrcpynW", lpString1, lpString2, iMaxLength);
            }
            return (MemorySegment)mh$.invokeExact(lpString1, lpString2, iMaxLength);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lstrcpyA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("lstrcpyA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LPSTR lstrcpyA(LPSTR lpString1, LPCSTR lpString2)
     * }
     */
    public static FunctionDescriptor lstrcpyA$descriptor() {
        return lstrcpyA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LPSTR lstrcpyA(LPSTR lpString1, LPCSTR lpString2)
     * }
     */
    public static MethodHandle lstrcpyA$handle() {
        return lstrcpyA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * LPSTR lstrcpyA(LPSTR lpString1, LPCSTR lpString2)
     * }
     */
    public static MemorySegment lstrcpyA(MemorySegment lpString1, MemorySegment lpString2) {
        var mh$ = lstrcpyA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lstrcpyA", lpString1, lpString2);
            }
            return (MemorySegment)mh$.invokeExact(lpString1, lpString2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lstrcpyW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("lstrcpyW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LPWSTR lstrcpyW(LPWSTR lpString1, LPCWSTR lpString2)
     * }
     */
    public static FunctionDescriptor lstrcpyW$descriptor() {
        return lstrcpyW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LPWSTR lstrcpyW(LPWSTR lpString1, LPCWSTR lpString2)
     * }
     */
    public static MethodHandle lstrcpyW$handle() {
        return lstrcpyW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * LPWSTR lstrcpyW(LPWSTR lpString1, LPCWSTR lpString2)
     * }
     */
    public static MemorySegment lstrcpyW(MemorySegment lpString1, MemorySegment lpString2) {
        var mh$ = lstrcpyW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lstrcpyW", lpString1, lpString2);
            }
            return (MemorySegment)mh$.invokeExact(lpString1, lpString2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lstrcatA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("lstrcatA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LPSTR lstrcatA(LPSTR lpString1, LPCSTR lpString2)
     * }
     */
    public static FunctionDescriptor lstrcatA$descriptor() {
        return lstrcatA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LPSTR lstrcatA(LPSTR lpString1, LPCSTR lpString2)
     * }
     */
    public static MethodHandle lstrcatA$handle() {
        return lstrcatA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * LPSTR lstrcatA(LPSTR lpString1, LPCSTR lpString2)
     * }
     */
    public static MemorySegment lstrcatA(MemorySegment lpString1, MemorySegment lpString2) {
        var mh$ = lstrcatA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lstrcatA", lpString1, lpString2);
            }
            return (MemorySegment)mh$.invokeExact(lpString1, lpString2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lstrcatW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("lstrcatW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LPWSTR lstrcatW(LPWSTR lpString1, LPCWSTR lpString2)
     * }
     */
    public static FunctionDescriptor lstrcatW$descriptor() {
        return lstrcatW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LPWSTR lstrcatW(LPWSTR lpString1, LPCWSTR lpString2)
     * }
     */
    public static MethodHandle lstrcatW$handle() {
        return lstrcatW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * LPWSTR lstrcatW(LPWSTR lpString1, LPCWSTR lpString2)
     * }
     */
    public static MemorySegment lstrcatW(MemorySegment lpString1, MemorySegment lpString2) {
        var mh$ = lstrcatW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lstrcatW", lpString1, lpString2);
            }
            return (MemorySegment)mh$.invokeExact(lpString1, lpString2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lstrlenA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("lstrlenA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int lstrlenA(LPCSTR lpString)
     * }
     */
    public static FunctionDescriptor lstrlenA$descriptor() {
        return lstrlenA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int lstrlenA(LPCSTR lpString)
     * }
     */
    public static MethodHandle lstrlenA$handle() {
        return lstrlenA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int lstrlenA(LPCSTR lpString)
     * }
     */
    public static int lstrlenA(MemorySegment lpString) {
        var mh$ = lstrlenA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lstrlenA", lpString);
            }
            return (int)mh$.invokeExact(lpString);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lstrlenW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("lstrlenW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int lstrlenW(LPCWSTR lpString)
     * }
     */
    public static FunctionDescriptor lstrlenW$descriptor() {
        return lstrlenW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int lstrlenW(LPCWSTR lpString)
     * }
     */
    public static MethodHandle lstrlenW$handle() {
        return lstrlenW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int lstrlenW(LPCWSTR lpString)
     * }
     */
    public static int lstrlenW(MemorySegment lpString) {
        var mh$ = lstrlenW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lstrlenW", lpString);
            }
            return (int)mh$.invokeExact(lpString);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class OpenFile {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("OpenFile"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HFILE OpenFile(LPCSTR lpFileName, LPOFSTRUCT lpReOpenBuff, UINT uStyle)
     * }
     */
    public static FunctionDescriptor OpenFile$descriptor() {
        return OpenFile.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HFILE OpenFile(LPCSTR lpFileName, LPOFSTRUCT lpReOpenBuff, UINT uStyle)
     * }
     */
    public static MethodHandle OpenFile$handle() {
        return OpenFile.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * HFILE OpenFile(LPCSTR lpFileName, LPOFSTRUCT lpReOpenBuff, UINT uStyle)
     * }
     */
    public static int OpenFile(MemorySegment lpFileName, MemorySegment lpReOpenBuff, int uStyle) {
        var mh$ = OpenFile.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("OpenFile", lpFileName, lpReOpenBuff, uStyle);
            }
            return (int)mh$.invokeExact(lpFileName, lpReOpenBuff, uStyle);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _lopen {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("_lopen"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HFILE _lopen(LPCSTR lpPathName, int iReadWrite)
     * }
     */
    public static FunctionDescriptor _lopen$descriptor() {
        return _lopen.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HFILE _lopen(LPCSTR lpPathName, int iReadWrite)
     * }
     */
    public static MethodHandle _lopen$handle() {
        return _lopen.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * HFILE _lopen(LPCSTR lpPathName, int iReadWrite)
     * }
     */
    public static int _lopen(MemorySegment lpPathName, int iReadWrite) {
        var mh$ = _lopen.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_lopen", lpPathName, iReadWrite);
            }
            return (int)mh$.invokeExact(lpPathName, iReadWrite);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _lcreat {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("_lcreat"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HFILE _lcreat(LPCSTR lpPathName, int iAttribute)
     * }
     */
    public static FunctionDescriptor _lcreat$descriptor() {
        return _lcreat.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HFILE _lcreat(LPCSTR lpPathName, int iAttribute)
     * }
     */
    public static MethodHandle _lcreat$handle() {
        return _lcreat.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * HFILE _lcreat(LPCSTR lpPathName, int iAttribute)
     * }
     */
    public static int _lcreat(MemorySegment lpPathName, int iAttribute) {
        var mh$ = _lcreat.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_lcreat", lpPathName, iAttribute);
            }
            return (int)mh$.invokeExact(lpPathName, iAttribute);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _lread {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_INT,
            C_POINTER,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("_lread"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * UINT _lread(HFILE hFile, LPVOID lpBuffer, UINT uBytes)
     * }
     */
    public static FunctionDescriptor _lread$descriptor() {
        return _lread.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * UINT _lread(HFILE hFile, LPVOID lpBuffer, UINT uBytes)
     * }
     */
    public static MethodHandle _lread$handle() {
        return _lread.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * UINT _lread(HFILE hFile, LPVOID lpBuffer, UINT uBytes)
     * }
     */
    public static int _lread(int hFile, MemorySegment lpBuffer, int uBytes) {
        var mh$ = _lread.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_lread", hFile, lpBuffer, uBytes);
            }
            return (int)mh$.invokeExact(hFile, lpBuffer, uBytes);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _lwrite {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_INT,
            C_POINTER,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("_lwrite"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * UINT _lwrite(HFILE hFile, LPCCH lpBuffer, UINT uBytes)
     * }
     */
    public static FunctionDescriptor _lwrite$descriptor() {
        return _lwrite.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * UINT _lwrite(HFILE hFile, LPCCH lpBuffer, UINT uBytes)
     * }
     */
    public static MethodHandle _lwrite$handle() {
        return _lwrite.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * UINT _lwrite(HFILE hFile, LPCCH lpBuffer, UINT uBytes)
     * }
     */
    public static int _lwrite(int hFile, MemorySegment lpBuffer, int uBytes) {
        var mh$ = _lwrite.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_lwrite", hFile, lpBuffer, uBytes);
            }
            return (int)mh$.invokeExact(hFile, lpBuffer, uBytes);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _hread {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_INT,
            C_POINTER,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("_hread"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long _hread(HFILE hFile, LPVOID lpBuffer, long lBytes)
     * }
     */
    public static FunctionDescriptor _hread$descriptor() {
        return _hread.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long _hread(HFILE hFile, LPVOID lpBuffer, long lBytes)
     * }
     */
    public static MethodHandle _hread$handle() {
        return _hread.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * long _hread(HFILE hFile, LPVOID lpBuffer, long lBytes)
     * }
     */
    public static int _hread(int hFile, MemorySegment lpBuffer, int lBytes) {
        var mh$ = _hread.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_hread", hFile, lpBuffer, lBytes);
            }
            return (int)mh$.invokeExact(hFile, lpBuffer, lBytes);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _hwrite {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_INT,
            C_POINTER,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("_hwrite"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long _hwrite(HFILE hFile, LPCCH lpBuffer, long lBytes)
     * }
     */
    public static FunctionDescriptor _hwrite$descriptor() {
        return _hwrite.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long _hwrite(HFILE hFile, LPCCH lpBuffer, long lBytes)
     * }
     */
    public static MethodHandle _hwrite$handle() {
        return _hwrite.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * long _hwrite(HFILE hFile, LPCCH lpBuffer, long lBytes)
     * }
     */
    public static int _hwrite(int hFile, MemorySegment lpBuffer, int lBytes) {
        var mh$ = _hwrite.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_hwrite", hFile, lpBuffer, lBytes);
            }
            return (int)mh$.invokeExact(hFile, lpBuffer, lBytes);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _lclose {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("_lclose"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HFILE _lclose(HFILE hFile)
     * }
     */
    public static FunctionDescriptor _lclose$descriptor() {
        return _lclose.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HFILE _lclose(HFILE hFile)
     * }
     */
    public static MethodHandle _lclose$handle() {
        return _lclose.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * HFILE _lclose(HFILE hFile)
     * }
     */
    public static int _lclose(int hFile) {
        var mh$ = _lclose.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_lclose", hFile);
            }
            return (int)mh$.invokeExact(hFile);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _llseek {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_INT,
            C_LONG,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("_llseek"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LONG _llseek(HFILE hFile, LONG lOffset, int iOrigin)
     * }
     */
    public static FunctionDescriptor _llseek$descriptor() {
        return _llseek.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LONG _llseek(HFILE hFile, LONG lOffset, int iOrigin)
     * }
     */
    public static MethodHandle _llseek$handle() {
        return _llseek.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * LONG _llseek(HFILE hFile, LONG lOffset, int iOrigin)
     * }
     */
    public static int _llseek(int hFile, int lOffset, int iOrigin) {
        var mh$ = _llseek.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_llseek", hFile, lOffset, iOrigin);
            }
            return (int)mh$.invokeExact(hFile, lOffset, iOrigin);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class IsTextUnicode {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("IsTextUnicode"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL IsTextUnicode(const void *lpv, int iSize, LPINT lpiResult)
     * }
     */
    public static FunctionDescriptor IsTextUnicode$descriptor() {
        return IsTextUnicode.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL IsTextUnicode(const void *lpv, int iSize, LPINT lpiResult)
     * }
     */
    public static MethodHandle IsTextUnicode$handle() {
        return IsTextUnicode.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL IsTextUnicode(const void *lpv, int iSize, LPINT lpiResult)
     * }
     */
    public static int IsTextUnicode(MemorySegment lpv, int iSize, MemorySegment lpiResult) {
        var mh$ = IsTextUnicode.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("IsTextUnicode", lpv, iSize, lpiResult);
            }
            return (int)mh$.invokeExact(lpv, iSize, lpiResult);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class BackupRead {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_LONG,
            C_POINTER,
            C_INT,
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("BackupRead"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL BackupRead(HANDLE hFile, LPBYTE lpBuffer, DWORD nNumberOfBytesToRead, LPDWORD lpNumberOfBytesRead, BOOL bAbort, BOOL bProcessSecurity, LPVOID *lpContext)
     * }
     */
    public static FunctionDescriptor BackupRead$descriptor() {
        return BackupRead.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL BackupRead(HANDLE hFile, LPBYTE lpBuffer, DWORD nNumberOfBytesToRead, LPDWORD lpNumberOfBytesRead, BOOL bAbort, BOOL bProcessSecurity, LPVOID *lpContext)
     * }
     */
    public static MethodHandle BackupRead$handle() {
        return BackupRead.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL BackupRead(HANDLE hFile, LPBYTE lpBuffer, DWORD nNumberOfBytesToRead, LPDWORD lpNumberOfBytesRead, BOOL bAbort, BOOL bProcessSecurity, LPVOID *lpContext)
     * }
     */
    public static int BackupRead(MemorySegment hFile, MemorySegment lpBuffer, int nNumberOfBytesToRead, MemorySegment lpNumberOfBytesRead, int bAbort, int bProcessSecurity, MemorySegment lpContext) {
        var mh$ = BackupRead.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("BackupRead", hFile, lpBuffer, nNumberOfBytesToRead, lpNumberOfBytesRead, bAbort, bProcessSecurity, lpContext);
            }
            return (int)mh$.invokeExact(hFile, lpBuffer, nNumberOfBytesToRead, lpNumberOfBytesRead, bAbort, bProcessSecurity, lpContext);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class BackupSeek {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_LONG,
            C_LONG,
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("BackupSeek"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL BackupSeek(HANDLE hFile, DWORD dwLowBytesToSeek, DWORD dwHighBytesToSeek, LPDWORD lpdwLowByteSeeked, LPDWORD lpdwHighByteSeeked, LPVOID *lpContext)
     * }
     */
    public static FunctionDescriptor BackupSeek$descriptor() {
        return BackupSeek.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL BackupSeek(HANDLE hFile, DWORD dwLowBytesToSeek, DWORD dwHighBytesToSeek, LPDWORD lpdwLowByteSeeked, LPDWORD lpdwHighByteSeeked, LPVOID *lpContext)
     * }
     */
    public static MethodHandle BackupSeek$handle() {
        return BackupSeek.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL BackupSeek(HANDLE hFile, DWORD dwLowBytesToSeek, DWORD dwHighBytesToSeek, LPDWORD lpdwLowByteSeeked, LPDWORD lpdwHighByteSeeked, LPVOID *lpContext)
     * }
     */
    public static int BackupSeek(MemorySegment hFile, int dwLowBytesToSeek, int dwHighBytesToSeek, MemorySegment lpdwLowByteSeeked, MemorySegment lpdwHighByteSeeked, MemorySegment lpContext) {
        var mh$ = BackupSeek.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("BackupSeek", hFile, dwLowBytesToSeek, dwHighBytesToSeek, lpdwLowByteSeeked, lpdwHighByteSeeked, lpContext);
            }
            return (int)mh$.invokeExact(hFile, dwLowBytesToSeek, dwHighBytesToSeek, lpdwLowByteSeeked, lpdwHighByteSeeked, lpContext);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class BackupWrite {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_LONG,
            C_POINTER,
            C_INT,
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("BackupWrite"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL BackupWrite(HANDLE hFile, LPBYTE lpBuffer, DWORD nNumberOfBytesToWrite, LPDWORD lpNumberOfBytesWritten, BOOL bAbort, BOOL bProcessSecurity, LPVOID *lpContext)
     * }
     */
    public static FunctionDescriptor BackupWrite$descriptor() {
        return BackupWrite.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL BackupWrite(HANDLE hFile, LPBYTE lpBuffer, DWORD nNumberOfBytesToWrite, LPDWORD lpNumberOfBytesWritten, BOOL bAbort, BOOL bProcessSecurity, LPVOID *lpContext)
     * }
     */
    public static MethodHandle BackupWrite$handle() {
        return BackupWrite.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL BackupWrite(HANDLE hFile, LPBYTE lpBuffer, DWORD nNumberOfBytesToWrite, LPDWORD lpNumberOfBytesWritten, BOOL bAbort, BOOL bProcessSecurity, LPVOID *lpContext)
     * }
     */
    public static int BackupWrite(MemorySegment hFile, MemorySegment lpBuffer, int nNumberOfBytesToWrite, MemorySegment lpNumberOfBytesWritten, int bAbort, int bProcessSecurity, MemorySegment lpContext) {
        var mh$ = BackupWrite.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("BackupWrite", hFile, lpBuffer, nNumberOfBytesToWrite, lpNumberOfBytesWritten, bAbort, bProcessSecurity, lpContext);
            }
            return (int)mh$.invokeExact(hFile, lpBuffer, nNumberOfBytesToWrite, lpNumberOfBytesWritten, bAbort, bProcessSecurity, lpContext);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct _WIN32_STREAM_ID {
     *     DWORD dwStreamId;
     *     DWORD dwStreamAttributes;
     *     LARGE_INTEGER Size;
     *     DWORD dwStreamNameSize;
     *     WCHAR cStreamName[1];
     * } *LPWIN32_STREAM_ID
     * }
     */
    public static final AddressLayout LPWIN32_STREAM_ID = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _STARTUPINFOEXA {
     *     STARTUPINFOA StartupInfo;
     *     LPPROC_THREAD_ATTRIBUTE_LIST lpAttributeList;
     * } *LPSTARTUPINFOEXA
     * }
     */
    public static final AddressLayout LPSTARTUPINFOEXA = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _STARTUPINFOEXW {
     *     STARTUPINFOW StartupInfo;
     *     LPPROC_THREAD_ATTRIBUTE_LIST lpAttributeList;
     * } *LPSTARTUPINFOEXW
     * }
     */
    public static final AddressLayout LPSTARTUPINFOEXW = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef LPSTARTUPINFOEXA LPSTARTUPINFOEX
     * }
     */
    public static final AddressLayout LPSTARTUPINFOEX = C_POINTER;

    private static class OpenMutexA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_LONG,
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("OpenMutexA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HANDLE OpenMutexA(DWORD dwDesiredAccess, BOOL bInheritHandle, LPCSTR lpName)
     * }
     */
    public static FunctionDescriptor OpenMutexA$descriptor() {
        return OpenMutexA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HANDLE OpenMutexA(DWORD dwDesiredAccess, BOOL bInheritHandle, LPCSTR lpName)
     * }
     */
    public static MethodHandle OpenMutexA$handle() {
        return OpenMutexA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * HANDLE OpenMutexA(DWORD dwDesiredAccess, BOOL bInheritHandle, LPCSTR lpName)
     * }
     */
    public static MemorySegment OpenMutexA(int dwDesiredAccess, int bInheritHandle, MemorySegment lpName) {
        var mh$ = OpenMutexA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("OpenMutexA", dwDesiredAccess, bInheritHandle, lpName);
            }
            return (MemorySegment)mh$.invokeExact(dwDesiredAccess, bInheritHandle, lpName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateSemaphoreA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER,
            C_LONG,
            C_LONG,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CreateSemaphoreA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HANDLE CreateSemaphoreA(LPSECURITY_ATTRIBUTES lpSemaphoreAttributes, LONG lInitialCount, LONG lMaximumCount, LPCSTR lpName)
     * }
     */
    public static FunctionDescriptor CreateSemaphoreA$descriptor() {
        return CreateSemaphoreA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HANDLE CreateSemaphoreA(LPSECURITY_ATTRIBUTES lpSemaphoreAttributes, LONG lInitialCount, LONG lMaximumCount, LPCSTR lpName)
     * }
     */
    public static MethodHandle CreateSemaphoreA$handle() {
        return CreateSemaphoreA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * HANDLE CreateSemaphoreA(LPSECURITY_ATTRIBUTES lpSemaphoreAttributes, LONG lInitialCount, LONG lMaximumCount, LPCSTR lpName)
     * }
     */
    public static MemorySegment CreateSemaphoreA(MemorySegment lpSemaphoreAttributes, int lInitialCount, int lMaximumCount, MemorySegment lpName) {
        var mh$ = CreateSemaphoreA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateSemaphoreA", lpSemaphoreAttributes, lInitialCount, lMaximumCount, lpName);
            }
            return (MemorySegment)mh$.invokeExact(lpSemaphoreAttributes, lInitialCount, lMaximumCount, lpName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class OpenSemaphoreA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_LONG,
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("OpenSemaphoreA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HANDLE OpenSemaphoreA(DWORD dwDesiredAccess, BOOL bInheritHandle, LPCSTR lpName)
     * }
     */
    public static FunctionDescriptor OpenSemaphoreA$descriptor() {
        return OpenSemaphoreA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HANDLE OpenSemaphoreA(DWORD dwDesiredAccess, BOOL bInheritHandle, LPCSTR lpName)
     * }
     */
    public static MethodHandle OpenSemaphoreA$handle() {
        return OpenSemaphoreA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * HANDLE OpenSemaphoreA(DWORD dwDesiredAccess, BOOL bInheritHandle, LPCSTR lpName)
     * }
     */
    public static MemorySegment OpenSemaphoreA(int dwDesiredAccess, int bInheritHandle, MemorySegment lpName) {
        var mh$ = OpenSemaphoreA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("OpenSemaphoreA", dwDesiredAccess, bInheritHandle, lpName);
            }
            return (MemorySegment)mh$.invokeExact(dwDesiredAccess, bInheritHandle, lpName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateWaitableTimerA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER,
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CreateWaitableTimerA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HANDLE CreateWaitableTimerA(LPSECURITY_ATTRIBUTES lpTimerAttributes, BOOL bManualReset, LPCSTR lpTimerName)
     * }
     */
    public static FunctionDescriptor CreateWaitableTimerA$descriptor() {
        return CreateWaitableTimerA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HANDLE CreateWaitableTimerA(LPSECURITY_ATTRIBUTES lpTimerAttributes, BOOL bManualReset, LPCSTR lpTimerName)
     * }
     */
    public static MethodHandle CreateWaitableTimerA$handle() {
        return CreateWaitableTimerA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * HANDLE CreateWaitableTimerA(LPSECURITY_ATTRIBUTES lpTimerAttributes, BOOL bManualReset, LPCSTR lpTimerName)
     * }
     */
    public static MemorySegment CreateWaitableTimerA(MemorySegment lpTimerAttributes, int bManualReset, MemorySegment lpTimerName) {
        var mh$ = CreateWaitableTimerA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateWaitableTimerA", lpTimerAttributes, bManualReset, lpTimerName);
            }
            return (MemorySegment)mh$.invokeExact(lpTimerAttributes, bManualReset, lpTimerName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class OpenWaitableTimerA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_LONG,
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("OpenWaitableTimerA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HANDLE OpenWaitableTimerA(DWORD dwDesiredAccess, BOOL bInheritHandle, LPCSTR lpTimerName)
     * }
     */
    public static FunctionDescriptor OpenWaitableTimerA$descriptor() {
        return OpenWaitableTimerA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HANDLE OpenWaitableTimerA(DWORD dwDesiredAccess, BOOL bInheritHandle, LPCSTR lpTimerName)
     * }
     */
    public static MethodHandle OpenWaitableTimerA$handle() {
        return OpenWaitableTimerA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * HANDLE OpenWaitableTimerA(DWORD dwDesiredAccess, BOOL bInheritHandle, LPCSTR lpTimerName)
     * }
     */
    public static MemorySegment OpenWaitableTimerA(int dwDesiredAccess, int bInheritHandle, MemorySegment lpTimerName) {
        var mh$ = OpenWaitableTimerA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("OpenWaitableTimerA", dwDesiredAccess, bInheritHandle, lpTimerName);
            }
            return (MemorySegment)mh$.invokeExact(dwDesiredAccess, bInheritHandle, lpTimerName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateSemaphoreExA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER,
            C_LONG,
            C_LONG,
            C_POINTER,
            C_LONG,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CreateSemaphoreExA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HANDLE CreateSemaphoreExA(LPSECURITY_ATTRIBUTES lpSemaphoreAttributes, LONG lInitialCount, LONG lMaximumCount, LPCSTR lpName, DWORD dwFlags, DWORD dwDesiredAccess)
     * }
     */
    public static FunctionDescriptor CreateSemaphoreExA$descriptor() {
        return CreateSemaphoreExA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HANDLE CreateSemaphoreExA(LPSECURITY_ATTRIBUTES lpSemaphoreAttributes, LONG lInitialCount, LONG lMaximumCount, LPCSTR lpName, DWORD dwFlags, DWORD dwDesiredAccess)
     * }
     */
    public static MethodHandle CreateSemaphoreExA$handle() {
        return CreateSemaphoreExA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * HANDLE CreateSemaphoreExA(LPSECURITY_ATTRIBUTES lpSemaphoreAttributes, LONG lInitialCount, LONG lMaximumCount, LPCSTR lpName, DWORD dwFlags, DWORD dwDesiredAccess)
     * }
     */
    public static MemorySegment CreateSemaphoreExA(MemorySegment lpSemaphoreAttributes, int lInitialCount, int lMaximumCount, MemorySegment lpName, int dwFlags, int dwDesiredAccess) {
        var mh$ = CreateSemaphoreExA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateSemaphoreExA", lpSemaphoreAttributes, lInitialCount, lMaximumCount, lpName, dwFlags, dwDesiredAccess);
            }
            return (MemorySegment)mh$.invokeExact(lpSemaphoreAttributes, lInitialCount, lMaximumCount, lpName, dwFlags, dwDesiredAccess);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateWaitableTimerExA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_LONG,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CreateWaitableTimerExA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HANDLE CreateWaitableTimerExA(LPSECURITY_ATTRIBUTES lpTimerAttributes, LPCSTR lpTimerName, DWORD dwFlags, DWORD dwDesiredAccess)
     * }
     */
    public static FunctionDescriptor CreateWaitableTimerExA$descriptor() {
        return CreateWaitableTimerExA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HANDLE CreateWaitableTimerExA(LPSECURITY_ATTRIBUTES lpTimerAttributes, LPCSTR lpTimerName, DWORD dwFlags, DWORD dwDesiredAccess)
     * }
     */
    public static MethodHandle CreateWaitableTimerExA$handle() {
        return CreateWaitableTimerExA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * HANDLE CreateWaitableTimerExA(LPSECURITY_ATTRIBUTES lpTimerAttributes, LPCSTR lpTimerName, DWORD dwFlags, DWORD dwDesiredAccess)
     * }
     */
    public static MemorySegment CreateWaitableTimerExA(MemorySegment lpTimerAttributes, MemorySegment lpTimerName, int dwFlags, int dwDesiredAccess) {
        var mh$ = CreateWaitableTimerExA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateWaitableTimerExA", lpTimerAttributes, lpTimerName, dwFlags, dwDesiredAccess);
            }
            return (MemorySegment)mh$.invokeExact(lpTimerAttributes, lpTimerName, dwFlags, dwDesiredAccess);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateFileMappingA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_LONG,
            C_LONG,
            C_LONG,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CreateFileMappingA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HANDLE CreateFileMappingA(HANDLE hFile, LPSECURITY_ATTRIBUTES lpFileMappingAttributes, DWORD flProtect, DWORD dwMaximumSizeHigh, DWORD dwMaximumSizeLow, LPCSTR lpName)
     * }
     */
    public static FunctionDescriptor CreateFileMappingA$descriptor() {
        return CreateFileMappingA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HANDLE CreateFileMappingA(HANDLE hFile, LPSECURITY_ATTRIBUTES lpFileMappingAttributes, DWORD flProtect, DWORD dwMaximumSizeHigh, DWORD dwMaximumSizeLow, LPCSTR lpName)
     * }
     */
    public static MethodHandle CreateFileMappingA$handle() {
        return CreateFileMappingA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * HANDLE CreateFileMappingA(HANDLE hFile, LPSECURITY_ATTRIBUTES lpFileMappingAttributes, DWORD flProtect, DWORD dwMaximumSizeHigh, DWORD dwMaximumSizeLow, LPCSTR lpName)
     * }
     */
    public static MemorySegment CreateFileMappingA(MemorySegment hFile, MemorySegment lpFileMappingAttributes, int flProtect, int dwMaximumSizeHigh, int dwMaximumSizeLow, MemorySegment lpName) {
        var mh$ = CreateFileMappingA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateFileMappingA", hFile, lpFileMappingAttributes, flProtect, dwMaximumSizeHigh, dwMaximumSizeLow, lpName);
            }
            return (MemorySegment)mh$.invokeExact(hFile, lpFileMappingAttributes, flProtect, dwMaximumSizeHigh, dwMaximumSizeLow, lpName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateFileMappingNumaA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_LONG,
            C_LONG,
            C_LONG,
            C_POINTER,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CreateFileMappingNumaA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HANDLE CreateFileMappingNumaA(HANDLE hFile, LPSECURITY_ATTRIBUTES lpFileMappingAttributes, DWORD flProtect, DWORD dwMaximumSizeHigh, DWORD dwMaximumSizeLow, LPCSTR lpName, DWORD nndPreferred)
     * }
     */
    public static FunctionDescriptor CreateFileMappingNumaA$descriptor() {
        return CreateFileMappingNumaA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HANDLE CreateFileMappingNumaA(HANDLE hFile, LPSECURITY_ATTRIBUTES lpFileMappingAttributes, DWORD flProtect, DWORD dwMaximumSizeHigh, DWORD dwMaximumSizeLow, LPCSTR lpName, DWORD nndPreferred)
     * }
     */
    public static MethodHandle CreateFileMappingNumaA$handle() {
        return CreateFileMappingNumaA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * HANDLE CreateFileMappingNumaA(HANDLE hFile, LPSECURITY_ATTRIBUTES lpFileMappingAttributes, DWORD flProtect, DWORD dwMaximumSizeHigh, DWORD dwMaximumSizeLow, LPCSTR lpName, DWORD nndPreferred)
     * }
     */
    public static MemorySegment CreateFileMappingNumaA(MemorySegment hFile, MemorySegment lpFileMappingAttributes, int flProtect, int dwMaximumSizeHigh, int dwMaximumSizeLow, MemorySegment lpName, int nndPreferred) {
        var mh$ = CreateFileMappingNumaA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateFileMappingNumaA", hFile, lpFileMappingAttributes, flProtect, dwMaximumSizeHigh, dwMaximumSizeLow, lpName, nndPreferred);
            }
            return (MemorySegment)mh$.invokeExact(hFile, lpFileMappingAttributes, flProtect, dwMaximumSizeHigh, dwMaximumSizeLow, lpName, nndPreferred);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class OpenFileMappingA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_LONG,
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("OpenFileMappingA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HANDLE OpenFileMappingA(DWORD dwDesiredAccess, BOOL bInheritHandle, LPCSTR lpName)
     * }
     */
    public static FunctionDescriptor OpenFileMappingA$descriptor() {
        return OpenFileMappingA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HANDLE OpenFileMappingA(DWORD dwDesiredAccess, BOOL bInheritHandle, LPCSTR lpName)
     * }
     */
    public static MethodHandle OpenFileMappingA$handle() {
        return OpenFileMappingA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * HANDLE OpenFileMappingA(DWORD dwDesiredAccess, BOOL bInheritHandle, LPCSTR lpName)
     * }
     */
    public static MemorySegment OpenFileMappingA(int dwDesiredAccess, int bInheritHandle, MemorySegment lpName) {
        var mh$ = OpenFileMappingA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("OpenFileMappingA", dwDesiredAccess, bInheritHandle, lpName);
            }
            return (MemorySegment)mh$.invokeExact(dwDesiredAccess, bInheritHandle, lpName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetLogicalDriveStringsA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_LONG,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetLogicalDriveStringsA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetLogicalDriveStringsA(DWORD nBufferLength, LPSTR lpBuffer)
     * }
     */
    public static FunctionDescriptor GetLogicalDriveStringsA$descriptor() {
        return GetLogicalDriveStringsA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetLogicalDriveStringsA(DWORD nBufferLength, LPSTR lpBuffer)
     * }
     */
    public static MethodHandle GetLogicalDriveStringsA$handle() {
        return GetLogicalDriveStringsA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * DWORD GetLogicalDriveStringsA(DWORD nBufferLength, LPSTR lpBuffer)
     * }
     */
    public static int GetLogicalDriveStringsA(int nBufferLength, MemorySegment lpBuffer) {
        var mh$ = GetLogicalDriveStringsA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetLogicalDriveStringsA", nBufferLength, lpBuffer);
            }
            return (int)mh$.invokeExact(nBufferLength, lpBuffer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LoadPackagedLibrary {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("LoadPackagedLibrary"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HMODULE LoadPackagedLibrary(LPCWSTR lpwLibFileName, DWORD Reserved)
     * }
     */
    public static FunctionDescriptor LoadPackagedLibrary$descriptor() {
        return LoadPackagedLibrary.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HMODULE LoadPackagedLibrary(LPCWSTR lpwLibFileName, DWORD Reserved)
     * }
     */
    public static MethodHandle LoadPackagedLibrary$handle() {
        return LoadPackagedLibrary.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * HMODULE LoadPackagedLibrary(LPCWSTR lpwLibFileName, DWORD Reserved)
     * }
     */
    public static MemorySegment LoadPackagedLibrary(MemorySegment lpwLibFileName, int Reserved) {
        var mh$ = LoadPackagedLibrary.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LoadPackagedLibrary", lpwLibFileName, Reserved);
            }
            return (MemorySegment)mh$.invokeExact(lpwLibFileName, Reserved);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class QueryFullProcessImageNameA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_LONG,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("QueryFullProcessImageNameA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL QueryFullProcessImageNameA(HANDLE hProcess, DWORD dwFlags, LPSTR lpExeName, PDWORD lpdwSize)
     * }
     */
    public static FunctionDescriptor QueryFullProcessImageNameA$descriptor() {
        return QueryFullProcessImageNameA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL QueryFullProcessImageNameA(HANDLE hProcess, DWORD dwFlags, LPSTR lpExeName, PDWORD lpdwSize)
     * }
     */
    public static MethodHandle QueryFullProcessImageNameA$handle() {
        return QueryFullProcessImageNameA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL QueryFullProcessImageNameA(HANDLE hProcess, DWORD dwFlags, LPSTR lpExeName, PDWORD lpdwSize)
     * }
     */
    public static int QueryFullProcessImageNameA(MemorySegment hProcess, int dwFlags, MemorySegment lpExeName, MemorySegment lpdwSize) {
        var mh$ = QueryFullProcessImageNameA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("QueryFullProcessImageNameA", hProcess, dwFlags, lpExeName, lpdwSize);
            }
            return (int)mh$.invokeExact(hProcess, dwFlags, lpExeName, lpdwSize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class QueryFullProcessImageNameW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_LONG,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("QueryFullProcessImageNameW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL QueryFullProcessImageNameW(HANDLE hProcess, DWORD dwFlags, LPWSTR lpExeName, PDWORD lpdwSize)
     * }
     */
    public static FunctionDescriptor QueryFullProcessImageNameW$descriptor() {
        return QueryFullProcessImageNameW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL QueryFullProcessImageNameW(HANDLE hProcess, DWORD dwFlags, LPWSTR lpExeName, PDWORD lpdwSize)
     * }
     */
    public static MethodHandle QueryFullProcessImageNameW$handle() {
        return QueryFullProcessImageNameW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL QueryFullProcessImageNameW(HANDLE hProcess, DWORD dwFlags, LPWSTR lpExeName, PDWORD lpdwSize)
     * }
     */
    public static int QueryFullProcessImageNameW(MemorySegment hProcess, int dwFlags, MemorySegment lpExeName, MemorySegment lpdwSize) {
        var mh$ = QueryFullProcessImageNameW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("QueryFullProcessImageNameW", hProcess, dwFlags, lpExeName, lpdwSize);
            }
            return (int)mh$.invokeExact(hProcess, dwFlags, lpExeName, lpdwSize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int ProcThreadAttributeParentProcess = (int)0L;
    /**
     * {@snippet lang=c :
     * enum _PROC_THREAD_ATTRIBUTE_NUM.ProcThreadAttributeParentProcess = 0
     * }
     */
    public static int ProcThreadAttributeParentProcess() {
        return ProcThreadAttributeParentProcess;
    }
    private static final int ProcThreadAttributeHandleList = (int)2L;
    /**
     * {@snippet lang=c :
     * enum _PROC_THREAD_ATTRIBUTE_NUM.ProcThreadAttributeHandleList = 2
     * }
     */
    public static int ProcThreadAttributeHandleList() {
        return ProcThreadAttributeHandleList;
    }
    private static final int ProcThreadAttributeGroupAffinity = (int)3L;
    /**
     * {@snippet lang=c :
     * enum _PROC_THREAD_ATTRIBUTE_NUM.ProcThreadAttributeGroupAffinity = 3
     * }
     */
    public static int ProcThreadAttributeGroupAffinity() {
        return ProcThreadAttributeGroupAffinity;
    }
    private static final int ProcThreadAttributePreferredNode = (int)4L;
    /**
     * {@snippet lang=c :
     * enum _PROC_THREAD_ATTRIBUTE_NUM.ProcThreadAttributePreferredNode = 4
     * }
     */
    public static int ProcThreadAttributePreferredNode() {
        return ProcThreadAttributePreferredNode;
    }
    private static final int ProcThreadAttributeIdealProcessor = (int)5L;
    /**
     * {@snippet lang=c :
     * enum _PROC_THREAD_ATTRIBUTE_NUM.ProcThreadAttributeIdealProcessor = 5
     * }
     */
    public static int ProcThreadAttributeIdealProcessor() {
        return ProcThreadAttributeIdealProcessor;
    }
    private static final int ProcThreadAttributeUmsThread = (int)6L;
    /**
     * {@snippet lang=c :
     * enum _PROC_THREAD_ATTRIBUTE_NUM.ProcThreadAttributeUmsThread = 6
     * }
     */
    public static int ProcThreadAttributeUmsThread() {
        return ProcThreadAttributeUmsThread;
    }
    private static final int ProcThreadAttributeMitigationPolicy = (int)7L;
    /**
     * {@snippet lang=c :
     * enum _PROC_THREAD_ATTRIBUTE_NUM.ProcThreadAttributeMitigationPolicy = 7
     * }
     */
    public static int ProcThreadAttributeMitigationPolicy() {
        return ProcThreadAttributeMitigationPolicy;
    }
    private static final int ProcThreadAttributeSecurityCapabilities = (int)9L;
    /**
     * {@snippet lang=c :
     * enum _PROC_THREAD_ATTRIBUTE_NUM.ProcThreadAttributeSecurityCapabilities = 9
     * }
     */
    public static int ProcThreadAttributeSecurityCapabilities() {
        return ProcThreadAttributeSecurityCapabilities;
    }
    private static final int ProcThreadAttributeProtectionLevel = (int)11L;
    /**
     * {@snippet lang=c :
     * enum _PROC_THREAD_ATTRIBUTE_NUM.ProcThreadAttributeProtectionLevel = 11
     * }
     */
    public static int ProcThreadAttributeProtectionLevel() {
        return ProcThreadAttributeProtectionLevel;
    }
    private static final int ProcThreadAttributeJobList = (int)13L;
    /**
     * {@snippet lang=c :
     * enum _PROC_THREAD_ATTRIBUTE_NUM.ProcThreadAttributeJobList = 13
     * }
     */
    public static int ProcThreadAttributeJobList() {
        return ProcThreadAttributeJobList;
    }
    private static final int ProcThreadAttributeChildProcessPolicy = (int)14L;
    /**
     * {@snippet lang=c :
     * enum _PROC_THREAD_ATTRIBUTE_NUM.ProcThreadAttributeChildProcessPolicy = 14
     * }
     */
    public static int ProcThreadAttributeChildProcessPolicy() {
        return ProcThreadAttributeChildProcessPolicy;
    }
    private static final int ProcThreadAttributeAllApplicationPackagesPolicy = (int)15L;
    /**
     * {@snippet lang=c :
     * enum _PROC_THREAD_ATTRIBUTE_NUM.ProcThreadAttributeAllApplicationPackagesPolicy = 15
     * }
     */
    public static int ProcThreadAttributeAllApplicationPackagesPolicy() {
        return ProcThreadAttributeAllApplicationPackagesPolicy;
    }
    private static final int ProcThreadAttributeWin32kFilter = (int)16L;
    /**
     * {@snippet lang=c :
     * enum _PROC_THREAD_ATTRIBUTE_NUM.ProcThreadAttributeWin32kFilter = 16
     * }
     */
    public static int ProcThreadAttributeWin32kFilter() {
        return ProcThreadAttributeWin32kFilter;
    }
    private static final int ProcThreadAttributeSafeOpenPromptOriginClaim = (int)17L;
    /**
     * {@snippet lang=c :
     * enum _PROC_THREAD_ATTRIBUTE_NUM.ProcThreadAttributeSafeOpenPromptOriginClaim = 17
     * }
     */
    public static int ProcThreadAttributeSafeOpenPromptOriginClaim() {
        return ProcThreadAttributeSafeOpenPromptOriginClaim;
    }
    private static final int ProcThreadAttributeDesktopAppPolicy = (int)18L;
    /**
     * {@snippet lang=c :
     * enum _PROC_THREAD_ATTRIBUTE_NUM.ProcThreadAttributeDesktopAppPolicy = 18
     * }
     */
    public static int ProcThreadAttributeDesktopAppPolicy() {
        return ProcThreadAttributeDesktopAppPolicy;
    }
    private static final int ProcThreadAttributePseudoConsole = (int)22L;
    /**
     * {@snippet lang=c :
     * enum _PROC_THREAD_ATTRIBUTE_NUM.ProcThreadAttributePseudoConsole = 22
     * }
     */
    public static int ProcThreadAttributePseudoConsole() {
        return ProcThreadAttributePseudoConsole;
    }
    private static final int ProcThreadAttributeMitigationAuditPolicy = (int)24L;
    /**
     * {@snippet lang=c :
     * enum _PROC_THREAD_ATTRIBUTE_NUM.ProcThreadAttributeMitigationAuditPolicy = 24
     * }
     */
    public static int ProcThreadAttributeMitigationAuditPolicy() {
        return ProcThreadAttributeMitigationAuditPolicy;
    }
    private static final int ProcThreadAttributeMachineType = (int)25L;
    /**
     * {@snippet lang=c :
     * enum _PROC_THREAD_ATTRIBUTE_NUM.ProcThreadAttributeMachineType = 25
     * }
     */
    public static int ProcThreadAttributeMachineType() {
        return ProcThreadAttributeMachineType;
    }
    private static final int ProcThreadAttributeComponentFilter = (int)26L;
    /**
     * {@snippet lang=c :
     * enum _PROC_THREAD_ATTRIBUTE_NUM.ProcThreadAttributeComponentFilter = 26
     * }
     */
    public static int ProcThreadAttributeComponentFilter() {
        return ProcThreadAttributeComponentFilter;
    }
    private static final int ProcThreadAttributeEnableOptionalXStateFeatures = (int)27L;
    /**
     * {@snippet lang=c :
     * enum _PROC_THREAD_ATTRIBUTE_NUM.ProcThreadAttributeEnableOptionalXStateFeatures = 27
     * }
     */
    public static int ProcThreadAttributeEnableOptionalXStateFeatures() {
        return ProcThreadAttributeEnableOptionalXStateFeatures;
    }

    private static class GetStartupInfoA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetStartupInfoA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void GetStartupInfoA(LPSTARTUPINFOA lpStartupInfo)
     * }
     */
    public static FunctionDescriptor GetStartupInfoA$descriptor() {
        return GetStartupInfoA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void GetStartupInfoA(LPSTARTUPINFOA lpStartupInfo)
     * }
     */
    public static MethodHandle GetStartupInfoA$handle() {
        return GetStartupInfoA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * void GetStartupInfoA(LPSTARTUPINFOA lpStartupInfo)
     * }
     */
    public static void GetStartupInfoA(MemorySegment lpStartupInfo) {
        var mh$ = GetStartupInfoA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetStartupInfoA", lpStartupInfo);
            }
            mh$.invokeExact(lpStartupInfo);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetFirmwareEnvironmentVariableA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetFirmwareEnvironmentVariableA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetFirmwareEnvironmentVariableA(LPCSTR lpName, LPCSTR lpGuid, PVOID pBuffer, DWORD nSize)
     * }
     */
    public static FunctionDescriptor GetFirmwareEnvironmentVariableA$descriptor() {
        return GetFirmwareEnvironmentVariableA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetFirmwareEnvironmentVariableA(LPCSTR lpName, LPCSTR lpGuid, PVOID pBuffer, DWORD nSize)
     * }
     */
    public static MethodHandle GetFirmwareEnvironmentVariableA$handle() {
        return GetFirmwareEnvironmentVariableA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * DWORD GetFirmwareEnvironmentVariableA(LPCSTR lpName, LPCSTR lpGuid, PVOID pBuffer, DWORD nSize)
     * }
     */
    public static int GetFirmwareEnvironmentVariableA(MemorySegment lpName, MemorySegment lpGuid, MemorySegment pBuffer, int nSize) {
        var mh$ = GetFirmwareEnvironmentVariableA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetFirmwareEnvironmentVariableA", lpName, lpGuid, pBuffer, nSize);
            }
            return (int)mh$.invokeExact(lpName, lpGuid, pBuffer, nSize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetFirmwareEnvironmentVariableW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetFirmwareEnvironmentVariableW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetFirmwareEnvironmentVariableW(LPCWSTR lpName, LPCWSTR lpGuid, PVOID pBuffer, DWORD nSize)
     * }
     */
    public static FunctionDescriptor GetFirmwareEnvironmentVariableW$descriptor() {
        return GetFirmwareEnvironmentVariableW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetFirmwareEnvironmentVariableW(LPCWSTR lpName, LPCWSTR lpGuid, PVOID pBuffer, DWORD nSize)
     * }
     */
    public static MethodHandle GetFirmwareEnvironmentVariableW$handle() {
        return GetFirmwareEnvironmentVariableW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * DWORD GetFirmwareEnvironmentVariableW(LPCWSTR lpName, LPCWSTR lpGuid, PVOID pBuffer, DWORD nSize)
     * }
     */
    public static int GetFirmwareEnvironmentVariableW(MemorySegment lpName, MemorySegment lpGuid, MemorySegment pBuffer, int nSize) {
        var mh$ = GetFirmwareEnvironmentVariableW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetFirmwareEnvironmentVariableW", lpName, lpGuid, pBuffer, nSize);
            }
            return (int)mh$.invokeExact(lpName, lpGuid, pBuffer, nSize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetFirmwareEnvironmentVariableExA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_LONG,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetFirmwareEnvironmentVariableExA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetFirmwareEnvironmentVariableExA(LPCSTR lpName, LPCSTR lpGuid, PVOID pBuffer, DWORD nSize, PDWORD pdwAttribubutes)
     * }
     */
    public static FunctionDescriptor GetFirmwareEnvironmentVariableExA$descriptor() {
        return GetFirmwareEnvironmentVariableExA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetFirmwareEnvironmentVariableExA(LPCSTR lpName, LPCSTR lpGuid, PVOID pBuffer, DWORD nSize, PDWORD pdwAttribubutes)
     * }
     */
    public static MethodHandle GetFirmwareEnvironmentVariableExA$handle() {
        return GetFirmwareEnvironmentVariableExA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * DWORD GetFirmwareEnvironmentVariableExA(LPCSTR lpName, LPCSTR lpGuid, PVOID pBuffer, DWORD nSize, PDWORD pdwAttribubutes)
     * }
     */
    public static int GetFirmwareEnvironmentVariableExA(MemorySegment lpName, MemorySegment lpGuid, MemorySegment pBuffer, int nSize, MemorySegment pdwAttribubutes) {
        var mh$ = GetFirmwareEnvironmentVariableExA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetFirmwareEnvironmentVariableExA", lpName, lpGuid, pBuffer, nSize, pdwAttribubutes);
            }
            return (int)mh$.invokeExact(lpName, lpGuid, pBuffer, nSize, pdwAttribubutes);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetFirmwareEnvironmentVariableExW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_LONG,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetFirmwareEnvironmentVariableExW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetFirmwareEnvironmentVariableExW(LPCWSTR lpName, LPCWSTR lpGuid, PVOID pBuffer, DWORD nSize, PDWORD pdwAttribubutes)
     * }
     */
    public static FunctionDescriptor GetFirmwareEnvironmentVariableExW$descriptor() {
        return GetFirmwareEnvironmentVariableExW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetFirmwareEnvironmentVariableExW(LPCWSTR lpName, LPCWSTR lpGuid, PVOID pBuffer, DWORD nSize, PDWORD pdwAttribubutes)
     * }
     */
    public static MethodHandle GetFirmwareEnvironmentVariableExW$handle() {
        return GetFirmwareEnvironmentVariableExW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * DWORD GetFirmwareEnvironmentVariableExW(LPCWSTR lpName, LPCWSTR lpGuid, PVOID pBuffer, DWORD nSize, PDWORD pdwAttribubutes)
     * }
     */
    public static int GetFirmwareEnvironmentVariableExW(MemorySegment lpName, MemorySegment lpGuid, MemorySegment pBuffer, int nSize, MemorySegment pdwAttribubutes) {
        var mh$ = GetFirmwareEnvironmentVariableExW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetFirmwareEnvironmentVariableExW", lpName, lpGuid, pBuffer, nSize, pdwAttribubutes);
            }
            return (int)mh$.invokeExact(lpName, lpGuid, pBuffer, nSize, pdwAttribubutes);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetFirmwareEnvironmentVariableA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("SetFirmwareEnvironmentVariableA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetFirmwareEnvironmentVariableA(LPCSTR lpName, LPCSTR lpGuid, PVOID pValue, DWORD nSize)
     * }
     */
    public static FunctionDescriptor SetFirmwareEnvironmentVariableA$descriptor() {
        return SetFirmwareEnvironmentVariableA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetFirmwareEnvironmentVariableA(LPCSTR lpName, LPCSTR lpGuid, PVOID pValue, DWORD nSize)
     * }
     */
    public static MethodHandle SetFirmwareEnvironmentVariableA$handle() {
        return SetFirmwareEnvironmentVariableA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL SetFirmwareEnvironmentVariableA(LPCSTR lpName, LPCSTR lpGuid, PVOID pValue, DWORD nSize)
     * }
     */
    public static int SetFirmwareEnvironmentVariableA(MemorySegment lpName, MemorySegment lpGuid, MemorySegment pValue, int nSize) {
        var mh$ = SetFirmwareEnvironmentVariableA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetFirmwareEnvironmentVariableA", lpName, lpGuid, pValue, nSize);
            }
            return (int)mh$.invokeExact(lpName, lpGuid, pValue, nSize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetFirmwareEnvironmentVariableW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("SetFirmwareEnvironmentVariableW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetFirmwareEnvironmentVariableW(LPCWSTR lpName, LPCWSTR lpGuid, PVOID pValue, DWORD nSize)
     * }
     */
    public static FunctionDescriptor SetFirmwareEnvironmentVariableW$descriptor() {
        return SetFirmwareEnvironmentVariableW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetFirmwareEnvironmentVariableW(LPCWSTR lpName, LPCWSTR lpGuid, PVOID pValue, DWORD nSize)
     * }
     */
    public static MethodHandle SetFirmwareEnvironmentVariableW$handle() {
        return SetFirmwareEnvironmentVariableW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL SetFirmwareEnvironmentVariableW(LPCWSTR lpName, LPCWSTR lpGuid, PVOID pValue, DWORD nSize)
     * }
     */
    public static int SetFirmwareEnvironmentVariableW(MemorySegment lpName, MemorySegment lpGuid, MemorySegment pValue, int nSize) {
        var mh$ = SetFirmwareEnvironmentVariableW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetFirmwareEnvironmentVariableW", lpName, lpGuid, pValue, nSize);
            }
            return (int)mh$.invokeExact(lpName, lpGuid, pValue, nSize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetFirmwareEnvironmentVariableExA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_LONG,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("SetFirmwareEnvironmentVariableExA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetFirmwareEnvironmentVariableExA(LPCSTR lpName, LPCSTR lpGuid, PVOID pValue, DWORD nSize, DWORD dwAttributes)
     * }
     */
    public static FunctionDescriptor SetFirmwareEnvironmentVariableExA$descriptor() {
        return SetFirmwareEnvironmentVariableExA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetFirmwareEnvironmentVariableExA(LPCSTR lpName, LPCSTR lpGuid, PVOID pValue, DWORD nSize, DWORD dwAttributes)
     * }
     */
    public static MethodHandle SetFirmwareEnvironmentVariableExA$handle() {
        return SetFirmwareEnvironmentVariableExA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL SetFirmwareEnvironmentVariableExA(LPCSTR lpName, LPCSTR lpGuid, PVOID pValue, DWORD nSize, DWORD dwAttributes)
     * }
     */
    public static int SetFirmwareEnvironmentVariableExA(MemorySegment lpName, MemorySegment lpGuid, MemorySegment pValue, int nSize, int dwAttributes) {
        var mh$ = SetFirmwareEnvironmentVariableExA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetFirmwareEnvironmentVariableExA", lpName, lpGuid, pValue, nSize, dwAttributes);
            }
            return (int)mh$.invokeExact(lpName, lpGuid, pValue, nSize, dwAttributes);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetFirmwareEnvironmentVariableExW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_LONG,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("SetFirmwareEnvironmentVariableExW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetFirmwareEnvironmentVariableExW(LPCWSTR lpName, LPCWSTR lpGuid, PVOID pValue, DWORD nSize, DWORD dwAttributes)
     * }
     */
    public static FunctionDescriptor SetFirmwareEnvironmentVariableExW$descriptor() {
        return SetFirmwareEnvironmentVariableExW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetFirmwareEnvironmentVariableExW(LPCWSTR lpName, LPCWSTR lpGuid, PVOID pValue, DWORD nSize, DWORD dwAttributes)
     * }
     */
    public static MethodHandle SetFirmwareEnvironmentVariableExW$handle() {
        return SetFirmwareEnvironmentVariableExW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL SetFirmwareEnvironmentVariableExW(LPCWSTR lpName, LPCWSTR lpGuid, PVOID pValue, DWORD nSize, DWORD dwAttributes)
     * }
     */
    public static int SetFirmwareEnvironmentVariableExW(MemorySegment lpName, MemorySegment lpGuid, MemorySegment pValue, int nSize, int dwAttributes) {
        var mh$ = SetFirmwareEnvironmentVariableExW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetFirmwareEnvironmentVariableExW", lpName, lpGuid, pValue, nSize, dwAttributes);
            }
            return (int)mh$.invokeExact(lpName, lpGuid, pValue, nSize, dwAttributes);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetFirmwareType {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetFirmwareType"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetFirmwareType(PFIRMWARE_TYPE FirmwareType)
     * }
     */
    public static FunctionDescriptor GetFirmwareType$descriptor() {
        return GetFirmwareType.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetFirmwareType(PFIRMWARE_TYPE FirmwareType)
     * }
     */
    public static MethodHandle GetFirmwareType$handle() {
        return GetFirmwareType.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL GetFirmwareType(PFIRMWARE_TYPE FirmwareType)
     * }
     */
    public static int GetFirmwareType(MemorySegment FirmwareType) {
        var mh$ = GetFirmwareType.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetFirmwareType", FirmwareType);
            }
            return (int)mh$.invokeExact(FirmwareType);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class IsNativeVhdBoot {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("IsNativeVhdBoot"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL IsNativeVhdBoot(PBOOL NativeVhdBoot)
     * }
     */
    public static FunctionDescriptor IsNativeVhdBoot$descriptor() {
        return IsNativeVhdBoot.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL IsNativeVhdBoot(PBOOL NativeVhdBoot)
     * }
     */
    public static MethodHandle IsNativeVhdBoot$handle() {
        return IsNativeVhdBoot.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL IsNativeVhdBoot(PBOOL NativeVhdBoot)
     * }
     */
    public static int IsNativeVhdBoot(MemorySegment NativeVhdBoot) {
        var mh$ = IsNativeVhdBoot.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("IsNativeVhdBoot", NativeVhdBoot);
            }
            return (int)mh$.invokeExact(NativeVhdBoot);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FindResourceA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("FindResourceA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HRSRC FindResourceA(HMODULE hModule, LPCSTR lpName, LPCSTR lpType)
     * }
     */
    public static FunctionDescriptor FindResourceA$descriptor() {
        return FindResourceA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HRSRC FindResourceA(HMODULE hModule, LPCSTR lpName, LPCSTR lpType)
     * }
     */
    public static MethodHandle FindResourceA$handle() {
        return FindResourceA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * HRSRC FindResourceA(HMODULE hModule, LPCSTR lpName, LPCSTR lpType)
     * }
     */
    public static MemorySegment FindResourceA(MemorySegment hModule, MemorySegment lpName, MemorySegment lpType) {
        var mh$ = FindResourceA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FindResourceA", hModule, lpName, lpType);
            }
            return (MemorySegment)mh$.invokeExact(hModule, lpName, lpType);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FindResourceExA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_SHORT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("FindResourceExA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HRSRC FindResourceExA(HMODULE hModule, LPCSTR lpType, LPCSTR lpName, WORD wLanguage)
     * }
     */
    public static FunctionDescriptor FindResourceExA$descriptor() {
        return FindResourceExA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HRSRC FindResourceExA(HMODULE hModule, LPCSTR lpType, LPCSTR lpName, WORD wLanguage)
     * }
     */
    public static MethodHandle FindResourceExA$handle() {
        return FindResourceExA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * HRSRC FindResourceExA(HMODULE hModule, LPCSTR lpType, LPCSTR lpName, WORD wLanguage)
     * }
     */
    public static MemorySegment FindResourceExA(MemorySegment hModule, MemorySegment lpType, MemorySegment lpName, short wLanguage) {
        var mh$ = FindResourceExA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FindResourceExA", hModule, lpType, lpName, wLanguage);
            }
            return (MemorySegment)mh$.invokeExact(hModule, lpType, lpName, wLanguage);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class EnumResourceTypesA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_LONG_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("EnumResourceTypesA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL EnumResourceTypesA(HMODULE hModule, ENUMRESTYPEPROCA lpEnumFunc, LONG_PTR lParam)
     * }
     */
    public static FunctionDescriptor EnumResourceTypesA$descriptor() {
        return EnumResourceTypesA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL EnumResourceTypesA(HMODULE hModule, ENUMRESTYPEPROCA lpEnumFunc, LONG_PTR lParam)
     * }
     */
    public static MethodHandle EnumResourceTypesA$handle() {
        return EnumResourceTypesA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL EnumResourceTypesA(HMODULE hModule, ENUMRESTYPEPROCA lpEnumFunc, LONG_PTR lParam)
     * }
     */
    public static int EnumResourceTypesA(MemorySegment hModule, MemorySegment lpEnumFunc, long lParam) {
        var mh$ = EnumResourceTypesA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("EnumResourceTypesA", hModule, lpEnumFunc, lParam);
            }
            return (int)mh$.invokeExact(hModule, lpEnumFunc, lParam);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class EnumResourceTypesW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_LONG_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("EnumResourceTypesW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL EnumResourceTypesW(HMODULE hModule, ENUMRESTYPEPROCW lpEnumFunc, LONG_PTR lParam)
     * }
     */
    public static FunctionDescriptor EnumResourceTypesW$descriptor() {
        return EnumResourceTypesW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL EnumResourceTypesW(HMODULE hModule, ENUMRESTYPEPROCW lpEnumFunc, LONG_PTR lParam)
     * }
     */
    public static MethodHandle EnumResourceTypesW$handle() {
        return EnumResourceTypesW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL EnumResourceTypesW(HMODULE hModule, ENUMRESTYPEPROCW lpEnumFunc, LONG_PTR lParam)
     * }
     */
    public static int EnumResourceTypesW(MemorySegment hModule, MemorySegment lpEnumFunc, long lParam) {
        var mh$ = EnumResourceTypesW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("EnumResourceTypesW", hModule, lpEnumFunc, lParam);
            }
            return (int)mh$.invokeExact(hModule, lpEnumFunc, lParam);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class EnumResourceLanguagesA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_LONG_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("EnumResourceLanguagesA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL EnumResourceLanguagesA(HMODULE hModule, LPCSTR lpType, LPCSTR lpName, ENUMRESLANGPROCA lpEnumFunc, LONG_PTR lParam)
     * }
     */
    public static FunctionDescriptor EnumResourceLanguagesA$descriptor() {
        return EnumResourceLanguagesA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL EnumResourceLanguagesA(HMODULE hModule, LPCSTR lpType, LPCSTR lpName, ENUMRESLANGPROCA lpEnumFunc, LONG_PTR lParam)
     * }
     */
    public static MethodHandle EnumResourceLanguagesA$handle() {
        return EnumResourceLanguagesA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL EnumResourceLanguagesA(HMODULE hModule, LPCSTR lpType, LPCSTR lpName, ENUMRESLANGPROCA lpEnumFunc, LONG_PTR lParam)
     * }
     */
    public static int EnumResourceLanguagesA(MemorySegment hModule, MemorySegment lpType, MemorySegment lpName, MemorySegment lpEnumFunc, long lParam) {
        var mh$ = EnumResourceLanguagesA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("EnumResourceLanguagesA", hModule, lpType, lpName, lpEnumFunc, lParam);
            }
            return (int)mh$.invokeExact(hModule, lpType, lpName, lpEnumFunc, lParam);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class EnumResourceLanguagesW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_LONG_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("EnumResourceLanguagesW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL EnumResourceLanguagesW(HMODULE hModule, LPCWSTR lpType, LPCWSTR lpName, ENUMRESLANGPROCW lpEnumFunc, LONG_PTR lParam)
     * }
     */
    public static FunctionDescriptor EnumResourceLanguagesW$descriptor() {
        return EnumResourceLanguagesW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL EnumResourceLanguagesW(HMODULE hModule, LPCWSTR lpType, LPCWSTR lpName, ENUMRESLANGPROCW lpEnumFunc, LONG_PTR lParam)
     * }
     */
    public static MethodHandle EnumResourceLanguagesW$handle() {
        return EnumResourceLanguagesW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL EnumResourceLanguagesW(HMODULE hModule, LPCWSTR lpType, LPCWSTR lpName, ENUMRESLANGPROCW lpEnumFunc, LONG_PTR lParam)
     * }
     */
    public static int EnumResourceLanguagesW(MemorySegment hModule, MemorySegment lpType, MemorySegment lpName, MemorySegment lpEnumFunc, long lParam) {
        var mh$ = EnumResourceLanguagesW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("EnumResourceLanguagesW", hModule, lpType, lpName, lpEnumFunc, lParam);
            }
            return (int)mh$.invokeExact(hModule, lpType, lpName, lpEnumFunc, lParam);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class BeginUpdateResourceA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("BeginUpdateResourceA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HANDLE BeginUpdateResourceA(LPCSTR pFileName, BOOL bDeleteExistingResources)
     * }
     */
    public static FunctionDescriptor BeginUpdateResourceA$descriptor() {
        return BeginUpdateResourceA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HANDLE BeginUpdateResourceA(LPCSTR pFileName, BOOL bDeleteExistingResources)
     * }
     */
    public static MethodHandle BeginUpdateResourceA$handle() {
        return BeginUpdateResourceA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * HANDLE BeginUpdateResourceA(LPCSTR pFileName, BOOL bDeleteExistingResources)
     * }
     */
    public static MemorySegment BeginUpdateResourceA(MemorySegment pFileName, int bDeleteExistingResources) {
        var mh$ = BeginUpdateResourceA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("BeginUpdateResourceA", pFileName, bDeleteExistingResources);
            }
            return (MemorySegment)mh$.invokeExact(pFileName, bDeleteExistingResources);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class BeginUpdateResourceW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("BeginUpdateResourceW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HANDLE BeginUpdateResourceW(LPCWSTR pFileName, BOOL bDeleteExistingResources)
     * }
     */
    public static FunctionDescriptor BeginUpdateResourceW$descriptor() {
        return BeginUpdateResourceW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HANDLE BeginUpdateResourceW(LPCWSTR pFileName, BOOL bDeleteExistingResources)
     * }
     */
    public static MethodHandle BeginUpdateResourceW$handle() {
        return BeginUpdateResourceW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * HANDLE BeginUpdateResourceW(LPCWSTR pFileName, BOOL bDeleteExistingResources)
     * }
     */
    public static MemorySegment BeginUpdateResourceW(MemorySegment pFileName, int bDeleteExistingResources) {
        var mh$ = BeginUpdateResourceW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("BeginUpdateResourceW", pFileName, bDeleteExistingResources);
            }
            return (MemorySegment)mh$.invokeExact(pFileName, bDeleteExistingResources);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class UpdateResourceA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_SHORT,
            C_POINTER,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("UpdateResourceA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL UpdateResourceA(HANDLE hUpdate, LPCSTR lpType, LPCSTR lpName, WORD wLanguage, LPVOID lpData, DWORD cb)
     * }
     */
    public static FunctionDescriptor UpdateResourceA$descriptor() {
        return UpdateResourceA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL UpdateResourceA(HANDLE hUpdate, LPCSTR lpType, LPCSTR lpName, WORD wLanguage, LPVOID lpData, DWORD cb)
     * }
     */
    public static MethodHandle UpdateResourceA$handle() {
        return UpdateResourceA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL UpdateResourceA(HANDLE hUpdate, LPCSTR lpType, LPCSTR lpName, WORD wLanguage, LPVOID lpData, DWORD cb)
     * }
     */
    public static int UpdateResourceA(MemorySegment hUpdate, MemorySegment lpType, MemorySegment lpName, short wLanguage, MemorySegment lpData, int cb) {
        var mh$ = UpdateResourceA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("UpdateResourceA", hUpdate, lpType, lpName, wLanguage, lpData, cb);
            }
            return (int)mh$.invokeExact(hUpdate, lpType, lpName, wLanguage, lpData, cb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class UpdateResourceW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_SHORT,
            C_POINTER,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("UpdateResourceW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL UpdateResourceW(HANDLE hUpdate, LPCWSTR lpType, LPCWSTR lpName, WORD wLanguage, LPVOID lpData, DWORD cb)
     * }
     */
    public static FunctionDescriptor UpdateResourceW$descriptor() {
        return UpdateResourceW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL UpdateResourceW(HANDLE hUpdate, LPCWSTR lpType, LPCWSTR lpName, WORD wLanguage, LPVOID lpData, DWORD cb)
     * }
     */
    public static MethodHandle UpdateResourceW$handle() {
        return UpdateResourceW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL UpdateResourceW(HANDLE hUpdate, LPCWSTR lpType, LPCWSTR lpName, WORD wLanguage, LPVOID lpData, DWORD cb)
     * }
     */
    public static int UpdateResourceW(MemorySegment hUpdate, MemorySegment lpType, MemorySegment lpName, short wLanguage, MemorySegment lpData, int cb) {
        var mh$ = UpdateResourceW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("UpdateResourceW", hUpdate, lpType, lpName, wLanguage, lpData, cb);
            }
            return (int)mh$.invokeExact(hUpdate, lpType, lpName, wLanguage, lpData, cb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class EndUpdateResourceA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("EndUpdateResourceA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL EndUpdateResourceA(HANDLE hUpdate, BOOL fDiscard)
     * }
     */
    public static FunctionDescriptor EndUpdateResourceA$descriptor() {
        return EndUpdateResourceA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL EndUpdateResourceA(HANDLE hUpdate, BOOL fDiscard)
     * }
     */
    public static MethodHandle EndUpdateResourceA$handle() {
        return EndUpdateResourceA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL EndUpdateResourceA(HANDLE hUpdate, BOOL fDiscard)
     * }
     */
    public static int EndUpdateResourceA(MemorySegment hUpdate, int fDiscard) {
        var mh$ = EndUpdateResourceA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("EndUpdateResourceA", hUpdate, fDiscard);
            }
            return (int)mh$.invokeExact(hUpdate, fDiscard);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class EndUpdateResourceW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("EndUpdateResourceW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL EndUpdateResourceW(HANDLE hUpdate, BOOL fDiscard)
     * }
     */
    public static FunctionDescriptor EndUpdateResourceW$descriptor() {
        return EndUpdateResourceW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL EndUpdateResourceW(HANDLE hUpdate, BOOL fDiscard)
     * }
     */
    public static MethodHandle EndUpdateResourceW$handle() {
        return EndUpdateResourceW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL EndUpdateResourceW(HANDLE hUpdate, BOOL fDiscard)
     * }
     */
    public static int EndUpdateResourceW(MemorySegment hUpdate, int fDiscard) {
        var mh$ = EndUpdateResourceW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("EndUpdateResourceW", hUpdate, fDiscard);
            }
            return (int)mh$.invokeExact(hUpdate, fDiscard);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GlobalAddAtomA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_SHORT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GlobalAddAtomA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ATOM GlobalAddAtomA(LPCSTR lpString)
     * }
     */
    public static FunctionDescriptor GlobalAddAtomA$descriptor() {
        return GlobalAddAtomA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ATOM GlobalAddAtomA(LPCSTR lpString)
     * }
     */
    public static MethodHandle GlobalAddAtomA$handle() {
        return GlobalAddAtomA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * ATOM GlobalAddAtomA(LPCSTR lpString)
     * }
     */
    public static short GlobalAddAtomA(MemorySegment lpString) {
        var mh$ = GlobalAddAtomA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GlobalAddAtomA", lpString);
            }
            return (short)mh$.invokeExact(lpString);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GlobalAddAtomW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_SHORT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GlobalAddAtomW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ATOM GlobalAddAtomW(LPCWSTR lpString)
     * }
     */
    public static FunctionDescriptor GlobalAddAtomW$descriptor() {
        return GlobalAddAtomW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ATOM GlobalAddAtomW(LPCWSTR lpString)
     * }
     */
    public static MethodHandle GlobalAddAtomW$handle() {
        return GlobalAddAtomW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * ATOM GlobalAddAtomW(LPCWSTR lpString)
     * }
     */
    public static short GlobalAddAtomW(MemorySegment lpString) {
        var mh$ = GlobalAddAtomW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GlobalAddAtomW", lpString);
            }
            return (short)mh$.invokeExact(lpString);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GlobalAddAtomExA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_SHORT,
            C_POINTER,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GlobalAddAtomExA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ATOM GlobalAddAtomExA(LPCSTR lpString, DWORD Flags)
     * }
     */
    public static FunctionDescriptor GlobalAddAtomExA$descriptor() {
        return GlobalAddAtomExA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ATOM GlobalAddAtomExA(LPCSTR lpString, DWORD Flags)
     * }
     */
    public static MethodHandle GlobalAddAtomExA$handle() {
        return GlobalAddAtomExA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * ATOM GlobalAddAtomExA(LPCSTR lpString, DWORD Flags)
     * }
     */
    public static short GlobalAddAtomExA(MemorySegment lpString, int Flags) {
        var mh$ = GlobalAddAtomExA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GlobalAddAtomExA", lpString, Flags);
            }
            return (short)mh$.invokeExact(lpString, Flags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GlobalAddAtomExW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_SHORT,
            C_POINTER,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GlobalAddAtomExW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ATOM GlobalAddAtomExW(LPCWSTR lpString, DWORD Flags)
     * }
     */
    public static FunctionDescriptor GlobalAddAtomExW$descriptor() {
        return GlobalAddAtomExW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ATOM GlobalAddAtomExW(LPCWSTR lpString, DWORD Flags)
     * }
     */
    public static MethodHandle GlobalAddAtomExW$handle() {
        return GlobalAddAtomExW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * ATOM GlobalAddAtomExW(LPCWSTR lpString, DWORD Flags)
     * }
     */
    public static short GlobalAddAtomExW(MemorySegment lpString, int Flags) {
        var mh$ = GlobalAddAtomExW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GlobalAddAtomExW", lpString, Flags);
            }
            return (short)mh$.invokeExact(lpString, Flags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GlobalFindAtomA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_SHORT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GlobalFindAtomA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ATOM GlobalFindAtomA(LPCSTR lpString)
     * }
     */
    public static FunctionDescriptor GlobalFindAtomA$descriptor() {
        return GlobalFindAtomA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ATOM GlobalFindAtomA(LPCSTR lpString)
     * }
     */
    public static MethodHandle GlobalFindAtomA$handle() {
        return GlobalFindAtomA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * ATOM GlobalFindAtomA(LPCSTR lpString)
     * }
     */
    public static short GlobalFindAtomA(MemorySegment lpString) {
        var mh$ = GlobalFindAtomA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GlobalFindAtomA", lpString);
            }
            return (short)mh$.invokeExact(lpString);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GlobalFindAtomW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_SHORT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GlobalFindAtomW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ATOM GlobalFindAtomW(LPCWSTR lpString)
     * }
     */
    public static FunctionDescriptor GlobalFindAtomW$descriptor() {
        return GlobalFindAtomW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ATOM GlobalFindAtomW(LPCWSTR lpString)
     * }
     */
    public static MethodHandle GlobalFindAtomW$handle() {
        return GlobalFindAtomW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * ATOM GlobalFindAtomW(LPCWSTR lpString)
     * }
     */
    public static short GlobalFindAtomW(MemorySegment lpString) {
        var mh$ = GlobalFindAtomW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GlobalFindAtomW", lpString);
            }
            return (short)mh$.invokeExact(lpString);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GlobalGetAtomNameA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_SHORT,
            C_POINTER,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GlobalGetAtomNameA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * UINT GlobalGetAtomNameA(ATOM nAtom, LPSTR lpBuffer, int nSize)
     * }
     */
    public static FunctionDescriptor GlobalGetAtomNameA$descriptor() {
        return GlobalGetAtomNameA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * UINT GlobalGetAtomNameA(ATOM nAtom, LPSTR lpBuffer, int nSize)
     * }
     */
    public static MethodHandle GlobalGetAtomNameA$handle() {
        return GlobalGetAtomNameA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * UINT GlobalGetAtomNameA(ATOM nAtom, LPSTR lpBuffer, int nSize)
     * }
     */
    public static int GlobalGetAtomNameA(short nAtom, MemorySegment lpBuffer, int nSize) {
        var mh$ = GlobalGetAtomNameA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GlobalGetAtomNameA", nAtom, lpBuffer, nSize);
            }
            return (int)mh$.invokeExact(nAtom, lpBuffer, nSize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GlobalGetAtomNameW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_SHORT,
            C_POINTER,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GlobalGetAtomNameW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * UINT GlobalGetAtomNameW(ATOM nAtom, LPWSTR lpBuffer, int nSize)
     * }
     */
    public static FunctionDescriptor GlobalGetAtomNameW$descriptor() {
        return GlobalGetAtomNameW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * UINT GlobalGetAtomNameW(ATOM nAtom, LPWSTR lpBuffer, int nSize)
     * }
     */
    public static MethodHandle GlobalGetAtomNameW$handle() {
        return GlobalGetAtomNameW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * UINT GlobalGetAtomNameW(ATOM nAtom, LPWSTR lpBuffer, int nSize)
     * }
     */
    public static int GlobalGetAtomNameW(short nAtom, MemorySegment lpBuffer, int nSize) {
        var mh$ = GlobalGetAtomNameW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GlobalGetAtomNameW", nAtom, lpBuffer, nSize);
            }
            return (int)mh$.invokeExact(nAtom, lpBuffer, nSize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class AddAtomA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_SHORT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("AddAtomA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ATOM AddAtomA(LPCSTR lpString)
     * }
     */
    public static FunctionDescriptor AddAtomA$descriptor() {
        return AddAtomA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ATOM AddAtomA(LPCSTR lpString)
     * }
     */
    public static MethodHandle AddAtomA$handle() {
        return AddAtomA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * ATOM AddAtomA(LPCSTR lpString)
     * }
     */
    public static short AddAtomA(MemorySegment lpString) {
        var mh$ = AddAtomA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("AddAtomA", lpString);
            }
            return (short)mh$.invokeExact(lpString);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class AddAtomW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_SHORT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("AddAtomW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ATOM AddAtomW(LPCWSTR lpString)
     * }
     */
    public static FunctionDescriptor AddAtomW$descriptor() {
        return AddAtomW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ATOM AddAtomW(LPCWSTR lpString)
     * }
     */
    public static MethodHandle AddAtomW$handle() {
        return AddAtomW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * ATOM AddAtomW(LPCWSTR lpString)
     * }
     */
    public static short AddAtomW(MemorySegment lpString) {
        var mh$ = AddAtomW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("AddAtomW", lpString);
            }
            return (short)mh$.invokeExact(lpString);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FindAtomA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_SHORT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("FindAtomA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ATOM FindAtomA(LPCSTR lpString)
     * }
     */
    public static FunctionDescriptor FindAtomA$descriptor() {
        return FindAtomA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ATOM FindAtomA(LPCSTR lpString)
     * }
     */
    public static MethodHandle FindAtomA$handle() {
        return FindAtomA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * ATOM FindAtomA(LPCSTR lpString)
     * }
     */
    public static short FindAtomA(MemorySegment lpString) {
        var mh$ = FindAtomA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FindAtomA", lpString);
            }
            return (short)mh$.invokeExact(lpString);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FindAtomW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_SHORT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("FindAtomW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ATOM FindAtomW(LPCWSTR lpString)
     * }
     */
    public static FunctionDescriptor FindAtomW$descriptor() {
        return FindAtomW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ATOM FindAtomW(LPCWSTR lpString)
     * }
     */
    public static MethodHandle FindAtomW$handle() {
        return FindAtomW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * ATOM FindAtomW(LPCWSTR lpString)
     * }
     */
    public static short FindAtomW(MemorySegment lpString) {
        var mh$ = FindAtomW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FindAtomW", lpString);
            }
            return (short)mh$.invokeExact(lpString);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetAtomNameA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_SHORT,
            C_POINTER,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetAtomNameA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * UINT GetAtomNameA(ATOM nAtom, LPSTR lpBuffer, int nSize)
     * }
     */
    public static FunctionDescriptor GetAtomNameA$descriptor() {
        return GetAtomNameA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * UINT GetAtomNameA(ATOM nAtom, LPSTR lpBuffer, int nSize)
     * }
     */
    public static MethodHandle GetAtomNameA$handle() {
        return GetAtomNameA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * UINT GetAtomNameA(ATOM nAtom, LPSTR lpBuffer, int nSize)
     * }
     */
    public static int GetAtomNameA(short nAtom, MemorySegment lpBuffer, int nSize) {
        var mh$ = GetAtomNameA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetAtomNameA", nAtom, lpBuffer, nSize);
            }
            return (int)mh$.invokeExact(nAtom, lpBuffer, nSize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetAtomNameW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_SHORT,
            C_POINTER,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetAtomNameW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * UINT GetAtomNameW(ATOM nAtom, LPWSTR lpBuffer, int nSize)
     * }
     */
    public static FunctionDescriptor GetAtomNameW$descriptor() {
        return GetAtomNameW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * UINT GetAtomNameW(ATOM nAtom, LPWSTR lpBuffer, int nSize)
     * }
     */
    public static MethodHandle GetAtomNameW$handle() {
        return GetAtomNameW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * UINT GetAtomNameW(ATOM nAtom, LPWSTR lpBuffer, int nSize)
     * }
     */
    public static int GetAtomNameW(short nAtom, MemorySegment lpBuffer, int nSize) {
        var mh$ = GetAtomNameW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetAtomNameW", nAtom, lpBuffer, nSize);
            }
            return (int)mh$.invokeExact(nAtom, lpBuffer, nSize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetProfileIntA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetProfileIntA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * UINT GetProfileIntA(LPCSTR lpAppName, LPCSTR lpKeyName, INT nDefault)
     * }
     */
    public static FunctionDescriptor GetProfileIntA$descriptor() {
        return GetProfileIntA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * UINT GetProfileIntA(LPCSTR lpAppName, LPCSTR lpKeyName, INT nDefault)
     * }
     */
    public static MethodHandle GetProfileIntA$handle() {
        return GetProfileIntA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * UINT GetProfileIntA(LPCSTR lpAppName, LPCSTR lpKeyName, INT nDefault)
     * }
     */
    public static int GetProfileIntA(MemorySegment lpAppName, MemorySegment lpKeyName, int nDefault) {
        var mh$ = GetProfileIntA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetProfileIntA", lpAppName, lpKeyName, nDefault);
            }
            return (int)mh$.invokeExact(lpAppName, lpKeyName, nDefault);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetProfileIntW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetProfileIntW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * UINT GetProfileIntW(LPCWSTR lpAppName, LPCWSTR lpKeyName, INT nDefault)
     * }
     */
    public static FunctionDescriptor GetProfileIntW$descriptor() {
        return GetProfileIntW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * UINT GetProfileIntW(LPCWSTR lpAppName, LPCWSTR lpKeyName, INT nDefault)
     * }
     */
    public static MethodHandle GetProfileIntW$handle() {
        return GetProfileIntW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * UINT GetProfileIntW(LPCWSTR lpAppName, LPCWSTR lpKeyName, INT nDefault)
     * }
     */
    public static int GetProfileIntW(MemorySegment lpAppName, MemorySegment lpKeyName, int nDefault) {
        var mh$ = GetProfileIntW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetProfileIntW", lpAppName, lpKeyName, nDefault);
            }
            return (int)mh$.invokeExact(lpAppName, lpKeyName, nDefault);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetProfileStringA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetProfileStringA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetProfileStringA(LPCSTR lpAppName, LPCSTR lpKeyName, LPCSTR lpDefault, LPSTR lpReturnedString, DWORD nSize)
     * }
     */
    public static FunctionDescriptor GetProfileStringA$descriptor() {
        return GetProfileStringA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetProfileStringA(LPCSTR lpAppName, LPCSTR lpKeyName, LPCSTR lpDefault, LPSTR lpReturnedString, DWORD nSize)
     * }
     */
    public static MethodHandle GetProfileStringA$handle() {
        return GetProfileStringA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * DWORD GetProfileStringA(LPCSTR lpAppName, LPCSTR lpKeyName, LPCSTR lpDefault, LPSTR lpReturnedString, DWORD nSize)
     * }
     */
    public static int GetProfileStringA(MemorySegment lpAppName, MemorySegment lpKeyName, MemorySegment lpDefault, MemorySegment lpReturnedString, int nSize) {
        var mh$ = GetProfileStringA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetProfileStringA", lpAppName, lpKeyName, lpDefault, lpReturnedString, nSize);
            }
            return (int)mh$.invokeExact(lpAppName, lpKeyName, lpDefault, lpReturnedString, nSize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetProfileStringW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetProfileStringW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetProfileStringW(LPCWSTR lpAppName, LPCWSTR lpKeyName, LPCWSTR lpDefault, LPWSTR lpReturnedString, DWORD nSize)
     * }
     */
    public static FunctionDescriptor GetProfileStringW$descriptor() {
        return GetProfileStringW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetProfileStringW(LPCWSTR lpAppName, LPCWSTR lpKeyName, LPCWSTR lpDefault, LPWSTR lpReturnedString, DWORD nSize)
     * }
     */
    public static MethodHandle GetProfileStringW$handle() {
        return GetProfileStringW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * DWORD GetProfileStringW(LPCWSTR lpAppName, LPCWSTR lpKeyName, LPCWSTR lpDefault, LPWSTR lpReturnedString, DWORD nSize)
     * }
     */
    public static int GetProfileStringW(MemorySegment lpAppName, MemorySegment lpKeyName, MemorySegment lpDefault, MemorySegment lpReturnedString, int nSize) {
        var mh$ = GetProfileStringW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetProfileStringW", lpAppName, lpKeyName, lpDefault, lpReturnedString, nSize);
            }
            return (int)mh$.invokeExact(lpAppName, lpKeyName, lpDefault, lpReturnedString, nSize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class WriteProfileStringA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("WriteProfileStringA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL WriteProfileStringA(LPCSTR lpAppName, LPCSTR lpKeyName, LPCSTR lpString)
     * }
     */
    public static FunctionDescriptor WriteProfileStringA$descriptor() {
        return WriteProfileStringA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL WriteProfileStringA(LPCSTR lpAppName, LPCSTR lpKeyName, LPCSTR lpString)
     * }
     */
    public static MethodHandle WriteProfileStringA$handle() {
        return WriteProfileStringA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL WriteProfileStringA(LPCSTR lpAppName, LPCSTR lpKeyName, LPCSTR lpString)
     * }
     */
    public static int WriteProfileStringA(MemorySegment lpAppName, MemorySegment lpKeyName, MemorySegment lpString) {
        var mh$ = WriteProfileStringA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WriteProfileStringA", lpAppName, lpKeyName, lpString);
            }
            return (int)mh$.invokeExact(lpAppName, lpKeyName, lpString);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class WriteProfileStringW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("WriteProfileStringW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL WriteProfileStringW(LPCWSTR lpAppName, LPCWSTR lpKeyName, LPCWSTR lpString)
     * }
     */
    public static FunctionDescriptor WriteProfileStringW$descriptor() {
        return WriteProfileStringW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL WriteProfileStringW(LPCWSTR lpAppName, LPCWSTR lpKeyName, LPCWSTR lpString)
     * }
     */
    public static MethodHandle WriteProfileStringW$handle() {
        return WriteProfileStringW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL WriteProfileStringW(LPCWSTR lpAppName, LPCWSTR lpKeyName, LPCWSTR lpString)
     * }
     */
    public static int WriteProfileStringW(MemorySegment lpAppName, MemorySegment lpKeyName, MemorySegment lpString) {
        var mh$ = WriteProfileStringW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WriteProfileStringW", lpAppName, lpKeyName, lpString);
            }
            return (int)mh$.invokeExact(lpAppName, lpKeyName, lpString);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetProfileSectionA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_POINTER,
            C_POINTER,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetProfileSectionA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetProfileSectionA(LPCSTR lpAppName, LPSTR lpReturnedString, DWORD nSize)
     * }
     */
    public static FunctionDescriptor GetProfileSectionA$descriptor() {
        return GetProfileSectionA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetProfileSectionA(LPCSTR lpAppName, LPSTR lpReturnedString, DWORD nSize)
     * }
     */
    public static MethodHandle GetProfileSectionA$handle() {
        return GetProfileSectionA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * DWORD GetProfileSectionA(LPCSTR lpAppName, LPSTR lpReturnedString, DWORD nSize)
     * }
     */
    public static int GetProfileSectionA(MemorySegment lpAppName, MemorySegment lpReturnedString, int nSize) {
        var mh$ = GetProfileSectionA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetProfileSectionA", lpAppName, lpReturnedString, nSize);
            }
            return (int)mh$.invokeExact(lpAppName, lpReturnedString, nSize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetProfileSectionW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_POINTER,
            C_POINTER,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetProfileSectionW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetProfileSectionW(LPCWSTR lpAppName, LPWSTR lpReturnedString, DWORD nSize)
     * }
     */
    public static FunctionDescriptor GetProfileSectionW$descriptor() {
        return GetProfileSectionW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetProfileSectionW(LPCWSTR lpAppName, LPWSTR lpReturnedString, DWORD nSize)
     * }
     */
    public static MethodHandle GetProfileSectionW$handle() {
        return GetProfileSectionW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * DWORD GetProfileSectionW(LPCWSTR lpAppName, LPWSTR lpReturnedString, DWORD nSize)
     * }
     */
    public static int GetProfileSectionW(MemorySegment lpAppName, MemorySegment lpReturnedString, int nSize) {
        var mh$ = GetProfileSectionW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetProfileSectionW", lpAppName, lpReturnedString, nSize);
            }
            return (int)mh$.invokeExact(lpAppName, lpReturnedString, nSize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class WriteProfileSectionA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("WriteProfileSectionA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL WriteProfileSectionA(LPCSTR lpAppName, LPCSTR lpString)
     * }
     */
    public static FunctionDescriptor WriteProfileSectionA$descriptor() {
        return WriteProfileSectionA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL WriteProfileSectionA(LPCSTR lpAppName, LPCSTR lpString)
     * }
     */
    public static MethodHandle WriteProfileSectionA$handle() {
        return WriteProfileSectionA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL WriteProfileSectionA(LPCSTR lpAppName, LPCSTR lpString)
     * }
     */
    public static int WriteProfileSectionA(MemorySegment lpAppName, MemorySegment lpString) {
        var mh$ = WriteProfileSectionA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WriteProfileSectionA", lpAppName, lpString);
            }
            return (int)mh$.invokeExact(lpAppName, lpString);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class WriteProfileSectionW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("WriteProfileSectionW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL WriteProfileSectionW(LPCWSTR lpAppName, LPCWSTR lpString)
     * }
     */
    public static FunctionDescriptor WriteProfileSectionW$descriptor() {
        return WriteProfileSectionW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL WriteProfileSectionW(LPCWSTR lpAppName, LPCWSTR lpString)
     * }
     */
    public static MethodHandle WriteProfileSectionW$handle() {
        return WriteProfileSectionW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL WriteProfileSectionW(LPCWSTR lpAppName, LPCWSTR lpString)
     * }
     */
    public static int WriteProfileSectionW(MemorySegment lpAppName, MemorySegment lpString) {
        var mh$ = WriteProfileSectionW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WriteProfileSectionW", lpAppName, lpString);
            }
            return (int)mh$.invokeExact(lpAppName, lpString);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetPrivateProfileIntA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetPrivateProfileIntA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * UINT GetPrivateProfileIntA(LPCSTR lpAppName, LPCSTR lpKeyName, INT nDefault, LPCSTR lpFileName)
     * }
     */
    public static FunctionDescriptor GetPrivateProfileIntA$descriptor() {
        return GetPrivateProfileIntA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * UINT GetPrivateProfileIntA(LPCSTR lpAppName, LPCSTR lpKeyName, INT nDefault, LPCSTR lpFileName)
     * }
     */
    public static MethodHandle GetPrivateProfileIntA$handle() {
        return GetPrivateProfileIntA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * UINT GetPrivateProfileIntA(LPCSTR lpAppName, LPCSTR lpKeyName, INT nDefault, LPCSTR lpFileName)
     * }
     */
    public static int GetPrivateProfileIntA(MemorySegment lpAppName, MemorySegment lpKeyName, int nDefault, MemorySegment lpFileName) {
        var mh$ = GetPrivateProfileIntA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetPrivateProfileIntA", lpAppName, lpKeyName, nDefault, lpFileName);
            }
            return (int)mh$.invokeExact(lpAppName, lpKeyName, nDefault, lpFileName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetPrivateProfileIntW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetPrivateProfileIntW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * UINT GetPrivateProfileIntW(LPCWSTR lpAppName, LPCWSTR lpKeyName, INT nDefault, LPCWSTR lpFileName)
     * }
     */
    public static FunctionDescriptor GetPrivateProfileIntW$descriptor() {
        return GetPrivateProfileIntW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * UINT GetPrivateProfileIntW(LPCWSTR lpAppName, LPCWSTR lpKeyName, INT nDefault, LPCWSTR lpFileName)
     * }
     */
    public static MethodHandle GetPrivateProfileIntW$handle() {
        return GetPrivateProfileIntW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * UINT GetPrivateProfileIntW(LPCWSTR lpAppName, LPCWSTR lpKeyName, INT nDefault, LPCWSTR lpFileName)
     * }
     */
    public static int GetPrivateProfileIntW(MemorySegment lpAppName, MemorySegment lpKeyName, int nDefault, MemorySegment lpFileName) {
        var mh$ = GetPrivateProfileIntW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetPrivateProfileIntW", lpAppName, lpKeyName, nDefault, lpFileName);
            }
            return (int)mh$.invokeExact(lpAppName, lpKeyName, nDefault, lpFileName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetPrivateProfileStringA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_LONG,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetPrivateProfileStringA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetPrivateProfileStringA(LPCSTR lpAppName, LPCSTR lpKeyName, LPCSTR lpDefault, LPSTR lpReturnedString, DWORD nSize, LPCSTR lpFileName)
     * }
     */
    public static FunctionDescriptor GetPrivateProfileStringA$descriptor() {
        return GetPrivateProfileStringA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetPrivateProfileStringA(LPCSTR lpAppName, LPCSTR lpKeyName, LPCSTR lpDefault, LPSTR lpReturnedString, DWORD nSize, LPCSTR lpFileName)
     * }
     */
    public static MethodHandle GetPrivateProfileStringA$handle() {
        return GetPrivateProfileStringA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * DWORD GetPrivateProfileStringA(LPCSTR lpAppName, LPCSTR lpKeyName, LPCSTR lpDefault, LPSTR lpReturnedString, DWORD nSize, LPCSTR lpFileName)
     * }
     */
    public static int GetPrivateProfileStringA(MemorySegment lpAppName, MemorySegment lpKeyName, MemorySegment lpDefault, MemorySegment lpReturnedString, int nSize, MemorySegment lpFileName) {
        var mh$ = GetPrivateProfileStringA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetPrivateProfileStringA", lpAppName, lpKeyName, lpDefault, lpReturnedString, nSize, lpFileName);
            }
            return (int)mh$.invokeExact(lpAppName, lpKeyName, lpDefault, lpReturnedString, nSize, lpFileName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetPrivateProfileStringW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_LONG,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetPrivateProfileStringW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetPrivateProfileStringW(LPCWSTR lpAppName, LPCWSTR lpKeyName, LPCWSTR lpDefault, LPWSTR lpReturnedString, DWORD nSize, LPCWSTR lpFileName)
     * }
     */
    public static FunctionDescriptor GetPrivateProfileStringW$descriptor() {
        return GetPrivateProfileStringW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetPrivateProfileStringW(LPCWSTR lpAppName, LPCWSTR lpKeyName, LPCWSTR lpDefault, LPWSTR lpReturnedString, DWORD nSize, LPCWSTR lpFileName)
     * }
     */
    public static MethodHandle GetPrivateProfileStringW$handle() {
        return GetPrivateProfileStringW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * DWORD GetPrivateProfileStringW(LPCWSTR lpAppName, LPCWSTR lpKeyName, LPCWSTR lpDefault, LPWSTR lpReturnedString, DWORD nSize, LPCWSTR lpFileName)
     * }
     */
    public static int GetPrivateProfileStringW(MemorySegment lpAppName, MemorySegment lpKeyName, MemorySegment lpDefault, MemorySegment lpReturnedString, int nSize, MemorySegment lpFileName) {
        var mh$ = GetPrivateProfileStringW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetPrivateProfileStringW", lpAppName, lpKeyName, lpDefault, lpReturnedString, nSize, lpFileName);
            }
            return (int)mh$.invokeExact(lpAppName, lpKeyName, lpDefault, lpReturnedString, nSize, lpFileName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class WritePrivateProfileStringA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("WritePrivateProfileStringA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL WritePrivateProfileStringA(LPCSTR lpAppName, LPCSTR lpKeyName, LPCSTR lpString, LPCSTR lpFileName)
     * }
     */
    public static FunctionDescriptor WritePrivateProfileStringA$descriptor() {
        return WritePrivateProfileStringA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL WritePrivateProfileStringA(LPCSTR lpAppName, LPCSTR lpKeyName, LPCSTR lpString, LPCSTR lpFileName)
     * }
     */
    public static MethodHandle WritePrivateProfileStringA$handle() {
        return WritePrivateProfileStringA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL WritePrivateProfileStringA(LPCSTR lpAppName, LPCSTR lpKeyName, LPCSTR lpString, LPCSTR lpFileName)
     * }
     */
    public static int WritePrivateProfileStringA(MemorySegment lpAppName, MemorySegment lpKeyName, MemorySegment lpString, MemorySegment lpFileName) {
        var mh$ = WritePrivateProfileStringA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WritePrivateProfileStringA", lpAppName, lpKeyName, lpString, lpFileName);
            }
            return (int)mh$.invokeExact(lpAppName, lpKeyName, lpString, lpFileName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class WritePrivateProfileStringW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("WritePrivateProfileStringW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL WritePrivateProfileStringW(LPCWSTR lpAppName, LPCWSTR lpKeyName, LPCWSTR lpString, LPCWSTR lpFileName)
     * }
     */
    public static FunctionDescriptor WritePrivateProfileStringW$descriptor() {
        return WritePrivateProfileStringW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL WritePrivateProfileStringW(LPCWSTR lpAppName, LPCWSTR lpKeyName, LPCWSTR lpString, LPCWSTR lpFileName)
     * }
     */
    public static MethodHandle WritePrivateProfileStringW$handle() {
        return WritePrivateProfileStringW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL WritePrivateProfileStringW(LPCWSTR lpAppName, LPCWSTR lpKeyName, LPCWSTR lpString, LPCWSTR lpFileName)
     * }
     */
    public static int WritePrivateProfileStringW(MemorySegment lpAppName, MemorySegment lpKeyName, MemorySegment lpString, MemorySegment lpFileName) {
        var mh$ = WritePrivateProfileStringW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WritePrivateProfileStringW", lpAppName, lpKeyName, lpString, lpFileName);
            }
            return (int)mh$.invokeExact(lpAppName, lpKeyName, lpString, lpFileName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetPrivateProfileSectionA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_POINTER,
            C_POINTER,
            C_LONG,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetPrivateProfileSectionA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetPrivateProfileSectionA(LPCSTR lpAppName, LPSTR lpReturnedString, DWORD nSize, LPCSTR lpFileName)
     * }
     */
    public static FunctionDescriptor GetPrivateProfileSectionA$descriptor() {
        return GetPrivateProfileSectionA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetPrivateProfileSectionA(LPCSTR lpAppName, LPSTR lpReturnedString, DWORD nSize, LPCSTR lpFileName)
     * }
     */
    public static MethodHandle GetPrivateProfileSectionA$handle() {
        return GetPrivateProfileSectionA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * DWORD GetPrivateProfileSectionA(LPCSTR lpAppName, LPSTR lpReturnedString, DWORD nSize, LPCSTR lpFileName)
     * }
     */
    public static int GetPrivateProfileSectionA(MemorySegment lpAppName, MemorySegment lpReturnedString, int nSize, MemorySegment lpFileName) {
        var mh$ = GetPrivateProfileSectionA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetPrivateProfileSectionA", lpAppName, lpReturnedString, nSize, lpFileName);
            }
            return (int)mh$.invokeExact(lpAppName, lpReturnedString, nSize, lpFileName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetPrivateProfileSectionW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_POINTER,
            C_POINTER,
            C_LONG,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetPrivateProfileSectionW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetPrivateProfileSectionW(LPCWSTR lpAppName, LPWSTR lpReturnedString, DWORD nSize, LPCWSTR lpFileName)
     * }
     */
    public static FunctionDescriptor GetPrivateProfileSectionW$descriptor() {
        return GetPrivateProfileSectionW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetPrivateProfileSectionW(LPCWSTR lpAppName, LPWSTR lpReturnedString, DWORD nSize, LPCWSTR lpFileName)
     * }
     */
    public static MethodHandle GetPrivateProfileSectionW$handle() {
        return GetPrivateProfileSectionW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * DWORD GetPrivateProfileSectionW(LPCWSTR lpAppName, LPWSTR lpReturnedString, DWORD nSize, LPCWSTR lpFileName)
     * }
     */
    public static int GetPrivateProfileSectionW(MemorySegment lpAppName, MemorySegment lpReturnedString, int nSize, MemorySegment lpFileName) {
        var mh$ = GetPrivateProfileSectionW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetPrivateProfileSectionW", lpAppName, lpReturnedString, nSize, lpFileName);
            }
            return (int)mh$.invokeExact(lpAppName, lpReturnedString, nSize, lpFileName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class WritePrivateProfileSectionA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("WritePrivateProfileSectionA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL WritePrivateProfileSectionA(LPCSTR lpAppName, LPCSTR lpString, LPCSTR lpFileName)
     * }
     */
    public static FunctionDescriptor WritePrivateProfileSectionA$descriptor() {
        return WritePrivateProfileSectionA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL WritePrivateProfileSectionA(LPCSTR lpAppName, LPCSTR lpString, LPCSTR lpFileName)
     * }
     */
    public static MethodHandle WritePrivateProfileSectionA$handle() {
        return WritePrivateProfileSectionA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL WritePrivateProfileSectionA(LPCSTR lpAppName, LPCSTR lpString, LPCSTR lpFileName)
     * }
     */
    public static int WritePrivateProfileSectionA(MemorySegment lpAppName, MemorySegment lpString, MemorySegment lpFileName) {
        var mh$ = WritePrivateProfileSectionA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WritePrivateProfileSectionA", lpAppName, lpString, lpFileName);
            }
            return (int)mh$.invokeExact(lpAppName, lpString, lpFileName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class WritePrivateProfileSectionW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("WritePrivateProfileSectionW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL WritePrivateProfileSectionW(LPCWSTR lpAppName, LPCWSTR lpString, LPCWSTR lpFileName)
     * }
     */
    public static FunctionDescriptor WritePrivateProfileSectionW$descriptor() {
        return WritePrivateProfileSectionW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL WritePrivateProfileSectionW(LPCWSTR lpAppName, LPCWSTR lpString, LPCWSTR lpFileName)
     * }
     */
    public static MethodHandle WritePrivateProfileSectionW$handle() {
        return WritePrivateProfileSectionW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL WritePrivateProfileSectionW(LPCWSTR lpAppName, LPCWSTR lpString, LPCWSTR lpFileName)
     * }
     */
    public static int WritePrivateProfileSectionW(MemorySegment lpAppName, MemorySegment lpString, MemorySegment lpFileName) {
        var mh$ = WritePrivateProfileSectionW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WritePrivateProfileSectionW", lpAppName, lpString, lpFileName);
            }
            return (int)mh$.invokeExact(lpAppName, lpString, lpFileName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetPrivateProfileSectionNamesA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_POINTER,
            C_LONG,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetPrivateProfileSectionNamesA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetPrivateProfileSectionNamesA(LPSTR lpszReturnBuffer, DWORD nSize, LPCSTR lpFileName)
     * }
     */
    public static FunctionDescriptor GetPrivateProfileSectionNamesA$descriptor() {
        return GetPrivateProfileSectionNamesA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetPrivateProfileSectionNamesA(LPSTR lpszReturnBuffer, DWORD nSize, LPCSTR lpFileName)
     * }
     */
    public static MethodHandle GetPrivateProfileSectionNamesA$handle() {
        return GetPrivateProfileSectionNamesA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * DWORD GetPrivateProfileSectionNamesA(LPSTR lpszReturnBuffer, DWORD nSize, LPCSTR lpFileName)
     * }
     */
    public static int GetPrivateProfileSectionNamesA(MemorySegment lpszReturnBuffer, int nSize, MemorySegment lpFileName) {
        var mh$ = GetPrivateProfileSectionNamesA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetPrivateProfileSectionNamesA", lpszReturnBuffer, nSize, lpFileName);
            }
            return (int)mh$.invokeExact(lpszReturnBuffer, nSize, lpFileName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetPrivateProfileSectionNamesW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_POINTER,
            C_LONG,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetPrivateProfileSectionNamesW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetPrivateProfileSectionNamesW(LPWSTR lpszReturnBuffer, DWORD nSize, LPCWSTR lpFileName)
     * }
     */
    public static FunctionDescriptor GetPrivateProfileSectionNamesW$descriptor() {
        return GetPrivateProfileSectionNamesW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetPrivateProfileSectionNamesW(LPWSTR lpszReturnBuffer, DWORD nSize, LPCWSTR lpFileName)
     * }
     */
    public static MethodHandle GetPrivateProfileSectionNamesW$handle() {
        return GetPrivateProfileSectionNamesW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * DWORD GetPrivateProfileSectionNamesW(LPWSTR lpszReturnBuffer, DWORD nSize, LPCWSTR lpFileName)
     * }
     */
    public static int GetPrivateProfileSectionNamesW(MemorySegment lpszReturnBuffer, int nSize, MemorySegment lpFileName) {
        var mh$ = GetPrivateProfileSectionNamesW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetPrivateProfileSectionNamesW", lpszReturnBuffer, nSize, lpFileName);
            }
            return (int)mh$.invokeExact(lpszReturnBuffer, nSize, lpFileName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetPrivateProfileStructA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetPrivateProfileStructA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetPrivateProfileStructA(LPCSTR lpszSection, LPCSTR lpszKey, LPVOID lpStruct, UINT uSizeStruct, LPCSTR szFile)
     * }
     */
    public static FunctionDescriptor GetPrivateProfileStructA$descriptor() {
        return GetPrivateProfileStructA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetPrivateProfileStructA(LPCSTR lpszSection, LPCSTR lpszKey, LPVOID lpStruct, UINT uSizeStruct, LPCSTR szFile)
     * }
     */
    public static MethodHandle GetPrivateProfileStructA$handle() {
        return GetPrivateProfileStructA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL GetPrivateProfileStructA(LPCSTR lpszSection, LPCSTR lpszKey, LPVOID lpStruct, UINT uSizeStruct, LPCSTR szFile)
     * }
     */
    public static int GetPrivateProfileStructA(MemorySegment lpszSection, MemorySegment lpszKey, MemorySegment lpStruct, int uSizeStruct, MemorySegment szFile) {
        var mh$ = GetPrivateProfileStructA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetPrivateProfileStructA", lpszSection, lpszKey, lpStruct, uSizeStruct, szFile);
            }
            return (int)mh$.invokeExact(lpszSection, lpszKey, lpStruct, uSizeStruct, szFile);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetPrivateProfileStructW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetPrivateProfileStructW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetPrivateProfileStructW(LPCWSTR lpszSection, LPCWSTR lpszKey, LPVOID lpStruct, UINT uSizeStruct, LPCWSTR szFile)
     * }
     */
    public static FunctionDescriptor GetPrivateProfileStructW$descriptor() {
        return GetPrivateProfileStructW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetPrivateProfileStructW(LPCWSTR lpszSection, LPCWSTR lpszKey, LPVOID lpStruct, UINT uSizeStruct, LPCWSTR szFile)
     * }
     */
    public static MethodHandle GetPrivateProfileStructW$handle() {
        return GetPrivateProfileStructW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL GetPrivateProfileStructW(LPCWSTR lpszSection, LPCWSTR lpszKey, LPVOID lpStruct, UINT uSizeStruct, LPCWSTR szFile)
     * }
     */
    public static int GetPrivateProfileStructW(MemorySegment lpszSection, MemorySegment lpszKey, MemorySegment lpStruct, int uSizeStruct, MemorySegment szFile) {
        var mh$ = GetPrivateProfileStructW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetPrivateProfileStructW", lpszSection, lpszKey, lpStruct, uSizeStruct, szFile);
            }
            return (int)mh$.invokeExact(lpszSection, lpszKey, lpStruct, uSizeStruct, szFile);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class WritePrivateProfileStructA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("WritePrivateProfileStructA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL WritePrivateProfileStructA(LPCSTR lpszSection, LPCSTR lpszKey, LPVOID lpStruct, UINT uSizeStruct, LPCSTR szFile)
     * }
     */
    public static FunctionDescriptor WritePrivateProfileStructA$descriptor() {
        return WritePrivateProfileStructA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL WritePrivateProfileStructA(LPCSTR lpszSection, LPCSTR lpszKey, LPVOID lpStruct, UINT uSizeStruct, LPCSTR szFile)
     * }
     */
    public static MethodHandle WritePrivateProfileStructA$handle() {
        return WritePrivateProfileStructA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL WritePrivateProfileStructA(LPCSTR lpszSection, LPCSTR lpszKey, LPVOID lpStruct, UINT uSizeStruct, LPCSTR szFile)
     * }
     */
    public static int WritePrivateProfileStructA(MemorySegment lpszSection, MemorySegment lpszKey, MemorySegment lpStruct, int uSizeStruct, MemorySegment szFile) {
        var mh$ = WritePrivateProfileStructA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WritePrivateProfileStructA", lpszSection, lpszKey, lpStruct, uSizeStruct, szFile);
            }
            return (int)mh$.invokeExact(lpszSection, lpszKey, lpStruct, uSizeStruct, szFile);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class WritePrivateProfileStructW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("WritePrivateProfileStructW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL WritePrivateProfileStructW(LPCWSTR lpszSection, LPCWSTR lpszKey, LPVOID lpStruct, UINT uSizeStruct, LPCWSTR szFile)
     * }
     */
    public static FunctionDescriptor WritePrivateProfileStructW$descriptor() {
        return WritePrivateProfileStructW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL WritePrivateProfileStructW(LPCWSTR lpszSection, LPCWSTR lpszKey, LPVOID lpStruct, UINT uSizeStruct, LPCWSTR szFile)
     * }
     */
    public static MethodHandle WritePrivateProfileStructW$handle() {
        return WritePrivateProfileStructW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL WritePrivateProfileStructW(LPCWSTR lpszSection, LPCWSTR lpszKey, LPVOID lpStruct, UINT uSizeStruct, LPCWSTR szFile)
     * }
     */
    public static int WritePrivateProfileStructW(MemorySegment lpszSection, MemorySegment lpszKey, MemorySegment lpStruct, int uSizeStruct, MemorySegment szFile) {
        var mh$ = WritePrivateProfileStructW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WritePrivateProfileStructW", lpszSection, lpszKey, lpStruct, uSizeStruct, szFile);
            }
            return (int)mh$.invokeExact(lpszSection, lpszKey, lpStruct, uSizeStruct, szFile);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetDllDirectoryA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("SetDllDirectoryA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetDllDirectoryA(LPCSTR lpPathName)
     * }
     */
    public static FunctionDescriptor SetDllDirectoryA$descriptor() {
        return SetDllDirectoryA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetDllDirectoryA(LPCSTR lpPathName)
     * }
     */
    public static MethodHandle SetDllDirectoryA$handle() {
        return SetDllDirectoryA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL SetDllDirectoryA(LPCSTR lpPathName)
     * }
     */
    public static int SetDllDirectoryA(MemorySegment lpPathName) {
        var mh$ = SetDllDirectoryA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetDllDirectoryA", lpPathName);
            }
            return (int)mh$.invokeExact(lpPathName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetDllDirectoryW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("SetDllDirectoryW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetDllDirectoryW(LPCWSTR lpPathName)
     * }
     */
    public static FunctionDescriptor SetDllDirectoryW$descriptor() {
        return SetDllDirectoryW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetDllDirectoryW(LPCWSTR lpPathName)
     * }
     */
    public static MethodHandle SetDllDirectoryW$handle() {
        return SetDllDirectoryW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL SetDllDirectoryW(LPCWSTR lpPathName)
     * }
     */
    public static int SetDllDirectoryW(MemorySegment lpPathName) {
        var mh$ = SetDllDirectoryW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetDllDirectoryW", lpPathName);
            }
            return (int)mh$.invokeExact(lpPathName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetDllDirectoryA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_LONG,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetDllDirectoryA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetDllDirectoryA(DWORD nBufferLength, LPSTR lpBuffer)
     * }
     */
    public static FunctionDescriptor GetDllDirectoryA$descriptor() {
        return GetDllDirectoryA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetDllDirectoryA(DWORD nBufferLength, LPSTR lpBuffer)
     * }
     */
    public static MethodHandle GetDllDirectoryA$handle() {
        return GetDllDirectoryA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * DWORD GetDllDirectoryA(DWORD nBufferLength, LPSTR lpBuffer)
     * }
     */
    public static int GetDllDirectoryA(int nBufferLength, MemorySegment lpBuffer) {
        var mh$ = GetDllDirectoryA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetDllDirectoryA", nBufferLength, lpBuffer);
            }
            return (int)mh$.invokeExact(nBufferLength, lpBuffer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetDllDirectoryW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_LONG,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetDllDirectoryW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetDllDirectoryW(DWORD nBufferLength, LPWSTR lpBuffer)
     * }
     */
    public static FunctionDescriptor GetDllDirectoryW$descriptor() {
        return GetDllDirectoryW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetDllDirectoryW(DWORD nBufferLength, LPWSTR lpBuffer)
     * }
     */
    public static MethodHandle GetDllDirectoryW$handle() {
        return GetDllDirectoryW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * DWORD GetDllDirectoryW(DWORD nBufferLength, LPWSTR lpBuffer)
     * }
     */
    public static int GetDllDirectoryW(int nBufferLength, MemorySegment lpBuffer) {
        var mh$ = GetDllDirectoryW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetDllDirectoryW", nBufferLength, lpBuffer);
            }
            return (int)mh$.invokeExact(nBufferLength, lpBuffer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetSearchPathMode {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("SetSearchPathMode"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetSearchPathMode(DWORD Flags)
     * }
     */
    public static FunctionDescriptor SetSearchPathMode$descriptor() {
        return SetSearchPathMode.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetSearchPathMode(DWORD Flags)
     * }
     */
    public static MethodHandle SetSearchPathMode$handle() {
        return SetSearchPathMode.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL SetSearchPathMode(DWORD Flags)
     * }
     */
    public static int SetSearchPathMode(int Flags) {
        var mh$ = SetSearchPathMode.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetSearchPathMode", Flags);
            }
            return (int)mh$.invokeExact(Flags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateDirectoryExA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CreateDirectoryExA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CreateDirectoryExA(LPCSTR lpTemplateDirectory, LPCSTR lpNewDirectory, LPSECURITY_ATTRIBUTES lpSecurityAttributes)
     * }
     */
    public static FunctionDescriptor CreateDirectoryExA$descriptor() {
        return CreateDirectoryExA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CreateDirectoryExA(LPCSTR lpTemplateDirectory, LPCSTR lpNewDirectory, LPSECURITY_ATTRIBUTES lpSecurityAttributes)
     * }
     */
    public static MethodHandle CreateDirectoryExA$handle() {
        return CreateDirectoryExA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL CreateDirectoryExA(LPCSTR lpTemplateDirectory, LPCSTR lpNewDirectory, LPSECURITY_ATTRIBUTES lpSecurityAttributes)
     * }
     */
    public static int CreateDirectoryExA(MemorySegment lpTemplateDirectory, MemorySegment lpNewDirectory, MemorySegment lpSecurityAttributes) {
        var mh$ = CreateDirectoryExA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateDirectoryExA", lpTemplateDirectory, lpNewDirectory, lpSecurityAttributes);
            }
            return (int)mh$.invokeExact(lpTemplateDirectory, lpNewDirectory, lpSecurityAttributes);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateDirectoryExW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CreateDirectoryExW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CreateDirectoryExW(LPCWSTR lpTemplateDirectory, LPCWSTR lpNewDirectory, LPSECURITY_ATTRIBUTES lpSecurityAttributes)
     * }
     */
    public static FunctionDescriptor CreateDirectoryExW$descriptor() {
        return CreateDirectoryExW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CreateDirectoryExW(LPCWSTR lpTemplateDirectory, LPCWSTR lpNewDirectory, LPSECURITY_ATTRIBUTES lpSecurityAttributes)
     * }
     */
    public static MethodHandle CreateDirectoryExW$handle() {
        return CreateDirectoryExW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL CreateDirectoryExW(LPCWSTR lpTemplateDirectory, LPCWSTR lpNewDirectory, LPSECURITY_ATTRIBUTES lpSecurityAttributes)
     * }
     */
    public static int CreateDirectoryExW(MemorySegment lpTemplateDirectory, MemorySegment lpNewDirectory, MemorySegment lpSecurityAttributes) {
        var mh$ = CreateDirectoryExW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateDirectoryExW", lpTemplateDirectory, lpNewDirectory, lpSecurityAttributes);
            }
            return (int)mh$.invokeExact(lpTemplateDirectory, lpNewDirectory, lpSecurityAttributes);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateDirectoryTransactedA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CreateDirectoryTransactedA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CreateDirectoryTransactedA(LPCSTR lpTemplateDirectory, LPCSTR lpNewDirectory, LPSECURITY_ATTRIBUTES lpSecurityAttributes, HANDLE hTransaction)
     * }
     */
    public static FunctionDescriptor CreateDirectoryTransactedA$descriptor() {
        return CreateDirectoryTransactedA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CreateDirectoryTransactedA(LPCSTR lpTemplateDirectory, LPCSTR lpNewDirectory, LPSECURITY_ATTRIBUTES lpSecurityAttributes, HANDLE hTransaction)
     * }
     */
    public static MethodHandle CreateDirectoryTransactedA$handle() {
        return CreateDirectoryTransactedA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL CreateDirectoryTransactedA(LPCSTR lpTemplateDirectory, LPCSTR lpNewDirectory, LPSECURITY_ATTRIBUTES lpSecurityAttributes, HANDLE hTransaction)
     * }
     */
    public static int CreateDirectoryTransactedA(MemorySegment lpTemplateDirectory, MemorySegment lpNewDirectory, MemorySegment lpSecurityAttributes, MemorySegment hTransaction) {
        var mh$ = CreateDirectoryTransactedA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateDirectoryTransactedA", lpTemplateDirectory, lpNewDirectory, lpSecurityAttributes, hTransaction);
            }
            return (int)mh$.invokeExact(lpTemplateDirectory, lpNewDirectory, lpSecurityAttributes, hTransaction);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateDirectoryTransactedW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CreateDirectoryTransactedW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CreateDirectoryTransactedW(LPCWSTR lpTemplateDirectory, LPCWSTR lpNewDirectory, LPSECURITY_ATTRIBUTES lpSecurityAttributes, HANDLE hTransaction)
     * }
     */
    public static FunctionDescriptor CreateDirectoryTransactedW$descriptor() {
        return CreateDirectoryTransactedW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CreateDirectoryTransactedW(LPCWSTR lpTemplateDirectory, LPCWSTR lpNewDirectory, LPSECURITY_ATTRIBUTES lpSecurityAttributes, HANDLE hTransaction)
     * }
     */
    public static MethodHandle CreateDirectoryTransactedW$handle() {
        return CreateDirectoryTransactedW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL CreateDirectoryTransactedW(LPCWSTR lpTemplateDirectory, LPCWSTR lpNewDirectory, LPSECURITY_ATTRIBUTES lpSecurityAttributes, HANDLE hTransaction)
     * }
     */
    public static int CreateDirectoryTransactedW(MemorySegment lpTemplateDirectory, MemorySegment lpNewDirectory, MemorySegment lpSecurityAttributes, MemorySegment hTransaction) {
        var mh$ = CreateDirectoryTransactedW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateDirectoryTransactedW", lpTemplateDirectory, lpNewDirectory, lpSecurityAttributes, hTransaction);
            }
            return (int)mh$.invokeExact(lpTemplateDirectory, lpNewDirectory, lpSecurityAttributes, hTransaction);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RemoveDirectoryTransactedA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("RemoveDirectoryTransactedA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL RemoveDirectoryTransactedA(LPCSTR lpPathName, HANDLE hTransaction)
     * }
     */
    public static FunctionDescriptor RemoveDirectoryTransactedA$descriptor() {
        return RemoveDirectoryTransactedA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL RemoveDirectoryTransactedA(LPCSTR lpPathName, HANDLE hTransaction)
     * }
     */
    public static MethodHandle RemoveDirectoryTransactedA$handle() {
        return RemoveDirectoryTransactedA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL RemoveDirectoryTransactedA(LPCSTR lpPathName, HANDLE hTransaction)
     * }
     */
    public static int RemoveDirectoryTransactedA(MemorySegment lpPathName, MemorySegment hTransaction) {
        var mh$ = RemoveDirectoryTransactedA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RemoveDirectoryTransactedA", lpPathName, hTransaction);
            }
            return (int)mh$.invokeExact(lpPathName, hTransaction);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RemoveDirectoryTransactedW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("RemoveDirectoryTransactedW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL RemoveDirectoryTransactedW(LPCWSTR lpPathName, HANDLE hTransaction)
     * }
     */
    public static FunctionDescriptor RemoveDirectoryTransactedW$descriptor() {
        return RemoveDirectoryTransactedW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL RemoveDirectoryTransactedW(LPCWSTR lpPathName, HANDLE hTransaction)
     * }
     */
    public static MethodHandle RemoveDirectoryTransactedW$handle() {
        return RemoveDirectoryTransactedW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL RemoveDirectoryTransactedW(LPCWSTR lpPathName, HANDLE hTransaction)
     * }
     */
    public static int RemoveDirectoryTransactedW(MemorySegment lpPathName, MemorySegment hTransaction) {
        var mh$ = RemoveDirectoryTransactedW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RemoveDirectoryTransactedW", lpPathName, hTransaction);
            }
            return (int)mh$.invokeExact(lpPathName, hTransaction);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetFullPathNameTransactedA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_POINTER,
            C_LONG,
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetFullPathNameTransactedA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetFullPathNameTransactedA(LPCSTR lpFileName, DWORD nBufferLength, LPSTR lpBuffer, LPSTR *lpFilePart, HANDLE hTransaction)
     * }
     */
    public static FunctionDescriptor GetFullPathNameTransactedA$descriptor() {
        return GetFullPathNameTransactedA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetFullPathNameTransactedA(LPCSTR lpFileName, DWORD nBufferLength, LPSTR lpBuffer, LPSTR *lpFilePart, HANDLE hTransaction)
     * }
     */
    public static MethodHandle GetFullPathNameTransactedA$handle() {
        return GetFullPathNameTransactedA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * DWORD GetFullPathNameTransactedA(LPCSTR lpFileName, DWORD nBufferLength, LPSTR lpBuffer, LPSTR *lpFilePart, HANDLE hTransaction)
     * }
     */
    public static int GetFullPathNameTransactedA(MemorySegment lpFileName, int nBufferLength, MemorySegment lpBuffer, MemorySegment lpFilePart, MemorySegment hTransaction) {
        var mh$ = GetFullPathNameTransactedA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetFullPathNameTransactedA", lpFileName, nBufferLength, lpBuffer, lpFilePart, hTransaction);
            }
            return (int)mh$.invokeExact(lpFileName, nBufferLength, lpBuffer, lpFilePart, hTransaction);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetFullPathNameTransactedW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_POINTER,
            C_LONG,
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetFullPathNameTransactedW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetFullPathNameTransactedW(LPCWSTR lpFileName, DWORD nBufferLength, LPWSTR lpBuffer, LPWSTR *lpFilePart, HANDLE hTransaction)
     * }
     */
    public static FunctionDescriptor GetFullPathNameTransactedW$descriptor() {
        return GetFullPathNameTransactedW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetFullPathNameTransactedW(LPCWSTR lpFileName, DWORD nBufferLength, LPWSTR lpBuffer, LPWSTR *lpFilePart, HANDLE hTransaction)
     * }
     */
    public static MethodHandle GetFullPathNameTransactedW$handle() {
        return GetFullPathNameTransactedW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * DWORD GetFullPathNameTransactedW(LPCWSTR lpFileName, DWORD nBufferLength, LPWSTR lpBuffer, LPWSTR *lpFilePart, HANDLE hTransaction)
     * }
     */
    public static int GetFullPathNameTransactedW(MemorySegment lpFileName, int nBufferLength, MemorySegment lpBuffer, MemorySegment lpFilePart, MemorySegment hTransaction) {
        var mh$ = GetFullPathNameTransactedW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetFullPathNameTransactedW", lpFileName, nBufferLength, lpBuffer, lpFilePart, hTransaction);
            }
            return (int)mh$.invokeExact(lpFileName, nBufferLength, lpBuffer, lpFilePart, hTransaction);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DefineDosDeviceA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_LONG,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("DefineDosDeviceA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL DefineDosDeviceA(DWORD dwFlags, LPCSTR lpDeviceName, LPCSTR lpTargetPath)
     * }
     */
    public static FunctionDescriptor DefineDosDeviceA$descriptor() {
        return DefineDosDeviceA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL DefineDosDeviceA(DWORD dwFlags, LPCSTR lpDeviceName, LPCSTR lpTargetPath)
     * }
     */
    public static MethodHandle DefineDosDeviceA$handle() {
        return DefineDosDeviceA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL DefineDosDeviceA(DWORD dwFlags, LPCSTR lpDeviceName, LPCSTR lpTargetPath)
     * }
     */
    public static int DefineDosDeviceA(int dwFlags, MemorySegment lpDeviceName, MemorySegment lpTargetPath) {
        var mh$ = DefineDosDeviceA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DefineDosDeviceA", dwFlags, lpDeviceName, lpTargetPath);
            }
            return (int)mh$.invokeExact(dwFlags, lpDeviceName, lpTargetPath);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class QueryDosDeviceA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_POINTER,
            C_POINTER,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("QueryDosDeviceA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD QueryDosDeviceA(LPCSTR lpDeviceName, LPSTR lpTargetPath, DWORD ucchMax)
     * }
     */
    public static FunctionDescriptor QueryDosDeviceA$descriptor() {
        return QueryDosDeviceA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD QueryDosDeviceA(LPCSTR lpDeviceName, LPSTR lpTargetPath, DWORD ucchMax)
     * }
     */
    public static MethodHandle QueryDosDeviceA$handle() {
        return QueryDosDeviceA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * DWORD QueryDosDeviceA(LPCSTR lpDeviceName, LPSTR lpTargetPath, DWORD ucchMax)
     * }
     */
    public static int QueryDosDeviceA(MemorySegment lpDeviceName, MemorySegment lpTargetPath, int ucchMax) {
        var mh$ = QueryDosDeviceA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("QueryDosDeviceA", lpDeviceName, lpTargetPath, ucchMax);
            }
            return (int)mh$.invokeExact(lpDeviceName, lpTargetPath, ucchMax);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateFileTransactedA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER,
            C_LONG,
            C_LONG,
            C_POINTER,
            C_LONG,
            C_LONG,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CreateFileTransactedA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HANDLE CreateFileTransactedA(LPCSTR lpFileName, DWORD dwDesiredAccess, DWORD dwShareMode, LPSECURITY_ATTRIBUTES lpSecurityAttributes, DWORD dwCreationDisposition, DWORD dwFlagsAndAttributes, HANDLE hTemplateFile, HANDLE hTransaction, PUSHORT pusMiniVersion, PVOID lpExtendedParameter)
     * }
     */
    public static FunctionDescriptor CreateFileTransactedA$descriptor() {
        return CreateFileTransactedA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HANDLE CreateFileTransactedA(LPCSTR lpFileName, DWORD dwDesiredAccess, DWORD dwShareMode, LPSECURITY_ATTRIBUTES lpSecurityAttributes, DWORD dwCreationDisposition, DWORD dwFlagsAndAttributes, HANDLE hTemplateFile, HANDLE hTransaction, PUSHORT pusMiniVersion, PVOID lpExtendedParameter)
     * }
     */
    public static MethodHandle CreateFileTransactedA$handle() {
        return CreateFileTransactedA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * HANDLE CreateFileTransactedA(LPCSTR lpFileName, DWORD dwDesiredAccess, DWORD dwShareMode, LPSECURITY_ATTRIBUTES lpSecurityAttributes, DWORD dwCreationDisposition, DWORD dwFlagsAndAttributes, HANDLE hTemplateFile, HANDLE hTransaction, PUSHORT pusMiniVersion, PVOID lpExtendedParameter)
     * }
     */
    public static MemorySegment CreateFileTransactedA(MemorySegment lpFileName, int dwDesiredAccess, int dwShareMode, MemorySegment lpSecurityAttributes, int dwCreationDisposition, int dwFlagsAndAttributes, MemorySegment hTemplateFile, MemorySegment hTransaction, MemorySegment pusMiniVersion, MemorySegment lpExtendedParameter) {
        var mh$ = CreateFileTransactedA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateFileTransactedA", lpFileName, dwDesiredAccess, dwShareMode, lpSecurityAttributes, dwCreationDisposition, dwFlagsAndAttributes, hTemplateFile, hTransaction, pusMiniVersion, lpExtendedParameter);
            }
            return (MemorySegment)mh$.invokeExact(lpFileName, dwDesiredAccess, dwShareMode, lpSecurityAttributes, dwCreationDisposition, dwFlagsAndAttributes, hTemplateFile, hTransaction, pusMiniVersion, lpExtendedParameter);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateFileTransactedW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER,
            C_LONG,
            C_LONG,
            C_POINTER,
            C_LONG,
            C_LONG,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CreateFileTransactedW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HANDLE CreateFileTransactedW(LPCWSTR lpFileName, DWORD dwDesiredAccess, DWORD dwShareMode, LPSECURITY_ATTRIBUTES lpSecurityAttributes, DWORD dwCreationDisposition, DWORD dwFlagsAndAttributes, HANDLE hTemplateFile, HANDLE hTransaction, PUSHORT pusMiniVersion, PVOID lpExtendedParameter)
     * }
     */
    public static FunctionDescriptor CreateFileTransactedW$descriptor() {
        return CreateFileTransactedW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HANDLE CreateFileTransactedW(LPCWSTR lpFileName, DWORD dwDesiredAccess, DWORD dwShareMode, LPSECURITY_ATTRIBUTES lpSecurityAttributes, DWORD dwCreationDisposition, DWORD dwFlagsAndAttributes, HANDLE hTemplateFile, HANDLE hTransaction, PUSHORT pusMiniVersion, PVOID lpExtendedParameter)
     * }
     */
    public static MethodHandle CreateFileTransactedW$handle() {
        return CreateFileTransactedW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * HANDLE CreateFileTransactedW(LPCWSTR lpFileName, DWORD dwDesiredAccess, DWORD dwShareMode, LPSECURITY_ATTRIBUTES lpSecurityAttributes, DWORD dwCreationDisposition, DWORD dwFlagsAndAttributes, HANDLE hTemplateFile, HANDLE hTransaction, PUSHORT pusMiniVersion, PVOID lpExtendedParameter)
     * }
     */
    public static MemorySegment CreateFileTransactedW(MemorySegment lpFileName, int dwDesiredAccess, int dwShareMode, MemorySegment lpSecurityAttributes, int dwCreationDisposition, int dwFlagsAndAttributes, MemorySegment hTemplateFile, MemorySegment hTransaction, MemorySegment pusMiniVersion, MemorySegment lpExtendedParameter) {
        var mh$ = CreateFileTransactedW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateFileTransactedW", lpFileName, dwDesiredAccess, dwShareMode, lpSecurityAttributes, dwCreationDisposition, dwFlagsAndAttributes, hTemplateFile, hTransaction, pusMiniVersion, lpExtendedParameter);
            }
            return (MemorySegment)mh$.invokeExact(lpFileName, dwDesiredAccess, dwShareMode, lpSecurityAttributes, dwCreationDisposition, dwFlagsAndAttributes, hTemplateFile, hTransaction, pusMiniVersion, lpExtendedParameter);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ReOpenFile {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER,
            C_LONG,
            C_LONG,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("ReOpenFile"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HANDLE ReOpenFile(HANDLE hOriginalFile, DWORD dwDesiredAccess, DWORD dwShareMode, DWORD dwFlagsAndAttributes)
     * }
     */
    public static FunctionDescriptor ReOpenFile$descriptor() {
        return ReOpenFile.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HANDLE ReOpenFile(HANDLE hOriginalFile, DWORD dwDesiredAccess, DWORD dwShareMode, DWORD dwFlagsAndAttributes)
     * }
     */
    public static MethodHandle ReOpenFile$handle() {
        return ReOpenFile.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * HANDLE ReOpenFile(HANDLE hOriginalFile, DWORD dwDesiredAccess, DWORD dwShareMode, DWORD dwFlagsAndAttributes)
     * }
     */
    public static MemorySegment ReOpenFile(MemorySegment hOriginalFile, int dwDesiredAccess, int dwShareMode, int dwFlagsAndAttributes) {
        var mh$ = ReOpenFile.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ReOpenFile", hOriginalFile, dwDesiredAccess, dwShareMode, dwFlagsAndAttributes);
            }
            return (MemorySegment)mh$.invokeExact(hOriginalFile, dwDesiredAccess, dwShareMode, dwFlagsAndAttributes);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetFileAttributesTransactedA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_LONG,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("SetFileAttributesTransactedA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetFileAttributesTransactedA(LPCSTR lpFileName, DWORD dwFileAttributes, HANDLE hTransaction)
     * }
     */
    public static FunctionDescriptor SetFileAttributesTransactedA$descriptor() {
        return SetFileAttributesTransactedA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetFileAttributesTransactedA(LPCSTR lpFileName, DWORD dwFileAttributes, HANDLE hTransaction)
     * }
     */
    public static MethodHandle SetFileAttributesTransactedA$handle() {
        return SetFileAttributesTransactedA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL SetFileAttributesTransactedA(LPCSTR lpFileName, DWORD dwFileAttributes, HANDLE hTransaction)
     * }
     */
    public static int SetFileAttributesTransactedA(MemorySegment lpFileName, int dwFileAttributes, MemorySegment hTransaction) {
        var mh$ = SetFileAttributesTransactedA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetFileAttributesTransactedA", lpFileName, dwFileAttributes, hTransaction);
            }
            return (int)mh$.invokeExact(lpFileName, dwFileAttributes, hTransaction);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetFileAttributesTransactedW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_LONG,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("SetFileAttributesTransactedW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetFileAttributesTransactedW(LPCWSTR lpFileName, DWORD dwFileAttributes, HANDLE hTransaction)
     * }
     */
    public static FunctionDescriptor SetFileAttributesTransactedW$descriptor() {
        return SetFileAttributesTransactedW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetFileAttributesTransactedW(LPCWSTR lpFileName, DWORD dwFileAttributes, HANDLE hTransaction)
     * }
     */
    public static MethodHandle SetFileAttributesTransactedW$handle() {
        return SetFileAttributesTransactedW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL SetFileAttributesTransactedW(LPCWSTR lpFileName, DWORD dwFileAttributes, HANDLE hTransaction)
     * }
     */
    public static int SetFileAttributesTransactedW(MemorySegment lpFileName, int dwFileAttributes, MemorySegment hTransaction) {
        var mh$ = SetFileAttributesTransactedW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetFileAttributesTransactedW", lpFileName, dwFileAttributes, hTransaction);
            }
            return (int)mh$.invokeExact(lpFileName, dwFileAttributes, hTransaction);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetFileAttributesTransactedA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_INT,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetFileAttributesTransactedA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetFileAttributesTransactedA(LPCSTR lpFileName, GET_FILEEX_INFO_LEVELS fInfoLevelId, LPVOID lpFileInformation, HANDLE hTransaction)
     * }
     */
    public static FunctionDescriptor GetFileAttributesTransactedA$descriptor() {
        return GetFileAttributesTransactedA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetFileAttributesTransactedA(LPCSTR lpFileName, GET_FILEEX_INFO_LEVELS fInfoLevelId, LPVOID lpFileInformation, HANDLE hTransaction)
     * }
     */
    public static MethodHandle GetFileAttributesTransactedA$handle() {
        return GetFileAttributesTransactedA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL GetFileAttributesTransactedA(LPCSTR lpFileName, GET_FILEEX_INFO_LEVELS fInfoLevelId, LPVOID lpFileInformation, HANDLE hTransaction)
     * }
     */
    public static int GetFileAttributesTransactedA(MemorySegment lpFileName, int fInfoLevelId, MemorySegment lpFileInformation, MemorySegment hTransaction) {
        var mh$ = GetFileAttributesTransactedA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetFileAttributesTransactedA", lpFileName, fInfoLevelId, lpFileInformation, hTransaction);
            }
            return (int)mh$.invokeExact(lpFileName, fInfoLevelId, lpFileInformation, hTransaction);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetFileAttributesTransactedW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_INT,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetFileAttributesTransactedW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetFileAttributesTransactedW(LPCWSTR lpFileName, GET_FILEEX_INFO_LEVELS fInfoLevelId, LPVOID lpFileInformation, HANDLE hTransaction)
     * }
     */
    public static FunctionDescriptor GetFileAttributesTransactedW$descriptor() {
        return GetFileAttributesTransactedW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetFileAttributesTransactedW(LPCWSTR lpFileName, GET_FILEEX_INFO_LEVELS fInfoLevelId, LPVOID lpFileInformation, HANDLE hTransaction)
     * }
     */
    public static MethodHandle GetFileAttributesTransactedW$handle() {
        return GetFileAttributesTransactedW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL GetFileAttributesTransactedW(LPCWSTR lpFileName, GET_FILEEX_INFO_LEVELS fInfoLevelId, LPVOID lpFileInformation, HANDLE hTransaction)
     * }
     */
    public static int GetFileAttributesTransactedW(MemorySegment lpFileName, int fInfoLevelId, MemorySegment lpFileInformation, MemorySegment hTransaction) {
        var mh$ = GetFileAttributesTransactedW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetFileAttributesTransactedW", lpFileName, fInfoLevelId, lpFileInformation, hTransaction);
            }
            return (int)mh$.invokeExact(lpFileName, fInfoLevelId, lpFileInformation, hTransaction);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetCompressedFileSizeTransactedA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetCompressedFileSizeTransactedA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetCompressedFileSizeTransactedA(LPCSTR lpFileName, LPDWORD lpFileSizeHigh, HANDLE hTransaction)
     * }
     */
    public static FunctionDescriptor GetCompressedFileSizeTransactedA$descriptor() {
        return GetCompressedFileSizeTransactedA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetCompressedFileSizeTransactedA(LPCSTR lpFileName, LPDWORD lpFileSizeHigh, HANDLE hTransaction)
     * }
     */
    public static MethodHandle GetCompressedFileSizeTransactedA$handle() {
        return GetCompressedFileSizeTransactedA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * DWORD GetCompressedFileSizeTransactedA(LPCSTR lpFileName, LPDWORD lpFileSizeHigh, HANDLE hTransaction)
     * }
     */
    public static int GetCompressedFileSizeTransactedA(MemorySegment lpFileName, MemorySegment lpFileSizeHigh, MemorySegment hTransaction) {
        var mh$ = GetCompressedFileSizeTransactedA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetCompressedFileSizeTransactedA", lpFileName, lpFileSizeHigh, hTransaction);
            }
            return (int)mh$.invokeExact(lpFileName, lpFileSizeHigh, hTransaction);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetCompressedFileSizeTransactedW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetCompressedFileSizeTransactedW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetCompressedFileSizeTransactedW(LPCWSTR lpFileName, LPDWORD lpFileSizeHigh, HANDLE hTransaction)
     * }
     */
    public static FunctionDescriptor GetCompressedFileSizeTransactedW$descriptor() {
        return GetCompressedFileSizeTransactedW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetCompressedFileSizeTransactedW(LPCWSTR lpFileName, LPDWORD lpFileSizeHigh, HANDLE hTransaction)
     * }
     */
    public static MethodHandle GetCompressedFileSizeTransactedW$handle() {
        return GetCompressedFileSizeTransactedW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * DWORD GetCompressedFileSizeTransactedW(LPCWSTR lpFileName, LPDWORD lpFileSizeHigh, HANDLE hTransaction)
     * }
     */
    public static int GetCompressedFileSizeTransactedW(MemorySegment lpFileName, MemorySegment lpFileSizeHigh, MemorySegment hTransaction) {
        var mh$ = GetCompressedFileSizeTransactedW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetCompressedFileSizeTransactedW", lpFileName, lpFileSizeHigh, hTransaction);
            }
            return (int)mh$.invokeExact(lpFileName, lpFileSizeHigh, hTransaction);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DeleteFileTransactedA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("DeleteFileTransactedA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL DeleteFileTransactedA(LPCSTR lpFileName, HANDLE hTransaction)
     * }
     */
    public static FunctionDescriptor DeleteFileTransactedA$descriptor() {
        return DeleteFileTransactedA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL DeleteFileTransactedA(LPCSTR lpFileName, HANDLE hTransaction)
     * }
     */
    public static MethodHandle DeleteFileTransactedA$handle() {
        return DeleteFileTransactedA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL DeleteFileTransactedA(LPCSTR lpFileName, HANDLE hTransaction)
     * }
     */
    public static int DeleteFileTransactedA(MemorySegment lpFileName, MemorySegment hTransaction) {
        var mh$ = DeleteFileTransactedA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DeleteFileTransactedA", lpFileName, hTransaction);
            }
            return (int)mh$.invokeExact(lpFileName, hTransaction);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DeleteFileTransactedW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("DeleteFileTransactedW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL DeleteFileTransactedW(LPCWSTR lpFileName, HANDLE hTransaction)
     * }
     */
    public static FunctionDescriptor DeleteFileTransactedW$descriptor() {
        return DeleteFileTransactedW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL DeleteFileTransactedW(LPCWSTR lpFileName, HANDLE hTransaction)
     * }
     */
    public static MethodHandle DeleteFileTransactedW$handle() {
        return DeleteFileTransactedW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL DeleteFileTransactedW(LPCWSTR lpFileName, HANDLE hTransaction)
     * }
     */
    public static int DeleteFileTransactedW(MemorySegment lpFileName, MemorySegment hTransaction) {
        var mh$ = DeleteFileTransactedW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DeleteFileTransactedW", lpFileName, hTransaction);
            }
            return (int)mh$.invokeExact(lpFileName, hTransaction);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CheckNameLegalDOS8Dot3A {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_LONG,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CheckNameLegalDOS8Dot3A"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CheckNameLegalDOS8Dot3A(LPCSTR lpName, LPSTR lpOemName, DWORD OemNameSize, PBOOL pbNameContainsSpaces, PBOOL pbNameLegal)
     * }
     */
    public static FunctionDescriptor CheckNameLegalDOS8Dot3A$descriptor() {
        return CheckNameLegalDOS8Dot3A.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CheckNameLegalDOS8Dot3A(LPCSTR lpName, LPSTR lpOemName, DWORD OemNameSize, PBOOL pbNameContainsSpaces, PBOOL pbNameLegal)
     * }
     */
    public static MethodHandle CheckNameLegalDOS8Dot3A$handle() {
        return CheckNameLegalDOS8Dot3A.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL CheckNameLegalDOS8Dot3A(LPCSTR lpName, LPSTR lpOemName, DWORD OemNameSize, PBOOL pbNameContainsSpaces, PBOOL pbNameLegal)
     * }
     */
    public static int CheckNameLegalDOS8Dot3A(MemorySegment lpName, MemorySegment lpOemName, int OemNameSize, MemorySegment pbNameContainsSpaces, MemorySegment pbNameLegal) {
        var mh$ = CheckNameLegalDOS8Dot3A.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CheckNameLegalDOS8Dot3A", lpName, lpOemName, OemNameSize, pbNameContainsSpaces, pbNameLegal);
            }
            return (int)mh$.invokeExact(lpName, lpOemName, OemNameSize, pbNameContainsSpaces, pbNameLegal);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CheckNameLegalDOS8Dot3W {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_LONG,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CheckNameLegalDOS8Dot3W"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CheckNameLegalDOS8Dot3W(LPCWSTR lpName, LPSTR lpOemName, DWORD OemNameSize, PBOOL pbNameContainsSpaces, PBOOL pbNameLegal)
     * }
     */
    public static FunctionDescriptor CheckNameLegalDOS8Dot3W$descriptor() {
        return CheckNameLegalDOS8Dot3W.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CheckNameLegalDOS8Dot3W(LPCWSTR lpName, LPSTR lpOemName, DWORD OemNameSize, PBOOL pbNameContainsSpaces, PBOOL pbNameLegal)
     * }
     */
    public static MethodHandle CheckNameLegalDOS8Dot3W$handle() {
        return CheckNameLegalDOS8Dot3W.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL CheckNameLegalDOS8Dot3W(LPCWSTR lpName, LPSTR lpOemName, DWORD OemNameSize, PBOOL pbNameContainsSpaces, PBOOL pbNameLegal)
     * }
     */
    public static int CheckNameLegalDOS8Dot3W(MemorySegment lpName, MemorySegment lpOemName, int OemNameSize, MemorySegment pbNameContainsSpaces, MemorySegment pbNameLegal) {
        var mh$ = CheckNameLegalDOS8Dot3W.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CheckNameLegalDOS8Dot3W", lpName, lpOemName, OemNameSize, pbNameContainsSpaces, pbNameLegal);
            }
            return (int)mh$.invokeExact(lpName, lpOemName, OemNameSize, pbNameContainsSpaces, pbNameLegal);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FindFirstFileTransactedA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER,
            C_INT,
            C_POINTER,
            C_INT,
            C_POINTER,
            C_LONG,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("FindFirstFileTransactedA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HANDLE FindFirstFileTransactedA(LPCSTR lpFileName, FINDEX_INFO_LEVELS fInfoLevelId, LPVOID lpFindFileData, FINDEX_SEARCH_OPS fSearchOp, LPVOID lpSearchFilter, DWORD dwAdditionalFlags, HANDLE hTransaction)
     * }
     */
    public static FunctionDescriptor FindFirstFileTransactedA$descriptor() {
        return FindFirstFileTransactedA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HANDLE FindFirstFileTransactedA(LPCSTR lpFileName, FINDEX_INFO_LEVELS fInfoLevelId, LPVOID lpFindFileData, FINDEX_SEARCH_OPS fSearchOp, LPVOID lpSearchFilter, DWORD dwAdditionalFlags, HANDLE hTransaction)
     * }
     */
    public static MethodHandle FindFirstFileTransactedA$handle() {
        return FindFirstFileTransactedA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * HANDLE FindFirstFileTransactedA(LPCSTR lpFileName, FINDEX_INFO_LEVELS fInfoLevelId, LPVOID lpFindFileData, FINDEX_SEARCH_OPS fSearchOp, LPVOID lpSearchFilter, DWORD dwAdditionalFlags, HANDLE hTransaction)
     * }
     */
    public static MemorySegment FindFirstFileTransactedA(MemorySegment lpFileName, int fInfoLevelId, MemorySegment lpFindFileData, int fSearchOp, MemorySegment lpSearchFilter, int dwAdditionalFlags, MemorySegment hTransaction) {
        var mh$ = FindFirstFileTransactedA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FindFirstFileTransactedA", lpFileName, fInfoLevelId, lpFindFileData, fSearchOp, lpSearchFilter, dwAdditionalFlags, hTransaction);
            }
            return (MemorySegment)mh$.invokeExact(lpFileName, fInfoLevelId, lpFindFileData, fSearchOp, lpSearchFilter, dwAdditionalFlags, hTransaction);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FindFirstFileTransactedW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER,
            C_INT,
            C_POINTER,
            C_INT,
            C_POINTER,
            C_LONG,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("FindFirstFileTransactedW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HANDLE FindFirstFileTransactedW(LPCWSTR lpFileName, FINDEX_INFO_LEVELS fInfoLevelId, LPVOID lpFindFileData, FINDEX_SEARCH_OPS fSearchOp, LPVOID lpSearchFilter, DWORD dwAdditionalFlags, HANDLE hTransaction)
     * }
     */
    public static FunctionDescriptor FindFirstFileTransactedW$descriptor() {
        return FindFirstFileTransactedW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HANDLE FindFirstFileTransactedW(LPCWSTR lpFileName, FINDEX_INFO_LEVELS fInfoLevelId, LPVOID lpFindFileData, FINDEX_SEARCH_OPS fSearchOp, LPVOID lpSearchFilter, DWORD dwAdditionalFlags, HANDLE hTransaction)
     * }
     */
    public static MethodHandle FindFirstFileTransactedW$handle() {
        return FindFirstFileTransactedW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * HANDLE FindFirstFileTransactedW(LPCWSTR lpFileName, FINDEX_INFO_LEVELS fInfoLevelId, LPVOID lpFindFileData, FINDEX_SEARCH_OPS fSearchOp, LPVOID lpSearchFilter, DWORD dwAdditionalFlags, HANDLE hTransaction)
     * }
     */
    public static MemorySegment FindFirstFileTransactedW(MemorySegment lpFileName, int fInfoLevelId, MemorySegment lpFindFileData, int fSearchOp, MemorySegment lpSearchFilter, int dwAdditionalFlags, MemorySegment hTransaction) {
        var mh$ = FindFirstFileTransactedW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FindFirstFileTransactedW", lpFileName, fInfoLevelId, lpFindFileData, fSearchOp, lpSearchFilter, dwAdditionalFlags, hTransaction);
            }
            return (MemorySegment)mh$.invokeExact(lpFileName, fInfoLevelId, lpFindFileData, fSearchOp, lpSearchFilter, dwAdditionalFlags, hTransaction);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CopyFileA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CopyFileA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CopyFileA(LPCSTR lpExistingFileName, LPCSTR lpNewFileName, BOOL bFailIfExists)
     * }
     */
    public static FunctionDescriptor CopyFileA$descriptor() {
        return CopyFileA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CopyFileA(LPCSTR lpExistingFileName, LPCSTR lpNewFileName, BOOL bFailIfExists)
     * }
     */
    public static MethodHandle CopyFileA$handle() {
        return CopyFileA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL CopyFileA(LPCSTR lpExistingFileName, LPCSTR lpNewFileName, BOOL bFailIfExists)
     * }
     */
    public static int CopyFileA(MemorySegment lpExistingFileName, MemorySegment lpNewFileName, int bFailIfExists) {
        var mh$ = CopyFileA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CopyFileA", lpExistingFileName, lpNewFileName, bFailIfExists);
            }
            return (int)mh$.invokeExact(lpExistingFileName, lpNewFileName, bFailIfExists);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CopyFileW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CopyFileW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CopyFileW(LPCWSTR lpExistingFileName, LPCWSTR lpNewFileName, BOOL bFailIfExists)
     * }
     */
    public static FunctionDescriptor CopyFileW$descriptor() {
        return CopyFileW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CopyFileW(LPCWSTR lpExistingFileName, LPCWSTR lpNewFileName, BOOL bFailIfExists)
     * }
     */
    public static MethodHandle CopyFileW$handle() {
        return CopyFileW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL CopyFileW(LPCWSTR lpExistingFileName, LPCWSTR lpNewFileName, BOOL bFailIfExists)
     * }
     */
    public static int CopyFileW(MemorySegment lpExistingFileName, MemorySegment lpNewFileName, int bFailIfExists) {
        var mh$ = CopyFileW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CopyFileW", lpExistingFileName, lpNewFileName, bFailIfExists);
            }
            return (int)mh$.invokeExact(lpExistingFileName, lpNewFileName, bFailIfExists);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CopyFileExA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CopyFileExA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CopyFileExA(LPCSTR lpExistingFileName, LPCSTR lpNewFileName, LPPROGRESS_ROUTINE lpProgressRoutine, LPVOID lpData, LPBOOL pbCancel, DWORD dwCopyFlags)
     * }
     */
    public static FunctionDescriptor CopyFileExA$descriptor() {
        return CopyFileExA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CopyFileExA(LPCSTR lpExistingFileName, LPCSTR lpNewFileName, LPPROGRESS_ROUTINE lpProgressRoutine, LPVOID lpData, LPBOOL pbCancel, DWORD dwCopyFlags)
     * }
     */
    public static MethodHandle CopyFileExA$handle() {
        return CopyFileExA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL CopyFileExA(LPCSTR lpExistingFileName, LPCSTR lpNewFileName, LPPROGRESS_ROUTINE lpProgressRoutine, LPVOID lpData, LPBOOL pbCancel, DWORD dwCopyFlags)
     * }
     */
    public static int CopyFileExA(MemorySegment lpExistingFileName, MemorySegment lpNewFileName, MemorySegment lpProgressRoutine, MemorySegment lpData, MemorySegment pbCancel, int dwCopyFlags) {
        var mh$ = CopyFileExA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CopyFileExA", lpExistingFileName, lpNewFileName, lpProgressRoutine, lpData, pbCancel, dwCopyFlags);
            }
            return (int)mh$.invokeExact(lpExistingFileName, lpNewFileName, lpProgressRoutine, lpData, pbCancel, dwCopyFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CopyFileExW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CopyFileExW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CopyFileExW(LPCWSTR lpExistingFileName, LPCWSTR lpNewFileName, LPPROGRESS_ROUTINE lpProgressRoutine, LPVOID lpData, LPBOOL pbCancel, DWORD dwCopyFlags)
     * }
     */
    public static FunctionDescriptor CopyFileExW$descriptor() {
        return CopyFileExW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CopyFileExW(LPCWSTR lpExistingFileName, LPCWSTR lpNewFileName, LPPROGRESS_ROUTINE lpProgressRoutine, LPVOID lpData, LPBOOL pbCancel, DWORD dwCopyFlags)
     * }
     */
    public static MethodHandle CopyFileExW$handle() {
        return CopyFileExW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL CopyFileExW(LPCWSTR lpExistingFileName, LPCWSTR lpNewFileName, LPPROGRESS_ROUTINE lpProgressRoutine, LPVOID lpData, LPBOOL pbCancel, DWORD dwCopyFlags)
     * }
     */
    public static int CopyFileExW(MemorySegment lpExistingFileName, MemorySegment lpNewFileName, MemorySegment lpProgressRoutine, MemorySegment lpData, MemorySegment pbCancel, int dwCopyFlags) {
        var mh$ = CopyFileExW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CopyFileExW", lpExistingFileName, lpNewFileName, lpProgressRoutine, lpData, pbCancel, dwCopyFlags);
            }
            return (int)mh$.invokeExact(lpExistingFileName, lpNewFileName, lpProgressRoutine, lpData, pbCancel, dwCopyFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CopyFileTransactedA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_LONG,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CopyFileTransactedA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CopyFileTransactedA(LPCSTR lpExistingFileName, LPCSTR lpNewFileName, LPPROGRESS_ROUTINE lpProgressRoutine, LPVOID lpData, LPBOOL pbCancel, DWORD dwCopyFlags, HANDLE hTransaction)
     * }
     */
    public static FunctionDescriptor CopyFileTransactedA$descriptor() {
        return CopyFileTransactedA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CopyFileTransactedA(LPCSTR lpExistingFileName, LPCSTR lpNewFileName, LPPROGRESS_ROUTINE lpProgressRoutine, LPVOID lpData, LPBOOL pbCancel, DWORD dwCopyFlags, HANDLE hTransaction)
     * }
     */
    public static MethodHandle CopyFileTransactedA$handle() {
        return CopyFileTransactedA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL CopyFileTransactedA(LPCSTR lpExistingFileName, LPCSTR lpNewFileName, LPPROGRESS_ROUTINE lpProgressRoutine, LPVOID lpData, LPBOOL pbCancel, DWORD dwCopyFlags, HANDLE hTransaction)
     * }
     */
    public static int CopyFileTransactedA(MemorySegment lpExistingFileName, MemorySegment lpNewFileName, MemorySegment lpProgressRoutine, MemorySegment lpData, MemorySegment pbCancel, int dwCopyFlags, MemorySegment hTransaction) {
        var mh$ = CopyFileTransactedA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CopyFileTransactedA", lpExistingFileName, lpNewFileName, lpProgressRoutine, lpData, pbCancel, dwCopyFlags, hTransaction);
            }
            return (int)mh$.invokeExact(lpExistingFileName, lpNewFileName, lpProgressRoutine, lpData, pbCancel, dwCopyFlags, hTransaction);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CopyFileTransactedW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_LONG,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CopyFileTransactedW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CopyFileTransactedW(LPCWSTR lpExistingFileName, LPCWSTR lpNewFileName, LPPROGRESS_ROUTINE lpProgressRoutine, LPVOID lpData, LPBOOL pbCancel, DWORD dwCopyFlags, HANDLE hTransaction)
     * }
     */
    public static FunctionDescriptor CopyFileTransactedW$descriptor() {
        return CopyFileTransactedW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CopyFileTransactedW(LPCWSTR lpExistingFileName, LPCWSTR lpNewFileName, LPPROGRESS_ROUTINE lpProgressRoutine, LPVOID lpData, LPBOOL pbCancel, DWORD dwCopyFlags, HANDLE hTransaction)
     * }
     */
    public static MethodHandle CopyFileTransactedW$handle() {
        return CopyFileTransactedW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL CopyFileTransactedW(LPCWSTR lpExistingFileName, LPCWSTR lpNewFileName, LPPROGRESS_ROUTINE lpProgressRoutine, LPVOID lpData, LPBOOL pbCancel, DWORD dwCopyFlags, HANDLE hTransaction)
     * }
     */
    public static int CopyFileTransactedW(MemorySegment lpExistingFileName, MemorySegment lpNewFileName, MemorySegment lpProgressRoutine, MemorySegment lpData, MemorySegment pbCancel, int dwCopyFlags, MemorySegment hTransaction) {
        var mh$ = CopyFileTransactedW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CopyFileTransactedW", lpExistingFileName, lpNewFileName, lpProgressRoutine, lpData, pbCancel, dwCopyFlags, hTransaction);
            }
            return (int)mh$.invokeExact(lpExistingFileName, lpNewFileName, lpProgressRoutine, lpData, pbCancel, dwCopyFlags, hTransaction);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int COPYFILE2_CALLBACK_NONE = (int)0L;
    /**
     * {@snippet lang=c :
     * enum _COPYFILE2_MESSAGE_TYPE.COPYFILE2_CALLBACK_NONE = 0
     * }
     */
    public static int COPYFILE2_CALLBACK_NONE() {
        return COPYFILE2_CALLBACK_NONE;
    }
    private static final int COPYFILE2_CALLBACK_CHUNK_STARTED = (int)1L;
    /**
     * {@snippet lang=c :
     * enum _COPYFILE2_MESSAGE_TYPE.COPYFILE2_CALLBACK_CHUNK_STARTED = 1
     * }
     */
    public static int COPYFILE2_CALLBACK_CHUNK_STARTED() {
        return COPYFILE2_CALLBACK_CHUNK_STARTED;
    }
    private static final int COPYFILE2_CALLBACK_CHUNK_FINISHED = (int)2L;
    /**
     * {@snippet lang=c :
     * enum _COPYFILE2_MESSAGE_TYPE.COPYFILE2_CALLBACK_CHUNK_FINISHED = 2
     * }
     */
    public static int COPYFILE2_CALLBACK_CHUNK_FINISHED() {
        return COPYFILE2_CALLBACK_CHUNK_FINISHED;
    }
    private static final int COPYFILE2_CALLBACK_STREAM_STARTED = (int)3L;
    /**
     * {@snippet lang=c :
     * enum _COPYFILE2_MESSAGE_TYPE.COPYFILE2_CALLBACK_STREAM_STARTED = 3
     * }
     */
    public static int COPYFILE2_CALLBACK_STREAM_STARTED() {
        return COPYFILE2_CALLBACK_STREAM_STARTED;
    }
    private static final int COPYFILE2_CALLBACK_STREAM_FINISHED = (int)4L;
    /**
     * {@snippet lang=c :
     * enum _COPYFILE2_MESSAGE_TYPE.COPYFILE2_CALLBACK_STREAM_FINISHED = 4
     * }
     */
    public static int COPYFILE2_CALLBACK_STREAM_FINISHED() {
        return COPYFILE2_CALLBACK_STREAM_FINISHED;
    }
    private static final int COPYFILE2_CALLBACK_POLL_CONTINUE = (int)5L;
    /**
     * {@snippet lang=c :
     * enum _COPYFILE2_MESSAGE_TYPE.COPYFILE2_CALLBACK_POLL_CONTINUE = 5
     * }
     */
    public static int COPYFILE2_CALLBACK_POLL_CONTINUE() {
        return COPYFILE2_CALLBACK_POLL_CONTINUE;
    }
    private static final int COPYFILE2_CALLBACK_ERROR = (int)6L;
    /**
     * {@snippet lang=c :
     * enum _COPYFILE2_MESSAGE_TYPE.COPYFILE2_CALLBACK_ERROR = 6
     * }
     */
    public static int COPYFILE2_CALLBACK_ERROR() {
        return COPYFILE2_CALLBACK_ERROR;
    }
    private static final int COPYFILE2_CALLBACK_MAX = (int)7L;
    /**
     * {@snippet lang=c :
     * enum _COPYFILE2_MESSAGE_TYPE.COPYFILE2_CALLBACK_MAX = 7
     * }
     */
    public static int COPYFILE2_CALLBACK_MAX() {
        return COPYFILE2_CALLBACK_MAX;
    }
    private static final int COPYFILE2_PROGRESS_CONTINUE = (int)0L;
    /**
     * {@snippet lang=c :
     * enum _COPYFILE2_MESSAGE_ACTION.COPYFILE2_PROGRESS_CONTINUE = 0
     * }
     */
    public static int COPYFILE2_PROGRESS_CONTINUE() {
        return COPYFILE2_PROGRESS_CONTINUE;
    }
    private static final int COPYFILE2_PROGRESS_CANCEL = (int)1L;
    /**
     * {@snippet lang=c :
     * enum _COPYFILE2_MESSAGE_ACTION.COPYFILE2_PROGRESS_CANCEL = 1
     * }
     */
    public static int COPYFILE2_PROGRESS_CANCEL() {
        return COPYFILE2_PROGRESS_CANCEL;
    }
    private static final int COPYFILE2_PROGRESS_STOP = (int)2L;
    /**
     * {@snippet lang=c :
     * enum _COPYFILE2_MESSAGE_ACTION.COPYFILE2_PROGRESS_STOP = 2
     * }
     */
    public static int COPYFILE2_PROGRESS_STOP() {
        return COPYFILE2_PROGRESS_STOP;
    }
    private static final int COPYFILE2_PROGRESS_QUIET = (int)3L;
    /**
     * {@snippet lang=c :
     * enum _COPYFILE2_MESSAGE_ACTION.COPYFILE2_PROGRESS_QUIET = 3
     * }
     */
    public static int COPYFILE2_PROGRESS_QUIET() {
        return COPYFILE2_PROGRESS_QUIET;
    }
    private static final int COPYFILE2_PROGRESS_PAUSE = (int)4L;
    /**
     * {@snippet lang=c :
     * enum _COPYFILE2_MESSAGE_ACTION.COPYFILE2_PROGRESS_PAUSE = 4
     * }
     */
    public static int COPYFILE2_PROGRESS_PAUSE() {
        return COPYFILE2_PROGRESS_PAUSE;
    }
    private static final int COPYFILE2_PHASE_NONE = (int)0L;
    /**
     * {@snippet lang=c :
     * enum _COPYFILE2_COPY_PHASE.COPYFILE2_PHASE_NONE = 0
     * }
     */
    public static int COPYFILE2_PHASE_NONE() {
        return COPYFILE2_PHASE_NONE;
    }
    private static final int COPYFILE2_PHASE_PREPARE_SOURCE = (int)1L;
    /**
     * {@snippet lang=c :
     * enum _COPYFILE2_COPY_PHASE.COPYFILE2_PHASE_PREPARE_SOURCE = 1
     * }
     */
    public static int COPYFILE2_PHASE_PREPARE_SOURCE() {
        return COPYFILE2_PHASE_PREPARE_SOURCE;
    }
    private static final int COPYFILE2_PHASE_PREPARE_DEST = (int)2L;
    /**
     * {@snippet lang=c :
     * enum _COPYFILE2_COPY_PHASE.COPYFILE2_PHASE_PREPARE_DEST = 2
     * }
     */
    public static int COPYFILE2_PHASE_PREPARE_DEST() {
        return COPYFILE2_PHASE_PREPARE_DEST;
    }
    private static final int COPYFILE2_PHASE_READ_SOURCE = (int)3L;
    /**
     * {@snippet lang=c :
     * enum _COPYFILE2_COPY_PHASE.COPYFILE2_PHASE_READ_SOURCE = 3
     * }
     */
    public static int COPYFILE2_PHASE_READ_SOURCE() {
        return COPYFILE2_PHASE_READ_SOURCE;
    }
    private static final int COPYFILE2_PHASE_WRITE_DESTINATION = (int)4L;
    /**
     * {@snippet lang=c :
     * enum _COPYFILE2_COPY_PHASE.COPYFILE2_PHASE_WRITE_DESTINATION = 4
     * }
     */
    public static int COPYFILE2_PHASE_WRITE_DESTINATION() {
        return COPYFILE2_PHASE_WRITE_DESTINATION;
    }
    private static final int COPYFILE2_PHASE_SERVER_COPY = (int)5L;
    /**
     * {@snippet lang=c :
     * enum _COPYFILE2_COPY_PHASE.COPYFILE2_PHASE_SERVER_COPY = 5
     * }
     */
    public static int COPYFILE2_PHASE_SERVER_COPY() {
        return COPYFILE2_PHASE_SERVER_COPY;
    }
    private static final int COPYFILE2_PHASE_NAMEGRAFT_COPY = (int)6L;
    /**
     * {@snippet lang=c :
     * enum _COPYFILE2_COPY_PHASE.COPYFILE2_PHASE_NAMEGRAFT_COPY = 6
     * }
     */
    public static int COPYFILE2_PHASE_NAMEGRAFT_COPY() {
        return COPYFILE2_PHASE_NAMEGRAFT_COPY;
    }
    private static final int COPYFILE2_PHASE_MAX = (int)7L;
    /**
     * {@snippet lang=c :
     * enum _COPYFILE2_COPY_PHASE.COPYFILE2_PHASE_MAX = 7
     * }
     */
    public static int COPYFILE2_PHASE_MAX() {
        return COPYFILE2_PHASE_MAX;
    }

    private static class CopyFile2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CopyFile2"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HRESULT CopyFile2(PCWSTR pwszExistingFileName, PCWSTR pwszNewFileName, COPYFILE2_EXTENDED_PARAMETERS *pExtendedParameters)
     * }
     */
    public static FunctionDescriptor CopyFile2$descriptor() {
        return CopyFile2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HRESULT CopyFile2(PCWSTR pwszExistingFileName, PCWSTR pwszNewFileName, COPYFILE2_EXTENDED_PARAMETERS *pExtendedParameters)
     * }
     */
    public static MethodHandle CopyFile2$handle() {
        return CopyFile2.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * HRESULT CopyFile2(PCWSTR pwszExistingFileName, PCWSTR pwszNewFileName, COPYFILE2_EXTENDED_PARAMETERS *pExtendedParameters)
     * }
     */
    public static int CopyFile2(MemorySegment pwszExistingFileName, MemorySegment pwszNewFileName, MemorySegment pExtendedParameters) {
        var mh$ = CopyFile2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CopyFile2", pwszExistingFileName, pwszNewFileName, pExtendedParameters);
            }
            return (int)mh$.invokeExact(pwszExistingFileName, pwszNewFileName, pExtendedParameters);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MoveFileA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("MoveFileA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL MoveFileA(LPCSTR lpExistingFileName, LPCSTR lpNewFileName)
     * }
     */
    public static FunctionDescriptor MoveFileA$descriptor() {
        return MoveFileA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL MoveFileA(LPCSTR lpExistingFileName, LPCSTR lpNewFileName)
     * }
     */
    public static MethodHandle MoveFileA$handle() {
        return MoveFileA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL MoveFileA(LPCSTR lpExistingFileName, LPCSTR lpNewFileName)
     * }
     */
    public static int MoveFileA(MemorySegment lpExistingFileName, MemorySegment lpNewFileName) {
        var mh$ = MoveFileA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MoveFileA", lpExistingFileName, lpNewFileName);
            }
            return (int)mh$.invokeExact(lpExistingFileName, lpNewFileName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MoveFileW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("MoveFileW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL MoveFileW(LPCWSTR lpExistingFileName, LPCWSTR lpNewFileName)
     * }
     */
    public static FunctionDescriptor MoveFileW$descriptor() {
        return MoveFileW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL MoveFileW(LPCWSTR lpExistingFileName, LPCWSTR lpNewFileName)
     * }
     */
    public static MethodHandle MoveFileW$handle() {
        return MoveFileW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL MoveFileW(LPCWSTR lpExistingFileName, LPCWSTR lpNewFileName)
     * }
     */
    public static int MoveFileW(MemorySegment lpExistingFileName, MemorySegment lpNewFileName) {
        var mh$ = MoveFileW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MoveFileW", lpExistingFileName, lpNewFileName);
            }
            return (int)mh$.invokeExact(lpExistingFileName, lpNewFileName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MoveFileExA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("MoveFileExA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL MoveFileExA(LPCSTR lpExistingFileName, LPCSTR lpNewFileName, DWORD dwFlags)
     * }
     */
    public static FunctionDescriptor MoveFileExA$descriptor() {
        return MoveFileExA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL MoveFileExA(LPCSTR lpExistingFileName, LPCSTR lpNewFileName, DWORD dwFlags)
     * }
     */
    public static MethodHandle MoveFileExA$handle() {
        return MoveFileExA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL MoveFileExA(LPCSTR lpExistingFileName, LPCSTR lpNewFileName, DWORD dwFlags)
     * }
     */
    public static int MoveFileExA(MemorySegment lpExistingFileName, MemorySegment lpNewFileName, int dwFlags) {
        var mh$ = MoveFileExA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MoveFileExA", lpExistingFileName, lpNewFileName, dwFlags);
            }
            return (int)mh$.invokeExact(lpExistingFileName, lpNewFileName, dwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MoveFileExW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("MoveFileExW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL MoveFileExW(LPCWSTR lpExistingFileName, LPCWSTR lpNewFileName, DWORD dwFlags)
     * }
     */
    public static FunctionDescriptor MoveFileExW$descriptor() {
        return MoveFileExW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL MoveFileExW(LPCWSTR lpExistingFileName, LPCWSTR lpNewFileName, DWORD dwFlags)
     * }
     */
    public static MethodHandle MoveFileExW$handle() {
        return MoveFileExW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL MoveFileExW(LPCWSTR lpExistingFileName, LPCWSTR lpNewFileName, DWORD dwFlags)
     * }
     */
    public static int MoveFileExW(MemorySegment lpExistingFileName, MemorySegment lpNewFileName, int dwFlags) {
        var mh$ = MoveFileExW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MoveFileExW", lpExistingFileName, lpNewFileName, dwFlags);
            }
            return (int)mh$.invokeExact(lpExistingFileName, lpNewFileName, dwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MoveFileWithProgressA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("MoveFileWithProgressA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL MoveFileWithProgressA(LPCSTR lpExistingFileName, LPCSTR lpNewFileName, LPPROGRESS_ROUTINE lpProgressRoutine, LPVOID lpData, DWORD dwFlags)
     * }
     */
    public static FunctionDescriptor MoveFileWithProgressA$descriptor() {
        return MoveFileWithProgressA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL MoveFileWithProgressA(LPCSTR lpExistingFileName, LPCSTR lpNewFileName, LPPROGRESS_ROUTINE lpProgressRoutine, LPVOID lpData, DWORD dwFlags)
     * }
     */
    public static MethodHandle MoveFileWithProgressA$handle() {
        return MoveFileWithProgressA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL MoveFileWithProgressA(LPCSTR lpExistingFileName, LPCSTR lpNewFileName, LPPROGRESS_ROUTINE lpProgressRoutine, LPVOID lpData, DWORD dwFlags)
     * }
     */
    public static int MoveFileWithProgressA(MemorySegment lpExistingFileName, MemorySegment lpNewFileName, MemorySegment lpProgressRoutine, MemorySegment lpData, int dwFlags) {
        var mh$ = MoveFileWithProgressA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MoveFileWithProgressA", lpExistingFileName, lpNewFileName, lpProgressRoutine, lpData, dwFlags);
            }
            return (int)mh$.invokeExact(lpExistingFileName, lpNewFileName, lpProgressRoutine, lpData, dwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MoveFileWithProgressW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("MoveFileWithProgressW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL MoveFileWithProgressW(LPCWSTR lpExistingFileName, LPCWSTR lpNewFileName, LPPROGRESS_ROUTINE lpProgressRoutine, LPVOID lpData, DWORD dwFlags)
     * }
     */
    public static FunctionDescriptor MoveFileWithProgressW$descriptor() {
        return MoveFileWithProgressW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL MoveFileWithProgressW(LPCWSTR lpExistingFileName, LPCWSTR lpNewFileName, LPPROGRESS_ROUTINE lpProgressRoutine, LPVOID lpData, DWORD dwFlags)
     * }
     */
    public static MethodHandle MoveFileWithProgressW$handle() {
        return MoveFileWithProgressW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL MoveFileWithProgressW(LPCWSTR lpExistingFileName, LPCWSTR lpNewFileName, LPPROGRESS_ROUTINE lpProgressRoutine, LPVOID lpData, DWORD dwFlags)
     * }
     */
    public static int MoveFileWithProgressW(MemorySegment lpExistingFileName, MemorySegment lpNewFileName, MemorySegment lpProgressRoutine, MemorySegment lpData, int dwFlags) {
        var mh$ = MoveFileWithProgressW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MoveFileWithProgressW", lpExistingFileName, lpNewFileName, lpProgressRoutine, lpData, dwFlags);
            }
            return (int)mh$.invokeExact(lpExistingFileName, lpNewFileName, lpProgressRoutine, lpData, dwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MoveFileTransactedA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_LONG,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("MoveFileTransactedA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL MoveFileTransactedA(LPCSTR lpExistingFileName, LPCSTR lpNewFileName, LPPROGRESS_ROUTINE lpProgressRoutine, LPVOID lpData, DWORD dwFlags, HANDLE hTransaction)
     * }
     */
    public static FunctionDescriptor MoveFileTransactedA$descriptor() {
        return MoveFileTransactedA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL MoveFileTransactedA(LPCSTR lpExistingFileName, LPCSTR lpNewFileName, LPPROGRESS_ROUTINE lpProgressRoutine, LPVOID lpData, DWORD dwFlags, HANDLE hTransaction)
     * }
     */
    public static MethodHandle MoveFileTransactedA$handle() {
        return MoveFileTransactedA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL MoveFileTransactedA(LPCSTR lpExistingFileName, LPCSTR lpNewFileName, LPPROGRESS_ROUTINE lpProgressRoutine, LPVOID lpData, DWORD dwFlags, HANDLE hTransaction)
     * }
     */
    public static int MoveFileTransactedA(MemorySegment lpExistingFileName, MemorySegment lpNewFileName, MemorySegment lpProgressRoutine, MemorySegment lpData, int dwFlags, MemorySegment hTransaction) {
        var mh$ = MoveFileTransactedA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MoveFileTransactedA", lpExistingFileName, lpNewFileName, lpProgressRoutine, lpData, dwFlags, hTransaction);
            }
            return (int)mh$.invokeExact(lpExistingFileName, lpNewFileName, lpProgressRoutine, lpData, dwFlags, hTransaction);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MoveFileTransactedW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_LONG,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("MoveFileTransactedW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL MoveFileTransactedW(LPCWSTR lpExistingFileName, LPCWSTR lpNewFileName, LPPROGRESS_ROUTINE lpProgressRoutine, LPVOID lpData, DWORD dwFlags, HANDLE hTransaction)
     * }
     */
    public static FunctionDescriptor MoveFileTransactedW$descriptor() {
        return MoveFileTransactedW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL MoveFileTransactedW(LPCWSTR lpExistingFileName, LPCWSTR lpNewFileName, LPPROGRESS_ROUTINE lpProgressRoutine, LPVOID lpData, DWORD dwFlags, HANDLE hTransaction)
     * }
     */
    public static MethodHandle MoveFileTransactedW$handle() {
        return MoveFileTransactedW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL MoveFileTransactedW(LPCWSTR lpExistingFileName, LPCWSTR lpNewFileName, LPPROGRESS_ROUTINE lpProgressRoutine, LPVOID lpData, DWORD dwFlags, HANDLE hTransaction)
     * }
     */
    public static int MoveFileTransactedW(MemorySegment lpExistingFileName, MemorySegment lpNewFileName, MemorySegment lpProgressRoutine, MemorySegment lpData, int dwFlags, MemorySegment hTransaction) {
        var mh$ = MoveFileTransactedW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MoveFileTransactedW", lpExistingFileName, lpNewFileName, lpProgressRoutine, lpData, dwFlags, hTransaction);
            }
            return (int)mh$.invokeExact(lpExistingFileName, lpNewFileName, lpProgressRoutine, lpData, dwFlags, hTransaction);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ReplaceFileA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_LONG,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("ReplaceFileA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL ReplaceFileA(LPCSTR lpReplacedFileName, LPCSTR lpReplacementFileName, LPCSTR lpBackupFileName, DWORD dwReplaceFlags, LPVOID lpExclude, LPVOID lpReserved)
     * }
     */
    public static FunctionDescriptor ReplaceFileA$descriptor() {
        return ReplaceFileA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL ReplaceFileA(LPCSTR lpReplacedFileName, LPCSTR lpReplacementFileName, LPCSTR lpBackupFileName, DWORD dwReplaceFlags, LPVOID lpExclude, LPVOID lpReserved)
     * }
     */
    public static MethodHandle ReplaceFileA$handle() {
        return ReplaceFileA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL ReplaceFileA(LPCSTR lpReplacedFileName, LPCSTR lpReplacementFileName, LPCSTR lpBackupFileName, DWORD dwReplaceFlags, LPVOID lpExclude, LPVOID lpReserved)
     * }
     */
    public static int ReplaceFileA(MemorySegment lpReplacedFileName, MemorySegment lpReplacementFileName, MemorySegment lpBackupFileName, int dwReplaceFlags, MemorySegment lpExclude, MemorySegment lpReserved) {
        var mh$ = ReplaceFileA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ReplaceFileA", lpReplacedFileName, lpReplacementFileName, lpBackupFileName, dwReplaceFlags, lpExclude, lpReserved);
            }
            return (int)mh$.invokeExact(lpReplacedFileName, lpReplacementFileName, lpBackupFileName, dwReplaceFlags, lpExclude, lpReserved);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ReplaceFileW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_LONG,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("ReplaceFileW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL ReplaceFileW(LPCWSTR lpReplacedFileName, LPCWSTR lpReplacementFileName, LPCWSTR lpBackupFileName, DWORD dwReplaceFlags, LPVOID lpExclude, LPVOID lpReserved)
     * }
     */
    public static FunctionDescriptor ReplaceFileW$descriptor() {
        return ReplaceFileW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL ReplaceFileW(LPCWSTR lpReplacedFileName, LPCWSTR lpReplacementFileName, LPCWSTR lpBackupFileName, DWORD dwReplaceFlags, LPVOID lpExclude, LPVOID lpReserved)
     * }
     */
    public static MethodHandle ReplaceFileW$handle() {
        return ReplaceFileW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL ReplaceFileW(LPCWSTR lpReplacedFileName, LPCWSTR lpReplacementFileName, LPCWSTR lpBackupFileName, DWORD dwReplaceFlags, LPVOID lpExclude, LPVOID lpReserved)
     * }
     */
    public static int ReplaceFileW(MemorySegment lpReplacedFileName, MemorySegment lpReplacementFileName, MemorySegment lpBackupFileName, int dwReplaceFlags, MemorySegment lpExclude, MemorySegment lpReserved) {
        var mh$ = ReplaceFileW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ReplaceFileW", lpReplacedFileName, lpReplacementFileName, lpBackupFileName, dwReplaceFlags, lpExclude, lpReserved);
            }
            return (int)mh$.invokeExact(lpReplacedFileName, lpReplacementFileName, lpBackupFileName, dwReplaceFlags, lpExclude, lpReserved);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateHardLinkA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CreateHardLinkA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CreateHardLinkA(LPCSTR lpFileName, LPCSTR lpExistingFileName, LPSECURITY_ATTRIBUTES lpSecurityAttributes)
     * }
     */
    public static FunctionDescriptor CreateHardLinkA$descriptor() {
        return CreateHardLinkA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CreateHardLinkA(LPCSTR lpFileName, LPCSTR lpExistingFileName, LPSECURITY_ATTRIBUTES lpSecurityAttributes)
     * }
     */
    public static MethodHandle CreateHardLinkA$handle() {
        return CreateHardLinkA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL CreateHardLinkA(LPCSTR lpFileName, LPCSTR lpExistingFileName, LPSECURITY_ATTRIBUTES lpSecurityAttributes)
     * }
     */
    public static int CreateHardLinkA(MemorySegment lpFileName, MemorySegment lpExistingFileName, MemorySegment lpSecurityAttributes) {
        var mh$ = CreateHardLinkA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateHardLinkA", lpFileName, lpExistingFileName, lpSecurityAttributes);
            }
            return (int)mh$.invokeExact(lpFileName, lpExistingFileName, lpSecurityAttributes);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateHardLinkW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CreateHardLinkW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CreateHardLinkW(LPCWSTR lpFileName, LPCWSTR lpExistingFileName, LPSECURITY_ATTRIBUTES lpSecurityAttributes)
     * }
     */
    public static FunctionDescriptor CreateHardLinkW$descriptor() {
        return CreateHardLinkW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CreateHardLinkW(LPCWSTR lpFileName, LPCWSTR lpExistingFileName, LPSECURITY_ATTRIBUTES lpSecurityAttributes)
     * }
     */
    public static MethodHandle CreateHardLinkW$handle() {
        return CreateHardLinkW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL CreateHardLinkW(LPCWSTR lpFileName, LPCWSTR lpExistingFileName, LPSECURITY_ATTRIBUTES lpSecurityAttributes)
     * }
     */
    public static int CreateHardLinkW(MemorySegment lpFileName, MemorySegment lpExistingFileName, MemorySegment lpSecurityAttributes) {
        var mh$ = CreateHardLinkW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateHardLinkW", lpFileName, lpExistingFileName, lpSecurityAttributes);
            }
            return (int)mh$.invokeExact(lpFileName, lpExistingFileName, lpSecurityAttributes);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateHardLinkTransactedA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CreateHardLinkTransactedA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CreateHardLinkTransactedA(LPCSTR lpFileName, LPCSTR lpExistingFileName, LPSECURITY_ATTRIBUTES lpSecurityAttributes, HANDLE hTransaction)
     * }
     */
    public static FunctionDescriptor CreateHardLinkTransactedA$descriptor() {
        return CreateHardLinkTransactedA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CreateHardLinkTransactedA(LPCSTR lpFileName, LPCSTR lpExistingFileName, LPSECURITY_ATTRIBUTES lpSecurityAttributes, HANDLE hTransaction)
     * }
     */
    public static MethodHandle CreateHardLinkTransactedA$handle() {
        return CreateHardLinkTransactedA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL CreateHardLinkTransactedA(LPCSTR lpFileName, LPCSTR lpExistingFileName, LPSECURITY_ATTRIBUTES lpSecurityAttributes, HANDLE hTransaction)
     * }
     */
    public static int CreateHardLinkTransactedA(MemorySegment lpFileName, MemorySegment lpExistingFileName, MemorySegment lpSecurityAttributes, MemorySegment hTransaction) {
        var mh$ = CreateHardLinkTransactedA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateHardLinkTransactedA", lpFileName, lpExistingFileName, lpSecurityAttributes, hTransaction);
            }
            return (int)mh$.invokeExact(lpFileName, lpExistingFileName, lpSecurityAttributes, hTransaction);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateHardLinkTransactedW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CreateHardLinkTransactedW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CreateHardLinkTransactedW(LPCWSTR lpFileName, LPCWSTR lpExistingFileName, LPSECURITY_ATTRIBUTES lpSecurityAttributes, HANDLE hTransaction)
     * }
     */
    public static FunctionDescriptor CreateHardLinkTransactedW$descriptor() {
        return CreateHardLinkTransactedW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CreateHardLinkTransactedW(LPCWSTR lpFileName, LPCWSTR lpExistingFileName, LPSECURITY_ATTRIBUTES lpSecurityAttributes, HANDLE hTransaction)
     * }
     */
    public static MethodHandle CreateHardLinkTransactedW$handle() {
        return CreateHardLinkTransactedW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL CreateHardLinkTransactedW(LPCWSTR lpFileName, LPCWSTR lpExistingFileName, LPSECURITY_ATTRIBUTES lpSecurityAttributes, HANDLE hTransaction)
     * }
     */
    public static int CreateHardLinkTransactedW(MemorySegment lpFileName, MemorySegment lpExistingFileName, MemorySegment lpSecurityAttributes, MemorySegment hTransaction) {
        var mh$ = CreateHardLinkTransactedW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateHardLinkTransactedW", lpFileName, lpExistingFileName, lpSecurityAttributes, hTransaction);
            }
            return (int)mh$.invokeExact(lpFileName, lpExistingFileName, lpSecurityAttributes, hTransaction);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FindFirstStreamTransactedW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER,
            C_INT,
            C_POINTER,
            C_LONG,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("FindFirstStreamTransactedW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HANDLE FindFirstStreamTransactedW(LPCWSTR lpFileName, STREAM_INFO_LEVELS InfoLevel, LPVOID lpFindStreamData, DWORD dwFlags, HANDLE hTransaction)
     * }
     */
    public static FunctionDescriptor FindFirstStreamTransactedW$descriptor() {
        return FindFirstStreamTransactedW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HANDLE FindFirstStreamTransactedW(LPCWSTR lpFileName, STREAM_INFO_LEVELS InfoLevel, LPVOID lpFindStreamData, DWORD dwFlags, HANDLE hTransaction)
     * }
     */
    public static MethodHandle FindFirstStreamTransactedW$handle() {
        return FindFirstStreamTransactedW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * HANDLE FindFirstStreamTransactedW(LPCWSTR lpFileName, STREAM_INFO_LEVELS InfoLevel, LPVOID lpFindStreamData, DWORD dwFlags, HANDLE hTransaction)
     * }
     */
    public static MemorySegment FindFirstStreamTransactedW(MemorySegment lpFileName, int InfoLevel, MemorySegment lpFindStreamData, int dwFlags, MemorySegment hTransaction) {
        var mh$ = FindFirstStreamTransactedW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FindFirstStreamTransactedW", lpFileName, InfoLevel, lpFindStreamData, dwFlags, hTransaction);
            }
            return (MemorySegment)mh$.invokeExact(lpFileName, InfoLevel, lpFindStreamData, dwFlags, hTransaction);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FindFirstFileNameTransactedW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER,
            C_LONG,
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("FindFirstFileNameTransactedW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HANDLE FindFirstFileNameTransactedW(LPCWSTR lpFileName, DWORD dwFlags, LPDWORD StringLength, PWSTR LinkName, HANDLE hTransaction)
     * }
     */
    public static FunctionDescriptor FindFirstFileNameTransactedW$descriptor() {
        return FindFirstFileNameTransactedW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HANDLE FindFirstFileNameTransactedW(LPCWSTR lpFileName, DWORD dwFlags, LPDWORD StringLength, PWSTR LinkName, HANDLE hTransaction)
     * }
     */
    public static MethodHandle FindFirstFileNameTransactedW$handle() {
        return FindFirstFileNameTransactedW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * HANDLE FindFirstFileNameTransactedW(LPCWSTR lpFileName, DWORD dwFlags, LPDWORD StringLength, PWSTR LinkName, HANDLE hTransaction)
     * }
     */
    public static MemorySegment FindFirstFileNameTransactedW(MemorySegment lpFileName, int dwFlags, MemorySegment StringLength, MemorySegment LinkName, MemorySegment hTransaction) {
        var mh$ = FindFirstFileNameTransactedW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FindFirstFileNameTransactedW", lpFileName, dwFlags, StringLength, LinkName, hTransaction);
            }
            return (MemorySegment)mh$.invokeExact(lpFileName, dwFlags, StringLength, LinkName, hTransaction);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateNamedPipeA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER,
            C_LONG,
            C_LONG,
            C_LONG,
            C_LONG,
            C_LONG,
            C_LONG,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CreateNamedPipeA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HANDLE CreateNamedPipeA(LPCSTR lpName, DWORD dwOpenMode, DWORD dwPipeMode, DWORD nMaxInstances, DWORD nOutBufferSize, DWORD nInBufferSize, DWORD nDefaultTimeOut, LPSECURITY_ATTRIBUTES lpSecurityAttributes)
     * }
     */
    public static FunctionDescriptor CreateNamedPipeA$descriptor() {
        return CreateNamedPipeA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HANDLE CreateNamedPipeA(LPCSTR lpName, DWORD dwOpenMode, DWORD dwPipeMode, DWORD nMaxInstances, DWORD nOutBufferSize, DWORD nInBufferSize, DWORD nDefaultTimeOut, LPSECURITY_ATTRIBUTES lpSecurityAttributes)
     * }
     */
    public static MethodHandle CreateNamedPipeA$handle() {
        return CreateNamedPipeA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * HANDLE CreateNamedPipeA(LPCSTR lpName, DWORD dwOpenMode, DWORD dwPipeMode, DWORD nMaxInstances, DWORD nOutBufferSize, DWORD nInBufferSize, DWORD nDefaultTimeOut, LPSECURITY_ATTRIBUTES lpSecurityAttributes)
     * }
     */
    public static MemorySegment CreateNamedPipeA(MemorySegment lpName, int dwOpenMode, int dwPipeMode, int nMaxInstances, int nOutBufferSize, int nInBufferSize, int nDefaultTimeOut, MemorySegment lpSecurityAttributes) {
        var mh$ = CreateNamedPipeA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateNamedPipeA", lpName, dwOpenMode, dwPipeMode, nMaxInstances, nOutBufferSize, nInBufferSize, nDefaultTimeOut, lpSecurityAttributes);
            }
            return (MemorySegment)mh$.invokeExact(lpName, dwOpenMode, dwPipeMode, nMaxInstances, nOutBufferSize, nInBufferSize, nDefaultTimeOut, lpSecurityAttributes);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetNamedPipeHandleStateA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetNamedPipeHandleStateA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetNamedPipeHandleStateA(HANDLE hNamedPipe, LPDWORD lpState, LPDWORD lpCurInstances, LPDWORD lpMaxCollectionCount, LPDWORD lpCollectDataTimeout, LPSTR lpUserName, DWORD nMaxUserNameSize)
     * }
     */
    public static FunctionDescriptor GetNamedPipeHandleStateA$descriptor() {
        return GetNamedPipeHandleStateA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetNamedPipeHandleStateA(HANDLE hNamedPipe, LPDWORD lpState, LPDWORD lpCurInstances, LPDWORD lpMaxCollectionCount, LPDWORD lpCollectDataTimeout, LPSTR lpUserName, DWORD nMaxUserNameSize)
     * }
     */
    public static MethodHandle GetNamedPipeHandleStateA$handle() {
        return GetNamedPipeHandleStateA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL GetNamedPipeHandleStateA(HANDLE hNamedPipe, LPDWORD lpState, LPDWORD lpCurInstances, LPDWORD lpMaxCollectionCount, LPDWORD lpCollectDataTimeout, LPSTR lpUserName, DWORD nMaxUserNameSize)
     * }
     */
    public static int GetNamedPipeHandleStateA(MemorySegment hNamedPipe, MemorySegment lpState, MemorySegment lpCurInstances, MemorySegment lpMaxCollectionCount, MemorySegment lpCollectDataTimeout, MemorySegment lpUserName, int nMaxUserNameSize) {
        var mh$ = GetNamedPipeHandleStateA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetNamedPipeHandleStateA", hNamedPipe, lpState, lpCurInstances, lpMaxCollectionCount, lpCollectDataTimeout, lpUserName, nMaxUserNameSize);
            }
            return (int)mh$.invokeExact(hNamedPipe, lpState, lpCurInstances, lpMaxCollectionCount, lpCollectDataTimeout, lpUserName, nMaxUserNameSize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CallNamedPipeA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_LONG,
            C_POINTER,
            C_LONG,
            C_POINTER,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CallNamedPipeA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CallNamedPipeA(LPCSTR lpNamedPipeName, LPVOID lpInBuffer, DWORD nInBufferSize, LPVOID lpOutBuffer, DWORD nOutBufferSize, LPDWORD lpBytesRead, DWORD nTimeOut)
     * }
     */
    public static FunctionDescriptor CallNamedPipeA$descriptor() {
        return CallNamedPipeA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CallNamedPipeA(LPCSTR lpNamedPipeName, LPVOID lpInBuffer, DWORD nInBufferSize, LPVOID lpOutBuffer, DWORD nOutBufferSize, LPDWORD lpBytesRead, DWORD nTimeOut)
     * }
     */
    public static MethodHandle CallNamedPipeA$handle() {
        return CallNamedPipeA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL CallNamedPipeA(LPCSTR lpNamedPipeName, LPVOID lpInBuffer, DWORD nInBufferSize, LPVOID lpOutBuffer, DWORD nOutBufferSize, LPDWORD lpBytesRead, DWORD nTimeOut)
     * }
     */
    public static int CallNamedPipeA(MemorySegment lpNamedPipeName, MemorySegment lpInBuffer, int nInBufferSize, MemorySegment lpOutBuffer, int nOutBufferSize, MemorySegment lpBytesRead, int nTimeOut) {
        var mh$ = CallNamedPipeA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CallNamedPipeA", lpNamedPipeName, lpInBuffer, nInBufferSize, lpOutBuffer, nOutBufferSize, lpBytesRead, nTimeOut);
            }
            return (int)mh$.invokeExact(lpNamedPipeName, lpInBuffer, nInBufferSize, lpOutBuffer, nOutBufferSize, lpBytesRead, nTimeOut);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class WaitNamedPipeA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("WaitNamedPipeA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL WaitNamedPipeA(LPCSTR lpNamedPipeName, DWORD nTimeOut)
     * }
     */
    public static FunctionDescriptor WaitNamedPipeA$descriptor() {
        return WaitNamedPipeA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL WaitNamedPipeA(LPCSTR lpNamedPipeName, DWORD nTimeOut)
     * }
     */
    public static MethodHandle WaitNamedPipeA$handle() {
        return WaitNamedPipeA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL WaitNamedPipeA(LPCSTR lpNamedPipeName, DWORD nTimeOut)
     * }
     */
    public static int WaitNamedPipeA(MemorySegment lpNamedPipeName, int nTimeOut) {
        var mh$ = WaitNamedPipeA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WaitNamedPipeA", lpNamedPipeName, nTimeOut);
            }
            return (int)mh$.invokeExact(lpNamedPipeName, nTimeOut);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetNamedPipeClientComputerNameA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetNamedPipeClientComputerNameA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetNamedPipeClientComputerNameA(HANDLE Pipe, LPSTR ClientComputerName, ULONG ClientComputerNameLength)
     * }
     */
    public static FunctionDescriptor GetNamedPipeClientComputerNameA$descriptor() {
        return GetNamedPipeClientComputerNameA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetNamedPipeClientComputerNameA(HANDLE Pipe, LPSTR ClientComputerName, ULONG ClientComputerNameLength)
     * }
     */
    public static MethodHandle GetNamedPipeClientComputerNameA$handle() {
        return GetNamedPipeClientComputerNameA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL GetNamedPipeClientComputerNameA(HANDLE Pipe, LPSTR ClientComputerName, ULONG ClientComputerNameLength)
     * }
     */
    public static int GetNamedPipeClientComputerNameA(MemorySegment Pipe, MemorySegment ClientComputerName, int ClientComputerNameLength) {
        var mh$ = GetNamedPipeClientComputerNameA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetNamedPipeClientComputerNameA", Pipe, ClientComputerName, ClientComputerNameLength);
            }
            return (int)mh$.invokeExact(Pipe, ClientComputerName, ClientComputerNameLength);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetNamedPipeClientProcessId {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetNamedPipeClientProcessId"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetNamedPipeClientProcessId(HANDLE Pipe, PULONG ClientProcessId)
     * }
     */
    public static FunctionDescriptor GetNamedPipeClientProcessId$descriptor() {
        return GetNamedPipeClientProcessId.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetNamedPipeClientProcessId(HANDLE Pipe, PULONG ClientProcessId)
     * }
     */
    public static MethodHandle GetNamedPipeClientProcessId$handle() {
        return GetNamedPipeClientProcessId.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL GetNamedPipeClientProcessId(HANDLE Pipe, PULONG ClientProcessId)
     * }
     */
    public static int GetNamedPipeClientProcessId(MemorySegment Pipe, MemorySegment ClientProcessId) {
        var mh$ = GetNamedPipeClientProcessId.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetNamedPipeClientProcessId", Pipe, ClientProcessId);
            }
            return (int)mh$.invokeExact(Pipe, ClientProcessId);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetNamedPipeClientSessionId {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetNamedPipeClientSessionId"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetNamedPipeClientSessionId(HANDLE Pipe, PULONG ClientSessionId)
     * }
     */
    public static FunctionDescriptor GetNamedPipeClientSessionId$descriptor() {
        return GetNamedPipeClientSessionId.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetNamedPipeClientSessionId(HANDLE Pipe, PULONG ClientSessionId)
     * }
     */
    public static MethodHandle GetNamedPipeClientSessionId$handle() {
        return GetNamedPipeClientSessionId.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL GetNamedPipeClientSessionId(HANDLE Pipe, PULONG ClientSessionId)
     * }
     */
    public static int GetNamedPipeClientSessionId(MemorySegment Pipe, MemorySegment ClientSessionId) {
        var mh$ = GetNamedPipeClientSessionId.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetNamedPipeClientSessionId", Pipe, ClientSessionId);
            }
            return (int)mh$.invokeExact(Pipe, ClientSessionId);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetNamedPipeServerProcessId {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetNamedPipeServerProcessId"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetNamedPipeServerProcessId(HANDLE Pipe, PULONG ServerProcessId)
     * }
     */
    public static FunctionDescriptor GetNamedPipeServerProcessId$descriptor() {
        return GetNamedPipeServerProcessId.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetNamedPipeServerProcessId(HANDLE Pipe, PULONG ServerProcessId)
     * }
     */
    public static MethodHandle GetNamedPipeServerProcessId$handle() {
        return GetNamedPipeServerProcessId.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL GetNamedPipeServerProcessId(HANDLE Pipe, PULONG ServerProcessId)
     * }
     */
    public static int GetNamedPipeServerProcessId(MemorySegment Pipe, MemorySegment ServerProcessId) {
        var mh$ = GetNamedPipeServerProcessId.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetNamedPipeServerProcessId", Pipe, ServerProcessId);
            }
            return (int)mh$.invokeExact(Pipe, ServerProcessId);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetNamedPipeServerSessionId {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetNamedPipeServerSessionId"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetNamedPipeServerSessionId(HANDLE Pipe, PULONG ServerSessionId)
     * }
     */
    public static FunctionDescriptor GetNamedPipeServerSessionId$descriptor() {
        return GetNamedPipeServerSessionId.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetNamedPipeServerSessionId(HANDLE Pipe, PULONG ServerSessionId)
     * }
     */
    public static MethodHandle GetNamedPipeServerSessionId$handle() {
        return GetNamedPipeServerSessionId.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL GetNamedPipeServerSessionId(HANDLE Pipe, PULONG ServerSessionId)
     * }
     */
    public static int GetNamedPipeServerSessionId(MemorySegment Pipe, MemorySegment ServerSessionId) {
        var mh$ = GetNamedPipeServerSessionId.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetNamedPipeServerSessionId", Pipe, ServerSessionId);
            }
            return (int)mh$.invokeExact(Pipe, ServerSessionId);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetVolumeLabelA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("SetVolumeLabelA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetVolumeLabelA(LPCSTR lpRootPathName, LPCSTR lpVolumeName)
     * }
     */
    public static FunctionDescriptor SetVolumeLabelA$descriptor() {
        return SetVolumeLabelA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetVolumeLabelA(LPCSTR lpRootPathName, LPCSTR lpVolumeName)
     * }
     */
    public static MethodHandle SetVolumeLabelA$handle() {
        return SetVolumeLabelA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL SetVolumeLabelA(LPCSTR lpRootPathName, LPCSTR lpVolumeName)
     * }
     */
    public static int SetVolumeLabelA(MemorySegment lpRootPathName, MemorySegment lpVolumeName) {
        var mh$ = SetVolumeLabelA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetVolumeLabelA", lpRootPathName, lpVolumeName);
            }
            return (int)mh$.invokeExact(lpRootPathName, lpVolumeName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetVolumeLabelW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("SetVolumeLabelW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetVolumeLabelW(LPCWSTR lpRootPathName, LPCWSTR lpVolumeName)
     * }
     */
    public static FunctionDescriptor SetVolumeLabelW$descriptor() {
        return SetVolumeLabelW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetVolumeLabelW(LPCWSTR lpRootPathName, LPCWSTR lpVolumeName)
     * }
     */
    public static MethodHandle SetVolumeLabelW$handle() {
        return SetVolumeLabelW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL SetVolumeLabelW(LPCWSTR lpRootPathName, LPCWSTR lpVolumeName)
     * }
     */
    public static int SetVolumeLabelW(MemorySegment lpRootPathName, MemorySegment lpVolumeName) {
        var mh$ = SetVolumeLabelW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetVolumeLabelW", lpRootPathName, lpVolumeName);
            }
            return (int)mh$.invokeExact(lpRootPathName, lpVolumeName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetFileBandwidthReservation {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_LONG,
            C_LONG,
            C_INT,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("SetFileBandwidthReservation"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetFileBandwidthReservation(HANDLE hFile, DWORD nPeriodMilliseconds, DWORD nBytesPerPeriod, BOOL bDiscardable, LPDWORD lpTransferSize, LPDWORD lpNumOutstandingRequests)
     * }
     */
    public static FunctionDescriptor SetFileBandwidthReservation$descriptor() {
        return SetFileBandwidthReservation.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetFileBandwidthReservation(HANDLE hFile, DWORD nPeriodMilliseconds, DWORD nBytesPerPeriod, BOOL bDiscardable, LPDWORD lpTransferSize, LPDWORD lpNumOutstandingRequests)
     * }
     */
    public static MethodHandle SetFileBandwidthReservation$handle() {
        return SetFileBandwidthReservation.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL SetFileBandwidthReservation(HANDLE hFile, DWORD nPeriodMilliseconds, DWORD nBytesPerPeriod, BOOL bDiscardable, LPDWORD lpTransferSize, LPDWORD lpNumOutstandingRequests)
     * }
     */
    public static int SetFileBandwidthReservation(MemorySegment hFile, int nPeriodMilliseconds, int nBytesPerPeriod, int bDiscardable, MemorySegment lpTransferSize, MemorySegment lpNumOutstandingRequests) {
        var mh$ = SetFileBandwidthReservation.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetFileBandwidthReservation", hFile, nPeriodMilliseconds, nBytesPerPeriod, bDiscardable, lpTransferSize, lpNumOutstandingRequests);
            }
            return (int)mh$.invokeExact(hFile, nPeriodMilliseconds, nBytesPerPeriod, bDiscardable, lpTransferSize, lpNumOutstandingRequests);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetFileBandwidthReservation {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetFileBandwidthReservation"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetFileBandwidthReservation(HANDLE hFile, LPDWORD lpPeriodMilliseconds, LPDWORD lpBytesPerPeriod, LPBOOL pDiscardable, LPDWORD lpTransferSize, LPDWORD lpNumOutstandingRequests)
     * }
     */
    public static FunctionDescriptor GetFileBandwidthReservation$descriptor() {
        return GetFileBandwidthReservation.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetFileBandwidthReservation(HANDLE hFile, LPDWORD lpPeriodMilliseconds, LPDWORD lpBytesPerPeriod, LPBOOL pDiscardable, LPDWORD lpTransferSize, LPDWORD lpNumOutstandingRequests)
     * }
     */
    public static MethodHandle GetFileBandwidthReservation$handle() {
        return GetFileBandwidthReservation.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL GetFileBandwidthReservation(HANDLE hFile, LPDWORD lpPeriodMilliseconds, LPDWORD lpBytesPerPeriod, LPBOOL pDiscardable, LPDWORD lpTransferSize, LPDWORD lpNumOutstandingRequests)
     * }
     */
    public static int GetFileBandwidthReservation(MemorySegment hFile, MemorySegment lpPeriodMilliseconds, MemorySegment lpBytesPerPeriod, MemorySegment pDiscardable, MemorySegment lpTransferSize, MemorySegment lpNumOutstandingRequests) {
        var mh$ = GetFileBandwidthReservation.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetFileBandwidthReservation", hFile, lpPeriodMilliseconds, lpBytesPerPeriod, pDiscardable, lpTransferSize, lpNumOutstandingRequests);
            }
            return (int)mh$.invokeExact(hFile, lpPeriodMilliseconds, lpBytesPerPeriod, pDiscardable, lpTransferSize, lpNumOutstandingRequests);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ClearEventLogA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("ClearEventLogA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL ClearEventLogA(HANDLE hEventLog, LPCSTR lpBackupFileName)
     * }
     */
    public static FunctionDescriptor ClearEventLogA$descriptor() {
        return ClearEventLogA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL ClearEventLogA(HANDLE hEventLog, LPCSTR lpBackupFileName)
     * }
     */
    public static MethodHandle ClearEventLogA$handle() {
        return ClearEventLogA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL ClearEventLogA(HANDLE hEventLog, LPCSTR lpBackupFileName)
     * }
     */
    public static int ClearEventLogA(MemorySegment hEventLog, MemorySegment lpBackupFileName) {
        var mh$ = ClearEventLogA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ClearEventLogA", hEventLog, lpBackupFileName);
            }
            return (int)mh$.invokeExact(hEventLog, lpBackupFileName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ClearEventLogW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("ClearEventLogW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL ClearEventLogW(HANDLE hEventLog, LPCWSTR lpBackupFileName)
     * }
     */
    public static FunctionDescriptor ClearEventLogW$descriptor() {
        return ClearEventLogW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL ClearEventLogW(HANDLE hEventLog, LPCWSTR lpBackupFileName)
     * }
     */
    public static MethodHandle ClearEventLogW$handle() {
        return ClearEventLogW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL ClearEventLogW(HANDLE hEventLog, LPCWSTR lpBackupFileName)
     * }
     */
    public static int ClearEventLogW(MemorySegment hEventLog, MemorySegment lpBackupFileName) {
        var mh$ = ClearEventLogW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ClearEventLogW", hEventLog, lpBackupFileName);
            }
            return (int)mh$.invokeExact(hEventLog, lpBackupFileName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class BackupEventLogA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("BackupEventLogA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL BackupEventLogA(HANDLE hEventLog, LPCSTR lpBackupFileName)
     * }
     */
    public static FunctionDescriptor BackupEventLogA$descriptor() {
        return BackupEventLogA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL BackupEventLogA(HANDLE hEventLog, LPCSTR lpBackupFileName)
     * }
     */
    public static MethodHandle BackupEventLogA$handle() {
        return BackupEventLogA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL BackupEventLogA(HANDLE hEventLog, LPCSTR lpBackupFileName)
     * }
     */
    public static int BackupEventLogA(MemorySegment hEventLog, MemorySegment lpBackupFileName) {
        var mh$ = BackupEventLogA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("BackupEventLogA", hEventLog, lpBackupFileName);
            }
            return (int)mh$.invokeExact(hEventLog, lpBackupFileName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class BackupEventLogW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("BackupEventLogW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL BackupEventLogW(HANDLE hEventLog, LPCWSTR lpBackupFileName)
     * }
     */
    public static FunctionDescriptor BackupEventLogW$descriptor() {
        return BackupEventLogW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL BackupEventLogW(HANDLE hEventLog, LPCWSTR lpBackupFileName)
     * }
     */
    public static MethodHandle BackupEventLogW$handle() {
        return BackupEventLogW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL BackupEventLogW(HANDLE hEventLog, LPCWSTR lpBackupFileName)
     * }
     */
    public static int BackupEventLogW(MemorySegment hEventLog, MemorySegment lpBackupFileName) {
        var mh$ = BackupEventLogW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("BackupEventLogW", hEventLog, lpBackupFileName);
            }
            return (int)mh$.invokeExact(hEventLog, lpBackupFileName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CloseEventLog {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CloseEventLog"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CloseEventLog(HANDLE hEventLog)
     * }
     */
    public static FunctionDescriptor CloseEventLog$descriptor() {
        return CloseEventLog.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CloseEventLog(HANDLE hEventLog)
     * }
     */
    public static MethodHandle CloseEventLog$handle() {
        return CloseEventLog.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL CloseEventLog(HANDLE hEventLog)
     * }
     */
    public static int CloseEventLog(MemorySegment hEventLog) {
        var mh$ = CloseEventLog.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CloseEventLog", hEventLog);
            }
            return (int)mh$.invokeExact(hEventLog);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DeregisterEventSource {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("DeregisterEventSource"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL DeregisterEventSource(HANDLE hEventLog)
     * }
     */
    public static FunctionDescriptor DeregisterEventSource$descriptor() {
        return DeregisterEventSource.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL DeregisterEventSource(HANDLE hEventLog)
     * }
     */
    public static MethodHandle DeregisterEventSource$handle() {
        return DeregisterEventSource.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL DeregisterEventSource(HANDLE hEventLog)
     * }
     */
    public static int DeregisterEventSource(MemorySegment hEventLog) {
        var mh$ = DeregisterEventSource.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DeregisterEventSource", hEventLog);
            }
            return (int)mh$.invokeExact(hEventLog);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class NotifyChangeEventLog {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("NotifyChangeEventLog"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL NotifyChangeEventLog(HANDLE hEventLog, HANDLE hEvent)
     * }
     */
    public static FunctionDescriptor NotifyChangeEventLog$descriptor() {
        return NotifyChangeEventLog.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL NotifyChangeEventLog(HANDLE hEventLog, HANDLE hEvent)
     * }
     */
    public static MethodHandle NotifyChangeEventLog$handle() {
        return NotifyChangeEventLog.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL NotifyChangeEventLog(HANDLE hEventLog, HANDLE hEvent)
     * }
     */
    public static int NotifyChangeEventLog(MemorySegment hEventLog, MemorySegment hEvent) {
        var mh$ = NotifyChangeEventLog.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("NotifyChangeEventLog", hEventLog, hEvent);
            }
            return (int)mh$.invokeExact(hEventLog, hEvent);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetNumberOfEventLogRecords {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetNumberOfEventLogRecords"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetNumberOfEventLogRecords(HANDLE hEventLog, PDWORD NumberOfRecords)
     * }
     */
    public static FunctionDescriptor GetNumberOfEventLogRecords$descriptor() {
        return GetNumberOfEventLogRecords.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetNumberOfEventLogRecords(HANDLE hEventLog, PDWORD NumberOfRecords)
     * }
     */
    public static MethodHandle GetNumberOfEventLogRecords$handle() {
        return GetNumberOfEventLogRecords.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL GetNumberOfEventLogRecords(HANDLE hEventLog, PDWORD NumberOfRecords)
     * }
     */
    public static int GetNumberOfEventLogRecords(MemorySegment hEventLog, MemorySegment NumberOfRecords) {
        var mh$ = GetNumberOfEventLogRecords.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetNumberOfEventLogRecords", hEventLog, NumberOfRecords);
            }
            return (int)mh$.invokeExact(hEventLog, NumberOfRecords);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetOldestEventLogRecord {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetOldestEventLogRecord"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetOldestEventLogRecord(HANDLE hEventLog, PDWORD OldestRecord)
     * }
     */
    public static FunctionDescriptor GetOldestEventLogRecord$descriptor() {
        return GetOldestEventLogRecord.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetOldestEventLogRecord(HANDLE hEventLog, PDWORD OldestRecord)
     * }
     */
    public static MethodHandle GetOldestEventLogRecord$handle() {
        return GetOldestEventLogRecord.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL GetOldestEventLogRecord(HANDLE hEventLog, PDWORD OldestRecord)
     * }
     */
    public static int GetOldestEventLogRecord(MemorySegment hEventLog, MemorySegment OldestRecord) {
        var mh$ = GetOldestEventLogRecord.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetOldestEventLogRecord", hEventLog, OldestRecord);
            }
            return (int)mh$.invokeExact(hEventLog, OldestRecord);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class OpenEventLogA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("OpenEventLogA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HANDLE OpenEventLogA(LPCSTR lpUNCServerName, LPCSTR lpSourceName)
     * }
     */
    public static FunctionDescriptor OpenEventLogA$descriptor() {
        return OpenEventLogA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HANDLE OpenEventLogA(LPCSTR lpUNCServerName, LPCSTR lpSourceName)
     * }
     */
    public static MethodHandle OpenEventLogA$handle() {
        return OpenEventLogA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * HANDLE OpenEventLogA(LPCSTR lpUNCServerName, LPCSTR lpSourceName)
     * }
     */
    public static MemorySegment OpenEventLogA(MemorySegment lpUNCServerName, MemorySegment lpSourceName) {
        var mh$ = OpenEventLogA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("OpenEventLogA", lpUNCServerName, lpSourceName);
            }
            return (MemorySegment)mh$.invokeExact(lpUNCServerName, lpSourceName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class OpenEventLogW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("OpenEventLogW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HANDLE OpenEventLogW(LPCWSTR lpUNCServerName, LPCWSTR lpSourceName)
     * }
     */
    public static FunctionDescriptor OpenEventLogW$descriptor() {
        return OpenEventLogW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HANDLE OpenEventLogW(LPCWSTR lpUNCServerName, LPCWSTR lpSourceName)
     * }
     */
    public static MethodHandle OpenEventLogW$handle() {
        return OpenEventLogW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * HANDLE OpenEventLogW(LPCWSTR lpUNCServerName, LPCWSTR lpSourceName)
     * }
     */
    public static MemorySegment OpenEventLogW(MemorySegment lpUNCServerName, MemorySegment lpSourceName) {
        var mh$ = OpenEventLogW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("OpenEventLogW", lpUNCServerName, lpSourceName);
            }
            return (MemorySegment)mh$.invokeExact(lpUNCServerName, lpSourceName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RegisterEventSourceA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("RegisterEventSourceA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HANDLE RegisterEventSourceA(LPCSTR lpUNCServerName, LPCSTR lpSourceName)
     * }
     */
    public static FunctionDescriptor RegisterEventSourceA$descriptor() {
        return RegisterEventSourceA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HANDLE RegisterEventSourceA(LPCSTR lpUNCServerName, LPCSTR lpSourceName)
     * }
     */
    public static MethodHandle RegisterEventSourceA$handle() {
        return RegisterEventSourceA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * HANDLE RegisterEventSourceA(LPCSTR lpUNCServerName, LPCSTR lpSourceName)
     * }
     */
    public static MemorySegment RegisterEventSourceA(MemorySegment lpUNCServerName, MemorySegment lpSourceName) {
        var mh$ = RegisterEventSourceA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RegisterEventSourceA", lpUNCServerName, lpSourceName);
            }
            return (MemorySegment)mh$.invokeExact(lpUNCServerName, lpSourceName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RegisterEventSourceW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("RegisterEventSourceW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HANDLE RegisterEventSourceW(LPCWSTR lpUNCServerName, LPCWSTR lpSourceName)
     * }
     */
    public static FunctionDescriptor RegisterEventSourceW$descriptor() {
        return RegisterEventSourceW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HANDLE RegisterEventSourceW(LPCWSTR lpUNCServerName, LPCWSTR lpSourceName)
     * }
     */
    public static MethodHandle RegisterEventSourceW$handle() {
        return RegisterEventSourceW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * HANDLE RegisterEventSourceW(LPCWSTR lpUNCServerName, LPCWSTR lpSourceName)
     * }
     */
    public static MemorySegment RegisterEventSourceW(MemorySegment lpUNCServerName, MemorySegment lpSourceName) {
        var mh$ = RegisterEventSourceW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RegisterEventSourceW", lpUNCServerName, lpSourceName);
            }
            return (MemorySegment)mh$.invokeExact(lpUNCServerName, lpSourceName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class OpenBackupEventLogA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("OpenBackupEventLogA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HANDLE OpenBackupEventLogA(LPCSTR lpUNCServerName, LPCSTR lpFileName)
     * }
     */
    public static FunctionDescriptor OpenBackupEventLogA$descriptor() {
        return OpenBackupEventLogA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HANDLE OpenBackupEventLogA(LPCSTR lpUNCServerName, LPCSTR lpFileName)
     * }
     */
    public static MethodHandle OpenBackupEventLogA$handle() {
        return OpenBackupEventLogA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * HANDLE OpenBackupEventLogA(LPCSTR lpUNCServerName, LPCSTR lpFileName)
     * }
     */
    public static MemorySegment OpenBackupEventLogA(MemorySegment lpUNCServerName, MemorySegment lpFileName) {
        var mh$ = OpenBackupEventLogA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("OpenBackupEventLogA", lpUNCServerName, lpFileName);
            }
            return (MemorySegment)mh$.invokeExact(lpUNCServerName, lpFileName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class OpenBackupEventLogW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("OpenBackupEventLogW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HANDLE OpenBackupEventLogW(LPCWSTR lpUNCServerName, LPCWSTR lpFileName)
     * }
     */
    public static FunctionDescriptor OpenBackupEventLogW$descriptor() {
        return OpenBackupEventLogW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HANDLE OpenBackupEventLogW(LPCWSTR lpUNCServerName, LPCWSTR lpFileName)
     * }
     */
    public static MethodHandle OpenBackupEventLogW$handle() {
        return OpenBackupEventLogW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * HANDLE OpenBackupEventLogW(LPCWSTR lpUNCServerName, LPCWSTR lpFileName)
     * }
     */
    public static MemorySegment OpenBackupEventLogW(MemorySegment lpUNCServerName, MemorySegment lpFileName) {
        var mh$ = OpenBackupEventLogW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("OpenBackupEventLogW", lpUNCServerName, lpFileName);
            }
            return (MemorySegment)mh$.invokeExact(lpUNCServerName, lpFileName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ReadEventLogA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_LONG,
            C_LONG,
            C_POINTER,
            C_LONG,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("ReadEventLogA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL ReadEventLogA(HANDLE hEventLog, DWORD dwReadFlags, DWORD dwRecordOffset, LPVOID lpBuffer, DWORD nNumberOfBytesToRead, DWORD *pnBytesRead, DWORD *pnMinNumberOfBytesNeeded)
     * }
     */
    public static FunctionDescriptor ReadEventLogA$descriptor() {
        return ReadEventLogA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL ReadEventLogA(HANDLE hEventLog, DWORD dwReadFlags, DWORD dwRecordOffset, LPVOID lpBuffer, DWORD nNumberOfBytesToRead, DWORD *pnBytesRead, DWORD *pnMinNumberOfBytesNeeded)
     * }
     */
    public static MethodHandle ReadEventLogA$handle() {
        return ReadEventLogA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL ReadEventLogA(HANDLE hEventLog, DWORD dwReadFlags, DWORD dwRecordOffset, LPVOID lpBuffer, DWORD nNumberOfBytesToRead, DWORD *pnBytesRead, DWORD *pnMinNumberOfBytesNeeded)
     * }
     */
    public static int ReadEventLogA(MemorySegment hEventLog, int dwReadFlags, int dwRecordOffset, MemorySegment lpBuffer, int nNumberOfBytesToRead, MemorySegment pnBytesRead, MemorySegment pnMinNumberOfBytesNeeded) {
        var mh$ = ReadEventLogA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ReadEventLogA", hEventLog, dwReadFlags, dwRecordOffset, lpBuffer, nNumberOfBytesToRead, pnBytesRead, pnMinNumberOfBytesNeeded);
            }
            return (int)mh$.invokeExact(hEventLog, dwReadFlags, dwRecordOffset, lpBuffer, nNumberOfBytesToRead, pnBytesRead, pnMinNumberOfBytesNeeded);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ReadEventLogW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_LONG,
            C_LONG,
            C_POINTER,
            C_LONG,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("ReadEventLogW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL ReadEventLogW(HANDLE hEventLog, DWORD dwReadFlags, DWORD dwRecordOffset, LPVOID lpBuffer, DWORD nNumberOfBytesToRead, DWORD *pnBytesRead, DWORD *pnMinNumberOfBytesNeeded)
     * }
     */
    public static FunctionDescriptor ReadEventLogW$descriptor() {
        return ReadEventLogW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL ReadEventLogW(HANDLE hEventLog, DWORD dwReadFlags, DWORD dwRecordOffset, LPVOID lpBuffer, DWORD nNumberOfBytesToRead, DWORD *pnBytesRead, DWORD *pnMinNumberOfBytesNeeded)
     * }
     */
    public static MethodHandle ReadEventLogW$handle() {
        return ReadEventLogW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL ReadEventLogW(HANDLE hEventLog, DWORD dwReadFlags, DWORD dwRecordOffset, LPVOID lpBuffer, DWORD nNumberOfBytesToRead, DWORD *pnBytesRead, DWORD *pnMinNumberOfBytesNeeded)
     * }
     */
    public static int ReadEventLogW(MemorySegment hEventLog, int dwReadFlags, int dwRecordOffset, MemorySegment lpBuffer, int nNumberOfBytesToRead, MemorySegment pnBytesRead, MemorySegment pnMinNumberOfBytesNeeded) {
        var mh$ = ReadEventLogW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ReadEventLogW", hEventLog, dwReadFlags, dwRecordOffset, lpBuffer, nNumberOfBytesToRead, pnBytesRead, pnMinNumberOfBytesNeeded);
            }
            return (int)mh$.invokeExact(hEventLog, dwReadFlags, dwRecordOffset, lpBuffer, nNumberOfBytesToRead, pnBytesRead, pnMinNumberOfBytesNeeded);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ReportEventA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_SHORT,
            C_SHORT,
            C_LONG,
            C_POINTER,
            C_SHORT,
            C_LONG,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("ReportEventA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL ReportEventA(HANDLE hEventLog, WORD wType, WORD wCategory, DWORD dwEventID, PSID lpUserSid, WORD wNumStrings, DWORD dwDataSize, LPCSTR *lpStrings, LPVOID lpRawData)
     * }
     */
    public static FunctionDescriptor ReportEventA$descriptor() {
        return ReportEventA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL ReportEventA(HANDLE hEventLog, WORD wType, WORD wCategory, DWORD dwEventID, PSID lpUserSid, WORD wNumStrings, DWORD dwDataSize, LPCSTR *lpStrings, LPVOID lpRawData)
     * }
     */
    public static MethodHandle ReportEventA$handle() {
        return ReportEventA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL ReportEventA(HANDLE hEventLog, WORD wType, WORD wCategory, DWORD dwEventID, PSID lpUserSid, WORD wNumStrings, DWORD dwDataSize, LPCSTR *lpStrings, LPVOID lpRawData)
     * }
     */
    public static int ReportEventA(MemorySegment hEventLog, short wType, short wCategory, int dwEventID, MemorySegment lpUserSid, short wNumStrings, int dwDataSize, MemorySegment lpStrings, MemorySegment lpRawData) {
        var mh$ = ReportEventA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ReportEventA", hEventLog, wType, wCategory, dwEventID, lpUserSid, wNumStrings, dwDataSize, lpStrings, lpRawData);
            }
            return (int)mh$.invokeExact(hEventLog, wType, wCategory, dwEventID, lpUserSid, wNumStrings, dwDataSize, lpStrings, lpRawData);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ReportEventW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_SHORT,
            C_SHORT,
            C_LONG,
            C_POINTER,
            C_SHORT,
            C_LONG,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("ReportEventW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL ReportEventW(HANDLE hEventLog, WORD wType, WORD wCategory, DWORD dwEventID, PSID lpUserSid, WORD wNumStrings, DWORD dwDataSize, LPCWSTR *lpStrings, LPVOID lpRawData)
     * }
     */
    public static FunctionDescriptor ReportEventW$descriptor() {
        return ReportEventW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL ReportEventW(HANDLE hEventLog, WORD wType, WORD wCategory, DWORD dwEventID, PSID lpUserSid, WORD wNumStrings, DWORD dwDataSize, LPCWSTR *lpStrings, LPVOID lpRawData)
     * }
     */
    public static MethodHandle ReportEventW$handle() {
        return ReportEventW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL ReportEventW(HANDLE hEventLog, WORD wType, WORD wCategory, DWORD dwEventID, PSID lpUserSid, WORD wNumStrings, DWORD dwDataSize, LPCWSTR *lpStrings, LPVOID lpRawData)
     * }
     */
    public static int ReportEventW(MemorySegment hEventLog, short wType, short wCategory, int dwEventID, MemorySegment lpUserSid, short wNumStrings, int dwDataSize, MemorySegment lpStrings, MemorySegment lpRawData) {
        var mh$ = ReportEventW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ReportEventW", hEventLog, wType, wCategory, dwEventID, lpUserSid, wNumStrings, dwDataSize, lpStrings, lpRawData);
            }
            return (int)mh$.invokeExact(hEventLog, wType, wCategory, dwEventID, lpUserSid, wNumStrings, dwDataSize, lpStrings, lpRawData);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct _EVENTLOG_FULL_INFORMATION {
     *     DWORD dwFull;
     * } *LPEVENTLOG_FULL_INFORMATION
     * }
     */
    public static final AddressLayout LPEVENTLOG_FULL_INFORMATION = C_POINTER;

    private static class GetEventLogInformation {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_LONG,
            C_POINTER,
            C_LONG,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetEventLogInformation"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetEventLogInformation(HANDLE hEventLog, DWORD dwInfoLevel, LPVOID lpBuffer, DWORD cbBufSize, LPDWORD pcbBytesNeeded)
     * }
     */
    public static FunctionDescriptor GetEventLogInformation$descriptor() {
        return GetEventLogInformation.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetEventLogInformation(HANDLE hEventLog, DWORD dwInfoLevel, LPVOID lpBuffer, DWORD cbBufSize, LPDWORD pcbBytesNeeded)
     * }
     */
    public static MethodHandle GetEventLogInformation$handle() {
        return GetEventLogInformation.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL GetEventLogInformation(HANDLE hEventLog, DWORD dwInfoLevel, LPVOID lpBuffer, DWORD cbBufSize, LPDWORD pcbBytesNeeded)
     * }
     */
    public static int GetEventLogInformation(MemorySegment hEventLog, int dwInfoLevel, MemorySegment lpBuffer, int cbBufSize, MemorySegment pcbBytesNeeded) {
        var mh$ = GetEventLogInformation.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetEventLogInformation", hEventLog, dwInfoLevel, lpBuffer, cbBufSize, pcbBytesNeeded);
            }
            return (int)mh$.invokeExact(hEventLog, dwInfoLevel, lpBuffer, cbBufSize, pcbBytesNeeded);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef ULONG OPERATION_ID
     * }
     */
    public static final OfInt OPERATION_ID = C_LONG;
    /**
     * {@snippet lang=c :
     * typedef struct _OPERATION_START_PARAMETERS {
     *     ULONG Version;
     *     OPERATION_ID OperationId;
     *     ULONG Flags;
     * } *POPERATION_START_PARAMETERS
     * }
     */
    public static final AddressLayout POPERATION_START_PARAMETERS = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _OPERATION_END_PARAMETERS {
     *     ULONG Version;
     *     OPERATION_ID OperationId;
     *     ULONG Flags;
     * } *POPERATION_END_PARAMETERS
     * }
     */
    public static final AddressLayout POPERATION_END_PARAMETERS = C_POINTER;

    private static class OperationStart {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("OperationStart"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL OperationStart(OPERATION_START_PARAMETERS *OperationStartParams)
     * }
     */
    public static FunctionDescriptor OperationStart$descriptor() {
        return OperationStart.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL OperationStart(OPERATION_START_PARAMETERS *OperationStartParams)
     * }
     */
    public static MethodHandle OperationStart$handle() {
        return OperationStart.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL OperationStart(OPERATION_START_PARAMETERS *OperationStartParams)
     * }
     */
    public static int OperationStart(MemorySegment OperationStartParams) {
        var mh$ = OperationStart.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("OperationStart", OperationStartParams);
            }
            return (int)mh$.invokeExact(OperationStartParams);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class OperationEnd {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("OperationEnd"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL OperationEnd(OPERATION_END_PARAMETERS *OperationEndParams)
     * }
     */
    public static FunctionDescriptor OperationEnd$descriptor() {
        return OperationEnd.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL OperationEnd(OPERATION_END_PARAMETERS *OperationEndParams)
     * }
     */
    public static MethodHandle OperationEnd$handle() {
        return OperationEnd.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL OperationEnd(OPERATION_END_PARAMETERS *OperationEndParams)
     * }
     */
    public static int OperationEnd(MemorySegment OperationEndParams) {
        var mh$ = OperationEnd.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("OperationEnd", OperationEndParams);
            }
            return (int)mh$.invokeExact(OperationEndParams);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class AccessCheckAndAuditAlarmA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_LONG,
            C_POINTER,
            C_INT,
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("AccessCheckAndAuditAlarmA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL AccessCheckAndAuditAlarmA(LPCSTR SubsystemName, LPVOID HandleId, LPSTR ObjectTypeName, LPSTR ObjectName, PSECURITY_DESCRIPTOR SecurityDescriptor, DWORD DesiredAccess, PGENERIC_MAPPING GenericMapping, BOOL ObjectCreation, LPDWORD GrantedAccess, LPBOOL AccessStatus, LPBOOL pfGenerateOnClose)
     * }
     */
    public static FunctionDescriptor AccessCheckAndAuditAlarmA$descriptor() {
        return AccessCheckAndAuditAlarmA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL AccessCheckAndAuditAlarmA(LPCSTR SubsystemName, LPVOID HandleId, LPSTR ObjectTypeName, LPSTR ObjectName, PSECURITY_DESCRIPTOR SecurityDescriptor, DWORD DesiredAccess, PGENERIC_MAPPING GenericMapping, BOOL ObjectCreation, LPDWORD GrantedAccess, LPBOOL AccessStatus, LPBOOL pfGenerateOnClose)
     * }
     */
    public static MethodHandle AccessCheckAndAuditAlarmA$handle() {
        return AccessCheckAndAuditAlarmA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL AccessCheckAndAuditAlarmA(LPCSTR SubsystemName, LPVOID HandleId, LPSTR ObjectTypeName, LPSTR ObjectName, PSECURITY_DESCRIPTOR SecurityDescriptor, DWORD DesiredAccess, PGENERIC_MAPPING GenericMapping, BOOL ObjectCreation, LPDWORD GrantedAccess, LPBOOL AccessStatus, LPBOOL pfGenerateOnClose)
     * }
     */
    public static int AccessCheckAndAuditAlarmA(MemorySegment SubsystemName, MemorySegment HandleId, MemorySegment ObjectTypeName, MemorySegment ObjectName, MemorySegment SecurityDescriptor, int DesiredAccess, MemorySegment GenericMapping, int ObjectCreation, MemorySegment GrantedAccess, MemorySegment AccessStatus, MemorySegment pfGenerateOnClose) {
        var mh$ = AccessCheckAndAuditAlarmA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("AccessCheckAndAuditAlarmA", SubsystemName, HandleId, ObjectTypeName, ObjectName, SecurityDescriptor, DesiredAccess, GenericMapping, ObjectCreation, GrantedAccess, AccessStatus, pfGenerateOnClose);
            }
            return (int)mh$.invokeExact(SubsystemName, HandleId, ObjectTypeName, ObjectName, SecurityDescriptor, DesiredAccess, GenericMapping, ObjectCreation, GrantedAccess, AccessStatus, pfGenerateOnClose);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class AccessCheckByTypeAndAuditAlarmA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_LONG,
            C_INT,
            C_LONG,
            C_POINTER,
            C_LONG,
            C_POINTER,
            C_INT,
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("AccessCheckByTypeAndAuditAlarmA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL AccessCheckByTypeAndAuditAlarmA(LPCSTR SubsystemName, LPVOID HandleId, LPCSTR ObjectTypeName, LPCSTR ObjectName, PSECURITY_DESCRIPTOR SecurityDescriptor, PSID PrincipalSelfSid, DWORD DesiredAccess, AUDIT_EVENT_TYPE AuditType, DWORD Flags, POBJECT_TYPE_LIST ObjectTypeList, DWORD ObjectTypeListLength, PGENERIC_MAPPING GenericMapping, BOOL ObjectCreation, LPDWORD GrantedAccess, LPBOOL AccessStatus, LPBOOL pfGenerateOnClose)
     * }
     */
    public static FunctionDescriptor AccessCheckByTypeAndAuditAlarmA$descriptor() {
        return AccessCheckByTypeAndAuditAlarmA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL AccessCheckByTypeAndAuditAlarmA(LPCSTR SubsystemName, LPVOID HandleId, LPCSTR ObjectTypeName, LPCSTR ObjectName, PSECURITY_DESCRIPTOR SecurityDescriptor, PSID PrincipalSelfSid, DWORD DesiredAccess, AUDIT_EVENT_TYPE AuditType, DWORD Flags, POBJECT_TYPE_LIST ObjectTypeList, DWORD ObjectTypeListLength, PGENERIC_MAPPING GenericMapping, BOOL ObjectCreation, LPDWORD GrantedAccess, LPBOOL AccessStatus, LPBOOL pfGenerateOnClose)
     * }
     */
    public static MethodHandle AccessCheckByTypeAndAuditAlarmA$handle() {
        return AccessCheckByTypeAndAuditAlarmA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL AccessCheckByTypeAndAuditAlarmA(LPCSTR SubsystemName, LPVOID HandleId, LPCSTR ObjectTypeName, LPCSTR ObjectName, PSECURITY_DESCRIPTOR SecurityDescriptor, PSID PrincipalSelfSid, DWORD DesiredAccess, AUDIT_EVENT_TYPE AuditType, DWORD Flags, POBJECT_TYPE_LIST ObjectTypeList, DWORD ObjectTypeListLength, PGENERIC_MAPPING GenericMapping, BOOL ObjectCreation, LPDWORD GrantedAccess, LPBOOL AccessStatus, LPBOOL pfGenerateOnClose)
     * }
     */
    public static int AccessCheckByTypeAndAuditAlarmA(MemorySegment SubsystemName, MemorySegment HandleId, MemorySegment ObjectTypeName, MemorySegment ObjectName, MemorySegment SecurityDescriptor, MemorySegment PrincipalSelfSid, int DesiredAccess, int AuditType, int Flags, MemorySegment ObjectTypeList, int ObjectTypeListLength, MemorySegment GenericMapping, int ObjectCreation, MemorySegment GrantedAccess, MemorySegment AccessStatus, MemorySegment pfGenerateOnClose) {
        var mh$ = AccessCheckByTypeAndAuditAlarmA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("AccessCheckByTypeAndAuditAlarmA", SubsystemName, HandleId, ObjectTypeName, ObjectName, SecurityDescriptor, PrincipalSelfSid, DesiredAccess, AuditType, Flags, ObjectTypeList, ObjectTypeListLength, GenericMapping, ObjectCreation, GrantedAccess, AccessStatus, pfGenerateOnClose);
            }
            return (int)mh$.invokeExact(SubsystemName, HandleId, ObjectTypeName, ObjectName, SecurityDescriptor, PrincipalSelfSid, DesiredAccess, AuditType, Flags, ObjectTypeList, ObjectTypeListLength, GenericMapping, ObjectCreation, GrantedAccess, AccessStatus, pfGenerateOnClose);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class AccessCheckByTypeResultListAndAuditAlarmA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_LONG,
            C_INT,
            C_LONG,
            C_POINTER,
            C_LONG,
            C_POINTER,
            C_INT,
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("AccessCheckByTypeResultListAndAuditAlarmA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL AccessCheckByTypeResultListAndAuditAlarmA(LPCSTR SubsystemName, LPVOID HandleId, LPCSTR ObjectTypeName, LPCSTR ObjectName, PSECURITY_DESCRIPTOR SecurityDescriptor, PSID PrincipalSelfSid, DWORD DesiredAccess, AUDIT_EVENT_TYPE AuditType, DWORD Flags, POBJECT_TYPE_LIST ObjectTypeList, DWORD ObjectTypeListLength, PGENERIC_MAPPING GenericMapping, BOOL ObjectCreation, LPDWORD GrantedAccess, LPDWORD AccessStatusList, LPBOOL pfGenerateOnClose)
     * }
     */
    public static FunctionDescriptor AccessCheckByTypeResultListAndAuditAlarmA$descriptor() {
        return AccessCheckByTypeResultListAndAuditAlarmA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL AccessCheckByTypeResultListAndAuditAlarmA(LPCSTR SubsystemName, LPVOID HandleId, LPCSTR ObjectTypeName, LPCSTR ObjectName, PSECURITY_DESCRIPTOR SecurityDescriptor, PSID PrincipalSelfSid, DWORD DesiredAccess, AUDIT_EVENT_TYPE AuditType, DWORD Flags, POBJECT_TYPE_LIST ObjectTypeList, DWORD ObjectTypeListLength, PGENERIC_MAPPING GenericMapping, BOOL ObjectCreation, LPDWORD GrantedAccess, LPDWORD AccessStatusList, LPBOOL pfGenerateOnClose)
     * }
     */
    public static MethodHandle AccessCheckByTypeResultListAndAuditAlarmA$handle() {
        return AccessCheckByTypeResultListAndAuditAlarmA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL AccessCheckByTypeResultListAndAuditAlarmA(LPCSTR SubsystemName, LPVOID HandleId, LPCSTR ObjectTypeName, LPCSTR ObjectName, PSECURITY_DESCRIPTOR SecurityDescriptor, PSID PrincipalSelfSid, DWORD DesiredAccess, AUDIT_EVENT_TYPE AuditType, DWORD Flags, POBJECT_TYPE_LIST ObjectTypeList, DWORD ObjectTypeListLength, PGENERIC_MAPPING GenericMapping, BOOL ObjectCreation, LPDWORD GrantedAccess, LPDWORD AccessStatusList, LPBOOL pfGenerateOnClose)
     * }
     */
    public static int AccessCheckByTypeResultListAndAuditAlarmA(MemorySegment SubsystemName, MemorySegment HandleId, MemorySegment ObjectTypeName, MemorySegment ObjectName, MemorySegment SecurityDescriptor, MemorySegment PrincipalSelfSid, int DesiredAccess, int AuditType, int Flags, MemorySegment ObjectTypeList, int ObjectTypeListLength, MemorySegment GenericMapping, int ObjectCreation, MemorySegment GrantedAccess, MemorySegment AccessStatusList, MemorySegment pfGenerateOnClose) {
        var mh$ = AccessCheckByTypeResultListAndAuditAlarmA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("AccessCheckByTypeResultListAndAuditAlarmA", SubsystemName, HandleId, ObjectTypeName, ObjectName, SecurityDescriptor, PrincipalSelfSid, DesiredAccess, AuditType, Flags, ObjectTypeList, ObjectTypeListLength, GenericMapping, ObjectCreation, GrantedAccess, AccessStatusList, pfGenerateOnClose);
            }
            return (int)mh$.invokeExact(SubsystemName, HandleId, ObjectTypeName, ObjectName, SecurityDescriptor, PrincipalSelfSid, DesiredAccess, AuditType, Flags, ObjectTypeList, ObjectTypeListLength, GenericMapping, ObjectCreation, GrantedAccess, AccessStatusList, pfGenerateOnClose);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class AccessCheckByTypeResultListAndAuditAlarmByHandleA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_LONG,
            C_INT,
            C_LONG,
            C_POINTER,
            C_LONG,
            C_POINTER,
            C_INT,
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("AccessCheckByTypeResultListAndAuditAlarmByHandleA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL AccessCheckByTypeResultListAndAuditAlarmByHandleA(LPCSTR SubsystemName, LPVOID HandleId, HANDLE ClientToken, LPCSTR ObjectTypeName, LPCSTR ObjectName, PSECURITY_DESCRIPTOR SecurityDescriptor, PSID PrincipalSelfSid, DWORD DesiredAccess, AUDIT_EVENT_TYPE AuditType, DWORD Flags, POBJECT_TYPE_LIST ObjectTypeList, DWORD ObjectTypeListLength, PGENERIC_MAPPING GenericMapping, BOOL ObjectCreation, LPDWORD GrantedAccess, LPDWORD AccessStatusList, LPBOOL pfGenerateOnClose)
     * }
     */
    public static FunctionDescriptor AccessCheckByTypeResultListAndAuditAlarmByHandleA$descriptor() {
        return AccessCheckByTypeResultListAndAuditAlarmByHandleA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL AccessCheckByTypeResultListAndAuditAlarmByHandleA(LPCSTR SubsystemName, LPVOID HandleId, HANDLE ClientToken, LPCSTR ObjectTypeName, LPCSTR ObjectName, PSECURITY_DESCRIPTOR SecurityDescriptor, PSID PrincipalSelfSid, DWORD DesiredAccess, AUDIT_EVENT_TYPE AuditType, DWORD Flags, POBJECT_TYPE_LIST ObjectTypeList, DWORD ObjectTypeListLength, PGENERIC_MAPPING GenericMapping, BOOL ObjectCreation, LPDWORD GrantedAccess, LPDWORD AccessStatusList, LPBOOL pfGenerateOnClose)
     * }
     */
    public static MethodHandle AccessCheckByTypeResultListAndAuditAlarmByHandleA$handle() {
        return AccessCheckByTypeResultListAndAuditAlarmByHandleA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL AccessCheckByTypeResultListAndAuditAlarmByHandleA(LPCSTR SubsystemName, LPVOID HandleId, HANDLE ClientToken, LPCSTR ObjectTypeName, LPCSTR ObjectName, PSECURITY_DESCRIPTOR SecurityDescriptor, PSID PrincipalSelfSid, DWORD DesiredAccess, AUDIT_EVENT_TYPE AuditType, DWORD Flags, POBJECT_TYPE_LIST ObjectTypeList, DWORD ObjectTypeListLength, PGENERIC_MAPPING GenericMapping, BOOL ObjectCreation, LPDWORD GrantedAccess, LPDWORD AccessStatusList, LPBOOL pfGenerateOnClose)
     * }
     */
    public static int AccessCheckByTypeResultListAndAuditAlarmByHandleA(MemorySegment SubsystemName, MemorySegment HandleId, MemorySegment ClientToken, MemorySegment ObjectTypeName, MemorySegment ObjectName, MemorySegment SecurityDescriptor, MemorySegment PrincipalSelfSid, int DesiredAccess, int AuditType, int Flags, MemorySegment ObjectTypeList, int ObjectTypeListLength, MemorySegment GenericMapping, int ObjectCreation, MemorySegment GrantedAccess, MemorySegment AccessStatusList, MemorySegment pfGenerateOnClose) {
        var mh$ = AccessCheckByTypeResultListAndAuditAlarmByHandleA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("AccessCheckByTypeResultListAndAuditAlarmByHandleA", SubsystemName, HandleId, ClientToken, ObjectTypeName, ObjectName, SecurityDescriptor, PrincipalSelfSid, DesiredAccess, AuditType, Flags, ObjectTypeList, ObjectTypeListLength, GenericMapping, ObjectCreation, GrantedAccess, AccessStatusList, pfGenerateOnClose);
            }
            return (int)mh$.invokeExact(SubsystemName, HandleId, ClientToken, ObjectTypeName, ObjectName, SecurityDescriptor, PrincipalSelfSid, DesiredAccess, AuditType, Flags, ObjectTypeList, ObjectTypeListLength, GenericMapping, ObjectCreation, GrantedAccess, AccessStatusList, pfGenerateOnClose);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ObjectOpenAuditAlarmA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_LONG,
            C_LONG,
            C_POINTER,
            C_INT,
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("ObjectOpenAuditAlarmA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL ObjectOpenAuditAlarmA(LPCSTR SubsystemName, LPVOID HandleId, LPSTR ObjectTypeName, LPSTR ObjectName, PSECURITY_DESCRIPTOR pSecurityDescriptor, HANDLE ClientToken, DWORD DesiredAccess, DWORD GrantedAccess, PPRIVILEGE_SET Privileges, BOOL ObjectCreation, BOOL AccessGranted, LPBOOL GenerateOnClose)
     * }
     */
    public static FunctionDescriptor ObjectOpenAuditAlarmA$descriptor() {
        return ObjectOpenAuditAlarmA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL ObjectOpenAuditAlarmA(LPCSTR SubsystemName, LPVOID HandleId, LPSTR ObjectTypeName, LPSTR ObjectName, PSECURITY_DESCRIPTOR pSecurityDescriptor, HANDLE ClientToken, DWORD DesiredAccess, DWORD GrantedAccess, PPRIVILEGE_SET Privileges, BOOL ObjectCreation, BOOL AccessGranted, LPBOOL GenerateOnClose)
     * }
     */
    public static MethodHandle ObjectOpenAuditAlarmA$handle() {
        return ObjectOpenAuditAlarmA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL ObjectOpenAuditAlarmA(LPCSTR SubsystemName, LPVOID HandleId, LPSTR ObjectTypeName, LPSTR ObjectName, PSECURITY_DESCRIPTOR pSecurityDescriptor, HANDLE ClientToken, DWORD DesiredAccess, DWORD GrantedAccess, PPRIVILEGE_SET Privileges, BOOL ObjectCreation, BOOL AccessGranted, LPBOOL GenerateOnClose)
     * }
     */
    public static int ObjectOpenAuditAlarmA(MemorySegment SubsystemName, MemorySegment HandleId, MemorySegment ObjectTypeName, MemorySegment ObjectName, MemorySegment pSecurityDescriptor, MemorySegment ClientToken, int DesiredAccess, int GrantedAccess, MemorySegment Privileges, int ObjectCreation, int AccessGranted, MemorySegment GenerateOnClose) {
        var mh$ = ObjectOpenAuditAlarmA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ObjectOpenAuditAlarmA", SubsystemName, HandleId, ObjectTypeName, ObjectName, pSecurityDescriptor, ClientToken, DesiredAccess, GrantedAccess, Privileges, ObjectCreation, AccessGranted, GenerateOnClose);
            }
            return (int)mh$.invokeExact(SubsystemName, HandleId, ObjectTypeName, ObjectName, pSecurityDescriptor, ClientToken, DesiredAccess, GrantedAccess, Privileges, ObjectCreation, AccessGranted, GenerateOnClose);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ObjectPrivilegeAuditAlarmA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_LONG,
            C_POINTER,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("ObjectPrivilegeAuditAlarmA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL ObjectPrivilegeAuditAlarmA(LPCSTR SubsystemName, LPVOID HandleId, HANDLE ClientToken, DWORD DesiredAccess, PPRIVILEGE_SET Privileges, BOOL AccessGranted)
     * }
     */
    public static FunctionDescriptor ObjectPrivilegeAuditAlarmA$descriptor() {
        return ObjectPrivilegeAuditAlarmA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL ObjectPrivilegeAuditAlarmA(LPCSTR SubsystemName, LPVOID HandleId, HANDLE ClientToken, DWORD DesiredAccess, PPRIVILEGE_SET Privileges, BOOL AccessGranted)
     * }
     */
    public static MethodHandle ObjectPrivilegeAuditAlarmA$handle() {
        return ObjectPrivilegeAuditAlarmA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL ObjectPrivilegeAuditAlarmA(LPCSTR SubsystemName, LPVOID HandleId, HANDLE ClientToken, DWORD DesiredAccess, PPRIVILEGE_SET Privileges, BOOL AccessGranted)
     * }
     */
    public static int ObjectPrivilegeAuditAlarmA(MemorySegment SubsystemName, MemorySegment HandleId, MemorySegment ClientToken, int DesiredAccess, MemorySegment Privileges, int AccessGranted) {
        var mh$ = ObjectPrivilegeAuditAlarmA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ObjectPrivilegeAuditAlarmA", SubsystemName, HandleId, ClientToken, DesiredAccess, Privileges, AccessGranted);
            }
            return (int)mh$.invokeExact(SubsystemName, HandleId, ClientToken, DesiredAccess, Privileges, AccessGranted);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ObjectCloseAuditAlarmA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("ObjectCloseAuditAlarmA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL ObjectCloseAuditAlarmA(LPCSTR SubsystemName, LPVOID HandleId, BOOL GenerateOnClose)
     * }
     */
    public static FunctionDescriptor ObjectCloseAuditAlarmA$descriptor() {
        return ObjectCloseAuditAlarmA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL ObjectCloseAuditAlarmA(LPCSTR SubsystemName, LPVOID HandleId, BOOL GenerateOnClose)
     * }
     */
    public static MethodHandle ObjectCloseAuditAlarmA$handle() {
        return ObjectCloseAuditAlarmA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL ObjectCloseAuditAlarmA(LPCSTR SubsystemName, LPVOID HandleId, BOOL GenerateOnClose)
     * }
     */
    public static int ObjectCloseAuditAlarmA(MemorySegment SubsystemName, MemorySegment HandleId, int GenerateOnClose) {
        var mh$ = ObjectCloseAuditAlarmA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ObjectCloseAuditAlarmA", SubsystemName, HandleId, GenerateOnClose);
            }
            return (int)mh$.invokeExact(SubsystemName, HandleId, GenerateOnClose);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ObjectDeleteAuditAlarmA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("ObjectDeleteAuditAlarmA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL ObjectDeleteAuditAlarmA(LPCSTR SubsystemName, LPVOID HandleId, BOOL GenerateOnClose)
     * }
     */
    public static FunctionDescriptor ObjectDeleteAuditAlarmA$descriptor() {
        return ObjectDeleteAuditAlarmA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL ObjectDeleteAuditAlarmA(LPCSTR SubsystemName, LPVOID HandleId, BOOL GenerateOnClose)
     * }
     */
    public static MethodHandle ObjectDeleteAuditAlarmA$handle() {
        return ObjectDeleteAuditAlarmA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL ObjectDeleteAuditAlarmA(LPCSTR SubsystemName, LPVOID HandleId, BOOL GenerateOnClose)
     * }
     */
    public static int ObjectDeleteAuditAlarmA(MemorySegment SubsystemName, MemorySegment HandleId, int GenerateOnClose) {
        var mh$ = ObjectDeleteAuditAlarmA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ObjectDeleteAuditAlarmA", SubsystemName, HandleId, GenerateOnClose);
            }
            return (int)mh$.invokeExact(SubsystemName, HandleId, GenerateOnClose);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PrivilegedServiceAuditAlarmA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("PrivilegedServiceAuditAlarmA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL PrivilegedServiceAuditAlarmA(LPCSTR SubsystemName, LPCSTR ServiceName, HANDLE ClientToken, PPRIVILEGE_SET Privileges, BOOL AccessGranted)
     * }
     */
    public static FunctionDescriptor PrivilegedServiceAuditAlarmA$descriptor() {
        return PrivilegedServiceAuditAlarmA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL PrivilegedServiceAuditAlarmA(LPCSTR SubsystemName, LPCSTR ServiceName, HANDLE ClientToken, PPRIVILEGE_SET Privileges, BOOL AccessGranted)
     * }
     */
    public static MethodHandle PrivilegedServiceAuditAlarmA$handle() {
        return PrivilegedServiceAuditAlarmA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL PrivilegedServiceAuditAlarmA(LPCSTR SubsystemName, LPCSTR ServiceName, HANDLE ClientToken, PPRIVILEGE_SET Privileges, BOOL AccessGranted)
     * }
     */
    public static int PrivilegedServiceAuditAlarmA(MemorySegment SubsystemName, MemorySegment ServiceName, MemorySegment ClientToken, MemorySegment Privileges, int AccessGranted) {
        var mh$ = PrivilegedServiceAuditAlarmA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PrivilegedServiceAuditAlarmA", SubsystemName, ServiceName, ClientToken, Privileges, AccessGranted);
            }
            return (int)mh$.invokeExact(SubsystemName, ServiceName, ClientToken, Privileges, AccessGranted);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class AddConditionalAce {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_LONG,
            C_LONG,
            C_CHAR,
            C_LONG,
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("AddConditionalAce"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL AddConditionalAce(PACL pAcl, DWORD dwAceRevision, DWORD AceFlags, UCHAR AceType, DWORD AccessMask, PSID pSid, PWCHAR ConditionStr, DWORD *ReturnLength)
     * }
     */
    public static FunctionDescriptor AddConditionalAce$descriptor() {
        return AddConditionalAce.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL AddConditionalAce(PACL pAcl, DWORD dwAceRevision, DWORD AceFlags, UCHAR AceType, DWORD AccessMask, PSID pSid, PWCHAR ConditionStr, DWORD *ReturnLength)
     * }
     */
    public static MethodHandle AddConditionalAce$handle() {
        return AddConditionalAce.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL AddConditionalAce(PACL pAcl, DWORD dwAceRevision, DWORD AceFlags, UCHAR AceType, DWORD AccessMask, PSID pSid, PWCHAR ConditionStr, DWORD *ReturnLength)
     * }
     */
    public static int AddConditionalAce(MemorySegment pAcl, int dwAceRevision, int AceFlags, byte AceType, int AccessMask, MemorySegment pSid, MemorySegment ConditionStr, MemorySegment ReturnLength) {
        var mh$ = AddConditionalAce.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("AddConditionalAce", pAcl, dwAceRevision, AceFlags, AceType, AccessMask, pSid, ConditionStr, ReturnLength);
            }
            return (int)mh$.invokeExact(pAcl, dwAceRevision, AceFlags, AceType, AccessMask, pSid, ConditionStr, ReturnLength);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetFileSecurityA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_LONG,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("SetFileSecurityA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetFileSecurityA(LPCSTR lpFileName, SECURITY_INFORMATION SecurityInformation, PSECURITY_DESCRIPTOR pSecurityDescriptor)
     * }
     */
    public static FunctionDescriptor SetFileSecurityA$descriptor() {
        return SetFileSecurityA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetFileSecurityA(LPCSTR lpFileName, SECURITY_INFORMATION SecurityInformation, PSECURITY_DESCRIPTOR pSecurityDescriptor)
     * }
     */
    public static MethodHandle SetFileSecurityA$handle() {
        return SetFileSecurityA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL SetFileSecurityA(LPCSTR lpFileName, SECURITY_INFORMATION SecurityInformation, PSECURITY_DESCRIPTOR pSecurityDescriptor)
     * }
     */
    public static int SetFileSecurityA(MemorySegment lpFileName, int SecurityInformation, MemorySegment pSecurityDescriptor) {
        var mh$ = SetFileSecurityA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetFileSecurityA", lpFileName, SecurityInformation, pSecurityDescriptor);
            }
            return (int)mh$.invokeExact(lpFileName, SecurityInformation, pSecurityDescriptor);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetFileSecurityA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_LONG,
            C_POINTER,
            C_LONG,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetFileSecurityA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetFileSecurityA(LPCSTR lpFileName, SECURITY_INFORMATION RequestedInformation, PSECURITY_DESCRIPTOR pSecurityDescriptor, DWORD nLength, LPDWORD lpnLengthNeeded)
     * }
     */
    public static FunctionDescriptor GetFileSecurityA$descriptor() {
        return GetFileSecurityA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetFileSecurityA(LPCSTR lpFileName, SECURITY_INFORMATION RequestedInformation, PSECURITY_DESCRIPTOR pSecurityDescriptor, DWORD nLength, LPDWORD lpnLengthNeeded)
     * }
     */
    public static MethodHandle GetFileSecurityA$handle() {
        return GetFileSecurityA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL GetFileSecurityA(LPCSTR lpFileName, SECURITY_INFORMATION RequestedInformation, PSECURITY_DESCRIPTOR pSecurityDescriptor, DWORD nLength, LPDWORD lpnLengthNeeded)
     * }
     */
    public static int GetFileSecurityA(MemorySegment lpFileName, int RequestedInformation, MemorySegment pSecurityDescriptor, int nLength, MemorySegment lpnLengthNeeded) {
        var mh$ = GetFileSecurityA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetFileSecurityA", lpFileName, RequestedInformation, pSecurityDescriptor, nLength, lpnLengthNeeded);
            }
            return (int)mh$.invokeExact(lpFileName, RequestedInformation, pSecurityDescriptor, nLength, lpnLengthNeeded);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ReadDirectoryChangesW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_LONG,
            C_INT,
            C_LONG,
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("ReadDirectoryChangesW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL ReadDirectoryChangesW(HANDLE hDirectory, LPVOID lpBuffer, DWORD nBufferLength, BOOL bWatchSubtree, DWORD dwNotifyFilter, LPDWORD lpBytesReturned, LPOVERLAPPED lpOverlapped, LPOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine)
     * }
     */
    public static FunctionDescriptor ReadDirectoryChangesW$descriptor() {
        return ReadDirectoryChangesW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL ReadDirectoryChangesW(HANDLE hDirectory, LPVOID lpBuffer, DWORD nBufferLength, BOOL bWatchSubtree, DWORD dwNotifyFilter, LPDWORD lpBytesReturned, LPOVERLAPPED lpOverlapped, LPOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine)
     * }
     */
    public static MethodHandle ReadDirectoryChangesW$handle() {
        return ReadDirectoryChangesW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL ReadDirectoryChangesW(HANDLE hDirectory, LPVOID lpBuffer, DWORD nBufferLength, BOOL bWatchSubtree, DWORD dwNotifyFilter, LPDWORD lpBytesReturned, LPOVERLAPPED lpOverlapped, LPOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine)
     * }
     */
    public static int ReadDirectoryChangesW(MemorySegment hDirectory, MemorySegment lpBuffer, int nBufferLength, int bWatchSubtree, int dwNotifyFilter, MemorySegment lpBytesReturned, MemorySegment lpOverlapped, MemorySegment lpCompletionRoutine) {
        var mh$ = ReadDirectoryChangesW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ReadDirectoryChangesW", hDirectory, lpBuffer, nBufferLength, bWatchSubtree, dwNotifyFilter, lpBytesReturned, lpOverlapped, lpCompletionRoutine);
            }
            return (int)mh$.invokeExact(hDirectory, lpBuffer, nBufferLength, bWatchSubtree, dwNotifyFilter, lpBytesReturned, lpOverlapped, lpCompletionRoutine);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ReadDirectoryChangesExW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_LONG,
            C_INT,
            C_LONG,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("ReadDirectoryChangesExW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL ReadDirectoryChangesExW(HANDLE hDirectory, LPVOID lpBuffer, DWORD nBufferLength, BOOL bWatchSubtree, DWORD dwNotifyFilter, LPDWORD lpBytesReturned, LPOVERLAPPED lpOverlapped, LPOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine, READ_DIRECTORY_NOTIFY_INFORMATION_CLASS ReadDirectoryNotifyInformationClass)
     * }
     */
    public static FunctionDescriptor ReadDirectoryChangesExW$descriptor() {
        return ReadDirectoryChangesExW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL ReadDirectoryChangesExW(HANDLE hDirectory, LPVOID lpBuffer, DWORD nBufferLength, BOOL bWatchSubtree, DWORD dwNotifyFilter, LPDWORD lpBytesReturned, LPOVERLAPPED lpOverlapped, LPOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine, READ_DIRECTORY_NOTIFY_INFORMATION_CLASS ReadDirectoryNotifyInformationClass)
     * }
     */
    public static MethodHandle ReadDirectoryChangesExW$handle() {
        return ReadDirectoryChangesExW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL ReadDirectoryChangesExW(HANDLE hDirectory, LPVOID lpBuffer, DWORD nBufferLength, BOOL bWatchSubtree, DWORD dwNotifyFilter, LPDWORD lpBytesReturned, LPOVERLAPPED lpOverlapped, LPOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine, READ_DIRECTORY_NOTIFY_INFORMATION_CLASS ReadDirectoryNotifyInformationClass)
     * }
     */
    public static int ReadDirectoryChangesExW(MemorySegment hDirectory, MemorySegment lpBuffer, int nBufferLength, int bWatchSubtree, int dwNotifyFilter, MemorySegment lpBytesReturned, MemorySegment lpOverlapped, MemorySegment lpCompletionRoutine, int ReadDirectoryNotifyInformationClass) {
        var mh$ = ReadDirectoryChangesExW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ReadDirectoryChangesExW", hDirectory, lpBuffer, nBufferLength, bWatchSubtree, dwNotifyFilter, lpBytesReturned, lpOverlapped, lpCompletionRoutine, ReadDirectoryNotifyInformationClass);
            }
            return (int)mh$.invokeExact(hDirectory, lpBuffer, nBufferLength, bWatchSubtree, dwNotifyFilter, lpBytesReturned, lpOverlapped, lpCompletionRoutine, ReadDirectoryNotifyInformationClass);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MapViewOfFileExNuma {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER,
            C_LONG,
            C_LONG,
            C_LONG,
            C_LONG_LONG,
            C_POINTER,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("MapViewOfFileExNuma"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LPVOID MapViewOfFileExNuma(HANDLE hFileMappingObject, DWORD dwDesiredAccess, DWORD dwFileOffsetHigh, DWORD dwFileOffsetLow, SIZE_T dwNumberOfBytesToMap, LPVOID lpBaseAddress, DWORD nndPreferred)
     * }
     */
    public static FunctionDescriptor MapViewOfFileExNuma$descriptor() {
        return MapViewOfFileExNuma.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LPVOID MapViewOfFileExNuma(HANDLE hFileMappingObject, DWORD dwDesiredAccess, DWORD dwFileOffsetHigh, DWORD dwFileOffsetLow, SIZE_T dwNumberOfBytesToMap, LPVOID lpBaseAddress, DWORD nndPreferred)
     * }
     */
    public static MethodHandle MapViewOfFileExNuma$handle() {
        return MapViewOfFileExNuma.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * LPVOID MapViewOfFileExNuma(HANDLE hFileMappingObject, DWORD dwDesiredAccess, DWORD dwFileOffsetHigh, DWORD dwFileOffsetLow, SIZE_T dwNumberOfBytesToMap, LPVOID lpBaseAddress, DWORD nndPreferred)
     * }
     */
    public static MemorySegment MapViewOfFileExNuma(MemorySegment hFileMappingObject, int dwDesiredAccess, int dwFileOffsetHigh, int dwFileOffsetLow, long dwNumberOfBytesToMap, MemorySegment lpBaseAddress, int nndPreferred) {
        var mh$ = MapViewOfFileExNuma.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MapViewOfFileExNuma", hFileMappingObject, dwDesiredAccess, dwFileOffsetHigh, dwFileOffsetLow, dwNumberOfBytesToMap, lpBaseAddress, nndPreferred);
            }
            return (MemorySegment)mh$.invokeExact(hFileMappingObject, dwDesiredAccess, dwFileOffsetHigh, dwFileOffsetLow, dwNumberOfBytesToMap, lpBaseAddress, nndPreferred);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class IsBadReadPtr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_LONG_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("IsBadReadPtr"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL IsBadReadPtr(const void *lp, UINT_PTR ucb)
     * }
     */
    public static FunctionDescriptor IsBadReadPtr$descriptor() {
        return IsBadReadPtr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL IsBadReadPtr(const void *lp, UINT_PTR ucb)
     * }
     */
    public static MethodHandle IsBadReadPtr$handle() {
        return IsBadReadPtr.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL IsBadReadPtr(const void *lp, UINT_PTR ucb)
     * }
     */
    public static int IsBadReadPtr(MemorySegment lp, long ucb) {
        var mh$ = IsBadReadPtr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("IsBadReadPtr", lp, ucb);
            }
            return (int)mh$.invokeExact(lp, ucb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class IsBadWritePtr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_LONG_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("IsBadWritePtr"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL IsBadWritePtr(LPVOID lp, UINT_PTR ucb)
     * }
     */
    public static FunctionDescriptor IsBadWritePtr$descriptor() {
        return IsBadWritePtr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL IsBadWritePtr(LPVOID lp, UINT_PTR ucb)
     * }
     */
    public static MethodHandle IsBadWritePtr$handle() {
        return IsBadWritePtr.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL IsBadWritePtr(LPVOID lp, UINT_PTR ucb)
     * }
     */
    public static int IsBadWritePtr(MemorySegment lp, long ucb) {
        var mh$ = IsBadWritePtr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("IsBadWritePtr", lp, ucb);
            }
            return (int)mh$.invokeExact(lp, ucb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class IsBadHugeReadPtr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_LONG_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("IsBadHugeReadPtr"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL IsBadHugeReadPtr(const void *lp, UINT_PTR ucb)
     * }
     */
    public static FunctionDescriptor IsBadHugeReadPtr$descriptor() {
        return IsBadHugeReadPtr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL IsBadHugeReadPtr(const void *lp, UINT_PTR ucb)
     * }
     */
    public static MethodHandle IsBadHugeReadPtr$handle() {
        return IsBadHugeReadPtr.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL IsBadHugeReadPtr(const void *lp, UINT_PTR ucb)
     * }
     */
    public static int IsBadHugeReadPtr(MemorySegment lp, long ucb) {
        var mh$ = IsBadHugeReadPtr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("IsBadHugeReadPtr", lp, ucb);
            }
            return (int)mh$.invokeExact(lp, ucb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class IsBadHugeWritePtr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_LONG_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("IsBadHugeWritePtr"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL IsBadHugeWritePtr(LPVOID lp, UINT_PTR ucb)
     * }
     */
    public static FunctionDescriptor IsBadHugeWritePtr$descriptor() {
        return IsBadHugeWritePtr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL IsBadHugeWritePtr(LPVOID lp, UINT_PTR ucb)
     * }
     */
    public static MethodHandle IsBadHugeWritePtr$handle() {
        return IsBadHugeWritePtr.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL IsBadHugeWritePtr(LPVOID lp, UINT_PTR ucb)
     * }
     */
    public static int IsBadHugeWritePtr(MemorySegment lp, long ucb) {
        var mh$ = IsBadHugeWritePtr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("IsBadHugeWritePtr", lp, ucb);
            }
            return (int)mh$.invokeExact(lp, ucb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class IsBadCodePtr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("IsBadCodePtr"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL IsBadCodePtr(FARPROC lpfn)
     * }
     */
    public static FunctionDescriptor IsBadCodePtr$descriptor() {
        return IsBadCodePtr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL IsBadCodePtr(FARPROC lpfn)
     * }
     */
    public static MethodHandle IsBadCodePtr$handle() {
        return IsBadCodePtr.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL IsBadCodePtr(FARPROC lpfn)
     * }
     */
    public static int IsBadCodePtr(MemorySegment lpfn) {
        var mh$ = IsBadCodePtr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("IsBadCodePtr", lpfn);
            }
            return (int)mh$.invokeExact(lpfn);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class IsBadStringPtrA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_LONG_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("IsBadStringPtrA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL IsBadStringPtrA(LPCSTR lpsz, UINT_PTR ucchMax)
     * }
     */
    public static FunctionDescriptor IsBadStringPtrA$descriptor() {
        return IsBadStringPtrA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL IsBadStringPtrA(LPCSTR lpsz, UINT_PTR ucchMax)
     * }
     */
    public static MethodHandle IsBadStringPtrA$handle() {
        return IsBadStringPtrA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL IsBadStringPtrA(LPCSTR lpsz, UINT_PTR ucchMax)
     * }
     */
    public static int IsBadStringPtrA(MemorySegment lpsz, long ucchMax) {
        var mh$ = IsBadStringPtrA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("IsBadStringPtrA", lpsz, ucchMax);
            }
            return (int)mh$.invokeExact(lpsz, ucchMax);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class IsBadStringPtrW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_LONG_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("IsBadStringPtrW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL IsBadStringPtrW(LPCWSTR lpsz, UINT_PTR ucchMax)
     * }
     */
    public static FunctionDescriptor IsBadStringPtrW$descriptor() {
        return IsBadStringPtrW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL IsBadStringPtrW(LPCWSTR lpsz, UINT_PTR ucchMax)
     * }
     */
    public static MethodHandle IsBadStringPtrW$handle() {
        return IsBadStringPtrW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL IsBadStringPtrW(LPCWSTR lpsz, UINT_PTR ucchMax)
     * }
     */
    public static int IsBadStringPtrW(MemorySegment lpsz, long ucchMax) {
        var mh$ = IsBadStringPtrW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("IsBadStringPtrW", lpsz, ucchMax);
            }
            return (int)mh$.invokeExact(lpsz, ucchMax);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LookupAccountSidA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("LookupAccountSidA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL LookupAccountSidA(LPCSTR lpSystemName, PSID Sid, LPSTR Name, LPDWORD cchName, LPSTR ReferencedDomainName, LPDWORD cchReferencedDomainName, PSID_NAME_USE peUse)
     * }
     */
    public static FunctionDescriptor LookupAccountSidA$descriptor() {
        return LookupAccountSidA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL LookupAccountSidA(LPCSTR lpSystemName, PSID Sid, LPSTR Name, LPDWORD cchName, LPSTR ReferencedDomainName, LPDWORD cchReferencedDomainName, PSID_NAME_USE peUse)
     * }
     */
    public static MethodHandle LookupAccountSidA$handle() {
        return LookupAccountSidA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL LookupAccountSidA(LPCSTR lpSystemName, PSID Sid, LPSTR Name, LPDWORD cchName, LPSTR ReferencedDomainName, LPDWORD cchReferencedDomainName, PSID_NAME_USE peUse)
     * }
     */
    public static int LookupAccountSidA(MemorySegment lpSystemName, MemorySegment Sid, MemorySegment Name, MemorySegment cchName, MemorySegment ReferencedDomainName, MemorySegment cchReferencedDomainName, MemorySegment peUse) {
        var mh$ = LookupAccountSidA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LookupAccountSidA", lpSystemName, Sid, Name, cchName, ReferencedDomainName, cchReferencedDomainName, peUse);
            }
            return (int)mh$.invokeExact(lpSystemName, Sid, Name, cchName, ReferencedDomainName, cchReferencedDomainName, peUse);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LookupAccountSidW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("LookupAccountSidW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL LookupAccountSidW(LPCWSTR lpSystemName, PSID Sid, LPWSTR Name, LPDWORD cchName, LPWSTR ReferencedDomainName, LPDWORD cchReferencedDomainName, PSID_NAME_USE peUse)
     * }
     */
    public static FunctionDescriptor LookupAccountSidW$descriptor() {
        return LookupAccountSidW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL LookupAccountSidW(LPCWSTR lpSystemName, PSID Sid, LPWSTR Name, LPDWORD cchName, LPWSTR ReferencedDomainName, LPDWORD cchReferencedDomainName, PSID_NAME_USE peUse)
     * }
     */
    public static MethodHandle LookupAccountSidW$handle() {
        return LookupAccountSidW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL LookupAccountSidW(LPCWSTR lpSystemName, PSID Sid, LPWSTR Name, LPDWORD cchName, LPWSTR ReferencedDomainName, LPDWORD cchReferencedDomainName, PSID_NAME_USE peUse)
     * }
     */
    public static int LookupAccountSidW(MemorySegment lpSystemName, MemorySegment Sid, MemorySegment Name, MemorySegment cchName, MemorySegment ReferencedDomainName, MemorySegment cchReferencedDomainName, MemorySegment peUse) {
        var mh$ = LookupAccountSidW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LookupAccountSidW", lpSystemName, Sid, Name, cchName, ReferencedDomainName, cchReferencedDomainName, peUse);
            }
            return (int)mh$.invokeExact(lpSystemName, Sid, Name, cchName, ReferencedDomainName, cchReferencedDomainName, peUse);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LookupAccountNameA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("LookupAccountNameA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL LookupAccountNameA(LPCSTR lpSystemName, LPCSTR lpAccountName, PSID Sid, LPDWORD cbSid, LPSTR ReferencedDomainName, LPDWORD cchReferencedDomainName, PSID_NAME_USE peUse)
     * }
     */
    public static FunctionDescriptor LookupAccountNameA$descriptor() {
        return LookupAccountNameA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL LookupAccountNameA(LPCSTR lpSystemName, LPCSTR lpAccountName, PSID Sid, LPDWORD cbSid, LPSTR ReferencedDomainName, LPDWORD cchReferencedDomainName, PSID_NAME_USE peUse)
     * }
     */
    public static MethodHandle LookupAccountNameA$handle() {
        return LookupAccountNameA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL LookupAccountNameA(LPCSTR lpSystemName, LPCSTR lpAccountName, PSID Sid, LPDWORD cbSid, LPSTR ReferencedDomainName, LPDWORD cchReferencedDomainName, PSID_NAME_USE peUse)
     * }
     */
    public static int LookupAccountNameA(MemorySegment lpSystemName, MemorySegment lpAccountName, MemorySegment Sid, MemorySegment cbSid, MemorySegment ReferencedDomainName, MemorySegment cchReferencedDomainName, MemorySegment peUse) {
        var mh$ = LookupAccountNameA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LookupAccountNameA", lpSystemName, lpAccountName, Sid, cbSid, ReferencedDomainName, cchReferencedDomainName, peUse);
            }
            return (int)mh$.invokeExact(lpSystemName, lpAccountName, Sid, cbSid, ReferencedDomainName, cchReferencedDomainName, peUse);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LookupAccountNameW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("LookupAccountNameW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL LookupAccountNameW(LPCWSTR lpSystemName, LPCWSTR lpAccountName, PSID Sid, LPDWORD cbSid, LPWSTR ReferencedDomainName, LPDWORD cchReferencedDomainName, PSID_NAME_USE peUse)
     * }
     */
    public static FunctionDescriptor LookupAccountNameW$descriptor() {
        return LookupAccountNameW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL LookupAccountNameW(LPCWSTR lpSystemName, LPCWSTR lpAccountName, PSID Sid, LPDWORD cbSid, LPWSTR ReferencedDomainName, LPDWORD cchReferencedDomainName, PSID_NAME_USE peUse)
     * }
     */
    public static MethodHandle LookupAccountNameW$handle() {
        return LookupAccountNameW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL LookupAccountNameW(LPCWSTR lpSystemName, LPCWSTR lpAccountName, PSID Sid, LPDWORD cbSid, LPWSTR ReferencedDomainName, LPDWORD cchReferencedDomainName, PSID_NAME_USE peUse)
     * }
     */
    public static int LookupAccountNameW(MemorySegment lpSystemName, MemorySegment lpAccountName, MemorySegment Sid, MemorySegment cbSid, MemorySegment ReferencedDomainName, MemorySegment cchReferencedDomainName, MemorySegment peUse) {
        var mh$ = LookupAccountNameW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LookupAccountNameW", lpSystemName, lpAccountName, Sid, cbSid, ReferencedDomainName, cchReferencedDomainName, peUse);
            }
            return (int)mh$.invokeExact(lpSystemName, lpAccountName, Sid, cbSid, ReferencedDomainName, cchReferencedDomainName, peUse);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LookupAccountNameLocalA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("LookupAccountNameLocalA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL LookupAccountNameLocalA(LPCSTR lpAccountName, PSID Sid, LPDWORD cbSid, LPSTR ReferencedDomainName, LPDWORD cchReferencedDomainName, PSID_NAME_USE peUse)
     * }
     */
    public static FunctionDescriptor LookupAccountNameLocalA$descriptor() {
        return LookupAccountNameLocalA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL LookupAccountNameLocalA(LPCSTR lpAccountName, PSID Sid, LPDWORD cbSid, LPSTR ReferencedDomainName, LPDWORD cchReferencedDomainName, PSID_NAME_USE peUse)
     * }
     */
    public static MethodHandle LookupAccountNameLocalA$handle() {
        return LookupAccountNameLocalA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL LookupAccountNameLocalA(LPCSTR lpAccountName, PSID Sid, LPDWORD cbSid, LPSTR ReferencedDomainName, LPDWORD cchReferencedDomainName, PSID_NAME_USE peUse)
     * }
     */
    public static int LookupAccountNameLocalA(MemorySegment lpAccountName, MemorySegment Sid, MemorySegment cbSid, MemorySegment ReferencedDomainName, MemorySegment cchReferencedDomainName, MemorySegment peUse) {
        var mh$ = LookupAccountNameLocalA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LookupAccountNameLocalA", lpAccountName, Sid, cbSid, ReferencedDomainName, cchReferencedDomainName, peUse);
            }
            return (int)mh$.invokeExact(lpAccountName, Sid, cbSid, ReferencedDomainName, cchReferencedDomainName, peUse);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LookupAccountNameLocalW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("LookupAccountNameLocalW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL LookupAccountNameLocalW(LPCWSTR lpAccountName, PSID Sid, LPDWORD cbSid, LPWSTR ReferencedDomainName, LPDWORD cchReferencedDomainName, PSID_NAME_USE peUse)
     * }
     */
    public static FunctionDescriptor LookupAccountNameLocalW$descriptor() {
        return LookupAccountNameLocalW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL LookupAccountNameLocalW(LPCWSTR lpAccountName, PSID Sid, LPDWORD cbSid, LPWSTR ReferencedDomainName, LPDWORD cchReferencedDomainName, PSID_NAME_USE peUse)
     * }
     */
    public static MethodHandle LookupAccountNameLocalW$handle() {
        return LookupAccountNameLocalW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL LookupAccountNameLocalW(LPCWSTR lpAccountName, PSID Sid, LPDWORD cbSid, LPWSTR ReferencedDomainName, LPDWORD cchReferencedDomainName, PSID_NAME_USE peUse)
     * }
     */
    public static int LookupAccountNameLocalW(MemorySegment lpAccountName, MemorySegment Sid, MemorySegment cbSid, MemorySegment ReferencedDomainName, MemorySegment cchReferencedDomainName, MemorySegment peUse) {
        var mh$ = LookupAccountNameLocalW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LookupAccountNameLocalW", lpAccountName, Sid, cbSid, ReferencedDomainName, cchReferencedDomainName, peUse);
            }
            return (int)mh$.invokeExact(lpAccountName, Sid, cbSid, ReferencedDomainName, cchReferencedDomainName, peUse);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LookupAccountSidLocalA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("LookupAccountSidLocalA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL LookupAccountSidLocalA(PSID Sid, LPSTR Name, LPDWORD cchName, LPSTR ReferencedDomainName, LPDWORD cchReferencedDomainName, PSID_NAME_USE peUse)
     * }
     */
    public static FunctionDescriptor LookupAccountSidLocalA$descriptor() {
        return LookupAccountSidLocalA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL LookupAccountSidLocalA(PSID Sid, LPSTR Name, LPDWORD cchName, LPSTR ReferencedDomainName, LPDWORD cchReferencedDomainName, PSID_NAME_USE peUse)
     * }
     */
    public static MethodHandle LookupAccountSidLocalA$handle() {
        return LookupAccountSidLocalA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL LookupAccountSidLocalA(PSID Sid, LPSTR Name, LPDWORD cchName, LPSTR ReferencedDomainName, LPDWORD cchReferencedDomainName, PSID_NAME_USE peUse)
     * }
     */
    public static int LookupAccountSidLocalA(MemorySegment Sid, MemorySegment Name, MemorySegment cchName, MemorySegment ReferencedDomainName, MemorySegment cchReferencedDomainName, MemorySegment peUse) {
        var mh$ = LookupAccountSidLocalA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LookupAccountSidLocalA", Sid, Name, cchName, ReferencedDomainName, cchReferencedDomainName, peUse);
            }
            return (int)mh$.invokeExact(Sid, Name, cchName, ReferencedDomainName, cchReferencedDomainName, peUse);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LookupAccountSidLocalW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("LookupAccountSidLocalW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL LookupAccountSidLocalW(PSID Sid, LPWSTR Name, LPDWORD cchName, LPWSTR ReferencedDomainName, LPDWORD cchReferencedDomainName, PSID_NAME_USE peUse)
     * }
     */
    public static FunctionDescriptor LookupAccountSidLocalW$descriptor() {
        return LookupAccountSidLocalW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL LookupAccountSidLocalW(PSID Sid, LPWSTR Name, LPDWORD cchName, LPWSTR ReferencedDomainName, LPDWORD cchReferencedDomainName, PSID_NAME_USE peUse)
     * }
     */
    public static MethodHandle LookupAccountSidLocalW$handle() {
        return LookupAccountSidLocalW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL LookupAccountSidLocalW(PSID Sid, LPWSTR Name, LPDWORD cchName, LPWSTR ReferencedDomainName, LPDWORD cchReferencedDomainName, PSID_NAME_USE peUse)
     * }
     */
    public static int LookupAccountSidLocalW(MemorySegment Sid, MemorySegment Name, MemorySegment cchName, MemorySegment ReferencedDomainName, MemorySegment cchReferencedDomainName, MemorySegment peUse) {
        var mh$ = LookupAccountSidLocalW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LookupAccountSidLocalW", Sid, Name, cchName, ReferencedDomainName, cchReferencedDomainName, peUse);
            }
            return (int)mh$.invokeExact(Sid, Name, cchName, ReferencedDomainName, cchReferencedDomainName, peUse);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LookupPrivilegeValueA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("LookupPrivilegeValueA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL LookupPrivilegeValueA(LPCSTR lpSystemName, LPCSTR lpName, PLUID lpLuid)
     * }
     */
    public static FunctionDescriptor LookupPrivilegeValueA$descriptor() {
        return LookupPrivilegeValueA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL LookupPrivilegeValueA(LPCSTR lpSystemName, LPCSTR lpName, PLUID lpLuid)
     * }
     */
    public static MethodHandle LookupPrivilegeValueA$handle() {
        return LookupPrivilegeValueA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL LookupPrivilegeValueA(LPCSTR lpSystemName, LPCSTR lpName, PLUID lpLuid)
     * }
     */
    public static int LookupPrivilegeValueA(MemorySegment lpSystemName, MemorySegment lpName, MemorySegment lpLuid) {
        var mh$ = LookupPrivilegeValueA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LookupPrivilegeValueA", lpSystemName, lpName, lpLuid);
            }
            return (int)mh$.invokeExact(lpSystemName, lpName, lpLuid);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LookupPrivilegeValueW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("LookupPrivilegeValueW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL LookupPrivilegeValueW(LPCWSTR lpSystemName, LPCWSTR lpName, PLUID lpLuid)
     * }
     */
    public static FunctionDescriptor LookupPrivilegeValueW$descriptor() {
        return LookupPrivilegeValueW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL LookupPrivilegeValueW(LPCWSTR lpSystemName, LPCWSTR lpName, PLUID lpLuid)
     * }
     */
    public static MethodHandle LookupPrivilegeValueW$handle() {
        return LookupPrivilegeValueW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL LookupPrivilegeValueW(LPCWSTR lpSystemName, LPCWSTR lpName, PLUID lpLuid)
     * }
     */
    public static int LookupPrivilegeValueW(MemorySegment lpSystemName, MemorySegment lpName, MemorySegment lpLuid) {
        var mh$ = LookupPrivilegeValueW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LookupPrivilegeValueW", lpSystemName, lpName, lpLuid);
            }
            return (int)mh$.invokeExact(lpSystemName, lpName, lpLuid);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LookupPrivilegeNameA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("LookupPrivilegeNameA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL LookupPrivilegeNameA(LPCSTR lpSystemName, PLUID lpLuid, LPSTR lpName, LPDWORD cchName)
     * }
     */
    public static FunctionDescriptor LookupPrivilegeNameA$descriptor() {
        return LookupPrivilegeNameA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL LookupPrivilegeNameA(LPCSTR lpSystemName, PLUID lpLuid, LPSTR lpName, LPDWORD cchName)
     * }
     */
    public static MethodHandle LookupPrivilegeNameA$handle() {
        return LookupPrivilegeNameA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL LookupPrivilegeNameA(LPCSTR lpSystemName, PLUID lpLuid, LPSTR lpName, LPDWORD cchName)
     * }
     */
    public static int LookupPrivilegeNameA(MemorySegment lpSystemName, MemorySegment lpLuid, MemorySegment lpName, MemorySegment cchName) {
        var mh$ = LookupPrivilegeNameA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LookupPrivilegeNameA", lpSystemName, lpLuid, lpName, cchName);
            }
            return (int)mh$.invokeExact(lpSystemName, lpLuid, lpName, cchName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LookupPrivilegeNameW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("LookupPrivilegeNameW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL LookupPrivilegeNameW(LPCWSTR lpSystemName, PLUID lpLuid, LPWSTR lpName, LPDWORD cchName)
     * }
     */
    public static FunctionDescriptor LookupPrivilegeNameW$descriptor() {
        return LookupPrivilegeNameW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL LookupPrivilegeNameW(LPCWSTR lpSystemName, PLUID lpLuid, LPWSTR lpName, LPDWORD cchName)
     * }
     */
    public static MethodHandle LookupPrivilegeNameW$handle() {
        return LookupPrivilegeNameW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL LookupPrivilegeNameW(LPCWSTR lpSystemName, PLUID lpLuid, LPWSTR lpName, LPDWORD cchName)
     * }
     */
    public static int LookupPrivilegeNameW(MemorySegment lpSystemName, MemorySegment lpLuid, MemorySegment lpName, MemorySegment cchName) {
        var mh$ = LookupPrivilegeNameW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LookupPrivilegeNameW", lpSystemName, lpLuid, lpName, cchName);
            }
            return (int)mh$.invokeExact(lpSystemName, lpLuid, lpName, cchName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LookupPrivilegeDisplayNameA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("LookupPrivilegeDisplayNameA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL LookupPrivilegeDisplayNameA(LPCSTR lpSystemName, LPCSTR lpName, LPSTR lpDisplayName, LPDWORD cchDisplayName, LPDWORD lpLanguageId)
     * }
     */
    public static FunctionDescriptor LookupPrivilegeDisplayNameA$descriptor() {
        return LookupPrivilegeDisplayNameA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL LookupPrivilegeDisplayNameA(LPCSTR lpSystemName, LPCSTR lpName, LPSTR lpDisplayName, LPDWORD cchDisplayName, LPDWORD lpLanguageId)
     * }
     */
    public static MethodHandle LookupPrivilegeDisplayNameA$handle() {
        return LookupPrivilegeDisplayNameA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL LookupPrivilegeDisplayNameA(LPCSTR lpSystemName, LPCSTR lpName, LPSTR lpDisplayName, LPDWORD cchDisplayName, LPDWORD lpLanguageId)
     * }
     */
    public static int LookupPrivilegeDisplayNameA(MemorySegment lpSystemName, MemorySegment lpName, MemorySegment lpDisplayName, MemorySegment cchDisplayName, MemorySegment lpLanguageId) {
        var mh$ = LookupPrivilegeDisplayNameA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LookupPrivilegeDisplayNameA", lpSystemName, lpName, lpDisplayName, cchDisplayName, lpLanguageId);
            }
            return (int)mh$.invokeExact(lpSystemName, lpName, lpDisplayName, cchDisplayName, lpLanguageId);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LookupPrivilegeDisplayNameW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("LookupPrivilegeDisplayNameW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL LookupPrivilegeDisplayNameW(LPCWSTR lpSystemName, LPCWSTR lpName, LPWSTR lpDisplayName, LPDWORD cchDisplayName, LPDWORD lpLanguageId)
     * }
     */
    public static FunctionDescriptor LookupPrivilegeDisplayNameW$descriptor() {
        return LookupPrivilegeDisplayNameW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL LookupPrivilegeDisplayNameW(LPCWSTR lpSystemName, LPCWSTR lpName, LPWSTR lpDisplayName, LPDWORD cchDisplayName, LPDWORD lpLanguageId)
     * }
     */
    public static MethodHandle LookupPrivilegeDisplayNameW$handle() {
        return LookupPrivilegeDisplayNameW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL LookupPrivilegeDisplayNameW(LPCWSTR lpSystemName, LPCWSTR lpName, LPWSTR lpDisplayName, LPDWORD cchDisplayName, LPDWORD lpLanguageId)
     * }
     */
    public static int LookupPrivilegeDisplayNameW(MemorySegment lpSystemName, MemorySegment lpName, MemorySegment lpDisplayName, MemorySegment cchDisplayName, MemorySegment lpLanguageId) {
        var mh$ = LookupPrivilegeDisplayNameW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LookupPrivilegeDisplayNameW", lpSystemName, lpName, lpDisplayName, cchDisplayName, lpLanguageId);
            }
            return (int)mh$.invokeExact(lpSystemName, lpName, lpDisplayName, cchDisplayName, lpLanguageId);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class BuildCommDCBA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("BuildCommDCBA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL BuildCommDCBA(LPCSTR lpDef, LPDCB lpDCB)
     * }
     */
    public static FunctionDescriptor BuildCommDCBA$descriptor() {
        return BuildCommDCBA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL BuildCommDCBA(LPCSTR lpDef, LPDCB lpDCB)
     * }
     */
    public static MethodHandle BuildCommDCBA$handle() {
        return BuildCommDCBA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL BuildCommDCBA(LPCSTR lpDef, LPDCB lpDCB)
     * }
     */
    public static int BuildCommDCBA(MemorySegment lpDef, MemorySegment lpDCB) {
        var mh$ = BuildCommDCBA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("BuildCommDCBA", lpDef, lpDCB);
            }
            return (int)mh$.invokeExact(lpDef, lpDCB);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class BuildCommDCBW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("BuildCommDCBW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL BuildCommDCBW(LPCWSTR lpDef, LPDCB lpDCB)
     * }
     */
    public static FunctionDescriptor BuildCommDCBW$descriptor() {
        return BuildCommDCBW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL BuildCommDCBW(LPCWSTR lpDef, LPDCB lpDCB)
     * }
     */
    public static MethodHandle BuildCommDCBW$handle() {
        return BuildCommDCBW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL BuildCommDCBW(LPCWSTR lpDef, LPDCB lpDCB)
     * }
     */
    public static int BuildCommDCBW(MemorySegment lpDef, MemorySegment lpDCB) {
        var mh$ = BuildCommDCBW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("BuildCommDCBW", lpDef, lpDCB);
            }
            return (int)mh$.invokeExact(lpDef, lpDCB);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class BuildCommDCBAndTimeoutsA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("BuildCommDCBAndTimeoutsA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL BuildCommDCBAndTimeoutsA(LPCSTR lpDef, LPDCB lpDCB, LPCOMMTIMEOUTS lpCommTimeouts)
     * }
     */
    public static FunctionDescriptor BuildCommDCBAndTimeoutsA$descriptor() {
        return BuildCommDCBAndTimeoutsA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL BuildCommDCBAndTimeoutsA(LPCSTR lpDef, LPDCB lpDCB, LPCOMMTIMEOUTS lpCommTimeouts)
     * }
     */
    public static MethodHandle BuildCommDCBAndTimeoutsA$handle() {
        return BuildCommDCBAndTimeoutsA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL BuildCommDCBAndTimeoutsA(LPCSTR lpDef, LPDCB lpDCB, LPCOMMTIMEOUTS lpCommTimeouts)
     * }
     */
    public static int BuildCommDCBAndTimeoutsA(MemorySegment lpDef, MemorySegment lpDCB, MemorySegment lpCommTimeouts) {
        var mh$ = BuildCommDCBAndTimeoutsA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("BuildCommDCBAndTimeoutsA", lpDef, lpDCB, lpCommTimeouts);
            }
            return (int)mh$.invokeExact(lpDef, lpDCB, lpCommTimeouts);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class BuildCommDCBAndTimeoutsW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("BuildCommDCBAndTimeoutsW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL BuildCommDCBAndTimeoutsW(LPCWSTR lpDef, LPDCB lpDCB, LPCOMMTIMEOUTS lpCommTimeouts)
     * }
     */
    public static FunctionDescriptor BuildCommDCBAndTimeoutsW$descriptor() {
        return BuildCommDCBAndTimeoutsW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL BuildCommDCBAndTimeoutsW(LPCWSTR lpDef, LPDCB lpDCB, LPCOMMTIMEOUTS lpCommTimeouts)
     * }
     */
    public static MethodHandle BuildCommDCBAndTimeoutsW$handle() {
        return BuildCommDCBAndTimeoutsW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL BuildCommDCBAndTimeoutsW(LPCWSTR lpDef, LPDCB lpDCB, LPCOMMTIMEOUTS lpCommTimeouts)
     * }
     */
    public static int BuildCommDCBAndTimeoutsW(MemorySegment lpDef, MemorySegment lpDCB, MemorySegment lpCommTimeouts) {
        var mh$ = BuildCommDCBAndTimeoutsW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("BuildCommDCBAndTimeoutsW", lpDef, lpDCB, lpCommTimeouts);
            }
            return (int)mh$.invokeExact(lpDef, lpDCB, lpCommTimeouts);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CommConfigDialogA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CommConfigDialogA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CommConfigDialogA(LPCSTR lpszName, HWND hWnd, LPCOMMCONFIG lpCC)
     * }
     */
    public static FunctionDescriptor CommConfigDialogA$descriptor() {
        return CommConfigDialogA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CommConfigDialogA(LPCSTR lpszName, HWND hWnd, LPCOMMCONFIG lpCC)
     * }
     */
    public static MethodHandle CommConfigDialogA$handle() {
        return CommConfigDialogA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL CommConfigDialogA(LPCSTR lpszName, HWND hWnd, LPCOMMCONFIG lpCC)
     * }
     */
    public static int CommConfigDialogA(MemorySegment lpszName, MemorySegment hWnd, MemorySegment lpCC) {
        var mh$ = CommConfigDialogA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CommConfigDialogA", lpszName, hWnd, lpCC);
            }
            return (int)mh$.invokeExact(lpszName, hWnd, lpCC);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CommConfigDialogW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CommConfigDialogW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CommConfigDialogW(LPCWSTR lpszName, HWND hWnd, LPCOMMCONFIG lpCC)
     * }
     */
    public static FunctionDescriptor CommConfigDialogW$descriptor() {
        return CommConfigDialogW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CommConfigDialogW(LPCWSTR lpszName, HWND hWnd, LPCOMMCONFIG lpCC)
     * }
     */
    public static MethodHandle CommConfigDialogW$handle() {
        return CommConfigDialogW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL CommConfigDialogW(LPCWSTR lpszName, HWND hWnd, LPCOMMCONFIG lpCC)
     * }
     */
    public static int CommConfigDialogW(MemorySegment lpszName, MemorySegment hWnd, MemorySegment lpCC) {
        var mh$ = CommConfigDialogW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CommConfigDialogW", lpszName, hWnd, lpCC);
            }
            return (int)mh$.invokeExact(lpszName, hWnd, lpCC);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetDefaultCommConfigA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetDefaultCommConfigA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetDefaultCommConfigA(LPCSTR lpszName, LPCOMMCONFIG lpCC, LPDWORD lpdwSize)
     * }
     */
    public static FunctionDescriptor GetDefaultCommConfigA$descriptor() {
        return GetDefaultCommConfigA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetDefaultCommConfigA(LPCSTR lpszName, LPCOMMCONFIG lpCC, LPDWORD lpdwSize)
     * }
     */
    public static MethodHandle GetDefaultCommConfigA$handle() {
        return GetDefaultCommConfigA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL GetDefaultCommConfigA(LPCSTR lpszName, LPCOMMCONFIG lpCC, LPDWORD lpdwSize)
     * }
     */
    public static int GetDefaultCommConfigA(MemorySegment lpszName, MemorySegment lpCC, MemorySegment lpdwSize) {
        var mh$ = GetDefaultCommConfigA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetDefaultCommConfigA", lpszName, lpCC, lpdwSize);
            }
            return (int)mh$.invokeExact(lpszName, lpCC, lpdwSize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetDefaultCommConfigW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetDefaultCommConfigW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetDefaultCommConfigW(LPCWSTR lpszName, LPCOMMCONFIG lpCC, LPDWORD lpdwSize)
     * }
     */
    public static FunctionDescriptor GetDefaultCommConfigW$descriptor() {
        return GetDefaultCommConfigW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetDefaultCommConfigW(LPCWSTR lpszName, LPCOMMCONFIG lpCC, LPDWORD lpdwSize)
     * }
     */
    public static MethodHandle GetDefaultCommConfigW$handle() {
        return GetDefaultCommConfigW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL GetDefaultCommConfigW(LPCWSTR lpszName, LPCOMMCONFIG lpCC, LPDWORD lpdwSize)
     * }
     */
    public static int GetDefaultCommConfigW(MemorySegment lpszName, MemorySegment lpCC, MemorySegment lpdwSize) {
        var mh$ = GetDefaultCommConfigW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetDefaultCommConfigW", lpszName, lpCC, lpdwSize);
            }
            return (int)mh$.invokeExact(lpszName, lpCC, lpdwSize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetDefaultCommConfigA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("SetDefaultCommConfigA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetDefaultCommConfigA(LPCSTR lpszName, LPCOMMCONFIG lpCC, DWORD dwSize)
     * }
     */
    public static FunctionDescriptor SetDefaultCommConfigA$descriptor() {
        return SetDefaultCommConfigA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetDefaultCommConfigA(LPCSTR lpszName, LPCOMMCONFIG lpCC, DWORD dwSize)
     * }
     */
    public static MethodHandle SetDefaultCommConfigA$handle() {
        return SetDefaultCommConfigA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL SetDefaultCommConfigA(LPCSTR lpszName, LPCOMMCONFIG lpCC, DWORD dwSize)
     * }
     */
    public static int SetDefaultCommConfigA(MemorySegment lpszName, MemorySegment lpCC, int dwSize) {
        var mh$ = SetDefaultCommConfigA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetDefaultCommConfigA", lpszName, lpCC, dwSize);
            }
            return (int)mh$.invokeExact(lpszName, lpCC, dwSize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetDefaultCommConfigW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("SetDefaultCommConfigW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetDefaultCommConfigW(LPCWSTR lpszName, LPCOMMCONFIG lpCC, DWORD dwSize)
     * }
     */
    public static FunctionDescriptor SetDefaultCommConfigW$descriptor() {
        return SetDefaultCommConfigW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetDefaultCommConfigW(LPCWSTR lpszName, LPCOMMCONFIG lpCC, DWORD dwSize)
     * }
     */
    public static MethodHandle SetDefaultCommConfigW$handle() {
        return SetDefaultCommConfigW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL SetDefaultCommConfigW(LPCWSTR lpszName, LPCOMMCONFIG lpCC, DWORD dwSize)
     * }
     */
    public static int SetDefaultCommConfigW(MemorySegment lpszName, MemorySegment lpCC, int dwSize) {
        var mh$ = SetDefaultCommConfigW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetDefaultCommConfigW", lpszName, lpCC, dwSize);
            }
            return (int)mh$.invokeExact(lpszName, lpCC, dwSize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetComputerNameA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetComputerNameA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetComputerNameA(LPSTR lpBuffer, LPDWORD nSize)
     * }
     */
    public static FunctionDescriptor GetComputerNameA$descriptor() {
        return GetComputerNameA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetComputerNameA(LPSTR lpBuffer, LPDWORD nSize)
     * }
     */
    public static MethodHandle GetComputerNameA$handle() {
        return GetComputerNameA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL GetComputerNameA(LPSTR lpBuffer, LPDWORD nSize)
     * }
     */
    public static int GetComputerNameA(MemorySegment lpBuffer, MemorySegment nSize) {
        var mh$ = GetComputerNameA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetComputerNameA", lpBuffer, nSize);
            }
            return (int)mh$.invokeExact(lpBuffer, nSize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetComputerNameW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetComputerNameW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetComputerNameW(LPWSTR lpBuffer, LPDWORD nSize)
     * }
     */
    public static FunctionDescriptor GetComputerNameW$descriptor() {
        return GetComputerNameW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetComputerNameW(LPWSTR lpBuffer, LPDWORD nSize)
     * }
     */
    public static MethodHandle GetComputerNameW$handle() {
        return GetComputerNameW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL GetComputerNameW(LPWSTR lpBuffer, LPDWORD nSize)
     * }
     */
    public static int GetComputerNameW(MemorySegment lpBuffer, MemorySegment nSize) {
        var mh$ = GetComputerNameW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetComputerNameW", lpBuffer, nSize);
            }
            return (int)mh$.invokeExact(lpBuffer, nSize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DnsHostnameToComputerNameA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("DnsHostnameToComputerNameA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL DnsHostnameToComputerNameA(LPCSTR Hostname, LPSTR ComputerName, LPDWORD nSize)
     * }
     */
    public static FunctionDescriptor DnsHostnameToComputerNameA$descriptor() {
        return DnsHostnameToComputerNameA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL DnsHostnameToComputerNameA(LPCSTR Hostname, LPSTR ComputerName, LPDWORD nSize)
     * }
     */
    public static MethodHandle DnsHostnameToComputerNameA$handle() {
        return DnsHostnameToComputerNameA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL DnsHostnameToComputerNameA(LPCSTR Hostname, LPSTR ComputerName, LPDWORD nSize)
     * }
     */
    public static int DnsHostnameToComputerNameA(MemorySegment Hostname, MemorySegment ComputerName, MemorySegment nSize) {
        var mh$ = DnsHostnameToComputerNameA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DnsHostnameToComputerNameA", Hostname, ComputerName, nSize);
            }
            return (int)mh$.invokeExact(Hostname, ComputerName, nSize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DnsHostnameToComputerNameW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("DnsHostnameToComputerNameW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL DnsHostnameToComputerNameW(LPCWSTR Hostname, LPWSTR ComputerName, LPDWORD nSize)
     * }
     */
    public static FunctionDescriptor DnsHostnameToComputerNameW$descriptor() {
        return DnsHostnameToComputerNameW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL DnsHostnameToComputerNameW(LPCWSTR Hostname, LPWSTR ComputerName, LPDWORD nSize)
     * }
     */
    public static MethodHandle DnsHostnameToComputerNameW$handle() {
        return DnsHostnameToComputerNameW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL DnsHostnameToComputerNameW(LPCWSTR Hostname, LPWSTR ComputerName, LPDWORD nSize)
     * }
     */
    public static int DnsHostnameToComputerNameW(MemorySegment Hostname, MemorySegment ComputerName, MemorySegment nSize) {
        var mh$ = DnsHostnameToComputerNameW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DnsHostnameToComputerNameW", Hostname, ComputerName, nSize);
            }
            return (int)mh$.invokeExact(Hostname, ComputerName, nSize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetUserNameA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetUserNameA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetUserNameA(LPSTR lpBuffer, LPDWORD pcbBuffer)
     * }
     */
    public static FunctionDescriptor GetUserNameA$descriptor() {
        return GetUserNameA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetUserNameA(LPSTR lpBuffer, LPDWORD pcbBuffer)
     * }
     */
    public static MethodHandle GetUserNameA$handle() {
        return GetUserNameA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL GetUserNameA(LPSTR lpBuffer, LPDWORD pcbBuffer)
     * }
     */
    public static int GetUserNameA(MemorySegment lpBuffer, MemorySegment pcbBuffer) {
        var mh$ = GetUserNameA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetUserNameA", lpBuffer, pcbBuffer);
            }
            return (int)mh$.invokeExact(lpBuffer, pcbBuffer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetUserNameW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetUserNameW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetUserNameW(LPWSTR lpBuffer, LPDWORD pcbBuffer)
     * }
     */
    public static FunctionDescriptor GetUserNameW$descriptor() {
        return GetUserNameW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetUserNameW(LPWSTR lpBuffer, LPDWORD pcbBuffer)
     * }
     */
    public static MethodHandle GetUserNameW$handle() {
        return GetUserNameW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL GetUserNameW(LPWSTR lpBuffer, LPDWORD pcbBuffer)
     * }
     */
    public static int GetUserNameW(MemorySegment lpBuffer, MemorySegment pcbBuffer) {
        var mh$ = GetUserNameW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetUserNameW", lpBuffer, pcbBuffer);
            }
            return (int)mh$.invokeExact(lpBuffer, pcbBuffer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LogonUserA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_LONG,
            C_LONG,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("LogonUserA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL LogonUserA(LPCSTR lpszUsername, LPCSTR lpszDomain, LPCSTR lpszPassword, DWORD dwLogonType, DWORD dwLogonProvider, PHANDLE phToken)
     * }
     */
    public static FunctionDescriptor LogonUserA$descriptor() {
        return LogonUserA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL LogonUserA(LPCSTR lpszUsername, LPCSTR lpszDomain, LPCSTR lpszPassword, DWORD dwLogonType, DWORD dwLogonProvider, PHANDLE phToken)
     * }
     */
    public static MethodHandle LogonUserA$handle() {
        return LogonUserA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL LogonUserA(LPCSTR lpszUsername, LPCSTR lpszDomain, LPCSTR lpszPassword, DWORD dwLogonType, DWORD dwLogonProvider, PHANDLE phToken)
     * }
     */
    public static int LogonUserA(MemorySegment lpszUsername, MemorySegment lpszDomain, MemorySegment lpszPassword, int dwLogonType, int dwLogonProvider, MemorySegment phToken) {
        var mh$ = LogonUserA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LogonUserA", lpszUsername, lpszDomain, lpszPassword, dwLogonType, dwLogonProvider, phToken);
            }
            return (int)mh$.invokeExact(lpszUsername, lpszDomain, lpszPassword, dwLogonType, dwLogonProvider, phToken);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LogonUserW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_LONG,
            C_LONG,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("LogonUserW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL LogonUserW(LPCWSTR lpszUsername, LPCWSTR lpszDomain, LPCWSTR lpszPassword, DWORD dwLogonType, DWORD dwLogonProvider, PHANDLE phToken)
     * }
     */
    public static FunctionDescriptor LogonUserW$descriptor() {
        return LogonUserW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL LogonUserW(LPCWSTR lpszUsername, LPCWSTR lpszDomain, LPCWSTR lpszPassword, DWORD dwLogonType, DWORD dwLogonProvider, PHANDLE phToken)
     * }
     */
    public static MethodHandle LogonUserW$handle() {
        return LogonUserW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL LogonUserW(LPCWSTR lpszUsername, LPCWSTR lpszDomain, LPCWSTR lpszPassword, DWORD dwLogonType, DWORD dwLogonProvider, PHANDLE phToken)
     * }
     */
    public static int LogonUserW(MemorySegment lpszUsername, MemorySegment lpszDomain, MemorySegment lpszPassword, int dwLogonType, int dwLogonProvider, MemorySegment phToken) {
        var mh$ = LogonUserW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LogonUserW", lpszUsername, lpszDomain, lpszPassword, dwLogonType, dwLogonProvider, phToken);
            }
            return (int)mh$.invokeExact(lpszUsername, lpszDomain, lpszPassword, dwLogonType, dwLogonProvider, phToken);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LogonUserExA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_LONG,
            C_LONG,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("LogonUserExA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL LogonUserExA(LPCSTR lpszUsername, LPCSTR lpszDomain, LPCSTR lpszPassword, DWORD dwLogonType, DWORD dwLogonProvider, PHANDLE phToken, PSID *ppLogonSid, PVOID *ppProfileBuffer, LPDWORD pdwProfileLength, PQUOTA_LIMITS pQuotaLimits)
     * }
     */
    public static FunctionDescriptor LogonUserExA$descriptor() {
        return LogonUserExA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL LogonUserExA(LPCSTR lpszUsername, LPCSTR lpszDomain, LPCSTR lpszPassword, DWORD dwLogonType, DWORD dwLogonProvider, PHANDLE phToken, PSID *ppLogonSid, PVOID *ppProfileBuffer, LPDWORD pdwProfileLength, PQUOTA_LIMITS pQuotaLimits)
     * }
     */
    public static MethodHandle LogonUserExA$handle() {
        return LogonUserExA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL LogonUserExA(LPCSTR lpszUsername, LPCSTR lpszDomain, LPCSTR lpszPassword, DWORD dwLogonType, DWORD dwLogonProvider, PHANDLE phToken, PSID *ppLogonSid, PVOID *ppProfileBuffer, LPDWORD pdwProfileLength, PQUOTA_LIMITS pQuotaLimits)
     * }
     */
    public static int LogonUserExA(MemorySegment lpszUsername, MemorySegment lpszDomain, MemorySegment lpszPassword, int dwLogonType, int dwLogonProvider, MemorySegment phToken, MemorySegment ppLogonSid, MemorySegment ppProfileBuffer, MemorySegment pdwProfileLength, MemorySegment pQuotaLimits) {
        var mh$ = LogonUserExA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LogonUserExA", lpszUsername, lpszDomain, lpszPassword, dwLogonType, dwLogonProvider, phToken, ppLogonSid, ppProfileBuffer, pdwProfileLength, pQuotaLimits);
            }
            return (int)mh$.invokeExact(lpszUsername, lpszDomain, lpszPassword, dwLogonType, dwLogonProvider, phToken, ppLogonSid, ppProfileBuffer, pdwProfileLength, pQuotaLimits);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LogonUserExW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_LONG,
            C_LONG,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("LogonUserExW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL LogonUserExW(LPCWSTR lpszUsername, LPCWSTR lpszDomain, LPCWSTR lpszPassword, DWORD dwLogonType, DWORD dwLogonProvider, PHANDLE phToken, PSID *ppLogonSid, PVOID *ppProfileBuffer, LPDWORD pdwProfileLength, PQUOTA_LIMITS pQuotaLimits)
     * }
     */
    public static FunctionDescriptor LogonUserExW$descriptor() {
        return LogonUserExW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL LogonUserExW(LPCWSTR lpszUsername, LPCWSTR lpszDomain, LPCWSTR lpszPassword, DWORD dwLogonType, DWORD dwLogonProvider, PHANDLE phToken, PSID *ppLogonSid, PVOID *ppProfileBuffer, LPDWORD pdwProfileLength, PQUOTA_LIMITS pQuotaLimits)
     * }
     */
    public static MethodHandle LogonUserExW$handle() {
        return LogonUserExW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL LogonUserExW(LPCWSTR lpszUsername, LPCWSTR lpszDomain, LPCWSTR lpszPassword, DWORD dwLogonType, DWORD dwLogonProvider, PHANDLE phToken, PSID *ppLogonSid, PVOID *ppProfileBuffer, LPDWORD pdwProfileLength, PQUOTA_LIMITS pQuotaLimits)
     * }
     */
    public static int LogonUserExW(MemorySegment lpszUsername, MemorySegment lpszDomain, MemorySegment lpszPassword, int dwLogonType, int dwLogonProvider, MemorySegment phToken, MemorySegment ppLogonSid, MemorySegment ppProfileBuffer, MemorySegment pdwProfileLength, MemorySegment pQuotaLimits) {
        var mh$ = LogonUserExW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LogonUserExW", lpszUsername, lpszDomain, lpszPassword, dwLogonType, dwLogonProvider, phToken, ppLogonSid, ppProfileBuffer, pdwProfileLength, pQuotaLimits);
            }
            return (int)mh$.invokeExact(lpszUsername, lpszDomain, lpszPassword, dwLogonType, dwLogonProvider, phToken, ppLogonSid, ppProfileBuffer, pdwProfileLength, pQuotaLimits);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateProcessWithLogonW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_LONG,
            C_POINTER,
            C_POINTER,
            C_LONG,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CreateProcessWithLogonW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CreateProcessWithLogonW(LPCWSTR lpUsername, LPCWSTR lpDomain, LPCWSTR lpPassword, DWORD dwLogonFlags, LPCWSTR lpApplicationName, LPWSTR lpCommandLine, DWORD dwCreationFlags, LPVOID lpEnvironment, LPCWSTR lpCurrentDirectory, LPSTARTUPINFOW lpStartupInfo, LPPROCESS_INFORMATION lpProcessInformation)
     * }
     */
    public static FunctionDescriptor CreateProcessWithLogonW$descriptor() {
        return CreateProcessWithLogonW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CreateProcessWithLogonW(LPCWSTR lpUsername, LPCWSTR lpDomain, LPCWSTR lpPassword, DWORD dwLogonFlags, LPCWSTR lpApplicationName, LPWSTR lpCommandLine, DWORD dwCreationFlags, LPVOID lpEnvironment, LPCWSTR lpCurrentDirectory, LPSTARTUPINFOW lpStartupInfo, LPPROCESS_INFORMATION lpProcessInformation)
     * }
     */
    public static MethodHandle CreateProcessWithLogonW$handle() {
        return CreateProcessWithLogonW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL CreateProcessWithLogonW(LPCWSTR lpUsername, LPCWSTR lpDomain, LPCWSTR lpPassword, DWORD dwLogonFlags, LPCWSTR lpApplicationName, LPWSTR lpCommandLine, DWORD dwCreationFlags, LPVOID lpEnvironment, LPCWSTR lpCurrentDirectory, LPSTARTUPINFOW lpStartupInfo, LPPROCESS_INFORMATION lpProcessInformation)
     * }
     */
    public static int CreateProcessWithLogonW(MemorySegment lpUsername, MemorySegment lpDomain, MemorySegment lpPassword, int dwLogonFlags, MemorySegment lpApplicationName, MemorySegment lpCommandLine, int dwCreationFlags, MemorySegment lpEnvironment, MemorySegment lpCurrentDirectory, MemorySegment lpStartupInfo, MemorySegment lpProcessInformation) {
        var mh$ = CreateProcessWithLogonW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateProcessWithLogonW", lpUsername, lpDomain, lpPassword, dwLogonFlags, lpApplicationName, lpCommandLine, dwCreationFlags, lpEnvironment, lpCurrentDirectory, lpStartupInfo, lpProcessInformation);
            }
            return (int)mh$.invokeExact(lpUsername, lpDomain, lpPassword, dwLogonFlags, lpApplicationName, lpCommandLine, dwCreationFlags, lpEnvironment, lpCurrentDirectory, lpStartupInfo, lpProcessInformation);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateProcessWithTokenW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_LONG,
            C_POINTER,
            C_POINTER,
            C_LONG,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CreateProcessWithTokenW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CreateProcessWithTokenW(HANDLE hToken, DWORD dwLogonFlags, LPCWSTR lpApplicationName, LPWSTR lpCommandLine, DWORD dwCreationFlags, LPVOID lpEnvironment, LPCWSTR lpCurrentDirectory, LPSTARTUPINFOW lpStartupInfo, LPPROCESS_INFORMATION lpProcessInformation)
     * }
     */
    public static FunctionDescriptor CreateProcessWithTokenW$descriptor() {
        return CreateProcessWithTokenW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CreateProcessWithTokenW(HANDLE hToken, DWORD dwLogonFlags, LPCWSTR lpApplicationName, LPWSTR lpCommandLine, DWORD dwCreationFlags, LPVOID lpEnvironment, LPCWSTR lpCurrentDirectory, LPSTARTUPINFOW lpStartupInfo, LPPROCESS_INFORMATION lpProcessInformation)
     * }
     */
    public static MethodHandle CreateProcessWithTokenW$handle() {
        return CreateProcessWithTokenW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL CreateProcessWithTokenW(HANDLE hToken, DWORD dwLogonFlags, LPCWSTR lpApplicationName, LPWSTR lpCommandLine, DWORD dwCreationFlags, LPVOID lpEnvironment, LPCWSTR lpCurrentDirectory, LPSTARTUPINFOW lpStartupInfo, LPPROCESS_INFORMATION lpProcessInformation)
     * }
     */
    public static int CreateProcessWithTokenW(MemorySegment hToken, int dwLogonFlags, MemorySegment lpApplicationName, MemorySegment lpCommandLine, int dwCreationFlags, MemorySegment lpEnvironment, MemorySegment lpCurrentDirectory, MemorySegment lpStartupInfo, MemorySegment lpProcessInformation) {
        var mh$ = CreateProcessWithTokenW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateProcessWithTokenW", hToken, dwLogonFlags, lpApplicationName, lpCommandLine, dwCreationFlags, lpEnvironment, lpCurrentDirectory, lpStartupInfo, lpProcessInformation);
            }
            return (int)mh$.invokeExact(hToken, dwLogonFlags, lpApplicationName, lpCommandLine, dwCreationFlags, lpEnvironment, lpCurrentDirectory, lpStartupInfo, lpProcessInformation);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class IsTokenUntrusted {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("IsTokenUntrusted"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL IsTokenUntrusted(HANDLE TokenHandle)
     * }
     */
    public static FunctionDescriptor IsTokenUntrusted$descriptor() {
        return IsTokenUntrusted.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL IsTokenUntrusted(HANDLE TokenHandle)
     * }
     */
    public static MethodHandle IsTokenUntrusted$handle() {
        return IsTokenUntrusted.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL IsTokenUntrusted(HANDLE TokenHandle)
     * }
     */
    public static int IsTokenUntrusted(MemorySegment TokenHandle) {
        var mh$ = IsTokenUntrusted.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("IsTokenUntrusted", TokenHandle);
            }
            return (int)mh$.invokeExact(TokenHandle);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RegisterWaitForSingleObject {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_LONG,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("RegisterWaitForSingleObject"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL RegisterWaitForSingleObject(PHANDLE phNewWaitObject, HANDLE hObject, WAITORTIMERCALLBACK Callback, PVOID Context, ULONG dwMilliseconds, ULONG dwFlags)
     * }
     */
    public static FunctionDescriptor RegisterWaitForSingleObject$descriptor() {
        return RegisterWaitForSingleObject.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL RegisterWaitForSingleObject(PHANDLE phNewWaitObject, HANDLE hObject, WAITORTIMERCALLBACK Callback, PVOID Context, ULONG dwMilliseconds, ULONG dwFlags)
     * }
     */
    public static MethodHandle RegisterWaitForSingleObject$handle() {
        return RegisterWaitForSingleObject.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL RegisterWaitForSingleObject(PHANDLE phNewWaitObject, HANDLE hObject, WAITORTIMERCALLBACK Callback, PVOID Context, ULONG dwMilliseconds, ULONG dwFlags)
     * }
     */
    public static int RegisterWaitForSingleObject(MemorySegment phNewWaitObject, MemorySegment hObject, MemorySegment Callback, MemorySegment Context, int dwMilliseconds, int dwFlags) {
        var mh$ = RegisterWaitForSingleObject.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RegisterWaitForSingleObject", phNewWaitObject, hObject, Callback, Context, dwMilliseconds, dwFlags);
            }
            return (int)mh$.invokeExact(phNewWaitObject, hObject, Callback, Context, dwMilliseconds, dwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class UnregisterWait {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("UnregisterWait"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL UnregisterWait(HANDLE WaitHandle)
     * }
     */
    public static FunctionDescriptor UnregisterWait$descriptor() {
        return UnregisterWait.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL UnregisterWait(HANDLE WaitHandle)
     * }
     */
    public static MethodHandle UnregisterWait$handle() {
        return UnregisterWait.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL UnregisterWait(HANDLE WaitHandle)
     * }
     */
    public static int UnregisterWait(MemorySegment WaitHandle) {
        var mh$ = UnregisterWait.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("UnregisterWait", WaitHandle);
            }
            return (int)mh$.invokeExact(WaitHandle);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class BindIoCompletionCallback {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("BindIoCompletionCallback"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL BindIoCompletionCallback(HANDLE FileHandle, LPOVERLAPPED_COMPLETION_ROUTINE Function, ULONG Flags)
     * }
     */
    public static FunctionDescriptor BindIoCompletionCallback$descriptor() {
        return BindIoCompletionCallback.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL BindIoCompletionCallback(HANDLE FileHandle, LPOVERLAPPED_COMPLETION_ROUTINE Function, ULONG Flags)
     * }
     */
    public static MethodHandle BindIoCompletionCallback$handle() {
        return BindIoCompletionCallback.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL BindIoCompletionCallback(HANDLE FileHandle, LPOVERLAPPED_COMPLETION_ROUTINE Function, ULONG Flags)
     * }
     */
    public static int BindIoCompletionCallback(MemorySegment FileHandle, MemorySegment Function, int Flags) {
        var mh$ = BindIoCompletionCallback.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("BindIoCompletionCallback", FileHandle, Function, Flags);
            }
            return (int)mh$.invokeExact(FileHandle, Function, Flags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetTimerQueueTimer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_LONG,
            C_LONG,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("SetTimerQueueTimer"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HANDLE SetTimerQueueTimer(HANDLE TimerQueue, WAITORTIMERCALLBACK Callback, PVOID Parameter, DWORD DueTime, DWORD Period, BOOL PreferIo)
     * }
     */
    public static FunctionDescriptor SetTimerQueueTimer$descriptor() {
        return SetTimerQueueTimer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HANDLE SetTimerQueueTimer(HANDLE TimerQueue, WAITORTIMERCALLBACK Callback, PVOID Parameter, DWORD DueTime, DWORD Period, BOOL PreferIo)
     * }
     */
    public static MethodHandle SetTimerQueueTimer$handle() {
        return SetTimerQueueTimer.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * HANDLE SetTimerQueueTimer(HANDLE TimerQueue, WAITORTIMERCALLBACK Callback, PVOID Parameter, DWORD DueTime, DWORD Period, BOOL PreferIo)
     * }
     */
    public static MemorySegment SetTimerQueueTimer(MemorySegment TimerQueue, MemorySegment Callback, MemorySegment Parameter, int DueTime, int Period, int PreferIo) {
        var mh$ = SetTimerQueueTimer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetTimerQueueTimer", TimerQueue, Callback, Parameter, DueTime, Period, PreferIo);
            }
            return (MemorySegment)mh$.invokeExact(TimerQueue, Callback, Parameter, DueTime, Period, PreferIo);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CancelTimerQueueTimer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CancelTimerQueueTimer"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CancelTimerQueueTimer(HANDLE TimerQueue, HANDLE Timer)
     * }
     */
    public static FunctionDescriptor CancelTimerQueueTimer$descriptor() {
        return CancelTimerQueueTimer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CancelTimerQueueTimer(HANDLE TimerQueue, HANDLE Timer)
     * }
     */
    public static MethodHandle CancelTimerQueueTimer$handle() {
        return CancelTimerQueueTimer.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL CancelTimerQueueTimer(HANDLE TimerQueue, HANDLE Timer)
     * }
     */
    public static int CancelTimerQueueTimer(MemorySegment TimerQueue, MemorySegment Timer) {
        var mh$ = CancelTimerQueueTimer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CancelTimerQueueTimer", TimerQueue, Timer);
            }
            return (int)mh$.invokeExact(TimerQueue, Timer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreatePrivateNamespaceA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CreatePrivateNamespaceA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HANDLE CreatePrivateNamespaceA(LPSECURITY_ATTRIBUTES lpPrivateNamespaceAttributes, LPVOID lpBoundaryDescriptor, LPCSTR lpAliasPrefix)
     * }
     */
    public static FunctionDescriptor CreatePrivateNamespaceA$descriptor() {
        return CreatePrivateNamespaceA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HANDLE CreatePrivateNamespaceA(LPSECURITY_ATTRIBUTES lpPrivateNamespaceAttributes, LPVOID lpBoundaryDescriptor, LPCSTR lpAliasPrefix)
     * }
     */
    public static MethodHandle CreatePrivateNamespaceA$handle() {
        return CreatePrivateNamespaceA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * HANDLE CreatePrivateNamespaceA(LPSECURITY_ATTRIBUTES lpPrivateNamespaceAttributes, LPVOID lpBoundaryDescriptor, LPCSTR lpAliasPrefix)
     * }
     */
    public static MemorySegment CreatePrivateNamespaceA(MemorySegment lpPrivateNamespaceAttributes, MemorySegment lpBoundaryDescriptor, MemorySegment lpAliasPrefix) {
        var mh$ = CreatePrivateNamespaceA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreatePrivateNamespaceA", lpPrivateNamespaceAttributes, lpBoundaryDescriptor, lpAliasPrefix);
            }
            return (MemorySegment)mh$.invokeExact(lpPrivateNamespaceAttributes, lpBoundaryDescriptor, lpAliasPrefix);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class OpenPrivateNamespaceA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("OpenPrivateNamespaceA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HANDLE OpenPrivateNamespaceA(LPVOID lpBoundaryDescriptor, LPCSTR lpAliasPrefix)
     * }
     */
    public static FunctionDescriptor OpenPrivateNamespaceA$descriptor() {
        return OpenPrivateNamespaceA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HANDLE OpenPrivateNamespaceA(LPVOID lpBoundaryDescriptor, LPCSTR lpAliasPrefix)
     * }
     */
    public static MethodHandle OpenPrivateNamespaceA$handle() {
        return OpenPrivateNamespaceA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * HANDLE OpenPrivateNamespaceA(LPVOID lpBoundaryDescriptor, LPCSTR lpAliasPrefix)
     * }
     */
    public static MemorySegment OpenPrivateNamespaceA(MemorySegment lpBoundaryDescriptor, MemorySegment lpAliasPrefix) {
        var mh$ = OpenPrivateNamespaceA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("OpenPrivateNamespaceA", lpBoundaryDescriptor, lpAliasPrefix);
            }
            return (MemorySegment)mh$.invokeExact(lpBoundaryDescriptor, lpAliasPrefix);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateBoundaryDescriptorA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CreateBoundaryDescriptorA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HANDLE CreateBoundaryDescriptorA(LPCSTR Name, ULONG Flags)
     * }
     */
    public static FunctionDescriptor CreateBoundaryDescriptorA$descriptor() {
        return CreateBoundaryDescriptorA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HANDLE CreateBoundaryDescriptorA(LPCSTR Name, ULONG Flags)
     * }
     */
    public static MethodHandle CreateBoundaryDescriptorA$handle() {
        return CreateBoundaryDescriptorA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * HANDLE CreateBoundaryDescriptorA(LPCSTR Name, ULONG Flags)
     * }
     */
    public static MemorySegment CreateBoundaryDescriptorA(MemorySegment Name, int Flags) {
        var mh$ = CreateBoundaryDescriptorA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateBoundaryDescriptorA", Name, Flags);
            }
            return (MemorySegment)mh$.invokeExact(Name, Flags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class AddIntegrityLabelToBoundaryDescriptor {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("AddIntegrityLabelToBoundaryDescriptor"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL AddIntegrityLabelToBoundaryDescriptor(HANDLE *BoundaryDescriptor, PSID IntegrityLabel)
     * }
     */
    public static FunctionDescriptor AddIntegrityLabelToBoundaryDescriptor$descriptor() {
        return AddIntegrityLabelToBoundaryDescriptor.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL AddIntegrityLabelToBoundaryDescriptor(HANDLE *BoundaryDescriptor, PSID IntegrityLabel)
     * }
     */
    public static MethodHandle AddIntegrityLabelToBoundaryDescriptor$handle() {
        return AddIntegrityLabelToBoundaryDescriptor.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL AddIntegrityLabelToBoundaryDescriptor(HANDLE *BoundaryDescriptor, PSID IntegrityLabel)
     * }
     */
    public static int AddIntegrityLabelToBoundaryDescriptor(MemorySegment BoundaryDescriptor, MemorySegment IntegrityLabel) {
        var mh$ = AddIntegrityLabelToBoundaryDescriptor.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("AddIntegrityLabelToBoundaryDescriptor", BoundaryDescriptor, IntegrityLabel);
            }
            return (int)mh$.invokeExact(BoundaryDescriptor, IntegrityLabel);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct tagHW_PROFILE_INFOA {
     *     DWORD dwDockInfo;
     *     CHAR szHwProfileGuid[39];
     *     CHAR szHwProfileName[80];
     * } *LPHW_PROFILE_INFOA
     * }
     */
    public static final AddressLayout LPHW_PROFILE_INFOA = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagHW_PROFILE_INFOW {
     *     DWORD dwDockInfo;
     *     WCHAR szHwProfileGuid[39];
     *     WCHAR szHwProfileName[80];
     * } *LPHW_PROFILE_INFOW
     * }
     */
    public static final AddressLayout LPHW_PROFILE_INFOW = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef LPHW_PROFILE_INFOA LPHW_PROFILE_INFO
     * }
     */
    public static final AddressLayout LPHW_PROFILE_INFO = C_POINTER;

    private static class GetCurrentHwProfileA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetCurrentHwProfileA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetCurrentHwProfileA(LPHW_PROFILE_INFOA lpHwProfileInfo)
     * }
     */
    public static FunctionDescriptor GetCurrentHwProfileA$descriptor() {
        return GetCurrentHwProfileA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetCurrentHwProfileA(LPHW_PROFILE_INFOA lpHwProfileInfo)
     * }
     */
    public static MethodHandle GetCurrentHwProfileA$handle() {
        return GetCurrentHwProfileA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL GetCurrentHwProfileA(LPHW_PROFILE_INFOA lpHwProfileInfo)
     * }
     */
    public static int GetCurrentHwProfileA(MemorySegment lpHwProfileInfo) {
        var mh$ = GetCurrentHwProfileA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetCurrentHwProfileA", lpHwProfileInfo);
            }
            return (int)mh$.invokeExact(lpHwProfileInfo);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetCurrentHwProfileW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetCurrentHwProfileW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetCurrentHwProfileW(LPHW_PROFILE_INFOW lpHwProfileInfo)
     * }
     */
    public static FunctionDescriptor GetCurrentHwProfileW$descriptor() {
        return GetCurrentHwProfileW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetCurrentHwProfileW(LPHW_PROFILE_INFOW lpHwProfileInfo)
     * }
     */
    public static MethodHandle GetCurrentHwProfileW$handle() {
        return GetCurrentHwProfileW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL GetCurrentHwProfileW(LPHW_PROFILE_INFOW lpHwProfileInfo)
     * }
     */
    public static int GetCurrentHwProfileW(MemorySegment lpHwProfileInfo) {
        var mh$ = GetCurrentHwProfileW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetCurrentHwProfileW", lpHwProfileInfo);
            }
            return (int)mh$.invokeExact(lpHwProfileInfo);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class VerifyVersionInfoA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_LONG,
            C_LONG_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("VerifyVersionInfoA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL VerifyVersionInfoA(LPOSVERSIONINFOEXA lpVersionInformation, DWORD dwTypeMask, DWORDLONG dwlConditionMask)
     * }
     */
    public static FunctionDescriptor VerifyVersionInfoA$descriptor() {
        return VerifyVersionInfoA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL VerifyVersionInfoA(LPOSVERSIONINFOEXA lpVersionInformation, DWORD dwTypeMask, DWORDLONG dwlConditionMask)
     * }
     */
    public static MethodHandle VerifyVersionInfoA$handle() {
        return VerifyVersionInfoA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL VerifyVersionInfoA(LPOSVERSIONINFOEXA lpVersionInformation, DWORD dwTypeMask, DWORDLONG dwlConditionMask)
     * }
     */
    public static int VerifyVersionInfoA(MemorySegment lpVersionInformation, int dwTypeMask, long dwlConditionMask) {
        var mh$ = VerifyVersionInfoA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("VerifyVersionInfoA", lpVersionInformation, dwTypeMask, dwlConditionMask);
            }
            return (int)mh$.invokeExact(lpVersionInformation, dwTypeMask, dwlConditionMask);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class VerifyVersionInfoW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_LONG,
            C_LONG_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("VerifyVersionInfoW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL VerifyVersionInfoW(LPOSVERSIONINFOEXW lpVersionInformation, DWORD dwTypeMask, DWORDLONG dwlConditionMask)
     * }
     */
    public static FunctionDescriptor VerifyVersionInfoW$descriptor() {
        return VerifyVersionInfoW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL VerifyVersionInfoW(LPOSVERSIONINFOEXW lpVersionInformation, DWORD dwTypeMask, DWORDLONG dwlConditionMask)
     * }
     */
    public static MethodHandle VerifyVersionInfoW$handle() {
        return VerifyVersionInfoW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL VerifyVersionInfoW(LPOSVERSIONINFOEXW lpVersionInformation, DWORD dwTypeMask, DWORDLONG dwlConditionMask)
     * }
     */
    public static int VerifyVersionInfoW(MemorySegment lpVersionInformation, int dwTypeMask, long dwlConditionMask) {
        var mh$ = VerifyVersionInfoW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("VerifyVersionInfoW", lpVersionInformation, dwTypeMask, dwlConditionMask);
            }
            return (int)mh$.invokeExact(lpVersionInformation, dwTypeMask, dwlConditionMask);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct _TIME_ZONE_INFORMATION {
     *     LONG Bias;
     *     WCHAR StandardName[32];
     *     SYSTEMTIME StandardDate;
     *     LONG StandardBias;
     *     WCHAR DaylightName[32];
     *     SYSTEMTIME DaylightDate;
     *     LONG DaylightBias;
     * } *PTIME_ZONE_INFORMATION
     * }
     */
    public static final AddressLayout PTIME_ZONE_INFORMATION = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _TIME_ZONE_INFORMATION {
     *     LONG Bias;
     *     WCHAR StandardName[32];
     *     SYSTEMTIME StandardDate;
     *     LONG StandardBias;
     *     WCHAR DaylightName[32];
     *     SYSTEMTIME DaylightDate;
     *     LONG DaylightBias;
     * } *LPTIME_ZONE_INFORMATION
     * }
     */
    public static final AddressLayout LPTIME_ZONE_INFORMATION = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _TIME_DYNAMIC_ZONE_INFORMATION {
     *     LONG Bias;
     *     WCHAR StandardName[32];
     *     SYSTEMTIME StandardDate;
     *     LONG StandardBias;
     *     WCHAR DaylightName[32];
     *     SYSTEMTIME DaylightDate;
     *     LONG DaylightBias;
     *     WCHAR TimeZoneKeyName[128];
     *     BOOLEAN DynamicDaylightTimeDisabled;
     * } *PDYNAMIC_TIME_ZONE_INFORMATION
     * }
     */
    public static final AddressLayout PDYNAMIC_TIME_ZONE_INFORMATION = C_POINTER;

    private static class SystemTimeToTzSpecificLocalTime {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("SystemTimeToTzSpecificLocalTime"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SystemTimeToTzSpecificLocalTime(const TIME_ZONE_INFORMATION *lpTimeZoneInformation, const SYSTEMTIME *lpUniversalTime, LPSYSTEMTIME lpLocalTime)
     * }
     */
    public static FunctionDescriptor SystemTimeToTzSpecificLocalTime$descriptor() {
        return SystemTimeToTzSpecificLocalTime.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SystemTimeToTzSpecificLocalTime(const TIME_ZONE_INFORMATION *lpTimeZoneInformation, const SYSTEMTIME *lpUniversalTime, LPSYSTEMTIME lpLocalTime)
     * }
     */
    public static MethodHandle SystemTimeToTzSpecificLocalTime$handle() {
        return SystemTimeToTzSpecificLocalTime.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL SystemTimeToTzSpecificLocalTime(const TIME_ZONE_INFORMATION *lpTimeZoneInformation, const SYSTEMTIME *lpUniversalTime, LPSYSTEMTIME lpLocalTime)
     * }
     */
    public static int SystemTimeToTzSpecificLocalTime(MemorySegment lpTimeZoneInformation, MemorySegment lpUniversalTime, MemorySegment lpLocalTime) {
        var mh$ = SystemTimeToTzSpecificLocalTime.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SystemTimeToTzSpecificLocalTime", lpTimeZoneInformation, lpUniversalTime, lpLocalTime);
            }
            return (int)mh$.invokeExact(lpTimeZoneInformation, lpUniversalTime, lpLocalTime);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TzSpecificLocalTimeToSystemTime {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("TzSpecificLocalTimeToSystemTime"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL TzSpecificLocalTimeToSystemTime(const TIME_ZONE_INFORMATION *lpTimeZoneInformation, const SYSTEMTIME *lpLocalTime, LPSYSTEMTIME lpUniversalTime)
     * }
     */
    public static FunctionDescriptor TzSpecificLocalTimeToSystemTime$descriptor() {
        return TzSpecificLocalTimeToSystemTime.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL TzSpecificLocalTimeToSystemTime(const TIME_ZONE_INFORMATION *lpTimeZoneInformation, const SYSTEMTIME *lpLocalTime, LPSYSTEMTIME lpUniversalTime)
     * }
     */
    public static MethodHandle TzSpecificLocalTimeToSystemTime$handle() {
        return TzSpecificLocalTimeToSystemTime.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL TzSpecificLocalTimeToSystemTime(const TIME_ZONE_INFORMATION *lpTimeZoneInformation, const SYSTEMTIME *lpLocalTime, LPSYSTEMTIME lpUniversalTime)
     * }
     */
    public static int TzSpecificLocalTimeToSystemTime(MemorySegment lpTimeZoneInformation, MemorySegment lpLocalTime, MemorySegment lpUniversalTime) {
        var mh$ = TzSpecificLocalTimeToSystemTime.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TzSpecificLocalTimeToSystemTime", lpTimeZoneInformation, lpLocalTime, lpUniversalTime);
            }
            return (int)mh$.invokeExact(lpTimeZoneInformation, lpLocalTime, lpUniversalTime);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FileTimeToSystemTime {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("FileTimeToSystemTime"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL FileTimeToSystemTime(const FILETIME *lpFileTime, LPSYSTEMTIME lpSystemTime)
     * }
     */
    public static FunctionDescriptor FileTimeToSystemTime$descriptor() {
        return FileTimeToSystemTime.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL FileTimeToSystemTime(const FILETIME *lpFileTime, LPSYSTEMTIME lpSystemTime)
     * }
     */
    public static MethodHandle FileTimeToSystemTime$handle() {
        return FileTimeToSystemTime.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL FileTimeToSystemTime(const FILETIME *lpFileTime, LPSYSTEMTIME lpSystemTime)
     * }
     */
    public static int FileTimeToSystemTime(MemorySegment lpFileTime, MemorySegment lpSystemTime) {
        var mh$ = FileTimeToSystemTime.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FileTimeToSystemTime", lpFileTime, lpSystemTime);
            }
            return (int)mh$.invokeExact(lpFileTime, lpSystemTime);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SystemTimeToFileTime {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("SystemTimeToFileTime"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SystemTimeToFileTime(const SYSTEMTIME *lpSystemTime, LPFILETIME lpFileTime)
     * }
     */
    public static FunctionDescriptor SystemTimeToFileTime$descriptor() {
        return SystemTimeToFileTime.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SystemTimeToFileTime(const SYSTEMTIME *lpSystemTime, LPFILETIME lpFileTime)
     * }
     */
    public static MethodHandle SystemTimeToFileTime$handle() {
        return SystemTimeToFileTime.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL SystemTimeToFileTime(const SYSTEMTIME *lpSystemTime, LPFILETIME lpFileTime)
     * }
     */
    public static int SystemTimeToFileTime(MemorySegment lpSystemTime, MemorySegment lpFileTime) {
        var mh$ = SystemTimeToFileTime.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SystemTimeToFileTime", lpSystemTime, lpFileTime);
            }
            return (int)mh$.invokeExact(lpSystemTime, lpFileTime);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetTimeZoneInformation {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetTimeZoneInformation"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetTimeZoneInformation(LPTIME_ZONE_INFORMATION lpTimeZoneInformation)
     * }
     */
    public static FunctionDescriptor GetTimeZoneInformation$descriptor() {
        return GetTimeZoneInformation.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetTimeZoneInformation(LPTIME_ZONE_INFORMATION lpTimeZoneInformation)
     * }
     */
    public static MethodHandle GetTimeZoneInformation$handle() {
        return GetTimeZoneInformation.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * DWORD GetTimeZoneInformation(LPTIME_ZONE_INFORMATION lpTimeZoneInformation)
     * }
     */
    public static int GetTimeZoneInformation(MemorySegment lpTimeZoneInformation) {
        var mh$ = GetTimeZoneInformation.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetTimeZoneInformation", lpTimeZoneInformation);
            }
            return (int)mh$.invokeExact(lpTimeZoneInformation);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetTimeZoneInformation {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("SetTimeZoneInformation"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetTimeZoneInformation(const TIME_ZONE_INFORMATION *lpTimeZoneInformation)
     * }
     */
    public static FunctionDescriptor SetTimeZoneInformation$descriptor() {
        return SetTimeZoneInformation.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetTimeZoneInformation(const TIME_ZONE_INFORMATION *lpTimeZoneInformation)
     * }
     */
    public static MethodHandle SetTimeZoneInformation$handle() {
        return SetTimeZoneInformation.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL SetTimeZoneInformation(const TIME_ZONE_INFORMATION *lpTimeZoneInformation)
     * }
     */
    public static int SetTimeZoneInformation(MemorySegment lpTimeZoneInformation) {
        var mh$ = SetTimeZoneInformation.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetTimeZoneInformation", lpTimeZoneInformation);
            }
            return (int)mh$.invokeExact(lpTimeZoneInformation);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetDynamicTimeZoneInformation {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("SetDynamicTimeZoneInformation"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetDynamicTimeZoneInformation(const DYNAMIC_TIME_ZONE_INFORMATION *lpTimeZoneInformation)
     * }
     */
    public static FunctionDescriptor SetDynamicTimeZoneInformation$descriptor() {
        return SetDynamicTimeZoneInformation.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetDynamicTimeZoneInformation(const DYNAMIC_TIME_ZONE_INFORMATION *lpTimeZoneInformation)
     * }
     */
    public static MethodHandle SetDynamicTimeZoneInformation$handle() {
        return SetDynamicTimeZoneInformation.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL SetDynamicTimeZoneInformation(const DYNAMIC_TIME_ZONE_INFORMATION *lpTimeZoneInformation)
     * }
     */
    public static int SetDynamicTimeZoneInformation(MemorySegment lpTimeZoneInformation) {
        var mh$ = SetDynamicTimeZoneInformation.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetDynamicTimeZoneInformation", lpTimeZoneInformation);
            }
            return (int)mh$.invokeExact(lpTimeZoneInformation);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetDynamicTimeZoneInformation {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetDynamicTimeZoneInformation"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetDynamicTimeZoneInformation(PDYNAMIC_TIME_ZONE_INFORMATION pTimeZoneInformation)
     * }
     */
    public static FunctionDescriptor GetDynamicTimeZoneInformation$descriptor() {
        return GetDynamicTimeZoneInformation.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetDynamicTimeZoneInformation(PDYNAMIC_TIME_ZONE_INFORMATION pTimeZoneInformation)
     * }
     */
    public static MethodHandle GetDynamicTimeZoneInformation$handle() {
        return GetDynamicTimeZoneInformation.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * DWORD GetDynamicTimeZoneInformation(PDYNAMIC_TIME_ZONE_INFORMATION pTimeZoneInformation)
     * }
     */
    public static int GetDynamicTimeZoneInformation(MemorySegment pTimeZoneInformation) {
        var mh$ = GetDynamicTimeZoneInformation.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetDynamicTimeZoneInformation", pTimeZoneInformation);
            }
            return (int)mh$.invokeExact(pTimeZoneInformation);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetTimeZoneInformationForYear {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_SHORT,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetTimeZoneInformationForYear"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetTimeZoneInformationForYear(USHORT wYear, PDYNAMIC_TIME_ZONE_INFORMATION pdtzi, LPTIME_ZONE_INFORMATION ptzi)
     * }
     */
    public static FunctionDescriptor GetTimeZoneInformationForYear$descriptor() {
        return GetTimeZoneInformationForYear.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetTimeZoneInformationForYear(USHORT wYear, PDYNAMIC_TIME_ZONE_INFORMATION pdtzi, LPTIME_ZONE_INFORMATION ptzi)
     * }
     */
    public static MethodHandle GetTimeZoneInformationForYear$handle() {
        return GetTimeZoneInformationForYear.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL GetTimeZoneInformationForYear(USHORT wYear, PDYNAMIC_TIME_ZONE_INFORMATION pdtzi, LPTIME_ZONE_INFORMATION ptzi)
     * }
     */
    public static int GetTimeZoneInformationForYear(short wYear, MemorySegment pdtzi, MemorySegment ptzi) {
        var mh$ = GetTimeZoneInformationForYear.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetTimeZoneInformationForYear", wYear, pdtzi, ptzi);
            }
            return (int)mh$.invokeExact(wYear, pdtzi, ptzi);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class EnumDynamicTimeZoneInformation {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_LONG,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("EnumDynamicTimeZoneInformation"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD EnumDynamicTimeZoneInformation(const DWORD dwIndex, PDYNAMIC_TIME_ZONE_INFORMATION lpTimeZoneInformation)
     * }
     */
    public static FunctionDescriptor EnumDynamicTimeZoneInformation$descriptor() {
        return EnumDynamicTimeZoneInformation.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD EnumDynamicTimeZoneInformation(const DWORD dwIndex, PDYNAMIC_TIME_ZONE_INFORMATION lpTimeZoneInformation)
     * }
     */
    public static MethodHandle EnumDynamicTimeZoneInformation$handle() {
        return EnumDynamicTimeZoneInformation.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * DWORD EnumDynamicTimeZoneInformation(const DWORD dwIndex, PDYNAMIC_TIME_ZONE_INFORMATION lpTimeZoneInformation)
     * }
     */
    public static int EnumDynamicTimeZoneInformation(int dwIndex, MemorySegment lpTimeZoneInformation) {
        var mh$ = EnumDynamicTimeZoneInformation.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("EnumDynamicTimeZoneInformation", dwIndex, lpTimeZoneInformation);
            }
            return (int)mh$.invokeExact(dwIndex, lpTimeZoneInformation);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetDynamicTimeZoneInformationEffectiveYears {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetDynamicTimeZoneInformationEffectiveYears"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetDynamicTimeZoneInformationEffectiveYears(const PDYNAMIC_TIME_ZONE_INFORMATION lpTimeZoneInformation, LPDWORD FirstYear, LPDWORD LastYear)
     * }
     */
    public static FunctionDescriptor GetDynamicTimeZoneInformationEffectiveYears$descriptor() {
        return GetDynamicTimeZoneInformationEffectiveYears.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetDynamicTimeZoneInformationEffectiveYears(const PDYNAMIC_TIME_ZONE_INFORMATION lpTimeZoneInformation, LPDWORD FirstYear, LPDWORD LastYear)
     * }
     */
    public static MethodHandle GetDynamicTimeZoneInformationEffectiveYears$handle() {
        return GetDynamicTimeZoneInformationEffectiveYears.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * DWORD GetDynamicTimeZoneInformationEffectiveYears(const PDYNAMIC_TIME_ZONE_INFORMATION lpTimeZoneInformation, LPDWORD FirstYear, LPDWORD LastYear)
     * }
     */
    public static int GetDynamicTimeZoneInformationEffectiveYears(MemorySegment lpTimeZoneInformation, MemorySegment FirstYear, MemorySegment LastYear) {
        var mh$ = GetDynamicTimeZoneInformationEffectiveYears.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetDynamicTimeZoneInformationEffectiveYears", lpTimeZoneInformation, FirstYear, LastYear);
            }
            return (int)mh$.invokeExact(lpTimeZoneInformation, FirstYear, LastYear);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SystemTimeToTzSpecificLocalTimeEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("SystemTimeToTzSpecificLocalTimeEx"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SystemTimeToTzSpecificLocalTimeEx(const DYNAMIC_TIME_ZONE_INFORMATION *lpTimeZoneInformation, const SYSTEMTIME *lpUniversalTime, LPSYSTEMTIME lpLocalTime)
     * }
     */
    public static FunctionDescriptor SystemTimeToTzSpecificLocalTimeEx$descriptor() {
        return SystemTimeToTzSpecificLocalTimeEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SystemTimeToTzSpecificLocalTimeEx(const DYNAMIC_TIME_ZONE_INFORMATION *lpTimeZoneInformation, const SYSTEMTIME *lpUniversalTime, LPSYSTEMTIME lpLocalTime)
     * }
     */
    public static MethodHandle SystemTimeToTzSpecificLocalTimeEx$handle() {
        return SystemTimeToTzSpecificLocalTimeEx.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL SystemTimeToTzSpecificLocalTimeEx(const DYNAMIC_TIME_ZONE_INFORMATION *lpTimeZoneInformation, const SYSTEMTIME *lpUniversalTime, LPSYSTEMTIME lpLocalTime)
     * }
     */
    public static int SystemTimeToTzSpecificLocalTimeEx(MemorySegment lpTimeZoneInformation, MemorySegment lpUniversalTime, MemorySegment lpLocalTime) {
        var mh$ = SystemTimeToTzSpecificLocalTimeEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SystemTimeToTzSpecificLocalTimeEx", lpTimeZoneInformation, lpUniversalTime, lpLocalTime);
            }
            return (int)mh$.invokeExact(lpTimeZoneInformation, lpUniversalTime, lpLocalTime);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TzSpecificLocalTimeToSystemTimeEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("TzSpecificLocalTimeToSystemTimeEx"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL TzSpecificLocalTimeToSystemTimeEx(const DYNAMIC_TIME_ZONE_INFORMATION *lpTimeZoneInformation, const SYSTEMTIME *lpLocalTime, LPSYSTEMTIME lpUniversalTime)
     * }
     */
    public static FunctionDescriptor TzSpecificLocalTimeToSystemTimeEx$descriptor() {
        return TzSpecificLocalTimeToSystemTimeEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL TzSpecificLocalTimeToSystemTimeEx(const DYNAMIC_TIME_ZONE_INFORMATION *lpTimeZoneInformation, const SYSTEMTIME *lpLocalTime, LPSYSTEMTIME lpUniversalTime)
     * }
     */
    public static MethodHandle TzSpecificLocalTimeToSystemTimeEx$handle() {
        return TzSpecificLocalTimeToSystemTimeEx.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL TzSpecificLocalTimeToSystemTimeEx(const DYNAMIC_TIME_ZONE_INFORMATION *lpTimeZoneInformation, const SYSTEMTIME *lpLocalTime, LPSYSTEMTIME lpUniversalTime)
     * }
     */
    public static int TzSpecificLocalTimeToSystemTimeEx(MemorySegment lpTimeZoneInformation, MemorySegment lpLocalTime, MemorySegment lpUniversalTime) {
        var mh$ = TzSpecificLocalTimeToSystemTimeEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TzSpecificLocalTimeToSystemTimeEx", lpTimeZoneInformation, lpLocalTime, lpUniversalTime);
            }
            return (int)mh$.invokeExact(lpTimeZoneInformation, lpLocalTime, lpUniversalTime);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LocalFileTimeToLocalSystemTime {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("LocalFileTimeToLocalSystemTime"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL LocalFileTimeToLocalSystemTime(const TIME_ZONE_INFORMATION *timeZoneInformation, const FILETIME *localFileTime, SYSTEMTIME *localSystemTime)
     * }
     */
    public static FunctionDescriptor LocalFileTimeToLocalSystemTime$descriptor() {
        return LocalFileTimeToLocalSystemTime.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL LocalFileTimeToLocalSystemTime(const TIME_ZONE_INFORMATION *timeZoneInformation, const FILETIME *localFileTime, SYSTEMTIME *localSystemTime)
     * }
     */
    public static MethodHandle LocalFileTimeToLocalSystemTime$handle() {
        return LocalFileTimeToLocalSystemTime.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL LocalFileTimeToLocalSystemTime(const TIME_ZONE_INFORMATION *timeZoneInformation, const FILETIME *localFileTime, SYSTEMTIME *localSystemTime)
     * }
     */
    public static int LocalFileTimeToLocalSystemTime(MemorySegment timeZoneInformation, MemorySegment localFileTime, MemorySegment localSystemTime) {
        var mh$ = LocalFileTimeToLocalSystemTime.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LocalFileTimeToLocalSystemTime", timeZoneInformation, localFileTime, localSystemTime);
            }
            return (int)mh$.invokeExact(timeZoneInformation, localFileTime, localSystemTime);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LocalSystemTimeToLocalFileTime {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("LocalSystemTimeToLocalFileTime"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL LocalSystemTimeToLocalFileTime(const TIME_ZONE_INFORMATION *timeZoneInformation, const SYSTEMTIME *localSystemTime, FILETIME *localFileTime)
     * }
     */
    public static FunctionDescriptor LocalSystemTimeToLocalFileTime$descriptor() {
        return LocalSystemTimeToLocalFileTime.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL LocalSystemTimeToLocalFileTime(const TIME_ZONE_INFORMATION *timeZoneInformation, const SYSTEMTIME *localSystemTime, FILETIME *localFileTime)
     * }
     */
    public static MethodHandle LocalSystemTimeToLocalFileTime$handle() {
        return LocalSystemTimeToLocalFileTime.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL LocalSystemTimeToLocalFileTime(const TIME_ZONE_INFORMATION *timeZoneInformation, const SYSTEMTIME *localSystemTime, FILETIME *localFileTime)
     * }
     */
    public static int LocalSystemTimeToLocalFileTime(MemorySegment timeZoneInformation, MemorySegment localSystemTime, MemorySegment localFileTime) {
        var mh$ = LocalSystemTimeToLocalFileTime.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LocalSystemTimeToLocalFileTime", timeZoneInformation, localSystemTime, localFileTime);
            }
            return (int)mh$.invokeExact(timeZoneInformation, localSystemTime, localFileTime);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetSystemPowerState {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_INT,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("SetSystemPowerState"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetSystemPowerState(BOOL fSuspend, BOOL fForce)
     * }
     */
    public static FunctionDescriptor SetSystemPowerState$descriptor() {
        return SetSystemPowerState.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetSystemPowerState(BOOL fSuspend, BOOL fForce)
     * }
     */
    public static MethodHandle SetSystemPowerState$handle() {
        return SetSystemPowerState.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL SetSystemPowerState(BOOL fSuspend, BOOL fForce)
     * }
     */
    public static int SetSystemPowerState(int fSuspend, int fForce) {
        var mh$ = SetSystemPowerState.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetSystemPowerState", fSuspend, fForce);
            }
            return (int)mh$.invokeExact(fSuspend, fForce);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct _SYSTEM_POWER_STATUS {
     *     BYTE ACLineStatus;
     *     BYTE BatteryFlag;
     *     BYTE BatteryLifePercent;
     *     BYTE SystemStatusFlag;
     *     DWORD BatteryLifeTime;
     *     DWORD BatteryFullLifeTime;
     * } *LPSYSTEM_POWER_STATUS
     * }
     */
    public static final AddressLayout LPSYSTEM_POWER_STATUS = C_POINTER;

    private static class GetSystemPowerStatus {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetSystemPowerStatus"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetSystemPowerStatus(LPSYSTEM_POWER_STATUS lpSystemPowerStatus)
     * }
     */
    public static FunctionDescriptor GetSystemPowerStatus$descriptor() {
        return GetSystemPowerStatus.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetSystemPowerStatus(LPSYSTEM_POWER_STATUS lpSystemPowerStatus)
     * }
     */
    public static MethodHandle GetSystemPowerStatus$handle() {
        return GetSystemPowerStatus.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL GetSystemPowerStatus(LPSYSTEM_POWER_STATUS lpSystemPowerStatus)
     * }
     */
    public static int GetSystemPowerStatus(MemorySegment lpSystemPowerStatus) {
        var mh$ = GetSystemPowerStatus.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetSystemPowerStatus", lpSystemPowerStatus);
            }
            return (int)mh$.invokeExact(lpSystemPowerStatus);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MapUserPhysicalPagesScatter {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_LONG_LONG,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("MapUserPhysicalPagesScatter"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL MapUserPhysicalPagesScatter(PVOID *VirtualAddresses, ULONG_PTR NumberOfPages, PULONG_PTR PageArray)
     * }
     */
    public static FunctionDescriptor MapUserPhysicalPagesScatter$descriptor() {
        return MapUserPhysicalPagesScatter.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL MapUserPhysicalPagesScatter(PVOID *VirtualAddresses, ULONG_PTR NumberOfPages, PULONG_PTR PageArray)
     * }
     */
    public static MethodHandle MapUserPhysicalPagesScatter$handle() {
        return MapUserPhysicalPagesScatter.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL MapUserPhysicalPagesScatter(PVOID *VirtualAddresses, ULONG_PTR NumberOfPages, PULONG_PTR PageArray)
     * }
     */
    public static int MapUserPhysicalPagesScatter(MemorySegment VirtualAddresses, long NumberOfPages, MemorySegment PageArray) {
        var mh$ = MapUserPhysicalPagesScatter.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MapUserPhysicalPagesScatter", VirtualAddresses, NumberOfPages, PageArray);
            }
            return (int)mh$.invokeExact(VirtualAddresses, NumberOfPages, PageArray);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateJobObjectA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CreateJobObjectA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HANDLE CreateJobObjectA(LPSECURITY_ATTRIBUTES lpJobAttributes, LPCSTR lpName)
     * }
     */
    public static FunctionDescriptor CreateJobObjectA$descriptor() {
        return CreateJobObjectA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HANDLE CreateJobObjectA(LPSECURITY_ATTRIBUTES lpJobAttributes, LPCSTR lpName)
     * }
     */
    public static MethodHandle CreateJobObjectA$handle() {
        return CreateJobObjectA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * HANDLE CreateJobObjectA(LPSECURITY_ATTRIBUTES lpJobAttributes, LPCSTR lpName)
     * }
     */
    public static MemorySegment CreateJobObjectA(MemorySegment lpJobAttributes, MemorySegment lpName) {
        var mh$ = CreateJobObjectA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateJobObjectA", lpJobAttributes, lpName);
            }
            return (MemorySegment)mh$.invokeExact(lpJobAttributes, lpName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class OpenJobObjectA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_LONG,
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("OpenJobObjectA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HANDLE OpenJobObjectA(DWORD dwDesiredAccess, BOOL bInheritHandle, LPCSTR lpName)
     * }
     */
    public static FunctionDescriptor OpenJobObjectA$descriptor() {
        return OpenJobObjectA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HANDLE OpenJobObjectA(DWORD dwDesiredAccess, BOOL bInheritHandle, LPCSTR lpName)
     * }
     */
    public static MethodHandle OpenJobObjectA$handle() {
        return OpenJobObjectA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * HANDLE OpenJobObjectA(DWORD dwDesiredAccess, BOOL bInheritHandle, LPCSTR lpName)
     * }
     */
    public static MemorySegment OpenJobObjectA(int dwDesiredAccess, int bInheritHandle, MemorySegment lpName) {
        var mh$ = OpenJobObjectA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("OpenJobObjectA", dwDesiredAccess, bInheritHandle, lpName);
            }
            return (MemorySegment)mh$.invokeExact(dwDesiredAccess, bInheritHandle, lpName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateJobSet {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_LONG,
            C_POINTER,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CreateJobSet"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CreateJobSet(ULONG NumJob, PJOB_SET_ARRAY UserJobSet, ULONG Flags)
     * }
     */
    public static FunctionDescriptor CreateJobSet$descriptor() {
        return CreateJobSet.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CreateJobSet(ULONG NumJob, PJOB_SET_ARRAY UserJobSet, ULONG Flags)
     * }
     */
    public static MethodHandle CreateJobSet$handle() {
        return CreateJobSet.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL CreateJobSet(ULONG NumJob, PJOB_SET_ARRAY UserJobSet, ULONG Flags)
     * }
     */
    public static int CreateJobSet(int NumJob, MemorySegment UserJobSet, int Flags) {
        var mh$ = CreateJobSet.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateJobSet", NumJob, UserJobSet, Flags);
            }
            return (int)mh$.invokeExact(NumJob, UserJobSet, Flags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FindFirstVolumeA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("FindFirstVolumeA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HANDLE FindFirstVolumeA(LPSTR lpszVolumeName, DWORD cchBufferLength)
     * }
     */
    public static FunctionDescriptor FindFirstVolumeA$descriptor() {
        return FindFirstVolumeA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HANDLE FindFirstVolumeA(LPSTR lpszVolumeName, DWORD cchBufferLength)
     * }
     */
    public static MethodHandle FindFirstVolumeA$handle() {
        return FindFirstVolumeA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * HANDLE FindFirstVolumeA(LPSTR lpszVolumeName, DWORD cchBufferLength)
     * }
     */
    public static MemorySegment FindFirstVolumeA(MemorySegment lpszVolumeName, int cchBufferLength) {
        var mh$ = FindFirstVolumeA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FindFirstVolumeA", lpszVolumeName, cchBufferLength);
            }
            return (MemorySegment)mh$.invokeExact(lpszVolumeName, cchBufferLength);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FindNextVolumeA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("FindNextVolumeA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL FindNextVolumeA(HANDLE hFindVolume, LPSTR lpszVolumeName, DWORD cchBufferLength)
     * }
     */
    public static FunctionDescriptor FindNextVolumeA$descriptor() {
        return FindNextVolumeA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL FindNextVolumeA(HANDLE hFindVolume, LPSTR lpszVolumeName, DWORD cchBufferLength)
     * }
     */
    public static MethodHandle FindNextVolumeA$handle() {
        return FindNextVolumeA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL FindNextVolumeA(HANDLE hFindVolume, LPSTR lpszVolumeName, DWORD cchBufferLength)
     * }
     */
    public static int FindNextVolumeA(MemorySegment hFindVolume, MemorySegment lpszVolumeName, int cchBufferLength) {
        var mh$ = FindNextVolumeA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FindNextVolumeA", hFindVolume, lpszVolumeName, cchBufferLength);
            }
            return (int)mh$.invokeExact(hFindVolume, lpszVolumeName, cchBufferLength);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FindFirstVolumeMountPointA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("FindFirstVolumeMountPointA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HANDLE FindFirstVolumeMountPointA(LPCSTR lpszRootPathName, LPSTR lpszVolumeMountPoint, DWORD cchBufferLength)
     * }
     */
    public static FunctionDescriptor FindFirstVolumeMountPointA$descriptor() {
        return FindFirstVolumeMountPointA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HANDLE FindFirstVolumeMountPointA(LPCSTR lpszRootPathName, LPSTR lpszVolumeMountPoint, DWORD cchBufferLength)
     * }
     */
    public static MethodHandle FindFirstVolumeMountPointA$handle() {
        return FindFirstVolumeMountPointA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * HANDLE FindFirstVolumeMountPointA(LPCSTR lpszRootPathName, LPSTR lpszVolumeMountPoint, DWORD cchBufferLength)
     * }
     */
    public static MemorySegment FindFirstVolumeMountPointA(MemorySegment lpszRootPathName, MemorySegment lpszVolumeMountPoint, int cchBufferLength) {
        var mh$ = FindFirstVolumeMountPointA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FindFirstVolumeMountPointA", lpszRootPathName, lpszVolumeMountPoint, cchBufferLength);
            }
            return (MemorySegment)mh$.invokeExact(lpszRootPathName, lpszVolumeMountPoint, cchBufferLength);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FindFirstVolumeMountPointW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("FindFirstVolumeMountPointW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HANDLE FindFirstVolumeMountPointW(LPCWSTR lpszRootPathName, LPWSTR lpszVolumeMountPoint, DWORD cchBufferLength)
     * }
     */
    public static FunctionDescriptor FindFirstVolumeMountPointW$descriptor() {
        return FindFirstVolumeMountPointW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HANDLE FindFirstVolumeMountPointW(LPCWSTR lpszRootPathName, LPWSTR lpszVolumeMountPoint, DWORD cchBufferLength)
     * }
     */
    public static MethodHandle FindFirstVolumeMountPointW$handle() {
        return FindFirstVolumeMountPointW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * HANDLE FindFirstVolumeMountPointW(LPCWSTR lpszRootPathName, LPWSTR lpszVolumeMountPoint, DWORD cchBufferLength)
     * }
     */
    public static MemorySegment FindFirstVolumeMountPointW(MemorySegment lpszRootPathName, MemorySegment lpszVolumeMountPoint, int cchBufferLength) {
        var mh$ = FindFirstVolumeMountPointW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FindFirstVolumeMountPointW", lpszRootPathName, lpszVolumeMountPoint, cchBufferLength);
            }
            return (MemorySegment)mh$.invokeExact(lpszRootPathName, lpszVolumeMountPoint, cchBufferLength);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FindNextVolumeMountPointA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("FindNextVolumeMountPointA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL FindNextVolumeMountPointA(HANDLE hFindVolumeMountPoint, LPSTR lpszVolumeMountPoint, DWORD cchBufferLength)
     * }
     */
    public static FunctionDescriptor FindNextVolumeMountPointA$descriptor() {
        return FindNextVolumeMountPointA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL FindNextVolumeMountPointA(HANDLE hFindVolumeMountPoint, LPSTR lpszVolumeMountPoint, DWORD cchBufferLength)
     * }
     */
    public static MethodHandle FindNextVolumeMountPointA$handle() {
        return FindNextVolumeMountPointA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL FindNextVolumeMountPointA(HANDLE hFindVolumeMountPoint, LPSTR lpszVolumeMountPoint, DWORD cchBufferLength)
     * }
     */
    public static int FindNextVolumeMountPointA(MemorySegment hFindVolumeMountPoint, MemorySegment lpszVolumeMountPoint, int cchBufferLength) {
        var mh$ = FindNextVolumeMountPointA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FindNextVolumeMountPointA", hFindVolumeMountPoint, lpszVolumeMountPoint, cchBufferLength);
            }
            return (int)mh$.invokeExact(hFindVolumeMountPoint, lpszVolumeMountPoint, cchBufferLength);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FindNextVolumeMountPointW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("FindNextVolumeMountPointW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL FindNextVolumeMountPointW(HANDLE hFindVolumeMountPoint, LPWSTR lpszVolumeMountPoint, DWORD cchBufferLength)
     * }
     */
    public static FunctionDescriptor FindNextVolumeMountPointW$descriptor() {
        return FindNextVolumeMountPointW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL FindNextVolumeMountPointW(HANDLE hFindVolumeMountPoint, LPWSTR lpszVolumeMountPoint, DWORD cchBufferLength)
     * }
     */
    public static MethodHandle FindNextVolumeMountPointW$handle() {
        return FindNextVolumeMountPointW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL FindNextVolumeMountPointW(HANDLE hFindVolumeMountPoint, LPWSTR lpszVolumeMountPoint, DWORD cchBufferLength)
     * }
     */
    public static int FindNextVolumeMountPointW(MemorySegment hFindVolumeMountPoint, MemorySegment lpszVolumeMountPoint, int cchBufferLength) {
        var mh$ = FindNextVolumeMountPointW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FindNextVolumeMountPointW", hFindVolumeMountPoint, lpszVolumeMountPoint, cchBufferLength);
            }
            return (int)mh$.invokeExact(hFindVolumeMountPoint, lpszVolumeMountPoint, cchBufferLength);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FindVolumeMountPointClose {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("FindVolumeMountPointClose"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL FindVolumeMountPointClose(HANDLE hFindVolumeMountPoint)
     * }
     */
    public static FunctionDescriptor FindVolumeMountPointClose$descriptor() {
        return FindVolumeMountPointClose.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL FindVolumeMountPointClose(HANDLE hFindVolumeMountPoint)
     * }
     */
    public static MethodHandle FindVolumeMountPointClose$handle() {
        return FindVolumeMountPointClose.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL FindVolumeMountPointClose(HANDLE hFindVolumeMountPoint)
     * }
     */
    public static int FindVolumeMountPointClose(MemorySegment hFindVolumeMountPoint) {
        var mh$ = FindVolumeMountPointClose.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FindVolumeMountPointClose", hFindVolumeMountPoint);
            }
            return (int)mh$.invokeExact(hFindVolumeMountPoint);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetVolumeMountPointA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("SetVolumeMountPointA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetVolumeMountPointA(LPCSTR lpszVolumeMountPoint, LPCSTR lpszVolumeName)
     * }
     */
    public static FunctionDescriptor SetVolumeMountPointA$descriptor() {
        return SetVolumeMountPointA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetVolumeMountPointA(LPCSTR lpszVolumeMountPoint, LPCSTR lpszVolumeName)
     * }
     */
    public static MethodHandle SetVolumeMountPointA$handle() {
        return SetVolumeMountPointA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL SetVolumeMountPointA(LPCSTR lpszVolumeMountPoint, LPCSTR lpszVolumeName)
     * }
     */
    public static int SetVolumeMountPointA(MemorySegment lpszVolumeMountPoint, MemorySegment lpszVolumeName) {
        var mh$ = SetVolumeMountPointA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetVolumeMountPointA", lpszVolumeMountPoint, lpszVolumeName);
            }
            return (int)mh$.invokeExact(lpszVolumeMountPoint, lpszVolumeName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetVolumeMountPointW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("SetVolumeMountPointW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetVolumeMountPointW(LPCWSTR lpszVolumeMountPoint, LPCWSTR lpszVolumeName)
     * }
     */
    public static FunctionDescriptor SetVolumeMountPointW$descriptor() {
        return SetVolumeMountPointW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetVolumeMountPointW(LPCWSTR lpszVolumeMountPoint, LPCWSTR lpszVolumeName)
     * }
     */
    public static MethodHandle SetVolumeMountPointW$handle() {
        return SetVolumeMountPointW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL SetVolumeMountPointW(LPCWSTR lpszVolumeMountPoint, LPCWSTR lpszVolumeName)
     * }
     */
    public static int SetVolumeMountPointW(MemorySegment lpszVolumeMountPoint, MemorySegment lpszVolumeName) {
        var mh$ = SetVolumeMountPointW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetVolumeMountPointW", lpszVolumeMountPoint, lpszVolumeName);
            }
            return (int)mh$.invokeExact(lpszVolumeMountPoint, lpszVolumeName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DeleteVolumeMountPointA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("DeleteVolumeMountPointA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL DeleteVolumeMountPointA(LPCSTR lpszVolumeMountPoint)
     * }
     */
    public static FunctionDescriptor DeleteVolumeMountPointA$descriptor() {
        return DeleteVolumeMountPointA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL DeleteVolumeMountPointA(LPCSTR lpszVolumeMountPoint)
     * }
     */
    public static MethodHandle DeleteVolumeMountPointA$handle() {
        return DeleteVolumeMountPointA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL DeleteVolumeMountPointA(LPCSTR lpszVolumeMountPoint)
     * }
     */
    public static int DeleteVolumeMountPointA(MemorySegment lpszVolumeMountPoint) {
        var mh$ = DeleteVolumeMountPointA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DeleteVolumeMountPointA", lpszVolumeMountPoint);
            }
            return (int)mh$.invokeExact(lpszVolumeMountPoint);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetVolumeNameForVolumeMountPointA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetVolumeNameForVolumeMountPointA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetVolumeNameForVolumeMountPointA(LPCSTR lpszVolumeMountPoint, LPSTR lpszVolumeName, DWORD cchBufferLength)
     * }
     */
    public static FunctionDescriptor GetVolumeNameForVolumeMountPointA$descriptor() {
        return GetVolumeNameForVolumeMountPointA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetVolumeNameForVolumeMountPointA(LPCSTR lpszVolumeMountPoint, LPSTR lpszVolumeName, DWORD cchBufferLength)
     * }
     */
    public static MethodHandle GetVolumeNameForVolumeMountPointA$handle() {
        return GetVolumeNameForVolumeMountPointA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL GetVolumeNameForVolumeMountPointA(LPCSTR lpszVolumeMountPoint, LPSTR lpszVolumeName, DWORD cchBufferLength)
     * }
     */
    public static int GetVolumeNameForVolumeMountPointA(MemorySegment lpszVolumeMountPoint, MemorySegment lpszVolumeName, int cchBufferLength) {
        var mh$ = GetVolumeNameForVolumeMountPointA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetVolumeNameForVolumeMountPointA", lpszVolumeMountPoint, lpszVolumeName, cchBufferLength);
            }
            return (int)mh$.invokeExact(lpszVolumeMountPoint, lpszVolumeName, cchBufferLength);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetVolumePathNameA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetVolumePathNameA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetVolumePathNameA(LPCSTR lpszFileName, LPSTR lpszVolumePathName, DWORD cchBufferLength)
     * }
     */
    public static FunctionDescriptor GetVolumePathNameA$descriptor() {
        return GetVolumePathNameA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetVolumePathNameA(LPCSTR lpszFileName, LPSTR lpszVolumePathName, DWORD cchBufferLength)
     * }
     */
    public static MethodHandle GetVolumePathNameA$handle() {
        return GetVolumePathNameA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL GetVolumePathNameA(LPCSTR lpszFileName, LPSTR lpszVolumePathName, DWORD cchBufferLength)
     * }
     */
    public static int GetVolumePathNameA(MemorySegment lpszFileName, MemorySegment lpszVolumePathName, int cchBufferLength) {
        var mh$ = GetVolumePathNameA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetVolumePathNameA", lpszFileName, lpszVolumePathName, cchBufferLength);
            }
            return (int)mh$.invokeExact(lpszFileName, lpszVolumePathName, cchBufferLength);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetVolumePathNamesForVolumeNameA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_LONG,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetVolumePathNamesForVolumeNameA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetVolumePathNamesForVolumeNameA(LPCSTR lpszVolumeName, LPCH lpszVolumePathNames, DWORD cchBufferLength, PDWORD lpcchReturnLength)
     * }
     */
    public static FunctionDescriptor GetVolumePathNamesForVolumeNameA$descriptor() {
        return GetVolumePathNamesForVolumeNameA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetVolumePathNamesForVolumeNameA(LPCSTR lpszVolumeName, LPCH lpszVolumePathNames, DWORD cchBufferLength, PDWORD lpcchReturnLength)
     * }
     */
    public static MethodHandle GetVolumePathNamesForVolumeNameA$handle() {
        return GetVolumePathNamesForVolumeNameA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL GetVolumePathNamesForVolumeNameA(LPCSTR lpszVolumeName, LPCH lpszVolumePathNames, DWORD cchBufferLength, PDWORD lpcchReturnLength)
     * }
     */
    public static int GetVolumePathNamesForVolumeNameA(MemorySegment lpszVolumeName, MemorySegment lpszVolumePathNames, int cchBufferLength, MemorySegment lpcchReturnLength) {
        var mh$ = GetVolumePathNamesForVolumeNameA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetVolumePathNamesForVolumeNameA", lpszVolumeName, lpszVolumePathNames, cchBufferLength, lpcchReturnLength);
            }
            return (int)mh$.invokeExact(lpszVolumeName, lpszVolumePathNames, cchBufferLength, lpcchReturnLength);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct tagACTCTXA {
     *     ULONG cbSize;
     *     DWORD dwFlags;
     *     LPCSTR lpSource;
     *     USHORT wProcessorArchitecture;
     *     LANGID wLangId;
     *     LPCSTR lpAssemblyDirectory;
     *     LPCSTR lpResourceName;
     *     LPCSTR lpApplicationName;
     *     HMODULE hModule;
     * } *PACTCTXA
     * }
     */
    public static final AddressLayout PACTCTXA = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagACTCTXW {
     *     ULONG cbSize;
     *     DWORD dwFlags;
     *     LPCWSTR lpSource;
     *     USHORT wProcessorArchitecture;
     *     LANGID wLangId;
     *     LPCWSTR lpAssemblyDirectory;
     *     LPCWSTR lpResourceName;
     *     LPCWSTR lpApplicationName;
     *     HMODULE hModule;
     * } *PACTCTXW
     * }
     */
    public static final AddressLayout PACTCTXW = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef PACTCTXA PACTCTX
     * }
     */
    public static final AddressLayout PACTCTX = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef const ACTCTXA *PCACTCTXA
     * }
     */
    public static final AddressLayout PCACTCTXA = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef const ACTCTXW *PCACTCTXW
     * }
     */
    public static final AddressLayout PCACTCTXW = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef PCACTCTXA PCACTCTX
     * }
     */
    public static final AddressLayout PCACTCTX = C_POINTER;

    private static class CreateActCtxA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CreateActCtxA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HANDLE CreateActCtxA(PCACTCTXA pActCtx)
     * }
     */
    public static FunctionDescriptor CreateActCtxA$descriptor() {
        return CreateActCtxA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HANDLE CreateActCtxA(PCACTCTXA pActCtx)
     * }
     */
    public static MethodHandle CreateActCtxA$handle() {
        return CreateActCtxA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * HANDLE CreateActCtxA(PCACTCTXA pActCtx)
     * }
     */
    public static MemorySegment CreateActCtxA(MemorySegment pActCtx) {
        var mh$ = CreateActCtxA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateActCtxA", pActCtx);
            }
            return (MemorySegment)mh$.invokeExact(pActCtx);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateActCtxW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CreateActCtxW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HANDLE CreateActCtxW(PCACTCTXW pActCtx)
     * }
     */
    public static FunctionDescriptor CreateActCtxW$descriptor() {
        return CreateActCtxW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HANDLE CreateActCtxW(PCACTCTXW pActCtx)
     * }
     */
    public static MethodHandle CreateActCtxW$handle() {
        return CreateActCtxW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * HANDLE CreateActCtxW(PCACTCTXW pActCtx)
     * }
     */
    public static MemorySegment CreateActCtxW(MemorySegment pActCtx) {
        var mh$ = CreateActCtxW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateActCtxW", pActCtx);
            }
            return (MemorySegment)mh$.invokeExact(pActCtx);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class AddRefActCtx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("AddRefActCtx"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void AddRefActCtx(HANDLE hActCtx)
     * }
     */
    public static FunctionDescriptor AddRefActCtx$descriptor() {
        return AddRefActCtx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void AddRefActCtx(HANDLE hActCtx)
     * }
     */
    public static MethodHandle AddRefActCtx$handle() {
        return AddRefActCtx.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * void AddRefActCtx(HANDLE hActCtx)
     * }
     */
    public static void AddRefActCtx(MemorySegment hActCtx) {
        var mh$ = AddRefActCtx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("AddRefActCtx", hActCtx);
            }
            mh$.invokeExact(hActCtx);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ReleaseActCtx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("ReleaseActCtx"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ReleaseActCtx(HANDLE hActCtx)
     * }
     */
    public static FunctionDescriptor ReleaseActCtx$descriptor() {
        return ReleaseActCtx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ReleaseActCtx(HANDLE hActCtx)
     * }
     */
    public static MethodHandle ReleaseActCtx$handle() {
        return ReleaseActCtx.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * void ReleaseActCtx(HANDLE hActCtx)
     * }
     */
    public static void ReleaseActCtx(MemorySegment hActCtx) {
        var mh$ = ReleaseActCtx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ReleaseActCtx", hActCtx);
            }
            mh$.invokeExact(hActCtx);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ZombifyActCtx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("ZombifyActCtx"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL ZombifyActCtx(HANDLE hActCtx)
     * }
     */
    public static FunctionDescriptor ZombifyActCtx$descriptor() {
        return ZombifyActCtx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL ZombifyActCtx(HANDLE hActCtx)
     * }
     */
    public static MethodHandle ZombifyActCtx$handle() {
        return ZombifyActCtx.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL ZombifyActCtx(HANDLE hActCtx)
     * }
     */
    public static int ZombifyActCtx(MemorySegment hActCtx) {
        var mh$ = ZombifyActCtx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ZombifyActCtx", hActCtx);
            }
            return (int)mh$.invokeExact(hActCtx);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ActivateActCtx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("ActivateActCtx"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL ActivateActCtx(HANDLE hActCtx, ULONG_PTR *lpCookie)
     * }
     */
    public static FunctionDescriptor ActivateActCtx$descriptor() {
        return ActivateActCtx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL ActivateActCtx(HANDLE hActCtx, ULONG_PTR *lpCookie)
     * }
     */
    public static MethodHandle ActivateActCtx$handle() {
        return ActivateActCtx.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL ActivateActCtx(HANDLE hActCtx, ULONG_PTR *lpCookie)
     * }
     */
    public static int ActivateActCtx(MemorySegment hActCtx, MemorySegment lpCookie) {
        var mh$ = ActivateActCtx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ActivateActCtx", hActCtx, lpCookie);
            }
            return (int)mh$.invokeExact(hActCtx, lpCookie);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DeactivateActCtx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_LONG,
            C_LONG_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("DeactivateActCtx"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL DeactivateActCtx(DWORD dwFlags, ULONG_PTR ulCookie)
     * }
     */
    public static FunctionDescriptor DeactivateActCtx$descriptor() {
        return DeactivateActCtx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL DeactivateActCtx(DWORD dwFlags, ULONG_PTR ulCookie)
     * }
     */
    public static MethodHandle DeactivateActCtx$handle() {
        return DeactivateActCtx.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL DeactivateActCtx(DWORD dwFlags, ULONG_PTR ulCookie)
     * }
     */
    public static int DeactivateActCtx(int dwFlags, long ulCookie) {
        var mh$ = DeactivateActCtx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DeactivateActCtx", dwFlags, ulCookie);
            }
            return (int)mh$.invokeExact(dwFlags, ulCookie);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetCurrentActCtx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetCurrentActCtx"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetCurrentActCtx(HANDLE *lphActCtx)
     * }
     */
    public static FunctionDescriptor GetCurrentActCtx$descriptor() {
        return GetCurrentActCtx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetCurrentActCtx(HANDLE *lphActCtx)
     * }
     */
    public static MethodHandle GetCurrentActCtx$handle() {
        return GetCurrentActCtx.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL GetCurrentActCtx(HANDLE *lphActCtx)
     * }
     */
    public static int GetCurrentActCtx(MemorySegment lphActCtx) {
        var mh$ = GetCurrentActCtx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetCurrentActCtx", lphActCtx);
            }
            return (int)mh$.invokeExact(lphActCtx);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct tagACTCTX_SECTION_KEYED_DATA_2600 {
     *     ULONG cbSize;
     *     ULONG ulDataFormatVersion;
     *     PVOID lpData;
     *     ULONG ulLength;
     *     PVOID lpSectionGlobalData;
     *     ULONG ulSectionGlobalDataLength;
     *     PVOID lpSectionBase;
     *     ULONG ulSectionTotalLength;
     *     HANDLE hActCtx;
     *     ULONG ulAssemblyRosterIndex;
     * } *PACTCTX_SECTION_KEYED_DATA_2600
     * }
     */
    public static final AddressLayout PACTCTX_SECTION_KEYED_DATA_2600 = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef const ACTCTX_SECTION_KEYED_DATA_2600 *PCACTCTX_SECTION_KEYED_DATA_2600
     * }
     */
    public static final AddressLayout PCACTCTX_SECTION_KEYED_DATA_2600 = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagACTCTX_SECTION_KEYED_DATA_ASSEMBLY_METADATA {
     *     PVOID lpInformation;
     *     PVOID lpSectionBase;
     *     ULONG ulSectionLength;
     *     PVOID lpSectionGlobalDataBase;
     *     ULONG ulSectionGlobalDataLength;
     * } *PACTCTX_SECTION_KEYED_DATA_ASSEMBLY_METADATA
     * }
     */
    public static final AddressLayout PACTCTX_SECTION_KEYED_DATA_ASSEMBLY_METADATA = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef const ACTCTX_SECTION_KEYED_DATA_ASSEMBLY_METADATA *PCACTCTX_SECTION_KEYED_DATA_ASSEMBLY_METADATA
     * }
     */
    public static final AddressLayout PCACTCTX_SECTION_KEYED_DATA_ASSEMBLY_METADATA = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagACTCTX_SECTION_KEYED_DATA {
     *     ULONG cbSize;
     *     ULONG ulDataFormatVersion;
     *     PVOID lpData;
     *     ULONG ulLength;
     *     PVOID lpSectionGlobalData;
     *     ULONG ulSectionGlobalDataLength;
     *     PVOID lpSectionBase;
     *     ULONG ulSectionTotalLength;
     *     HANDLE hActCtx;
     *     ULONG ulAssemblyRosterIndex;
     *     ULONG ulFlags;
     *     ACTCTX_SECTION_KEYED_DATA_ASSEMBLY_METADATA AssemblyMetadata;
     * } *PACTCTX_SECTION_KEYED_DATA
     * }
     */
    public static final AddressLayout PACTCTX_SECTION_KEYED_DATA = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef const ACTCTX_SECTION_KEYED_DATA *PCACTCTX_SECTION_KEYED_DATA
     * }
     */
    public static final AddressLayout PCACTCTX_SECTION_KEYED_DATA = C_POINTER;

    private static class FindActCtxSectionStringA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_LONG,
            C_POINTER,
            C_LONG,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("FindActCtxSectionStringA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL FindActCtxSectionStringA(DWORD dwFlags, const GUID *lpExtensionGuid, ULONG ulSectionId, LPCSTR lpStringToFind, PACTCTX_SECTION_KEYED_DATA ReturnedData)
     * }
     */
    public static FunctionDescriptor FindActCtxSectionStringA$descriptor() {
        return FindActCtxSectionStringA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL FindActCtxSectionStringA(DWORD dwFlags, const GUID *lpExtensionGuid, ULONG ulSectionId, LPCSTR lpStringToFind, PACTCTX_SECTION_KEYED_DATA ReturnedData)
     * }
     */
    public static MethodHandle FindActCtxSectionStringA$handle() {
        return FindActCtxSectionStringA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL FindActCtxSectionStringA(DWORD dwFlags, const GUID *lpExtensionGuid, ULONG ulSectionId, LPCSTR lpStringToFind, PACTCTX_SECTION_KEYED_DATA ReturnedData)
     * }
     */
    public static int FindActCtxSectionStringA(int dwFlags, MemorySegment lpExtensionGuid, int ulSectionId, MemorySegment lpStringToFind, MemorySegment ReturnedData) {
        var mh$ = FindActCtxSectionStringA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FindActCtxSectionStringA", dwFlags, lpExtensionGuid, ulSectionId, lpStringToFind, ReturnedData);
            }
            return (int)mh$.invokeExact(dwFlags, lpExtensionGuid, ulSectionId, lpStringToFind, ReturnedData);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FindActCtxSectionStringW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_LONG,
            C_POINTER,
            C_LONG,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("FindActCtxSectionStringW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL FindActCtxSectionStringW(DWORD dwFlags, const GUID *lpExtensionGuid, ULONG ulSectionId, LPCWSTR lpStringToFind, PACTCTX_SECTION_KEYED_DATA ReturnedData)
     * }
     */
    public static FunctionDescriptor FindActCtxSectionStringW$descriptor() {
        return FindActCtxSectionStringW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL FindActCtxSectionStringW(DWORD dwFlags, const GUID *lpExtensionGuid, ULONG ulSectionId, LPCWSTR lpStringToFind, PACTCTX_SECTION_KEYED_DATA ReturnedData)
     * }
     */
    public static MethodHandle FindActCtxSectionStringW$handle() {
        return FindActCtxSectionStringW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL FindActCtxSectionStringW(DWORD dwFlags, const GUID *lpExtensionGuid, ULONG ulSectionId, LPCWSTR lpStringToFind, PACTCTX_SECTION_KEYED_DATA ReturnedData)
     * }
     */
    public static int FindActCtxSectionStringW(int dwFlags, MemorySegment lpExtensionGuid, int ulSectionId, MemorySegment lpStringToFind, MemorySegment ReturnedData) {
        var mh$ = FindActCtxSectionStringW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FindActCtxSectionStringW", dwFlags, lpExtensionGuid, ulSectionId, lpStringToFind, ReturnedData);
            }
            return (int)mh$.invokeExact(dwFlags, lpExtensionGuid, ulSectionId, lpStringToFind, ReturnedData);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FindActCtxSectionGuid {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_LONG,
            C_POINTER,
            C_LONG,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("FindActCtxSectionGuid"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL FindActCtxSectionGuid(DWORD dwFlags, const GUID *lpExtensionGuid, ULONG ulSectionId, const GUID *lpGuidToFind, PACTCTX_SECTION_KEYED_DATA ReturnedData)
     * }
     */
    public static FunctionDescriptor FindActCtxSectionGuid$descriptor() {
        return FindActCtxSectionGuid.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL FindActCtxSectionGuid(DWORD dwFlags, const GUID *lpExtensionGuid, ULONG ulSectionId, const GUID *lpGuidToFind, PACTCTX_SECTION_KEYED_DATA ReturnedData)
     * }
     */
    public static MethodHandle FindActCtxSectionGuid$handle() {
        return FindActCtxSectionGuid.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL FindActCtxSectionGuid(DWORD dwFlags, const GUID *lpExtensionGuid, ULONG ulSectionId, const GUID *lpGuidToFind, PACTCTX_SECTION_KEYED_DATA ReturnedData)
     * }
     */
    public static int FindActCtxSectionGuid(int dwFlags, MemorySegment lpExtensionGuid, int ulSectionId, MemorySegment lpGuidToFind, MemorySegment ReturnedData) {
        var mh$ = FindActCtxSectionGuid.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FindActCtxSectionGuid", dwFlags, lpExtensionGuid, ulSectionId, lpGuidToFind, ReturnedData);
            }
            return (int)mh$.invokeExact(dwFlags, lpExtensionGuid, ulSectionId, lpGuidToFind, ReturnedData);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct _ACTIVATION_CONTEXT_BASIC_INFORMATION {
     *     HANDLE hActCtx;
     *     DWORD dwFlags;
     * } *PACTIVATION_CONTEXT_BASIC_INFORMATION
     * }
     */
    public static final AddressLayout PACTIVATION_CONTEXT_BASIC_INFORMATION = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef const struct _ACTIVATION_CONTEXT_BASIC_INFORMATION {
     *     HANDLE hActCtx;
     *     DWORD dwFlags;
     * } *PCACTIVATION_CONTEXT_BASIC_INFORMATION
     * }
     */
    public static final AddressLayout PCACTIVATION_CONTEXT_BASIC_INFORMATION = C_POINTER;

    private static class QueryActCtxW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_LONG,
            C_POINTER,
            C_POINTER,
            C_LONG,
            C_POINTER,
            C_LONG_LONG,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("QueryActCtxW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL QueryActCtxW(DWORD dwFlags, HANDLE hActCtx, PVOID pvSubInstance, ULONG ulInfoClass, PVOID pvBuffer, SIZE_T cbBuffer, SIZE_T *pcbWrittenOrRequired)
     * }
     */
    public static FunctionDescriptor QueryActCtxW$descriptor() {
        return QueryActCtxW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL QueryActCtxW(DWORD dwFlags, HANDLE hActCtx, PVOID pvSubInstance, ULONG ulInfoClass, PVOID pvBuffer, SIZE_T cbBuffer, SIZE_T *pcbWrittenOrRequired)
     * }
     */
    public static MethodHandle QueryActCtxW$handle() {
        return QueryActCtxW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL QueryActCtxW(DWORD dwFlags, HANDLE hActCtx, PVOID pvSubInstance, ULONG ulInfoClass, PVOID pvBuffer, SIZE_T cbBuffer, SIZE_T *pcbWrittenOrRequired)
     * }
     */
    public static int QueryActCtxW(int dwFlags, MemorySegment hActCtx, MemorySegment pvSubInstance, int ulInfoClass, MemorySegment pvBuffer, long cbBuffer, MemorySegment pcbWrittenOrRequired) {
        var mh$ = QueryActCtxW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("QueryActCtxW", dwFlags, hActCtx, pvSubInstance, ulInfoClass, pvBuffer, cbBuffer, pcbWrittenOrRequired);
            }
            return (int)mh$.invokeExact(dwFlags, hActCtx, pvSubInstance, ulInfoClass, pvBuffer, cbBuffer, pcbWrittenOrRequired);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class WTSGetActiveConsoleSessionId {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG    );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("WTSGetActiveConsoleSessionId"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD WTSGetActiveConsoleSessionId()
     * }
     */
    public static FunctionDescriptor WTSGetActiveConsoleSessionId$descriptor() {
        return WTSGetActiveConsoleSessionId.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD WTSGetActiveConsoleSessionId()
     * }
     */
    public static MethodHandle WTSGetActiveConsoleSessionId$handle() {
        return WTSGetActiveConsoleSessionId.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * DWORD WTSGetActiveConsoleSessionId()
     * }
     */
    public static int WTSGetActiveConsoleSessionId() {
        var mh$ = WTSGetActiveConsoleSessionId.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WTSGetActiveConsoleSessionId");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class WTSGetServiceSessionId {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG    );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("WTSGetServiceSessionId"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD WTSGetServiceSessionId()
     * }
     */
    public static FunctionDescriptor WTSGetServiceSessionId$descriptor() {
        return WTSGetServiceSessionId.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD WTSGetServiceSessionId()
     * }
     */
    public static MethodHandle WTSGetServiceSessionId$handle() {
        return WTSGetServiceSessionId.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * DWORD WTSGetServiceSessionId()
     * }
     */
    public static int WTSGetServiceSessionId() {
        var mh$ = WTSGetServiceSessionId.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WTSGetServiceSessionId");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class WTSIsServerContainer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_CHAR    );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("WTSIsServerContainer"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOLEAN WTSIsServerContainer()
     * }
     */
    public static FunctionDescriptor WTSIsServerContainer$descriptor() {
        return WTSIsServerContainer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOLEAN WTSIsServerContainer()
     * }
     */
    public static MethodHandle WTSIsServerContainer$handle() {
        return WTSIsServerContainer.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOLEAN WTSIsServerContainer()
     * }
     */
    public static byte WTSIsServerContainer() {
        var mh$ = WTSIsServerContainer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WTSIsServerContainer");
            }
            return (byte)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetActiveProcessorGroupCount {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_SHORT    );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetActiveProcessorGroupCount"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * WORD GetActiveProcessorGroupCount()
     * }
     */
    public static FunctionDescriptor GetActiveProcessorGroupCount$descriptor() {
        return GetActiveProcessorGroupCount.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * WORD GetActiveProcessorGroupCount()
     * }
     */
    public static MethodHandle GetActiveProcessorGroupCount$handle() {
        return GetActiveProcessorGroupCount.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * WORD GetActiveProcessorGroupCount()
     * }
     */
    public static short GetActiveProcessorGroupCount() {
        var mh$ = GetActiveProcessorGroupCount.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetActiveProcessorGroupCount");
            }
            return (short)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetMaximumProcessorGroupCount {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_SHORT    );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetMaximumProcessorGroupCount"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * WORD GetMaximumProcessorGroupCount()
     * }
     */
    public static FunctionDescriptor GetMaximumProcessorGroupCount$descriptor() {
        return GetMaximumProcessorGroupCount.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * WORD GetMaximumProcessorGroupCount()
     * }
     */
    public static MethodHandle GetMaximumProcessorGroupCount$handle() {
        return GetMaximumProcessorGroupCount.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * WORD GetMaximumProcessorGroupCount()
     * }
     */
    public static short GetMaximumProcessorGroupCount() {
        var mh$ = GetMaximumProcessorGroupCount.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetMaximumProcessorGroupCount");
            }
            return (short)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetActiveProcessorCount {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_SHORT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetActiveProcessorCount"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetActiveProcessorCount(WORD GroupNumber)
     * }
     */
    public static FunctionDescriptor GetActiveProcessorCount$descriptor() {
        return GetActiveProcessorCount.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetActiveProcessorCount(WORD GroupNumber)
     * }
     */
    public static MethodHandle GetActiveProcessorCount$handle() {
        return GetActiveProcessorCount.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * DWORD GetActiveProcessorCount(WORD GroupNumber)
     * }
     */
    public static int GetActiveProcessorCount(short GroupNumber) {
        var mh$ = GetActiveProcessorCount.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetActiveProcessorCount", GroupNumber);
            }
            return (int)mh$.invokeExact(GroupNumber);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetMaximumProcessorCount {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_SHORT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetMaximumProcessorCount"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetMaximumProcessorCount(WORD GroupNumber)
     * }
     */
    public static FunctionDescriptor GetMaximumProcessorCount$descriptor() {
        return GetMaximumProcessorCount.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetMaximumProcessorCount(WORD GroupNumber)
     * }
     */
    public static MethodHandle GetMaximumProcessorCount$handle() {
        return GetMaximumProcessorCount.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * DWORD GetMaximumProcessorCount(WORD GroupNumber)
     * }
     */
    public static int GetMaximumProcessorCount(short GroupNumber) {
        var mh$ = GetMaximumProcessorCount.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetMaximumProcessorCount", GroupNumber);
            }
            return (int)mh$.invokeExact(GroupNumber);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetNumaProcessorNode {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_CHAR,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetNumaProcessorNode"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetNumaProcessorNode(UCHAR Processor, PUCHAR NodeNumber)
     * }
     */
    public static FunctionDescriptor GetNumaProcessorNode$descriptor() {
        return GetNumaProcessorNode.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetNumaProcessorNode(UCHAR Processor, PUCHAR NodeNumber)
     * }
     */
    public static MethodHandle GetNumaProcessorNode$handle() {
        return GetNumaProcessorNode.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL GetNumaProcessorNode(UCHAR Processor, PUCHAR NodeNumber)
     * }
     */
    public static int GetNumaProcessorNode(byte Processor, MemorySegment NodeNumber) {
        var mh$ = GetNumaProcessorNode.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetNumaProcessorNode", Processor, NodeNumber);
            }
            return (int)mh$.invokeExact(Processor, NodeNumber);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetNumaNodeNumberFromHandle {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetNumaNodeNumberFromHandle"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetNumaNodeNumberFromHandle(HANDLE hFile, PUSHORT NodeNumber)
     * }
     */
    public static FunctionDescriptor GetNumaNodeNumberFromHandle$descriptor() {
        return GetNumaNodeNumberFromHandle.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetNumaNodeNumberFromHandle(HANDLE hFile, PUSHORT NodeNumber)
     * }
     */
    public static MethodHandle GetNumaNodeNumberFromHandle$handle() {
        return GetNumaNodeNumberFromHandle.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL GetNumaNodeNumberFromHandle(HANDLE hFile, PUSHORT NodeNumber)
     * }
     */
    public static int GetNumaNodeNumberFromHandle(MemorySegment hFile, MemorySegment NodeNumber) {
        var mh$ = GetNumaNodeNumberFromHandle.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetNumaNodeNumberFromHandle", hFile, NodeNumber);
            }
            return (int)mh$.invokeExact(hFile, NodeNumber);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetNumaProcessorNodeEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetNumaProcessorNodeEx"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetNumaProcessorNodeEx(PPROCESSOR_NUMBER Processor, PUSHORT NodeNumber)
     * }
     */
    public static FunctionDescriptor GetNumaProcessorNodeEx$descriptor() {
        return GetNumaProcessorNodeEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetNumaProcessorNodeEx(PPROCESSOR_NUMBER Processor, PUSHORT NodeNumber)
     * }
     */
    public static MethodHandle GetNumaProcessorNodeEx$handle() {
        return GetNumaProcessorNodeEx.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL GetNumaProcessorNodeEx(PPROCESSOR_NUMBER Processor, PUSHORT NodeNumber)
     * }
     */
    public static int GetNumaProcessorNodeEx(MemorySegment Processor, MemorySegment NodeNumber) {
        var mh$ = GetNumaProcessorNodeEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetNumaProcessorNodeEx", Processor, NodeNumber);
            }
            return (int)mh$.invokeExact(Processor, NodeNumber);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetNumaNodeProcessorMask {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_CHAR,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetNumaNodeProcessorMask"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetNumaNodeProcessorMask(UCHAR Node, PULONGLONG ProcessorMask)
     * }
     */
    public static FunctionDescriptor GetNumaNodeProcessorMask$descriptor() {
        return GetNumaNodeProcessorMask.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetNumaNodeProcessorMask(UCHAR Node, PULONGLONG ProcessorMask)
     * }
     */
    public static MethodHandle GetNumaNodeProcessorMask$handle() {
        return GetNumaNodeProcessorMask.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL GetNumaNodeProcessorMask(UCHAR Node, PULONGLONG ProcessorMask)
     * }
     */
    public static int GetNumaNodeProcessorMask(byte Node, MemorySegment ProcessorMask) {
        var mh$ = GetNumaNodeProcessorMask.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetNumaNodeProcessorMask", Node, ProcessorMask);
            }
            return (int)mh$.invokeExact(Node, ProcessorMask);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetNumaAvailableMemoryNode {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_CHAR,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetNumaAvailableMemoryNode"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetNumaAvailableMemoryNode(UCHAR Node, PULONGLONG AvailableBytes)
     * }
     */
    public static FunctionDescriptor GetNumaAvailableMemoryNode$descriptor() {
        return GetNumaAvailableMemoryNode.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetNumaAvailableMemoryNode(UCHAR Node, PULONGLONG AvailableBytes)
     * }
     */
    public static MethodHandle GetNumaAvailableMemoryNode$handle() {
        return GetNumaAvailableMemoryNode.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL GetNumaAvailableMemoryNode(UCHAR Node, PULONGLONG AvailableBytes)
     * }
     */
    public static int GetNumaAvailableMemoryNode(byte Node, MemorySegment AvailableBytes) {
        var mh$ = GetNumaAvailableMemoryNode.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetNumaAvailableMemoryNode", Node, AvailableBytes);
            }
            return (int)mh$.invokeExact(Node, AvailableBytes);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetNumaAvailableMemoryNodeEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_SHORT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetNumaAvailableMemoryNodeEx"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetNumaAvailableMemoryNodeEx(USHORT Node, PULONGLONG AvailableBytes)
     * }
     */
    public static FunctionDescriptor GetNumaAvailableMemoryNodeEx$descriptor() {
        return GetNumaAvailableMemoryNodeEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetNumaAvailableMemoryNodeEx(USHORT Node, PULONGLONG AvailableBytes)
     * }
     */
    public static MethodHandle GetNumaAvailableMemoryNodeEx$handle() {
        return GetNumaAvailableMemoryNodeEx.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL GetNumaAvailableMemoryNodeEx(USHORT Node, PULONGLONG AvailableBytes)
     * }
     */
    public static int GetNumaAvailableMemoryNodeEx(short Node, MemorySegment AvailableBytes) {
        var mh$ = GetNumaAvailableMemoryNodeEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetNumaAvailableMemoryNodeEx", Node, AvailableBytes);
            }
            return (int)mh$.invokeExact(Node, AvailableBytes);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetNumaProximityNode {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_LONG,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetNumaProximityNode"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetNumaProximityNode(ULONG ProximityId, PUCHAR NodeNumber)
     * }
     */
    public static FunctionDescriptor GetNumaProximityNode$descriptor() {
        return GetNumaProximityNode.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetNumaProximityNode(ULONG ProximityId, PUCHAR NodeNumber)
     * }
     */
    public static MethodHandle GetNumaProximityNode$handle() {
        return GetNumaProximityNode.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL GetNumaProximityNode(ULONG ProximityId, PUCHAR NodeNumber)
     * }
     */
    public static int GetNumaProximityNode(int ProximityId, MemorySegment NodeNumber) {
        var mh$ = GetNumaProximityNode.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetNumaProximityNode", ProximityId, NodeNumber);
            }
            return (int)mh$.invokeExact(ProximityId, NodeNumber);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RegisterApplicationRecoveryCallback {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_POINTER,
            C_POINTER,
            C_LONG,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("RegisterApplicationRecoveryCallback"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HRESULT RegisterApplicationRecoveryCallback(APPLICATION_RECOVERY_CALLBACK pRecoveyCallback, PVOID pvParameter, DWORD dwPingInterval, DWORD dwFlags)
     * }
     */
    public static FunctionDescriptor RegisterApplicationRecoveryCallback$descriptor() {
        return RegisterApplicationRecoveryCallback.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HRESULT RegisterApplicationRecoveryCallback(APPLICATION_RECOVERY_CALLBACK pRecoveyCallback, PVOID pvParameter, DWORD dwPingInterval, DWORD dwFlags)
     * }
     */
    public static MethodHandle RegisterApplicationRecoveryCallback$handle() {
        return RegisterApplicationRecoveryCallback.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * HRESULT RegisterApplicationRecoveryCallback(APPLICATION_RECOVERY_CALLBACK pRecoveyCallback, PVOID pvParameter, DWORD dwPingInterval, DWORD dwFlags)
     * }
     */
    public static int RegisterApplicationRecoveryCallback(MemorySegment pRecoveyCallback, MemorySegment pvParameter, int dwPingInterval, int dwFlags) {
        var mh$ = RegisterApplicationRecoveryCallback.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RegisterApplicationRecoveryCallback", pRecoveyCallback, pvParameter, dwPingInterval, dwFlags);
            }
            return (int)mh$.invokeExact(pRecoveyCallback, pvParameter, dwPingInterval, dwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class UnregisterApplicationRecoveryCallback {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG    );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("UnregisterApplicationRecoveryCallback"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HRESULT UnregisterApplicationRecoveryCallback()
     * }
     */
    public static FunctionDescriptor UnregisterApplicationRecoveryCallback$descriptor() {
        return UnregisterApplicationRecoveryCallback.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HRESULT UnregisterApplicationRecoveryCallback()
     * }
     */
    public static MethodHandle UnregisterApplicationRecoveryCallback$handle() {
        return UnregisterApplicationRecoveryCallback.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * HRESULT UnregisterApplicationRecoveryCallback()
     * }
     */
    public static int UnregisterApplicationRecoveryCallback() {
        var mh$ = UnregisterApplicationRecoveryCallback.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("UnregisterApplicationRecoveryCallback");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RegisterApplicationRestart {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_POINTER,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("RegisterApplicationRestart"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HRESULT RegisterApplicationRestart(PCWSTR pwzCommandline, DWORD dwFlags)
     * }
     */
    public static FunctionDescriptor RegisterApplicationRestart$descriptor() {
        return RegisterApplicationRestart.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HRESULT RegisterApplicationRestart(PCWSTR pwzCommandline, DWORD dwFlags)
     * }
     */
    public static MethodHandle RegisterApplicationRestart$handle() {
        return RegisterApplicationRestart.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * HRESULT RegisterApplicationRestart(PCWSTR pwzCommandline, DWORD dwFlags)
     * }
     */
    public static int RegisterApplicationRestart(MemorySegment pwzCommandline, int dwFlags) {
        var mh$ = RegisterApplicationRestart.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RegisterApplicationRestart", pwzCommandline, dwFlags);
            }
            return (int)mh$.invokeExact(pwzCommandline, dwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class UnregisterApplicationRestart {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG    );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("UnregisterApplicationRestart"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HRESULT UnregisterApplicationRestart()
     * }
     */
    public static FunctionDescriptor UnregisterApplicationRestart$descriptor() {
        return UnregisterApplicationRestart.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HRESULT UnregisterApplicationRestart()
     * }
     */
    public static MethodHandle UnregisterApplicationRestart$handle() {
        return UnregisterApplicationRestart.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * HRESULT UnregisterApplicationRestart()
     * }
     */
    public static int UnregisterApplicationRestart() {
        var mh$ = UnregisterApplicationRestart.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("UnregisterApplicationRestart");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetApplicationRecoveryCallback {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetApplicationRecoveryCallback"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HRESULT GetApplicationRecoveryCallback(HANDLE hProcess, APPLICATION_RECOVERY_CALLBACK *pRecoveryCallback, PVOID *ppvParameter, PDWORD pdwPingInterval, PDWORD pdwFlags)
     * }
     */
    public static FunctionDescriptor GetApplicationRecoveryCallback$descriptor() {
        return GetApplicationRecoveryCallback.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HRESULT GetApplicationRecoveryCallback(HANDLE hProcess, APPLICATION_RECOVERY_CALLBACK *pRecoveryCallback, PVOID *ppvParameter, PDWORD pdwPingInterval, PDWORD pdwFlags)
     * }
     */
    public static MethodHandle GetApplicationRecoveryCallback$handle() {
        return GetApplicationRecoveryCallback.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * HRESULT GetApplicationRecoveryCallback(HANDLE hProcess, APPLICATION_RECOVERY_CALLBACK *pRecoveryCallback, PVOID *ppvParameter, PDWORD pdwPingInterval, PDWORD pdwFlags)
     * }
     */
    public static int GetApplicationRecoveryCallback(MemorySegment hProcess, MemorySegment pRecoveryCallback, MemorySegment ppvParameter, MemorySegment pdwPingInterval, MemorySegment pdwFlags) {
        var mh$ = GetApplicationRecoveryCallback.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetApplicationRecoveryCallback", hProcess, pRecoveryCallback, ppvParameter, pdwPingInterval, pdwFlags);
            }
            return (int)mh$.invokeExact(hProcess, pRecoveryCallback, ppvParameter, pdwPingInterval, pdwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetApplicationRestartSettings {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetApplicationRestartSettings"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HRESULT GetApplicationRestartSettings(HANDLE hProcess, PWSTR pwzCommandline, PDWORD pcchSize, PDWORD pdwFlags)
     * }
     */
    public static FunctionDescriptor GetApplicationRestartSettings$descriptor() {
        return GetApplicationRestartSettings.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HRESULT GetApplicationRestartSettings(HANDLE hProcess, PWSTR pwzCommandline, PDWORD pcchSize, PDWORD pdwFlags)
     * }
     */
    public static MethodHandle GetApplicationRestartSettings$handle() {
        return GetApplicationRestartSettings.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * HRESULT GetApplicationRestartSettings(HANDLE hProcess, PWSTR pwzCommandline, PDWORD pcchSize, PDWORD pdwFlags)
     * }
     */
    public static int GetApplicationRestartSettings(MemorySegment hProcess, MemorySegment pwzCommandline, MemorySegment pcchSize, MemorySegment pdwFlags) {
        var mh$ = GetApplicationRestartSettings.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetApplicationRestartSettings", hProcess, pwzCommandline, pcchSize, pdwFlags);
            }
            return (int)mh$.invokeExact(hProcess, pwzCommandline, pcchSize, pdwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ApplicationRecoveryInProgress {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("ApplicationRecoveryInProgress"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HRESULT ApplicationRecoveryInProgress(PBOOL pbCancelled)
     * }
     */
    public static FunctionDescriptor ApplicationRecoveryInProgress$descriptor() {
        return ApplicationRecoveryInProgress.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HRESULT ApplicationRecoveryInProgress(PBOOL pbCancelled)
     * }
     */
    public static MethodHandle ApplicationRecoveryInProgress$handle() {
        return ApplicationRecoveryInProgress.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * HRESULT ApplicationRecoveryInProgress(PBOOL pbCancelled)
     * }
     */
    public static int ApplicationRecoveryInProgress(MemorySegment pbCancelled) {
        var mh$ = ApplicationRecoveryInProgress.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ApplicationRecoveryInProgress", pbCancelled);
            }
            return (int)mh$.invokeExact(pbCancelled);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ApplicationRecoveryFinished {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("ApplicationRecoveryFinished"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ApplicationRecoveryFinished(BOOL bSuccess)
     * }
     */
    public static FunctionDescriptor ApplicationRecoveryFinished$descriptor() {
        return ApplicationRecoveryFinished.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ApplicationRecoveryFinished(BOOL bSuccess)
     * }
     */
    public static MethodHandle ApplicationRecoveryFinished$handle() {
        return ApplicationRecoveryFinished.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * void ApplicationRecoveryFinished(BOOL bSuccess)
     * }
     */
    public static void ApplicationRecoveryFinished(int bSuccess) {
        var mh$ = ApplicationRecoveryFinished.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ApplicationRecoveryFinished", bSuccess);
            }
            mh$.invokeExact(bSuccess);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct _FILE_BASIC_INFO {
     *     LARGE_INTEGER CreationTime;
     *     LARGE_INTEGER LastAccessTime;
     *     LARGE_INTEGER LastWriteTime;
     *     LARGE_INTEGER ChangeTime;
     *     DWORD FileAttributes;
     * } *PFILE_BASIC_INFO
     * }
     */
    public static final AddressLayout PFILE_BASIC_INFO = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _FILE_STANDARD_INFO {
     *     LARGE_INTEGER AllocationSize;
     *     LARGE_INTEGER EndOfFile;
     *     DWORD NumberOfLinks;
     *     BOOLEAN DeletePending;
     *     BOOLEAN Directory;
     * } *PFILE_STANDARD_INFO
     * }
     */
    public static final AddressLayout PFILE_STANDARD_INFO = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _FILE_NAME_INFO {
     *     DWORD FileNameLength;
     *     WCHAR FileName[1];
     * } *PFILE_NAME_INFO
     * }
     */
    public static final AddressLayout PFILE_NAME_INFO = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _FILE_CASE_SENSITIVE_INFO {
     *     ULONG Flags;
     * } *PFILE_CASE_SENSITIVE_INFO
     * }
     */
    public static final AddressLayout PFILE_CASE_SENSITIVE_INFO = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _FILE_RENAME_INFO {
     *     union {
     *         BOOLEAN ReplaceIfExists;
     *         DWORD Flags;
     *     };
     *     HANDLE RootDirectory;
     *     DWORD FileNameLength;
     *     WCHAR FileName[1];
     * } *PFILE_RENAME_INFO
     * }
     */
    public static final AddressLayout PFILE_RENAME_INFO = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _FILE_ALLOCATION_INFO {
     *     LARGE_INTEGER AllocationSize;
     * } *PFILE_ALLOCATION_INFO
     * }
     */
    public static final AddressLayout PFILE_ALLOCATION_INFO = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _FILE_END_OF_FILE_INFO {
     *     LARGE_INTEGER EndOfFile;
     * } *PFILE_END_OF_FILE_INFO
     * }
     */
    public static final AddressLayout PFILE_END_OF_FILE_INFO = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _FILE_STREAM_INFO {
     *     DWORD NextEntryOffset;
     *     DWORD StreamNameLength;
     *     LARGE_INTEGER StreamSize;
     *     LARGE_INTEGER StreamAllocationSize;
     *     WCHAR StreamName[1];
     * } *PFILE_STREAM_INFO
     * }
     */
    public static final AddressLayout PFILE_STREAM_INFO = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _FILE_COMPRESSION_INFO {
     *     LARGE_INTEGER CompressedFileSize;
     *     WORD CompressionFormat;
     *     UCHAR CompressionUnitShift;
     *     UCHAR ChunkShift;
     *     UCHAR ClusterShift;
     *     UCHAR Reserved[3];
     * } *PFILE_COMPRESSION_INFO
     * }
     */
    public static final AddressLayout PFILE_COMPRESSION_INFO = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _FILE_ATTRIBUTE_TAG_INFO {
     *     DWORD FileAttributes;
     *     DWORD ReparseTag;
     * } *PFILE_ATTRIBUTE_TAG_INFO
     * }
     */
    public static final AddressLayout PFILE_ATTRIBUTE_TAG_INFO = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _FILE_DISPOSITION_INFO {
     *     BOOLEAN DeleteFileA;
     * } *PFILE_DISPOSITION_INFO
     * }
     */
    public static final AddressLayout PFILE_DISPOSITION_INFO = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _FILE_DISPOSITION_INFO_EX {
     *     DWORD Flags;
     * } *PFILE_DISPOSITION_INFO_EX
     * }
     */
    public static final AddressLayout PFILE_DISPOSITION_INFO_EX = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _FILE_ID_BOTH_DIR_INFO {
     *     DWORD NextEntryOffset;
     *     DWORD FileIndex;
     *     LARGE_INTEGER CreationTime;
     *     LARGE_INTEGER LastAccessTime;
     *     LARGE_INTEGER LastWriteTime;
     *     LARGE_INTEGER ChangeTime;
     *     LARGE_INTEGER EndOfFile;
     *     LARGE_INTEGER AllocationSize;
     *     DWORD FileAttributes;
     *     DWORD FileNameLength;
     *     DWORD EaSize;
     *     CCHAR ShortNameLength;
     *     WCHAR ShortName[12];
     *     LARGE_INTEGER FileId;
     *     WCHAR FileName[1];
     * } *PFILE_ID_BOTH_DIR_INFO
     * }
     */
    public static final AddressLayout PFILE_ID_BOTH_DIR_INFO = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _FILE_FULL_DIR_INFO {
     *     ULONG NextEntryOffset;
     *     ULONG FileIndex;
     *     LARGE_INTEGER CreationTime;
     *     LARGE_INTEGER LastAccessTime;
     *     LARGE_INTEGER LastWriteTime;
     *     LARGE_INTEGER ChangeTime;
     *     LARGE_INTEGER EndOfFile;
     *     LARGE_INTEGER AllocationSize;
     *     ULONG FileAttributes;
     *     ULONG FileNameLength;
     *     ULONG EaSize;
     *     WCHAR FileName[1];
     * } *PFILE_FULL_DIR_INFO
     * }
     */
    public static final AddressLayout PFILE_FULL_DIR_INFO = C_POINTER;
    private static final int IoPriorityHintVeryLow = (int)0L;
    /**
     * {@snippet lang=c :
     * enum _PRIORITY_HINT.IoPriorityHintVeryLow = 0
     * }
     */
    public static int IoPriorityHintVeryLow() {
        return IoPriorityHintVeryLow;
    }
    private static final int IoPriorityHintLow = (int)1L;
    /**
     * {@snippet lang=c :
     * enum _PRIORITY_HINT.IoPriorityHintLow = 1
     * }
     */
    public static int IoPriorityHintLow() {
        return IoPriorityHintLow;
    }
    private static final int IoPriorityHintNormal = (int)2L;
    /**
     * {@snippet lang=c :
     * enum _PRIORITY_HINT.IoPriorityHintNormal = 2
     * }
     */
    public static int IoPriorityHintNormal() {
        return IoPriorityHintNormal;
    }
    private static final int MaximumIoPriorityHintType = (int)3L;
    /**
     * {@snippet lang=c :
     * enum _PRIORITY_HINT.MaximumIoPriorityHintType = 3
     * }
     */
    public static int MaximumIoPriorityHintType() {
        return MaximumIoPriorityHintType;
    }
    /**
     * {@snippet lang=c :
     * typedef struct _FILE_IO_PRIORITY_HINT_INFO {
     *     PRIORITY_HINT PriorityHint;
     * } *PFILE_IO_PRIORITY_HINT_INFO
     * }
     */
    public static final AddressLayout PFILE_IO_PRIORITY_HINT_INFO = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _FILE_ALIGNMENT_INFO {
     *     ULONG AlignmentRequirement;
     * } *PFILE_ALIGNMENT_INFO
     * }
     */
    public static final AddressLayout PFILE_ALIGNMENT_INFO = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _FILE_STORAGE_INFO {
     *     ULONG LogicalBytesPerSector;
     *     ULONG PhysicalBytesPerSectorForAtomicity;
     *     ULONG PhysicalBytesPerSectorForPerformance;
     *     ULONG FileSystemEffectivePhysicalBytesPerSectorForAtomicity;
     *     ULONG Flags;
     *     ULONG ByteOffsetForSectorAlignment;
     *     ULONG ByteOffsetForPartitionAlignment;
     * } *PFILE_STORAGE_INFO
     * }
     */
    public static final AddressLayout PFILE_STORAGE_INFO = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _FILE_ID_INFO {
     *     ULONGLONG VolumeSerialNumber;
     *     FILE_ID_128 FileId;
     * } *PFILE_ID_INFO
     * }
     */
    public static final AddressLayout PFILE_ID_INFO = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _FILE_ID_EXTD_DIR_INFO {
     *     ULONG NextEntryOffset;
     *     ULONG FileIndex;
     *     LARGE_INTEGER CreationTime;
     *     LARGE_INTEGER LastAccessTime;
     *     LARGE_INTEGER LastWriteTime;
     *     LARGE_INTEGER ChangeTime;
     *     LARGE_INTEGER EndOfFile;
     *     LARGE_INTEGER AllocationSize;
     *     ULONG FileAttributes;
     *     ULONG FileNameLength;
     *     ULONG EaSize;
     *     ULONG ReparsePointTag;
     *     FILE_ID_128 FileId;
     *     WCHAR FileName[1];
     * } *PFILE_ID_EXTD_DIR_INFO
     * }
     */
    public static final AddressLayout PFILE_ID_EXTD_DIR_INFO = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _FILE_REMOTE_PROTOCOL_INFO {
     *     USHORT StructureVersion;
     *     USHORT StructureSize;
     *     ULONG Protocol;
     *     USHORT ProtocolMajorVersion;
     *     USHORT ProtocolMinorVersion;
     *     USHORT ProtocolRevision;
     *     USHORT Reserved;
     *     ULONG Flags;
     *     struct {
     *         ULONG Reserved[8];
     *     } GenericReserved;
     *     union {
     *         struct {
     *             struct {
     *                 ULONG Capabilities;
     *             } Server;
     *             struct {
     *                 ULONG Capabilities;
     *                 ULONG CachingFlags;
     *             } Share;
     *         } Smb2;
     *         ULONG Reserved[16];
     *     } ProtocolSpecific;
     * } *PFILE_REMOTE_PROTOCOL_INFO
     * }
     */
    public static final AddressLayout PFILE_REMOTE_PROTOCOL_INFO = C_POINTER;

    private static class GetFileInformationByHandleEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_INT,
            C_POINTER,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetFileInformationByHandleEx"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetFileInformationByHandleEx(HANDLE hFile, FILE_INFO_BY_HANDLE_CLASS FileInformationClass, LPVOID lpFileInformation, DWORD dwBufferSize)
     * }
     */
    public static FunctionDescriptor GetFileInformationByHandleEx$descriptor() {
        return GetFileInformationByHandleEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetFileInformationByHandleEx(HANDLE hFile, FILE_INFO_BY_HANDLE_CLASS FileInformationClass, LPVOID lpFileInformation, DWORD dwBufferSize)
     * }
     */
    public static MethodHandle GetFileInformationByHandleEx$handle() {
        return GetFileInformationByHandleEx.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL GetFileInformationByHandleEx(HANDLE hFile, FILE_INFO_BY_HANDLE_CLASS FileInformationClass, LPVOID lpFileInformation, DWORD dwBufferSize)
     * }
     */
    public static int GetFileInformationByHandleEx(MemorySegment hFile, int FileInformationClass, MemorySegment lpFileInformation, int dwBufferSize) {
        var mh$ = GetFileInformationByHandleEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetFileInformationByHandleEx", hFile, FileInformationClass, lpFileInformation, dwBufferSize);
            }
            return (int)mh$.invokeExact(hFile, FileInformationClass, lpFileInformation, dwBufferSize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int FileIdType = (int)0L;
    /**
     * {@snippet lang=c :
     * enum _FILE_ID_TYPE.FileIdType = 0
     * }
     */
    public static int FileIdType() {
        return FileIdType;
    }
    private static final int ObjectIdType = (int)1L;
    /**
     * {@snippet lang=c :
     * enum _FILE_ID_TYPE.ObjectIdType = 1
     * }
     */
    public static int ObjectIdType() {
        return ObjectIdType;
    }
    private static final int ExtendedFileIdType = (int)2L;
    /**
     * {@snippet lang=c :
     * enum _FILE_ID_TYPE.ExtendedFileIdType = 2
     * }
     */
    public static int ExtendedFileIdType() {
        return ExtendedFileIdType;
    }
    private static final int MaximumFileIdType = (int)3L;
    /**
     * {@snippet lang=c :
     * enum _FILE_ID_TYPE.MaximumFileIdType = 3
     * }
     */
    public static int MaximumFileIdType() {
        return MaximumFileIdType;
    }
    /**
     * {@snippet lang=c :
     * typedef enum _FILE_ID_TYPE {
     *     FileIdType,
     *     ObjectIdType,
     *     ExtendedFileIdType,
     *     MaximumFileIdType
     * } *PFILE_ID_TYPE
     * }
     */
    public static final AddressLayout PFILE_ID_TYPE = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct FILE_ID_DESCRIPTOR {
     *     DWORD dwSize;
     *     FILE_ID_TYPE Type;
     *     union {
     *         LARGE_INTEGER FileId;
     *         GUID ObjectId;
     *         FILE_ID_128 ExtendedFileId;
     *     };
     * } *LPFILE_ID_DESCRIPTOR
     * }
     */
    public static final AddressLayout LPFILE_ID_DESCRIPTOR = C_POINTER;

    private static class OpenFileById {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_LONG,
            C_LONG,
            C_POINTER,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("OpenFileById"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HANDLE OpenFileById(HANDLE hVolumeHint, LPFILE_ID_DESCRIPTOR lpFileId, DWORD dwDesiredAccess, DWORD dwShareMode, LPSECURITY_ATTRIBUTES lpSecurityAttributes, DWORD dwFlagsAndAttributes)
     * }
     */
    public static FunctionDescriptor OpenFileById$descriptor() {
        return OpenFileById.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HANDLE OpenFileById(HANDLE hVolumeHint, LPFILE_ID_DESCRIPTOR lpFileId, DWORD dwDesiredAccess, DWORD dwShareMode, LPSECURITY_ATTRIBUTES lpSecurityAttributes, DWORD dwFlagsAndAttributes)
     * }
     */
    public static MethodHandle OpenFileById$handle() {
        return OpenFileById.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * HANDLE OpenFileById(HANDLE hVolumeHint, LPFILE_ID_DESCRIPTOR lpFileId, DWORD dwDesiredAccess, DWORD dwShareMode, LPSECURITY_ATTRIBUTES lpSecurityAttributes, DWORD dwFlagsAndAttributes)
     * }
     */
    public static MemorySegment OpenFileById(MemorySegment hVolumeHint, MemorySegment lpFileId, int dwDesiredAccess, int dwShareMode, MemorySegment lpSecurityAttributes, int dwFlagsAndAttributes) {
        var mh$ = OpenFileById.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("OpenFileById", hVolumeHint, lpFileId, dwDesiredAccess, dwShareMode, lpSecurityAttributes, dwFlagsAndAttributes);
            }
            return (MemorySegment)mh$.invokeExact(hVolumeHint, lpFileId, dwDesiredAccess, dwShareMode, lpSecurityAttributes, dwFlagsAndAttributes);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateSymbolicLinkA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_CHAR,
            C_POINTER,
            C_POINTER,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CreateSymbolicLinkA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOLEAN CreateSymbolicLinkA(LPCSTR lpSymlinkFileName, LPCSTR lpTargetFileName, DWORD dwFlags)
     * }
     */
    public static FunctionDescriptor CreateSymbolicLinkA$descriptor() {
        return CreateSymbolicLinkA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOLEAN CreateSymbolicLinkA(LPCSTR lpSymlinkFileName, LPCSTR lpTargetFileName, DWORD dwFlags)
     * }
     */
    public static MethodHandle CreateSymbolicLinkA$handle() {
        return CreateSymbolicLinkA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOLEAN CreateSymbolicLinkA(LPCSTR lpSymlinkFileName, LPCSTR lpTargetFileName, DWORD dwFlags)
     * }
     */
    public static byte CreateSymbolicLinkA(MemorySegment lpSymlinkFileName, MemorySegment lpTargetFileName, int dwFlags) {
        var mh$ = CreateSymbolicLinkA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateSymbolicLinkA", lpSymlinkFileName, lpTargetFileName, dwFlags);
            }
            return (byte)mh$.invokeExact(lpSymlinkFileName, lpTargetFileName, dwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateSymbolicLinkW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_CHAR,
            C_POINTER,
            C_POINTER,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CreateSymbolicLinkW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOLEAN CreateSymbolicLinkW(LPCWSTR lpSymlinkFileName, LPCWSTR lpTargetFileName, DWORD dwFlags)
     * }
     */
    public static FunctionDescriptor CreateSymbolicLinkW$descriptor() {
        return CreateSymbolicLinkW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOLEAN CreateSymbolicLinkW(LPCWSTR lpSymlinkFileName, LPCWSTR lpTargetFileName, DWORD dwFlags)
     * }
     */
    public static MethodHandle CreateSymbolicLinkW$handle() {
        return CreateSymbolicLinkW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOLEAN CreateSymbolicLinkW(LPCWSTR lpSymlinkFileName, LPCWSTR lpTargetFileName, DWORD dwFlags)
     * }
     */
    public static byte CreateSymbolicLinkW(MemorySegment lpSymlinkFileName, MemorySegment lpTargetFileName, int dwFlags) {
        var mh$ = CreateSymbolicLinkW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateSymbolicLinkW", lpSymlinkFileName, lpTargetFileName, dwFlags);
            }
            return (byte)mh$.invokeExact(lpSymlinkFileName, lpTargetFileName, dwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class QueryActCtxSettingsW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_LONG,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_LONG_LONG,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("QueryActCtxSettingsW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL QueryActCtxSettingsW(DWORD dwFlags, HANDLE hActCtx, PCWSTR settingsNameSpace, PCWSTR settingName, PWSTR pvBuffer, SIZE_T dwBuffer, SIZE_T *pdwWrittenOrRequired)
     * }
     */
    public static FunctionDescriptor QueryActCtxSettingsW$descriptor() {
        return QueryActCtxSettingsW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL QueryActCtxSettingsW(DWORD dwFlags, HANDLE hActCtx, PCWSTR settingsNameSpace, PCWSTR settingName, PWSTR pvBuffer, SIZE_T dwBuffer, SIZE_T *pdwWrittenOrRequired)
     * }
     */
    public static MethodHandle QueryActCtxSettingsW$handle() {
        return QueryActCtxSettingsW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL QueryActCtxSettingsW(DWORD dwFlags, HANDLE hActCtx, PCWSTR settingsNameSpace, PCWSTR settingName, PWSTR pvBuffer, SIZE_T dwBuffer, SIZE_T *pdwWrittenOrRequired)
     * }
     */
    public static int QueryActCtxSettingsW(int dwFlags, MemorySegment hActCtx, MemorySegment settingsNameSpace, MemorySegment settingName, MemorySegment pvBuffer, long dwBuffer, MemorySegment pdwWrittenOrRequired) {
        var mh$ = QueryActCtxSettingsW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("QueryActCtxSettingsW", dwFlags, hActCtx, settingsNameSpace, settingName, pvBuffer, dwBuffer, pdwWrittenOrRequired);
            }
            return (int)mh$.invokeExact(dwFlags, hActCtx, settingsNameSpace, settingName, pvBuffer, dwBuffer, pdwWrittenOrRequired);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateSymbolicLinkTransactedA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_CHAR,
            C_POINTER,
            C_POINTER,
            C_LONG,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CreateSymbolicLinkTransactedA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOLEAN CreateSymbolicLinkTransactedA(LPCSTR lpSymlinkFileName, LPCSTR lpTargetFileName, DWORD dwFlags, HANDLE hTransaction)
     * }
     */
    public static FunctionDescriptor CreateSymbolicLinkTransactedA$descriptor() {
        return CreateSymbolicLinkTransactedA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOLEAN CreateSymbolicLinkTransactedA(LPCSTR lpSymlinkFileName, LPCSTR lpTargetFileName, DWORD dwFlags, HANDLE hTransaction)
     * }
     */
    public static MethodHandle CreateSymbolicLinkTransactedA$handle() {
        return CreateSymbolicLinkTransactedA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOLEAN CreateSymbolicLinkTransactedA(LPCSTR lpSymlinkFileName, LPCSTR lpTargetFileName, DWORD dwFlags, HANDLE hTransaction)
     * }
     */
    public static byte CreateSymbolicLinkTransactedA(MemorySegment lpSymlinkFileName, MemorySegment lpTargetFileName, int dwFlags, MemorySegment hTransaction) {
        var mh$ = CreateSymbolicLinkTransactedA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateSymbolicLinkTransactedA", lpSymlinkFileName, lpTargetFileName, dwFlags, hTransaction);
            }
            return (byte)mh$.invokeExact(lpSymlinkFileName, lpTargetFileName, dwFlags, hTransaction);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateSymbolicLinkTransactedW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_CHAR,
            C_POINTER,
            C_POINTER,
            C_LONG,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CreateSymbolicLinkTransactedW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOLEAN CreateSymbolicLinkTransactedW(LPCWSTR lpSymlinkFileName, LPCWSTR lpTargetFileName, DWORD dwFlags, HANDLE hTransaction)
     * }
     */
    public static FunctionDescriptor CreateSymbolicLinkTransactedW$descriptor() {
        return CreateSymbolicLinkTransactedW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOLEAN CreateSymbolicLinkTransactedW(LPCWSTR lpSymlinkFileName, LPCWSTR lpTargetFileName, DWORD dwFlags, HANDLE hTransaction)
     * }
     */
    public static MethodHandle CreateSymbolicLinkTransactedW$handle() {
        return CreateSymbolicLinkTransactedW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOLEAN CreateSymbolicLinkTransactedW(LPCWSTR lpSymlinkFileName, LPCWSTR lpTargetFileName, DWORD dwFlags, HANDLE hTransaction)
     * }
     */
    public static byte CreateSymbolicLinkTransactedW(MemorySegment lpSymlinkFileName, MemorySegment lpTargetFileName, int dwFlags, MemorySegment hTransaction) {
        var mh$ = CreateSymbolicLinkTransactedW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateSymbolicLinkTransactedW", lpSymlinkFileName, lpTargetFileName, dwFlags, hTransaction);
            }
            return (byte)mh$.invokeExact(lpSymlinkFileName, lpTargetFileName, dwFlags, hTransaction);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ReplacePartitionUnit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("ReplacePartitionUnit"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL ReplacePartitionUnit(PWSTR TargetPartition, PWSTR SparePartition, ULONG Flags)
     * }
     */
    public static FunctionDescriptor ReplacePartitionUnit$descriptor() {
        return ReplacePartitionUnit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL ReplacePartitionUnit(PWSTR TargetPartition, PWSTR SparePartition, ULONG Flags)
     * }
     */
    public static MethodHandle ReplacePartitionUnit$handle() {
        return ReplacePartitionUnit.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL ReplacePartitionUnit(PWSTR TargetPartition, PWSTR SparePartition, ULONG Flags)
     * }
     */
    public static int ReplacePartitionUnit(MemorySegment TargetPartition, MemorySegment SparePartition, int Flags) {
        var mh$ = ReplacePartitionUnit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ReplacePartitionUnit", TargetPartition, SparePartition, Flags);
            }
            return (int)mh$.invokeExact(TargetPartition, SparePartition, Flags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class AddSecureMemoryCacheCallback {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("AddSecureMemoryCacheCallback"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL AddSecureMemoryCacheCallback(PSECURE_MEMORY_CACHE_CALLBACK pfnCallBack)
     * }
     */
    public static FunctionDescriptor AddSecureMemoryCacheCallback$descriptor() {
        return AddSecureMemoryCacheCallback.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL AddSecureMemoryCacheCallback(PSECURE_MEMORY_CACHE_CALLBACK pfnCallBack)
     * }
     */
    public static MethodHandle AddSecureMemoryCacheCallback$handle() {
        return AddSecureMemoryCacheCallback.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL AddSecureMemoryCacheCallback(PSECURE_MEMORY_CACHE_CALLBACK pfnCallBack)
     * }
     */
    public static int AddSecureMemoryCacheCallback(MemorySegment pfnCallBack) {
        var mh$ = AddSecureMemoryCacheCallback.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("AddSecureMemoryCacheCallback", pfnCallBack);
            }
            return (int)mh$.invokeExact(pfnCallBack);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RemoveSecureMemoryCacheCallback {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("RemoveSecureMemoryCacheCallback"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL RemoveSecureMemoryCacheCallback(PSECURE_MEMORY_CACHE_CALLBACK pfnCallBack)
     * }
     */
    public static FunctionDescriptor RemoveSecureMemoryCacheCallback$descriptor() {
        return RemoveSecureMemoryCacheCallback.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL RemoveSecureMemoryCacheCallback(PSECURE_MEMORY_CACHE_CALLBACK pfnCallBack)
     * }
     */
    public static MethodHandle RemoveSecureMemoryCacheCallback$handle() {
        return RemoveSecureMemoryCacheCallback.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL RemoveSecureMemoryCacheCallback(PSECURE_MEMORY_CACHE_CALLBACK pfnCallBack)
     * }
     */
    public static int RemoveSecureMemoryCacheCallback(MemorySegment pfnCallBack) {
        var mh$ = RemoveSecureMemoryCacheCallback.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RemoveSecureMemoryCacheCallback", pfnCallBack);
            }
            return (int)mh$.invokeExact(pfnCallBack);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CopyContext {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_LONG,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CopyContext"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CopyContext(PCONTEXT Destination, DWORD ContextFlags, PCONTEXT Source)
     * }
     */
    public static FunctionDescriptor CopyContext$descriptor() {
        return CopyContext.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CopyContext(PCONTEXT Destination, DWORD ContextFlags, PCONTEXT Source)
     * }
     */
    public static MethodHandle CopyContext$handle() {
        return CopyContext.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL CopyContext(PCONTEXT Destination, DWORD ContextFlags, PCONTEXT Source)
     * }
     */
    public static int CopyContext(MemorySegment Destination, int ContextFlags, MemorySegment Source) {
        var mh$ = CopyContext.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CopyContext", Destination, ContextFlags, Source);
            }
            return (int)mh$.invokeExact(Destination, ContextFlags, Source);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class InitializeContext {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_LONG,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("InitializeContext"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL InitializeContext(PVOID Buffer, DWORD ContextFlags, PCONTEXT *Context, PDWORD ContextLength)
     * }
     */
    public static FunctionDescriptor InitializeContext$descriptor() {
        return InitializeContext.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL InitializeContext(PVOID Buffer, DWORD ContextFlags, PCONTEXT *Context, PDWORD ContextLength)
     * }
     */
    public static MethodHandle InitializeContext$handle() {
        return InitializeContext.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL InitializeContext(PVOID Buffer, DWORD ContextFlags, PCONTEXT *Context, PDWORD ContextLength)
     * }
     */
    public static int InitializeContext(MemorySegment Buffer, int ContextFlags, MemorySegment Context, MemorySegment ContextLength) {
        var mh$ = InitializeContext.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("InitializeContext", Buffer, ContextFlags, Context, ContextLength);
            }
            return (int)mh$.invokeExact(Buffer, ContextFlags, Context, ContextLength);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class InitializeContext2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_LONG,
            C_POINTER,
            C_POINTER,
            C_LONG_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("InitializeContext2"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL InitializeContext2(PVOID Buffer, DWORD ContextFlags, PCONTEXT *Context, PDWORD ContextLength, ULONG64 XStateCompactionMask)
     * }
     */
    public static FunctionDescriptor InitializeContext2$descriptor() {
        return InitializeContext2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL InitializeContext2(PVOID Buffer, DWORD ContextFlags, PCONTEXT *Context, PDWORD ContextLength, ULONG64 XStateCompactionMask)
     * }
     */
    public static MethodHandle InitializeContext2$handle() {
        return InitializeContext2.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL InitializeContext2(PVOID Buffer, DWORD ContextFlags, PCONTEXT *Context, PDWORD ContextLength, ULONG64 XStateCompactionMask)
     * }
     */
    public static int InitializeContext2(MemorySegment Buffer, int ContextFlags, MemorySegment Context, MemorySegment ContextLength, long XStateCompactionMask) {
        var mh$ = InitializeContext2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("InitializeContext2", Buffer, ContextFlags, Context, ContextLength, XStateCompactionMask);
            }
            return (int)mh$.invokeExact(Buffer, ContextFlags, Context, ContextLength, XStateCompactionMask);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetEnabledXStateFeatures {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG_LONG    );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetEnabledXStateFeatures"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD64 GetEnabledXStateFeatures()
     * }
     */
    public static FunctionDescriptor GetEnabledXStateFeatures$descriptor() {
        return GetEnabledXStateFeatures.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD64 GetEnabledXStateFeatures()
     * }
     */
    public static MethodHandle GetEnabledXStateFeatures$handle() {
        return GetEnabledXStateFeatures.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * DWORD64 GetEnabledXStateFeatures()
     * }
     */
    public static long GetEnabledXStateFeatures() {
        var mh$ = GetEnabledXStateFeatures.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetEnabledXStateFeatures");
            }
            return (long)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetXStateFeaturesMask {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetXStateFeaturesMask"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetXStateFeaturesMask(PCONTEXT Context, PDWORD64 FeatureMask)
     * }
     */
    public static FunctionDescriptor GetXStateFeaturesMask$descriptor() {
        return GetXStateFeaturesMask.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetXStateFeaturesMask(PCONTEXT Context, PDWORD64 FeatureMask)
     * }
     */
    public static MethodHandle GetXStateFeaturesMask$handle() {
        return GetXStateFeaturesMask.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL GetXStateFeaturesMask(PCONTEXT Context, PDWORD64 FeatureMask)
     * }
     */
    public static int GetXStateFeaturesMask(MemorySegment Context, MemorySegment FeatureMask) {
        var mh$ = GetXStateFeaturesMask.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetXStateFeaturesMask", Context, FeatureMask);
            }
            return (int)mh$.invokeExact(Context, FeatureMask);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LocateXStateFeature {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER,
            C_LONG,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("LocateXStateFeature"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PVOID LocateXStateFeature(PCONTEXT Context, DWORD FeatureId, PDWORD Length)
     * }
     */
    public static FunctionDescriptor LocateXStateFeature$descriptor() {
        return LocateXStateFeature.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PVOID LocateXStateFeature(PCONTEXT Context, DWORD FeatureId, PDWORD Length)
     * }
     */
    public static MethodHandle LocateXStateFeature$handle() {
        return LocateXStateFeature.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * PVOID LocateXStateFeature(PCONTEXT Context, DWORD FeatureId, PDWORD Length)
     * }
     */
    public static MemorySegment LocateXStateFeature(MemorySegment Context, int FeatureId, MemorySegment Length) {
        var mh$ = LocateXStateFeature.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LocateXStateFeature", Context, FeatureId, Length);
            }
            return (MemorySegment)mh$.invokeExact(Context, FeatureId, Length);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetXStateFeaturesMask {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_LONG_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("SetXStateFeaturesMask"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetXStateFeaturesMask(PCONTEXT Context, DWORD64 FeatureMask)
     * }
     */
    public static FunctionDescriptor SetXStateFeaturesMask$descriptor() {
        return SetXStateFeaturesMask.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetXStateFeaturesMask(PCONTEXT Context, DWORD64 FeatureMask)
     * }
     */
    public static MethodHandle SetXStateFeaturesMask$handle() {
        return SetXStateFeaturesMask.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL SetXStateFeaturesMask(PCONTEXT Context, DWORD64 FeatureMask)
     * }
     */
    public static int SetXStateFeaturesMask(MemorySegment Context, long FeatureMask) {
        var mh$ = SetXStateFeaturesMask.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetXStateFeaturesMask", Context, FeatureMask);
            }
            return (int)mh$.invokeExact(Context, FeatureMask);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetThreadEnabledXStateFeatures {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG_LONG    );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetThreadEnabledXStateFeatures"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD64 GetThreadEnabledXStateFeatures()
     * }
     */
    public static FunctionDescriptor GetThreadEnabledXStateFeatures$descriptor() {
        return GetThreadEnabledXStateFeatures.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD64 GetThreadEnabledXStateFeatures()
     * }
     */
    public static MethodHandle GetThreadEnabledXStateFeatures$handle() {
        return GetThreadEnabledXStateFeatures.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * DWORD64 GetThreadEnabledXStateFeatures()
     * }
     */
    public static long GetThreadEnabledXStateFeatures() {
        var mh$ = GetThreadEnabledXStateFeatures.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetThreadEnabledXStateFeatures");
            }
            return (long)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class EnableProcessOptionalXStateFeatures {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_LONG_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("EnableProcessOptionalXStateFeatures"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL EnableProcessOptionalXStateFeatures(DWORD64 Features)
     * }
     */
    public static FunctionDescriptor EnableProcessOptionalXStateFeatures$descriptor() {
        return EnableProcessOptionalXStateFeatures.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL EnableProcessOptionalXStateFeatures(DWORD64 Features)
     * }
     */
    public static MethodHandle EnableProcessOptionalXStateFeatures$handle() {
        return EnableProcessOptionalXStateFeatures.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL EnableProcessOptionalXStateFeatures(DWORD64 Features)
     * }
     */
    public static int EnableProcessOptionalXStateFeatures(long Features) {
        var mh$ = EnableProcessOptionalXStateFeatures.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("EnableProcessOptionalXStateFeatures", Features);
            }
            return (int)mh$.invokeExact(Features);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class EnableThreadProfiling {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_POINTER,
            C_LONG,
            C_LONG_LONG,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("EnableThreadProfiling"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD EnableThreadProfiling(HANDLE ThreadHandle, DWORD Flags, DWORD64 HardwareCounters, HANDLE *PerformanceDataHandle)
     * }
     */
    public static FunctionDescriptor EnableThreadProfiling$descriptor() {
        return EnableThreadProfiling.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD EnableThreadProfiling(HANDLE ThreadHandle, DWORD Flags, DWORD64 HardwareCounters, HANDLE *PerformanceDataHandle)
     * }
     */
    public static MethodHandle EnableThreadProfiling$handle() {
        return EnableThreadProfiling.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * DWORD EnableThreadProfiling(HANDLE ThreadHandle, DWORD Flags, DWORD64 HardwareCounters, HANDLE *PerformanceDataHandle)
     * }
     */
    public static int EnableThreadProfiling(MemorySegment ThreadHandle, int Flags, long HardwareCounters, MemorySegment PerformanceDataHandle) {
        var mh$ = EnableThreadProfiling.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("EnableThreadProfiling", ThreadHandle, Flags, HardwareCounters, PerformanceDataHandle);
            }
            return (int)mh$.invokeExact(ThreadHandle, Flags, HardwareCounters, PerformanceDataHandle);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DisableThreadProfiling {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("DisableThreadProfiling"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD DisableThreadProfiling(HANDLE PerformanceDataHandle)
     * }
     */
    public static FunctionDescriptor DisableThreadProfiling$descriptor() {
        return DisableThreadProfiling.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD DisableThreadProfiling(HANDLE PerformanceDataHandle)
     * }
     */
    public static MethodHandle DisableThreadProfiling$handle() {
        return DisableThreadProfiling.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * DWORD DisableThreadProfiling(HANDLE PerformanceDataHandle)
     * }
     */
    public static int DisableThreadProfiling(MemorySegment PerformanceDataHandle) {
        var mh$ = DisableThreadProfiling.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DisableThreadProfiling", PerformanceDataHandle);
            }
            return (int)mh$.invokeExact(PerformanceDataHandle);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class QueryThreadProfiling {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("QueryThreadProfiling"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD QueryThreadProfiling(HANDLE ThreadHandle, PBOOLEAN Enabled)
     * }
     */
    public static FunctionDescriptor QueryThreadProfiling$descriptor() {
        return QueryThreadProfiling.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD QueryThreadProfiling(HANDLE ThreadHandle, PBOOLEAN Enabled)
     * }
     */
    public static MethodHandle QueryThreadProfiling$handle() {
        return QueryThreadProfiling.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * DWORD QueryThreadProfiling(HANDLE ThreadHandle, PBOOLEAN Enabled)
     * }
     */
    public static int QueryThreadProfiling(MemorySegment ThreadHandle, MemorySegment Enabled) {
        var mh$ = QueryThreadProfiling.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("QueryThreadProfiling", ThreadHandle, Enabled);
            }
            return (int)mh$.invokeExact(ThreadHandle, Enabled);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ReadThreadProfilingData {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_POINTER,
            C_LONG,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("ReadThreadProfilingData"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD ReadThreadProfilingData(HANDLE PerformanceDataHandle, DWORD Flags, PPERFORMANCE_DATA PerformanceData)
     * }
     */
    public static FunctionDescriptor ReadThreadProfilingData$descriptor() {
        return ReadThreadProfilingData.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD ReadThreadProfilingData(HANDLE PerformanceDataHandle, DWORD Flags, PPERFORMANCE_DATA PerformanceData)
     * }
     */
    public static MethodHandle ReadThreadProfilingData$handle() {
        return ReadThreadProfilingData.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * DWORD ReadThreadProfilingData(HANDLE PerformanceDataHandle, DWORD Flags, PPERFORMANCE_DATA PerformanceData)
     * }
     */
    public static int ReadThreadProfilingData(MemorySegment PerformanceDataHandle, int Flags, MemorySegment PerformanceData) {
        var mh$ = ReadThreadProfilingData.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ReadThreadProfilingData", PerformanceDataHandle, Flags, PerformanceData);
            }
            return (int)mh$.invokeExact(PerformanceDataHandle, Flags, PerformanceData);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RaiseCustomSystemEventTrigger {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("RaiseCustomSystemEventTrigger"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD RaiseCustomSystemEventTrigger(PCUSTOM_SYSTEM_EVENT_TRIGGER_CONFIG CustomSystemEventTriggerConfig)
     * }
     */
    public static FunctionDescriptor RaiseCustomSystemEventTrigger$descriptor() {
        return RaiseCustomSystemEventTrigger.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD RaiseCustomSystemEventTrigger(PCUSTOM_SYSTEM_EVENT_TRIGGER_CONFIG CustomSystemEventTriggerConfig)
     * }
     */
    public static MethodHandle RaiseCustomSystemEventTrigger$handle() {
        return RaiseCustomSystemEventTrigger.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * DWORD RaiseCustomSystemEventTrigger(PCUSTOM_SYSTEM_EVENT_TRIGGER_CONFIG CustomSystemEventTriggerConfig)
     * }
     */
    public static int RaiseCustomSystemEventTrigger(MemorySegment CustomSystemEventTriggerConfig) {
        var mh$ = RaiseCustomSystemEventTrigger.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RaiseCustomSystemEventTrigger", CustomSystemEventTriggerConfig);
            }
            return (int)mh$.invokeExact(CustomSystemEventTriggerConfig);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct _DRAWPATRECT {
     *     POINT ptPosition;
     *     POINT ptSize;
     *     WORD wStyle;
     *     WORD wPattern;
     * } *PDRAWPATRECT
     * }
     */
    public static final AddressLayout PDRAWPATRECT = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _PSINJECTDATA {
     *     DWORD DataBytes;
     *     WORD InjectionPoint;
     *     WORD PageNumber;
     * } *PPSINJECTDATA
     * }
     */
    public static final AddressLayout PPSINJECTDATA = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _PSFEATURE_OUTPUT {
     *     BOOL bPageIndependent;
     *     BOOL bSetPageDevice;
     * } *PPSFEATURE_OUTPUT
     * }
     */
    public static final AddressLayout PPSFEATURE_OUTPUT = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _PSFEATURE_CUSTPAPER {
     *     LONG lOrientation;
     *     LONG lWidth;
     *     LONG lHeight;
     *     LONG lWidthOffset;
     *     LONG lHeightOffset;
     * } *PPSFEATURE_CUSTPAPER
     * }
     */
    public static final AddressLayout PPSFEATURE_CUSTPAPER = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagXFORM {
     *     FLOAT eM11;
     *     FLOAT eM12;
     *     FLOAT eM21;
     *     FLOAT eM22;
     *     FLOAT eDx;
     *     FLOAT eDy;
     * } *PXFORM
     * }
     */
    public static final AddressLayout PXFORM = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagXFORM {
     *     FLOAT eM11;
     *     FLOAT eM12;
     *     FLOAT eM21;
     *     FLOAT eM22;
     *     FLOAT eDx;
     *     FLOAT eDy;
     * } *LPXFORM
     * }
     */
    public static final AddressLayout LPXFORM = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagBITMAP {
     *     LONG bmType;
     *     LONG bmWidth;
     *     LONG bmHeight;
     *     LONG bmWidthBytes;
     *     WORD bmPlanes;
     *     WORD bmBitsPixel;
     *     LPVOID bmBits;
     * } *PBITMAP
     * }
     */
    public static final AddressLayout PBITMAP = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagBITMAP {
     *     LONG bmType;
     *     LONG bmWidth;
     *     LONG bmHeight;
     *     LONG bmWidthBytes;
     *     WORD bmPlanes;
     *     WORD bmBitsPixel;
     *     LPVOID bmBits;
     * } *NPBITMAP
     * }
     */
    public static final AddressLayout NPBITMAP = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagBITMAP {
     *     LONG bmType;
     *     LONG bmWidth;
     *     LONG bmHeight;
     *     LONG bmWidthBytes;
     *     WORD bmPlanes;
     *     WORD bmBitsPixel;
     *     LPVOID bmBits;
     * } *LPBITMAP
     * }
     */
    public static final AddressLayout LPBITMAP = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagRGBTRIPLE {
     *     BYTE rgbtBlue;
     *     BYTE rgbtGreen;
     *     BYTE rgbtRed;
     * } *PRGBTRIPLE
     * }
     */
    public static final AddressLayout PRGBTRIPLE = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagRGBTRIPLE {
     *     BYTE rgbtBlue;
     *     BYTE rgbtGreen;
     *     BYTE rgbtRed;
     * } *NPRGBTRIPLE
     * }
     */
    public static final AddressLayout NPRGBTRIPLE = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagRGBTRIPLE {
     *     BYTE rgbtBlue;
     *     BYTE rgbtGreen;
     *     BYTE rgbtRed;
     * } *LPRGBTRIPLE
     * }
     */
    public static final AddressLayout LPRGBTRIPLE = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef RGBQUAD *LPRGBQUAD
     * }
     */
    public static final AddressLayout LPRGBQUAD = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef LONG LCSCSTYPE
     * }
     */
    public static final OfInt LCSCSTYPE = C_LONG;
    /**
     * {@snippet lang=c :
     * typedef LONG LCSGAMUTMATCH
     * }
     */
    public static final OfInt LCSGAMUTMATCH = C_LONG;
    /**
     * {@snippet lang=c :
     * typedef long FXPT16DOT16
     * }
     */
    public static final OfInt FXPT16DOT16 = C_LONG;
    /**
     * {@snippet lang=c :
     * typedef long *LPFXPT16DOT16
     * }
     */
    public static final AddressLayout LPFXPT16DOT16 = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef long FXPT2DOT30
     * }
     */
    public static final OfInt FXPT2DOT30 = C_LONG;
    /**
     * {@snippet lang=c :
     * typedef long *LPFXPT2DOT30
     * }
     */
    public static final AddressLayout LPFXPT2DOT30 = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef CIEXYZ *LPCIEXYZ
     * }
     */
    public static final AddressLayout LPCIEXYZ = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef CIEXYZTRIPLE *LPCIEXYZTRIPLE
     * }
     */
    public static final AddressLayout LPCIEXYZTRIPLE = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagLOGCOLORSPACEA {
     *     DWORD lcsSignature;
     *     DWORD lcsVersion;
     *     DWORD lcsSize;
     *     LCSCSTYPE lcsCSType;
     *     LCSGAMUTMATCH lcsIntent;
     *     CIEXYZTRIPLE lcsEndpoints;
     *     DWORD lcsGammaRed;
     *     DWORD lcsGammaGreen;
     *     DWORD lcsGammaBlue;
     *     CHAR lcsFilename[260];
     * } *LPLOGCOLORSPACEA
     * }
     */
    public static final AddressLayout LPLOGCOLORSPACEA = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagLOGCOLORSPACEW {
     *     DWORD lcsSignature;
     *     DWORD lcsVersion;
     *     DWORD lcsSize;
     *     LCSCSTYPE lcsCSType;
     *     LCSGAMUTMATCH lcsIntent;
     *     CIEXYZTRIPLE lcsEndpoints;
     *     DWORD lcsGammaRed;
     *     DWORD lcsGammaGreen;
     *     DWORD lcsGammaBlue;
     *     WCHAR lcsFilename[260];
     * } *LPLOGCOLORSPACEW
     * }
     */
    public static final AddressLayout LPLOGCOLORSPACEW = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef LPLOGCOLORSPACEA LPLOGCOLORSPACE
     * }
     */
    public static final AddressLayout LPLOGCOLORSPACE = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagBITMAPCOREHEADER {
     *     DWORD bcSize;
     *     WORD bcWidth;
     *     WORD bcHeight;
     *     WORD bcPlanes;
     *     WORD bcBitCount;
     * } *LPBITMAPCOREHEADER
     * }
     */
    public static final AddressLayout LPBITMAPCOREHEADER = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagBITMAPCOREHEADER {
     *     DWORD bcSize;
     *     WORD bcWidth;
     *     WORD bcHeight;
     *     WORD bcPlanes;
     *     WORD bcBitCount;
     * } *PBITMAPCOREHEADER
     * }
     */
    public static final AddressLayout PBITMAPCOREHEADER = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagBITMAPINFOHEADER {
     *     DWORD biSize;
     *     LONG biWidth;
     *     LONG biHeight;
     *     WORD biPlanes;
     *     WORD biBitCount;
     *     DWORD biCompression;
     *     DWORD biSizeImage;
     *     LONG biXPelsPerMeter;
     *     LONG biYPelsPerMeter;
     *     DWORD biClrUsed;
     *     DWORD biClrImportant;
     * } *LPBITMAPINFOHEADER
     * }
     */
    public static final AddressLayout LPBITMAPINFOHEADER = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagBITMAPINFOHEADER {
     *     DWORD biSize;
     *     LONG biWidth;
     *     LONG biHeight;
     *     WORD biPlanes;
     *     WORD biBitCount;
     *     DWORD biCompression;
     *     DWORD biSizeImage;
     *     LONG biXPelsPerMeter;
     *     LONG biYPelsPerMeter;
     *     DWORD biClrUsed;
     *     DWORD biClrImportant;
     * } *PBITMAPINFOHEADER
     * }
     */
    public static final AddressLayout PBITMAPINFOHEADER = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct {
     *     DWORD bV4Size;
     *     LONG bV4Width;
     *     LONG bV4Height;
     *     WORD bV4Planes;
     *     WORD bV4BitCount;
     *     DWORD bV4V4Compression;
     *     DWORD bV4SizeImage;
     *     LONG bV4XPelsPerMeter;
     *     LONG bV4YPelsPerMeter;
     *     DWORD bV4ClrUsed;
     *     DWORD bV4ClrImportant;
     *     DWORD bV4RedMask;
     *     DWORD bV4GreenMask;
     *     DWORD bV4BlueMask;
     *     DWORD bV4AlphaMask;
     *     DWORD bV4CSType;
     *     CIEXYZTRIPLE bV4Endpoints;
     *     DWORD bV4GammaRed;
     *     DWORD bV4GammaGreen;
     *     DWORD bV4GammaBlue;
     * } *LPBITMAPV4HEADER
     * }
     */
    public static final AddressLayout LPBITMAPV4HEADER = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct {
     *     DWORD bV4Size;
     *     LONG bV4Width;
     *     LONG bV4Height;
     *     WORD bV4Planes;
     *     WORD bV4BitCount;
     *     DWORD bV4V4Compression;
     *     DWORD bV4SizeImage;
     *     LONG bV4XPelsPerMeter;
     *     LONG bV4YPelsPerMeter;
     *     DWORD bV4ClrUsed;
     *     DWORD bV4ClrImportant;
     *     DWORD bV4RedMask;
     *     DWORD bV4GreenMask;
     *     DWORD bV4BlueMask;
     *     DWORD bV4AlphaMask;
     *     DWORD bV4CSType;
     *     CIEXYZTRIPLE bV4Endpoints;
     *     DWORD bV4GammaRed;
     *     DWORD bV4GammaGreen;
     *     DWORD bV4GammaBlue;
     * } *PBITMAPV4HEADER
     * }
     */
    public static final AddressLayout PBITMAPV4HEADER = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct {
     *     DWORD bV5Size;
     *     LONG bV5Width;
     *     LONG bV5Height;
     *     WORD bV5Planes;
     *     WORD bV5BitCount;
     *     DWORD bV5Compression;
     *     DWORD bV5SizeImage;
     *     LONG bV5XPelsPerMeter;
     *     LONG bV5YPelsPerMeter;
     *     DWORD bV5ClrUsed;
     *     DWORD bV5ClrImportant;
     *     DWORD bV5RedMask;
     *     DWORD bV5GreenMask;
     *     DWORD bV5BlueMask;
     *     DWORD bV5AlphaMask;
     *     DWORD bV5CSType;
     *     CIEXYZTRIPLE bV5Endpoints;
     *     DWORD bV5GammaRed;
     *     DWORD bV5GammaGreen;
     *     DWORD bV5GammaBlue;
     *     DWORD bV5Intent;
     *     DWORD bV5ProfileData;
     *     DWORD bV5ProfileSize;
     *     DWORD bV5Reserved;
     * } *LPBITMAPV5HEADER
     * }
     */
    public static final AddressLayout LPBITMAPV5HEADER = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct {
     *     DWORD bV5Size;
     *     LONG bV5Width;
     *     LONG bV5Height;
     *     WORD bV5Planes;
     *     WORD bV5BitCount;
     *     DWORD bV5Compression;
     *     DWORD bV5SizeImage;
     *     LONG bV5XPelsPerMeter;
     *     LONG bV5YPelsPerMeter;
     *     DWORD bV5ClrUsed;
     *     DWORD bV5ClrImportant;
     *     DWORD bV5RedMask;
     *     DWORD bV5GreenMask;
     *     DWORD bV5BlueMask;
     *     DWORD bV5AlphaMask;
     *     DWORD bV5CSType;
     *     CIEXYZTRIPLE bV5Endpoints;
     *     DWORD bV5GammaRed;
     *     DWORD bV5GammaGreen;
     *     DWORD bV5GammaBlue;
     *     DWORD bV5Intent;
     *     DWORD bV5ProfileData;
     *     DWORD bV5ProfileSize;
     *     DWORD bV5Reserved;
     * } *PBITMAPV5HEADER
     * }
     */
    public static final AddressLayout PBITMAPV5HEADER = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagBITMAPINFO {
     *     BITMAPINFOHEADER bmiHeader;
     *     RGBQUAD bmiColors[1];
     * } *LPBITMAPINFO
     * }
     */
    public static final AddressLayout LPBITMAPINFO = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagBITMAPINFO {
     *     BITMAPINFOHEADER bmiHeader;
     *     RGBQUAD bmiColors[1];
     * } *PBITMAPINFO
     * }
     */
    public static final AddressLayout PBITMAPINFO = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagBITMAPCOREINFO {
     *     BITMAPCOREHEADER bmciHeader;
     *     RGBTRIPLE bmciColors[1];
     * } *LPBITMAPCOREINFO
     * }
     */
    public static final AddressLayout LPBITMAPCOREINFO = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagBITMAPCOREINFO {
     *     BITMAPCOREHEADER bmciHeader;
     *     RGBTRIPLE bmciColors[1];
     * } *PBITMAPCOREINFO
     * }
     */
    public static final AddressLayout PBITMAPCOREINFO = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagBITMAPFILEHEADER {
     *     WORD bfType;
     *     DWORD bfSize;
     *     WORD bfReserved1;
     *     WORD bfReserved2;
     *     DWORD bfOffBits;
     * } *LPBITMAPFILEHEADER
     * }
     */
    public static final AddressLayout LPBITMAPFILEHEADER = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagBITMAPFILEHEADER {
     *     WORD bfType;
     *     DWORD bfSize;
     *     WORD bfReserved1;
     *     WORD bfReserved2;
     *     DWORD bfOffBits;
     * } *PBITMAPFILEHEADER
     * }
     */
    public static final AddressLayout PBITMAPFILEHEADER = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagFONTSIGNATURE {
     *     DWORD fsUsb[4];
     *     DWORD fsCsb[2];
     * } *PFONTSIGNATURE
     * }
     */
    public static final AddressLayout PFONTSIGNATURE = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagFONTSIGNATURE {
     *     DWORD fsUsb[4];
     *     DWORD fsCsb[2];
     * } *LPFONTSIGNATURE
     * }
     */
    public static final AddressLayout LPFONTSIGNATURE = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagCHARSETINFO {
     *     UINT ciCharset;
     *     UINT ciACP;
     *     FONTSIGNATURE fs;
     * } *PCHARSETINFO
     * }
     */
    public static final AddressLayout PCHARSETINFO = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagCHARSETINFO {
     *     UINT ciCharset;
     *     UINT ciACP;
     *     FONTSIGNATURE fs;
     * } *NPCHARSETINFO
     * }
     */
    public static final AddressLayout NPCHARSETINFO = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagCHARSETINFO {
     *     UINT ciCharset;
     *     UINT ciACP;
     *     FONTSIGNATURE fs;
     * } *LPCHARSETINFO
     * }
     */
    public static final AddressLayout LPCHARSETINFO = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagLOCALESIGNATURE {
     *     DWORD lsUsb[4];
     *     DWORD lsCsbDefault[2];
     *     DWORD lsCsbSupported[2];
     * } *PLOCALESIGNATURE
     * }
     */
    public static final AddressLayout PLOCALESIGNATURE = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagLOCALESIGNATURE {
     *     DWORD lsUsb[4];
     *     DWORD lsCsbDefault[2];
     *     DWORD lsCsbSupported[2];
     * } *LPLOCALESIGNATURE
     * }
     */
    public static final AddressLayout LPLOCALESIGNATURE = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagHANDLETABLE {
     *     HGDIOBJ objectHandle[1];
     * } *PHANDLETABLE
     * }
     */
    public static final AddressLayout PHANDLETABLE = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagHANDLETABLE {
     *     HGDIOBJ objectHandle[1];
     * } *LPHANDLETABLE
     * }
     */
    public static final AddressLayout LPHANDLETABLE = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef __unaligned struct tagMETARECORD {
     *     DWORD rdSize;
     *     WORD rdFunction;
     *     WORD rdParm[1];
     * } *PMETARECORD
     * }
     */
    public static final AddressLayout PMETARECORD = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef __unaligned struct tagMETARECORD {
     *     DWORD rdSize;
     *     WORD rdFunction;
     *     WORD rdParm[1];
     * } *LPMETARECORD
     * }
     */
    public static final AddressLayout LPMETARECORD = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagMETAFILEPICT {
     *     LONG mm;
     *     LONG xExt;
     *     LONG yExt;
     *     HMETAFILE hMF;
     * } *LPMETAFILEPICT
     * }
     */
    public static final AddressLayout LPMETAFILEPICT = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef __unaligned struct tagMETAHEADER {
     *     WORD mtType;
     *     WORD mtHeaderSize;
     *     WORD mtVersion;
     *     DWORD mtSize;
     *     WORD mtNoObjects;
     *     DWORD mtMaxRecord;
     *     WORD mtNoParameters;
     * } *PMETAHEADER
     * }
     */
    public static final AddressLayout PMETAHEADER = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef __unaligned struct tagMETAHEADER {
     *     WORD mtType;
     *     WORD mtHeaderSize;
     *     WORD mtVersion;
     *     DWORD mtSize;
     *     WORD mtNoObjects;
     *     DWORD mtMaxRecord;
     *     WORD mtNoParameters;
     * } *LPMETAHEADER
     * }
     */
    public static final AddressLayout LPMETAHEADER = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagENHMETARECORD {
     *     DWORD iType;
     *     DWORD nSize;
     *     DWORD dParm[1];
     * } *PENHMETARECORD
     * }
     */
    public static final AddressLayout PENHMETARECORD = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagENHMETARECORD {
     *     DWORD iType;
     *     DWORD nSize;
     *     DWORD dParm[1];
     * } *LPENHMETARECORD
     * }
     */
    public static final AddressLayout LPENHMETARECORD = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagENHMETAHEADER {
     *     DWORD iType;
     *     DWORD nSize;
     *     RECTL rclBounds;
     *     RECTL rclFrame;
     *     DWORD dSignature;
     *     DWORD nVersion;
     *     DWORD nBytes;
     *     DWORD nRecords;
     *     WORD nHandles;
     *     WORD sReserved;
     *     DWORD nDescription;
     *     DWORD offDescription;
     *     DWORD nPalEntries;
     *     SIZEL szlDevice;
     *     SIZEL szlMillimeters;
     *     DWORD cbPixelFormat;
     *     DWORD offPixelFormat;
     *     DWORD bOpenGL;
     *     SIZEL szlMicrometers;
     * } *PENHMETAHEADER
     * }
     */
    public static final AddressLayout PENHMETAHEADER = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagENHMETAHEADER {
     *     DWORD iType;
     *     DWORD nSize;
     *     RECTL rclBounds;
     *     RECTL rclFrame;
     *     DWORD dSignature;
     *     DWORD nVersion;
     *     DWORD nBytes;
     *     DWORD nRecords;
     *     WORD nHandles;
     *     WORD sReserved;
     *     DWORD nDescription;
     *     DWORD offDescription;
     *     DWORD nPalEntries;
     *     SIZEL szlDevice;
     *     SIZEL szlMillimeters;
     *     DWORD cbPixelFormat;
     *     DWORD offPixelFormat;
     *     DWORD bOpenGL;
     *     SIZEL szlMicrometers;
     * } *LPENHMETAHEADER
     * }
     */
    public static final AddressLayout LPENHMETAHEADER = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef BYTE BCHAR
     * }
     */
    public static final OfByte BCHAR = C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef struct tagTEXTMETRICA {
     *     LONG tmHeight;
     *     LONG tmAscent;
     *     LONG tmDescent;
     *     LONG tmInternalLeading;
     *     LONG tmExternalLeading;
     *     LONG tmAveCharWidth;
     *     LONG tmMaxCharWidth;
     *     LONG tmWeight;
     *     LONG tmOverhang;
     *     LONG tmDigitizedAspectX;
     *     LONG tmDigitizedAspectY;
     *     BYTE tmFirstChar;
     *     BYTE tmLastChar;
     *     BYTE tmDefaultChar;
     *     BYTE tmBreakChar;
     *     BYTE tmItalic;
     *     BYTE tmUnderlined;
     *     BYTE tmStruckOut;
     *     BYTE tmPitchAndFamily;
     *     BYTE tmCharSet;
     * } *PTEXTMETRICA
     * }
     */
    public static final AddressLayout PTEXTMETRICA = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagTEXTMETRICA {
     *     LONG tmHeight;
     *     LONG tmAscent;
     *     LONG tmDescent;
     *     LONG tmInternalLeading;
     *     LONG tmExternalLeading;
     *     LONG tmAveCharWidth;
     *     LONG tmMaxCharWidth;
     *     LONG tmWeight;
     *     LONG tmOverhang;
     *     LONG tmDigitizedAspectX;
     *     LONG tmDigitizedAspectY;
     *     BYTE tmFirstChar;
     *     BYTE tmLastChar;
     *     BYTE tmDefaultChar;
     *     BYTE tmBreakChar;
     *     BYTE tmItalic;
     *     BYTE tmUnderlined;
     *     BYTE tmStruckOut;
     *     BYTE tmPitchAndFamily;
     *     BYTE tmCharSet;
     * } *NPTEXTMETRICA
     * }
     */
    public static final AddressLayout NPTEXTMETRICA = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagTEXTMETRICA {
     *     LONG tmHeight;
     *     LONG tmAscent;
     *     LONG tmDescent;
     *     LONG tmInternalLeading;
     *     LONG tmExternalLeading;
     *     LONG tmAveCharWidth;
     *     LONG tmMaxCharWidth;
     *     LONG tmWeight;
     *     LONG tmOverhang;
     *     LONG tmDigitizedAspectX;
     *     LONG tmDigitizedAspectY;
     *     BYTE tmFirstChar;
     *     BYTE tmLastChar;
     *     BYTE tmDefaultChar;
     *     BYTE tmBreakChar;
     *     BYTE tmItalic;
     *     BYTE tmUnderlined;
     *     BYTE tmStruckOut;
     *     BYTE tmPitchAndFamily;
     *     BYTE tmCharSet;
     * } *LPTEXTMETRICA
     * }
     */
    public static final AddressLayout LPTEXTMETRICA = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagTEXTMETRICW {
     *     LONG tmHeight;
     *     LONG tmAscent;
     *     LONG tmDescent;
     *     LONG tmInternalLeading;
     *     LONG tmExternalLeading;
     *     LONG tmAveCharWidth;
     *     LONG tmMaxCharWidth;
     *     LONG tmWeight;
     *     LONG tmOverhang;
     *     LONG tmDigitizedAspectX;
     *     LONG tmDigitizedAspectY;
     *     WCHAR tmFirstChar;
     *     WCHAR tmLastChar;
     *     WCHAR tmDefaultChar;
     *     WCHAR tmBreakChar;
     *     BYTE tmItalic;
     *     BYTE tmUnderlined;
     *     BYTE tmStruckOut;
     *     BYTE tmPitchAndFamily;
     *     BYTE tmCharSet;
     * } *PTEXTMETRICW
     * }
     */
    public static final AddressLayout PTEXTMETRICW = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagTEXTMETRICW {
     *     LONG tmHeight;
     *     LONG tmAscent;
     *     LONG tmDescent;
     *     LONG tmInternalLeading;
     *     LONG tmExternalLeading;
     *     LONG tmAveCharWidth;
     *     LONG tmMaxCharWidth;
     *     LONG tmWeight;
     *     LONG tmOverhang;
     *     LONG tmDigitizedAspectX;
     *     LONG tmDigitizedAspectY;
     *     WCHAR tmFirstChar;
     *     WCHAR tmLastChar;
     *     WCHAR tmDefaultChar;
     *     WCHAR tmBreakChar;
     *     BYTE tmItalic;
     *     BYTE tmUnderlined;
     *     BYTE tmStruckOut;
     *     BYTE tmPitchAndFamily;
     *     BYTE tmCharSet;
     * } *NPTEXTMETRICW
     * }
     */
    public static final AddressLayout NPTEXTMETRICW = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagTEXTMETRICW {
     *     LONG tmHeight;
     *     LONG tmAscent;
     *     LONG tmDescent;
     *     LONG tmInternalLeading;
     *     LONG tmExternalLeading;
     *     LONG tmAveCharWidth;
     *     LONG tmMaxCharWidth;
     *     LONG tmWeight;
     *     LONG tmOverhang;
     *     LONG tmDigitizedAspectX;
     *     LONG tmDigitizedAspectY;
     *     WCHAR tmFirstChar;
     *     WCHAR tmLastChar;
     *     WCHAR tmDefaultChar;
     *     WCHAR tmBreakChar;
     *     BYTE tmItalic;
     *     BYTE tmUnderlined;
     *     BYTE tmStruckOut;
     *     BYTE tmPitchAndFamily;
     *     BYTE tmCharSet;
     * } *LPTEXTMETRICW
     * }
     */
    public static final AddressLayout LPTEXTMETRICW = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef PTEXTMETRICA PTEXTMETRIC
     * }
     */
    public static final AddressLayout PTEXTMETRIC = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef NPTEXTMETRICA NPTEXTMETRIC
     * }
     */
    public static final AddressLayout NPTEXTMETRIC = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef LPTEXTMETRICA LPTEXTMETRIC
     * }
     */
    public static final AddressLayout LPTEXTMETRIC = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagNEWTEXTMETRICA {
     *     LONG tmHeight;
     *     LONG tmAscent;
     *     LONG tmDescent;
     *     LONG tmInternalLeading;
     *     LONG tmExternalLeading;
     *     LONG tmAveCharWidth;
     *     LONG tmMaxCharWidth;
     *     LONG tmWeight;
     *     LONG tmOverhang;
     *     LONG tmDigitizedAspectX;
     *     LONG tmDigitizedAspectY;
     *     BYTE tmFirstChar;
     *     BYTE tmLastChar;
     *     BYTE tmDefaultChar;
     *     BYTE tmBreakChar;
     *     BYTE tmItalic;
     *     BYTE tmUnderlined;
     *     BYTE tmStruckOut;
     *     BYTE tmPitchAndFamily;
     *     BYTE tmCharSet;
     *     DWORD ntmFlags;
     *     UINT ntmSizeEM;
     *     UINT ntmCellHeight;
     *     UINT ntmAvgWidth;
     * } *PNEWTEXTMETRICA
     * }
     */
    public static final AddressLayout PNEWTEXTMETRICA = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagNEWTEXTMETRICA {
     *     LONG tmHeight;
     *     LONG tmAscent;
     *     LONG tmDescent;
     *     LONG tmInternalLeading;
     *     LONG tmExternalLeading;
     *     LONG tmAveCharWidth;
     *     LONG tmMaxCharWidth;
     *     LONG tmWeight;
     *     LONG tmOverhang;
     *     LONG tmDigitizedAspectX;
     *     LONG tmDigitizedAspectY;
     *     BYTE tmFirstChar;
     *     BYTE tmLastChar;
     *     BYTE tmDefaultChar;
     *     BYTE tmBreakChar;
     *     BYTE tmItalic;
     *     BYTE tmUnderlined;
     *     BYTE tmStruckOut;
     *     BYTE tmPitchAndFamily;
     *     BYTE tmCharSet;
     *     DWORD ntmFlags;
     *     UINT ntmSizeEM;
     *     UINT ntmCellHeight;
     *     UINT ntmAvgWidth;
     * } *NPNEWTEXTMETRICA
     * }
     */
    public static final AddressLayout NPNEWTEXTMETRICA = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagNEWTEXTMETRICA {
     *     LONG tmHeight;
     *     LONG tmAscent;
     *     LONG tmDescent;
     *     LONG tmInternalLeading;
     *     LONG tmExternalLeading;
     *     LONG tmAveCharWidth;
     *     LONG tmMaxCharWidth;
     *     LONG tmWeight;
     *     LONG tmOverhang;
     *     LONG tmDigitizedAspectX;
     *     LONG tmDigitizedAspectY;
     *     BYTE tmFirstChar;
     *     BYTE tmLastChar;
     *     BYTE tmDefaultChar;
     *     BYTE tmBreakChar;
     *     BYTE tmItalic;
     *     BYTE tmUnderlined;
     *     BYTE tmStruckOut;
     *     BYTE tmPitchAndFamily;
     *     BYTE tmCharSet;
     *     DWORD ntmFlags;
     *     UINT ntmSizeEM;
     *     UINT ntmCellHeight;
     *     UINT ntmAvgWidth;
     * } *LPNEWTEXTMETRICA
     * }
     */
    public static final AddressLayout LPNEWTEXTMETRICA = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagNEWTEXTMETRICW {
     *     LONG tmHeight;
     *     LONG tmAscent;
     *     LONG tmDescent;
     *     LONG tmInternalLeading;
     *     LONG tmExternalLeading;
     *     LONG tmAveCharWidth;
     *     LONG tmMaxCharWidth;
     *     LONG tmWeight;
     *     LONG tmOverhang;
     *     LONG tmDigitizedAspectX;
     *     LONG tmDigitizedAspectY;
     *     WCHAR tmFirstChar;
     *     WCHAR tmLastChar;
     *     WCHAR tmDefaultChar;
     *     WCHAR tmBreakChar;
     *     BYTE tmItalic;
     *     BYTE tmUnderlined;
     *     BYTE tmStruckOut;
     *     BYTE tmPitchAndFamily;
     *     BYTE tmCharSet;
     *     DWORD ntmFlags;
     *     UINT ntmSizeEM;
     *     UINT ntmCellHeight;
     *     UINT ntmAvgWidth;
     * } *PNEWTEXTMETRICW
     * }
     */
    public static final AddressLayout PNEWTEXTMETRICW = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagNEWTEXTMETRICW {
     *     LONG tmHeight;
     *     LONG tmAscent;
     *     LONG tmDescent;
     *     LONG tmInternalLeading;
     *     LONG tmExternalLeading;
     *     LONG tmAveCharWidth;
     *     LONG tmMaxCharWidth;
     *     LONG tmWeight;
     *     LONG tmOverhang;
     *     LONG tmDigitizedAspectX;
     *     LONG tmDigitizedAspectY;
     *     WCHAR tmFirstChar;
     *     WCHAR tmLastChar;
     *     WCHAR tmDefaultChar;
     *     WCHAR tmBreakChar;
     *     BYTE tmItalic;
     *     BYTE tmUnderlined;
     *     BYTE tmStruckOut;
     *     BYTE tmPitchAndFamily;
     *     BYTE tmCharSet;
     *     DWORD ntmFlags;
     *     UINT ntmSizeEM;
     *     UINT ntmCellHeight;
     *     UINT ntmAvgWidth;
     * } *NPNEWTEXTMETRICW
     * }
     */
    public static final AddressLayout NPNEWTEXTMETRICW = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagNEWTEXTMETRICW {
     *     LONG tmHeight;
     *     LONG tmAscent;
     *     LONG tmDescent;
     *     LONG tmInternalLeading;
     *     LONG tmExternalLeading;
     *     LONG tmAveCharWidth;
     *     LONG tmMaxCharWidth;
     *     LONG tmWeight;
     *     LONG tmOverhang;
     *     LONG tmDigitizedAspectX;
     *     LONG tmDigitizedAspectY;
     *     WCHAR tmFirstChar;
     *     WCHAR tmLastChar;
     *     WCHAR tmDefaultChar;
     *     WCHAR tmBreakChar;
     *     BYTE tmItalic;
     *     BYTE tmUnderlined;
     *     BYTE tmStruckOut;
     *     BYTE tmPitchAndFamily;
     *     BYTE tmCharSet;
     *     DWORD ntmFlags;
     *     UINT ntmSizeEM;
     *     UINT ntmCellHeight;
     *     UINT ntmAvgWidth;
     * } *LPNEWTEXTMETRICW
     * }
     */
    public static final AddressLayout LPNEWTEXTMETRICW = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef PNEWTEXTMETRICA PNEWTEXTMETRIC
     * }
     */
    public static final AddressLayout PNEWTEXTMETRIC = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef NPNEWTEXTMETRICA NPNEWTEXTMETRIC
     * }
     */
    public static final AddressLayout NPNEWTEXTMETRIC = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef LPNEWTEXTMETRICA LPNEWTEXTMETRIC
     * }
     */
    public static final AddressLayout LPNEWTEXTMETRIC = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagPELARRAY {
     *     LONG paXCount;
     *     LONG paYCount;
     *     LONG paXExt;
     *     LONG paYExt;
     *     BYTE paRGBs;
     * } *PPELARRAY
     * }
     */
    public static final AddressLayout PPELARRAY = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagPELARRAY {
     *     LONG paXCount;
     *     LONG paYCount;
     *     LONG paXExt;
     *     LONG paYExt;
     *     BYTE paRGBs;
     * } *NPPELARRAY
     * }
     */
    public static final AddressLayout NPPELARRAY = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagPELARRAY {
     *     LONG paXCount;
     *     LONG paYCount;
     *     LONG paXExt;
     *     LONG paYExt;
     *     BYTE paRGBs;
     * } *LPPELARRAY
     * }
     */
    public static final AddressLayout LPPELARRAY = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagLOGBRUSH {
     *     UINT lbStyle;
     *     COLORREF lbColor;
     *     ULONG_PTR lbHatch;
     * } *PLOGBRUSH
     * }
     */
    public static final AddressLayout PLOGBRUSH = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagLOGBRUSH {
     *     UINT lbStyle;
     *     COLORREF lbColor;
     *     ULONG_PTR lbHatch;
     * } *NPLOGBRUSH
     * }
     */
    public static final AddressLayout NPLOGBRUSH = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagLOGBRUSH {
     *     UINT lbStyle;
     *     COLORREF lbColor;
     *     ULONG_PTR lbHatch;
     * } *LPLOGBRUSH
     * }
     */
    public static final AddressLayout LPLOGBRUSH = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagLOGBRUSH32 {
     *     UINT lbStyle;
     *     COLORREF lbColor;
     *     ULONG lbHatch;
     * } *PLOGBRUSH32
     * }
     */
    public static final AddressLayout PLOGBRUSH32 = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagLOGBRUSH32 {
     *     UINT lbStyle;
     *     COLORREF lbColor;
     *     ULONG lbHatch;
     * } *NPLOGBRUSH32
     * }
     */
    public static final AddressLayout NPLOGBRUSH32 = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagLOGBRUSH32 {
     *     UINT lbStyle;
     *     COLORREF lbColor;
     *     ULONG lbHatch;
     * } *LPLOGBRUSH32
     * }
     */
    public static final AddressLayout LPLOGBRUSH32 = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef PATTERN *PPATTERN
     * }
     */
    public static final AddressLayout PPATTERN = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef PATTERN *NPPATTERN
     * }
     */
    public static final AddressLayout NPPATTERN = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef PATTERN *LPPATTERN
     * }
     */
    public static final AddressLayout LPPATTERN = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagLOGPEN {
     *     UINT lopnStyle;
     *     POINT lopnWidth;
     *     COLORREF lopnColor;
     * } *PLOGPEN
     * }
     */
    public static final AddressLayout PLOGPEN = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagLOGPEN {
     *     UINT lopnStyle;
     *     POINT lopnWidth;
     *     COLORREF lopnColor;
     * } *NPLOGPEN
     * }
     */
    public static final AddressLayout NPLOGPEN = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagLOGPEN {
     *     UINT lopnStyle;
     *     POINT lopnWidth;
     *     COLORREF lopnColor;
     * } *LPLOGPEN
     * }
     */
    public static final AddressLayout LPLOGPEN = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEXTLOGPEN {
     *     DWORD elpPenStyle;
     *     DWORD elpWidth;
     *     UINT elpBrushStyle;
     *     COLORREF elpColor;
     *     ULONG_PTR elpHatch;
     *     DWORD elpNumEntries;
     *     DWORD elpStyleEntry[1];
     * } *PEXTLOGPEN
     * }
     */
    public static final AddressLayout PEXTLOGPEN = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEXTLOGPEN {
     *     DWORD elpPenStyle;
     *     DWORD elpWidth;
     *     UINT elpBrushStyle;
     *     COLORREF elpColor;
     *     ULONG_PTR elpHatch;
     *     DWORD elpNumEntries;
     *     DWORD elpStyleEntry[1];
     * } *NPEXTLOGPEN
     * }
     */
    public static final AddressLayout NPEXTLOGPEN = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEXTLOGPEN {
     *     DWORD elpPenStyle;
     *     DWORD elpWidth;
     *     UINT elpBrushStyle;
     *     COLORREF elpColor;
     *     ULONG_PTR elpHatch;
     *     DWORD elpNumEntries;
     *     DWORD elpStyleEntry[1];
     * } *LPEXTLOGPEN
     * }
     */
    public static final AddressLayout LPEXTLOGPEN = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEXTLOGPEN32 {
     *     DWORD elpPenStyle;
     *     DWORD elpWidth;
     *     UINT elpBrushStyle;
     *     COLORREF elpColor;
     *     ULONG elpHatch;
     *     DWORD elpNumEntries;
     *     DWORD elpStyleEntry[1];
     * } *PEXTLOGPEN32
     * }
     */
    public static final AddressLayout PEXTLOGPEN32 = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEXTLOGPEN32 {
     *     DWORD elpPenStyle;
     *     DWORD elpWidth;
     *     UINT elpBrushStyle;
     *     COLORREF elpColor;
     *     ULONG elpHatch;
     *     DWORD elpNumEntries;
     *     DWORD elpStyleEntry[1];
     * } *NPEXTLOGPEN32
     * }
     */
    public static final AddressLayout NPEXTLOGPEN32 = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEXTLOGPEN32 {
     *     DWORD elpPenStyle;
     *     DWORD elpWidth;
     *     UINT elpBrushStyle;
     *     COLORREF elpColor;
     *     ULONG elpHatch;
     *     DWORD elpNumEntries;
     *     DWORD elpStyleEntry[1];
     * } *LPEXTLOGPEN32
     * }
     */
    public static final AddressLayout LPEXTLOGPEN32 = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagPALETTEENTRY {
     *     BYTE peRed;
     *     BYTE peGreen;
     *     BYTE peBlue;
     *     BYTE peFlags;
     * } *PPALETTEENTRY
     * }
     */
    public static final AddressLayout PPALETTEENTRY = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagPALETTEENTRY {
     *     BYTE peRed;
     *     BYTE peGreen;
     *     BYTE peBlue;
     *     BYTE peFlags;
     * } *LPPALETTEENTRY
     * }
     */
    public static final AddressLayout LPPALETTEENTRY = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagLOGPALETTE {
     *     WORD palVersion;
     *     WORD palNumEntries;
     *     PALETTEENTRY palPalEntry[1];
     * } *PLOGPALETTE
     * }
     */
    public static final AddressLayout PLOGPALETTE = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagLOGPALETTE {
     *     WORD palVersion;
     *     WORD palNumEntries;
     *     PALETTEENTRY palPalEntry[1];
     * } *NPLOGPALETTE
     * }
     */
    public static final AddressLayout NPLOGPALETTE = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagLOGPALETTE {
     *     WORD palVersion;
     *     WORD palNumEntries;
     *     PALETTEENTRY palPalEntry[1];
     * } *LPLOGPALETTE
     * }
     */
    public static final AddressLayout LPLOGPALETTE = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagLOGFONTA {
     *     LONG lfHeight;
     *     LONG lfWidth;
     *     LONG lfEscapement;
     *     LONG lfOrientation;
     *     LONG lfWeight;
     *     BYTE lfItalic;
     *     BYTE lfUnderline;
     *     BYTE lfStrikeOut;
     *     BYTE lfCharSet;
     *     BYTE lfOutPrecision;
     *     BYTE lfClipPrecision;
     *     BYTE lfQuality;
     *     BYTE lfPitchAndFamily;
     *     CHAR lfFaceName[32];
     * } *PLOGFONTA
     * }
     */
    public static final AddressLayout PLOGFONTA = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagLOGFONTA {
     *     LONG lfHeight;
     *     LONG lfWidth;
     *     LONG lfEscapement;
     *     LONG lfOrientation;
     *     LONG lfWeight;
     *     BYTE lfItalic;
     *     BYTE lfUnderline;
     *     BYTE lfStrikeOut;
     *     BYTE lfCharSet;
     *     BYTE lfOutPrecision;
     *     BYTE lfClipPrecision;
     *     BYTE lfQuality;
     *     BYTE lfPitchAndFamily;
     *     CHAR lfFaceName[32];
     * } *NPLOGFONTA
     * }
     */
    public static final AddressLayout NPLOGFONTA = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagLOGFONTA {
     *     LONG lfHeight;
     *     LONG lfWidth;
     *     LONG lfEscapement;
     *     LONG lfOrientation;
     *     LONG lfWeight;
     *     BYTE lfItalic;
     *     BYTE lfUnderline;
     *     BYTE lfStrikeOut;
     *     BYTE lfCharSet;
     *     BYTE lfOutPrecision;
     *     BYTE lfClipPrecision;
     *     BYTE lfQuality;
     *     BYTE lfPitchAndFamily;
     *     CHAR lfFaceName[32];
     * } *LPLOGFONTA
     * }
     */
    public static final AddressLayout LPLOGFONTA = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagLOGFONTW {
     *     LONG lfHeight;
     *     LONG lfWidth;
     *     LONG lfEscapement;
     *     LONG lfOrientation;
     *     LONG lfWeight;
     *     BYTE lfItalic;
     *     BYTE lfUnderline;
     *     BYTE lfStrikeOut;
     *     BYTE lfCharSet;
     *     BYTE lfOutPrecision;
     *     BYTE lfClipPrecision;
     *     BYTE lfQuality;
     *     BYTE lfPitchAndFamily;
     *     WCHAR lfFaceName[32];
     * } *PLOGFONTW
     * }
     */
    public static final AddressLayout PLOGFONTW = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagLOGFONTW {
     *     LONG lfHeight;
     *     LONG lfWidth;
     *     LONG lfEscapement;
     *     LONG lfOrientation;
     *     LONG lfWeight;
     *     BYTE lfItalic;
     *     BYTE lfUnderline;
     *     BYTE lfStrikeOut;
     *     BYTE lfCharSet;
     *     BYTE lfOutPrecision;
     *     BYTE lfClipPrecision;
     *     BYTE lfQuality;
     *     BYTE lfPitchAndFamily;
     *     WCHAR lfFaceName[32];
     * } *NPLOGFONTW
     * }
     */
    public static final AddressLayout NPLOGFONTW = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagLOGFONTW {
     *     LONG lfHeight;
     *     LONG lfWidth;
     *     LONG lfEscapement;
     *     LONG lfOrientation;
     *     LONG lfWeight;
     *     BYTE lfItalic;
     *     BYTE lfUnderline;
     *     BYTE lfStrikeOut;
     *     BYTE lfCharSet;
     *     BYTE lfOutPrecision;
     *     BYTE lfClipPrecision;
     *     BYTE lfQuality;
     *     BYTE lfPitchAndFamily;
     *     WCHAR lfFaceName[32];
     * } *LPLOGFONTW
     * }
     */
    public static final AddressLayout LPLOGFONTW = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef PLOGFONTA PLOGFONT
     * }
     */
    public static final AddressLayout PLOGFONT = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef NPLOGFONTA NPLOGFONT
     * }
     */
    public static final AddressLayout NPLOGFONT = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef LPLOGFONTA LPLOGFONT
     * }
     */
    public static final AddressLayout LPLOGFONT = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagENUMLOGFONTA {
     *     LOGFONTA elfLogFont;
     *     BYTE elfFullName[64];
     *     BYTE elfStyle[32];
     * } *LPENUMLOGFONTA
     * }
     */
    public static final AddressLayout LPENUMLOGFONTA = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagENUMLOGFONTW {
     *     LOGFONTW elfLogFont;
     *     WCHAR elfFullName[64];
     *     WCHAR elfStyle[32];
     * } *LPENUMLOGFONTW
     * }
     */
    public static final AddressLayout LPENUMLOGFONTW = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef LPENUMLOGFONTA LPENUMLOGFONT
     * }
     */
    public static final AddressLayout LPENUMLOGFONT = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagENUMLOGFONTEXA {
     *     LOGFONTA elfLogFont;
     *     BYTE elfFullName[64];
     *     BYTE elfStyle[32];
     *     BYTE elfScript[32];
     * } *LPENUMLOGFONTEXA
     * }
     */
    public static final AddressLayout LPENUMLOGFONTEXA = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagENUMLOGFONTEXW {
     *     LOGFONTW elfLogFont;
     *     WCHAR elfFullName[64];
     *     WCHAR elfStyle[32];
     *     WCHAR elfScript[32];
     * } *LPENUMLOGFONTEXW
     * }
     */
    public static final AddressLayout LPENUMLOGFONTEXW = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef LPENUMLOGFONTEXA LPENUMLOGFONTEX
     * }
     */
    public static final AddressLayout LPENUMLOGFONTEX = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagPANOSE {
     *     BYTE bFamilyType;
     *     BYTE bSerifStyle;
     *     BYTE bWeight;
     *     BYTE bProportion;
     *     BYTE bContrast;
     *     BYTE bStrokeVariation;
     *     BYTE bArmStyle;
     *     BYTE bLetterform;
     *     BYTE bMidline;
     *     BYTE bXHeight;
     * } *LPPANOSE
     * }
     */
    public static final AddressLayout LPPANOSE = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEXTLOGFONTA {
     *     LOGFONTA elfLogFont;
     *     BYTE elfFullName[64];
     *     BYTE elfStyle[32];
     *     DWORD elfVersion;
     *     DWORD elfStyleSize;
     *     DWORD elfMatch;
     *     DWORD elfReserved;
     *     BYTE elfVendorId[4];
     *     DWORD elfCulture;
     *     PANOSE elfPanose;
     * } *PEXTLOGFONTA
     * }
     */
    public static final AddressLayout PEXTLOGFONTA = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEXTLOGFONTA {
     *     LOGFONTA elfLogFont;
     *     BYTE elfFullName[64];
     *     BYTE elfStyle[32];
     *     DWORD elfVersion;
     *     DWORD elfStyleSize;
     *     DWORD elfMatch;
     *     DWORD elfReserved;
     *     BYTE elfVendorId[4];
     *     DWORD elfCulture;
     *     PANOSE elfPanose;
     * } *NPEXTLOGFONTA
     * }
     */
    public static final AddressLayout NPEXTLOGFONTA = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEXTLOGFONTA {
     *     LOGFONTA elfLogFont;
     *     BYTE elfFullName[64];
     *     BYTE elfStyle[32];
     *     DWORD elfVersion;
     *     DWORD elfStyleSize;
     *     DWORD elfMatch;
     *     DWORD elfReserved;
     *     BYTE elfVendorId[4];
     *     DWORD elfCulture;
     *     PANOSE elfPanose;
     * } *LPEXTLOGFONTA
     * }
     */
    public static final AddressLayout LPEXTLOGFONTA = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEXTLOGFONTW {
     *     LOGFONTW elfLogFont;
     *     WCHAR elfFullName[64];
     *     WCHAR elfStyle[32];
     *     DWORD elfVersion;
     *     DWORD elfStyleSize;
     *     DWORD elfMatch;
     *     DWORD elfReserved;
     *     BYTE elfVendorId[4];
     *     DWORD elfCulture;
     *     PANOSE elfPanose;
     * } *PEXTLOGFONTW
     * }
     */
    public static final AddressLayout PEXTLOGFONTW = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEXTLOGFONTW {
     *     LOGFONTW elfLogFont;
     *     WCHAR elfFullName[64];
     *     WCHAR elfStyle[32];
     *     DWORD elfVersion;
     *     DWORD elfStyleSize;
     *     DWORD elfMatch;
     *     DWORD elfReserved;
     *     BYTE elfVendorId[4];
     *     DWORD elfCulture;
     *     PANOSE elfPanose;
     * } *NPEXTLOGFONTW
     * }
     */
    public static final AddressLayout NPEXTLOGFONTW = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEXTLOGFONTW {
     *     LOGFONTW elfLogFont;
     *     WCHAR elfFullName[64];
     *     WCHAR elfStyle[32];
     *     DWORD elfVersion;
     *     DWORD elfStyleSize;
     *     DWORD elfMatch;
     *     DWORD elfReserved;
     *     BYTE elfVendorId[4];
     *     DWORD elfCulture;
     *     PANOSE elfPanose;
     * } *LPEXTLOGFONTW
     * }
     */
    public static final AddressLayout LPEXTLOGFONTW = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef PEXTLOGFONTA PEXTLOGFONT
     * }
     */
    public static final AddressLayout PEXTLOGFONT = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef NPEXTLOGFONTA NPEXTLOGFONT
     * }
     */
    public static final AddressLayout NPEXTLOGFONT = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef LPEXTLOGFONTA LPEXTLOGFONT
     * }
     */
    public static final AddressLayout LPEXTLOGFONT = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _devicemodeA {
     *     BYTE dmDeviceName[32];
     *     WORD dmSpecVersion;
     *     WORD dmDriverVersion;
     *     WORD dmSize;
     *     WORD dmDriverExtra;
     *     DWORD dmFields;
     *     union {
     *         struct {
     *             short dmOrientation;
     *             short dmPaperSize;
     *             short dmPaperLength;
     *             short dmPaperWidth;
     *             short dmScale;
     *             short dmCopies;
     *             short dmDefaultSource;
     *             short dmPrintQuality;
     *         };
     *         struct {
     *             POINTL dmPosition;
     *             DWORD dmDisplayOrientation;
     *             DWORD dmDisplayFixedOutput;
     *         };
     *     };
     *     short dmColor;
     *     short dmDuplex;
     *     short dmYResolution;
     *     short dmTTOption;
     *     short dmCollate;
     *     BYTE dmFormName[32];
     *     WORD dmLogPixels;
     *     DWORD dmBitsPerPel;
     *     DWORD dmPelsWidth;
     *     DWORD dmPelsHeight;
     *     union {
     *         DWORD dmDisplayFlags;
     *         DWORD dmNup;
     *     };
     *     DWORD dmDisplayFrequency;
     *     DWORD dmICMMethod;
     *     DWORD dmICMIntent;
     *     DWORD dmMediaType;
     *     DWORD dmDitherType;
     *     DWORD dmReserved1;
     *     DWORD dmReserved2;
     *     DWORD dmPanningWidth;
     *     DWORD dmPanningHeight;
     * } *PDEVMODEA
     * }
     */
    public static final AddressLayout PDEVMODEA = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _devicemodeA {
     *     BYTE dmDeviceName[32];
     *     WORD dmSpecVersion;
     *     WORD dmDriverVersion;
     *     WORD dmSize;
     *     WORD dmDriverExtra;
     *     DWORD dmFields;
     *     union {
     *         struct {
     *             short dmOrientation;
     *             short dmPaperSize;
     *             short dmPaperLength;
     *             short dmPaperWidth;
     *             short dmScale;
     *             short dmCopies;
     *             short dmDefaultSource;
     *             short dmPrintQuality;
     *         };
     *         struct {
     *             POINTL dmPosition;
     *             DWORD dmDisplayOrientation;
     *             DWORD dmDisplayFixedOutput;
     *         };
     *     };
     *     short dmColor;
     *     short dmDuplex;
     *     short dmYResolution;
     *     short dmTTOption;
     *     short dmCollate;
     *     BYTE dmFormName[32];
     *     WORD dmLogPixels;
     *     DWORD dmBitsPerPel;
     *     DWORD dmPelsWidth;
     *     DWORD dmPelsHeight;
     *     union {
     *         DWORD dmDisplayFlags;
     *         DWORD dmNup;
     *     };
     *     DWORD dmDisplayFrequency;
     *     DWORD dmICMMethod;
     *     DWORD dmICMIntent;
     *     DWORD dmMediaType;
     *     DWORD dmDitherType;
     *     DWORD dmReserved1;
     *     DWORD dmReserved2;
     *     DWORD dmPanningWidth;
     *     DWORD dmPanningHeight;
     * } *NPDEVMODEA
     * }
     */
    public static final AddressLayout NPDEVMODEA = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _devicemodeA {
     *     BYTE dmDeviceName[32];
     *     WORD dmSpecVersion;
     *     WORD dmDriverVersion;
     *     WORD dmSize;
     *     WORD dmDriverExtra;
     *     DWORD dmFields;
     *     union {
     *         struct {
     *             short dmOrientation;
     *             short dmPaperSize;
     *             short dmPaperLength;
     *             short dmPaperWidth;
     *             short dmScale;
     *             short dmCopies;
     *             short dmDefaultSource;
     *             short dmPrintQuality;
     *         };
     *         struct {
     *             POINTL dmPosition;
     *             DWORD dmDisplayOrientation;
     *             DWORD dmDisplayFixedOutput;
     *         };
     *     };
     *     short dmColor;
     *     short dmDuplex;
     *     short dmYResolution;
     *     short dmTTOption;
     *     short dmCollate;
     *     BYTE dmFormName[32];
     *     WORD dmLogPixels;
     *     DWORD dmBitsPerPel;
     *     DWORD dmPelsWidth;
     *     DWORD dmPelsHeight;
     *     union {
     *         DWORD dmDisplayFlags;
     *         DWORD dmNup;
     *     };
     *     DWORD dmDisplayFrequency;
     *     DWORD dmICMMethod;
     *     DWORD dmICMIntent;
     *     DWORD dmMediaType;
     *     DWORD dmDitherType;
     *     DWORD dmReserved1;
     *     DWORD dmReserved2;
     *     DWORD dmPanningWidth;
     *     DWORD dmPanningHeight;
     * } *LPDEVMODEA
     * }
     */
    public static final AddressLayout LPDEVMODEA = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _devicemodeW {
     *     WCHAR dmDeviceName[32];
     *     WORD dmSpecVersion;
     *     WORD dmDriverVersion;
     *     WORD dmSize;
     *     WORD dmDriverExtra;
     *     DWORD dmFields;
     *     union {
     *         struct {
     *             short dmOrientation;
     *             short dmPaperSize;
     *             short dmPaperLength;
     *             short dmPaperWidth;
     *             short dmScale;
     *             short dmCopies;
     *             short dmDefaultSource;
     *             short dmPrintQuality;
     *         };
     *         struct {
     *             POINTL dmPosition;
     *             DWORD dmDisplayOrientation;
     *             DWORD dmDisplayFixedOutput;
     *         };
     *     };
     *     short dmColor;
     *     short dmDuplex;
     *     short dmYResolution;
     *     short dmTTOption;
     *     short dmCollate;
     *     WCHAR dmFormName[32];
     *     WORD dmLogPixels;
     *     DWORD dmBitsPerPel;
     *     DWORD dmPelsWidth;
     *     DWORD dmPelsHeight;
     *     union {
     *         DWORD dmDisplayFlags;
     *         DWORD dmNup;
     *     };
     *     DWORD dmDisplayFrequency;
     *     DWORD dmICMMethod;
     *     DWORD dmICMIntent;
     *     DWORD dmMediaType;
     *     DWORD dmDitherType;
     *     DWORD dmReserved1;
     *     DWORD dmReserved2;
     *     DWORD dmPanningWidth;
     *     DWORD dmPanningHeight;
     * } *PDEVMODEW
     * }
     */
    public static final AddressLayout PDEVMODEW = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _devicemodeW {
     *     WCHAR dmDeviceName[32];
     *     WORD dmSpecVersion;
     *     WORD dmDriverVersion;
     *     WORD dmSize;
     *     WORD dmDriverExtra;
     *     DWORD dmFields;
     *     union {
     *         struct {
     *             short dmOrientation;
     *             short dmPaperSize;
     *             short dmPaperLength;
     *             short dmPaperWidth;
     *             short dmScale;
     *             short dmCopies;
     *             short dmDefaultSource;
     *             short dmPrintQuality;
     *         };
     *         struct {
     *             POINTL dmPosition;
     *             DWORD dmDisplayOrientation;
     *             DWORD dmDisplayFixedOutput;
     *         };
     *     };
     *     short dmColor;
     *     short dmDuplex;
     *     short dmYResolution;
     *     short dmTTOption;
     *     short dmCollate;
     *     WCHAR dmFormName[32];
     *     WORD dmLogPixels;
     *     DWORD dmBitsPerPel;
     *     DWORD dmPelsWidth;
     *     DWORD dmPelsHeight;
     *     union {
     *         DWORD dmDisplayFlags;
     *         DWORD dmNup;
     *     };
     *     DWORD dmDisplayFrequency;
     *     DWORD dmICMMethod;
     *     DWORD dmICMIntent;
     *     DWORD dmMediaType;
     *     DWORD dmDitherType;
     *     DWORD dmReserved1;
     *     DWORD dmReserved2;
     *     DWORD dmPanningWidth;
     *     DWORD dmPanningHeight;
     * } *NPDEVMODEW
     * }
     */
    public static final AddressLayout NPDEVMODEW = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _devicemodeW {
     *     WCHAR dmDeviceName[32];
     *     WORD dmSpecVersion;
     *     WORD dmDriverVersion;
     *     WORD dmSize;
     *     WORD dmDriverExtra;
     *     DWORD dmFields;
     *     union {
     *         struct {
     *             short dmOrientation;
     *             short dmPaperSize;
     *             short dmPaperLength;
     *             short dmPaperWidth;
     *             short dmScale;
     *             short dmCopies;
     *             short dmDefaultSource;
     *             short dmPrintQuality;
     *         };
     *         struct {
     *             POINTL dmPosition;
     *             DWORD dmDisplayOrientation;
     *             DWORD dmDisplayFixedOutput;
     *         };
     *     };
     *     short dmColor;
     *     short dmDuplex;
     *     short dmYResolution;
     *     short dmTTOption;
     *     short dmCollate;
     *     WCHAR dmFormName[32];
     *     WORD dmLogPixels;
     *     DWORD dmBitsPerPel;
     *     DWORD dmPelsWidth;
     *     DWORD dmPelsHeight;
     *     union {
     *         DWORD dmDisplayFlags;
     *         DWORD dmNup;
     *     };
     *     DWORD dmDisplayFrequency;
     *     DWORD dmICMMethod;
     *     DWORD dmICMIntent;
     *     DWORD dmMediaType;
     *     DWORD dmDitherType;
     *     DWORD dmReserved1;
     *     DWORD dmReserved2;
     *     DWORD dmPanningWidth;
     *     DWORD dmPanningHeight;
     * } *LPDEVMODEW
     * }
     */
    public static final AddressLayout LPDEVMODEW = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef PDEVMODEA PDEVMODE
     * }
     */
    public static final AddressLayout PDEVMODE = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef NPDEVMODEA NPDEVMODE
     * }
     */
    public static final AddressLayout NPDEVMODE = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef LPDEVMODEA LPDEVMODE
     * }
     */
    public static final AddressLayout LPDEVMODE = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _DISPLAY_DEVICEA {
     *     DWORD cb;
     *     CHAR DeviceName[32];
     *     CHAR DeviceString[128];
     *     DWORD StateFlags;
     *     CHAR DeviceID[128];
     *     CHAR DeviceKey[128];
     * } *PDISPLAY_DEVICEA
     * }
     */
    public static final AddressLayout PDISPLAY_DEVICEA = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _DISPLAY_DEVICEA {
     *     DWORD cb;
     *     CHAR DeviceName[32];
     *     CHAR DeviceString[128];
     *     DWORD StateFlags;
     *     CHAR DeviceID[128];
     *     CHAR DeviceKey[128];
     * } *LPDISPLAY_DEVICEA
     * }
     */
    public static final AddressLayout LPDISPLAY_DEVICEA = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _DISPLAY_DEVICEW {
     *     DWORD cb;
     *     WCHAR DeviceName[32];
     *     WCHAR DeviceString[128];
     *     DWORD StateFlags;
     *     WCHAR DeviceID[128];
     *     WCHAR DeviceKey[128];
     * } *PDISPLAY_DEVICEW
     * }
     */
    public static final AddressLayout PDISPLAY_DEVICEW = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _DISPLAY_DEVICEW {
     *     DWORD cb;
     *     WCHAR DeviceName[32];
     *     WCHAR DeviceString[128];
     *     DWORD StateFlags;
     *     WCHAR DeviceID[128];
     *     WCHAR DeviceKey[128];
     * } *LPDISPLAY_DEVICEW
     * }
     */
    public static final AddressLayout LPDISPLAY_DEVICEW = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef PDISPLAY_DEVICEA PDISPLAY_DEVICE
     * }
     */
    public static final AddressLayout PDISPLAY_DEVICE = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef LPDISPLAY_DEVICEA LPDISPLAY_DEVICE
     * }
     */
    public static final AddressLayout LPDISPLAY_DEVICE = C_POINTER;
    private static final int DISPLAYCONFIG_OUTPUT_TECHNOLOGY_OTHER = (int)-1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.DISPLAYCONFIG_OUTPUT_TECHNOLOGY_OTHER = -1
     * }
     */
    public static int DISPLAYCONFIG_OUTPUT_TECHNOLOGY_OTHER() {
        return DISPLAYCONFIG_OUTPUT_TECHNOLOGY_OTHER;
    }
    private static final int DISPLAYCONFIG_OUTPUT_TECHNOLOGY_HD15 = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.DISPLAYCONFIG_OUTPUT_TECHNOLOGY_HD15 = 0
     * }
     */
    public static int DISPLAYCONFIG_OUTPUT_TECHNOLOGY_HD15() {
        return DISPLAYCONFIG_OUTPUT_TECHNOLOGY_HD15;
    }
    private static final int DISPLAYCONFIG_OUTPUT_TECHNOLOGY_SVIDEO = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.DISPLAYCONFIG_OUTPUT_TECHNOLOGY_SVIDEO = 1
     * }
     */
    public static int DISPLAYCONFIG_OUTPUT_TECHNOLOGY_SVIDEO() {
        return DISPLAYCONFIG_OUTPUT_TECHNOLOGY_SVIDEO;
    }
    private static final int DISPLAYCONFIG_OUTPUT_TECHNOLOGY_COMPOSITE_VIDEO = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.DISPLAYCONFIG_OUTPUT_TECHNOLOGY_COMPOSITE_VIDEO = 2
     * }
     */
    public static int DISPLAYCONFIG_OUTPUT_TECHNOLOGY_COMPOSITE_VIDEO() {
        return DISPLAYCONFIG_OUTPUT_TECHNOLOGY_COMPOSITE_VIDEO;
    }
    private static final int DISPLAYCONFIG_OUTPUT_TECHNOLOGY_COMPONENT_VIDEO = (int)3L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.DISPLAYCONFIG_OUTPUT_TECHNOLOGY_COMPONENT_VIDEO = 3
     * }
     */
    public static int DISPLAYCONFIG_OUTPUT_TECHNOLOGY_COMPONENT_VIDEO() {
        return DISPLAYCONFIG_OUTPUT_TECHNOLOGY_COMPONENT_VIDEO;
    }
    private static final int DISPLAYCONFIG_OUTPUT_TECHNOLOGY_DVI = (int)4L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.DISPLAYCONFIG_OUTPUT_TECHNOLOGY_DVI = 4
     * }
     */
    public static int DISPLAYCONFIG_OUTPUT_TECHNOLOGY_DVI() {
        return DISPLAYCONFIG_OUTPUT_TECHNOLOGY_DVI;
    }
    private static final int DISPLAYCONFIG_OUTPUT_TECHNOLOGY_HDMI = (int)5L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.DISPLAYCONFIG_OUTPUT_TECHNOLOGY_HDMI = 5
     * }
     */
    public static int DISPLAYCONFIG_OUTPUT_TECHNOLOGY_HDMI() {
        return DISPLAYCONFIG_OUTPUT_TECHNOLOGY_HDMI;
    }
    private static final int DISPLAYCONFIG_OUTPUT_TECHNOLOGY_LVDS = (int)6L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.DISPLAYCONFIG_OUTPUT_TECHNOLOGY_LVDS = 6
     * }
     */
    public static int DISPLAYCONFIG_OUTPUT_TECHNOLOGY_LVDS() {
        return DISPLAYCONFIG_OUTPUT_TECHNOLOGY_LVDS;
    }
    private static final int DISPLAYCONFIG_OUTPUT_TECHNOLOGY_D_JPN = (int)8L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.DISPLAYCONFIG_OUTPUT_TECHNOLOGY_D_JPN = 8
     * }
     */
    public static int DISPLAYCONFIG_OUTPUT_TECHNOLOGY_D_JPN() {
        return DISPLAYCONFIG_OUTPUT_TECHNOLOGY_D_JPN;
    }
    private static final int DISPLAYCONFIG_OUTPUT_TECHNOLOGY_SDI = (int)9L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.DISPLAYCONFIG_OUTPUT_TECHNOLOGY_SDI = 9
     * }
     */
    public static int DISPLAYCONFIG_OUTPUT_TECHNOLOGY_SDI() {
        return DISPLAYCONFIG_OUTPUT_TECHNOLOGY_SDI;
    }
    private static final int DISPLAYCONFIG_OUTPUT_TECHNOLOGY_DISPLAYPORT_EXTERNAL = (int)10L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.DISPLAYCONFIG_OUTPUT_TECHNOLOGY_DISPLAYPORT_EXTERNAL = 10
     * }
     */
    public static int DISPLAYCONFIG_OUTPUT_TECHNOLOGY_DISPLAYPORT_EXTERNAL() {
        return DISPLAYCONFIG_OUTPUT_TECHNOLOGY_DISPLAYPORT_EXTERNAL;
    }
    private static final int DISPLAYCONFIG_OUTPUT_TECHNOLOGY_DISPLAYPORT_EMBEDDED = (int)11L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.DISPLAYCONFIG_OUTPUT_TECHNOLOGY_DISPLAYPORT_EMBEDDED = 11
     * }
     */
    public static int DISPLAYCONFIG_OUTPUT_TECHNOLOGY_DISPLAYPORT_EMBEDDED() {
        return DISPLAYCONFIG_OUTPUT_TECHNOLOGY_DISPLAYPORT_EMBEDDED;
    }
    private static final int DISPLAYCONFIG_OUTPUT_TECHNOLOGY_UDI_EXTERNAL = (int)12L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.DISPLAYCONFIG_OUTPUT_TECHNOLOGY_UDI_EXTERNAL = 12
     * }
     */
    public static int DISPLAYCONFIG_OUTPUT_TECHNOLOGY_UDI_EXTERNAL() {
        return DISPLAYCONFIG_OUTPUT_TECHNOLOGY_UDI_EXTERNAL;
    }
    private static final int DISPLAYCONFIG_OUTPUT_TECHNOLOGY_UDI_EMBEDDED = (int)13L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.DISPLAYCONFIG_OUTPUT_TECHNOLOGY_UDI_EMBEDDED = 13
     * }
     */
    public static int DISPLAYCONFIG_OUTPUT_TECHNOLOGY_UDI_EMBEDDED() {
        return DISPLAYCONFIG_OUTPUT_TECHNOLOGY_UDI_EMBEDDED;
    }
    private static final int DISPLAYCONFIG_OUTPUT_TECHNOLOGY_SDTVDONGLE = (int)14L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.DISPLAYCONFIG_OUTPUT_TECHNOLOGY_SDTVDONGLE = 14
     * }
     */
    public static int DISPLAYCONFIG_OUTPUT_TECHNOLOGY_SDTVDONGLE() {
        return DISPLAYCONFIG_OUTPUT_TECHNOLOGY_SDTVDONGLE;
    }
    private static final int DISPLAYCONFIG_OUTPUT_TECHNOLOGY_MIRACAST = (int)15L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.DISPLAYCONFIG_OUTPUT_TECHNOLOGY_MIRACAST = 15
     * }
     */
    public static int DISPLAYCONFIG_OUTPUT_TECHNOLOGY_MIRACAST() {
        return DISPLAYCONFIG_OUTPUT_TECHNOLOGY_MIRACAST;
    }
    private static final int DISPLAYCONFIG_OUTPUT_TECHNOLOGY_INDIRECT_WIRED = (int)16L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.DISPLAYCONFIG_OUTPUT_TECHNOLOGY_INDIRECT_WIRED = 16
     * }
     */
    public static int DISPLAYCONFIG_OUTPUT_TECHNOLOGY_INDIRECT_WIRED() {
        return DISPLAYCONFIG_OUTPUT_TECHNOLOGY_INDIRECT_WIRED;
    }
    private static final int DISPLAYCONFIG_OUTPUT_TECHNOLOGY_INDIRECT_VIRTUAL = (int)17L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.DISPLAYCONFIG_OUTPUT_TECHNOLOGY_INDIRECT_VIRTUAL = 17
     * }
     */
    public static int DISPLAYCONFIG_OUTPUT_TECHNOLOGY_INDIRECT_VIRTUAL() {
        return DISPLAYCONFIG_OUTPUT_TECHNOLOGY_INDIRECT_VIRTUAL;
    }
    private static final int DISPLAYCONFIG_OUTPUT_TECHNOLOGY_DISPLAYPORT_USB_TUNNEL = (int)18L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.DISPLAYCONFIG_OUTPUT_TECHNOLOGY_DISPLAYPORT_USB_TUNNEL = 18
     * }
     */
    public static int DISPLAYCONFIG_OUTPUT_TECHNOLOGY_DISPLAYPORT_USB_TUNNEL() {
        return DISPLAYCONFIG_OUTPUT_TECHNOLOGY_DISPLAYPORT_USB_TUNNEL;
    }
    private static final int DISPLAYCONFIG_OUTPUT_TECHNOLOGY_INTERNAL = (int)-2147483648L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.DISPLAYCONFIG_OUTPUT_TECHNOLOGY_INTERNAL = -2147483648
     * }
     */
    public static int DISPLAYCONFIG_OUTPUT_TECHNOLOGY_INTERNAL() {
        return DISPLAYCONFIG_OUTPUT_TECHNOLOGY_INTERNAL;
    }
    private static final int DISPLAYCONFIG_OUTPUT_TECHNOLOGY_FORCE_UINT32 = (int)-1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.DISPLAYCONFIG_OUTPUT_TECHNOLOGY_FORCE_UINT32 = -1
     * }
     */
    public static int DISPLAYCONFIG_OUTPUT_TECHNOLOGY_FORCE_UINT32() {
        return DISPLAYCONFIG_OUTPUT_TECHNOLOGY_FORCE_UINT32;
    }
    private static final int DISPLAYCONFIG_SCANLINE_ORDERING_UNSPECIFIED = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.DISPLAYCONFIG_SCANLINE_ORDERING_UNSPECIFIED = 0
     * }
     */
    public static int DISPLAYCONFIG_SCANLINE_ORDERING_UNSPECIFIED() {
        return DISPLAYCONFIG_SCANLINE_ORDERING_UNSPECIFIED;
    }
    private static final int DISPLAYCONFIG_SCANLINE_ORDERING_PROGRESSIVE = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.DISPLAYCONFIG_SCANLINE_ORDERING_PROGRESSIVE = 1
     * }
     */
    public static int DISPLAYCONFIG_SCANLINE_ORDERING_PROGRESSIVE() {
        return DISPLAYCONFIG_SCANLINE_ORDERING_PROGRESSIVE;
    }
    private static final int DISPLAYCONFIG_SCANLINE_ORDERING_INTERLACED = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.DISPLAYCONFIG_SCANLINE_ORDERING_INTERLACED = 2
     * }
     */
    public static int DISPLAYCONFIG_SCANLINE_ORDERING_INTERLACED() {
        return DISPLAYCONFIG_SCANLINE_ORDERING_INTERLACED;
    }
    private static final int DISPLAYCONFIG_SCANLINE_ORDERING_INTERLACED_UPPERFIELDFIRST = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.DISPLAYCONFIG_SCANLINE_ORDERING_INTERLACED_UPPERFIELDFIRST = 2
     * }
     */
    public static int DISPLAYCONFIG_SCANLINE_ORDERING_INTERLACED_UPPERFIELDFIRST() {
        return DISPLAYCONFIG_SCANLINE_ORDERING_INTERLACED_UPPERFIELDFIRST;
    }
    private static final int DISPLAYCONFIG_SCANLINE_ORDERING_INTERLACED_LOWERFIELDFIRST = (int)3L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.DISPLAYCONFIG_SCANLINE_ORDERING_INTERLACED_LOWERFIELDFIRST = 3
     * }
     */
    public static int DISPLAYCONFIG_SCANLINE_ORDERING_INTERLACED_LOWERFIELDFIRST() {
        return DISPLAYCONFIG_SCANLINE_ORDERING_INTERLACED_LOWERFIELDFIRST;
    }
    private static final int DISPLAYCONFIG_SCANLINE_ORDERING_FORCE_UINT32 = (int)-1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.DISPLAYCONFIG_SCANLINE_ORDERING_FORCE_UINT32 = -1
     * }
     */
    public static int DISPLAYCONFIG_SCANLINE_ORDERING_FORCE_UINT32() {
        return DISPLAYCONFIG_SCANLINE_ORDERING_FORCE_UINT32;
    }
    private static final int DISPLAYCONFIG_SCALING_IDENTITY = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.DISPLAYCONFIG_SCALING_IDENTITY = 1
     * }
     */
    public static int DISPLAYCONFIG_SCALING_IDENTITY() {
        return DISPLAYCONFIG_SCALING_IDENTITY;
    }
    private static final int DISPLAYCONFIG_SCALING_CENTERED = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.DISPLAYCONFIG_SCALING_CENTERED = 2
     * }
     */
    public static int DISPLAYCONFIG_SCALING_CENTERED() {
        return DISPLAYCONFIG_SCALING_CENTERED;
    }
    private static final int DISPLAYCONFIG_SCALING_STRETCHED = (int)3L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.DISPLAYCONFIG_SCALING_STRETCHED = 3
     * }
     */
    public static int DISPLAYCONFIG_SCALING_STRETCHED() {
        return DISPLAYCONFIG_SCALING_STRETCHED;
    }
    private static final int DISPLAYCONFIG_SCALING_ASPECTRATIOCENTEREDMAX = (int)4L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.DISPLAYCONFIG_SCALING_ASPECTRATIOCENTEREDMAX = 4
     * }
     */
    public static int DISPLAYCONFIG_SCALING_ASPECTRATIOCENTEREDMAX() {
        return DISPLAYCONFIG_SCALING_ASPECTRATIOCENTEREDMAX;
    }
    private static final int DISPLAYCONFIG_SCALING_CUSTOM = (int)5L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.DISPLAYCONFIG_SCALING_CUSTOM = 5
     * }
     */
    public static int DISPLAYCONFIG_SCALING_CUSTOM() {
        return DISPLAYCONFIG_SCALING_CUSTOM;
    }
    private static final int DISPLAYCONFIG_SCALING_PREFERRED = (int)128L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.DISPLAYCONFIG_SCALING_PREFERRED = 128
     * }
     */
    public static int DISPLAYCONFIG_SCALING_PREFERRED() {
        return DISPLAYCONFIG_SCALING_PREFERRED;
    }
    private static final int DISPLAYCONFIG_SCALING_FORCE_UINT32 = (int)-1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.DISPLAYCONFIG_SCALING_FORCE_UINT32 = -1
     * }
     */
    public static int DISPLAYCONFIG_SCALING_FORCE_UINT32() {
        return DISPLAYCONFIG_SCALING_FORCE_UINT32;
    }
    private static final int DISPLAYCONFIG_ROTATION_IDENTITY = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.DISPLAYCONFIG_ROTATION_IDENTITY = 1
     * }
     */
    public static int DISPLAYCONFIG_ROTATION_IDENTITY() {
        return DISPLAYCONFIG_ROTATION_IDENTITY;
    }
    private static final int DISPLAYCONFIG_ROTATION_ROTATE90 = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.DISPLAYCONFIG_ROTATION_ROTATE90 = 2
     * }
     */
    public static int DISPLAYCONFIG_ROTATION_ROTATE90() {
        return DISPLAYCONFIG_ROTATION_ROTATE90;
    }
    private static final int DISPLAYCONFIG_ROTATION_ROTATE180 = (int)3L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.DISPLAYCONFIG_ROTATION_ROTATE180 = 3
     * }
     */
    public static int DISPLAYCONFIG_ROTATION_ROTATE180() {
        return DISPLAYCONFIG_ROTATION_ROTATE180;
    }
    private static final int DISPLAYCONFIG_ROTATION_ROTATE270 = (int)4L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.DISPLAYCONFIG_ROTATION_ROTATE270 = 4
     * }
     */
    public static int DISPLAYCONFIG_ROTATION_ROTATE270() {
        return DISPLAYCONFIG_ROTATION_ROTATE270;
    }
    private static final int DISPLAYCONFIG_ROTATION_FORCE_UINT32 = (int)-1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.DISPLAYCONFIG_ROTATION_FORCE_UINT32 = -1
     * }
     */
    public static int DISPLAYCONFIG_ROTATION_FORCE_UINT32() {
        return DISPLAYCONFIG_ROTATION_FORCE_UINT32;
    }
    private static final int DISPLAYCONFIG_MODE_INFO_TYPE_SOURCE = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.DISPLAYCONFIG_MODE_INFO_TYPE_SOURCE = 1
     * }
     */
    public static int DISPLAYCONFIG_MODE_INFO_TYPE_SOURCE() {
        return DISPLAYCONFIG_MODE_INFO_TYPE_SOURCE;
    }
    private static final int DISPLAYCONFIG_MODE_INFO_TYPE_TARGET = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.DISPLAYCONFIG_MODE_INFO_TYPE_TARGET = 2
     * }
     */
    public static int DISPLAYCONFIG_MODE_INFO_TYPE_TARGET() {
        return DISPLAYCONFIG_MODE_INFO_TYPE_TARGET;
    }
    private static final int DISPLAYCONFIG_MODE_INFO_TYPE_DESKTOP_IMAGE = (int)3L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.DISPLAYCONFIG_MODE_INFO_TYPE_DESKTOP_IMAGE = 3
     * }
     */
    public static int DISPLAYCONFIG_MODE_INFO_TYPE_DESKTOP_IMAGE() {
        return DISPLAYCONFIG_MODE_INFO_TYPE_DESKTOP_IMAGE;
    }
    private static final int DISPLAYCONFIG_MODE_INFO_TYPE_FORCE_UINT32 = (int)-1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.DISPLAYCONFIG_MODE_INFO_TYPE_FORCE_UINT32 = -1
     * }
     */
    public static int DISPLAYCONFIG_MODE_INFO_TYPE_FORCE_UINT32() {
        return DISPLAYCONFIG_MODE_INFO_TYPE_FORCE_UINT32;
    }
    private static final int DISPLAYCONFIG_PIXELFORMAT_8BPP = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.DISPLAYCONFIG_PIXELFORMAT_8BPP = 1
     * }
     */
    public static int DISPLAYCONFIG_PIXELFORMAT_8BPP() {
        return DISPLAYCONFIG_PIXELFORMAT_8BPP;
    }
    private static final int DISPLAYCONFIG_PIXELFORMAT_16BPP = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.DISPLAYCONFIG_PIXELFORMAT_16BPP = 2
     * }
     */
    public static int DISPLAYCONFIG_PIXELFORMAT_16BPP() {
        return DISPLAYCONFIG_PIXELFORMAT_16BPP;
    }
    private static final int DISPLAYCONFIG_PIXELFORMAT_24BPP = (int)3L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.DISPLAYCONFIG_PIXELFORMAT_24BPP = 3
     * }
     */
    public static int DISPLAYCONFIG_PIXELFORMAT_24BPP() {
        return DISPLAYCONFIG_PIXELFORMAT_24BPP;
    }
    private static final int DISPLAYCONFIG_PIXELFORMAT_32BPP = (int)4L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.DISPLAYCONFIG_PIXELFORMAT_32BPP = 4
     * }
     */
    public static int DISPLAYCONFIG_PIXELFORMAT_32BPP() {
        return DISPLAYCONFIG_PIXELFORMAT_32BPP;
    }
    private static final int DISPLAYCONFIG_PIXELFORMAT_NONGDI = (int)5L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.DISPLAYCONFIG_PIXELFORMAT_NONGDI = 5
     * }
     */
    public static int DISPLAYCONFIG_PIXELFORMAT_NONGDI() {
        return DISPLAYCONFIG_PIXELFORMAT_NONGDI;
    }
    private static final int DISPLAYCONFIG_PIXELFORMAT_FORCE_UINT32 = (int)-1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.DISPLAYCONFIG_PIXELFORMAT_FORCE_UINT32 = -1
     * }
     */
    public static int DISPLAYCONFIG_PIXELFORMAT_FORCE_UINT32() {
        return DISPLAYCONFIG_PIXELFORMAT_FORCE_UINT32;
    }
    private static final int DISPLAYCONFIG_TOPOLOGY_INTERNAL = (int)1L;
    /**
     * {@snippet lang=c :
     * enum DISPLAYCONFIG_TOPOLOGY_ID.DISPLAYCONFIG_TOPOLOGY_INTERNAL = 1
     * }
     */
    public static int DISPLAYCONFIG_TOPOLOGY_INTERNAL() {
        return DISPLAYCONFIG_TOPOLOGY_INTERNAL;
    }
    private static final int DISPLAYCONFIG_TOPOLOGY_CLONE = (int)2L;
    /**
     * {@snippet lang=c :
     * enum DISPLAYCONFIG_TOPOLOGY_ID.DISPLAYCONFIG_TOPOLOGY_CLONE = 2
     * }
     */
    public static int DISPLAYCONFIG_TOPOLOGY_CLONE() {
        return DISPLAYCONFIG_TOPOLOGY_CLONE;
    }
    private static final int DISPLAYCONFIG_TOPOLOGY_EXTEND = (int)4L;
    /**
     * {@snippet lang=c :
     * enum DISPLAYCONFIG_TOPOLOGY_ID.DISPLAYCONFIG_TOPOLOGY_EXTEND = 4
     * }
     */
    public static int DISPLAYCONFIG_TOPOLOGY_EXTEND() {
        return DISPLAYCONFIG_TOPOLOGY_EXTEND;
    }
    private static final int DISPLAYCONFIG_TOPOLOGY_EXTERNAL = (int)8L;
    /**
     * {@snippet lang=c :
     * enum DISPLAYCONFIG_TOPOLOGY_ID.DISPLAYCONFIG_TOPOLOGY_EXTERNAL = 8
     * }
     */
    public static int DISPLAYCONFIG_TOPOLOGY_EXTERNAL() {
        return DISPLAYCONFIG_TOPOLOGY_EXTERNAL;
    }
    private static final int DISPLAYCONFIG_TOPOLOGY_FORCE_UINT32 = (int)-1L;
    /**
     * {@snippet lang=c :
     * enum DISPLAYCONFIG_TOPOLOGY_ID.DISPLAYCONFIG_TOPOLOGY_FORCE_UINT32 = -1
     * }
     */
    public static int DISPLAYCONFIG_TOPOLOGY_FORCE_UINT32() {
        return DISPLAYCONFIG_TOPOLOGY_FORCE_UINT32;
    }
    private static final int DISPLAYCONFIG_DEVICE_INFO_GET_SOURCE_NAME = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.DISPLAYCONFIG_DEVICE_INFO_GET_SOURCE_NAME = 1
     * }
     */
    public static int DISPLAYCONFIG_DEVICE_INFO_GET_SOURCE_NAME() {
        return DISPLAYCONFIG_DEVICE_INFO_GET_SOURCE_NAME;
    }
    private static final int DISPLAYCONFIG_DEVICE_INFO_GET_TARGET_NAME = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.DISPLAYCONFIG_DEVICE_INFO_GET_TARGET_NAME = 2
     * }
     */
    public static int DISPLAYCONFIG_DEVICE_INFO_GET_TARGET_NAME() {
        return DISPLAYCONFIG_DEVICE_INFO_GET_TARGET_NAME;
    }
    private static final int DISPLAYCONFIG_DEVICE_INFO_GET_TARGET_PREFERRED_MODE = (int)3L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.DISPLAYCONFIG_DEVICE_INFO_GET_TARGET_PREFERRED_MODE = 3
     * }
     */
    public static int DISPLAYCONFIG_DEVICE_INFO_GET_TARGET_PREFERRED_MODE() {
        return DISPLAYCONFIG_DEVICE_INFO_GET_TARGET_PREFERRED_MODE;
    }
    private static final int DISPLAYCONFIG_DEVICE_INFO_GET_ADAPTER_NAME = (int)4L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.DISPLAYCONFIG_DEVICE_INFO_GET_ADAPTER_NAME = 4
     * }
     */
    public static int DISPLAYCONFIG_DEVICE_INFO_GET_ADAPTER_NAME() {
        return DISPLAYCONFIG_DEVICE_INFO_GET_ADAPTER_NAME;
    }
    private static final int DISPLAYCONFIG_DEVICE_INFO_SET_TARGET_PERSISTENCE = (int)5L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.DISPLAYCONFIG_DEVICE_INFO_SET_TARGET_PERSISTENCE = 5
     * }
     */
    public static int DISPLAYCONFIG_DEVICE_INFO_SET_TARGET_PERSISTENCE() {
        return DISPLAYCONFIG_DEVICE_INFO_SET_TARGET_PERSISTENCE;
    }
    private static final int DISPLAYCONFIG_DEVICE_INFO_GET_TARGET_BASE_TYPE = (int)6L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.DISPLAYCONFIG_DEVICE_INFO_GET_TARGET_BASE_TYPE = 6
     * }
     */
    public static int DISPLAYCONFIG_DEVICE_INFO_GET_TARGET_BASE_TYPE() {
        return DISPLAYCONFIG_DEVICE_INFO_GET_TARGET_BASE_TYPE;
    }
    private static final int DISPLAYCONFIG_DEVICE_INFO_GET_SUPPORT_VIRTUAL_RESOLUTION = (int)7L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.DISPLAYCONFIG_DEVICE_INFO_GET_SUPPORT_VIRTUAL_RESOLUTION = 7
     * }
     */
    public static int DISPLAYCONFIG_DEVICE_INFO_GET_SUPPORT_VIRTUAL_RESOLUTION() {
        return DISPLAYCONFIG_DEVICE_INFO_GET_SUPPORT_VIRTUAL_RESOLUTION;
    }
    private static final int DISPLAYCONFIG_DEVICE_INFO_SET_SUPPORT_VIRTUAL_RESOLUTION = (int)8L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.DISPLAYCONFIG_DEVICE_INFO_SET_SUPPORT_VIRTUAL_RESOLUTION = 8
     * }
     */
    public static int DISPLAYCONFIG_DEVICE_INFO_SET_SUPPORT_VIRTUAL_RESOLUTION() {
        return DISPLAYCONFIG_DEVICE_INFO_SET_SUPPORT_VIRTUAL_RESOLUTION;
    }
    private static final int DISPLAYCONFIG_DEVICE_INFO_GET_ADVANCED_COLOR_INFO = (int)9L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.DISPLAYCONFIG_DEVICE_INFO_GET_ADVANCED_COLOR_INFO = 9
     * }
     */
    public static int DISPLAYCONFIG_DEVICE_INFO_GET_ADVANCED_COLOR_INFO() {
        return DISPLAYCONFIG_DEVICE_INFO_GET_ADVANCED_COLOR_INFO;
    }
    private static final int DISPLAYCONFIG_DEVICE_INFO_SET_ADVANCED_COLOR_STATE = (int)10L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.DISPLAYCONFIG_DEVICE_INFO_SET_ADVANCED_COLOR_STATE = 10
     * }
     */
    public static int DISPLAYCONFIG_DEVICE_INFO_SET_ADVANCED_COLOR_STATE() {
        return DISPLAYCONFIG_DEVICE_INFO_SET_ADVANCED_COLOR_STATE;
    }
    private static final int DISPLAYCONFIG_DEVICE_INFO_GET_SDR_WHITE_LEVEL = (int)11L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.DISPLAYCONFIG_DEVICE_INFO_GET_SDR_WHITE_LEVEL = 11
     * }
     */
    public static int DISPLAYCONFIG_DEVICE_INFO_GET_SDR_WHITE_LEVEL() {
        return DISPLAYCONFIG_DEVICE_INFO_GET_SDR_WHITE_LEVEL;
    }
    private static final int DISPLAYCONFIG_DEVICE_INFO_GET_MONITOR_SPECIALIZATION = (int)12L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.DISPLAYCONFIG_DEVICE_INFO_GET_MONITOR_SPECIALIZATION = 12
     * }
     */
    public static int DISPLAYCONFIG_DEVICE_INFO_GET_MONITOR_SPECIALIZATION() {
        return DISPLAYCONFIG_DEVICE_INFO_GET_MONITOR_SPECIALIZATION;
    }
    private static final int DISPLAYCONFIG_DEVICE_INFO_SET_MONITOR_SPECIALIZATION = (int)13L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.DISPLAYCONFIG_DEVICE_INFO_SET_MONITOR_SPECIALIZATION = 13
     * }
     */
    public static int DISPLAYCONFIG_DEVICE_INFO_SET_MONITOR_SPECIALIZATION() {
        return DISPLAYCONFIG_DEVICE_INFO_SET_MONITOR_SPECIALIZATION;
    }
    private static final int DISPLAYCONFIG_DEVICE_INFO_FORCE_UINT32 = (int)-1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.DISPLAYCONFIG_DEVICE_INFO_FORCE_UINT32 = -1
     * }
     */
    public static int DISPLAYCONFIG_DEVICE_INFO_FORCE_UINT32() {
        return DISPLAYCONFIG_DEVICE_INFO_FORCE_UINT32;
    }
    private static final int DISPLAYCONFIG_COLOR_ENCODING_RGB = (int)0L;
    /**
     * {@snippet lang=c :
     * enum _DISPLAYCONFIG_COLOR_ENCODING.DISPLAYCONFIG_COLOR_ENCODING_RGB = 0
     * }
     */
    public static int DISPLAYCONFIG_COLOR_ENCODING_RGB() {
        return DISPLAYCONFIG_COLOR_ENCODING_RGB;
    }
    private static final int DISPLAYCONFIG_COLOR_ENCODING_YCBCR444 = (int)1L;
    /**
     * {@snippet lang=c :
     * enum _DISPLAYCONFIG_COLOR_ENCODING.DISPLAYCONFIG_COLOR_ENCODING_YCBCR444 = 1
     * }
     */
    public static int DISPLAYCONFIG_COLOR_ENCODING_YCBCR444() {
        return DISPLAYCONFIG_COLOR_ENCODING_YCBCR444;
    }
    private static final int DISPLAYCONFIG_COLOR_ENCODING_YCBCR422 = (int)2L;
    /**
     * {@snippet lang=c :
     * enum _DISPLAYCONFIG_COLOR_ENCODING.DISPLAYCONFIG_COLOR_ENCODING_YCBCR422 = 2
     * }
     */
    public static int DISPLAYCONFIG_COLOR_ENCODING_YCBCR422() {
        return DISPLAYCONFIG_COLOR_ENCODING_YCBCR422;
    }
    private static final int DISPLAYCONFIG_COLOR_ENCODING_YCBCR420 = (int)3L;
    /**
     * {@snippet lang=c :
     * enum _DISPLAYCONFIG_COLOR_ENCODING.DISPLAYCONFIG_COLOR_ENCODING_YCBCR420 = 3
     * }
     */
    public static int DISPLAYCONFIG_COLOR_ENCODING_YCBCR420() {
        return DISPLAYCONFIG_COLOR_ENCODING_YCBCR420;
    }
}

