// Generated by jextract

package com.github.teruteru128.foreign.windows;

import java.lang.invoke.*;
import java.lang.foreign.*;
import java.nio.ByteOrder;
import java.util.*;
import java.util.function.*;
import java.util.stream.*;

import static java.lang.foreign.ValueLayout.*;
import static java.lang.foreign.MemoryLayout.PathElement.*;

public class Windows_h_22 extends Windows_h_23 {

    Windows_h_22() {
        // Should not be called directly
    }

    private static class GetPointerTouchInfoHistory {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_INT,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetPointerTouchInfoHistory"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetPointerTouchInfoHistory(UINT32 pointerId, UINT32 *entriesCount, POINTER_TOUCH_INFO *touchInfo)
     * }
     */
    public static FunctionDescriptor GetPointerTouchInfoHistory$descriptor() {
        return GetPointerTouchInfoHistory.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetPointerTouchInfoHistory(UINT32 pointerId, UINT32 *entriesCount, POINTER_TOUCH_INFO *touchInfo)
     * }
     */
    public static MethodHandle GetPointerTouchInfoHistory$handle() {
        return GetPointerTouchInfoHistory.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL GetPointerTouchInfoHistory(UINT32 pointerId, UINT32 *entriesCount, POINTER_TOUCH_INFO *touchInfo)
     * }
     */
    public static int GetPointerTouchInfoHistory(int pointerId, MemorySegment entriesCount, MemorySegment touchInfo) {
        var mh$ = GetPointerTouchInfoHistory.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetPointerTouchInfoHistory", pointerId, entriesCount, touchInfo);
            }
            return (int)mh$.invokeExact(pointerId, entriesCount, touchInfo);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetPointerFrameTouchInfo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_INT,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetPointerFrameTouchInfo"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetPointerFrameTouchInfo(UINT32 pointerId, UINT32 *pointerCount, POINTER_TOUCH_INFO *touchInfo)
     * }
     */
    public static FunctionDescriptor GetPointerFrameTouchInfo$descriptor() {
        return GetPointerFrameTouchInfo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetPointerFrameTouchInfo(UINT32 pointerId, UINT32 *pointerCount, POINTER_TOUCH_INFO *touchInfo)
     * }
     */
    public static MethodHandle GetPointerFrameTouchInfo$handle() {
        return GetPointerFrameTouchInfo.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL GetPointerFrameTouchInfo(UINT32 pointerId, UINT32 *pointerCount, POINTER_TOUCH_INFO *touchInfo)
     * }
     */
    public static int GetPointerFrameTouchInfo(int pointerId, MemorySegment pointerCount, MemorySegment touchInfo) {
        var mh$ = GetPointerFrameTouchInfo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetPointerFrameTouchInfo", pointerId, pointerCount, touchInfo);
            }
            return (int)mh$.invokeExact(pointerId, pointerCount, touchInfo);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetPointerFrameTouchInfoHistory {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_INT,
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetPointerFrameTouchInfoHistory"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetPointerFrameTouchInfoHistory(UINT32 pointerId, UINT32 *entriesCount, UINT32 *pointerCount, POINTER_TOUCH_INFO *touchInfo)
     * }
     */
    public static FunctionDescriptor GetPointerFrameTouchInfoHistory$descriptor() {
        return GetPointerFrameTouchInfoHistory.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetPointerFrameTouchInfoHistory(UINT32 pointerId, UINT32 *entriesCount, UINT32 *pointerCount, POINTER_TOUCH_INFO *touchInfo)
     * }
     */
    public static MethodHandle GetPointerFrameTouchInfoHistory$handle() {
        return GetPointerFrameTouchInfoHistory.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL GetPointerFrameTouchInfoHistory(UINT32 pointerId, UINT32 *entriesCount, UINT32 *pointerCount, POINTER_TOUCH_INFO *touchInfo)
     * }
     */
    public static int GetPointerFrameTouchInfoHistory(int pointerId, MemorySegment entriesCount, MemorySegment pointerCount, MemorySegment touchInfo) {
        var mh$ = GetPointerFrameTouchInfoHistory.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetPointerFrameTouchInfoHistory", pointerId, entriesCount, pointerCount, touchInfo);
            }
            return (int)mh$.invokeExact(pointerId, entriesCount, pointerCount, touchInfo);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetPointerPenInfo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetPointerPenInfo"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetPointerPenInfo(UINT32 pointerId, POINTER_PEN_INFO *penInfo)
     * }
     */
    public static FunctionDescriptor GetPointerPenInfo$descriptor() {
        return GetPointerPenInfo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetPointerPenInfo(UINT32 pointerId, POINTER_PEN_INFO *penInfo)
     * }
     */
    public static MethodHandle GetPointerPenInfo$handle() {
        return GetPointerPenInfo.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL GetPointerPenInfo(UINT32 pointerId, POINTER_PEN_INFO *penInfo)
     * }
     */
    public static int GetPointerPenInfo(int pointerId, MemorySegment penInfo) {
        var mh$ = GetPointerPenInfo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetPointerPenInfo", pointerId, penInfo);
            }
            return (int)mh$.invokeExact(pointerId, penInfo);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetPointerPenInfoHistory {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_INT,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetPointerPenInfoHistory"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetPointerPenInfoHistory(UINT32 pointerId, UINT32 *entriesCount, POINTER_PEN_INFO *penInfo)
     * }
     */
    public static FunctionDescriptor GetPointerPenInfoHistory$descriptor() {
        return GetPointerPenInfoHistory.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetPointerPenInfoHistory(UINT32 pointerId, UINT32 *entriesCount, POINTER_PEN_INFO *penInfo)
     * }
     */
    public static MethodHandle GetPointerPenInfoHistory$handle() {
        return GetPointerPenInfoHistory.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL GetPointerPenInfoHistory(UINT32 pointerId, UINT32 *entriesCount, POINTER_PEN_INFO *penInfo)
     * }
     */
    public static int GetPointerPenInfoHistory(int pointerId, MemorySegment entriesCount, MemorySegment penInfo) {
        var mh$ = GetPointerPenInfoHistory.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetPointerPenInfoHistory", pointerId, entriesCount, penInfo);
            }
            return (int)mh$.invokeExact(pointerId, entriesCount, penInfo);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetPointerFramePenInfo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_INT,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetPointerFramePenInfo"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetPointerFramePenInfo(UINT32 pointerId, UINT32 *pointerCount, POINTER_PEN_INFO *penInfo)
     * }
     */
    public static FunctionDescriptor GetPointerFramePenInfo$descriptor() {
        return GetPointerFramePenInfo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetPointerFramePenInfo(UINT32 pointerId, UINT32 *pointerCount, POINTER_PEN_INFO *penInfo)
     * }
     */
    public static MethodHandle GetPointerFramePenInfo$handle() {
        return GetPointerFramePenInfo.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL GetPointerFramePenInfo(UINT32 pointerId, UINT32 *pointerCount, POINTER_PEN_INFO *penInfo)
     * }
     */
    public static int GetPointerFramePenInfo(int pointerId, MemorySegment pointerCount, MemorySegment penInfo) {
        var mh$ = GetPointerFramePenInfo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetPointerFramePenInfo", pointerId, pointerCount, penInfo);
            }
            return (int)mh$.invokeExact(pointerId, pointerCount, penInfo);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetPointerFramePenInfoHistory {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_INT,
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetPointerFramePenInfoHistory"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetPointerFramePenInfoHistory(UINT32 pointerId, UINT32 *entriesCount, UINT32 *pointerCount, POINTER_PEN_INFO *penInfo)
     * }
     */
    public static FunctionDescriptor GetPointerFramePenInfoHistory$descriptor() {
        return GetPointerFramePenInfoHistory.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetPointerFramePenInfoHistory(UINT32 pointerId, UINT32 *entriesCount, UINT32 *pointerCount, POINTER_PEN_INFO *penInfo)
     * }
     */
    public static MethodHandle GetPointerFramePenInfoHistory$handle() {
        return GetPointerFramePenInfoHistory.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL GetPointerFramePenInfoHistory(UINT32 pointerId, UINT32 *entriesCount, UINT32 *pointerCount, POINTER_PEN_INFO *penInfo)
     * }
     */
    public static int GetPointerFramePenInfoHistory(int pointerId, MemorySegment entriesCount, MemorySegment pointerCount, MemorySegment penInfo) {
        var mh$ = GetPointerFramePenInfoHistory.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetPointerFramePenInfoHistory", pointerId, entriesCount, pointerCount, penInfo);
            }
            return (int)mh$.invokeExact(pointerId, entriesCount, pointerCount, penInfo);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SkipPointerFrameMessages {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("SkipPointerFrameMessages"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SkipPointerFrameMessages(UINT32 pointerId)
     * }
     */
    public static FunctionDescriptor SkipPointerFrameMessages$descriptor() {
        return SkipPointerFrameMessages.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SkipPointerFrameMessages(UINT32 pointerId)
     * }
     */
    public static MethodHandle SkipPointerFrameMessages$handle() {
        return SkipPointerFrameMessages.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL SkipPointerFrameMessages(UINT32 pointerId)
     * }
     */
    public static int SkipPointerFrameMessages(int pointerId) {
        var mh$ = SkipPointerFrameMessages.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SkipPointerFrameMessages", pointerId);
            }
            return (int)mh$.invokeExact(pointerId);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RegisterPointerInputTarget {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("RegisterPointerInputTarget"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL RegisterPointerInputTarget(HWND hwnd, POINTER_INPUT_TYPE pointerType)
     * }
     */
    public static FunctionDescriptor RegisterPointerInputTarget$descriptor() {
        return RegisterPointerInputTarget.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL RegisterPointerInputTarget(HWND hwnd, POINTER_INPUT_TYPE pointerType)
     * }
     */
    public static MethodHandle RegisterPointerInputTarget$handle() {
        return RegisterPointerInputTarget.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL RegisterPointerInputTarget(HWND hwnd, POINTER_INPUT_TYPE pointerType)
     * }
     */
    public static int RegisterPointerInputTarget(MemorySegment hwnd, int pointerType) {
        var mh$ = RegisterPointerInputTarget.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RegisterPointerInputTarget", hwnd, pointerType);
            }
            return (int)mh$.invokeExact(hwnd, pointerType);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class UnregisterPointerInputTarget {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("UnregisterPointerInputTarget"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL UnregisterPointerInputTarget(HWND hwnd, POINTER_INPUT_TYPE pointerType)
     * }
     */
    public static FunctionDescriptor UnregisterPointerInputTarget$descriptor() {
        return UnregisterPointerInputTarget.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL UnregisterPointerInputTarget(HWND hwnd, POINTER_INPUT_TYPE pointerType)
     * }
     */
    public static MethodHandle UnregisterPointerInputTarget$handle() {
        return UnregisterPointerInputTarget.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL UnregisterPointerInputTarget(HWND hwnd, POINTER_INPUT_TYPE pointerType)
     * }
     */
    public static int UnregisterPointerInputTarget(MemorySegment hwnd, int pointerType) {
        var mh$ = UnregisterPointerInputTarget.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("UnregisterPointerInputTarget", hwnd, pointerType);
            }
            return (int)mh$.invokeExact(hwnd, pointerType);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RegisterPointerInputTargetEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_LONG,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("RegisterPointerInputTargetEx"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL RegisterPointerInputTargetEx(HWND hwnd, POINTER_INPUT_TYPE pointerType, BOOL fObserve)
     * }
     */
    public static FunctionDescriptor RegisterPointerInputTargetEx$descriptor() {
        return RegisterPointerInputTargetEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL RegisterPointerInputTargetEx(HWND hwnd, POINTER_INPUT_TYPE pointerType, BOOL fObserve)
     * }
     */
    public static MethodHandle RegisterPointerInputTargetEx$handle() {
        return RegisterPointerInputTargetEx.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL RegisterPointerInputTargetEx(HWND hwnd, POINTER_INPUT_TYPE pointerType, BOOL fObserve)
     * }
     */
    public static int RegisterPointerInputTargetEx(MemorySegment hwnd, int pointerType, int fObserve) {
        var mh$ = RegisterPointerInputTargetEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RegisterPointerInputTargetEx", hwnd, pointerType, fObserve);
            }
            return (int)mh$.invokeExact(hwnd, pointerType, fObserve);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class UnregisterPointerInputTargetEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("UnregisterPointerInputTargetEx"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL UnregisterPointerInputTargetEx(HWND hwnd, POINTER_INPUT_TYPE pointerType)
     * }
     */
    public static FunctionDescriptor UnregisterPointerInputTargetEx$descriptor() {
        return UnregisterPointerInputTargetEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL UnregisterPointerInputTargetEx(HWND hwnd, POINTER_INPUT_TYPE pointerType)
     * }
     */
    public static MethodHandle UnregisterPointerInputTargetEx$handle() {
        return UnregisterPointerInputTargetEx.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL UnregisterPointerInputTargetEx(HWND hwnd, POINTER_INPUT_TYPE pointerType)
     * }
     */
    public static int UnregisterPointerInputTargetEx(MemorySegment hwnd, int pointerType) {
        var mh$ = UnregisterPointerInputTargetEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("UnregisterPointerInputTargetEx", hwnd, pointerType);
            }
            return (int)mh$.invokeExact(hwnd, pointerType);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct HSYNTHETICPOINTERDEVICE__ {
     *     int unused;
     * } *HSYNTHETICPOINTERDEVICE
     * }
     */
    public static final AddressLayout HSYNTHETICPOINTERDEVICE = C_POINTER;

    private static class CreateSyntheticPointerDevice {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_LONG,
            C_LONG,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CreateSyntheticPointerDevice"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HSYNTHETICPOINTERDEVICE CreateSyntheticPointerDevice(POINTER_INPUT_TYPE pointerType, ULONG maxCount, POINTER_FEEDBACK_MODE mode)
     * }
     */
    public static FunctionDescriptor CreateSyntheticPointerDevice$descriptor() {
        return CreateSyntheticPointerDevice.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HSYNTHETICPOINTERDEVICE CreateSyntheticPointerDevice(POINTER_INPUT_TYPE pointerType, ULONG maxCount, POINTER_FEEDBACK_MODE mode)
     * }
     */
    public static MethodHandle CreateSyntheticPointerDevice$handle() {
        return CreateSyntheticPointerDevice.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * HSYNTHETICPOINTERDEVICE CreateSyntheticPointerDevice(POINTER_INPUT_TYPE pointerType, ULONG maxCount, POINTER_FEEDBACK_MODE mode)
     * }
     */
    public static MemorySegment CreateSyntheticPointerDevice(int pointerType, int maxCount, int mode) {
        var mh$ = CreateSyntheticPointerDevice.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateSyntheticPointerDevice", pointerType, maxCount, mode);
            }
            return (MemorySegment)mh$.invokeExact(pointerType, maxCount, mode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class InjectSyntheticPointerInput {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("InjectSyntheticPointerInput"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL InjectSyntheticPointerInput(HSYNTHETICPOINTERDEVICE device, const POINTER_TYPE_INFO *pointerInfo, UINT32 count)
     * }
     */
    public static FunctionDescriptor InjectSyntheticPointerInput$descriptor() {
        return InjectSyntheticPointerInput.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL InjectSyntheticPointerInput(HSYNTHETICPOINTERDEVICE device, const POINTER_TYPE_INFO *pointerInfo, UINT32 count)
     * }
     */
    public static MethodHandle InjectSyntheticPointerInput$handle() {
        return InjectSyntheticPointerInput.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL InjectSyntheticPointerInput(HSYNTHETICPOINTERDEVICE device, const POINTER_TYPE_INFO *pointerInfo, UINT32 count)
     * }
     */
    public static int InjectSyntheticPointerInput(MemorySegment device, MemorySegment pointerInfo, int count) {
        var mh$ = InjectSyntheticPointerInput.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("InjectSyntheticPointerInput", device, pointerInfo, count);
            }
            return (int)mh$.invokeExact(device, pointerInfo, count);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DestroySyntheticPointerDevice {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("DestroySyntheticPointerDevice"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void DestroySyntheticPointerDevice(HSYNTHETICPOINTERDEVICE device)
     * }
     */
    public static FunctionDescriptor DestroySyntheticPointerDevice$descriptor() {
        return DestroySyntheticPointerDevice.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void DestroySyntheticPointerDevice(HSYNTHETICPOINTERDEVICE device)
     * }
     */
    public static MethodHandle DestroySyntheticPointerDevice$handle() {
        return DestroySyntheticPointerDevice.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * void DestroySyntheticPointerDevice(HSYNTHETICPOINTERDEVICE device)
     * }
     */
    public static void DestroySyntheticPointerDevice(MemorySegment device) {
        var mh$ = DestroySyntheticPointerDevice.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DestroySyntheticPointerDevice", device);
            }
            mh$.invokeExact(device);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class EnableMouseInPointer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("EnableMouseInPointer"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL EnableMouseInPointer(BOOL fEnable)
     * }
     */
    public static FunctionDescriptor EnableMouseInPointer$descriptor() {
        return EnableMouseInPointer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL EnableMouseInPointer(BOOL fEnable)
     * }
     */
    public static MethodHandle EnableMouseInPointer$handle() {
        return EnableMouseInPointer.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL EnableMouseInPointer(BOOL fEnable)
     * }
     */
    public static int EnableMouseInPointer(int fEnable) {
        var mh$ = EnableMouseInPointer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("EnableMouseInPointer", fEnable);
            }
            return (int)mh$.invokeExact(fEnable);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class IsMouseInPointerEnabled {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT    );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("IsMouseInPointerEnabled"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL IsMouseInPointerEnabled()
     * }
     */
    public static FunctionDescriptor IsMouseInPointerEnabled$descriptor() {
        return IsMouseInPointerEnabled.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL IsMouseInPointerEnabled()
     * }
     */
    public static MethodHandle IsMouseInPointerEnabled$handle() {
        return IsMouseInPointerEnabled.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL IsMouseInPointerEnabled()
     * }
     */
    public static int IsMouseInPointerEnabled() {
        var mh$ = IsMouseInPointerEnabled.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("IsMouseInPointerEnabled");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class EnableMouseInPointerForThread {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT    );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("EnableMouseInPointerForThread"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL EnableMouseInPointerForThread()
     * }
     */
    public static FunctionDescriptor EnableMouseInPointerForThread$descriptor() {
        return EnableMouseInPointerForThread.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL EnableMouseInPointerForThread()
     * }
     */
    public static MethodHandle EnableMouseInPointerForThread$handle() {
        return EnableMouseInPointerForThread.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL EnableMouseInPointerForThread()
     * }
     */
    public static int EnableMouseInPointerForThread() {
        var mh$ = EnableMouseInPointerForThread.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("EnableMouseInPointerForThread");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RegisterTouchHitTestingWindow {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("RegisterTouchHitTestingWindow"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL RegisterTouchHitTestingWindow(HWND hwnd, ULONG value)
     * }
     */
    public static FunctionDescriptor RegisterTouchHitTestingWindow$descriptor() {
        return RegisterTouchHitTestingWindow.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL RegisterTouchHitTestingWindow(HWND hwnd, ULONG value)
     * }
     */
    public static MethodHandle RegisterTouchHitTestingWindow$handle() {
        return RegisterTouchHitTestingWindow.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL RegisterTouchHitTestingWindow(HWND hwnd, ULONG value)
     * }
     */
    public static int RegisterTouchHitTestingWindow(MemorySegment hwnd, int value) {
        var mh$ = RegisterTouchHitTestingWindow.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RegisterTouchHitTestingWindow", hwnd, value);
            }
            return (int)mh$.invokeExact(hwnd, value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct tagTOUCH_HIT_TESTING_PROXIMITY_EVALUATION {
     *     UINT16 score;
     *     POINT adjustedPoint;
     * } *PTOUCH_HIT_TESTING_PROXIMITY_EVALUATION
     * }
     */
    public static final AddressLayout PTOUCH_HIT_TESTING_PROXIMITY_EVALUATION = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagTOUCH_HIT_TESTING_INPUT {
     *     UINT32 pointerId;
     *     POINT point;
     *     RECT boundingBox;
     *     RECT nonOccludedBoundingBox;
     *     UINT32 orientation;
     * } *PTOUCH_HIT_TESTING_INPUT
     * }
     */
    public static final AddressLayout PTOUCH_HIT_TESTING_INPUT = C_POINTER;

    private static class EvaluateProximityToRect {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("EvaluateProximityToRect"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL EvaluateProximityToRect(const RECT *controlBoundingBox, const TOUCH_HIT_TESTING_INPUT *pHitTestingInput, TOUCH_HIT_TESTING_PROXIMITY_EVALUATION *pProximityEval)
     * }
     */
    public static FunctionDescriptor EvaluateProximityToRect$descriptor() {
        return EvaluateProximityToRect.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL EvaluateProximityToRect(const RECT *controlBoundingBox, const TOUCH_HIT_TESTING_INPUT *pHitTestingInput, TOUCH_HIT_TESTING_PROXIMITY_EVALUATION *pProximityEval)
     * }
     */
    public static MethodHandle EvaluateProximityToRect$handle() {
        return EvaluateProximityToRect.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL EvaluateProximityToRect(const RECT *controlBoundingBox, const TOUCH_HIT_TESTING_INPUT *pHitTestingInput, TOUCH_HIT_TESTING_PROXIMITY_EVALUATION *pProximityEval)
     * }
     */
    public static int EvaluateProximityToRect(MemorySegment controlBoundingBox, MemorySegment pHitTestingInput, MemorySegment pProximityEval) {
        var mh$ = EvaluateProximityToRect.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("EvaluateProximityToRect", controlBoundingBox, pHitTestingInput, pProximityEval);
            }
            return (int)mh$.invokeExact(controlBoundingBox, pHitTestingInput, pProximityEval);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class EvaluateProximityToPolygon {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_INT,
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("EvaluateProximityToPolygon"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL EvaluateProximityToPolygon(UINT32 numVertices, const POINT *controlPolygon, const TOUCH_HIT_TESTING_INPUT *pHitTestingInput, TOUCH_HIT_TESTING_PROXIMITY_EVALUATION *pProximityEval)
     * }
     */
    public static FunctionDescriptor EvaluateProximityToPolygon$descriptor() {
        return EvaluateProximityToPolygon.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL EvaluateProximityToPolygon(UINT32 numVertices, const POINT *controlPolygon, const TOUCH_HIT_TESTING_INPUT *pHitTestingInput, TOUCH_HIT_TESTING_PROXIMITY_EVALUATION *pProximityEval)
     * }
     */
    public static MethodHandle EvaluateProximityToPolygon$handle() {
        return EvaluateProximityToPolygon.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL EvaluateProximityToPolygon(UINT32 numVertices, const POINT *controlPolygon, const TOUCH_HIT_TESTING_INPUT *pHitTestingInput, TOUCH_HIT_TESTING_PROXIMITY_EVALUATION *pProximityEval)
     * }
     */
    public static int EvaluateProximityToPolygon(int numVertices, MemorySegment controlPolygon, MemorySegment pHitTestingInput, MemorySegment pProximityEval) {
        var mh$ = EvaluateProximityToPolygon.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("EvaluateProximityToPolygon", numVertices, controlPolygon, pHitTestingInput, pProximityEval);
            }
            return (int)mh$.invokeExact(numVertices, controlPolygon, pHitTestingInput, pProximityEval);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PackTouchHitTestingProximityEvaluation {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG_LONG,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("PackTouchHitTestingProximityEvaluation"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LRESULT PackTouchHitTestingProximityEvaluation(const TOUCH_HIT_TESTING_INPUT *pHitTestingInput, const TOUCH_HIT_TESTING_PROXIMITY_EVALUATION *pProximityEval)
     * }
     */
    public static FunctionDescriptor PackTouchHitTestingProximityEvaluation$descriptor() {
        return PackTouchHitTestingProximityEvaluation.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LRESULT PackTouchHitTestingProximityEvaluation(const TOUCH_HIT_TESTING_INPUT *pHitTestingInput, const TOUCH_HIT_TESTING_PROXIMITY_EVALUATION *pProximityEval)
     * }
     */
    public static MethodHandle PackTouchHitTestingProximityEvaluation$handle() {
        return PackTouchHitTestingProximityEvaluation.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * LRESULT PackTouchHitTestingProximityEvaluation(const TOUCH_HIT_TESTING_INPUT *pHitTestingInput, const TOUCH_HIT_TESTING_PROXIMITY_EVALUATION *pProximityEval)
     * }
     */
    public static long PackTouchHitTestingProximityEvaluation(MemorySegment pHitTestingInput, MemorySegment pProximityEval) {
        var mh$ = PackTouchHitTestingProximityEvaluation.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PackTouchHitTestingProximityEvaluation", pHitTestingInput, pProximityEval);
            }
            return (long)mh$.invokeExact(pHitTestingInput, pProximityEval);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int FEEDBACK_TOUCH_CONTACTVISUALIZATION = (int)1L;
    /**
     * {@snippet lang=c :
     * enum tagFEEDBACK_TYPE.FEEDBACK_TOUCH_CONTACTVISUALIZATION = 1
     * }
     */
    public static int FEEDBACK_TOUCH_CONTACTVISUALIZATION() {
        return FEEDBACK_TOUCH_CONTACTVISUALIZATION;
    }
    private static final int FEEDBACK_PEN_BARRELVISUALIZATION = (int)2L;
    /**
     * {@snippet lang=c :
     * enum tagFEEDBACK_TYPE.FEEDBACK_PEN_BARRELVISUALIZATION = 2
     * }
     */
    public static int FEEDBACK_PEN_BARRELVISUALIZATION() {
        return FEEDBACK_PEN_BARRELVISUALIZATION;
    }
    private static final int FEEDBACK_PEN_TAP = (int)3L;
    /**
     * {@snippet lang=c :
     * enum tagFEEDBACK_TYPE.FEEDBACK_PEN_TAP = 3
     * }
     */
    public static int FEEDBACK_PEN_TAP() {
        return FEEDBACK_PEN_TAP;
    }
    private static final int FEEDBACK_PEN_DOUBLETAP = (int)4L;
    /**
     * {@snippet lang=c :
     * enum tagFEEDBACK_TYPE.FEEDBACK_PEN_DOUBLETAP = 4
     * }
     */
    public static int FEEDBACK_PEN_DOUBLETAP() {
        return FEEDBACK_PEN_DOUBLETAP;
    }
    private static final int FEEDBACK_PEN_PRESSANDHOLD = (int)5L;
    /**
     * {@snippet lang=c :
     * enum tagFEEDBACK_TYPE.FEEDBACK_PEN_PRESSANDHOLD = 5
     * }
     */
    public static int FEEDBACK_PEN_PRESSANDHOLD() {
        return FEEDBACK_PEN_PRESSANDHOLD;
    }
    private static final int FEEDBACK_PEN_RIGHTTAP = (int)6L;
    /**
     * {@snippet lang=c :
     * enum tagFEEDBACK_TYPE.FEEDBACK_PEN_RIGHTTAP = 6
     * }
     */
    public static int FEEDBACK_PEN_RIGHTTAP() {
        return FEEDBACK_PEN_RIGHTTAP;
    }
    private static final int FEEDBACK_TOUCH_TAP = (int)7L;
    /**
     * {@snippet lang=c :
     * enum tagFEEDBACK_TYPE.FEEDBACK_TOUCH_TAP = 7
     * }
     */
    public static int FEEDBACK_TOUCH_TAP() {
        return FEEDBACK_TOUCH_TAP;
    }
    private static final int FEEDBACK_TOUCH_DOUBLETAP = (int)8L;
    /**
     * {@snippet lang=c :
     * enum tagFEEDBACK_TYPE.FEEDBACK_TOUCH_DOUBLETAP = 8
     * }
     */
    public static int FEEDBACK_TOUCH_DOUBLETAP() {
        return FEEDBACK_TOUCH_DOUBLETAP;
    }
    private static final int FEEDBACK_TOUCH_PRESSANDHOLD = (int)9L;
    /**
     * {@snippet lang=c :
     * enum tagFEEDBACK_TYPE.FEEDBACK_TOUCH_PRESSANDHOLD = 9
     * }
     */
    public static int FEEDBACK_TOUCH_PRESSANDHOLD() {
        return FEEDBACK_TOUCH_PRESSANDHOLD;
    }
    private static final int FEEDBACK_TOUCH_RIGHTTAP = (int)10L;
    /**
     * {@snippet lang=c :
     * enum tagFEEDBACK_TYPE.FEEDBACK_TOUCH_RIGHTTAP = 10
     * }
     */
    public static int FEEDBACK_TOUCH_RIGHTTAP() {
        return FEEDBACK_TOUCH_RIGHTTAP;
    }
    private static final int FEEDBACK_GESTURE_PRESSANDTAP = (int)11L;
    /**
     * {@snippet lang=c :
     * enum tagFEEDBACK_TYPE.FEEDBACK_GESTURE_PRESSANDTAP = 11
     * }
     */
    public static int FEEDBACK_GESTURE_PRESSANDTAP() {
        return FEEDBACK_GESTURE_PRESSANDTAP;
    }
    private static final int FEEDBACK_MAX = (int)-1L;
    /**
     * {@snippet lang=c :
     * enum tagFEEDBACK_TYPE.FEEDBACK_MAX = -1
     * }
     */
    public static int FEEDBACK_MAX() {
        return FEEDBACK_MAX;
    }

    private static class GetWindowFeedbackSetting {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_INT,
            C_LONG,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetWindowFeedbackSetting"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetWindowFeedbackSetting(HWND hwnd, FEEDBACK_TYPE feedback, DWORD dwFlags, UINT32 *pSize, void *config)
     * }
     */
    public static FunctionDescriptor GetWindowFeedbackSetting$descriptor() {
        return GetWindowFeedbackSetting.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetWindowFeedbackSetting(HWND hwnd, FEEDBACK_TYPE feedback, DWORD dwFlags, UINT32 *pSize, void *config)
     * }
     */
    public static MethodHandle GetWindowFeedbackSetting$handle() {
        return GetWindowFeedbackSetting.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL GetWindowFeedbackSetting(HWND hwnd, FEEDBACK_TYPE feedback, DWORD dwFlags, UINT32 *pSize, void *config)
     * }
     */
    public static int GetWindowFeedbackSetting(MemorySegment hwnd, int feedback, int dwFlags, MemorySegment pSize, MemorySegment config) {
        var mh$ = GetWindowFeedbackSetting.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetWindowFeedbackSetting", hwnd, feedback, dwFlags, pSize, config);
            }
            return (int)mh$.invokeExact(hwnd, feedback, dwFlags, pSize, config);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetWindowFeedbackSetting {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_INT,
            C_LONG,
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("SetWindowFeedbackSetting"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetWindowFeedbackSetting(HWND hwnd, FEEDBACK_TYPE feedback, DWORD dwFlags, UINT32 size, const void *configuration)
     * }
     */
    public static FunctionDescriptor SetWindowFeedbackSetting$descriptor() {
        return SetWindowFeedbackSetting.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetWindowFeedbackSetting(HWND hwnd, FEEDBACK_TYPE feedback, DWORD dwFlags, UINT32 size, const void *configuration)
     * }
     */
    public static MethodHandle SetWindowFeedbackSetting$handle() {
        return SetWindowFeedbackSetting.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL SetWindowFeedbackSetting(HWND hwnd, FEEDBACK_TYPE feedback, DWORD dwFlags, UINT32 size, const void *configuration)
     * }
     */
    public static int SetWindowFeedbackSetting(MemorySegment hwnd, int feedback, int dwFlags, int size, MemorySegment configuration) {
        var mh$ = SetWindowFeedbackSetting.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetWindowFeedbackSetting", hwnd, feedback, dwFlags, size, configuration);
            }
            return (int)mh$.invokeExact(hwnd, feedback, dwFlags, size, configuration);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetPointerInputTransform {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_INT,
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetPointerInputTransform"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetPointerInputTransform(UINT32 pointerId, UINT32 historyCount, INPUT_TRANSFORM *inputTransform)
     * }
     */
    public static FunctionDescriptor GetPointerInputTransform$descriptor() {
        return GetPointerInputTransform.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetPointerInputTransform(UINT32 pointerId, UINT32 historyCount, INPUT_TRANSFORM *inputTransform)
     * }
     */
    public static MethodHandle GetPointerInputTransform$handle() {
        return GetPointerInputTransform.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL GetPointerInputTransform(UINT32 pointerId, UINT32 historyCount, INPUT_TRANSFORM *inputTransform)
     * }
     */
    public static int GetPointerInputTransform(int pointerId, int historyCount, MemorySegment inputTransform) {
        var mh$ = GetPointerInputTransform.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetPointerInputTransform", pointerId, historyCount, inputTransform);
            }
            return (int)mh$.invokeExact(pointerId, historyCount, inputTransform);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct tagLASTINPUTINFO {
     *     UINT cbSize;
     *     DWORD dwTime;
     * } *PLASTINPUTINFO
     * }
     */
    public static final AddressLayout PLASTINPUTINFO = C_POINTER;

    private static class GetLastInputInfo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetLastInputInfo"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetLastInputInfo(PLASTINPUTINFO plii)
     * }
     */
    public static FunctionDescriptor GetLastInputInfo$descriptor() {
        return GetLastInputInfo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetLastInputInfo(PLASTINPUTINFO plii)
     * }
     */
    public static MethodHandle GetLastInputInfo$handle() {
        return GetLastInputInfo.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL GetLastInputInfo(PLASTINPUTINFO plii)
     * }
     */
    public static int GetLastInputInfo(MemorySegment plii) {
        var mh$ = GetLastInputInfo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetLastInputInfo", plii);
            }
            return (int)mh$.invokeExact(plii);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MapVirtualKeyA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_INT,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("MapVirtualKeyA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * UINT MapVirtualKeyA(UINT uCode, UINT uMapType)
     * }
     */
    public static FunctionDescriptor MapVirtualKeyA$descriptor() {
        return MapVirtualKeyA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * UINT MapVirtualKeyA(UINT uCode, UINT uMapType)
     * }
     */
    public static MethodHandle MapVirtualKeyA$handle() {
        return MapVirtualKeyA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * UINT MapVirtualKeyA(UINT uCode, UINT uMapType)
     * }
     */
    public static int MapVirtualKeyA(int uCode, int uMapType) {
        var mh$ = MapVirtualKeyA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MapVirtualKeyA", uCode, uMapType);
            }
            return (int)mh$.invokeExact(uCode, uMapType);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MapVirtualKeyW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_INT,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("MapVirtualKeyW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * UINT MapVirtualKeyW(UINT uCode, UINT uMapType)
     * }
     */
    public static FunctionDescriptor MapVirtualKeyW$descriptor() {
        return MapVirtualKeyW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * UINT MapVirtualKeyW(UINT uCode, UINT uMapType)
     * }
     */
    public static MethodHandle MapVirtualKeyW$handle() {
        return MapVirtualKeyW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * UINT MapVirtualKeyW(UINT uCode, UINT uMapType)
     * }
     */
    public static int MapVirtualKeyW(int uCode, int uMapType) {
        var mh$ = MapVirtualKeyW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MapVirtualKeyW", uCode, uMapType);
            }
            return (int)mh$.invokeExact(uCode, uMapType);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MapVirtualKeyExA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_INT,
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("MapVirtualKeyExA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * UINT MapVirtualKeyExA(UINT uCode, UINT uMapType, HKL dwhkl)
     * }
     */
    public static FunctionDescriptor MapVirtualKeyExA$descriptor() {
        return MapVirtualKeyExA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * UINT MapVirtualKeyExA(UINT uCode, UINT uMapType, HKL dwhkl)
     * }
     */
    public static MethodHandle MapVirtualKeyExA$handle() {
        return MapVirtualKeyExA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * UINT MapVirtualKeyExA(UINT uCode, UINT uMapType, HKL dwhkl)
     * }
     */
    public static int MapVirtualKeyExA(int uCode, int uMapType, MemorySegment dwhkl) {
        var mh$ = MapVirtualKeyExA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MapVirtualKeyExA", uCode, uMapType, dwhkl);
            }
            return (int)mh$.invokeExact(uCode, uMapType, dwhkl);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MapVirtualKeyExW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_INT,
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("MapVirtualKeyExW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * UINT MapVirtualKeyExW(UINT uCode, UINT uMapType, HKL dwhkl)
     * }
     */
    public static FunctionDescriptor MapVirtualKeyExW$descriptor() {
        return MapVirtualKeyExW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * UINT MapVirtualKeyExW(UINT uCode, UINT uMapType, HKL dwhkl)
     * }
     */
    public static MethodHandle MapVirtualKeyExW$handle() {
        return MapVirtualKeyExW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * UINT MapVirtualKeyExW(UINT uCode, UINT uMapType, HKL dwhkl)
     * }
     */
    public static int MapVirtualKeyExW(int uCode, int uMapType, MemorySegment dwhkl) {
        var mh$ = MapVirtualKeyExW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MapVirtualKeyExW", uCode, uMapType, dwhkl);
            }
            return (int)mh$.invokeExact(uCode, uMapType, dwhkl);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetInputState {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT    );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetInputState"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetInputState()
     * }
     */
    public static FunctionDescriptor GetInputState$descriptor() {
        return GetInputState.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetInputState()
     * }
     */
    public static MethodHandle GetInputState$handle() {
        return GetInputState.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL GetInputState()
     * }
     */
    public static int GetInputState() {
        var mh$ = GetInputState.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetInputState");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetQueueStatus {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetQueueStatus"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetQueueStatus(UINT flags)
     * }
     */
    public static FunctionDescriptor GetQueueStatus$descriptor() {
        return GetQueueStatus.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetQueueStatus(UINT flags)
     * }
     */
    public static MethodHandle GetQueueStatus$handle() {
        return GetQueueStatus.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * DWORD GetQueueStatus(UINT flags)
     * }
     */
    public static int GetQueueStatus(int flags) {
        var mh$ = GetQueueStatus.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetQueueStatus", flags);
            }
            return (int)mh$.invokeExact(flags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetCapture {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER    );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetCapture"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HWND GetCapture()
     * }
     */
    public static FunctionDescriptor GetCapture$descriptor() {
        return GetCapture.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HWND GetCapture()
     * }
     */
    public static MethodHandle GetCapture$handle() {
        return GetCapture.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * HWND GetCapture()
     * }
     */
    public static MemorySegment GetCapture() {
        var mh$ = GetCapture.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetCapture");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetCapture {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("SetCapture"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HWND SetCapture(HWND hWnd)
     * }
     */
    public static FunctionDescriptor SetCapture$descriptor() {
        return SetCapture.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HWND SetCapture(HWND hWnd)
     * }
     */
    public static MethodHandle SetCapture$handle() {
        return SetCapture.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * HWND SetCapture(HWND hWnd)
     * }
     */
    public static MemorySegment SetCapture(MemorySegment hWnd) {
        var mh$ = SetCapture.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetCapture", hWnd);
            }
            return (MemorySegment)mh$.invokeExact(hWnd);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ReleaseCapture {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT    );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("ReleaseCapture"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL ReleaseCapture()
     * }
     */
    public static FunctionDescriptor ReleaseCapture$descriptor() {
        return ReleaseCapture.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL ReleaseCapture()
     * }
     */
    public static MethodHandle ReleaseCapture$handle() {
        return ReleaseCapture.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL ReleaseCapture()
     * }
     */
    public static int ReleaseCapture() {
        var mh$ = ReleaseCapture.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ReleaseCapture");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MsgWaitForMultipleObjects {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_LONG,
            C_POINTER,
            C_INT,
            C_LONG,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("MsgWaitForMultipleObjects"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD MsgWaitForMultipleObjects(DWORD nCount, const HANDLE *pHandles, BOOL fWaitAll, DWORD dwMilliseconds, DWORD dwWakeMask)
     * }
     */
    public static FunctionDescriptor MsgWaitForMultipleObjects$descriptor() {
        return MsgWaitForMultipleObjects.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD MsgWaitForMultipleObjects(DWORD nCount, const HANDLE *pHandles, BOOL fWaitAll, DWORD dwMilliseconds, DWORD dwWakeMask)
     * }
     */
    public static MethodHandle MsgWaitForMultipleObjects$handle() {
        return MsgWaitForMultipleObjects.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * DWORD MsgWaitForMultipleObjects(DWORD nCount, const HANDLE *pHandles, BOOL fWaitAll, DWORD dwMilliseconds, DWORD dwWakeMask)
     * }
     */
    public static int MsgWaitForMultipleObjects(int nCount, MemorySegment pHandles, int fWaitAll, int dwMilliseconds, int dwWakeMask) {
        var mh$ = MsgWaitForMultipleObjects.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MsgWaitForMultipleObjects", nCount, pHandles, fWaitAll, dwMilliseconds, dwWakeMask);
            }
            return (int)mh$.invokeExact(nCount, pHandles, fWaitAll, dwMilliseconds, dwWakeMask);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MsgWaitForMultipleObjectsEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_LONG,
            C_POINTER,
            C_LONG,
            C_LONG,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("MsgWaitForMultipleObjectsEx"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD MsgWaitForMultipleObjectsEx(DWORD nCount, const HANDLE *pHandles, DWORD dwMilliseconds, DWORD dwWakeMask, DWORD dwFlags)
     * }
     */
    public static FunctionDescriptor MsgWaitForMultipleObjectsEx$descriptor() {
        return MsgWaitForMultipleObjectsEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD MsgWaitForMultipleObjectsEx(DWORD nCount, const HANDLE *pHandles, DWORD dwMilliseconds, DWORD dwWakeMask, DWORD dwFlags)
     * }
     */
    public static MethodHandle MsgWaitForMultipleObjectsEx$handle() {
        return MsgWaitForMultipleObjectsEx.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * DWORD MsgWaitForMultipleObjectsEx(DWORD nCount, const HANDLE *pHandles, DWORD dwMilliseconds, DWORD dwWakeMask, DWORD dwFlags)
     * }
     */
    public static int MsgWaitForMultipleObjectsEx(int nCount, MemorySegment pHandles, int dwMilliseconds, int dwWakeMask, int dwFlags) {
        var mh$ = MsgWaitForMultipleObjectsEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MsgWaitForMultipleObjectsEx", nCount, pHandles, dwMilliseconds, dwWakeMask, dwFlags);
            }
            return (int)mh$.invokeExact(nCount, pHandles, dwMilliseconds, dwWakeMask, dwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetTimer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG_LONG,
            C_POINTER,
            C_LONG_LONG,
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("SetTimer"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * UINT_PTR SetTimer(HWND hWnd, UINT_PTR nIDEvent, UINT uElapse, TIMERPROC lpTimerFunc)
     * }
     */
    public static FunctionDescriptor SetTimer$descriptor() {
        return SetTimer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * UINT_PTR SetTimer(HWND hWnd, UINT_PTR nIDEvent, UINT uElapse, TIMERPROC lpTimerFunc)
     * }
     */
    public static MethodHandle SetTimer$handle() {
        return SetTimer.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * UINT_PTR SetTimer(HWND hWnd, UINT_PTR nIDEvent, UINT uElapse, TIMERPROC lpTimerFunc)
     * }
     */
    public static long SetTimer(MemorySegment hWnd, long nIDEvent, int uElapse, MemorySegment lpTimerFunc) {
        var mh$ = SetTimer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetTimer", hWnd, nIDEvent, uElapse, lpTimerFunc);
            }
            return (long)mh$.invokeExact(hWnd, nIDEvent, uElapse, lpTimerFunc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetCoalescableTimer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG_LONG,
            C_POINTER,
            C_LONG_LONG,
            C_INT,
            C_POINTER,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("SetCoalescableTimer"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * UINT_PTR SetCoalescableTimer(HWND hWnd, UINT_PTR nIDEvent, UINT uElapse, TIMERPROC lpTimerFunc, ULONG uToleranceDelay)
     * }
     */
    public static FunctionDescriptor SetCoalescableTimer$descriptor() {
        return SetCoalescableTimer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * UINT_PTR SetCoalescableTimer(HWND hWnd, UINT_PTR nIDEvent, UINT uElapse, TIMERPROC lpTimerFunc, ULONG uToleranceDelay)
     * }
     */
    public static MethodHandle SetCoalescableTimer$handle() {
        return SetCoalescableTimer.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * UINT_PTR SetCoalescableTimer(HWND hWnd, UINT_PTR nIDEvent, UINT uElapse, TIMERPROC lpTimerFunc, ULONG uToleranceDelay)
     * }
     */
    public static long SetCoalescableTimer(MemorySegment hWnd, long nIDEvent, int uElapse, MemorySegment lpTimerFunc, int uToleranceDelay) {
        var mh$ = SetCoalescableTimer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetCoalescableTimer", hWnd, nIDEvent, uElapse, lpTimerFunc, uToleranceDelay);
            }
            return (long)mh$.invokeExact(hWnd, nIDEvent, uElapse, lpTimerFunc, uToleranceDelay);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class KillTimer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_LONG_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("KillTimer"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL KillTimer(HWND hWnd, UINT_PTR uIDEvent)
     * }
     */
    public static FunctionDescriptor KillTimer$descriptor() {
        return KillTimer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL KillTimer(HWND hWnd, UINT_PTR uIDEvent)
     * }
     */
    public static MethodHandle KillTimer$handle() {
        return KillTimer.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL KillTimer(HWND hWnd, UINT_PTR uIDEvent)
     * }
     */
    public static int KillTimer(MemorySegment hWnd, long uIDEvent) {
        var mh$ = KillTimer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("KillTimer", hWnd, uIDEvent);
            }
            return (int)mh$.invokeExact(hWnd, uIDEvent);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class IsWindowUnicode {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("IsWindowUnicode"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL IsWindowUnicode(HWND hWnd)
     * }
     */
    public static FunctionDescriptor IsWindowUnicode$descriptor() {
        return IsWindowUnicode.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL IsWindowUnicode(HWND hWnd)
     * }
     */
    public static MethodHandle IsWindowUnicode$handle() {
        return IsWindowUnicode.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL IsWindowUnicode(HWND hWnd)
     * }
     */
    public static int IsWindowUnicode(MemorySegment hWnd) {
        var mh$ = IsWindowUnicode.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("IsWindowUnicode", hWnd);
            }
            return (int)mh$.invokeExact(hWnd);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class EnableWindow {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("EnableWindow"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL EnableWindow(HWND hWnd, BOOL bEnable)
     * }
     */
    public static FunctionDescriptor EnableWindow$descriptor() {
        return EnableWindow.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL EnableWindow(HWND hWnd, BOOL bEnable)
     * }
     */
    public static MethodHandle EnableWindow$handle() {
        return EnableWindow.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL EnableWindow(HWND hWnd, BOOL bEnable)
     * }
     */
    public static int EnableWindow(MemorySegment hWnd, int bEnable) {
        var mh$ = EnableWindow.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("EnableWindow", hWnd, bEnable);
            }
            return (int)mh$.invokeExact(hWnd, bEnable);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class IsWindowEnabled {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("IsWindowEnabled"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL IsWindowEnabled(HWND hWnd)
     * }
     */
    public static FunctionDescriptor IsWindowEnabled$descriptor() {
        return IsWindowEnabled.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL IsWindowEnabled(HWND hWnd)
     * }
     */
    public static MethodHandle IsWindowEnabled$handle() {
        return IsWindowEnabled.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL IsWindowEnabled(HWND hWnd)
     * }
     */
    public static int IsWindowEnabled(MemorySegment hWnd) {
        var mh$ = IsWindowEnabled.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("IsWindowEnabled", hWnd);
            }
            return (int)mh$.invokeExact(hWnd);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LoadAcceleratorsA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("LoadAcceleratorsA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HACCEL LoadAcceleratorsA(HINSTANCE hInstance, LPCSTR lpTableName)
     * }
     */
    public static FunctionDescriptor LoadAcceleratorsA$descriptor() {
        return LoadAcceleratorsA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HACCEL LoadAcceleratorsA(HINSTANCE hInstance, LPCSTR lpTableName)
     * }
     */
    public static MethodHandle LoadAcceleratorsA$handle() {
        return LoadAcceleratorsA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * HACCEL LoadAcceleratorsA(HINSTANCE hInstance, LPCSTR lpTableName)
     * }
     */
    public static MemorySegment LoadAcceleratorsA(MemorySegment hInstance, MemorySegment lpTableName) {
        var mh$ = LoadAcceleratorsA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LoadAcceleratorsA", hInstance, lpTableName);
            }
            return (MemorySegment)mh$.invokeExact(hInstance, lpTableName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LoadAcceleratorsW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("LoadAcceleratorsW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HACCEL LoadAcceleratorsW(HINSTANCE hInstance, LPCWSTR lpTableName)
     * }
     */
    public static FunctionDescriptor LoadAcceleratorsW$descriptor() {
        return LoadAcceleratorsW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HACCEL LoadAcceleratorsW(HINSTANCE hInstance, LPCWSTR lpTableName)
     * }
     */
    public static MethodHandle LoadAcceleratorsW$handle() {
        return LoadAcceleratorsW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * HACCEL LoadAcceleratorsW(HINSTANCE hInstance, LPCWSTR lpTableName)
     * }
     */
    public static MemorySegment LoadAcceleratorsW(MemorySegment hInstance, MemorySegment lpTableName) {
        var mh$ = LoadAcceleratorsW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LoadAcceleratorsW", hInstance, lpTableName);
            }
            return (MemorySegment)mh$.invokeExact(hInstance, lpTableName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateAcceleratorTableA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CreateAcceleratorTableA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HACCEL CreateAcceleratorTableA(LPACCEL paccel, int cAccel)
     * }
     */
    public static FunctionDescriptor CreateAcceleratorTableA$descriptor() {
        return CreateAcceleratorTableA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HACCEL CreateAcceleratorTableA(LPACCEL paccel, int cAccel)
     * }
     */
    public static MethodHandle CreateAcceleratorTableA$handle() {
        return CreateAcceleratorTableA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * HACCEL CreateAcceleratorTableA(LPACCEL paccel, int cAccel)
     * }
     */
    public static MemorySegment CreateAcceleratorTableA(MemorySegment paccel, int cAccel) {
        var mh$ = CreateAcceleratorTableA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateAcceleratorTableA", paccel, cAccel);
            }
            return (MemorySegment)mh$.invokeExact(paccel, cAccel);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateAcceleratorTableW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CreateAcceleratorTableW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HACCEL CreateAcceleratorTableW(LPACCEL paccel, int cAccel)
     * }
     */
    public static FunctionDescriptor CreateAcceleratorTableW$descriptor() {
        return CreateAcceleratorTableW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HACCEL CreateAcceleratorTableW(LPACCEL paccel, int cAccel)
     * }
     */
    public static MethodHandle CreateAcceleratorTableW$handle() {
        return CreateAcceleratorTableW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * HACCEL CreateAcceleratorTableW(LPACCEL paccel, int cAccel)
     * }
     */
    public static MemorySegment CreateAcceleratorTableW(MemorySegment paccel, int cAccel) {
        var mh$ = CreateAcceleratorTableW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateAcceleratorTableW", paccel, cAccel);
            }
            return (MemorySegment)mh$.invokeExact(paccel, cAccel);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DestroyAcceleratorTable {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("DestroyAcceleratorTable"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL DestroyAcceleratorTable(HACCEL hAccel)
     * }
     */
    public static FunctionDescriptor DestroyAcceleratorTable$descriptor() {
        return DestroyAcceleratorTable.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL DestroyAcceleratorTable(HACCEL hAccel)
     * }
     */
    public static MethodHandle DestroyAcceleratorTable$handle() {
        return DestroyAcceleratorTable.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL DestroyAcceleratorTable(HACCEL hAccel)
     * }
     */
    public static int DestroyAcceleratorTable(MemorySegment hAccel) {
        var mh$ = DestroyAcceleratorTable.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DestroyAcceleratorTable", hAccel);
            }
            return (int)mh$.invokeExact(hAccel);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CopyAcceleratorTableA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CopyAcceleratorTableA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int CopyAcceleratorTableA(HACCEL hAccelSrc, LPACCEL lpAccelDst, int cAccelEntries)
     * }
     */
    public static FunctionDescriptor CopyAcceleratorTableA$descriptor() {
        return CopyAcceleratorTableA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int CopyAcceleratorTableA(HACCEL hAccelSrc, LPACCEL lpAccelDst, int cAccelEntries)
     * }
     */
    public static MethodHandle CopyAcceleratorTableA$handle() {
        return CopyAcceleratorTableA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int CopyAcceleratorTableA(HACCEL hAccelSrc, LPACCEL lpAccelDst, int cAccelEntries)
     * }
     */
    public static int CopyAcceleratorTableA(MemorySegment hAccelSrc, MemorySegment lpAccelDst, int cAccelEntries) {
        var mh$ = CopyAcceleratorTableA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CopyAcceleratorTableA", hAccelSrc, lpAccelDst, cAccelEntries);
            }
            return (int)mh$.invokeExact(hAccelSrc, lpAccelDst, cAccelEntries);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CopyAcceleratorTableW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CopyAcceleratorTableW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int CopyAcceleratorTableW(HACCEL hAccelSrc, LPACCEL lpAccelDst, int cAccelEntries)
     * }
     */
    public static FunctionDescriptor CopyAcceleratorTableW$descriptor() {
        return CopyAcceleratorTableW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int CopyAcceleratorTableW(HACCEL hAccelSrc, LPACCEL lpAccelDst, int cAccelEntries)
     * }
     */
    public static MethodHandle CopyAcceleratorTableW$handle() {
        return CopyAcceleratorTableW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int CopyAcceleratorTableW(HACCEL hAccelSrc, LPACCEL lpAccelDst, int cAccelEntries)
     * }
     */
    public static int CopyAcceleratorTableW(MemorySegment hAccelSrc, MemorySegment lpAccelDst, int cAccelEntries) {
        var mh$ = CopyAcceleratorTableW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CopyAcceleratorTableW", hAccelSrc, lpAccelDst, cAccelEntries);
            }
            return (int)mh$.invokeExact(hAccelSrc, lpAccelDst, cAccelEntries);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TranslateAcceleratorA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("TranslateAcceleratorA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int TranslateAcceleratorA(HWND hWnd, HACCEL hAccTable, LPMSG lpMsg)
     * }
     */
    public static FunctionDescriptor TranslateAcceleratorA$descriptor() {
        return TranslateAcceleratorA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int TranslateAcceleratorA(HWND hWnd, HACCEL hAccTable, LPMSG lpMsg)
     * }
     */
    public static MethodHandle TranslateAcceleratorA$handle() {
        return TranslateAcceleratorA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int TranslateAcceleratorA(HWND hWnd, HACCEL hAccTable, LPMSG lpMsg)
     * }
     */
    public static int TranslateAcceleratorA(MemorySegment hWnd, MemorySegment hAccTable, MemorySegment lpMsg) {
        var mh$ = TranslateAcceleratorA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TranslateAcceleratorA", hWnd, hAccTable, lpMsg);
            }
            return (int)mh$.invokeExact(hWnd, hAccTable, lpMsg);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TranslateAcceleratorW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("TranslateAcceleratorW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int TranslateAcceleratorW(HWND hWnd, HACCEL hAccTable, LPMSG lpMsg)
     * }
     */
    public static FunctionDescriptor TranslateAcceleratorW$descriptor() {
        return TranslateAcceleratorW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int TranslateAcceleratorW(HWND hWnd, HACCEL hAccTable, LPMSG lpMsg)
     * }
     */
    public static MethodHandle TranslateAcceleratorW$handle() {
        return TranslateAcceleratorW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int TranslateAcceleratorW(HWND hWnd, HACCEL hAccTable, LPMSG lpMsg)
     * }
     */
    public static int TranslateAcceleratorW(MemorySegment hWnd, MemorySegment hAccTable, MemorySegment lpMsg) {
        var mh$ = TranslateAcceleratorW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TranslateAcceleratorW", hWnd, hAccTable, lpMsg);
            }
            return (int)mh$.invokeExact(hWnd, hAccTable, lpMsg);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetSystemMetrics {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetSystemMetrics"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int GetSystemMetrics(int nIndex)
     * }
     */
    public static FunctionDescriptor GetSystemMetrics$descriptor() {
        return GetSystemMetrics.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int GetSystemMetrics(int nIndex)
     * }
     */
    public static MethodHandle GetSystemMetrics$handle() {
        return GetSystemMetrics.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int GetSystemMetrics(int nIndex)
     * }
     */
    public static int GetSystemMetrics(int nIndex) {
        var mh$ = GetSystemMetrics.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetSystemMetrics", nIndex);
            }
            return (int)mh$.invokeExact(nIndex);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetSystemMetricsForDpi {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_INT,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetSystemMetricsForDpi"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int GetSystemMetricsForDpi(int nIndex, UINT dpi)
     * }
     */
    public static FunctionDescriptor GetSystemMetricsForDpi$descriptor() {
        return GetSystemMetricsForDpi.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int GetSystemMetricsForDpi(int nIndex, UINT dpi)
     * }
     */
    public static MethodHandle GetSystemMetricsForDpi$handle() {
        return GetSystemMetricsForDpi.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int GetSystemMetricsForDpi(int nIndex, UINT dpi)
     * }
     */
    public static int GetSystemMetricsForDpi(int nIndex, int dpi) {
        var mh$ = GetSystemMetricsForDpi.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetSystemMetricsForDpi", nIndex, dpi);
            }
            return (int)mh$.invokeExact(nIndex, dpi);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LoadMenuA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("LoadMenuA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HMENU LoadMenuA(HINSTANCE hInstance, LPCSTR lpMenuName)
     * }
     */
    public static FunctionDescriptor LoadMenuA$descriptor() {
        return LoadMenuA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HMENU LoadMenuA(HINSTANCE hInstance, LPCSTR lpMenuName)
     * }
     */
    public static MethodHandle LoadMenuA$handle() {
        return LoadMenuA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * HMENU LoadMenuA(HINSTANCE hInstance, LPCSTR lpMenuName)
     * }
     */
    public static MemorySegment LoadMenuA(MemorySegment hInstance, MemorySegment lpMenuName) {
        var mh$ = LoadMenuA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LoadMenuA", hInstance, lpMenuName);
            }
            return (MemorySegment)mh$.invokeExact(hInstance, lpMenuName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LoadMenuW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("LoadMenuW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HMENU LoadMenuW(HINSTANCE hInstance, LPCWSTR lpMenuName)
     * }
     */
    public static FunctionDescriptor LoadMenuW$descriptor() {
        return LoadMenuW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HMENU LoadMenuW(HINSTANCE hInstance, LPCWSTR lpMenuName)
     * }
     */
    public static MethodHandle LoadMenuW$handle() {
        return LoadMenuW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * HMENU LoadMenuW(HINSTANCE hInstance, LPCWSTR lpMenuName)
     * }
     */
    public static MemorySegment LoadMenuW(MemorySegment hInstance, MemorySegment lpMenuName) {
        var mh$ = LoadMenuW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LoadMenuW", hInstance, lpMenuName);
            }
            return (MemorySegment)mh$.invokeExact(hInstance, lpMenuName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LoadMenuIndirectA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("LoadMenuIndirectA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HMENU LoadMenuIndirectA(const MENUTEMPLATEA *lpMenuTemplate)
     * }
     */
    public static FunctionDescriptor LoadMenuIndirectA$descriptor() {
        return LoadMenuIndirectA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HMENU LoadMenuIndirectA(const MENUTEMPLATEA *lpMenuTemplate)
     * }
     */
    public static MethodHandle LoadMenuIndirectA$handle() {
        return LoadMenuIndirectA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * HMENU LoadMenuIndirectA(const MENUTEMPLATEA *lpMenuTemplate)
     * }
     */
    public static MemorySegment LoadMenuIndirectA(MemorySegment lpMenuTemplate) {
        var mh$ = LoadMenuIndirectA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LoadMenuIndirectA", lpMenuTemplate);
            }
            return (MemorySegment)mh$.invokeExact(lpMenuTemplate);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LoadMenuIndirectW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("LoadMenuIndirectW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HMENU LoadMenuIndirectW(const MENUTEMPLATEW *lpMenuTemplate)
     * }
     */
    public static FunctionDescriptor LoadMenuIndirectW$descriptor() {
        return LoadMenuIndirectW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HMENU LoadMenuIndirectW(const MENUTEMPLATEW *lpMenuTemplate)
     * }
     */
    public static MethodHandle LoadMenuIndirectW$handle() {
        return LoadMenuIndirectW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * HMENU LoadMenuIndirectW(const MENUTEMPLATEW *lpMenuTemplate)
     * }
     */
    public static MemorySegment LoadMenuIndirectW(MemorySegment lpMenuTemplate) {
        var mh$ = LoadMenuIndirectW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LoadMenuIndirectW", lpMenuTemplate);
            }
            return (MemorySegment)mh$.invokeExact(lpMenuTemplate);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetMenu {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetMenu"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HMENU GetMenu(HWND hWnd)
     * }
     */
    public static FunctionDescriptor GetMenu$descriptor() {
        return GetMenu.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HMENU GetMenu(HWND hWnd)
     * }
     */
    public static MethodHandle GetMenu$handle() {
        return GetMenu.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * HMENU GetMenu(HWND hWnd)
     * }
     */
    public static MemorySegment GetMenu(MemorySegment hWnd) {
        var mh$ = GetMenu.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetMenu", hWnd);
            }
            return (MemorySegment)mh$.invokeExact(hWnd);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetMenu {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("SetMenu"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetMenu(HWND hWnd, HMENU hMenu)
     * }
     */
    public static FunctionDescriptor SetMenu$descriptor() {
        return SetMenu.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetMenu(HWND hWnd, HMENU hMenu)
     * }
     */
    public static MethodHandle SetMenu$handle() {
        return SetMenu.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL SetMenu(HWND hWnd, HMENU hMenu)
     * }
     */
    public static int SetMenu(MemorySegment hWnd, MemorySegment hMenu) {
        var mh$ = SetMenu.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetMenu", hWnd, hMenu);
            }
            return (int)mh$.invokeExact(hWnd, hMenu);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ChangeMenuA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_INT,
            C_POINTER,
            C_INT,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("ChangeMenuA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL ChangeMenuA(HMENU hMenu, UINT cmd, LPCSTR lpszNewItem, UINT cmdInsert, UINT flags)
     * }
     */
    public static FunctionDescriptor ChangeMenuA$descriptor() {
        return ChangeMenuA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL ChangeMenuA(HMENU hMenu, UINT cmd, LPCSTR lpszNewItem, UINT cmdInsert, UINT flags)
     * }
     */
    public static MethodHandle ChangeMenuA$handle() {
        return ChangeMenuA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL ChangeMenuA(HMENU hMenu, UINT cmd, LPCSTR lpszNewItem, UINT cmdInsert, UINT flags)
     * }
     */
    public static int ChangeMenuA(MemorySegment hMenu, int cmd, MemorySegment lpszNewItem, int cmdInsert, int flags) {
        var mh$ = ChangeMenuA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ChangeMenuA", hMenu, cmd, lpszNewItem, cmdInsert, flags);
            }
            return (int)mh$.invokeExact(hMenu, cmd, lpszNewItem, cmdInsert, flags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ChangeMenuW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_INT,
            C_POINTER,
            C_INT,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("ChangeMenuW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL ChangeMenuW(HMENU hMenu, UINT cmd, LPCWSTR lpszNewItem, UINT cmdInsert, UINT flags)
     * }
     */
    public static FunctionDescriptor ChangeMenuW$descriptor() {
        return ChangeMenuW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL ChangeMenuW(HMENU hMenu, UINT cmd, LPCWSTR lpszNewItem, UINT cmdInsert, UINT flags)
     * }
     */
    public static MethodHandle ChangeMenuW$handle() {
        return ChangeMenuW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL ChangeMenuW(HMENU hMenu, UINT cmd, LPCWSTR lpszNewItem, UINT cmdInsert, UINT flags)
     * }
     */
    public static int ChangeMenuW(MemorySegment hMenu, int cmd, MemorySegment lpszNewItem, int cmdInsert, int flags) {
        var mh$ = ChangeMenuW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ChangeMenuW", hMenu, cmd, lpszNewItem, cmdInsert, flags);
            }
            return (int)mh$.invokeExact(hMenu, cmd, lpszNewItem, cmdInsert, flags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class HiliteMenuItem {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_INT,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("HiliteMenuItem"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL HiliteMenuItem(HWND hWnd, HMENU hMenu, UINT uIDHiliteItem, UINT uHilite)
     * }
     */
    public static FunctionDescriptor HiliteMenuItem$descriptor() {
        return HiliteMenuItem.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL HiliteMenuItem(HWND hWnd, HMENU hMenu, UINT uIDHiliteItem, UINT uHilite)
     * }
     */
    public static MethodHandle HiliteMenuItem$handle() {
        return HiliteMenuItem.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL HiliteMenuItem(HWND hWnd, HMENU hMenu, UINT uIDHiliteItem, UINT uHilite)
     * }
     */
    public static int HiliteMenuItem(MemorySegment hWnd, MemorySegment hMenu, int uIDHiliteItem, int uHilite) {
        var mh$ = HiliteMenuItem.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("HiliteMenuItem", hWnd, hMenu, uIDHiliteItem, uHilite);
            }
            return (int)mh$.invokeExact(hWnd, hMenu, uIDHiliteItem, uHilite);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetMenuStringA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_INT,
            C_POINTER,
            C_INT,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetMenuStringA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int GetMenuStringA(HMENU hMenu, UINT uIDItem, LPSTR lpString, int cchMax, UINT flags)
     * }
     */
    public static FunctionDescriptor GetMenuStringA$descriptor() {
        return GetMenuStringA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int GetMenuStringA(HMENU hMenu, UINT uIDItem, LPSTR lpString, int cchMax, UINT flags)
     * }
     */
    public static MethodHandle GetMenuStringA$handle() {
        return GetMenuStringA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int GetMenuStringA(HMENU hMenu, UINT uIDItem, LPSTR lpString, int cchMax, UINT flags)
     * }
     */
    public static int GetMenuStringA(MemorySegment hMenu, int uIDItem, MemorySegment lpString, int cchMax, int flags) {
        var mh$ = GetMenuStringA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetMenuStringA", hMenu, uIDItem, lpString, cchMax, flags);
            }
            return (int)mh$.invokeExact(hMenu, uIDItem, lpString, cchMax, flags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetMenuStringW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_INT,
            C_POINTER,
            C_INT,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetMenuStringW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int GetMenuStringW(HMENU hMenu, UINT uIDItem, LPWSTR lpString, int cchMax, UINT flags)
     * }
     */
    public static FunctionDescriptor GetMenuStringW$descriptor() {
        return GetMenuStringW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int GetMenuStringW(HMENU hMenu, UINT uIDItem, LPWSTR lpString, int cchMax, UINT flags)
     * }
     */
    public static MethodHandle GetMenuStringW$handle() {
        return GetMenuStringW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int GetMenuStringW(HMENU hMenu, UINT uIDItem, LPWSTR lpString, int cchMax, UINT flags)
     * }
     */
    public static int GetMenuStringW(MemorySegment hMenu, int uIDItem, MemorySegment lpString, int cchMax, int flags) {
        var mh$ = GetMenuStringW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetMenuStringW", hMenu, uIDItem, lpString, cchMax, flags);
            }
            return (int)mh$.invokeExact(hMenu, uIDItem, lpString, cchMax, flags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetMenuState {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_INT,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetMenuState"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * UINT GetMenuState(HMENU hMenu, UINT uId, UINT uFlags)
     * }
     */
    public static FunctionDescriptor GetMenuState$descriptor() {
        return GetMenuState.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * UINT GetMenuState(HMENU hMenu, UINT uId, UINT uFlags)
     * }
     */
    public static MethodHandle GetMenuState$handle() {
        return GetMenuState.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * UINT GetMenuState(HMENU hMenu, UINT uId, UINT uFlags)
     * }
     */
    public static int GetMenuState(MemorySegment hMenu, int uId, int uFlags) {
        var mh$ = GetMenuState.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetMenuState", hMenu, uId, uFlags);
            }
            return (int)mh$.invokeExact(hMenu, uId, uFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DrawMenuBar {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("DrawMenuBar"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL DrawMenuBar(HWND hWnd)
     * }
     */
    public static FunctionDescriptor DrawMenuBar$descriptor() {
        return DrawMenuBar.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL DrawMenuBar(HWND hWnd)
     * }
     */
    public static MethodHandle DrawMenuBar$handle() {
        return DrawMenuBar.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL DrawMenuBar(HWND hWnd)
     * }
     */
    public static int DrawMenuBar(MemorySegment hWnd) {
        var mh$ = DrawMenuBar.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DrawMenuBar", hWnd);
            }
            return (int)mh$.invokeExact(hWnd);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetSystemMenu {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetSystemMenu"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HMENU GetSystemMenu(HWND hWnd, BOOL bRevert)
     * }
     */
    public static FunctionDescriptor GetSystemMenu$descriptor() {
        return GetSystemMenu.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HMENU GetSystemMenu(HWND hWnd, BOOL bRevert)
     * }
     */
    public static MethodHandle GetSystemMenu$handle() {
        return GetSystemMenu.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * HMENU GetSystemMenu(HWND hWnd, BOOL bRevert)
     * }
     */
    public static MemorySegment GetSystemMenu(MemorySegment hWnd, int bRevert) {
        var mh$ = GetSystemMenu.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetSystemMenu", hWnd, bRevert);
            }
            return (MemorySegment)mh$.invokeExact(hWnd, bRevert);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateMenu {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER    );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CreateMenu"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HMENU CreateMenu()
     * }
     */
    public static FunctionDescriptor CreateMenu$descriptor() {
        return CreateMenu.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HMENU CreateMenu()
     * }
     */
    public static MethodHandle CreateMenu$handle() {
        return CreateMenu.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * HMENU CreateMenu()
     * }
     */
    public static MemorySegment CreateMenu() {
        var mh$ = CreateMenu.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateMenu");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreatePopupMenu {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER    );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CreatePopupMenu"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HMENU CreatePopupMenu()
     * }
     */
    public static FunctionDescriptor CreatePopupMenu$descriptor() {
        return CreatePopupMenu.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HMENU CreatePopupMenu()
     * }
     */
    public static MethodHandle CreatePopupMenu$handle() {
        return CreatePopupMenu.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * HMENU CreatePopupMenu()
     * }
     */
    public static MemorySegment CreatePopupMenu() {
        var mh$ = CreatePopupMenu.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreatePopupMenu");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DestroyMenu {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("DestroyMenu"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL DestroyMenu(HMENU hMenu)
     * }
     */
    public static FunctionDescriptor DestroyMenu$descriptor() {
        return DestroyMenu.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL DestroyMenu(HMENU hMenu)
     * }
     */
    public static MethodHandle DestroyMenu$handle() {
        return DestroyMenu.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL DestroyMenu(HMENU hMenu)
     * }
     */
    public static int DestroyMenu(MemorySegment hMenu) {
        var mh$ = DestroyMenu.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DestroyMenu", hMenu);
            }
            return (int)mh$.invokeExact(hMenu);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CheckMenuItem {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_POINTER,
            C_INT,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CheckMenuItem"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD CheckMenuItem(HMENU hMenu, UINT uIDCheckItem, UINT uCheck)
     * }
     */
    public static FunctionDescriptor CheckMenuItem$descriptor() {
        return CheckMenuItem.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD CheckMenuItem(HMENU hMenu, UINT uIDCheckItem, UINT uCheck)
     * }
     */
    public static MethodHandle CheckMenuItem$handle() {
        return CheckMenuItem.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * DWORD CheckMenuItem(HMENU hMenu, UINT uIDCheckItem, UINT uCheck)
     * }
     */
    public static int CheckMenuItem(MemorySegment hMenu, int uIDCheckItem, int uCheck) {
        var mh$ = CheckMenuItem.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CheckMenuItem", hMenu, uIDCheckItem, uCheck);
            }
            return (int)mh$.invokeExact(hMenu, uIDCheckItem, uCheck);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class EnableMenuItem {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_INT,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("EnableMenuItem"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL EnableMenuItem(HMENU hMenu, UINT uIDEnableItem, UINT uEnable)
     * }
     */
    public static FunctionDescriptor EnableMenuItem$descriptor() {
        return EnableMenuItem.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL EnableMenuItem(HMENU hMenu, UINT uIDEnableItem, UINT uEnable)
     * }
     */
    public static MethodHandle EnableMenuItem$handle() {
        return EnableMenuItem.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL EnableMenuItem(HMENU hMenu, UINT uIDEnableItem, UINT uEnable)
     * }
     */
    public static int EnableMenuItem(MemorySegment hMenu, int uIDEnableItem, int uEnable) {
        var mh$ = EnableMenuItem.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("EnableMenuItem", hMenu, uIDEnableItem, uEnable);
            }
            return (int)mh$.invokeExact(hMenu, uIDEnableItem, uEnable);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetSubMenu {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetSubMenu"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HMENU GetSubMenu(HMENU hMenu, int nPos)
     * }
     */
    public static FunctionDescriptor GetSubMenu$descriptor() {
        return GetSubMenu.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HMENU GetSubMenu(HMENU hMenu, int nPos)
     * }
     */
    public static MethodHandle GetSubMenu$handle() {
        return GetSubMenu.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * HMENU GetSubMenu(HMENU hMenu, int nPos)
     * }
     */
    public static MemorySegment GetSubMenu(MemorySegment hMenu, int nPos) {
        var mh$ = GetSubMenu.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetSubMenu", hMenu, nPos);
            }
            return (MemorySegment)mh$.invokeExact(hMenu, nPos);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetMenuItemID {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetMenuItemID"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * UINT GetMenuItemID(HMENU hMenu, int nPos)
     * }
     */
    public static FunctionDescriptor GetMenuItemID$descriptor() {
        return GetMenuItemID.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * UINT GetMenuItemID(HMENU hMenu, int nPos)
     * }
     */
    public static MethodHandle GetMenuItemID$handle() {
        return GetMenuItemID.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * UINT GetMenuItemID(HMENU hMenu, int nPos)
     * }
     */
    public static int GetMenuItemID(MemorySegment hMenu, int nPos) {
        var mh$ = GetMenuItemID.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetMenuItemID", hMenu, nPos);
            }
            return (int)mh$.invokeExact(hMenu, nPos);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetMenuItemCount {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetMenuItemCount"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int GetMenuItemCount(HMENU hMenu)
     * }
     */
    public static FunctionDescriptor GetMenuItemCount$descriptor() {
        return GetMenuItemCount.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int GetMenuItemCount(HMENU hMenu)
     * }
     */
    public static MethodHandle GetMenuItemCount$handle() {
        return GetMenuItemCount.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int GetMenuItemCount(HMENU hMenu)
     * }
     */
    public static int GetMenuItemCount(MemorySegment hMenu) {
        var mh$ = GetMenuItemCount.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetMenuItemCount", hMenu);
            }
            return (int)mh$.invokeExact(hMenu);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class InsertMenuA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_INT,
            C_INT,
            C_LONG_LONG,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("InsertMenuA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL InsertMenuA(HMENU hMenu, UINT uPosition, UINT uFlags, UINT_PTR uIDNewItem, LPCSTR lpNewItem)
     * }
     */
    public static FunctionDescriptor InsertMenuA$descriptor() {
        return InsertMenuA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL InsertMenuA(HMENU hMenu, UINT uPosition, UINT uFlags, UINT_PTR uIDNewItem, LPCSTR lpNewItem)
     * }
     */
    public static MethodHandle InsertMenuA$handle() {
        return InsertMenuA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL InsertMenuA(HMENU hMenu, UINT uPosition, UINT uFlags, UINT_PTR uIDNewItem, LPCSTR lpNewItem)
     * }
     */
    public static int InsertMenuA(MemorySegment hMenu, int uPosition, int uFlags, long uIDNewItem, MemorySegment lpNewItem) {
        var mh$ = InsertMenuA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("InsertMenuA", hMenu, uPosition, uFlags, uIDNewItem, lpNewItem);
            }
            return (int)mh$.invokeExact(hMenu, uPosition, uFlags, uIDNewItem, lpNewItem);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class InsertMenuW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_INT,
            C_INT,
            C_LONG_LONG,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("InsertMenuW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL InsertMenuW(HMENU hMenu, UINT uPosition, UINT uFlags, UINT_PTR uIDNewItem, LPCWSTR lpNewItem)
     * }
     */
    public static FunctionDescriptor InsertMenuW$descriptor() {
        return InsertMenuW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL InsertMenuW(HMENU hMenu, UINT uPosition, UINT uFlags, UINT_PTR uIDNewItem, LPCWSTR lpNewItem)
     * }
     */
    public static MethodHandle InsertMenuW$handle() {
        return InsertMenuW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL InsertMenuW(HMENU hMenu, UINT uPosition, UINT uFlags, UINT_PTR uIDNewItem, LPCWSTR lpNewItem)
     * }
     */
    public static int InsertMenuW(MemorySegment hMenu, int uPosition, int uFlags, long uIDNewItem, MemorySegment lpNewItem) {
        var mh$ = InsertMenuW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("InsertMenuW", hMenu, uPosition, uFlags, uIDNewItem, lpNewItem);
            }
            return (int)mh$.invokeExact(hMenu, uPosition, uFlags, uIDNewItem, lpNewItem);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class AppendMenuA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_INT,
            C_LONG_LONG,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("AppendMenuA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL AppendMenuA(HMENU hMenu, UINT uFlags, UINT_PTR uIDNewItem, LPCSTR lpNewItem)
     * }
     */
    public static FunctionDescriptor AppendMenuA$descriptor() {
        return AppendMenuA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL AppendMenuA(HMENU hMenu, UINT uFlags, UINT_PTR uIDNewItem, LPCSTR lpNewItem)
     * }
     */
    public static MethodHandle AppendMenuA$handle() {
        return AppendMenuA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL AppendMenuA(HMENU hMenu, UINT uFlags, UINT_PTR uIDNewItem, LPCSTR lpNewItem)
     * }
     */
    public static int AppendMenuA(MemorySegment hMenu, int uFlags, long uIDNewItem, MemorySegment lpNewItem) {
        var mh$ = AppendMenuA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("AppendMenuA", hMenu, uFlags, uIDNewItem, lpNewItem);
            }
            return (int)mh$.invokeExact(hMenu, uFlags, uIDNewItem, lpNewItem);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class AppendMenuW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_INT,
            C_LONG_LONG,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("AppendMenuW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL AppendMenuW(HMENU hMenu, UINT uFlags, UINT_PTR uIDNewItem, LPCWSTR lpNewItem)
     * }
     */
    public static FunctionDescriptor AppendMenuW$descriptor() {
        return AppendMenuW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL AppendMenuW(HMENU hMenu, UINT uFlags, UINT_PTR uIDNewItem, LPCWSTR lpNewItem)
     * }
     */
    public static MethodHandle AppendMenuW$handle() {
        return AppendMenuW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL AppendMenuW(HMENU hMenu, UINT uFlags, UINT_PTR uIDNewItem, LPCWSTR lpNewItem)
     * }
     */
    public static int AppendMenuW(MemorySegment hMenu, int uFlags, long uIDNewItem, MemorySegment lpNewItem) {
        var mh$ = AppendMenuW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("AppendMenuW", hMenu, uFlags, uIDNewItem, lpNewItem);
            }
            return (int)mh$.invokeExact(hMenu, uFlags, uIDNewItem, lpNewItem);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ModifyMenuA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_INT,
            C_INT,
            C_LONG_LONG,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("ModifyMenuA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL ModifyMenuA(HMENU hMnu, UINT uPosition, UINT uFlags, UINT_PTR uIDNewItem, LPCSTR lpNewItem)
     * }
     */
    public static FunctionDescriptor ModifyMenuA$descriptor() {
        return ModifyMenuA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL ModifyMenuA(HMENU hMnu, UINT uPosition, UINT uFlags, UINT_PTR uIDNewItem, LPCSTR lpNewItem)
     * }
     */
    public static MethodHandle ModifyMenuA$handle() {
        return ModifyMenuA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL ModifyMenuA(HMENU hMnu, UINT uPosition, UINT uFlags, UINT_PTR uIDNewItem, LPCSTR lpNewItem)
     * }
     */
    public static int ModifyMenuA(MemorySegment hMnu, int uPosition, int uFlags, long uIDNewItem, MemorySegment lpNewItem) {
        var mh$ = ModifyMenuA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ModifyMenuA", hMnu, uPosition, uFlags, uIDNewItem, lpNewItem);
            }
            return (int)mh$.invokeExact(hMnu, uPosition, uFlags, uIDNewItem, lpNewItem);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ModifyMenuW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_INT,
            C_INT,
            C_LONG_LONG,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("ModifyMenuW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL ModifyMenuW(HMENU hMnu, UINT uPosition, UINT uFlags, UINT_PTR uIDNewItem, LPCWSTR lpNewItem)
     * }
     */
    public static FunctionDescriptor ModifyMenuW$descriptor() {
        return ModifyMenuW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL ModifyMenuW(HMENU hMnu, UINT uPosition, UINT uFlags, UINT_PTR uIDNewItem, LPCWSTR lpNewItem)
     * }
     */
    public static MethodHandle ModifyMenuW$handle() {
        return ModifyMenuW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL ModifyMenuW(HMENU hMnu, UINT uPosition, UINT uFlags, UINT_PTR uIDNewItem, LPCWSTR lpNewItem)
     * }
     */
    public static int ModifyMenuW(MemorySegment hMnu, int uPosition, int uFlags, long uIDNewItem, MemorySegment lpNewItem) {
        var mh$ = ModifyMenuW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ModifyMenuW", hMnu, uPosition, uFlags, uIDNewItem, lpNewItem);
            }
            return (int)mh$.invokeExact(hMnu, uPosition, uFlags, uIDNewItem, lpNewItem);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RemoveMenu {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_INT,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("RemoveMenu"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL RemoveMenu(HMENU hMenu, UINT uPosition, UINT uFlags)
     * }
     */
    public static FunctionDescriptor RemoveMenu$descriptor() {
        return RemoveMenu.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL RemoveMenu(HMENU hMenu, UINT uPosition, UINT uFlags)
     * }
     */
    public static MethodHandle RemoveMenu$handle() {
        return RemoveMenu.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL RemoveMenu(HMENU hMenu, UINT uPosition, UINT uFlags)
     * }
     */
    public static int RemoveMenu(MemorySegment hMenu, int uPosition, int uFlags) {
        var mh$ = RemoveMenu.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RemoveMenu", hMenu, uPosition, uFlags);
            }
            return (int)mh$.invokeExact(hMenu, uPosition, uFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DeleteMenu {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_INT,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("DeleteMenu"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL DeleteMenu(HMENU hMenu, UINT uPosition, UINT uFlags)
     * }
     */
    public static FunctionDescriptor DeleteMenu$descriptor() {
        return DeleteMenu.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL DeleteMenu(HMENU hMenu, UINT uPosition, UINT uFlags)
     * }
     */
    public static MethodHandle DeleteMenu$handle() {
        return DeleteMenu.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL DeleteMenu(HMENU hMenu, UINT uPosition, UINT uFlags)
     * }
     */
    public static int DeleteMenu(MemorySegment hMenu, int uPosition, int uFlags) {
        var mh$ = DeleteMenu.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DeleteMenu", hMenu, uPosition, uFlags);
            }
            return (int)mh$.invokeExact(hMenu, uPosition, uFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetMenuItemBitmaps {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_INT,
            C_INT,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("SetMenuItemBitmaps"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetMenuItemBitmaps(HMENU hMenu, UINT uPosition, UINT uFlags, HBITMAP hBitmapUnchecked, HBITMAP hBitmapChecked)
     * }
     */
    public static FunctionDescriptor SetMenuItemBitmaps$descriptor() {
        return SetMenuItemBitmaps.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetMenuItemBitmaps(HMENU hMenu, UINT uPosition, UINT uFlags, HBITMAP hBitmapUnchecked, HBITMAP hBitmapChecked)
     * }
     */
    public static MethodHandle SetMenuItemBitmaps$handle() {
        return SetMenuItemBitmaps.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL SetMenuItemBitmaps(HMENU hMenu, UINT uPosition, UINT uFlags, HBITMAP hBitmapUnchecked, HBITMAP hBitmapChecked)
     * }
     */
    public static int SetMenuItemBitmaps(MemorySegment hMenu, int uPosition, int uFlags, MemorySegment hBitmapUnchecked, MemorySegment hBitmapChecked) {
        var mh$ = SetMenuItemBitmaps.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetMenuItemBitmaps", hMenu, uPosition, uFlags, hBitmapUnchecked, hBitmapChecked);
            }
            return (int)mh$.invokeExact(hMenu, uPosition, uFlags, hBitmapUnchecked, hBitmapChecked);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetMenuCheckMarkDimensions {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG    );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetMenuCheckMarkDimensions"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LONG GetMenuCheckMarkDimensions()
     * }
     */
    public static FunctionDescriptor GetMenuCheckMarkDimensions$descriptor() {
        return GetMenuCheckMarkDimensions.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LONG GetMenuCheckMarkDimensions()
     * }
     */
    public static MethodHandle GetMenuCheckMarkDimensions$handle() {
        return GetMenuCheckMarkDimensions.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * LONG GetMenuCheckMarkDimensions()
     * }
     */
    public static int GetMenuCheckMarkDimensions() {
        var mh$ = GetMenuCheckMarkDimensions.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetMenuCheckMarkDimensions");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TrackPopupMenu {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_INT,
            C_INT,
            C_INT,
            C_INT,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("TrackPopupMenu"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL TrackPopupMenu(HMENU hMenu, UINT uFlags, int x, int y, int nReserved, HWND hWnd, const RECT *prcRect)
     * }
     */
    public static FunctionDescriptor TrackPopupMenu$descriptor() {
        return TrackPopupMenu.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL TrackPopupMenu(HMENU hMenu, UINT uFlags, int x, int y, int nReserved, HWND hWnd, const RECT *prcRect)
     * }
     */
    public static MethodHandle TrackPopupMenu$handle() {
        return TrackPopupMenu.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL TrackPopupMenu(HMENU hMenu, UINT uFlags, int x, int y, int nReserved, HWND hWnd, const RECT *prcRect)
     * }
     */
    public static int TrackPopupMenu(MemorySegment hMenu, int uFlags, int x, int y, int nReserved, MemorySegment hWnd, MemorySegment prcRect) {
        var mh$ = TrackPopupMenu.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TrackPopupMenu", hMenu, uFlags, x, y, nReserved, hWnd, prcRect);
            }
            return (int)mh$.invokeExact(hMenu, uFlags, x, y, nReserved, hWnd, prcRect);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef TPMPARAMS *LPTPMPARAMS
     * }
     */
    public static final AddressLayout LPTPMPARAMS = C_POINTER;

    private static class TrackPopupMenuEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_INT,
            C_INT,
            C_INT,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("TrackPopupMenuEx"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL TrackPopupMenuEx(HMENU hMenu, UINT uFlags, int x, int y, HWND hwnd, LPTPMPARAMS lptpm)
     * }
     */
    public static FunctionDescriptor TrackPopupMenuEx$descriptor() {
        return TrackPopupMenuEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL TrackPopupMenuEx(HMENU hMenu, UINT uFlags, int x, int y, HWND hwnd, LPTPMPARAMS lptpm)
     * }
     */
    public static MethodHandle TrackPopupMenuEx$handle() {
        return TrackPopupMenuEx.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL TrackPopupMenuEx(HMENU hMenu, UINT uFlags, int x, int y, HWND hwnd, LPTPMPARAMS lptpm)
     * }
     */
    public static int TrackPopupMenuEx(MemorySegment hMenu, int uFlags, int x, int y, MemorySegment hwnd, MemorySegment lptpm) {
        var mh$ = TrackPopupMenuEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TrackPopupMenuEx", hMenu, uFlags, x, y, hwnd, lptpm);
            }
            return (int)mh$.invokeExact(hMenu, uFlags, x, y, hwnd, lptpm);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CalculatePopupWindowPosition {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_INT,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CalculatePopupWindowPosition"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CalculatePopupWindowPosition(const POINT *anchorPoint, const SIZE *windowSize, UINT flags, RECT *excludeRect, RECT *popupWindowPosition)
     * }
     */
    public static FunctionDescriptor CalculatePopupWindowPosition$descriptor() {
        return CalculatePopupWindowPosition.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CalculatePopupWindowPosition(const POINT *anchorPoint, const SIZE *windowSize, UINT flags, RECT *excludeRect, RECT *popupWindowPosition)
     * }
     */
    public static MethodHandle CalculatePopupWindowPosition$handle() {
        return CalculatePopupWindowPosition.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL CalculatePopupWindowPosition(const POINT *anchorPoint, const SIZE *windowSize, UINT flags, RECT *excludeRect, RECT *popupWindowPosition)
     * }
     */
    public static int CalculatePopupWindowPosition(MemorySegment anchorPoint, MemorySegment windowSize, int flags, MemorySegment excludeRect, MemorySegment popupWindowPosition) {
        var mh$ = CalculatePopupWindowPosition.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CalculatePopupWindowPosition", anchorPoint, windowSize, flags, excludeRect, popupWindowPosition);
            }
            return (int)mh$.invokeExact(anchorPoint, windowSize, flags, excludeRect, popupWindowPosition);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct tagMENUINFO {
     *     DWORD cbSize;
     *     DWORD fMask;
     *     DWORD dwStyle;
     *     UINT cyMax;
     *     HBRUSH hbrBack;
     *     DWORD dwContextHelpID;
     *     ULONG_PTR dwMenuData;
     * } *LPMENUINFO
     * }
     */
    public static final AddressLayout LPMENUINFO = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef const MENUINFO *LPCMENUINFO
     * }
     */
    public static final AddressLayout LPCMENUINFO = C_POINTER;

    private static class GetMenuInfo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetMenuInfo"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetMenuInfo(HMENU, LPMENUINFO)
     * }
     */
    public static FunctionDescriptor GetMenuInfo$descriptor() {
        return GetMenuInfo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetMenuInfo(HMENU, LPMENUINFO)
     * }
     */
    public static MethodHandle GetMenuInfo$handle() {
        return GetMenuInfo.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL GetMenuInfo(HMENU, LPMENUINFO)
     * }
     */
    public static int GetMenuInfo(MemorySegment x0, MemorySegment x1) {
        var mh$ = GetMenuInfo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetMenuInfo", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetMenuInfo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("SetMenuInfo"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetMenuInfo(HMENU, LPCMENUINFO)
     * }
     */
    public static FunctionDescriptor SetMenuInfo$descriptor() {
        return SetMenuInfo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetMenuInfo(HMENU, LPCMENUINFO)
     * }
     */
    public static MethodHandle SetMenuInfo$handle() {
        return SetMenuInfo.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL SetMenuInfo(HMENU, LPCMENUINFO)
     * }
     */
    public static int SetMenuInfo(MemorySegment x0, MemorySegment x1) {
        var mh$ = SetMenuInfo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetMenuInfo", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class EndMenu {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT    );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("EndMenu"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL EndMenu()
     * }
     */
    public static FunctionDescriptor EndMenu$descriptor() {
        return EndMenu.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL EndMenu()
     * }
     */
    public static MethodHandle EndMenu$handle() {
        return EndMenu.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL EndMenu()
     * }
     */
    public static int EndMenu() {
        var mh$ = EndMenu.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("EndMenu");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct tagMENUGETOBJECTINFO {
     *     DWORD dwFlags;
     *     UINT uPos;
     *     HMENU hmenu;
     *     PVOID riid;
     *     PVOID pvObj;
     * } *PMENUGETOBJECTINFO
     * }
     */
    public static final AddressLayout PMENUGETOBJECTINFO = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagMENUITEMINFOA {
     *     UINT cbSize;
     *     UINT fMask;
     *     UINT fType;
     *     UINT fState;
     *     UINT wID;
     *     HMENU hSubMenu;
     *     HBITMAP hbmpChecked;
     *     HBITMAP hbmpUnchecked;
     *     ULONG_PTR dwItemData;
     *     LPSTR dwTypeData;
     *     UINT cch;
     *     HBITMAP hbmpItem;
     * } *LPMENUITEMINFOA
     * }
     */
    public static final AddressLayout LPMENUITEMINFOA = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagMENUITEMINFOW {
     *     UINT cbSize;
     *     UINT fMask;
     *     UINT fType;
     *     UINT fState;
     *     UINT wID;
     *     HMENU hSubMenu;
     *     HBITMAP hbmpChecked;
     *     HBITMAP hbmpUnchecked;
     *     ULONG_PTR dwItemData;
     *     LPWSTR dwTypeData;
     *     UINT cch;
     *     HBITMAP hbmpItem;
     * } *LPMENUITEMINFOW
     * }
     */
    public static final AddressLayout LPMENUITEMINFOW = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef LPMENUITEMINFOA LPMENUITEMINFO
     * }
     */
    public static final AddressLayout LPMENUITEMINFO = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef const MENUITEMINFOA *LPCMENUITEMINFOA
     * }
     */
    public static final AddressLayout LPCMENUITEMINFOA = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef const MENUITEMINFOW *LPCMENUITEMINFOW
     * }
     */
    public static final AddressLayout LPCMENUITEMINFOW = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef LPCMENUITEMINFOA LPCMENUITEMINFO
     * }
     */
    public static final AddressLayout LPCMENUITEMINFO = C_POINTER;

    private static class InsertMenuItemA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_INT,
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("InsertMenuItemA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL InsertMenuItemA(HMENU hmenu, UINT item, BOOL fByPosition, LPCMENUITEMINFOA lpmi)
     * }
     */
    public static FunctionDescriptor InsertMenuItemA$descriptor() {
        return InsertMenuItemA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL InsertMenuItemA(HMENU hmenu, UINT item, BOOL fByPosition, LPCMENUITEMINFOA lpmi)
     * }
     */
    public static MethodHandle InsertMenuItemA$handle() {
        return InsertMenuItemA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL InsertMenuItemA(HMENU hmenu, UINT item, BOOL fByPosition, LPCMENUITEMINFOA lpmi)
     * }
     */
    public static int InsertMenuItemA(MemorySegment hmenu, int item, int fByPosition, MemorySegment lpmi) {
        var mh$ = InsertMenuItemA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("InsertMenuItemA", hmenu, item, fByPosition, lpmi);
            }
            return (int)mh$.invokeExact(hmenu, item, fByPosition, lpmi);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class InsertMenuItemW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_INT,
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("InsertMenuItemW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL InsertMenuItemW(HMENU hmenu, UINT item, BOOL fByPosition, LPCMENUITEMINFOW lpmi)
     * }
     */
    public static FunctionDescriptor InsertMenuItemW$descriptor() {
        return InsertMenuItemW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL InsertMenuItemW(HMENU hmenu, UINT item, BOOL fByPosition, LPCMENUITEMINFOW lpmi)
     * }
     */
    public static MethodHandle InsertMenuItemW$handle() {
        return InsertMenuItemW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL InsertMenuItemW(HMENU hmenu, UINT item, BOOL fByPosition, LPCMENUITEMINFOW lpmi)
     * }
     */
    public static int InsertMenuItemW(MemorySegment hmenu, int item, int fByPosition, MemorySegment lpmi) {
        var mh$ = InsertMenuItemW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("InsertMenuItemW", hmenu, item, fByPosition, lpmi);
            }
            return (int)mh$.invokeExact(hmenu, item, fByPosition, lpmi);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetMenuItemInfoA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_INT,
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetMenuItemInfoA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetMenuItemInfoA(HMENU hmenu, UINT item, BOOL fByPosition, LPMENUITEMINFOA lpmii)
     * }
     */
    public static FunctionDescriptor GetMenuItemInfoA$descriptor() {
        return GetMenuItemInfoA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetMenuItemInfoA(HMENU hmenu, UINT item, BOOL fByPosition, LPMENUITEMINFOA lpmii)
     * }
     */
    public static MethodHandle GetMenuItemInfoA$handle() {
        return GetMenuItemInfoA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL GetMenuItemInfoA(HMENU hmenu, UINT item, BOOL fByPosition, LPMENUITEMINFOA lpmii)
     * }
     */
    public static int GetMenuItemInfoA(MemorySegment hmenu, int item, int fByPosition, MemorySegment lpmii) {
        var mh$ = GetMenuItemInfoA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetMenuItemInfoA", hmenu, item, fByPosition, lpmii);
            }
            return (int)mh$.invokeExact(hmenu, item, fByPosition, lpmii);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetMenuItemInfoW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_INT,
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetMenuItemInfoW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetMenuItemInfoW(HMENU hmenu, UINT item, BOOL fByPosition, LPMENUITEMINFOW lpmii)
     * }
     */
    public static FunctionDescriptor GetMenuItemInfoW$descriptor() {
        return GetMenuItemInfoW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetMenuItemInfoW(HMENU hmenu, UINT item, BOOL fByPosition, LPMENUITEMINFOW lpmii)
     * }
     */
    public static MethodHandle GetMenuItemInfoW$handle() {
        return GetMenuItemInfoW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL GetMenuItemInfoW(HMENU hmenu, UINT item, BOOL fByPosition, LPMENUITEMINFOW lpmii)
     * }
     */
    public static int GetMenuItemInfoW(MemorySegment hmenu, int item, int fByPosition, MemorySegment lpmii) {
        var mh$ = GetMenuItemInfoW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetMenuItemInfoW", hmenu, item, fByPosition, lpmii);
            }
            return (int)mh$.invokeExact(hmenu, item, fByPosition, lpmii);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetMenuItemInfoA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_INT,
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("SetMenuItemInfoA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetMenuItemInfoA(HMENU hmenu, UINT item, BOOL fByPositon, LPCMENUITEMINFOA lpmii)
     * }
     */
    public static FunctionDescriptor SetMenuItemInfoA$descriptor() {
        return SetMenuItemInfoA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetMenuItemInfoA(HMENU hmenu, UINT item, BOOL fByPositon, LPCMENUITEMINFOA lpmii)
     * }
     */
    public static MethodHandle SetMenuItemInfoA$handle() {
        return SetMenuItemInfoA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL SetMenuItemInfoA(HMENU hmenu, UINT item, BOOL fByPositon, LPCMENUITEMINFOA lpmii)
     * }
     */
    public static int SetMenuItemInfoA(MemorySegment hmenu, int item, int fByPositon, MemorySegment lpmii) {
        var mh$ = SetMenuItemInfoA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetMenuItemInfoA", hmenu, item, fByPositon, lpmii);
            }
            return (int)mh$.invokeExact(hmenu, item, fByPositon, lpmii);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetMenuItemInfoW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_INT,
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("SetMenuItemInfoW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetMenuItemInfoW(HMENU hmenu, UINT item, BOOL fByPositon, LPCMENUITEMINFOW lpmii)
     * }
     */
    public static FunctionDescriptor SetMenuItemInfoW$descriptor() {
        return SetMenuItemInfoW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetMenuItemInfoW(HMENU hmenu, UINT item, BOOL fByPositon, LPCMENUITEMINFOW lpmii)
     * }
     */
    public static MethodHandle SetMenuItemInfoW$handle() {
        return SetMenuItemInfoW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL SetMenuItemInfoW(HMENU hmenu, UINT item, BOOL fByPositon, LPCMENUITEMINFOW lpmii)
     * }
     */
    public static int SetMenuItemInfoW(MemorySegment hmenu, int item, int fByPositon, MemorySegment lpmii) {
        var mh$ = SetMenuItemInfoW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetMenuItemInfoW", hmenu, item, fByPositon, lpmii);
            }
            return (int)mh$.invokeExact(hmenu, item, fByPositon, lpmii);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetMenuDefaultItem {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_INT,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetMenuDefaultItem"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * UINT GetMenuDefaultItem(HMENU hMenu, UINT fByPos, UINT gmdiFlags)
     * }
     */
    public static FunctionDescriptor GetMenuDefaultItem$descriptor() {
        return GetMenuDefaultItem.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * UINT GetMenuDefaultItem(HMENU hMenu, UINT fByPos, UINT gmdiFlags)
     * }
     */
    public static MethodHandle GetMenuDefaultItem$handle() {
        return GetMenuDefaultItem.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * UINT GetMenuDefaultItem(HMENU hMenu, UINT fByPos, UINT gmdiFlags)
     * }
     */
    public static int GetMenuDefaultItem(MemorySegment hMenu, int fByPos, int gmdiFlags) {
        var mh$ = GetMenuDefaultItem.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetMenuDefaultItem", hMenu, fByPos, gmdiFlags);
            }
            return (int)mh$.invokeExact(hMenu, fByPos, gmdiFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetMenuDefaultItem {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_INT,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("SetMenuDefaultItem"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetMenuDefaultItem(HMENU hMenu, UINT uItem, UINT fByPos)
     * }
     */
    public static FunctionDescriptor SetMenuDefaultItem$descriptor() {
        return SetMenuDefaultItem.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetMenuDefaultItem(HMENU hMenu, UINT uItem, UINT fByPos)
     * }
     */
    public static MethodHandle SetMenuDefaultItem$handle() {
        return SetMenuDefaultItem.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL SetMenuDefaultItem(HMENU hMenu, UINT uItem, UINT fByPos)
     * }
     */
    public static int SetMenuDefaultItem(MemorySegment hMenu, int uItem, int fByPos) {
        var mh$ = SetMenuDefaultItem.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetMenuDefaultItem", hMenu, uItem, fByPos);
            }
            return (int)mh$.invokeExact(hMenu, uItem, fByPos);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetMenuItemRect {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetMenuItemRect"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetMenuItemRect(HWND hWnd, HMENU hMenu, UINT uItem, LPRECT lprcItem)
     * }
     */
    public static FunctionDescriptor GetMenuItemRect$descriptor() {
        return GetMenuItemRect.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetMenuItemRect(HWND hWnd, HMENU hMenu, UINT uItem, LPRECT lprcItem)
     * }
     */
    public static MethodHandle GetMenuItemRect$handle() {
        return GetMenuItemRect.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL GetMenuItemRect(HWND hWnd, HMENU hMenu, UINT uItem, LPRECT lprcItem)
     * }
     */
    public static int GetMenuItemRect(MemorySegment hWnd, MemorySegment hMenu, int uItem, MemorySegment lprcItem) {
        var mh$ = GetMenuItemRect.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetMenuItemRect", hWnd, hMenu, uItem, lprcItem);
            }
            return (int)mh$.invokeExact(hWnd, hMenu, uItem, lprcItem);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MenuItemFromPoint {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            tagPOINT.layout()
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("MenuItemFromPoint"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int MenuItemFromPoint(HWND hWnd, HMENU hMenu, POINT ptScreen)
     * }
     */
    public static FunctionDescriptor MenuItemFromPoint$descriptor() {
        return MenuItemFromPoint.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int MenuItemFromPoint(HWND hWnd, HMENU hMenu, POINT ptScreen)
     * }
     */
    public static MethodHandle MenuItemFromPoint$handle() {
        return MenuItemFromPoint.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int MenuItemFromPoint(HWND hWnd, HMENU hMenu, POINT ptScreen)
     * }
     */
    public static int MenuItemFromPoint(MemorySegment hWnd, MemorySegment hMenu, MemorySegment ptScreen) {
        var mh$ = MenuItemFromPoint.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MenuItemFromPoint", hWnd, hMenu, ptScreen);
            }
            return (int)mh$.invokeExact(hWnd, hMenu, ptScreen);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct tagDROPSTRUCT {
     *     HWND hwndSource;
     *     HWND hwndSink;
     *     DWORD wFmt;
     *     ULONG_PTR dwData;
     *     POINT ptDrop;
     *     DWORD dwControlData;
     * } *PDROPSTRUCT
     * }
     */
    public static final AddressLayout PDROPSTRUCT = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagDROPSTRUCT {
     *     HWND hwndSource;
     *     HWND hwndSink;
     *     DWORD wFmt;
     *     ULONG_PTR dwData;
     *     POINT ptDrop;
     *     DWORD dwControlData;
     * } *LPDROPSTRUCT
     * }
     */
    public static final AddressLayout LPDROPSTRUCT = C_POINTER;

    private static class DragObject {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_POINTER,
            C_POINTER,
            C_INT,
            C_LONG_LONG,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("DragObject"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD DragObject(HWND hwndParent, HWND hwndFrom, UINT fmt, ULONG_PTR data, HCURSOR hcur)
     * }
     */
    public static FunctionDescriptor DragObject$descriptor() {
        return DragObject.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD DragObject(HWND hwndParent, HWND hwndFrom, UINT fmt, ULONG_PTR data, HCURSOR hcur)
     * }
     */
    public static MethodHandle DragObject$handle() {
        return DragObject.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * DWORD DragObject(HWND hwndParent, HWND hwndFrom, UINT fmt, ULONG_PTR data, HCURSOR hcur)
     * }
     */
    public static int DragObject(MemorySegment hwndParent, MemorySegment hwndFrom, int fmt, long data, MemorySegment hcur) {
        var mh$ = DragObject.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DragObject", hwndParent, hwndFrom, fmt, data, hcur);
            }
            return (int)mh$.invokeExact(hwndParent, hwndFrom, fmt, data, hcur);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DragDetect {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            tagPOINT.layout()
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("DragDetect"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL DragDetect(HWND hwnd, POINT pt)
     * }
     */
    public static FunctionDescriptor DragDetect$descriptor() {
        return DragDetect.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL DragDetect(HWND hwnd, POINT pt)
     * }
     */
    public static MethodHandle DragDetect$handle() {
        return DragDetect.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL DragDetect(HWND hwnd, POINT pt)
     * }
     */
    public static int DragDetect(MemorySegment hwnd, MemorySegment pt) {
        var mh$ = DragDetect.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DragDetect", hwnd, pt);
            }
            return (int)mh$.invokeExact(hwnd, pt);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DrawIcon {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_INT,
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("DrawIcon"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL DrawIcon(HDC hDC, int X, int Y, HICON hIcon)
     * }
     */
    public static FunctionDescriptor DrawIcon$descriptor() {
        return DrawIcon.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL DrawIcon(HDC hDC, int X, int Y, HICON hIcon)
     * }
     */
    public static MethodHandle DrawIcon$handle() {
        return DrawIcon.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL DrawIcon(HDC hDC, int X, int Y, HICON hIcon)
     * }
     */
    public static int DrawIcon(MemorySegment hDC, int X, int Y, MemorySegment hIcon) {
        var mh$ = DrawIcon.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DrawIcon", hDC, X, Y, hIcon);
            }
            return (int)mh$.invokeExact(hDC, X, Y, hIcon);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct tagDRAWTEXTPARAMS {
     *     UINT cbSize;
     *     int iTabLength;
     *     int iLeftMargin;
     *     int iRightMargin;
     *     UINT uiLengthDrawn;
     * } *LPDRAWTEXTPARAMS
     * }
     */
    public static final AddressLayout LPDRAWTEXTPARAMS = C_POINTER;

    private static class DrawTextA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_INT,
            C_POINTER,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("DrawTextA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int DrawTextA(HDC hdc, LPCSTR lpchText, int cchText, LPRECT lprc, UINT format)
     * }
     */
    public static FunctionDescriptor DrawTextA$descriptor() {
        return DrawTextA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int DrawTextA(HDC hdc, LPCSTR lpchText, int cchText, LPRECT lprc, UINT format)
     * }
     */
    public static MethodHandle DrawTextA$handle() {
        return DrawTextA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int DrawTextA(HDC hdc, LPCSTR lpchText, int cchText, LPRECT lprc, UINT format)
     * }
     */
    public static int DrawTextA(MemorySegment hdc, MemorySegment lpchText, int cchText, MemorySegment lprc, int format) {
        var mh$ = DrawTextA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DrawTextA", hdc, lpchText, cchText, lprc, format);
            }
            return (int)mh$.invokeExact(hdc, lpchText, cchText, lprc, format);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DrawTextW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_INT,
            C_POINTER,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("DrawTextW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int DrawTextW(HDC hdc, LPCWSTR lpchText, int cchText, LPRECT lprc, UINT format)
     * }
     */
    public static FunctionDescriptor DrawTextW$descriptor() {
        return DrawTextW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int DrawTextW(HDC hdc, LPCWSTR lpchText, int cchText, LPRECT lprc, UINT format)
     * }
     */
    public static MethodHandle DrawTextW$handle() {
        return DrawTextW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int DrawTextW(HDC hdc, LPCWSTR lpchText, int cchText, LPRECT lprc, UINT format)
     * }
     */
    public static int DrawTextW(MemorySegment hdc, MemorySegment lpchText, int cchText, MemorySegment lprc, int format) {
        var mh$ = DrawTextW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DrawTextW", hdc, lpchText, cchText, lprc, format);
            }
            return (int)mh$.invokeExact(hdc, lpchText, cchText, lprc, format);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DrawTextExA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_INT,
            C_POINTER,
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("DrawTextExA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int DrawTextExA(HDC hdc, LPSTR lpchText, int cchText, LPRECT lprc, UINT format, LPDRAWTEXTPARAMS lpdtp)
     * }
     */
    public static FunctionDescriptor DrawTextExA$descriptor() {
        return DrawTextExA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int DrawTextExA(HDC hdc, LPSTR lpchText, int cchText, LPRECT lprc, UINT format, LPDRAWTEXTPARAMS lpdtp)
     * }
     */
    public static MethodHandle DrawTextExA$handle() {
        return DrawTextExA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int DrawTextExA(HDC hdc, LPSTR lpchText, int cchText, LPRECT lprc, UINT format, LPDRAWTEXTPARAMS lpdtp)
     * }
     */
    public static int DrawTextExA(MemorySegment hdc, MemorySegment lpchText, int cchText, MemorySegment lprc, int format, MemorySegment lpdtp) {
        var mh$ = DrawTextExA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DrawTextExA", hdc, lpchText, cchText, lprc, format, lpdtp);
            }
            return (int)mh$.invokeExact(hdc, lpchText, cchText, lprc, format, lpdtp);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DrawTextExW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_INT,
            C_POINTER,
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("DrawTextExW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int DrawTextExW(HDC hdc, LPWSTR lpchText, int cchText, LPRECT lprc, UINT format, LPDRAWTEXTPARAMS lpdtp)
     * }
     */
    public static FunctionDescriptor DrawTextExW$descriptor() {
        return DrawTextExW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int DrawTextExW(HDC hdc, LPWSTR lpchText, int cchText, LPRECT lprc, UINT format, LPDRAWTEXTPARAMS lpdtp)
     * }
     */
    public static MethodHandle DrawTextExW$handle() {
        return DrawTextExW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int DrawTextExW(HDC hdc, LPWSTR lpchText, int cchText, LPRECT lprc, UINT format, LPDRAWTEXTPARAMS lpdtp)
     * }
     */
    public static int DrawTextExW(MemorySegment hdc, MemorySegment lpchText, int cchText, MemorySegment lprc, int format, MemorySegment lpdtp) {
        var mh$ = DrawTextExW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DrawTextExW", hdc, lpchText, cchText, lprc, format, lpdtp);
            }
            return (int)mh$.invokeExact(hdc, lpchText, cchText, lprc, format, lpdtp);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GrayStringA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_LONG_LONG,
            C_INT,
            C_INT,
            C_INT,
            C_INT,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GrayStringA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GrayStringA(HDC hDC, HBRUSH hBrush, GRAYSTRINGPROC lpOutputFunc, LPARAM lpData, int nCount, int X, int Y, int nWidth, int nHeight)
     * }
     */
    public static FunctionDescriptor GrayStringA$descriptor() {
        return GrayStringA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GrayStringA(HDC hDC, HBRUSH hBrush, GRAYSTRINGPROC lpOutputFunc, LPARAM lpData, int nCount, int X, int Y, int nWidth, int nHeight)
     * }
     */
    public static MethodHandle GrayStringA$handle() {
        return GrayStringA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL GrayStringA(HDC hDC, HBRUSH hBrush, GRAYSTRINGPROC lpOutputFunc, LPARAM lpData, int nCount, int X, int Y, int nWidth, int nHeight)
     * }
     */
    public static int GrayStringA(MemorySegment hDC, MemorySegment hBrush, MemorySegment lpOutputFunc, long lpData, int nCount, int X, int Y, int nWidth, int nHeight) {
        var mh$ = GrayStringA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GrayStringA", hDC, hBrush, lpOutputFunc, lpData, nCount, X, Y, nWidth, nHeight);
            }
            return (int)mh$.invokeExact(hDC, hBrush, lpOutputFunc, lpData, nCount, X, Y, nWidth, nHeight);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GrayStringW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_LONG_LONG,
            C_INT,
            C_INT,
            C_INT,
            C_INT,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GrayStringW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GrayStringW(HDC hDC, HBRUSH hBrush, GRAYSTRINGPROC lpOutputFunc, LPARAM lpData, int nCount, int X, int Y, int nWidth, int nHeight)
     * }
     */
    public static FunctionDescriptor GrayStringW$descriptor() {
        return GrayStringW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GrayStringW(HDC hDC, HBRUSH hBrush, GRAYSTRINGPROC lpOutputFunc, LPARAM lpData, int nCount, int X, int Y, int nWidth, int nHeight)
     * }
     */
    public static MethodHandle GrayStringW$handle() {
        return GrayStringW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL GrayStringW(HDC hDC, HBRUSH hBrush, GRAYSTRINGPROC lpOutputFunc, LPARAM lpData, int nCount, int X, int Y, int nWidth, int nHeight)
     * }
     */
    public static int GrayStringW(MemorySegment hDC, MemorySegment hBrush, MemorySegment lpOutputFunc, long lpData, int nCount, int X, int Y, int nWidth, int nHeight) {
        var mh$ = GrayStringW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GrayStringW", hDC, hBrush, lpOutputFunc, lpData, nCount, X, Y, nWidth, nHeight);
            }
            return (int)mh$.invokeExact(hDC, hBrush, lpOutputFunc, lpData, nCount, X, Y, nWidth, nHeight);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DrawStateA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_LONG_LONG,
            C_LONG_LONG,
            C_INT,
            C_INT,
            C_INT,
            C_INT,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("DrawStateA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL DrawStateA(HDC hdc, HBRUSH hbrFore, DRAWSTATEPROC qfnCallBack, LPARAM lData, WPARAM wData, int x, int y, int cx, int cy, UINT uFlags)
     * }
     */
    public static FunctionDescriptor DrawStateA$descriptor() {
        return DrawStateA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL DrawStateA(HDC hdc, HBRUSH hbrFore, DRAWSTATEPROC qfnCallBack, LPARAM lData, WPARAM wData, int x, int y, int cx, int cy, UINT uFlags)
     * }
     */
    public static MethodHandle DrawStateA$handle() {
        return DrawStateA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL DrawStateA(HDC hdc, HBRUSH hbrFore, DRAWSTATEPROC qfnCallBack, LPARAM lData, WPARAM wData, int x, int y, int cx, int cy, UINT uFlags)
     * }
     */
    public static int DrawStateA(MemorySegment hdc, MemorySegment hbrFore, MemorySegment qfnCallBack, long lData, long wData, int x, int y, int cx, int cy, int uFlags) {
        var mh$ = DrawStateA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DrawStateA", hdc, hbrFore, qfnCallBack, lData, wData, x, y, cx, cy, uFlags);
            }
            return (int)mh$.invokeExact(hdc, hbrFore, qfnCallBack, lData, wData, x, y, cx, cy, uFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DrawStateW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_LONG_LONG,
            C_LONG_LONG,
            C_INT,
            C_INT,
            C_INT,
            C_INT,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("DrawStateW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL DrawStateW(HDC hdc, HBRUSH hbrFore, DRAWSTATEPROC qfnCallBack, LPARAM lData, WPARAM wData, int x, int y, int cx, int cy, UINT uFlags)
     * }
     */
    public static FunctionDescriptor DrawStateW$descriptor() {
        return DrawStateW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL DrawStateW(HDC hdc, HBRUSH hbrFore, DRAWSTATEPROC qfnCallBack, LPARAM lData, WPARAM wData, int x, int y, int cx, int cy, UINT uFlags)
     * }
     */
    public static MethodHandle DrawStateW$handle() {
        return DrawStateW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL DrawStateW(HDC hdc, HBRUSH hbrFore, DRAWSTATEPROC qfnCallBack, LPARAM lData, WPARAM wData, int x, int y, int cx, int cy, UINT uFlags)
     * }
     */
    public static int DrawStateW(MemorySegment hdc, MemorySegment hbrFore, MemorySegment qfnCallBack, long lData, long wData, int x, int y, int cx, int cy, int uFlags) {
        var mh$ = DrawStateW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DrawStateW", hdc, hbrFore, qfnCallBack, lData, wData, x, y, cx, cy, uFlags);
            }
            return (int)mh$.invokeExact(hdc, hbrFore, qfnCallBack, lData, wData, x, y, cx, cy, uFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TabbedTextOutA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_POINTER,
            C_INT,
            C_INT,
            C_POINTER,
            C_INT,
            C_INT,
            C_POINTER,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("TabbedTextOutA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LONG TabbedTextOutA(HDC hdc, int x, int y, LPCSTR lpString, int chCount, int nTabPositions, const INT *lpnTabStopPositions, int nTabOrigin)
     * }
     */
    public static FunctionDescriptor TabbedTextOutA$descriptor() {
        return TabbedTextOutA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LONG TabbedTextOutA(HDC hdc, int x, int y, LPCSTR lpString, int chCount, int nTabPositions, const INT *lpnTabStopPositions, int nTabOrigin)
     * }
     */
    public static MethodHandle TabbedTextOutA$handle() {
        return TabbedTextOutA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * LONG TabbedTextOutA(HDC hdc, int x, int y, LPCSTR lpString, int chCount, int nTabPositions, const INT *lpnTabStopPositions, int nTabOrigin)
     * }
     */
    public static int TabbedTextOutA(MemorySegment hdc, int x, int y, MemorySegment lpString, int chCount, int nTabPositions, MemorySegment lpnTabStopPositions, int nTabOrigin) {
        var mh$ = TabbedTextOutA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TabbedTextOutA", hdc, x, y, lpString, chCount, nTabPositions, lpnTabStopPositions, nTabOrigin);
            }
            return (int)mh$.invokeExact(hdc, x, y, lpString, chCount, nTabPositions, lpnTabStopPositions, nTabOrigin);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TabbedTextOutW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_POINTER,
            C_INT,
            C_INT,
            C_POINTER,
            C_INT,
            C_INT,
            C_POINTER,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("TabbedTextOutW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LONG TabbedTextOutW(HDC hdc, int x, int y, LPCWSTR lpString, int chCount, int nTabPositions, const INT *lpnTabStopPositions, int nTabOrigin)
     * }
     */
    public static FunctionDescriptor TabbedTextOutW$descriptor() {
        return TabbedTextOutW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LONG TabbedTextOutW(HDC hdc, int x, int y, LPCWSTR lpString, int chCount, int nTabPositions, const INT *lpnTabStopPositions, int nTabOrigin)
     * }
     */
    public static MethodHandle TabbedTextOutW$handle() {
        return TabbedTextOutW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * LONG TabbedTextOutW(HDC hdc, int x, int y, LPCWSTR lpString, int chCount, int nTabPositions, const INT *lpnTabStopPositions, int nTabOrigin)
     * }
     */
    public static int TabbedTextOutW(MemorySegment hdc, int x, int y, MemorySegment lpString, int chCount, int nTabPositions, MemorySegment lpnTabStopPositions, int nTabOrigin) {
        var mh$ = TabbedTextOutW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TabbedTextOutW", hdc, x, y, lpString, chCount, nTabPositions, lpnTabStopPositions, nTabOrigin);
            }
            return (int)mh$.invokeExact(hdc, x, y, lpString, chCount, nTabPositions, lpnTabStopPositions, nTabOrigin);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetTabbedTextExtentA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_POINTER,
            C_POINTER,
            C_INT,
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetTabbedTextExtentA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetTabbedTextExtentA(HDC hdc, LPCSTR lpString, int chCount, int nTabPositions, const INT *lpnTabStopPositions)
     * }
     */
    public static FunctionDescriptor GetTabbedTextExtentA$descriptor() {
        return GetTabbedTextExtentA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetTabbedTextExtentA(HDC hdc, LPCSTR lpString, int chCount, int nTabPositions, const INT *lpnTabStopPositions)
     * }
     */
    public static MethodHandle GetTabbedTextExtentA$handle() {
        return GetTabbedTextExtentA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * DWORD GetTabbedTextExtentA(HDC hdc, LPCSTR lpString, int chCount, int nTabPositions, const INT *lpnTabStopPositions)
     * }
     */
    public static int GetTabbedTextExtentA(MemorySegment hdc, MemorySegment lpString, int chCount, int nTabPositions, MemorySegment lpnTabStopPositions) {
        var mh$ = GetTabbedTextExtentA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetTabbedTextExtentA", hdc, lpString, chCount, nTabPositions, lpnTabStopPositions);
            }
            return (int)mh$.invokeExact(hdc, lpString, chCount, nTabPositions, lpnTabStopPositions);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetTabbedTextExtentW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_POINTER,
            C_POINTER,
            C_INT,
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetTabbedTextExtentW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetTabbedTextExtentW(HDC hdc, LPCWSTR lpString, int chCount, int nTabPositions, const INT *lpnTabStopPositions)
     * }
     */
    public static FunctionDescriptor GetTabbedTextExtentW$descriptor() {
        return GetTabbedTextExtentW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetTabbedTextExtentW(HDC hdc, LPCWSTR lpString, int chCount, int nTabPositions, const INT *lpnTabStopPositions)
     * }
     */
    public static MethodHandle GetTabbedTextExtentW$handle() {
        return GetTabbedTextExtentW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * DWORD GetTabbedTextExtentW(HDC hdc, LPCWSTR lpString, int chCount, int nTabPositions, const INT *lpnTabStopPositions)
     * }
     */
    public static int GetTabbedTextExtentW(MemorySegment hdc, MemorySegment lpString, int chCount, int nTabPositions, MemorySegment lpnTabStopPositions) {
        var mh$ = GetTabbedTextExtentW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetTabbedTextExtentW", hdc, lpString, chCount, nTabPositions, lpnTabStopPositions);
            }
            return (int)mh$.invokeExact(hdc, lpString, chCount, nTabPositions, lpnTabStopPositions);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class UpdateWindow {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("UpdateWindow"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL UpdateWindow(HWND hWnd)
     * }
     */
    public static FunctionDescriptor UpdateWindow$descriptor() {
        return UpdateWindow.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL UpdateWindow(HWND hWnd)
     * }
     */
    public static MethodHandle UpdateWindow$handle() {
        return UpdateWindow.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL UpdateWindow(HWND hWnd)
     * }
     */
    public static int UpdateWindow(MemorySegment hWnd) {
        var mh$ = UpdateWindow.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("UpdateWindow", hWnd);
            }
            return (int)mh$.invokeExact(hWnd);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetActiveWindow {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("SetActiveWindow"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HWND SetActiveWindow(HWND hWnd)
     * }
     */
    public static FunctionDescriptor SetActiveWindow$descriptor() {
        return SetActiveWindow.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HWND SetActiveWindow(HWND hWnd)
     * }
     */
    public static MethodHandle SetActiveWindow$handle() {
        return SetActiveWindow.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * HWND SetActiveWindow(HWND hWnd)
     * }
     */
    public static MemorySegment SetActiveWindow(MemorySegment hWnd) {
        var mh$ = SetActiveWindow.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetActiveWindow", hWnd);
            }
            return (MemorySegment)mh$.invokeExact(hWnd);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetForegroundWindow {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER    );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetForegroundWindow"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HWND GetForegroundWindow()
     * }
     */
    public static FunctionDescriptor GetForegroundWindow$descriptor() {
        return GetForegroundWindow.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HWND GetForegroundWindow()
     * }
     */
    public static MethodHandle GetForegroundWindow$handle() {
        return GetForegroundWindow.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * HWND GetForegroundWindow()
     * }
     */
    public static MemorySegment GetForegroundWindow() {
        var mh$ = GetForegroundWindow.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetForegroundWindow");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PaintDesktop {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("PaintDesktop"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL PaintDesktop(HDC hdc)
     * }
     */
    public static FunctionDescriptor PaintDesktop$descriptor() {
        return PaintDesktop.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL PaintDesktop(HDC hdc)
     * }
     */
    public static MethodHandle PaintDesktop$handle() {
        return PaintDesktop.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL PaintDesktop(HDC hdc)
     * }
     */
    public static int PaintDesktop(MemorySegment hdc) {
        var mh$ = PaintDesktop.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PaintDesktop", hdc);
            }
            return (int)mh$.invokeExact(hdc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SwitchToThisWindow {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C_POINTER,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("SwitchToThisWindow"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SwitchToThisWindow(HWND hwnd, BOOL fUnknown)
     * }
     */
    public static FunctionDescriptor SwitchToThisWindow$descriptor() {
        return SwitchToThisWindow.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SwitchToThisWindow(HWND hwnd, BOOL fUnknown)
     * }
     */
    public static MethodHandle SwitchToThisWindow$handle() {
        return SwitchToThisWindow.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * void SwitchToThisWindow(HWND hwnd, BOOL fUnknown)
     * }
     */
    public static void SwitchToThisWindow(MemorySegment hwnd, int fUnknown) {
        var mh$ = SwitchToThisWindow.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SwitchToThisWindow", hwnd, fUnknown);
            }
            mh$.invokeExact(hwnd, fUnknown);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetForegroundWindow {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("SetForegroundWindow"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetForegroundWindow(HWND hWnd)
     * }
     */
    public static FunctionDescriptor SetForegroundWindow$descriptor() {
        return SetForegroundWindow.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetForegroundWindow(HWND hWnd)
     * }
     */
    public static MethodHandle SetForegroundWindow$handle() {
        return SetForegroundWindow.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL SetForegroundWindow(HWND hWnd)
     * }
     */
    public static int SetForegroundWindow(MemorySegment hWnd) {
        var mh$ = SetForegroundWindow.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetForegroundWindow", hWnd);
            }
            return (int)mh$.invokeExact(hWnd);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class AllowSetForegroundWindow {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("AllowSetForegroundWindow"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL AllowSetForegroundWindow(DWORD dwProcessId)
     * }
     */
    public static FunctionDescriptor AllowSetForegroundWindow$descriptor() {
        return AllowSetForegroundWindow.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL AllowSetForegroundWindow(DWORD dwProcessId)
     * }
     */
    public static MethodHandle AllowSetForegroundWindow$handle() {
        return AllowSetForegroundWindow.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL AllowSetForegroundWindow(DWORD dwProcessId)
     * }
     */
    public static int AllowSetForegroundWindow(int dwProcessId) {
        var mh$ = AllowSetForegroundWindow.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("AllowSetForegroundWindow", dwProcessId);
            }
            return (int)mh$.invokeExact(dwProcessId);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LockSetForegroundWindow {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("LockSetForegroundWindow"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL LockSetForegroundWindow(UINT uLockCode)
     * }
     */
    public static FunctionDescriptor LockSetForegroundWindow$descriptor() {
        return LockSetForegroundWindow.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL LockSetForegroundWindow(UINT uLockCode)
     * }
     */
    public static MethodHandle LockSetForegroundWindow$handle() {
        return LockSetForegroundWindow.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL LockSetForegroundWindow(UINT uLockCode)
     * }
     */
    public static int LockSetForegroundWindow(int uLockCode) {
        var mh$ = LockSetForegroundWindow.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LockSetForegroundWindow", uLockCode);
            }
            return (int)mh$.invokeExact(uLockCode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class WindowFromDC {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("WindowFromDC"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HWND WindowFromDC(HDC hDC)
     * }
     */
    public static FunctionDescriptor WindowFromDC$descriptor() {
        return WindowFromDC.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HWND WindowFromDC(HDC hDC)
     * }
     */
    public static MethodHandle WindowFromDC$handle() {
        return WindowFromDC.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * HWND WindowFromDC(HDC hDC)
     * }
     */
    public static MemorySegment WindowFromDC(MemorySegment hDC) {
        var mh$ = WindowFromDC.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WindowFromDC", hDC);
            }
            return (MemorySegment)mh$.invokeExact(hDC);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetDC {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetDC"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HDC GetDC(HWND hWnd)
     * }
     */
    public static FunctionDescriptor GetDC$descriptor() {
        return GetDC.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HDC GetDC(HWND hWnd)
     * }
     */
    public static MethodHandle GetDC$handle() {
        return GetDC.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * HDC GetDC(HWND hWnd)
     * }
     */
    public static MemorySegment GetDC(MemorySegment hWnd) {
        var mh$ = GetDC.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetDC", hWnd);
            }
            return (MemorySegment)mh$.invokeExact(hWnd);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetDCEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetDCEx"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HDC GetDCEx(HWND hWnd, HRGN hrgnClip, DWORD flags)
     * }
     */
    public static FunctionDescriptor GetDCEx$descriptor() {
        return GetDCEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HDC GetDCEx(HWND hWnd, HRGN hrgnClip, DWORD flags)
     * }
     */
    public static MethodHandle GetDCEx$handle() {
        return GetDCEx.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * HDC GetDCEx(HWND hWnd, HRGN hrgnClip, DWORD flags)
     * }
     */
    public static MemorySegment GetDCEx(MemorySegment hWnd, MemorySegment hrgnClip, int flags) {
        var mh$ = GetDCEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetDCEx", hWnd, hrgnClip, flags);
            }
            return (MemorySegment)mh$.invokeExact(hWnd, hrgnClip, flags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetWindowDC {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetWindowDC"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HDC GetWindowDC(HWND hWnd)
     * }
     */
    public static FunctionDescriptor GetWindowDC$descriptor() {
        return GetWindowDC.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HDC GetWindowDC(HWND hWnd)
     * }
     */
    public static MethodHandle GetWindowDC$handle() {
        return GetWindowDC.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * HDC GetWindowDC(HWND hWnd)
     * }
     */
    public static MemorySegment GetWindowDC(MemorySegment hWnd) {
        var mh$ = GetWindowDC.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetWindowDC", hWnd);
            }
            return (MemorySegment)mh$.invokeExact(hWnd);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ReleaseDC {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("ReleaseDC"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int ReleaseDC(HWND hWnd, HDC hDC)
     * }
     */
    public static FunctionDescriptor ReleaseDC$descriptor() {
        return ReleaseDC.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int ReleaseDC(HWND hWnd, HDC hDC)
     * }
     */
    public static MethodHandle ReleaseDC$handle() {
        return ReleaseDC.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int ReleaseDC(HWND hWnd, HDC hDC)
     * }
     */
    public static int ReleaseDC(MemorySegment hWnd, MemorySegment hDC) {
        var mh$ = ReleaseDC.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ReleaseDC", hWnd, hDC);
            }
            return (int)mh$.invokeExact(hWnd, hDC);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class BeginPaint {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("BeginPaint"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HDC BeginPaint(HWND hWnd, LPPAINTSTRUCT lpPaint)
     * }
     */
    public static FunctionDescriptor BeginPaint$descriptor() {
        return BeginPaint.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HDC BeginPaint(HWND hWnd, LPPAINTSTRUCT lpPaint)
     * }
     */
    public static MethodHandle BeginPaint$handle() {
        return BeginPaint.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * HDC BeginPaint(HWND hWnd, LPPAINTSTRUCT lpPaint)
     * }
     */
    public static MemorySegment BeginPaint(MemorySegment hWnd, MemorySegment lpPaint) {
        var mh$ = BeginPaint.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("BeginPaint", hWnd, lpPaint);
            }
            return (MemorySegment)mh$.invokeExact(hWnd, lpPaint);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class EndPaint {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("EndPaint"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL EndPaint(HWND hWnd, const PAINTSTRUCT *lpPaint)
     * }
     */
    public static FunctionDescriptor EndPaint$descriptor() {
        return EndPaint.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL EndPaint(HWND hWnd, const PAINTSTRUCT *lpPaint)
     * }
     */
    public static MethodHandle EndPaint$handle() {
        return EndPaint.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL EndPaint(HWND hWnd, const PAINTSTRUCT *lpPaint)
     * }
     */
    public static int EndPaint(MemorySegment hWnd, MemorySegment lpPaint) {
        var mh$ = EndPaint.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("EndPaint", hWnd, lpPaint);
            }
            return (int)mh$.invokeExact(hWnd, lpPaint);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetUpdateRect {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetUpdateRect"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetUpdateRect(HWND hWnd, LPRECT lpRect, BOOL bErase)
     * }
     */
    public static FunctionDescriptor GetUpdateRect$descriptor() {
        return GetUpdateRect.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetUpdateRect(HWND hWnd, LPRECT lpRect, BOOL bErase)
     * }
     */
    public static MethodHandle GetUpdateRect$handle() {
        return GetUpdateRect.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL GetUpdateRect(HWND hWnd, LPRECT lpRect, BOOL bErase)
     * }
     */
    public static int GetUpdateRect(MemorySegment hWnd, MemorySegment lpRect, int bErase) {
        var mh$ = GetUpdateRect.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetUpdateRect", hWnd, lpRect, bErase);
            }
            return (int)mh$.invokeExact(hWnd, lpRect, bErase);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetUpdateRgn {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetUpdateRgn"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int GetUpdateRgn(HWND hWnd, HRGN hRgn, BOOL bErase)
     * }
     */
    public static FunctionDescriptor GetUpdateRgn$descriptor() {
        return GetUpdateRgn.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int GetUpdateRgn(HWND hWnd, HRGN hRgn, BOOL bErase)
     * }
     */
    public static MethodHandle GetUpdateRgn$handle() {
        return GetUpdateRgn.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int GetUpdateRgn(HWND hWnd, HRGN hRgn, BOOL bErase)
     * }
     */
    public static int GetUpdateRgn(MemorySegment hWnd, MemorySegment hRgn, int bErase) {
        var mh$ = GetUpdateRgn.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetUpdateRgn", hWnd, hRgn, bErase);
            }
            return (int)mh$.invokeExact(hWnd, hRgn, bErase);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetWindowRgn {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("SetWindowRgn"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SetWindowRgn(HWND hWnd, HRGN hRgn, BOOL bRedraw)
     * }
     */
    public static FunctionDescriptor SetWindowRgn$descriptor() {
        return SetWindowRgn.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SetWindowRgn(HWND hWnd, HRGN hRgn, BOOL bRedraw)
     * }
     */
    public static MethodHandle SetWindowRgn$handle() {
        return SetWindowRgn.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int SetWindowRgn(HWND hWnd, HRGN hRgn, BOOL bRedraw)
     * }
     */
    public static int SetWindowRgn(MemorySegment hWnd, MemorySegment hRgn, int bRedraw) {
        var mh$ = SetWindowRgn.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetWindowRgn", hWnd, hRgn, bRedraw);
            }
            return (int)mh$.invokeExact(hWnd, hRgn, bRedraw);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetWindowRgn {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetWindowRgn"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int GetWindowRgn(HWND hWnd, HRGN hRgn)
     * }
     */
    public static FunctionDescriptor GetWindowRgn$descriptor() {
        return GetWindowRgn.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int GetWindowRgn(HWND hWnd, HRGN hRgn)
     * }
     */
    public static MethodHandle GetWindowRgn$handle() {
        return GetWindowRgn.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int GetWindowRgn(HWND hWnd, HRGN hRgn)
     * }
     */
    public static int GetWindowRgn(MemorySegment hWnd, MemorySegment hRgn) {
        var mh$ = GetWindowRgn.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetWindowRgn", hWnd, hRgn);
            }
            return (int)mh$.invokeExact(hWnd, hRgn);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetWindowRgnBox {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetWindowRgnBox"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int GetWindowRgnBox(HWND hWnd, LPRECT lprc)
     * }
     */
    public static FunctionDescriptor GetWindowRgnBox$descriptor() {
        return GetWindowRgnBox.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int GetWindowRgnBox(HWND hWnd, LPRECT lprc)
     * }
     */
    public static MethodHandle GetWindowRgnBox$handle() {
        return GetWindowRgnBox.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int GetWindowRgnBox(HWND hWnd, LPRECT lprc)
     * }
     */
    public static int GetWindowRgnBox(MemorySegment hWnd, MemorySegment lprc) {
        var mh$ = GetWindowRgnBox.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetWindowRgnBox", hWnd, lprc);
            }
            return (int)mh$.invokeExact(hWnd, lprc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ExcludeUpdateRgn {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("ExcludeUpdateRgn"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int ExcludeUpdateRgn(HDC hDC, HWND hWnd)
     * }
     */
    public static FunctionDescriptor ExcludeUpdateRgn$descriptor() {
        return ExcludeUpdateRgn.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int ExcludeUpdateRgn(HDC hDC, HWND hWnd)
     * }
     */
    public static MethodHandle ExcludeUpdateRgn$handle() {
        return ExcludeUpdateRgn.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int ExcludeUpdateRgn(HDC hDC, HWND hWnd)
     * }
     */
    public static int ExcludeUpdateRgn(MemorySegment hDC, MemorySegment hWnd) {
        var mh$ = ExcludeUpdateRgn.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ExcludeUpdateRgn", hDC, hWnd);
            }
            return (int)mh$.invokeExact(hDC, hWnd);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class InvalidateRect {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("InvalidateRect"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL InvalidateRect(HWND hWnd, const RECT *lpRect, BOOL bErase)
     * }
     */
    public static FunctionDescriptor InvalidateRect$descriptor() {
        return InvalidateRect.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL InvalidateRect(HWND hWnd, const RECT *lpRect, BOOL bErase)
     * }
     */
    public static MethodHandle InvalidateRect$handle() {
        return InvalidateRect.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL InvalidateRect(HWND hWnd, const RECT *lpRect, BOOL bErase)
     * }
     */
    public static int InvalidateRect(MemorySegment hWnd, MemorySegment lpRect, int bErase) {
        var mh$ = InvalidateRect.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("InvalidateRect", hWnd, lpRect, bErase);
            }
            return (int)mh$.invokeExact(hWnd, lpRect, bErase);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ValidateRect {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("ValidateRect"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL ValidateRect(HWND hWnd, const RECT *lpRect)
     * }
     */
    public static FunctionDescriptor ValidateRect$descriptor() {
        return ValidateRect.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL ValidateRect(HWND hWnd, const RECT *lpRect)
     * }
     */
    public static MethodHandle ValidateRect$handle() {
        return ValidateRect.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL ValidateRect(HWND hWnd, const RECT *lpRect)
     * }
     */
    public static int ValidateRect(MemorySegment hWnd, MemorySegment lpRect) {
        var mh$ = ValidateRect.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ValidateRect", hWnd, lpRect);
            }
            return (int)mh$.invokeExact(hWnd, lpRect);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class InvalidateRgn {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("InvalidateRgn"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL InvalidateRgn(HWND hWnd, HRGN hRgn, BOOL bErase)
     * }
     */
    public static FunctionDescriptor InvalidateRgn$descriptor() {
        return InvalidateRgn.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL InvalidateRgn(HWND hWnd, HRGN hRgn, BOOL bErase)
     * }
     */
    public static MethodHandle InvalidateRgn$handle() {
        return InvalidateRgn.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL InvalidateRgn(HWND hWnd, HRGN hRgn, BOOL bErase)
     * }
     */
    public static int InvalidateRgn(MemorySegment hWnd, MemorySegment hRgn, int bErase) {
        var mh$ = InvalidateRgn.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("InvalidateRgn", hWnd, hRgn, bErase);
            }
            return (int)mh$.invokeExact(hWnd, hRgn, bErase);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ValidateRgn {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("ValidateRgn"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL ValidateRgn(HWND hWnd, HRGN hRgn)
     * }
     */
    public static FunctionDescriptor ValidateRgn$descriptor() {
        return ValidateRgn.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL ValidateRgn(HWND hWnd, HRGN hRgn)
     * }
     */
    public static MethodHandle ValidateRgn$handle() {
        return ValidateRgn.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL ValidateRgn(HWND hWnd, HRGN hRgn)
     * }
     */
    public static int ValidateRgn(MemorySegment hWnd, MemorySegment hRgn) {
        var mh$ = ValidateRgn.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ValidateRgn", hWnd, hRgn);
            }
            return (int)mh$.invokeExact(hWnd, hRgn);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RedrawWindow {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("RedrawWindow"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL RedrawWindow(HWND hWnd, const RECT *lprcUpdate, HRGN hrgnUpdate, UINT flags)
     * }
     */
    public static FunctionDescriptor RedrawWindow$descriptor() {
        return RedrawWindow.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL RedrawWindow(HWND hWnd, const RECT *lprcUpdate, HRGN hrgnUpdate, UINT flags)
     * }
     */
    public static MethodHandle RedrawWindow$handle() {
        return RedrawWindow.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL RedrawWindow(HWND hWnd, const RECT *lprcUpdate, HRGN hrgnUpdate, UINT flags)
     * }
     */
    public static int RedrawWindow(MemorySegment hWnd, MemorySegment lprcUpdate, MemorySegment hrgnUpdate, int flags) {
        var mh$ = RedrawWindow.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RedrawWindow", hWnd, lprcUpdate, hrgnUpdate, flags);
            }
            return (int)mh$.invokeExact(hWnd, lprcUpdate, hrgnUpdate, flags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LockWindowUpdate {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("LockWindowUpdate"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL LockWindowUpdate(HWND hWndLock)
     * }
     */
    public static FunctionDescriptor LockWindowUpdate$descriptor() {
        return LockWindowUpdate.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL LockWindowUpdate(HWND hWndLock)
     * }
     */
    public static MethodHandle LockWindowUpdate$handle() {
        return LockWindowUpdate.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL LockWindowUpdate(HWND hWndLock)
     * }
     */
    public static int LockWindowUpdate(MemorySegment hWndLock) {
        var mh$ = LockWindowUpdate.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LockWindowUpdate", hWndLock);
            }
            return (int)mh$.invokeExact(hWndLock);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ScrollWindow {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_INT,
            C_INT,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("ScrollWindow"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL ScrollWindow(HWND hWnd, int XAmount, int YAmount, const RECT *lpRect, const RECT *lpClipRect)
     * }
     */
    public static FunctionDescriptor ScrollWindow$descriptor() {
        return ScrollWindow.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL ScrollWindow(HWND hWnd, int XAmount, int YAmount, const RECT *lpRect, const RECT *lpClipRect)
     * }
     */
    public static MethodHandle ScrollWindow$handle() {
        return ScrollWindow.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL ScrollWindow(HWND hWnd, int XAmount, int YAmount, const RECT *lpRect, const RECT *lpClipRect)
     * }
     */
    public static int ScrollWindow(MemorySegment hWnd, int XAmount, int YAmount, MemorySegment lpRect, MemorySegment lpClipRect) {
        var mh$ = ScrollWindow.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ScrollWindow", hWnd, XAmount, YAmount, lpRect, lpClipRect);
            }
            return (int)mh$.invokeExact(hWnd, XAmount, YAmount, lpRect, lpClipRect);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ScrollDC {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_INT,
            C_INT,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("ScrollDC"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL ScrollDC(HDC hDC, int dx, int dy, const RECT *lprcScroll, const RECT *lprcClip, HRGN hrgnUpdate, LPRECT lprcUpdate)
     * }
     */
    public static FunctionDescriptor ScrollDC$descriptor() {
        return ScrollDC.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL ScrollDC(HDC hDC, int dx, int dy, const RECT *lprcScroll, const RECT *lprcClip, HRGN hrgnUpdate, LPRECT lprcUpdate)
     * }
     */
    public static MethodHandle ScrollDC$handle() {
        return ScrollDC.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL ScrollDC(HDC hDC, int dx, int dy, const RECT *lprcScroll, const RECT *lprcClip, HRGN hrgnUpdate, LPRECT lprcUpdate)
     * }
     */
    public static int ScrollDC(MemorySegment hDC, int dx, int dy, MemorySegment lprcScroll, MemorySegment lprcClip, MemorySegment hrgnUpdate, MemorySegment lprcUpdate) {
        var mh$ = ScrollDC.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ScrollDC", hDC, dx, dy, lprcScroll, lprcClip, hrgnUpdate, lprcUpdate);
            }
            return (int)mh$.invokeExact(hDC, dx, dy, lprcScroll, lprcClip, hrgnUpdate, lprcUpdate);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ScrollWindowEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_INT,
            C_INT,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("ScrollWindowEx"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int ScrollWindowEx(HWND hWnd, int dx, int dy, const RECT *prcScroll, const RECT *prcClip, HRGN hrgnUpdate, LPRECT prcUpdate, UINT flags)
     * }
     */
    public static FunctionDescriptor ScrollWindowEx$descriptor() {
        return ScrollWindowEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int ScrollWindowEx(HWND hWnd, int dx, int dy, const RECT *prcScroll, const RECT *prcClip, HRGN hrgnUpdate, LPRECT prcUpdate, UINT flags)
     * }
     */
    public static MethodHandle ScrollWindowEx$handle() {
        return ScrollWindowEx.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int ScrollWindowEx(HWND hWnd, int dx, int dy, const RECT *prcScroll, const RECT *prcClip, HRGN hrgnUpdate, LPRECT prcUpdate, UINT flags)
     * }
     */
    public static int ScrollWindowEx(MemorySegment hWnd, int dx, int dy, MemorySegment prcScroll, MemorySegment prcClip, MemorySegment hrgnUpdate, MemorySegment prcUpdate, int flags) {
        var mh$ = ScrollWindowEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ScrollWindowEx", hWnd, dx, dy, prcScroll, prcClip, hrgnUpdate, prcUpdate, flags);
            }
            return (int)mh$.invokeExact(hWnd, dx, dy, prcScroll, prcClip, hrgnUpdate, prcUpdate, flags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetScrollPos {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_INT,
            C_INT,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("SetScrollPos"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SetScrollPos(HWND hWnd, int nBar, int nPos, BOOL bRedraw)
     * }
     */
    public static FunctionDescriptor SetScrollPos$descriptor() {
        return SetScrollPos.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SetScrollPos(HWND hWnd, int nBar, int nPos, BOOL bRedraw)
     * }
     */
    public static MethodHandle SetScrollPos$handle() {
        return SetScrollPos.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int SetScrollPos(HWND hWnd, int nBar, int nPos, BOOL bRedraw)
     * }
     */
    public static int SetScrollPos(MemorySegment hWnd, int nBar, int nPos, int bRedraw) {
        var mh$ = SetScrollPos.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetScrollPos", hWnd, nBar, nPos, bRedraw);
            }
            return (int)mh$.invokeExact(hWnd, nBar, nPos, bRedraw);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetScrollPos {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetScrollPos"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int GetScrollPos(HWND hWnd, int nBar)
     * }
     */
    public static FunctionDescriptor GetScrollPos$descriptor() {
        return GetScrollPos.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int GetScrollPos(HWND hWnd, int nBar)
     * }
     */
    public static MethodHandle GetScrollPos$handle() {
        return GetScrollPos.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int GetScrollPos(HWND hWnd, int nBar)
     * }
     */
    public static int GetScrollPos(MemorySegment hWnd, int nBar) {
        var mh$ = GetScrollPos.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetScrollPos", hWnd, nBar);
            }
            return (int)mh$.invokeExact(hWnd, nBar);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetScrollRange {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_INT,
            C_INT,
            C_INT,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("SetScrollRange"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetScrollRange(HWND hWnd, int nBar, int nMinPos, int nMaxPos, BOOL bRedraw)
     * }
     */
    public static FunctionDescriptor SetScrollRange$descriptor() {
        return SetScrollRange.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetScrollRange(HWND hWnd, int nBar, int nMinPos, int nMaxPos, BOOL bRedraw)
     * }
     */
    public static MethodHandle SetScrollRange$handle() {
        return SetScrollRange.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL SetScrollRange(HWND hWnd, int nBar, int nMinPos, int nMaxPos, BOOL bRedraw)
     * }
     */
    public static int SetScrollRange(MemorySegment hWnd, int nBar, int nMinPos, int nMaxPos, int bRedraw) {
        var mh$ = SetScrollRange.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetScrollRange", hWnd, nBar, nMinPos, nMaxPos, bRedraw);
            }
            return (int)mh$.invokeExact(hWnd, nBar, nMinPos, nMaxPos, bRedraw);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetScrollRange {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_INT,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetScrollRange"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetScrollRange(HWND hWnd, int nBar, LPINT lpMinPos, LPINT lpMaxPos)
     * }
     */
    public static FunctionDescriptor GetScrollRange$descriptor() {
        return GetScrollRange.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetScrollRange(HWND hWnd, int nBar, LPINT lpMinPos, LPINT lpMaxPos)
     * }
     */
    public static MethodHandle GetScrollRange$handle() {
        return GetScrollRange.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL GetScrollRange(HWND hWnd, int nBar, LPINT lpMinPos, LPINT lpMaxPos)
     * }
     */
    public static int GetScrollRange(MemorySegment hWnd, int nBar, MemorySegment lpMinPos, MemorySegment lpMaxPos) {
        var mh$ = GetScrollRange.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetScrollRange", hWnd, nBar, lpMinPos, lpMaxPos);
            }
            return (int)mh$.invokeExact(hWnd, nBar, lpMinPos, lpMaxPos);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ShowScrollBar {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_INT,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("ShowScrollBar"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL ShowScrollBar(HWND hWnd, int wBar, BOOL bShow)
     * }
     */
    public static FunctionDescriptor ShowScrollBar$descriptor() {
        return ShowScrollBar.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL ShowScrollBar(HWND hWnd, int wBar, BOOL bShow)
     * }
     */
    public static MethodHandle ShowScrollBar$handle() {
        return ShowScrollBar.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL ShowScrollBar(HWND hWnd, int wBar, BOOL bShow)
     * }
     */
    public static int ShowScrollBar(MemorySegment hWnd, int wBar, int bShow) {
        var mh$ = ShowScrollBar.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ShowScrollBar", hWnd, wBar, bShow);
            }
            return (int)mh$.invokeExact(hWnd, wBar, bShow);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class EnableScrollBar {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_INT,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("EnableScrollBar"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL EnableScrollBar(HWND hWnd, UINT wSBflags, UINT wArrows)
     * }
     */
    public static FunctionDescriptor EnableScrollBar$descriptor() {
        return EnableScrollBar.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL EnableScrollBar(HWND hWnd, UINT wSBflags, UINT wArrows)
     * }
     */
    public static MethodHandle EnableScrollBar$handle() {
        return EnableScrollBar.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL EnableScrollBar(HWND hWnd, UINT wSBflags, UINT wArrows)
     * }
     */
    public static int EnableScrollBar(MemorySegment hWnd, int wSBflags, int wArrows) {
        var mh$ = EnableScrollBar.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("EnableScrollBar", hWnd, wSBflags, wArrows);
            }
            return (int)mh$.invokeExact(hWnd, wSBflags, wArrows);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetPropA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("SetPropA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetPropA(HWND hWnd, LPCSTR lpString, HANDLE hData)
     * }
     */
    public static FunctionDescriptor SetPropA$descriptor() {
        return SetPropA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetPropA(HWND hWnd, LPCSTR lpString, HANDLE hData)
     * }
     */
    public static MethodHandle SetPropA$handle() {
        return SetPropA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL SetPropA(HWND hWnd, LPCSTR lpString, HANDLE hData)
     * }
     */
    public static int SetPropA(MemorySegment hWnd, MemorySegment lpString, MemorySegment hData) {
        var mh$ = SetPropA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetPropA", hWnd, lpString, hData);
            }
            return (int)mh$.invokeExact(hWnd, lpString, hData);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetPropW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("SetPropW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetPropW(HWND hWnd, LPCWSTR lpString, HANDLE hData)
     * }
     */
    public static FunctionDescriptor SetPropW$descriptor() {
        return SetPropW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetPropW(HWND hWnd, LPCWSTR lpString, HANDLE hData)
     * }
     */
    public static MethodHandle SetPropW$handle() {
        return SetPropW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL SetPropW(HWND hWnd, LPCWSTR lpString, HANDLE hData)
     * }
     */
    public static int SetPropW(MemorySegment hWnd, MemorySegment lpString, MemorySegment hData) {
        var mh$ = SetPropW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetPropW", hWnd, lpString, hData);
            }
            return (int)mh$.invokeExact(hWnd, lpString, hData);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetPropA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetPropA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HANDLE GetPropA(HWND hWnd, LPCSTR lpString)
     * }
     */
    public static FunctionDescriptor GetPropA$descriptor() {
        return GetPropA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HANDLE GetPropA(HWND hWnd, LPCSTR lpString)
     * }
     */
    public static MethodHandle GetPropA$handle() {
        return GetPropA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * HANDLE GetPropA(HWND hWnd, LPCSTR lpString)
     * }
     */
    public static MemorySegment GetPropA(MemorySegment hWnd, MemorySegment lpString) {
        var mh$ = GetPropA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetPropA", hWnd, lpString);
            }
            return (MemorySegment)mh$.invokeExact(hWnd, lpString);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetPropW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetPropW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HANDLE GetPropW(HWND hWnd, LPCWSTR lpString)
     * }
     */
    public static FunctionDescriptor GetPropW$descriptor() {
        return GetPropW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HANDLE GetPropW(HWND hWnd, LPCWSTR lpString)
     * }
     */
    public static MethodHandle GetPropW$handle() {
        return GetPropW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * HANDLE GetPropW(HWND hWnd, LPCWSTR lpString)
     * }
     */
    public static MemorySegment GetPropW(MemorySegment hWnd, MemorySegment lpString) {
        var mh$ = GetPropW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetPropW", hWnd, lpString);
            }
            return (MemorySegment)mh$.invokeExact(hWnd, lpString);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RemovePropA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("RemovePropA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HANDLE RemovePropA(HWND hWnd, LPCSTR lpString)
     * }
     */
    public static FunctionDescriptor RemovePropA$descriptor() {
        return RemovePropA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HANDLE RemovePropA(HWND hWnd, LPCSTR lpString)
     * }
     */
    public static MethodHandle RemovePropA$handle() {
        return RemovePropA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * HANDLE RemovePropA(HWND hWnd, LPCSTR lpString)
     * }
     */
    public static MemorySegment RemovePropA(MemorySegment hWnd, MemorySegment lpString) {
        var mh$ = RemovePropA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RemovePropA", hWnd, lpString);
            }
            return (MemorySegment)mh$.invokeExact(hWnd, lpString);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RemovePropW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("RemovePropW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HANDLE RemovePropW(HWND hWnd, LPCWSTR lpString)
     * }
     */
    public static FunctionDescriptor RemovePropW$descriptor() {
        return RemovePropW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HANDLE RemovePropW(HWND hWnd, LPCWSTR lpString)
     * }
     */
    public static MethodHandle RemovePropW$handle() {
        return RemovePropW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * HANDLE RemovePropW(HWND hWnd, LPCWSTR lpString)
     * }
     */
    public static MemorySegment RemovePropW(MemorySegment hWnd, MemorySegment lpString) {
        var mh$ = RemovePropW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RemovePropW", hWnd, lpString);
            }
            return (MemorySegment)mh$.invokeExact(hWnd, lpString);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class EnumPropsExA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_LONG_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("EnumPropsExA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int EnumPropsExA(HWND hWnd, PROPENUMPROCEXA lpEnumFunc, LPARAM lParam)
     * }
     */
    public static FunctionDescriptor EnumPropsExA$descriptor() {
        return EnumPropsExA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int EnumPropsExA(HWND hWnd, PROPENUMPROCEXA lpEnumFunc, LPARAM lParam)
     * }
     */
    public static MethodHandle EnumPropsExA$handle() {
        return EnumPropsExA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int EnumPropsExA(HWND hWnd, PROPENUMPROCEXA lpEnumFunc, LPARAM lParam)
     * }
     */
    public static int EnumPropsExA(MemorySegment hWnd, MemorySegment lpEnumFunc, long lParam) {
        var mh$ = EnumPropsExA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("EnumPropsExA", hWnd, lpEnumFunc, lParam);
            }
            return (int)mh$.invokeExact(hWnd, lpEnumFunc, lParam);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class EnumPropsExW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_LONG_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("EnumPropsExW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int EnumPropsExW(HWND hWnd, PROPENUMPROCEXW lpEnumFunc, LPARAM lParam)
     * }
     */
    public static FunctionDescriptor EnumPropsExW$descriptor() {
        return EnumPropsExW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int EnumPropsExW(HWND hWnd, PROPENUMPROCEXW lpEnumFunc, LPARAM lParam)
     * }
     */
    public static MethodHandle EnumPropsExW$handle() {
        return EnumPropsExW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int EnumPropsExW(HWND hWnd, PROPENUMPROCEXW lpEnumFunc, LPARAM lParam)
     * }
     */
    public static int EnumPropsExW(MemorySegment hWnd, MemorySegment lpEnumFunc, long lParam) {
        var mh$ = EnumPropsExW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("EnumPropsExW", hWnd, lpEnumFunc, lParam);
            }
            return (int)mh$.invokeExact(hWnd, lpEnumFunc, lParam);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class EnumPropsA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("EnumPropsA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int EnumPropsA(HWND hWnd, PROPENUMPROCA lpEnumFunc)
     * }
     */
    public static FunctionDescriptor EnumPropsA$descriptor() {
        return EnumPropsA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int EnumPropsA(HWND hWnd, PROPENUMPROCA lpEnumFunc)
     * }
     */
    public static MethodHandle EnumPropsA$handle() {
        return EnumPropsA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int EnumPropsA(HWND hWnd, PROPENUMPROCA lpEnumFunc)
     * }
     */
    public static int EnumPropsA(MemorySegment hWnd, MemorySegment lpEnumFunc) {
        var mh$ = EnumPropsA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("EnumPropsA", hWnd, lpEnumFunc);
            }
            return (int)mh$.invokeExact(hWnd, lpEnumFunc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class EnumPropsW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("EnumPropsW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int EnumPropsW(HWND hWnd, PROPENUMPROCW lpEnumFunc)
     * }
     */
    public static FunctionDescriptor EnumPropsW$descriptor() {
        return EnumPropsW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int EnumPropsW(HWND hWnd, PROPENUMPROCW lpEnumFunc)
     * }
     */
    public static MethodHandle EnumPropsW$handle() {
        return EnumPropsW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int EnumPropsW(HWND hWnd, PROPENUMPROCW lpEnumFunc)
     * }
     */
    public static int EnumPropsW(MemorySegment hWnd, MemorySegment lpEnumFunc) {
        var mh$ = EnumPropsW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("EnumPropsW", hWnd, lpEnumFunc);
            }
            return (int)mh$.invokeExact(hWnd, lpEnumFunc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetWindowTextA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("SetWindowTextA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetWindowTextA(HWND hWnd, LPCSTR lpString)
     * }
     */
    public static FunctionDescriptor SetWindowTextA$descriptor() {
        return SetWindowTextA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetWindowTextA(HWND hWnd, LPCSTR lpString)
     * }
     */
    public static MethodHandle SetWindowTextA$handle() {
        return SetWindowTextA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL SetWindowTextA(HWND hWnd, LPCSTR lpString)
     * }
     */
    public static int SetWindowTextA(MemorySegment hWnd, MemorySegment lpString) {
        var mh$ = SetWindowTextA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetWindowTextA", hWnd, lpString);
            }
            return (int)mh$.invokeExact(hWnd, lpString);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetWindowTextW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("SetWindowTextW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetWindowTextW(HWND hWnd, LPCWSTR lpString)
     * }
     */
    public static FunctionDescriptor SetWindowTextW$descriptor() {
        return SetWindowTextW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetWindowTextW(HWND hWnd, LPCWSTR lpString)
     * }
     */
    public static MethodHandle SetWindowTextW$handle() {
        return SetWindowTextW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL SetWindowTextW(HWND hWnd, LPCWSTR lpString)
     * }
     */
    public static int SetWindowTextW(MemorySegment hWnd, MemorySegment lpString) {
        var mh$ = SetWindowTextW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetWindowTextW", hWnd, lpString);
            }
            return (int)mh$.invokeExact(hWnd, lpString);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetWindowTextA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetWindowTextA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int GetWindowTextA(HWND hWnd, LPSTR lpString, int nMaxCount)
     * }
     */
    public static FunctionDescriptor GetWindowTextA$descriptor() {
        return GetWindowTextA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int GetWindowTextA(HWND hWnd, LPSTR lpString, int nMaxCount)
     * }
     */
    public static MethodHandle GetWindowTextA$handle() {
        return GetWindowTextA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int GetWindowTextA(HWND hWnd, LPSTR lpString, int nMaxCount)
     * }
     */
    public static int GetWindowTextA(MemorySegment hWnd, MemorySegment lpString, int nMaxCount) {
        var mh$ = GetWindowTextA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetWindowTextA", hWnd, lpString, nMaxCount);
            }
            return (int)mh$.invokeExact(hWnd, lpString, nMaxCount);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetWindowTextW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetWindowTextW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int GetWindowTextW(HWND hWnd, LPWSTR lpString, int nMaxCount)
     * }
     */
    public static FunctionDescriptor GetWindowTextW$descriptor() {
        return GetWindowTextW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int GetWindowTextW(HWND hWnd, LPWSTR lpString, int nMaxCount)
     * }
     */
    public static MethodHandle GetWindowTextW$handle() {
        return GetWindowTextW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int GetWindowTextW(HWND hWnd, LPWSTR lpString, int nMaxCount)
     * }
     */
    public static int GetWindowTextW(MemorySegment hWnd, MemorySegment lpString, int nMaxCount) {
        var mh$ = GetWindowTextW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetWindowTextW", hWnd, lpString, nMaxCount);
            }
            return (int)mh$.invokeExact(hWnd, lpString, nMaxCount);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetWindowTextLengthA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetWindowTextLengthA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int GetWindowTextLengthA(HWND hWnd)
     * }
     */
    public static FunctionDescriptor GetWindowTextLengthA$descriptor() {
        return GetWindowTextLengthA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int GetWindowTextLengthA(HWND hWnd)
     * }
     */
    public static MethodHandle GetWindowTextLengthA$handle() {
        return GetWindowTextLengthA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int GetWindowTextLengthA(HWND hWnd)
     * }
     */
    public static int GetWindowTextLengthA(MemorySegment hWnd) {
        var mh$ = GetWindowTextLengthA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetWindowTextLengthA", hWnd);
            }
            return (int)mh$.invokeExact(hWnd);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetWindowTextLengthW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetWindowTextLengthW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int GetWindowTextLengthW(HWND hWnd)
     * }
     */
    public static FunctionDescriptor GetWindowTextLengthW$descriptor() {
        return GetWindowTextLengthW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int GetWindowTextLengthW(HWND hWnd)
     * }
     */
    public static MethodHandle GetWindowTextLengthW$handle() {
        return GetWindowTextLengthW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int GetWindowTextLengthW(HWND hWnd)
     * }
     */
    public static int GetWindowTextLengthW(MemorySegment hWnd) {
        var mh$ = GetWindowTextLengthW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetWindowTextLengthW", hWnd);
            }
            return (int)mh$.invokeExact(hWnd);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetClientRect {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetClientRect"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetClientRect(HWND hWnd, LPRECT lpRect)
     * }
     */
    public static FunctionDescriptor GetClientRect$descriptor() {
        return GetClientRect.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetClientRect(HWND hWnd, LPRECT lpRect)
     * }
     */
    public static MethodHandle GetClientRect$handle() {
        return GetClientRect.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL GetClientRect(HWND hWnd, LPRECT lpRect)
     * }
     */
    public static int GetClientRect(MemorySegment hWnd, MemorySegment lpRect) {
        var mh$ = GetClientRect.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetClientRect", hWnd, lpRect);
            }
            return (int)mh$.invokeExact(hWnd, lpRect);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetWindowRect {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetWindowRect"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetWindowRect(HWND hWnd, LPRECT lpRect)
     * }
     */
    public static FunctionDescriptor GetWindowRect$descriptor() {
        return GetWindowRect.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetWindowRect(HWND hWnd, LPRECT lpRect)
     * }
     */
    public static MethodHandle GetWindowRect$handle() {
        return GetWindowRect.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL GetWindowRect(HWND hWnd, LPRECT lpRect)
     * }
     */
    public static int GetWindowRect(MemorySegment hWnd, MemorySegment lpRect) {
        var mh$ = GetWindowRect.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetWindowRect", hWnd, lpRect);
            }
            return (int)mh$.invokeExact(hWnd, lpRect);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class AdjustWindowRect {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_LONG,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("AdjustWindowRect"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL AdjustWindowRect(LPRECT lpRect, DWORD dwStyle, BOOL bMenu)
     * }
     */
    public static FunctionDescriptor AdjustWindowRect$descriptor() {
        return AdjustWindowRect.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL AdjustWindowRect(LPRECT lpRect, DWORD dwStyle, BOOL bMenu)
     * }
     */
    public static MethodHandle AdjustWindowRect$handle() {
        return AdjustWindowRect.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL AdjustWindowRect(LPRECT lpRect, DWORD dwStyle, BOOL bMenu)
     * }
     */
    public static int AdjustWindowRect(MemorySegment lpRect, int dwStyle, int bMenu) {
        var mh$ = AdjustWindowRect.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("AdjustWindowRect", lpRect, dwStyle, bMenu);
            }
            return (int)mh$.invokeExact(lpRect, dwStyle, bMenu);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class AdjustWindowRectEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_LONG,
            C_INT,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("AdjustWindowRectEx"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL AdjustWindowRectEx(LPRECT lpRect, DWORD dwStyle, BOOL bMenu, DWORD dwExStyle)
     * }
     */
    public static FunctionDescriptor AdjustWindowRectEx$descriptor() {
        return AdjustWindowRectEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL AdjustWindowRectEx(LPRECT lpRect, DWORD dwStyle, BOOL bMenu, DWORD dwExStyle)
     * }
     */
    public static MethodHandle AdjustWindowRectEx$handle() {
        return AdjustWindowRectEx.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL AdjustWindowRectEx(LPRECT lpRect, DWORD dwStyle, BOOL bMenu, DWORD dwExStyle)
     * }
     */
    public static int AdjustWindowRectEx(MemorySegment lpRect, int dwStyle, int bMenu, int dwExStyle) {
        var mh$ = AdjustWindowRectEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("AdjustWindowRectEx", lpRect, dwStyle, bMenu, dwExStyle);
            }
            return (int)mh$.invokeExact(lpRect, dwStyle, bMenu, dwExStyle);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class AdjustWindowRectExForDpi {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_LONG,
            C_INT,
            C_LONG,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("AdjustWindowRectExForDpi"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL AdjustWindowRectExForDpi(LPRECT lpRect, DWORD dwStyle, BOOL bMenu, DWORD dwExStyle, UINT dpi)
     * }
     */
    public static FunctionDescriptor AdjustWindowRectExForDpi$descriptor() {
        return AdjustWindowRectExForDpi.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL AdjustWindowRectExForDpi(LPRECT lpRect, DWORD dwStyle, BOOL bMenu, DWORD dwExStyle, UINT dpi)
     * }
     */
    public static MethodHandle AdjustWindowRectExForDpi$handle() {
        return AdjustWindowRectExForDpi.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL AdjustWindowRectExForDpi(LPRECT lpRect, DWORD dwStyle, BOOL bMenu, DWORD dwExStyle, UINT dpi)
     * }
     */
    public static int AdjustWindowRectExForDpi(MemorySegment lpRect, int dwStyle, int bMenu, int dwExStyle, int dpi) {
        var mh$ = AdjustWindowRectExForDpi.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("AdjustWindowRectExForDpi", lpRect, dwStyle, bMenu, dwExStyle, dpi);
            }
            return (int)mh$.invokeExact(lpRect, dwStyle, bMenu, dwExStyle, dpi);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct tagHELPINFO {
     *     UINT cbSize;
     *     int iContextType;
     *     int iCtrlId;
     *     HANDLE hItemHandle;
     *     DWORD_PTR dwContextId;
     *     POINT MousePos;
     * } *LPHELPINFO
     * }
     */
    public static final AddressLayout LPHELPINFO = C_POINTER;

    private static class SetWindowContextHelpId {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("SetWindowContextHelpId"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetWindowContextHelpId(HWND, DWORD)
     * }
     */
    public static FunctionDescriptor SetWindowContextHelpId$descriptor() {
        return SetWindowContextHelpId.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetWindowContextHelpId(HWND, DWORD)
     * }
     */
    public static MethodHandle SetWindowContextHelpId$handle() {
        return SetWindowContextHelpId.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL SetWindowContextHelpId(HWND, DWORD)
     * }
     */
    public static int SetWindowContextHelpId(MemorySegment x0, int x1) {
        var mh$ = SetWindowContextHelpId.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetWindowContextHelpId", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetWindowContextHelpId {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetWindowContextHelpId"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetWindowContextHelpId(HWND)
     * }
     */
    public static FunctionDescriptor GetWindowContextHelpId$descriptor() {
        return GetWindowContextHelpId.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetWindowContextHelpId(HWND)
     * }
     */
    public static MethodHandle GetWindowContextHelpId$handle() {
        return GetWindowContextHelpId.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * DWORD GetWindowContextHelpId(HWND)
     * }
     */
    public static int GetWindowContextHelpId(MemorySegment x0) {
        var mh$ = GetWindowContextHelpId.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetWindowContextHelpId", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetMenuContextHelpId {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("SetMenuContextHelpId"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetMenuContextHelpId(HMENU, DWORD)
     * }
     */
    public static FunctionDescriptor SetMenuContextHelpId$descriptor() {
        return SetMenuContextHelpId.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetMenuContextHelpId(HMENU, DWORD)
     * }
     */
    public static MethodHandle SetMenuContextHelpId$handle() {
        return SetMenuContextHelpId.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL SetMenuContextHelpId(HMENU, DWORD)
     * }
     */
    public static int SetMenuContextHelpId(MemorySegment x0, int x1) {
        var mh$ = SetMenuContextHelpId.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetMenuContextHelpId", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetMenuContextHelpId {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetMenuContextHelpId"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetMenuContextHelpId(HMENU)
     * }
     */
    public static FunctionDescriptor GetMenuContextHelpId$descriptor() {
        return GetMenuContextHelpId.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetMenuContextHelpId(HMENU)
     * }
     */
    public static MethodHandle GetMenuContextHelpId$handle() {
        return GetMenuContextHelpId.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * DWORD GetMenuContextHelpId(HMENU)
     * }
     */
    public static int GetMenuContextHelpId(MemorySegment x0) {
        var mh$ = GetMenuContextHelpId.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetMenuContextHelpId", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MessageBoxA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("MessageBoxA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int MessageBoxA(HWND hWnd, LPCSTR lpText, LPCSTR lpCaption, UINT uType)
     * }
     */
    public static FunctionDescriptor MessageBoxA$descriptor() {
        return MessageBoxA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int MessageBoxA(HWND hWnd, LPCSTR lpText, LPCSTR lpCaption, UINT uType)
     * }
     */
    public static MethodHandle MessageBoxA$handle() {
        return MessageBoxA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int MessageBoxA(HWND hWnd, LPCSTR lpText, LPCSTR lpCaption, UINT uType)
     * }
     */
    public static int MessageBoxA(MemorySegment hWnd, MemorySegment lpText, MemorySegment lpCaption, int uType) {
        var mh$ = MessageBoxA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MessageBoxA", hWnd, lpText, lpCaption, uType);
            }
            return (int)mh$.invokeExact(hWnd, lpText, lpCaption, uType);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MessageBoxW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("MessageBoxW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int MessageBoxW(HWND hWnd, LPCWSTR lpText, LPCWSTR lpCaption, UINT uType)
     * }
     */
    public static FunctionDescriptor MessageBoxW$descriptor() {
        return MessageBoxW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int MessageBoxW(HWND hWnd, LPCWSTR lpText, LPCWSTR lpCaption, UINT uType)
     * }
     */
    public static MethodHandle MessageBoxW$handle() {
        return MessageBoxW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int MessageBoxW(HWND hWnd, LPCWSTR lpText, LPCWSTR lpCaption, UINT uType)
     * }
     */
    public static int MessageBoxW(MemorySegment hWnd, MemorySegment lpText, MemorySegment lpCaption, int uType) {
        var mh$ = MessageBoxW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MessageBoxW", hWnd, lpText, lpCaption, uType);
            }
            return (int)mh$.invokeExact(hWnd, lpText, lpCaption, uType);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MessageBoxExA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_INT,
            C_SHORT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("MessageBoxExA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int MessageBoxExA(HWND hWnd, LPCSTR lpText, LPCSTR lpCaption, UINT uType, WORD wLanguageId)
     * }
     */
    public static FunctionDescriptor MessageBoxExA$descriptor() {
        return MessageBoxExA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int MessageBoxExA(HWND hWnd, LPCSTR lpText, LPCSTR lpCaption, UINT uType, WORD wLanguageId)
     * }
     */
    public static MethodHandle MessageBoxExA$handle() {
        return MessageBoxExA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int MessageBoxExA(HWND hWnd, LPCSTR lpText, LPCSTR lpCaption, UINT uType, WORD wLanguageId)
     * }
     */
    public static int MessageBoxExA(MemorySegment hWnd, MemorySegment lpText, MemorySegment lpCaption, int uType, short wLanguageId) {
        var mh$ = MessageBoxExA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MessageBoxExA", hWnd, lpText, lpCaption, uType, wLanguageId);
            }
            return (int)mh$.invokeExact(hWnd, lpText, lpCaption, uType, wLanguageId);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MessageBoxExW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_INT,
            C_SHORT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("MessageBoxExW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int MessageBoxExW(HWND hWnd, LPCWSTR lpText, LPCWSTR lpCaption, UINT uType, WORD wLanguageId)
     * }
     */
    public static FunctionDescriptor MessageBoxExW$descriptor() {
        return MessageBoxExW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int MessageBoxExW(HWND hWnd, LPCWSTR lpText, LPCWSTR lpCaption, UINT uType, WORD wLanguageId)
     * }
     */
    public static MethodHandle MessageBoxExW$handle() {
        return MessageBoxExW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int MessageBoxExW(HWND hWnd, LPCWSTR lpText, LPCWSTR lpCaption, UINT uType, WORD wLanguageId)
     * }
     */
    public static int MessageBoxExW(MemorySegment hWnd, MemorySegment lpText, MemorySegment lpCaption, int uType, short wLanguageId) {
        var mh$ = MessageBoxExW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MessageBoxExW", hWnd, lpText, lpCaption, uType, wLanguageId);
            }
            return (int)mh$.invokeExact(hWnd, lpText, lpCaption, uType, wLanguageId);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct tagMSGBOXPARAMSA {
     *     UINT cbSize;
     *     HWND hwndOwner;
     *     HINSTANCE hInstance;
     *     LPCSTR lpszText;
     *     LPCSTR lpszCaption;
     *     DWORD dwStyle;
     *     LPCSTR lpszIcon;
     *     DWORD_PTR dwContextHelpId;
     *     MSGBOXCALLBACK lpfnMsgBoxCallback;
     *     DWORD dwLanguageId;
     * } *PMSGBOXPARAMSA
     * }
     */
    public static final AddressLayout PMSGBOXPARAMSA = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagMSGBOXPARAMSA {
     *     UINT cbSize;
     *     HWND hwndOwner;
     *     HINSTANCE hInstance;
     *     LPCSTR lpszText;
     *     LPCSTR lpszCaption;
     *     DWORD dwStyle;
     *     LPCSTR lpszIcon;
     *     DWORD_PTR dwContextHelpId;
     *     MSGBOXCALLBACK lpfnMsgBoxCallback;
     *     DWORD dwLanguageId;
     * } *LPMSGBOXPARAMSA
     * }
     */
    public static final AddressLayout LPMSGBOXPARAMSA = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagMSGBOXPARAMSW {
     *     UINT cbSize;
     *     HWND hwndOwner;
     *     HINSTANCE hInstance;
     *     LPCWSTR lpszText;
     *     LPCWSTR lpszCaption;
     *     DWORD dwStyle;
     *     LPCWSTR lpszIcon;
     *     DWORD_PTR dwContextHelpId;
     *     MSGBOXCALLBACK lpfnMsgBoxCallback;
     *     DWORD dwLanguageId;
     * } *PMSGBOXPARAMSW
     * }
     */
    public static final AddressLayout PMSGBOXPARAMSW = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagMSGBOXPARAMSW {
     *     UINT cbSize;
     *     HWND hwndOwner;
     *     HINSTANCE hInstance;
     *     LPCWSTR lpszText;
     *     LPCWSTR lpszCaption;
     *     DWORD dwStyle;
     *     LPCWSTR lpszIcon;
     *     DWORD_PTR dwContextHelpId;
     *     MSGBOXCALLBACK lpfnMsgBoxCallback;
     *     DWORD dwLanguageId;
     * } *LPMSGBOXPARAMSW
     * }
     */
    public static final AddressLayout LPMSGBOXPARAMSW = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef PMSGBOXPARAMSA PMSGBOXPARAMS
     * }
     */
    public static final AddressLayout PMSGBOXPARAMS = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef LPMSGBOXPARAMSA LPMSGBOXPARAMS
     * }
     */
    public static final AddressLayout LPMSGBOXPARAMS = C_POINTER;

    private static class MessageBoxIndirectA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("MessageBoxIndirectA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int MessageBoxIndirectA(const MSGBOXPARAMSA *lpmbp)
     * }
     */
    public static FunctionDescriptor MessageBoxIndirectA$descriptor() {
        return MessageBoxIndirectA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int MessageBoxIndirectA(const MSGBOXPARAMSA *lpmbp)
     * }
     */
    public static MethodHandle MessageBoxIndirectA$handle() {
        return MessageBoxIndirectA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int MessageBoxIndirectA(const MSGBOXPARAMSA *lpmbp)
     * }
     */
    public static int MessageBoxIndirectA(MemorySegment lpmbp) {
        var mh$ = MessageBoxIndirectA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MessageBoxIndirectA", lpmbp);
            }
            return (int)mh$.invokeExact(lpmbp);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MessageBoxIndirectW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("MessageBoxIndirectW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int MessageBoxIndirectW(const MSGBOXPARAMSW *lpmbp)
     * }
     */
    public static FunctionDescriptor MessageBoxIndirectW$descriptor() {
        return MessageBoxIndirectW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int MessageBoxIndirectW(const MSGBOXPARAMSW *lpmbp)
     * }
     */
    public static MethodHandle MessageBoxIndirectW$handle() {
        return MessageBoxIndirectW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int MessageBoxIndirectW(const MSGBOXPARAMSW *lpmbp)
     * }
     */
    public static int MessageBoxIndirectW(MemorySegment lpmbp) {
        var mh$ = MessageBoxIndirectW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MessageBoxIndirectW", lpmbp);
            }
            return (int)mh$.invokeExact(lpmbp);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MessageBeep {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("MessageBeep"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL MessageBeep(UINT uType)
     * }
     */
    public static FunctionDescriptor MessageBeep$descriptor() {
        return MessageBeep.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL MessageBeep(UINT uType)
     * }
     */
    public static MethodHandle MessageBeep$handle() {
        return MessageBeep.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL MessageBeep(UINT uType)
     * }
     */
    public static int MessageBeep(int uType) {
        var mh$ = MessageBeep.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MessageBeep", uType);
            }
            return (int)mh$.invokeExact(uType);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ShowCursor {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("ShowCursor"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int ShowCursor(BOOL bShow)
     * }
     */
    public static FunctionDescriptor ShowCursor$descriptor() {
        return ShowCursor.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int ShowCursor(BOOL bShow)
     * }
     */
    public static MethodHandle ShowCursor$handle() {
        return ShowCursor.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int ShowCursor(BOOL bShow)
     * }
     */
    public static int ShowCursor(int bShow) {
        var mh$ = ShowCursor.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ShowCursor", bShow);
            }
            return (int)mh$.invokeExact(bShow);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetCursorPos {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_INT,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("SetCursorPos"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetCursorPos(int X, int Y)
     * }
     */
    public static FunctionDescriptor SetCursorPos$descriptor() {
        return SetCursorPos.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetCursorPos(int X, int Y)
     * }
     */
    public static MethodHandle SetCursorPos$handle() {
        return SetCursorPos.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL SetCursorPos(int X, int Y)
     * }
     */
    public static int SetCursorPos(int X, int Y) {
        var mh$ = SetCursorPos.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetCursorPos", X, Y);
            }
            return (int)mh$.invokeExact(X, Y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetPhysicalCursorPos {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_INT,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("SetPhysicalCursorPos"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetPhysicalCursorPos(int X, int Y)
     * }
     */
    public static FunctionDescriptor SetPhysicalCursorPos$descriptor() {
        return SetPhysicalCursorPos.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetPhysicalCursorPos(int X, int Y)
     * }
     */
    public static MethodHandle SetPhysicalCursorPos$handle() {
        return SetPhysicalCursorPos.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL SetPhysicalCursorPos(int X, int Y)
     * }
     */
    public static int SetPhysicalCursorPos(int X, int Y) {
        var mh$ = SetPhysicalCursorPos.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetPhysicalCursorPos", X, Y);
            }
            return (int)mh$.invokeExact(X, Y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetCursor {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("SetCursor"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HCURSOR SetCursor(HCURSOR hCursor)
     * }
     */
    public static FunctionDescriptor SetCursor$descriptor() {
        return SetCursor.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HCURSOR SetCursor(HCURSOR hCursor)
     * }
     */
    public static MethodHandle SetCursor$handle() {
        return SetCursor.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * HCURSOR SetCursor(HCURSOR hCursor)
     * }
     */
    public static MemorySegment SetCursor(MemorySegment hCursor) {
        var mh$ = SetCursor.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetCursor", hCursor);
            }
            return (MemorySegment)mh$.invokeExact(hCursor);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetCursorPos {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetCursorPos"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetCursorPos(LPPOINT lpPoint)
     * }
     */
    public static FunctionDescriptor GetCursorPos$descriptor() {
        return GetCursorPos.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetCursorPos(LPPOINT lpPoint)
     * }
     */
    public static MethodHandle GetCursorPos$handle() {
        return GetCursorPos.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL GetCursorPos(LPPOINT lpPoint)
     * }
     */
    public static int GetCursorPos(MemorySegment lpPoint) {
        var mh$ = GetCursorPos.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetCursorPos", lpPoint);
            }
            return (int)mh$.invokeExact(lpPoint);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetPhysicalCursorPos {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetPhysicalCursorPos"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetPhysicalCursorPos(LPPOINT lpPoint)
     * }
     */
    public static FunctionDescriptor GetPhysicalCursorPos$descriptor() {
        return GetPhysicalCursorPos.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetPhysicalCursorPos(LPPOINT lpPoint)
     * }
     */
    public static MethodHandle GetPhysicalCursorPos$handle() {
        return GetPhysicalCursorPos.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL GetPhysicalCursorPos(LPPOINT lpPoint)
     * }
     */
    public static int GetPhysicalCursorPos(MemorySegment lpPoint) {
        var mh$ = GetPhysicalCursorPos.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetPhysicalCursorPos", lpPoint);
            }
            return (int)mh$.invokeExact(lpPoint);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetClipCursor {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetClipCursor"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetClipCursor(LPRECT lpRect)
     * }
     */
    public static FunctionDescriptor GetClipCursor$descriptor() {
        return GetClipCursor.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetClipCursor(LPRECT lpRect)
     * }
     */
    public static MethodHandle GetClipCursor$handle() {
        return GetClipCursor.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL GetClipCursor(LPRECT lpRect)
     * }
     */
    public static int GetClipCursor(MemorySegment lpRect) {
        var mh$ = GetClipCursor.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetClipCursor", lpRect);
            }
            return (int)mh$.invokeExact(lpRect);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetCursor {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER    );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetCursor"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HCURSOR GetCursor()
     * }
     */
    public static FunctionDescriptor GetCursor$descriptor() {
        return GetCursor.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HCURSOR GetCursor()
     * }
     */
    public static MethodHandle GetCursor$handle() {
        return GetCursor.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * HCURSOR GetCursor()
     * }
     */
    public static MemorySegment GetCursor() {
        var mh$ = GetCursor.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetCursor");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateCaret {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_INT,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CreateCaret"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CreateCaret(HWND hWnd, HBITMAP hBitmap, int nWidth, int nHeight)
     * }
     */
    public static FunctionDescriptor CreateCaret$descriptor() {
        return CreateCaret.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CreateCaret(HWND hWnd, HBITMAP hBitmap, int nWidth, int nHeight)
     * }
     */
    public static MethodHandle CreateCaret$handle() {
        return CreateCaret.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL CreateCaret(HWND hWnd, HBITMAP hBitmap, int nWidth, int nHeight)
     * }
     */
    public static int CreateCaret(MemorySegment hWnd, MemorySegment hBitmap, int nWidth, int nHeight) {
        var mh$ = CreateCaret.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateCaret", hWnd, hBitmap, nWidth, nHeight);
            }
            return (int)mh$.invokeExact(hWnd, hBitmap, nWidth, nHeight);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetCaretBlinkTime {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT    );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetCaretBlinkTime"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * UINT GetCaretBlinkTime()
     * }
     */
    public static FunctionDescriptor GetCaretBlinkTime$descriptor() {
        return GetCaretBlinkTime.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * UINT GetCaretBlinkTime()
     * }
     */
    public static MethodHandle GetCaretBlinkTime$handle() {
        return GetCaretBlinkTime.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * UINT GetCaretBlinkTime()
     * }
     */
    public static int GetCaretBlinkTime() {
        var mh$ = GetCaretBlinkTime.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetCaretBlinkTime");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetCaretBlinkTime {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("SetCaretBlinkTime"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetCaretBlinkTime(UINT uMSeconds)
     * }
     */
    public static FunctionDescriptor SetCaretBlinkTime$descriptor() {
        return SetCaretBlinkTime.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetCaretBlinkTime(UINT uMSeconds)
     * }
     */
    public static MethodHandle SetCaretBlinkTime$handle() {
        return SetCaretBlinkTime.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL SetCaretBlinkTime(UINT uMSeconds)
     * }
     */
    public static int SetCaretBlinkTime(int uMSeconds) {
        var mh$ = SetCaretBlinkTime.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetCaretBlinkTime", uMSeconds);
            }
            return (int)mh$.invokeExact(uMSeconds);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DestroyCaret {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT    );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("DestroyCaret"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL DestroyCaret()
     * }
     */
    public static FunctionDescriptor DestroyCaret$descriptor() {
        return DestroyCaret.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL DestroyCaret()
     * }
     */
    public static MethodHandle DestroyCaret$handle() {
        return DestroyCaret.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL DestroyCaret()
     * }
     */
    public static int DestroyCaret() {
        var mh$ = DestroyCaret.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DestroyCaret");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class HideCaret {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("HideCaret"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL HideCaret(HWND hWnd)
     * }
     */
    public static FunctionDescriptor HideCaret$descriptor() {
        return HideCaret.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL HideCaret(HWND hWnd)
     * }
     */
    public static MethodHandle HideCaret$handle() {
        return HideCaret.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL HideCaret(HWND hWnd)
     * }
     */
    public static int HideCaret(MemorySegment hWnd) {
        var mh$ = HideCaret.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("HideCaret", hWnd);
            }
            return (int)mh$.invokeExact(hWnd);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ShowCaret {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("ShowCaret"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL ShowCaret(HWND hWnd)
     * }
     */
    public static FunctionDescriptor ShowCaret$descriptor() {
        return ShowCaret.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL ShowCaret(HWND hWnd)
     * }
     */
    public static MethodHandle ShowCaret$handle() {
        return ShowCaret.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL ShowCaret(HWND hWnd)
     * }
     */
    public static int ShowCaret(MemorySegment hWnd) {
        var mh$ = ShowCaret.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ShowCaret", hWnd);
            }
            return (int)mh$.invokeExact(hWnd);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetCaretPos {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_INT,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("SetCaretPos"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetCaretPos(int X, int Y)
     * }
     */
    public static FunctionDescriptor SetCaretPos$descriptor() {
        return SetCaretPos.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetCaretPos(int X, int Y)
     * }
     */
    public static MethodHandle SetCaretPos$handle() {
        return SetCaretPos.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL SetCaretPos(int X, int Y)
     * }
     */
    public static int SetCaretPos(int X, int Y) {
        var mh$ = SetCaretPos.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetCaretPos", X, Y);
            }
            return (int)mh$.invokeExact(X, Y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetCaretPos {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetCaretPos"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetCaretPos(LPPOINT lpPoint)
     * }
     */
    public static FunctionDescriptor GetCaretPos$descriptor() {
        return GetCaretPos.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetCaretPos(LPPOINT lpPoint)
     * }
     */
    public static MethodHandle GetCaretPos$handle() {
        return GetCaretPos.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL GetCaretPos(LPPOINT lpPoint)
     * }
     */
    public static int GetCaretPos(MemorySegment lpPoint) {
        var mh$ = GetCaretPos.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetCaretPos", lpPoint);
            }
            return (int)mh$.invokeExact(lpPoint);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ClientToScreen {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("ClientToScreen"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL ClientToScreen(HWND hWnd, LPPOINT lpPoint)
     * }
     */
    public static FunctionDescriptor ClientToScreen$descriptor() {
        return ClientToScreen.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL ClientToScreen(HWND hWnd, LPPOINT lpPoint)
     * }
     */
    public static MethodHandle ClientToScreen$handle() {
        return ClientToScreen.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL ClientToScreen(HWND hWnd, LPPOINT lpPoint)
     * }
     */
    public static int ClientToScreen(MemorySegment hWnd, MemorySegment lpPoint) {
        var mh$ = ClientToScreen.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ClientToScreen", hWnd, lpPoint);
            }
            return (int)mh$.invokeExact(hWnd, lpPoint);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ScreenToClient {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("ScreenToClient"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL ScreenToClient(HWND hWnd, LPPOINT lpPoint)
     * }
     */
    public static FunctionDescriptor ScreenToClient$descriptor() {
        return ScreenToClient.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL ScreenToClient(HWND hWnd, LPPOINT lpPoint)
     * }
     */
    public static MethodHandle ScreenToClient$handle() {
        return ScreenToClient.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL ScreenToClient(HWND hWnd, LPPOINT lpPoint)
     * }
     */
    public static int ScreenToClient(MemorySegment hWnd, MemorySegment lpPoint) {
        var mh$ = ScreenToClient.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ScreenToClient", hWnd, lpPoint);
            }
            return (int)mh$.invokeExact(hWnd, lpPoint);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LogicalToPhysicalPoint {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("LogicalToPhysicalPoint"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL LogicalToPhysicalPoint(HWND hWnd, LPPOINT lpPoint)
     * }
     */
    public static FunctionDescriptor LogicalToPhysicalPoint$descriptor() {
        return LogicalToPhysicalPoint.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL LogicalToPhysicalPoint(HWND hWnd, LPPOINT lpPoint)
     * }
     */
    public static MethodHandle LogicalToPhysicalPoint$handle() {
        return LogicalToPhysicalPoint.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL LogicalToPhysicalPoint(HWND hWnd, LPPOINT lpPoint)
     * }
     */
    public static int LogicalToPhysicalPoint(MemorySegment hWnd, MemorySegment lpPoint) {
        var mh$ = LogicalToPhysicalPoint.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LogicalToPhysicalPoint", hWnd, lpPoint);
            }
            return (int)mh$.invokeExact(hWnd, lpPoint);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PhysicalToLogicalPoint {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("PhysicalToLogicalPoint"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL PhysicalToLogicalPoint(HWND hWnd, LPPOINT lpPoint)
     * }
     */
    public static FunctionDescriptor PhysicalToLogicalPoint$descriptor() {
        return PhysicalToLogicalPoint.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL PhysicalToLogicalPoint(HWND hWnd, LPPOINT lpPoint)
     * }
     */
    public static MethodHandle PhysicalToLogicalPoint$handle() {
        return PhysicalToLogicalPoint.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL PhysicalToLogicalPoint(HWND hWnd, LPPOINT lpPoint)
     * }
     */
    public static int PhysicalToLogicalPoint(MemorySegment hWnd, MemorySegment lpPoint) {
        var mh$ = PhysicalToLogicalPoint.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PhysicalToLogicalPoint", hWnd, lpPoint);
            }
            return (int)mh$.invokeExact(hWnd, lpPoint);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LogicalToPhysicalPointForPerMonitorDPI {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("LogicalToPhysicalPointForPerMonitorDPI"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL LogicalToPhysicalPointForPerMonitorDPI(HWND hWnd, LPPOINT lpPoint)
     * }
     */
    public static FunctionDescriptor LogicalToPhysicalPointForPerMonitorDPI$descriptor() {
        return LogicalToPhysicalPointForPerMonitorDPI.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL LogicalToPhysicalPointForPerMonitorDPI(HWND hWnd, LPPOINT lpPoint)
     * }
     */
    public static MethodHandle LogicalToPhysicalPointForPerMonitorDPI$handle() {
        return LogicalToPhysicalPointForPerMonitorDPI.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL LogicalToPhysicalPointForPerMonitorDPI(HWND hWnd, LPPOINT lpPoint)
     * }
     */
    public static int LogicalToPhysicalPointForPerMonitorDPI(MemorySegment hWnd, MemorySegment lpPoint) {
        var mh$ = LogicalToPhysicalPointForPerMonitorDPI.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LogicalToPhysicalPointForPerMonitorDPI", hWnd, lpPoint);
            }
            return (int)mh$.invokeExact(hWnd, lpPoint);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PhysicalToLogicalPointForPerMonitorDPI {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("PhysicalToLogicalPointForPerMonitorDPI"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL PhysicalToLogicalPointForPerMonitorDPI(HWND hWnd, LPPOINT lpPoint)
     * }
     */
    public static FunctionDescriptor PhysicalToLogicalPointForPerMonitorDPI$descriptor() {
        return PhysicalToLogicalPointForPerMonitorDPI.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL PhysicalToLogicalPointForPerMonitorDPI(HWND hWnd, LPPOINT lpPoint)
     * }
     */
    public static MethodHandle PhysicalToLogicalPointForPerMonitorDPI$handle() {
        return PhysicalToLogicalPointForPerMonitorDPI.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL PhysicalToLogicalPointForPerMonitorDPI(HWND hWnd, LPPOINT lpPoint)
     * }
     */
    public static int PhysicalToLogicalPointForPerMonitorDPI(MemorySegment hWnd, MemorySegment lpPoint) {
        var mh$ = PhysicalToLogicalPointForPerMonitorDPI.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PhysicalToLogicalPointForPerMonitorDPI", hWnd, lpPoint);
            }
            return (int)mh$.invokeExact(hWnd, lpPoint);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MapWindowPoints {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("MapWindowPoints"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int MapWindowPoints(HWND hWndFrom, HWND hWndTo, LPPOINT lpPoints, UINT cPoints)
     * }
     */
    public static FunctionDescriptor MapWindowPoints$descriptor() {
        return MapWindowPoints.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int MapWindowPoints(HWND hWndFrom, HWND hWndTo, LPPOINT lpPoints, UINT cPoints)
     * }
     */
    public static MethodHandle MapWindowPoints$handle() {
        return MapWindowPoints.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int MapWindowPoints(HWND hWndFrom, HWND hWndTo, LPPOINT lpPoints, UINT cPoints)
     * }
     */
    public static int MapWindowPoints(MemorySegment hWndFrom, MemorySegment hWndTo, MemorySegment lpPoints, int cPoints) {
        var mh$ = MapWindowPoints.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MapWindowPoints", hWndFrom, hWndTo, lpPoints, cPoints);
            }
            return (int)mh$.invokeExact(hWndFrom, hWndTo, lpPoints, cPoints);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class WindowFromPoint {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            tagPOINT.layout()
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("WindowFromPoint"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HWND WindowFromPoint(POINT Point)
     * }
     */
    public static FunctionDescriptor WindowFromPoint$descriptor() {
        return WindowFromPoint.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HWND WindowFromPoint(POINT Point)
     * }
     */
    public static MethodHandle WindowFromPoint$handle() {
        return WindowFromPoint.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * HWND WindowFromPoint(POINT Point)
     * }
     */
    public static MemorySegment WindowFromPoint(MemorySegment Point) {
        var mh$ = WindowFromPoint.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WindowFromPoint", Point);
            }
            return (MemorySegment)mh$.invokeExact(Point);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class WindowFromPhysicalPoint {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            tagPOINT.layout()
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("WindowFromPhysicalPoint"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HWND WindowFromPhysicalPoint(POINT Point)
     * }
     */
    public static FunctionDescriptor WindowFromPhysicalPoint$descriptor() {
        return WindowFromPhysicalPoint.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HWND WindowFromPhysicalPoint(POINT Point)
     * }
     */
    public static MethodHandle WindowFromPhysicalPoint$handle() {
        return WindowFromPhysicalPoint.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * HWND WindowFromPhysicalPoint(POINT Point)
     * }
     */
    public static MemorySegment WindowFromPhysicalPoint(MemorySegment Point) {
        var mh$ = WindowFromPhysicalPoint.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WindowFromPhysicalPoint", Point);
            }
            return (MemorySegment)mh$.invokeExact(Point);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ChildWindowFromPoint {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER,
            tagPOINT.layout()
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("ChildWindowFromPoint"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HWND ChildWindowFromPoint(HWND hWndParent, POINT Point)
     * }
     */
    public static FunctionDescriptor ChildWindowFromPoint$descriptor() {
        return ChildWindowFromPoint.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HWND ChildWindowFromPoint(HWND hWndParent, POINT Point)
     * }
     */
    public static MethodHandle ChildWindowFromPoint$handle() {
        return ChildWindowFromPoint.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * HWND ChildWindowFromPoint(HWND hWndParent, POINT Point)
     * }
     */
    public static MemorySegment ChildWindowFromPoint(MemorySegment hWndParent, MemorySegment Point) {
        var mh$ = ChildWindowFromPoint.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ChildWindowFromPoint", hWndParent, Point);
            }
            return (MemorySegment)mh$.invokeExact(hWndParent, Point);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ClipCursor {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("ClipCursor"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL ClipCursor(const RECT *lpRect)
     * }
     */
    public static FunctionDescriptor ClipCursor$descriptor() {
        return ClipCursor.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL ClipCursor(const RECT *lpRect)
     * }
     */
    public static MethodHandle ClipCursor$handle() {
        return ClipCursor.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL ClipCursor(const RECT *lpRect)
     * }
     */
    public static int ClipCursor(MemorySegment lpRect) {
        var mh$ = ClipCursor.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ClipCursor", lpRect);
            }
            return (int)mh$.invokeExact(lpRect);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ChildWindowFromPointEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER,
            tagPOINT.layout(),
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("ChildWindowFromPointEx"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HWND ChildWindowFromPointEx(HWND hwnd, POINT pt, UINT flags)
     * }
     */
    public static FunctionDescriptor ChildWindowFromPointEx$descriptor() {
        return ChildWindowFromPointEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HWND ChildWindowFromPointEx(HWND hwnd, POINT pt, UINT flags)
     * }
     */
    public static MethodHandle ChildWindowFromPointEx$handle() {
        return ChildWindowFromPointEx.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * HWND ChildWindowFromPointEx(HWND hwnd, POINT pt, UINT flags)
     * }
     */
    public static MemorySegment ChildWindowFromPointEx(MemorySegment hwnd, MemorySegment pt, int flags) {
        var mh$ = ChildWindowFromPointEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ChildWindowFromPointEx", hwnd, pt, flags);
            }
            return (MemorySegment)mh$.invokeExact(hwnd, pt, flags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetSysColor {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetSysColor"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetSysColor(int nIndex)
     * }
     */
    public static FunctionDescriptor GetSysColor$descriptor() {
        return GetSysColor.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetSysColor(int nIndex)
     * }
     */
    public static MethodHandle GetSysColor$handle() {
        return GetSysColor.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * DWORD GetSysColor(int nIndex)
     * }
     */
    public static int GetSysColor(int nIndex) {
        var mh$ = GetSysColor.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetSysColor", nIndex);
            }
            return (int)mh$.invokeExact(nIndex);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetSysColorBrush {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetSysColorBrush"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HBRUSH GetSysColorBrush(int nIndex)
     * }
     */
    public static FunctionDescriptor GetSysColorBrush$descriptor() {
        return GetSysColorBrush.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HBRUSH GetSysColorBrush(int nIndex)
     * }
     */
    public static MethodHandle GetSysColorBrush$handle() {
        return GetSysColorBrush.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * HBRUSH GetSysColorBrush(int nIndex)
     * }
     */
    public static MemorySegment GetSysColorBrush(int nIndex) {
        var mh$ = GetSysColorBrush.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetSysColorBrush", nIndex);
            }
            return (MemorySegment)mh$.invokeExact(nIndex);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetSysColors {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_INT,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("SetSysColors"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetSysColors(int cElements, const INT *lpaElements, const COLORREF *lpaRgbValues)
     * }
     */
    public static FunctionDescriptor SetSysColors$descriptor() {
        return SetSysColors.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetSysColors(int cElements, const INT *lpaElements, const COLORREF *lpaRgbValues)
     * }
     */
    public static MethodHandle SetSysColors$handle() {
        return SetSysColors.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL SetSysColors(int cElements, const INT *lpaElements, const COLORREF *lpaRgbValues)
     * }
     */
    public static int SetSysColors(int cElements, MemorySegment lpaElements, MemorySegment lpaRgbValues) {
        var mh$ = SetSysColors.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetSysColors", cElements, lpaElements, lpaRgbValues);
            }
            return (int)mh$.invokeExact(cElements, lpaElements, lpaRgbValues);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DrawFocusRect {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("DrawFocusRect"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL DrawFocusRect(HDC hDC, const RECT *lprc)
     * }
     */
    public static FunctionDescriptor DrawFocusRect$descriptor() {
        return DrawFocusRect.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL DrawFocusRect(HDC hDC, const RECT *lprc)
     * }
     */
    public static MethodHandle DrawFocusRect$handle() {
        return DrawFocusRect.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL DrawFocusRect(HDC hDC, const RECT *lprc)
     * }
     */
    public static int DrawFocusRect(MemorySegment hDC, MemorySegment lprc) {
        var mh$ = DrawFocusRect.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DrawFocusRect", hDC, lprc);
            }
            return (int)mh$.invokeExact(hDC, lprc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FillRect {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("FillRect"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int FillRect(HDC hDC, const RECT *lprc, HBRUSH hbr)
     * }
     */
    public static FunctionDescriptor FillRect$descriptor() {
        return FillRect.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int FillRect(HDC hDC, const RECT *lprc, HBRUSH hbr)
     * }
     */
    public static MethodHandle FillRect$handle() {
        return FillRect.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int FillRect(HDC hDC, const RECT *lprc, HBRUSH hbr)
     * }
     */
    public static int FillRect(MemorySegment hDC, MemorySegment lprc, MemorySegment hbr) {
        var mh$ = FillRect.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FillRect", hDC, lprc, hbr);
            }
            return (int)mh$.invokeExact(hDC, lprc, hbr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FrameRect {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("FrameRect"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int FrameRect(HDC hDC, const RECT *lprc, HBRUSH hbr)
     * }
     */
    public static FunctionDescriptor FrameRect$descriptor() {
        return FrameRect.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int FrameRect(HDC hDC, const RECT *lprc, HBRUSH hbr)
     * }
     */
    public static MethodHandle FrameRect$handle() {
        return FrameRect.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int FrameRect(HDC hDC, const RECT *lprc, HBRUSH hbr)
     * }
     */
    public static int FrameRect(MemorySegment hDC, MemorySegment lprc, MemorySegment hbr) {
        var mh$ = FrameRect.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FrameRect", hDC, lprc, hbr);
            }
            return (int)mh$.invokeExact(hDC, lprc, hbr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class InvertRect {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("InvertRect"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL InvertRect(HDC hDC, const RECT *lprc)
     * }
     */
    public static FunctionDescriptor InvertRect$descriptor() {
        return InvertRect.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL InvertRect(HDC hDC, const RECT *lprc)
     * }
     */
    public static MethodHandle InvertRect$handle() {
        return InvertRect.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL InvertRect(HDC hDC, const RECT *lprc)
     * }
     */
    public static int InvertRect(MemorySegment hDC, MemorySegment lprc) {
        var mh$ = InvertRect.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("InvertRect", hDC, lprc);
            }
            return (int)mh$.invokeExact(hDC, lprc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetRect {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_INT,
            C_INT,
            C_INT,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("SetRect"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetRect(LPRECT lprc, int xLeft, int yTop, int xRight, int yBottom)
     * }
     */
    public static FunctionDescriptor SetRect$descriptor() {
        return SetRect.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetRect(LPRECT lprc, int xLeft, int yTop, int xRight, int yBottom)
     * }
     */
    public static MethodHandle SetRect$handle() {
        return SetRect.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL SetRect(LPRECT lprc, int xLeft, int yTop, int xRight, int yBottom)
     * }
     */
    public static int SetRect(MemorySegment lprc, int xLeft, int yTop, int xRight, int yBottom) {
        var mh$ = SetRect.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetRect", lprc, xLeft, yTop, xRight, yBottom);
            }
            return (int)mh$.invokeExact(lprc, xLeft, yTop, xRight, yBottom);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetRectEmpty {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("SetRectEmpty"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetRectEmpty(LPRECT lprc)
     * }
     */
    public static FunctionDescriptor SetRectEmpty$descriptor() {
        return SetRectEmpty.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetRectEmpty(LPRECT lprc)
     * }
     */
    public static MethodHandle SetRectEmpty$handle() {
        return SetRectEmpty.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL SetRectEmpty(LPRECT lprc)
     * }
     */
    public static int SetRectEmpty(MemorySegment lprc) {
        var mh$ = SetRectEmpty.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetRectEmpty", lprc);
            }
            return (int)mh$.invokeExact(lprc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CopyRect {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CopyRect"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CopyRect(LPRECT lprcDst, const RECT *lprcSrc)
     * }
     */
    public static FunctionDescriptor CopyRect$descriptor() {
        return CopyRect.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CopyRect(LPRECT lprcDst, const RECT *lprcSrc)
     * }
     */
    public static MethodHandle CopyRect$handle() {
        return CopyRect.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL CopyRect(LPRECT lprcDst, const RECT *lprcSrc)
     * }
     */
    public static int CopyRect(MemorySegment lprcDst, MemorySegment lprcSrc) {
        var mh$ = CopyRect.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CopyRect", lprcDst, lprcSrc);
            }
            return (int)mh$.invokeExact(lprcDst, lprcSrc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class InflateRect {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_INT,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("InflateRect"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL InflateRect(LPRECT lprc, int dx, int dy)
     * }
     */
    public static FunctionDescriptor InflateRect$descriptor() {
        return InflateRect.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL InflateRect(LPRECT lprc, int dx, int dy)
     * }
     */
    public static MethodHandle InflateRect$handle() {
        return InflateRect.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL InflateRect(LPRECT lprc, int dx, int dy)
     * }
     */
    public static int InflateRect(MemorySegment lprc, int dx, int dy) {
        var mh$ = InflateRect.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("InflateRect", lprc, dx, dy);
            }
            return (int)mh$.invokeExact(lprc, dx, dy);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class IntersectRect {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("IntersectRect"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL IntersectRect(LPRECT lprcDst, const RECT *lprcSrc1, const RECT *lprcSrc2)
     * }
     */
    public static FunctionDescriptor IntersectRect$descriptor() {
        return IntersectRect.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL IntersectRect(LPRECT lprcDst, const RECT *lprcSrc1, const RECT *lprcSrc2)
     * }
     */
    public static MethodHandle IntersectRect$handle() {
        return IntersectRect.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL IntersectRect(LPRECT lprcDst, const RECT *lprcSrc1, const RECT *lprcSrc2)
     * }
     */
    public static int IntersectRect(MemorySegment lprcDst, MemorySegment lprcSrc1, MemorySegment lprcSrc2) {
        var mh$ = IntersectRect.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("IntersectRect", lprcDst, lprcSrc1, lprcSrc2);
            }
            return (int)mh$.invokeExact(lprcDst, lprcSrc1, lprcSrc2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class UnionRect {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("UnionRect"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL UnionRect(LPRECT lprcDst, const RECT *lprcSrc1, const RECT *lprcSrc2)
     * }
     */
    public static FunctionDescriptor UnionRect$descriptor() {
        return UnionRect.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL UnionRect(LPRECT lprcDst, const RECT *lprcSrc1, const RECT *lprcSrc2)
     * }
     */
    public static MethodHandle UnionRect$handle() {
        return UnionRect.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL UnionRect(LPRECT lprcDst, const RECT *lprcSrc1, const RECT *lprcSrc2)
     * }
     */
    public static int UnionRect(MemorySegment lprcDst, MemorySegment lprcSrc1, MemorySegment lprcSrc2) {
        var mh$ = UnionRect.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("UnionRect", lprcDst, lprcSrc1, lprcSrc2);
            }
            return (int)mh$.invokeExact(lprcDst, lprcSrc1, lprcSrc2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SubtractRect {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("SubtractRect"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SubtractRect(LPRECT lprcDst, const RECT *lprcSrc1, const RECT *lprcSrc2)
     * }
     */
    public static FunctionDescriptor SubtractRect$descriptor() {
        return SubtractRect.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SubtractRect(LPRECT lprcDst, const RECT *lprcSrc1, const RECT *lprcSrc2)
     * }
     */
    public static MethodHandle SubtractRect$handle() {
        return SubtractRect.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL SubtractRect(LPRECT lprcDst, const RECT *lprcSrc1, const RECT *lprcSrc2)
     * }
     */
    public static int SubtractRect(MemorySegment lprcDst, MemorySegment lprcSrc1, MemorySegment lprcSrc2) {
        var mh$ = SubtractRect.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SubtractRect", lprcDst, lprcSrc1, lprcSrc2);
            }
            return (int)mh$.invokeExact(lprcDst, lprcSrc1, lprcSrc2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class OffsetRect {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_INT,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("OffsetRect"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL OffsetRect(LPRECT lprc, int dx, int dy)
     * }
     */
    public static FunctionDescriptor OffsetRect$descriptor() {
        return OffsetRect.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL OffsetRect(LPRECT lprc, int dx, int dy)
     * }
     */
    public static MethodHandle OffsetRect$handle() {
        return OffsetRect.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL OffsetRect(LPRECT lprc, int dx, int dy)
     * }
     */
    public static int OffsetRect(MemorySegment lprc, int dx, int dy) {
        var mh$ = OffsetRect.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("OffsetRect", lprc, dx, dy);
            }
            return (int)mh$.invokeExact(lprc, dx, dy);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class IsRectEmpty {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("IsRectEmpty"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL IsRectEmpty(const RECT *lprc)
     * }
     */
    public static FunctionDescriptor IsRectEmpty$descriptor() {
        return IsRectEmpty.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL IsRectEmpty(const RECT *lprc)
     * }
     */
    public static MethodHandle IsRectEmpty$handle() {
        return IsRectEmpty.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL IsRectEmpty(const RECT *lprc)
     * }
     */
    public static int IsRectEmpty(MemorySegment lprc) {
        var mh$ = IsRectEmpty.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("IsRectEmpty", lprc);
            }
            return (int)mh$.invokeExact(lprc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class EqualRect {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("EqualRect"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL EqualRect(const RECT *lprc1, const RECT *lprc2)
     * }
     */
    public static FunctionDescriptor EqualRect$descriptor() {
        return EqualRect.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL EqualRect(const RECT *lprc1, const RECT *lprc2)
     * }
     */
    public static MethodHandle EqualRect$handle() {
        return EqualRect.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL EqualRect(const RECT *lprc1, const RECT *lprc2)
     * }
     */
    public static int EqualRect(MemorySegment lprc1, MemorySegment lprc2) {
        var mh$ = EqualRect.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("EqualRect", lprc1, lprc2);
            }
            return (int)mh$.invokeExact(lprc1, lprc2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PtInRect {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            tagPOINT.layout()
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("PtInRect"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL PtInRect(const RECT *lprc, POINT pt)
     * }
     */
    public static FunctionDescriptor PtInRect$descriptor() {
        return PtInRect.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL PtInRect(const RECT *lprc, POINT pt)
     * }
     */
    public static MethodHandle PtInRect$handle() {
        return PtInRect.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL PtInRect(const RECT *lprc, POINT pt)
     * }
     */
    public static int PtInRect(MemorySegment lprc, MemorySegment pt) {
        var mh$ = PtInRect.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PtInRect", lprc, pt);
            }
            return (int)mh$.invokeExact(lprc, pt);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetWindowWord {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_SHORT,
            C_POINTER,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetWindowWord"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * WORD GetWindowWord(HWND hWnd, int nIndex)
     * }
     */
    public static FunctionDescriptor GetWindowWord$descriptor() {
        return GetWindowWord.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * WORD GetWindowWord(HWND hWnd, int nIndex)
     * }
     */
    public static MethodHandle GetWindowWord$handle() {
        return GetWindowWord.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * WORD GetWindowWord(HWND hWnd, int nIndex)
     * }
     */
    public static short GetWindowWord(MemorySegment hWnd, int nIndex) {
        var mh$ = GetWindowWord.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetWindowWord", hWnd, nIndex);
            }
            return (short)mh$.invokeExact(hWnd, nIndex);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetWindowWord {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_SHORT,
            C_POINTER,
            C_INT,
            C_SHORT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("SetWindowWord"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * WORD SetWindowWord(HWND hWnd, int nIndex, WORD wNewWord)
     * }
     */
    public static FunctionDescriptor SetWindowWord$descriptor() {
        return SetWindowWord.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * WORD SetWindowWord(HWND hWnd, int nIndex, WORD wNewWord)
     * }
     */
    public static MethodHandle SetWindowWord$handle() {
        return SetWindowWord.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * WORD SetWindowWord(HWND hWnd, int nIndex, WORD wNewWord)
     * }
     */
    public static short SetWindowWord(MemorySegment hWnd, int nIndex, short wNewWord) {
        var mh$ = SetWindowWord.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetWindowWord", hWnd, nIndex, wNewWord);
            }
            return (short)mh$.invokeExact(hWnd, nIndex, wNewWord);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetWindowLongA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_POINTER,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetWindowLongA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LONG GetWindowLongA(HWND hWnd, int nIndex)
     * }
     */
    public static FunctionDescriptor GetWindowLongA$descriptor() {
        return GetWindowLongA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LONG GetWindowLongA(HWND hWnd, int nIndex)
     * }
     */
    public static MethodHandle GetWindowLongA$handle() {
        return GetWindowLongA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * LONG GetWindowLongA(HWND hWnd, int nIndex)
     * }
     */
    public static int GetWindowLongA(MemorySegment hWnd, int nIndex) {
        var mh$ = GetWindowLongA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetWindowLongA", hWnd, nIndex);
            }
            return (int)mh$.invokeExact(hWnd, nIndex);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetWindowLongW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_POINTER,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetWindowLongW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LONG GetWindowLongW(HWND hWnd, int nIndex)
     * }
     */
    public static FunctionDescriptor GetWindowLongW$descriptor() {
        return GetWindowLongW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LONG GetWindowLongW(HWND hWnd, int nIndex)
     * }
     */
    public static MethodHandle GetWindowLongW$handle() {
        return GetWindowLongW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * LONG GetWindowLongW(HWND hWnd, int nIndex)
     * }
     */
    public static int GetWindowLongW(MemorySegment hWnd, int nIndex) {
        var mh$ = GetWindowLongW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetWindowLongW", hWnd, nIndex);
            }
            return (int)mh$.invokeExact(hWnd, nIndex);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetWindowLongA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_POINTER,
            C_INT,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("SetWindowLongA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LONG SetWindowLongA(HWND hWnd, int nIndex, LONG dwNewLong)
     * }
     */
    public static FunctionDescriptor SetWindowLongA$descriptor() {
        return SetWindowLongA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LONG SetWindowLongA(HWND hWnd, int nIndex, LONG dwNewLong)
     * }
     */
    public static MethodHandle SetWindowLongA$handle() {
        return SetWindowLongA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * LONG SetWindowLongA(HWND hWnd, int nIndex, LONG dwNewLong)
     * }
     */
    public static int SetWindowLongA(MemorySegment hWnd, int nIndex, int dwNewLong) {
        var mh$ = SetWindowLongA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetWindowLongA", hWnd, nIndex, dwNewLong);
            }
            return (int)mh$.invokeExact(hWnd, nIndex, dwNewLong);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetWindowLongW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_POINTER,
            C_INT,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("SetWindowLongW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LONG SetWindowLongW(HWND hWnd, int nIndex, LONG dwNewLong)
     * }
     */
    public static FunctionDescriptor SetWindowLongW$descriptor() {
        return SetWindowLongW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LONG SetWindowLongW(HWND hWnd, int nIndex, LONG dwNewLong)
     * }
     */
    public static MethodHandle SetWindowLongW$handle() {
        return SetWindowLongW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * LONG SetWindowLongW(HWND hWnd, int nIndex, LONG dwNewLong)
     * }
     */
    public static int SetWindowLongW(MemorySegment hWnd, int nIndex, int dwNewLong) {
        var mh$ = SetWindowLongW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetWindowLongW", hWnd, nIndex, dwNewLong);
            }
            return (int)mh$.invokeExact(hWnd, nIndex, dwNewLong);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetWindowLongPtrA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG_LONG,
            C_POINTER,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetWindowLongPtrA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LONG_PTR GetWindowLongPtrA(HWND hWnd, int nIndex)
     * }
     */
    public static FunctionDescriptor GetWindowLongPtrA$descriptor() {
        return GetWindowLongPtrA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LONG_PTR GetWindowLongPtrA(HWND hWnd, int nIndex)
     * }
     */
    public static MethodHandle GetWindowLongPtrA$handle() {
        return GetWindowLongPtrA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * LONG_PTR GetWindowLongPtrA(HWND hWnd, int nIndex)
     * }
     */
    public static long GetWindowLongPtrA(MemorySegment hWnd, int nIndex) {
        var mh$ = GetWindowLongPtrA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetWindowLongPtrA", hWnd, nIndex);
            }
            return (long)mh$.invokeExact(hWnd, nIndex);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetWindowLongPtrW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG_LONG,
            C_POINTER,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetWindowLongPtrW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LONG_PTR GetWindowLongPtrW(HWND hWnd, int nIndex)
     * }
     */
    public static FunctionDescriptor GetWindowLongPtrW$descriptor() {
        return GetWindowLongPtrW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LONG_PTR GetWindowLongPtrW(HWND hWnd, int nIndex)
     * }
     */
    public static MethodHandle GetWindowLongPtrW$handle() {
        return GetWindowLongPtrW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * LONG_PTR GetWindowLongPtrW(HWND hWnd, int nIndex)
     * }
     */
    public static long GetWindowLongPtrW(MemorySegment hWnd, int nIndex) {
        var mh$ = GetWindowLongPtrW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetWindowLongPtrW", hWnd, nIndex);
            }
            return (long)mh$.invokeExact(hWnd, nIndex);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetWindowLongPtrA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG_LONG,
            C_POINTER,
            C_INT,
            C_LONG_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("SetWindowLongPtrA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LONG_PTR SetWindowLongPtrA(HWND hWnd, int nIndex, LONG_PTR dwNewLong)
     * }
     */
    public static FunctionDescriptor SetWindowLongPtrA$descriptor() {
        return SetWindowLongPtrA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LONG_PTR SetWindowLongPtrA(HWND hWnd, int nIndex, LONG_PTR dwNewLong)
     * }
     */
    public static MethodHandle SetWindowLongPtrA$handle() {
        return SetWindowLongPtrA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * LONG_PTR SetWindowLongPtrA(HWND hWnd, int nIndex, LONG_PTR dwNewLong)
     * }
     */
    public static long SetWindowLongPtrA(MemorySegment hWnd, int nIndex, long dwNewLong) {
        var mh$ = SetWindowLongPtrA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetWindowLongPtrA", hWnd, nIndex, dwNewLong);
            }
            return (long)mh$.invokeExact(hWnd, nIndex, dwNewLong);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetWindowLongPtrW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG_LONG,
            C_POINTER,
            C_INT,
            C_LONG_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("SetWindowLongPtrW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LONG_PTR SetWindowLongPtrW(HWND hWnd, int nIndex, LONG_PTR dwNewLong)
     * }
     */
    public static FunctionDescriptor SetWindowLongPtrW$descriptor() {
        return SetWindowLongPtrW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LONG_PTR SetWindowLongPtrW(HWND hWnd, int nIndex, LONG_PTR dwNewLong)
     * }
     */
    public static MethodHandle SetWindowLongPtrW$handle() {
        return SetWindowLongPtrW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * LONG_PTR SetWindowLongPtrW(HWND hWnd, int nIndex, LONG_PTR dwNewLong)
     * }
     */
    public static long SetWindowLongPtrW(MemorySegment hWnd, int nIndex, long dwNewLong) {
        var mh$ = SetWindowLongPtrW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetWindowLongPtrW", hWnd, nIndex, dwNewLong);
            }
            return (long)mh$.invokeExact(hWnd, nIndex, dwNewLong);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetClassWord {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_SHORT,
            C_POINTER,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetClassWord"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * WORD GetClassWord(HWND hWnd, int nIndex)
     * }
     */
    public static FunctionDescriptor GetClassWord$descriptor() {
        return GetClassWord.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * WORD GetClassWord(HWND hWnd, int nIndex)
     * }
     */
    public static MethodHandle GetClassWord$handle() {
        return GetClassWord.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * WORD GetClassWord(HWND hWnd, int nIndex)
     * }
     */
    public static short GetClassWord(MemorySegment hWnd, int nIndex) {
        var mh$ = GetClassWord.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetClassWord", hWnd, nIndex);
            }
            return (short)mh$.invokeExact(hWnd, nIndex);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetClassWord {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_SHORT,
            C_POINTER,
            C_INT,
            C_SHORT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("SetClassWord"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * WORD SetClassWord(HWND hWnd, int nIndex, WORD wNewWord)
     * }
     */
    public static FunctionDescriptor SetClassWord$descriptor() {
        return SetClassWord.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * WORD SetClassWord(HWND hWnd, int nIndex, WORD wNewWord)
     * }
     */
    public static MethodHandle SetClassWord$handle() {
        return SetClassWord.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * WORD SetClassWord(HWND hWnd, int nIndex, WORD wNewWord)
     * }
     */
    public static short SetClassWord(MemorySegment hWnd, int nIndex, short wNewWord) {
        var mh$ = SetClassWord.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetClassWord", hWnd, nIndex, wNewWord);
            }
            return (short)mh$.invokeExact(hWnd, nIndex, wNewWord);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetClassLongA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_POINTER,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetClassLongA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetClassLongA(HWND hWnd, int nIndex)
     * }
     */
    public static FunctionDescriptor GetClassLongA$descriptor() {
        return GetClassLongA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetClassLongA(HWND hWnd, int nIndex)
     * }
     */
    public static MethodHandle GetClassLongA$handle() {
        return GetClassLongA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * DWORD GetClassLongA(HWND hWnd, int nIndex)
     * }
     */
    public static int GetClassLongA(MemorySegment hWnd, int nIndex) {
        var mh$ = GetClassLongA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetClassLongA", hWnd, nIndex);
            }
            return (int)mh$.invokeExact(hWnd, nIndex);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetClassLongW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_POINTER,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetClassLongW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetClassLongW(HWND hWnd, int nIndex)
     * }
     */
    public static FunctionDescriptor GetClassLongW$descriptor() {
        return GetClassLongW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetClassLongW(HWND hWnd, int nIndex)
     * }
     */
    public static MethodHandle GetClassLongW$handle() {
        return GetClassLongW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * DWORD GetClassLongW(HWND hWnd, int nIndex)
     * }
     */
    public static int GetClassLongW(MemorySegment hWnd, int nIndex) {
        var mh$ = GetClassLongW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetClassLongW", hWnd, nIndex);
            }
            return (int)mh$.invokeExact(hWnd, nIndex);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetClassLongA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_POINTER,
            C_INT,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("SetClassLongA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD SetClassLongA(HWND hWnd, int nIndex, LONG dwNewLong)
     * }
     */
    public static FunctionDescriptor SetClassLongA$descriptor() {
        return SetClassLongA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD SetClassLongA(HWND hWnd, int nIndex, LONG dwNewLong)
     * }
     */
    public static MethodHandle SetClassLongA$handle() {
        return SetClassLongA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * DWORD SetClassLongA(HWND hWnd, int nIndex, LONG dwNewLong)
     * }
     */
    public static int SetClassLongA(MemorySegment hWnd, int nIndex, int dwNewLong) {
        var mh$ = SetClassLongA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetClassLongA", hWnd, nIndex, dwNewLong);
            }
            return (int)mh$.invokeExact(hWnd, nIndex, dwNewLong);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetClassLongW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_POINTER,
            C_INT,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("SetClassLongW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD SetClassLongW(HWND hWnd, int nIndex, LONG dwNewLong)
     * }
     */
    public static FunctionDescriptor SetClassLongW$descriptor() {
        return SetClassLongW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD SetClassLongW(HWND hWnd, int nIndex, LONG dwNewLong)
     * }
     */
    public static MethodHandle SetClassLongW$handle() {
        return SetClassLongW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * DWORD SetClassLongW(HWND hWnd, int nIndex, LONG dwNewLong)
     * }
     */
    public static int SetClassLongW(MemorySegment hWnd, int nIndex, int dwNewLong) {
        var mh$ = SetClassLongW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetClassLongW", hWnd, nIndex, dwNewLong);
            }
            return (int)mh$.invokeExact(hWnd, nIndex, dwNewLong);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetClassLongPtrA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG_LONG,
            C_POINTER,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetClassLongPtrA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ULONG_PTR GetClassLongPtrA(HWND hWnd, int nIndex)
     * }
     */
    public static FunctionDescriptor GetClassLongPtrA$descriptor() {
        return GetClassLongPtrA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ULONG_PTR GetClassLongPtrA(HWND hWnd, int nIndex)
     * }
     */
    public static MethodHandle GetClassLongPtrA$handle() {
        return GetClassLongPtrA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * ULONG_PTR GetClassLongPtrA(HWND hWnd, int nIndex)
     * }
     */
    public static long GetClassLongPtrA(MemorySegment hWnd, int nIndex) {
        var mh$ = GetClassLongPtrA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetClassLongPtrA", hWnd, nIndex);
            }
            return (long)mh$.invokeExact(hWnd, nIndex);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetClassLongPtrW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG_LONG,
            C_POINTER,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetClassLongPtrW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ULONG_PTR GetClassLongPtrW(HWND hWnd, int nIndex)
     * }
     */
    public static FunctionDescriptor GetClassLongPtrW$descriptor() {
        return GetClassLongPtrW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ULONG_PTR GetClassLongPtrW(HWND hWnd, int nIndex)
     * }
     */
    public static MethodHandle GetClassLongPtrW$handle() {
        return GetClassLongPtrW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * ULONG_PTR GetClassLongPtrW(HWND hWnd, int nIndex)
     * }
     */
    public static long GetClassLongPtrW(MemorySegment hWnd, int nIndex) {
        var mh$ = GetClassLongPtrW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetClassLongPtrW", hWnd, nIndex);
            }
            return (long)mh$.invokeExact(hWnd, nIndex);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetClassLongPtrA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG_LONG,
            C_POINTER,
            C_INT,
            C_LONG_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("SetClassLongPtrA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ULONG_PTR SetClassLongPtrA(HWND hWnd, int nIndex, LONG_PTR dwNewLong)
     * }
     */
    public static FunctionDescriptor SetClassLongPtrA$descriptor() {
        return SetClassLongPtrA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ULONG_PTR SetClassLongPtrA(HWND hWnd, int nIndex, LONG_PTR dwNewLong)
     * }
     */
    public static MethodHandle SetClassLongPtrA$handle() {
        return SetClassLongPtrA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * ULONG_PTR SetClassLongPtrA(HWND hWnd, int nIndex, LONG_PTR dwNewLong)
     * }
     */
    public static long SetClassLongPtrA(MemorySegment hWnd, int nIndex, long dwNewLong) {
        var mh$ = SetClassLongPtrA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetClassLongPtrA", hWnd, nIndex, dwNewLong);
            }
            return (long)mh$.invokeExact(hWnd, nIndex, dwNewLong);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetClassLongPtrW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG_LONG,
            C_POINTER,
            C_INT,
            C_LONG_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("SetClassLongPtrW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ULONG_PTR SetClassLongPtrW(HWND hWnd, int nIndex, LONG_PTR dwNewLong)
     * }
     */
    public static FunctionDescriptor SetClassLongPtrW$descriptor() {
        return SetClassLongPtrW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ULONG_PTR SetClassLongPtrW(HWND hWnd, int nIndex, LONG_PTR dwNewLong)
     * }
     */
    public static MethodHandle SetClassLongPtrW$handle() {
        return SetClassLongPtrW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * ULONG_PTR SetClassLongPtrW(HWND hWnd, int nIndex, LONG_PTR dwNewLong)
     * }
     */
    public static long SetClassLongPtrW(MemorySegment hWnd, int nIndex, long dwNewLong) {
        var mh$ = SetClassLongPtrW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetClassLongPtrW", hWnd, nIndex, dwNewLong);
            }
            return (long)mh$.invokeExact(hWnd, nIndex, dwNewLong);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetProcessDefaultLayout {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetProcessDefaultLayout"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetProcessDefaultLayout(DWORD *pdwDefaultLayout)
     * }
     */
    public static FunctionDescriptor GetProcessDefaultLayout$descriptor() {
        return GetProcessDefaultLayout.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetProcessDefaultLayout(DWORD *pdwDefaultLayout)
     * }
     */
    public static MethodHandle GetProcessDefaultLayout$handle() {
        return GetProcessDefaultLayout.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL GetProcessDefaultLayout(DWORD *pdwDefaultLayout)
     * }
     */
    public static int GetProcessDefaultLayout(MemorySegment pdwDefaultLayout) {
        var mh$ = GetProcessDefaultLayout.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetProcessDefaultLayout", pdwDefaultLayout);
            }
            return (int)mh$.invokeExact(pdwDefaultLayout);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetProcessDefaultLayout {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("SetProcessDefaultLayout"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetProcessDefaultLayout(DWORD dwDefaultLayout)
     * }
     */
    public static FunctionDescriptor SetProcessDefaultLayout$descriptor() {
        return SetProcessDefaultLayout.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetProcessDefaultLayout(DWORD dwDefaultLayout)
     * }
     */
    public static MethodHandle SetProcessDefaultLayout$handle() {
        return SetProcessDefaultLayout.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL SetProcessDefaultLayout(DWORD dwDefaultLayout)
     * }
     */
    public static int SetProcessDefaultLayout(int dwDefaultLayout) {
        var mh$ = SetProcessDefaultLayout.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetProcessDefaultLayout", dwDefaultLayout);
            }
            return (int)mh$.invokeExact(dwDefaultLayout);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetDesktopWindow {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER    );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetDesktopWindow"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HWND GetDesktopWindow()
     * }
     */
    public static FunctionDescriptor GetDesktopWindow$descriptor() {
        return GetDesktopWindow.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HWND GetDesktopWindow()
     * }
     */
    public static MethodHandle GetDesktopWindow$handle() {
        return GetDesktopWindow.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * HWND GetDesktopWindow()
     * }
     */
    public static MemorySegment GetDesktopWindow() {
        var mh$ = GetDesktopWindow.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetDesktopWindow");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetParent {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetParent"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HWND GetParent(HWND hWnd)
     * }
     */
    public static FunctionDescriptor GetParent$descriptor() {
        return GetParent.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HWND GetParent(HWND hWnd)
     * }
     */
    public static MethodHandle GetParent$handle() {
        return GetParent.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * HWND GetParent(HWND hWnd)
     * }
     */
    public static MemorySegment GetParent(MemorySegment hWnd) {
        var mh$ = GetParent.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetParent", hWnd);
            }
            return (MemorySegment)mh$.invokeExact(hWnd);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetParent {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("SetParent"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HWND SetParent(HWND hWndChild, HWND hWndNewParent)
     * }
     */
    public static FunctionDescriptor SetParent$descriptor() {
        return SetParent.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HWND SetParent(HWND hWndChild, HWND hWndNewParent)
     * }
     */
    public static MethodHandle SetParent$handle() {
        return SetParent.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * HWND SetParent(HWND hWndChild, HWND hWndNewParent)
     * }
     */
    public static MemorySegment SetParent(MemorySegment hWndChild, MemorySegment hWndNewParent) {
        var mh$ = SetParent.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetParent", hWndChild, hWndNewParent);
            }
            return (MemorySegment)mh$.invokeExact(hWndChild, hWndNewParent);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class EnumChildWindows {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_LONG_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("EnumChildWindows"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL EnumChildWindows(HWND hWndParent, WNDENUMPROC lpEnumFunc, LPARAM lParam)
     * }
     */
    public static FunctionDescriptor EnumChildWindows$descriptor() {
        return EnumChildWindows.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL EnumChildWindows(HWND hWndParent, WNDENUMPROC lpEnumFunc, LPARAM lParam)
     * }
     */
    public static MethodHandle EnumChildWindows$handle() {
        return EnumChildWindows.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL EnumChildWindows(HWND hWndParent, WNDENUMPROC lpEnumFunc, LPARAM lParam)
     * }
     */
    public static int EnumChildWindows(MemorySegment hWndParent, MemorySegment lpEnumFunc, long lParam) {
        var mh$ = EnumChildWindows.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("EnumChildWindows", hWndParent, lpEnumFunc, lParam);
            }
            return (int)mh$.invokeExact(hWndParent, lpEnumFunc, lParam);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FindWindowA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("FindWindowA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HWND FindWindowA(LPCSTR lpClassName, LPCSTR lpWindowName)
     * }
     */
    public static FunctionDescriptor FindWindowA$descriptor() {
        return FindWindowA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HWND FindWindowA(LPCSTR lpClassName, LPCSTR lpWindowName)
     * }
     */
    public static MethodHandle FindWindowA$handle() {
        return FindWindowA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * HWND FindWindowA(LPCSTR lpClassName, LPCSTR lpWindowName)
     * }
     */
    public static MemorySegment FindWindowA(MemorySegment lpClassName, MemorySegment lpWindowName) {
        var mh$ = FindWindowA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FindWindowA", lpClassName, lpWindowName);
            }
            return (MemorySegment)mh$.invokeExact(lpClassName, lpWindowName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FindWindowW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("FindWindowW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HWND FindWindowW(LPCWSTR lpClassName, LPCWSTR lpWindowName)
     * }
     */
    public static FunctionDescriptor FindWindowW$descriptor() {
        return FindWindowW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HWND FindWindowW(LPCWSTR lpClassName, LPCWSTR lpWindowName)
     * }
     */
    public static MethodHandle FindWindowW$handle() {
        return FindWindowW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * HWND FindWindowW(LPCWSTR lpClassName, LPCWSTR lpWindowName)
     * }
     */
    public static MemorySegment FindWindowW(MemorySegment lpClassName, MemorySegment lpWindowName) {
        var mh$ = FindWindowW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FindWindowW", lpClassName, lpWindowName);
            }
            return (MemorySegment)mh$.invokeExact(lpClassName, lpWindowName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FindWindowExA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("FindWindowExA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HWND FindWindowExA(HWND hWndParent, HWND hWndChildAfter, LPCSTR lpszClass, LPCSTR lpszWindow)
     * }
     */
    public static FunctionDescriptor FindWindowExA$descriptor() {
        return FindWindowExA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HWND FindWindowExA(HWND hWndParent, HWND hWndChildAfter, LPCSTR lpszClass, LPCSTR lpszWindow)
     * }
     */
    public static MethodHandle FindWindowExA$handle() {
        return FindWindowExA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * HWND FindWindowExA(HWND hWndParent, HWND hWndChildAfter, LPCSTR lpszClass, LPCSTR lpszWindow)
     * }
     */
    public static MemorySegment FindWindowExA(MemorySegment hWndParent, MemorySegment hWndChildAfter, MemorySegment lpszClass, MemorySegment lpszWindow) {
        var mh$ = FindWindowExA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FindWindowExA", hWndParent, hWndChildAfter, lpszClass, lpszWindow);
            }
            return (MemorySegment)mh$.invokeExact(hWndParent, hWndChildAfter, lpszClass, lpszWindow);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FindWindowExW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("FindWindowExW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HWND FindWindowExW(HWND hWndParent, HWND hWndChildAfter, LPCWSTR lpszClass, LPCWSTR lpszWindow)
     * }
     */
    public static FunctionDescriptor FindWindowExW$descriptor() {
        return FindWindowExW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HWND FindWindowExW(HWND hWndParent, HWND hWndChildAfter, LPCWSTR lpszClass, LPCWSTR lpszWindow)
     * }
     */
    public static MethodHandle FindWindowExW$handle() {
        return FindWindowExW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * HWND FindWindowExW(HWND hWndParent, HWND hWndChildAfter, LPCWSTR lpszClass, LPCWSTR lpszWindow)
     * }
     */
    public static MemorySegment FindWindowExW(MemorySegment hWndParent, MemorySegment hWndChildAfter, MemorySegment lpszClass, MemorySegment lpszWindow) {
        var mh$ = FindWindowExW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FindWindowExW", hWndParent, hWndChildAfter, lpszClass, lpszWindow);
            }
            return (MemorySegment)mh$.invokeExact(hWndParent, hWndChildAfter, lpszClass, lpszWindow);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetShellWindow {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER    );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetShellWindow"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HWND GetShellWindow()
     * }
     */
    public static FunctionDescriptor GetShellWindow$descriptor() {
        return GetShellWindow.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HWND GetShellWindow()
     * }
     */
    public static MethodHandle GetShellWindow$handle() {
        return GetShellWindow.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * HWND GetShellWindow()
     * }
     */
    public static MemorySegment GetShellWindow() {
        var mh$ = GetShellWindow.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetShellWindow");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RegisterShellHookWindow {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("RegisterShellHookWindow"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL RegisterShellHookWindow(HWND hwnd)
     * }
     */
    public static FunctionDescriptor RegisterShellHookWindow$descriptor() {
        return RegisterShellHookWindow.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL RegisterShellHookWindow(HWND hwnd)
     * }
     */
    public static MethodHandle RegisterShellHookWindow$handle() {
        return RegisterShellHookWindow.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL RegisterShellHookWindow(HWND hwnd)
     * }
     */
    public static int RegisterShellHookWindow(MemorySegment hwnd) {
        var mh$ = RegisterShellHookWindow.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RegisterShellHookWindow", hwnd);
            }
            return (int)mh$.invokeExact(hwnd);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DeregisterShellHookWindow {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("DeregisterShellHookWindow"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL DeregisterShellHookWindow(HWND hwnd)
     * }
     */
    public static FunctionDescriptor DeregisterShellHookWindow$descriptor() {
        return DeregisterShellHookWindow.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL DeregisterShellHookWindow(HWND hwnd)
     * }
     */
    public static MethodHandle DeregisterShellHookWindow$handle() {
        return DeregisterShellHookWindow.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL DeregisterShellHookWindow(HWND hwnd)
     * }
     */
    public static int DeregisterShellHookWindow(MemorySegment hwnd) {
        var mh$ = DeregisterShellHookWindow.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DeregisterShellHookWindow", hwnd);
            }
            return (int)mh$.invokeExact(hwnd);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class EnumWindows {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_LONG_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("EnumWindows"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL EnumWindows(WNDENUMPROC lpEnumFunc, LPARAM lParam)
     * }
     */
    public static FunctionDescriptor EnumWindows$descriptor() {
        return EnumWindows.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL EnumWindows(WNDENUMPROC lpEnumFunc, LPARAM lParam)
     * }
     */
    public static MethodHandle EnumWindows$handle() {
        return EnumWindows.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL EnumWindows(WNDENUMPROC lpEnumFunc, LPARAM lParam)
     * }
     */
    public static int EnumWindows(MemorySegment lpEnumFunc, long lParam) {
        var mh$ = EnumWindows.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("EnumWindows", lpEnumFunc, lParam);
            }
            return (int)mh$.invokeExact(lpEnumFunc, lParam);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class EnumThreadWindows {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_LONG,
            C_POINTER,
            C_LONG_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("EnumThreadWindows"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL EnumThreadWindows(DWORD dwThreadId, WNDENUMPROC lpfn, LPARAM lParam)
     * }
     */
    public static FunctionDescriptor EnumThreadWindows$descriptor() {
        return EnumThreadWindows.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL EnumThreadWindows(DWORD dwThreadId, WNDENUMPROC lpfn, LPARAM lParam)
     * }
     */
    public static MethodHandle EnumThreadWindows$handle() {
        return EnumThreadWindows.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL EnumThreadWindows(DWORD dwThreadId, WNDENUMPROC lpfn, LPARAM lParam)
     * }
     */
    public static int EnumThreadWindows(int dwThreadId, MemorySegment lpfn, long lParam) {
        var mh$ = EnumThreadWindows.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("EnumThreadWindows", dwThreadId, lpfn, lParam);
            }
            return (int)mh$.invokeExact(dwThreadId, lpfn, lParam);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetClassNameA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetClassNameA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int GetClassNameA(HWND hWnd, LPSTR lpClassName, int nMaxCount)
     * }
     */
    public static FunctionDescriptor GetClassNameA$descriptor() {
        return GetClassNameA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int GetClassNameA(HWND hWnd, LPSTR lpClassName, int nMaxCount)
     * }
     */
    public static MethodHandle GetClassNameA$handle() {
        return GetClassNameA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int GetClassNameA(HWND hWnd, LPSTR lpClassName, int nMaxCount)
     * }
     */
    public static int GetClassNameA(MemorySegment hWnd, MemorySegment lpClassName, int nMaxCount) {
        var mh$ = GetClassNameA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetClassNameA", hWnd, lpClassName, nMaxCount);
            }
            return (int)mh$.invokeExact(hWnd, lpClassName, nMaxCount);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetClassNameW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetClassNameW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int GetClassNameW(HWND hWnd, LPWSTR lpClassName, int nMaxCount)
     * }
     */
    public static FunctionDescriptor GetClassNameW$descriptor() {
        return GetClassNameW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int GetClassNameW(HWND hWnd, LPWSTR lpClassName, int nMaxCount)
     * }
     */
    public static MethodHandle GetClassNameW$handle() {
        return GetClassNameW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int GetClassNameW(HWND hWnd, LPWSTR lpClassName, int nMaxCount)
     * }
     */
    public static int GetClassNameW(MemorySegment hWnd, MemorySegment lpClassName, int nMaxCount) {
        var mh$ = GetClassNameW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetClassNameW", hWnd, lpClassName, nMaxCount);
            }
            return (int)mh$.invokeExact(hWnd, lpClassName, nMaxCount);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetTopWindow {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetTopWindow"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HWND GetTopWindow(HWND hWnd)
     * }
     */
    public static FunctionDescriptor GetTopWindow$descriptor() {
        return GetTopWindow.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HWND GetTopWindow(HWND hWnd)
     * }
     */
    public static MethodHandle GetTopWindow$handle() {
        return GetTopWindow.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * HWND GetTopWindow(HWND hWnd)
     * }
     */
    public static MemorySegment GetTopWindow(MemorySegment hWnd) {
        var mh$ = GetTopWindow.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetTopWindow", hWnd);
            }
            return (MemorySegment)mh$.invokeExact(hWnd);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetWindowThreadProcessId {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetWindowThreadProcessId"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetWindowThreadProcessId(HWND hWnd, LPDWORD lpdwProcessId)
     * }
     */
    public static FunctionDescriptor GetWindowThreadProcessId$descriptor() {
        return GetWindowThreadProcessId.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetWindowThreadProcessId(HWND hWnd, LPDWORD lpdwProcessId)
     * }
     */
    public static MethodHandle GetWindowThreadProcessId$handle() {
        return GetWindowThreadProcessId.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * DWORD GetWindowThreadProcessId(HWND hWnd, LPDWORD lpdwProcessId)
     * }
     */
    public static int GetWindowThreadProcessId(MemorySegment hWnd, MemorySegment lpdwProcessId) {
        var mh$ = GetWindowThreadProcessId.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetWindowThreadProcessId", hWnd, lpdwProcessId);
            }
            return (int)mh$.invokeExact(hWnd, lpdwProcessId);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class IsGUIThread {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("IsGUIThread"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL IsGUIThread(BOOL bConvert)
     * }
     */
    public static FunctionDescriptor IsGUIThread$descriptor() {
        return IsGUIThread.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL IsGUIThread(BOOL bConvert)
     * }
     */
    public static MethodHandle IsGUIThread$handle() {
        return IsGUIThread.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL IsGUIThread(BOOL bConvert)
     * }
     */
    public static int IsGUIThread(int bConvert) {
        var mh$ = IsGUIThread.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("IsGUIThread", bConvert);
            }
            return (int)mh$.invokeExact(bConvert);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetLastActivePopup {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetLastActivePopup"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HWND GetLastActivePopup(HWND hWnd)
     * }
     */
    public static FunctionDescriptor GetLastActivePopup$descriptor() {
        return GetLastActivePopup.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HWND GetLastActivePopup(HWND hWnd)
     * }
     */
    public static MethodHandle GetLastActivePopup$handle() {
        return GetLastActivePopup.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * HWND GetLastActivePopup(HWND hWnd)
     * }
     */
    public static MemorySegment GetLastActivePopup(MemorySegment hWnd) {
        var mh$ = GetLastActivePopup.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetLastActivePopup", hWnd);
            }
            return (MemorySegment)mh$.invokeExact(hWnd);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetWindow {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetWindow"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HWND GetWindow(HWND hWnd, UINT uCmd)
     * }
     */
    public static FunctionDescriptor GetWindow$descriptor() {
        return GetWindow.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HWND GetWindow(HWND hWnd, UINT uCmd)
     * }
     */
    public static MethodHandle GetWindow$handle() {
        return GetWindow.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * HWND GetWindow(HWND hWnd, UINT uCmd)
     * }
     */
    public static MemorySegment GetWindow(MemorySegment hWnd, int uCmd) {
        var mh$ = GetWindow.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetWindow", hWnd, uCmd);
            }
            return (MemorySegment)mh$.invokeExact(hWnd, uCmd);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetWindowsHookA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("SetWindowsHookA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HHOOK SetWindowsHookA(int nFilterType, HOOKPROC pfnFilterProc)
     * }
     */
    public static FunctionDescriptor SetWindowsHookA$descriptor() {
        return SetWindowsHookA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HHOOK SetWindowsHookA(int nFilterType, HOOKPROC pfnFilterProc)
     * }
     */
    public static MethodHandle SetWindowsHookA$handle() {
        return SetWindowsHookA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * HHOOK SetWindowsHookA(int nFilterType, HOOKPROC pfnFilterProc)
     * }
     */
    public static MemorySegment SetWindowsHookA(int nFilterType, MemorySegment pfnFilterProc) {
        var mh$ = SetWindowsHookA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetWindowsHookA", nFilterType, pfnFilterProc);
            }
            return (MemorySegment)mh$.invokeExact(nFilterType, pfnFilterProc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetWindowsHookW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("SetWindowsHookW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HHOOK SetWindowsHookW(int nFilterType, HOOKPROC pfnFilterProc)
     * }
     */
    public static FunctionDescriptor SetWindowsHookW$descriptor() {
        return SetWindowsHookW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HHOOK SetWindowsHookW(int nFilterType, HOOKPROC pfnFilterProc)
     * }
     */
    public static MethodHandle SetWindowsHookW$handle() {
        return SetWindowsHookW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * HHOOK SetWindowsHookW(int nFilterType, HOOKPROC pfnFilterProc)
     * }
     */
    public static MemorySegment SetWindowsHookW(int nFilterType, MemorySegment pfnFilterProc) {
        var mh$ = SetWindowsHookW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetWindowsHookW", nFilterType, pfnFilterProc);
            }
            return (MemorySegment)mh$.invokeExact(nFilterType, pfnFilterProc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class UnhookWindowsHook {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("UnhookWindowsHook"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL UnhookWindowsHook(int nCode, HOOKPROC pfnFilterProc)
     * }
     */
    public static FunctionDescriptor UnhookWindowsHook$descriptor() {
        return UnhookWindowsHook.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL UnhookWindowsHook(int nCode, HOOKPROC pfnFilterProc)
     * }
     */
    public static MethodHandle UnhookWindowsHook$handle() {
        return UnhookWindowsHook.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL UnhookWindowsHook(int nCode, HOOKPROC pfnFilterProc)
     * }
     */
    public static int UnhookWindowsHook(int nCode, MemorySegment pfnFilterProc) {
        var mh$ = UnhookWindowsHook.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("UnhookWindowsHook", nCode, pfnFilterProc);
            }
            return (int)mh$.invokeExact(nCode, pfnFilterProc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetWindowsHookExA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_INT,
            C_POINTER,
            C_POINTER,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("SetWindowsHookExA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HHOOK SetWindowsHookExA(int idHook, HOOKPROC lpfn, HINSTANCE hmod, DWORD dwThreadId)
     * }
     */
    public static FunctionDescriptor SetWindowsHookExA$descriptor() {
        return SetWindowsHookExA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HHOOK SetWindowsHookExA(int idHook, HOOKPROC lpfn, HINSTANCE hmod, DWORD dwThreadId)
     * }
     */
    public static MethodHandle SetWindowsHookExA$handle() {
        return SetWindowsHookExA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * HHOOK SetWindowsHookExA(int idHook, HOOKPROC lpfn, HINSTANCE hmod, DWORD dwThreadId)
     * }
     */
    public static MemorySegment SetWindowsHookExA(int idHook, MemorySegment lpfn, MemorySegment hmod, int dwThreadId) {
        var mh$ = SetWindowsHookExA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetWindowsHookExA", idHook, lpfn, hmod, dwThreadId);
            }
            return (MemorySegment)mh$.invokeExact(idHook, lpfn, hmod, dwThreadId);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetWindowsHookExW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_INT,
            C_POINTER,
            C_POINTER,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("SetWindowsHookExW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HHOOK SetWindowsHookExW(int idHook, HOOKPROC lpfn, HINSTANCE hmod, DWORD dwThreadId)
     * }
     */
    public static FunctionDescriptor SetWindowsHookExW$descriptor() {
        return SetWindowsHookExW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HHOOK SetWindowsHookExW(int idHook, HOOKPROC lpfn, HINSTANCE hmod, DWORD dwThreadId)
     * }
     */
    public static MethodHandle SetWindowsHookExW$handle() {
        return SetWindowsHookExW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * HHOOK SetWindowsHookExW(int idHook, HOOKPROC lpfn, HINSTANCE hmod, DWORD dwThreadId)
     * }
     */
    public static MemorySegment SetWindowsHookExW(int idHook, MemorySegment lpfn, MemorySegment hmod, int dwThreadId) {
        var mh$ = SetWindowsHookExW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetWindowsHookExW", idHook, lpfn, hmod, dwThreadId);
            }
            return (MemorySegment)mh$.invokeExact(idHook, lpfn, hmod, dwThreadId);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class UnhookWindowsHookEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("UnhookWindowsHookEx"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL UnhookWindowsHookEx(HHOOK hhk)
     * }
     */
    public static FunctionDescriptor UnhookWindowsHookEx$descriptor() {
        return UnhookWindowsHookEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL UnhookWindowsHookEx(HHOOK hhk)
     * }
     */
    public static MethodHandle UnhookWindowsHookEx$handle() {
        return UnhookWindowsHookEx.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL UnhookWindowsHookEx(HHOOK hhk)
     * }
     */
    public static int UnhookWindowsHookEx(MemorySegment hhk) {
        var mh$ = UnhookWindowsHookEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("UnhookWindowsHookEx", hhk);
            }
            return (int)mh$.invokeExact(hhk);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CallNextHookEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG_LONG,
            C_POINTER,
            C_INT,
            C_LONG_LONG,
            C_LONG_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CallNextHookEx"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LRESULT CallNextHookEx(HHOOK hhk, int nCode, WPARAM wParam, LPARAM lParam)
     * }
     */
    public static FunctionDescriptor CallNextHookEx$descriptor() {
        return CallNextHookEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LRESULT CallNextHookEx(HHOOK hhk, int nCode, WPARAM wParam, LPARAM lParam)
     * }
     */
    public static MethodHandle CallNextHookEx$handle() {
        return CallNextHookEx.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * LRESULT CallNextHookEx(HHOOK hhk, int nCode, WPARAM wParam, LPARAM lParam)
     * }
     */
    public static long CallNextHookEx(MemorySegment hhk, int nCode, long wParam, long lParam) {
        var mh$ = CallNextHookEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CallNextHookEx", hhk, nCode, wParam, lParam);
            }
            return (long)mh$.invokeExact(hhk, nCode, wParam, lParam);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CheckMenuRadioItem {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_INT,
            C_INT,
            C_INT,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CheckMenuRadioItem"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CheckMenuRadioItem(HMENU hmenu, UINT first, UINT last, UINT check, UINT flags)
     * }
     */
    public static FunctionDescriptor CheckMenuRadioItem$descriptor() {
        return CheckMenuRadioItem.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CheckMenuRadioItem(HMENU hmenu, UINT first, UINT last, UINT check, UINT flags)
     * }
     */
    public static MethodHandle CheckMenuRadioItem$handle() {
        return CheckMenuRadioItem.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL CheckMenuRadioItem(HMENU hmenu, UINT first, UINT last, UINT check, UINT flags)
     * }
     */
    public static int CheckMenuRadioItem(MemorySegment hmenu, int first, int last, int check, int flags) {
        var mh$ = CheckMenuRadioItem.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CheckMenuRadioItem", hmenu, first, last, check, flags);
            }
            return (int)mh$.invokeExact(hmenu, first, last, check, flags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct {
     *     WORD versionNumber;
     *     WORD offset;
     * } *PMENUITEMTEMPLATEHEADER
     * }
     */
    public static final AddressLayout PMENUITEMTEMPLATEHEADER = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct {
     *     WORD mtOption;
     *     WORD mtID;
     *     WCHAR mtString[1];
     * } *PMENUITEMTEMPLATE
     * }
     */
    public static final AddressLayout PMENUITEMTEMPLATE = C_POINTER;

    private static class LoadBitmapA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("LoadBitmapA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HBITMAP LoadBitmapA(HINSTANCE hInstance, LPCSTR lpBitmapName)
     * }
     */
    public static FunctionDescriptor LoadBitmapA$descriptor() {
        return LoadBitmapA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HBITMAP LoadBitmapA(HINSTANCE hInstance, LPCSTR lpBitmapName)
     * }
     */
    public static MethodHandle LoadBitmapA$handle() {
        return LoadBitmapA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * HBITMAP LoadBitmapA(HINSTANCE hInstance, LPCSTR lpBitmapName)
     * }
     */
    public static MemorySegment LoadBitmapA(MemorySegment hInstance, MemorySegment lpBitmapName) {
        var mh$ = LoadBitmapA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LoadBitmapA", hInstance, lpBitmapName);
            }
            return (MemorySegment)mh$.invokeExact(hInstance, lpBitmapName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LoadBitmapW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("LoadBitmapW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HBITMAP LoadBitmapW(HINSTANCE hInstance, LPCWSTR lpBitmapName)
     * }
     */
    public static FunctionDescriptor LoadBitmapW$descriptor() {
        return LoadBitmapW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HBITMAP LoadBitmapW(HINSTANCE hInstance, LPCWSTR lpBitmapName)
     * }
     */
    public static MethodHandle LoadBitmapW$handle() {
        return LoadBitmapW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * HBITMAP LoadBitmapW(HINSTANCE hInstance, LPCWSTR lpBitmapName)
     * }
     */
    public static MemorySegment LoadBitmapW(MemorySegment hInstance, MemorySegment lpBitmapName) {
        var mh$ = LoadBitmapW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LoadBitmapW", hInstance, lpBitmapName);
            }
            return (MemorySegment)mh$.invokeExact(hInstance, lpBitmapName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LoadCursorA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("LoadCursorA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HCURSOR LoadCursorA(HINSTANCE hInstance, LPCSTR lpCursorName)
     * }
     */
    public static FunctionDescriptor LoadCursorA$descriptor() {
        return LoadCursorA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HCURSOR LoadCursorA(HINSTANCE hInstance, LPCSTR lpCursorName)
     * }
     */
    public static MethodHandle LoadCursorA$handle() {
        return LoadCursorA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * HCURSOR LoadCursorA(HINSTANCE hInstance, LPCSTR lpCursorName)
     * }
     */
    public static MemorySegment LoadCursorA(MemorySegment hInstance, MemorySegment lpCursorName) {
        var mh$ = LoadCursorA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LoadCursorA", hInstance, lpCursorName);
            }
            return (MemorySegment)mh$.invokeExact(hInstance, lpCursorName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LoadCursorW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("LoadCursorW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HCURSOR LoadCursorW(HINSTANCE hInstance, LPCWSTR lpCursorName)
     * }
     */
    public static FunctionDescriptor LoadCursorW$descriptor() {
        return LoadCursorW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HCURSOR LoadCursorW(HINSTANCE hInstance, LPCWSTR lpCursorName)
     * }
     */
    public static MethodHandle LoadCursorW$handle() {
        return LoadCursorW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * HCURSOR LoadCursorW(HINSTANCE hInstance, LPCWSTR lpCursorName)
     * }
     */
    public static MemorySegment LoadCursorW(MemorySegment hInstance, MemorySegment lpCursorName) {
        var mh$ = LoadCursorW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LoadCursorW", hInstance, lpCursorName);
            }
            return (MemorySegment)mh$.invokeExact(hInstance, lpCursorName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LoadCursorFromFileA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("LoadCursorFromFileA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HCURSOR LoadCursorFromFileA(LPCSTR lpFileName)
     * }
     */
    public static FunctionDescriptor LoadCursorFromFileA$descriptor() {
        return LoadCursorFromFileA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HCURSOR LoadCursorFromFileA(LPCSTR lpFileName)
     * }
     */
    public static MethodHandle LoadCursorFromFileA$handle() {
        return LoadCursorFromFileA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * HCURSOR LoadCursorFromFileA(LPCSTR lpFileName)
     * }
     */
    public static MemorySegment LoadCursorFromFileA(MemorySegment lpFileName) {
        var mh$ = LoadCursorFromFileA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LoadCursorFromFileA", lpFileName);
            }
            return (MemorySegment)mh$.invokeExact(lpFileName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LoadCursorFromFileW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("LoadCursorFromFileW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HCURSOR LoadCursorFromFileW(LPCWSTR lpFileName)
     * }
     */
    public static FunctionDescriptor LoadCursorFromFileW$descriptor() {
        return LoadCursorFromFileW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HCURSOR LoadCursorFromFileW(LPCWSTR lpFileName)
     * }
     */
    public static MethodHandle LoadCursorFromFileW$handle() {
        return LoadCursorFromFileW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * HCURSOR LoadCursorFromFileW(LPCWSTR lpFileName)
     * }
     */
    public static MemorySegment LoadCursorFromFileW(MemorySegment lpFileName) {
        var mh$ = LoadCursorFromFileW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LoadCursorFromFileW", lpFileName);
            }
            return (MemorySegment)mh$.invokeExact(lpFileName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateCursor {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER,
            C_INT,
            C_INT,
            C_INT,
            C_INT,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CreateCursor"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HCURSOR CreateCursor(HINSTANCE hInst, int xHotSpot, int yHotSpot, int nWidth, int nHeight, const void *pvANDPlane, const void *pvXORPlane)
     * }
     */
    public static FunctionDescriptor CreateCursor$descriptor() {
        return CreateCursor.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HCURSOR CreateCursor(HINSTANCE hInst, int xHotSpot, int yHotSpot, int nWidth, int nHeight, const void *pvANDPlane, const void *pvXORPlane)
     * }
     */
    public static MethodHandle CreateCursor$handle() {
        return CreateCursor.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * HCURSOR CreateCursor(HINSTANCE hInst, int xHotSpot, int yHotSpot, int nWidth, int nHeight, const void *pvANDPlane, const void *pvXORPlane)
     * }
     */
    public static MemorySegment CreateCursor(MemorySegment hInst, int xHotSpot, int yHotSpot, int nWidth, int nHeight, MemorySegment pvANDPlane, MemorySegment pvXORPlane) {
        var mh$ = CreateCursor.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateCursor", hInst, xHotSpot, yHotSpot, nWidth, nHeight, pvANDPlane, pvXORPlane);
            }
            return (MemorySegment)mh$.invokeExact(hInst, xHotSpot, yHotSpot, nWidth, nHeight, pvANDPlane, pvXORPlane);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DestroyCursor {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("DestroyCursor"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL DestroyCursor(HCURSOR hCursor)
     * }
     */
    public static FunctionDescriptor DestroyCursor$descriptor() {
        return DestroyCursor.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL DestroyCursor(HCURSOR hCursor)
     * }
     */
    public static MethodHandle DestroyCursor$handle() {
        return DestroyCursor.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL DestroyCursor(HCURSOR hCursor)
     * }
     */
    public static int DestroyCursor(MemorySegment hCursor) {
        var mh$ = DestroyCursor.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DestroyCursor", hCursor);
            }
            return (int)mh$.invokeExact(hCursor);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetSystemCursor {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("SetSystemCursor"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetSystemCursor(HCURSOR hcur, DWORD id)
     * }
     */
    public static FunctionDescriptor SetSystemCursor$descriptor() {
        return SetSystemCursor.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetSystemCursor(HCURSOR hcur, DWORD id)
     * }
     */
    public static MethodHandle SetSystemCursor$handle() {
        return SetSystemCursor.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL SetSystemCursor(HCURSOR hcur, DWORD id)
     * }
     */
    public static int SetSystemCursor(MemorySegment hcur, int id) {
        var mh$ = SetSystemCursor.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetSystemCursor", hcur, id);
            }
            return (int)mh$.invokeExact(hcur, id);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef ICONINFO *PICONINFO
     * }
     */
    public static final AddressLayout PICONINFO = C_POINTER;

    private static class LoadIconA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("LoadIconA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HICON LoadIconA(HINSTANCE hInstance, LPCSTR lpIconName)
     * }
     */
    public static FunctionDescriptor LoadIconA$descriptor() {
        return LoadIconA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HICON LoadIconA(HINSTANCE hInstance, LPCSTR lpIconName)
     * }
     */
    public static MethodHandle LoadIconA$handle() {
        return LoadIconA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * HICON LoadIconA(HINSTANCE hInstance, LPCSTR lpIconName)
     * }
     */
    public static MemorySegment LoadIconA(MemorySegment hInstance, MemorySegment lpIconName) {
        var mh$ = LoadIconA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LoadIconA", hInstance, lpIconName);
            }
            return (MemorySegment)mh$.invokeExact(hInstance, lpIconName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LoadIconW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("LoadIconW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HICON LoadIconW(HINSTANCE hInstance, LPCWSTR lpIconName)
     * }
     */
    public static FunctionDescriptor LoadIconW$descriptor() {
        return LoadIconW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HICON LoadIconW(HINSTANCE hInstance, LPCWSTR lpIconName)
     * }
     */
    public static MethodHandle LoadIconW$handle() {
        return LoadIconW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * HICON LoadIconW(HINSTANCE hInstance, LPCWSTR lpIconName)
     * }
     */
    public static MemorySegment LoadIconW(MemorySegment hInstance, MemorySegment lpIconName) {
        var mh$ = LoadIconW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LoadIconW", hInstance, lpIconName);
            }
            return (MemorySegment)mh$.invokeExact(hInstance, lpIconName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PrivateExtractIconsA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_INT,
            C_INT,
            C_INT,
            C_POINTER,
            C_POINTER,
            C_INT,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("PrivateExtractIconsA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * UINT PrivateExtractIconsA(LPCSTR szFileName, int nIconIndex, int cxIcon, int cyIcon, HICON *phicon, UINT *piconid, UINT nIcons, UINT flags)
     * }
     */
    public static FunctionDescriptor PrivateExtractIconsA$descriptor() {
        return PrivateExtractIconsA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * UINT PrivateExtractIconsA(LPCSTR szFileName, int nIconIndex, int cxIcon, int cyIcon, HICON *phicon, UINT *piconid, UINT nIcons, UINT flags)
     * }
     */
    public static MethodHandle PrivateExtractIconsA$handle() {
        return PrivateExtractIconsA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * UINT PrivateExtractIconsA(LPCSTR szFileName, int nIconIndex, int cxIcon, int cyIcon, HICON *phicon, UINT *piconid, UINT nIcons, UINT flags)
     * }
     */
    public static int PrivateExtractIconsA(MemorySegment szFileName, int nIconIndex, int cxIcon, int cyIcon, MemorySegment phicon, MemorySegment piconid, int nIcons, int flags) {
        var mh$ = PrivateExtractIconsA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PrivateExtractIconsA", szFileName, nIconIndex, cxIcon, cyIcon, phicon, piconid, nIcons, flags);
            }
            return (int)mh$.invokeExact(szFileName, nIconIndex, cxIcon, cyIcon, phicon, piconid, nIcons, flags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PrivateExtractIconsW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_INT,
            C_INT,
            C_INT,
            C_POINTER,
            C_POINTER,
            C_INT,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("PrivateExtractIconsW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * UINT PrivateExtractIconsW(LPCWSTR szFileName, int nIconIndex, int cxIcon, int cyIcon, HICON *phicon, UINT *piconid, UINT nIcons, UINT flags)
     * }
     */
    public static FunctionDescriptor PrivateExtractIconsW$descriptor() {
        return PrivateExtractIconsW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * UINT PrivateExtractIconsW(LPCWSTR szFileName, int nIconIndex, int cxIcon, int cyIcon, HICON *phicon, UINT *piconid, UINT nIcons, UINT flags)
     * }
     */
    public static MethodHandle PrivateExtractIconsW$handle() {
        return PrivateExtractIconsW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * UINT PrivateExtractIconsW(LPCWSTR szFileName, int nIconIndex, int cxIcon, int cyIcon, HICON *phicon, UINT *piconid, UINT nIcons, UINT flags)
     * }
     */
    public static int PrivateExtractIconsW(MemorySegment szFileName, int nIconIndex, int cxIcon, int cyIcon, MemorySegment phicon, MemorySegment piconid, int nIcons, int flags) {
        var mh$ = PrivateExtractIconsW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PrivateExtractIconsW", szFileName, nIconIndex, cxIcon, cyIcon, phicon, piconid, nIcons, flags);
            }
            return (int)mh$.invokeExact(szFileName, nIconIndex, cxIcon, cyIcon, phicon, piconid, nIcons, flags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateIcon {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER,
            C_INT,
            C_INT,
            C_CHAR,
            C_CHAR,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CreateIcon"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HICON CreateIcon(HINSTANCE hInstance, int nWidth, int nHeight, BYTE cPlanes, BYTE cBitsPixel, const BYTE *lpbANDbits, const BYTE *lpbXORbits)
     * }
     */
    public static FunctionDescriptor CreateIcon$descriptor() {
        return CreateIcon.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HICON CreateIcon(HINSTANCE hInstance, int nWidth, int nHeight, BYTE cPlanes, BYTE cBitsPixel, const BYTE *lpbANDbits, const BYTE *lpbXORbits)
     * }
     */
    public static MethodHandle CreateIcon$handle() {
        return CreateIcon.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * HICON CreateIcon(HINSTANCE hInstance, int nWidth, int nHeight, BYTE cPlanes, BYTE cBitsPixel, const BYTE *lpbANDbits, const BYTE *lpbXORbits)
     * }
     */
    public static MemorySegment CreateIcon(MemorySegment hInstance, int nWidth, int nHeight, byte cPlanes, byte cBitsPixel, MemorySegment lpbANDbits, MemorySegment lpbXORbits) {
        var mh$ = CreateIcon.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateIcon", hInstance, nWidth, nHeight, cPlanes, cBitsPixel, lpbANDbits, lpbXORbits);
            }
            return (MemorySegment)mh$.invokeExact(hInstance, nWidth, nHeight, cPlanes, cBitsPixel, lpbANDbits, lpbXORbits);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DestroyIcon {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("DestroyIcon"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL DestroyIcon(HICON hIcon)
     * }
     */
    public static FunctionDescriptor DestroyIcon$descriptor() {
        return DestroyIcon.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL DestroyIcon(HICON hIcon)
     * }
     */
    public static MethodHandle DestroyIcon$handle() {
        return DestroyIcon.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL DestroyIcon(HICON hIcon)
     * }
     */
    public static int DestroyIcon(MemorySegment hIcon) {
        var mh$ = DestroyIcon.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DestroyIcon", hIcon);
            }
            return (int)mh$.invokeExact(hIcon);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LookupIconIdFromDirectory {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("LookupIconIdFromDirectory"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LookupIconIdFromDirectory(PBYTE presbits, BOOL fIcon)
     * }
     */
    public static FunctionDescriptor LookupIconIdFromDirectory$descriptor() {
        return LookupIconIdFromDirectory.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LookupIconIdFromDirectory(PBYTE presbits, BOOL fIcon)
     * }
     */
    public static MethodHandle LookupIconIdFromDirectory$handle() {
        return LookupIconIdFromDirectory.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int LookupIconIdFromDirectory(PBYTE presbits, BOOL fIcon)
     * }
     */
    public static int LookupIconIdFromDirectory(MemorySegment presbits, int fIcon) {
        var mh$ = LookupIconIdFromDirectory.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LookupIconIdFromDirectory", presbits, fIcon);
            }
            return (int)mh$.invokeExact(presbits, fIcon);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LookupIconIdFromDirectoryEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_INT,
            C_INT,
            C_INT,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("LookupIconIdFromDirectoryEx"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LookupIconIdFromDirectoryEx(PBYTE presbits, BOOL fIcon, int cxDesired, int cyDesired, UINT Flags)
     * }
     */
    public static FunctionDescriptor LookupIconIdFromDirectoryEx$descriptor() {
        return LookupIconIdFromDirectoryEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LookupIconIdFromDirectoryEx(PBYTE presbits, BOOL fIcon, int cxDesired, int cyDesired, UINT Flags)
     * }
     */
    public static MethodHandle LookupIconIdFromDirectoryEx$handle() {
        return LookupIconIdFromDirectoryEx.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int LookupIconIdFromDirectoryEx(PBYTE presbits, BOOL fIcon, int cxDesired, int cyDesired, UINT Flags)
     * }
     */
    public static int LookupIconIdFromDirectoryEx(MemorySegment presbits, int fIcon, int cxDesired, int cyDesired, int Flags) {
        var mh$ = LookupIconIdFromDirectoryEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LookupIconIdFromDirectoryEx", presbits, fIcon, cxDesired, cyDesired, Flags);
            }
            return (int)mh$.invokeExact(presbits, fIcon, cxDesired, cyDesired, Flags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateIconFromResource {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER,
            C_LONG,
            C_INT,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CreateIconFromResource"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HICON CreateIconFromResource(PBYTE presbits, DWORD dwResSize, BOOL fIcon, DWORD dwVer)
     * }
     */
    public static FunctionDescriptor CreateIconFromResource$descriptor() {
        return CreateIconFromResource.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HICON CreateIconFromResource(PBYTE presbits, DWORD dwResSize, BOOL fIcon, DWORD dwVer)
     * }
     */
    public static MethodHandle CreateIconFromResource$handle() {
        return CreateIconFromResource.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * HICON CreateIconFromResource(PBYTE presbits, DWORD dwResSize, BOOL fIcon, DWORD dwVer)
     * }
     */
    public static MemorySegment CreateIconFromResource(MemorySegment presbits, int dwResSize, int fIcon, int dwVer) {
        var mh$ = CreateIconFromResource.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateIconFromResource", presbits, dwResSize, fIcon, dwVer);
            }
            return (MemorySegment)mh$.invokeExact(presbits, dwResSize, fIcon, dwVer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateIconFromResourceEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER,
            C_LONG,
            C_INT,
            C_LONG,
            C_INT,
            C_INT,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CreateIconFromResourceEx"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HICON CreateIconFromResourceEx(PBYTE presbits, DWORD dwResSize, BOOL fIcon, DWORD dwVer, int cxDesired, int cyDesired, UINT Flags)
     * }
     */
    public static FunctionDescriptor CreateIconFromResourceEx$descriptor() {
        return CreateIconFromResourceEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HICON CreateIconFromResourceEx(PBYTE presbits, DWORD dwResSize, BOOL fIcon, DWORD dwVer, int cxDesired, int cyDesired, UINT Flags)
     * }
     */
    public static MethodHandle CreateIconFromResourceEx$handle() {
        return CreateIconFromResourceEx.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * HICON CreateIconFromResourceEx(PBYTE presbits, DWORD dwResSize, BOOL fIcon, DWORD dwVer, int cxDesired, int cyDesired, UINT Flags)
     * }
     */
    public static MemorySegment CreateIconFromResourceEx(MemorySegment presbits, int dwResSize, int fIcon, int dwVer, int cxDesired, int cyDesired, int Flags) {
        var mh$ = CreateIconFromResourceEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateIconFromResourceEx", presbits, dwResSize, fIcon, dwVer, cxDesired, cyDesired, Flags);
            }
            return (MemorySegment)mh$.invokeExact(presbits, dwResSize, fIcon, dwVer, cxDesired, cyDesired, Flags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct tagCURSORSHAPE {
     *     int xHotSpot;
     *     int yHotSpot;
     *     int cx;
     *     int cy;
     *     int cbWidth;
     *     BYTE Planes;
     *     BYTE BitsPixel;
     * } *LPCURSORSHAPE
     * }
     */
    public static final AddressLayout LPCURSORSHAPE = C_POINTER;

    private static class SetThreadCursorCreationScaling {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("SetThreadCursorCreationScaling"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * UINT SetThreadCursorCreationScaling(UINT cursorDpi)
     * }
     */
    public static FunctionDescriptor SetThreadCursorCreationScaling$descriptor() {
        return SetThreadCursorCreationScaling.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * UINT SetThreadCursorCreationScaling(UINT cursorDpi)
     * }
     */
    public static MethodHandle SetThreadCursorCreationScaling$handle() {
        return SetThreadCursorCreationScaling.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * UINT SetThreadCursorCreationScaling(UINT cursorDpi)
     * }
     */
    public static int SetThreadCursorCreationScaling(int cursorDpi) {
        var mh$ = SetThreadCursorCreationScaling.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetThreadCursorCreationScaling", cursorDpi);
            }
            return (int)mh$.invokeExact(cursorDpi);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LoadImageA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_INT,
            C_INT,
            C_INT,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("LoadImageA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HANDLE LoadImageA(HINSTANCE hInst, LPCSTR name, UINT type, int cx, int cy, UINT fuLoad)
     * }
     */
    public static FunctionDescriptor LoadImageA$descriptor() {
        return LoadImageA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HANDLE LoadImageA(HINSTANCE hInst, LPCSTR name, UINT type, int cx, int cy, UINT fuLoad)
     * }
     */
    public static MethodHandle LoadImageA$handle() {
        return LoadImageA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * HANDLE LoadImageA(HINSTANCE hInst, LPCSTR name, UINT type, int cx, int cy, UINT fuLoad)
     * }
     */
    public static MemorySegment LoadImageA(MemorySegment hInst, MemorySegment name, int type, int cx, int cy, int fuLoad) {
        var mh$ = LoadImageA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LoadImageA", hInst, name, type, cx, cy, fuLoad);
            }
            return (MemorySegment)mh$.invokeExact(hInst, name, type, cx, cy, fuLoad);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LoadImageW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_INT,
            C_INT,
            C_INT,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("LoadImageW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HANDLE LoadImageW(HINSTANCE hInst, LPCWSTR name, UINT type, int cx, int cy, UINT fuLoad)
     * }
     */
    public static FunctionDescriptor LoadImageW$descriptor() {
        return LoadImageW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HANDLE LoadImageW(HINSTANCE hInst, LPCWSTR name, UINT type, int cx, int cy, UINT fuLoad)
     * }
     */
    public static MethodHandle LoadImageW$handle() {
        return LoadImageW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * HANDLE LoadImageW(HINSTANCE hInst, LPCWSTR name, UINT type, int cx, int cy, UINT fuLoad)
     * }
     */
    public static MemorySegment LoadImageW(MemorySegment hInst, MemorySegment name, int type, int cx, int cy, int fuLoad) {
        var mh$ = LoadImageW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LoadImageW", hInst, name, type, cx, cy, fuLoad);
            }
            return (MemorySegment)mh$.invokeExact(hInst, name, type, cx, cy, fuLoad);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CopyImage {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER,
            C_INT,
            C_INT,
            C_INT,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CopyImage"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HANDLE CopyImage(HANDLE h, UINT type, int cx, int cy, UINT flags)
     * }
     */
    public static FunctionDescriptor CopyImage$descriptor() {
        return CopyImage.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HANDLE CopyImage(HANDLE h, UINT type, int cx, int cy, UINT flags)
     * }
     */
    public static MethodHandle CopyImage$handle() {
        return CopyImage.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * HANDLE CopyImage(HANDLE h, UINT type, int cx, int cy, UINT flags)
     * }
     */
    public static MemorySegment CopyImage(MemorySegment h, int type, int cx, int cy, int flags) {
        var mh$ = CopyImage.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CopyImage", h, type, cx, cy, flags);
            }
            return (MemorySegment)mh$.invokeExact(h, type, cx, cy, flags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DrawIconEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_INT,
            C_INT,
            C_POINTER,
            C_INT,
            C_INT,
            C_INT,
            C_POINTER,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("DrawIconEx"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL DrawIconEx(HDC hdc, int xLeft, int yTop, HICON hIcon, int cxWidth, int cyWidth, UINT istepIfAniCur, HBRUSH hbrFlickerFreeDraw, UINT diFlags)
     * }
     */
    public static FunctionDescriptor DrawIconEx$descriptor() {
        return DrawIconEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL DrawIconEx(HDC hdc, int xLeft, int yTop, HICON hIcon, int cxWidth, int cyWidth, UINT istepIfAniCur, HBRUSH hbrFlickerFreeDraw, UINT diFlags)
     * }
     */
    public static MethodHandle DrawIconEx$handle() {
        return DrawIconEx.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL DrawIconEx(HDC hdc, int xLeft, int yTop, HICON hIcon, int cxWidth, int cyWidth, UINT istepIfAniCur, HBRUSH hbrFlickerFreeDraw, UINT diFlags)
     * }
     */
    public static int DrawIconEx(MemorySegment hdc, int xLeft, int yTop, MemorySegment hIcon, int cxWidth, int cyWidth, int istepIfAniCur, MemorySegment hbrFlickerFreeDraw, int diFlags) {
        var mh$ = DrawIconEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DrawIconEx", hdc, xLeft, yTop, hIcon, cxWidth, cyWidth, istepIfAniCur, hbrFlickerFreeDraw, diFlags);
            }
            return (int)mh$.invokeExact(hdc, xLeft, yTop, hIcon, cxWidth, cyWidth, istepIfAniCur, hbrFlickerFreeDraw, diFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateIconIndirect {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CreateIconIndirect"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HICON CreateIconIndirect(PICONINFO piconinfo)
     * }
     */
    public static FunctionDescriptor CreateIconIndirect$descriptor() {
        return CreateIconIndirect.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HICON CreateIconIndirect(PICONINFO piconinfo)
     * }
     */
    public static MethodHandle CreateIconIndirect$handle() {
        return CreateIconIndirect.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * HICON CreateIconIndirect(PICONINFO piconinfo)
     * }
     */
    public static MemorySegment CreateIconIndirect(MemorySegment piconinfo) {
        var mh$ = CreateIconIndirect.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateIconIndirect", piconinfo);
            }
            return (MemorySegment)mh$.invokeExact(piconinfo);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CopyIcon {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CopyIcon"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HICON CopyIcon(HICON hIcon)
     * }
     */
    public static FunctionDescriptor CopyIcon$descriptor() {
        return CopyIcon.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HICON CopyIcon(HICON hIcon)
     * }
     */
    public static MethodHandle CopyIcon$handle() {
        return CopyIcon.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * HICON CopyIcon(HICON hIcon)
     * }
     */
    public static MemorySegment CopyIcon(MemorySegment hIcon) {
        var mh$ = CopyIcon.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CopyIcon", hIcon);
            }
            return (MemorySegment)mh$.invokeExact(hIcon);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetIconInfo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetIconInfo"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetIconInfo(HICON hIcon, PICONINFO piconinfo)
     * }
     */
    public static FunctionDescriptor GetIconInfo$descriptor() {
        return GetIconInfo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetIconInfo(HICON hIcon, PICONINFO piconinfo)
     * }
     */
    public static MethodHandle GetIconInfo$handle() {
        return GetIconInfo.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL GetIconInfo(HICON hIcon, PICONINFO piconinfo)
     * }
     */
    public static int GetIconInfo(MemorySegment hIcon, MemorySegment piconinfo) {
        var mh$ = GetIconInfo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetIconInfo", hIcon, piconinfo);
            }
            return (int)mh$.invokeExact(hIcon, piconinfo);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct _ICONINFOEXA {
     *     DWORD cbSize;
     *     BOOL fIcon;
     *     DWORD xHotspot;
     *     DWORD yHotspot;
     *     HBITMAP hbmMask;
     *     HBITMAP hbmColor;
     *     WORD wResID;
     *     CHAR szModName[260];
     *     CHAR szResName[260];
     * } *PICONINFOEXA
     * }
     */
    public static final AddressLayout PICONINFOEXA = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _ICONINFOEXW {
     *     DWORD cbSize;
     *     BOOL fIcon;
     *     DWORD xHotspot;
     *     DWORD yHotspot;
     *     HBITMAP hbmMask;
     *     HBITMAP hbmColor;
     *     WORD wResID;
     *     WCHAR szModName[260];
     *     WCHAR szResName[260];
     * } *PICONINFOEXW
     * }
     */
    public static final AddressLayout PICONINFOEXW = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef PICONINFOEXA PICONINFOEX
     * }
     */
    public static final AddressLayout PICONINFOEX = C_POINTER;

    private static class GetIconInfoExA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetIconInfoExA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetIconInfoExA(HICON hicon, PICONINFOEXA piconinfo)
     * }
     */
    public static FunctionDescriptor GetIconInfoExA$descriptor() {
        return GetIconInfoExA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetIconInfoExA(HICON hicon, PICONINFOEXA piconinfo)
     * }
     */
    public static MethodHandle GetIconInfoExA$handle() {
        return GetIconInfoExA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL GetIconInfoExA(HICON hicon, PICONINFOEXA piconinfo)
     * }
     */
    public static int GetIconInfoExA(MemorySegment hicon, MemorySegment piconinfo) {
        var mh$ = GetIconInfoExA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetIconInfoExA", hicon, piconinfo);
            }
            return (int)mh$.invokeExact(hicon, piconinfo);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetIconInfoExW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetIconInfoExW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetIconInfoExW(HICON hicon, PICONINFOEXW piconinfo)
     * }
     */
    public static FunctionDescriptor GetIconInfoExW$descriptor() {
        return GetIconInfoExW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetIconInfoExW(HICON hicon, PICONINFOEXW piconinfo)
     * }
     */
    public static MethodHandle GetIconInfoExW$handle() {
        return GetIconInfoExW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL GetIconInfoExW(HICON hicon, PICONINFOEXW piconinfo)
     * }
     */
    public static int GetIconInfoExW(MemorySegment hicon, MemorySegment piconinfo) {
        var mh$ = GetIconInfoExW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetIconInfoExW", hicon, piconinfo);
            }
            return (int)mh$.invokeExact(hicon, piconinfo);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int EDIT_CONTROL_FEATURE_ENTERPRISE_DATA_PROTECTION_PASTE_SUPPORT = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.EDIT_CONTROL_FEATURE_ENTERPRISE_DATA_PROTECTION_PASTE_SUPPORT = 0
     * }
     */
    public static int EDIT_CONTROL_FEATURE_ENTERPRISE_DATA_PROTECTION_PASTE_SUPPORT() {
        return EDIT_CONTROL_FEATURE_ENTERPRISE_DATA_PROTECTION_PASTE_SUPPORT;
    }
    private static final int EDIT_CONTROL_FEATURE_PASTE_NOTIFICATIONS = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.EDIT_CONTROL_FEATURE_PASTE_NOTIFICATIONS = 1
     * }
     */
    public static int EDIT_CONTROL_FEATURE_PASTE_NOTIFICATIONS() {
        return EDIT_CONTROL_FEATURE_PASTE_NOTIFICATIONS;
    }

    private static class IsDialogMessageA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("IsDialogMessageA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL IsDialogMessageA(HWND hDlg, LPMSG lpMsg)
     * }
     */
    public static FunctionDescriptor IsDialogMessageA$descriptor() {
        return IsDialogMessageA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL IsDialogMessageA(HWND hDlg, LPMSG lpMsg)
     * }
     */
    public static MethodHandle IsDialogMessageA$handle() {
        return IsDialogMessageA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL IsDialogMessageA(HWND hDlg, LPMSG lpMsg)
     * }
     */
    public static int IsDialogMessageA(MemorySegment hDlg, MemorySegment lpMsg) {
        var mh$ = IsDialogMessageA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("IsDialogMessageA", hDlg, lpMsg);
            }
            return (int)mh$.invokeExact(hDlg, lpMsg);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class IsDialogMessageW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("IsDialogMessageW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL IsDialogMessageW(HWND hDlg, LPMSG lpMsg)
     * }
     */
    public static FunctionDescriptor IsDialogMessageW$descriptor() {
        return IsDialogMessageW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL IsDialogMessageW(HWND hDlg, LPMSG lpMsg)
     * }
     */
    public static MethodHandle IsDialogMessageW$handle() {
        return IsDialogMessageW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL IsDialogMessageW(HWND hDlg, LPMSG lpMsg)
     * }
     */
    public static int IsDialogMessageW(MemorySegment hDlg, MemorySegment lpMsg) {
        var mh$ = IsDialogMessageW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("IsDialogMessageW", hDlg, lpMsg);
            }
            return (int)mh$.invokeExact(hDlg, lpMsg);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MapDialogRect {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("MapDialogRect"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL MapDialogRect(HWND hDlg, LPRECT lpRect)
     * }
     */
    public static FunctionDescriptor MapDialogRect$descriptor() {
        return MapDialogRect.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL MapDialogRect(HWND hDlg, LPRECT lpRect)
     * }
     */
    public static MethodHandle MapDialogRect$handle() {
        return MapDialogRect.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL MapDialogRect(HWND hDlg, LPRECT lpRect)
     * }
     */
    public static int MapDialogRect(MemorySegment hDlg, MemorySegment lpRect) {
        var mh$ = MapDialogRect.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MapDialogRect", hDlg, lpRect);
            }
            return (int)mh$.invokeExact(hDlg, lpRect);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DlgDirListA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_INT,
            C_INT,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("DlgDirListA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int DlgDirListA(HWND hDlg, LPSTR lpPathSpec, int nIDListBox, int nIDStaticPath, UINT uFileType)
     * }
     */
    public static FunctionDescriptor DlgDirListA$descriptor() {
        return DlgDirListA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int DlgDirListA(HWND hDlg, LPSTR lpPathSpec, int nIDListBox, int nIDStaticPath, UINT uFileType)
     * }
     */
    public static MethodHandle DlgDirListA$handle() {
        return DlgDirListA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int DlgDirListA(HWND hDlg, LPSTR lpPathSpec, int nIDListBox, int nIDStaticPath, UINT uFileType)
     * }
     */
    public static int DlgDirListA(MemorySegment hDlg, MemorySegment lpPathSpec, int nIDListBox, int nIDStaticPath, int uFileType) {
        var mh$ = DlgDirListA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DlgDirListA", hDlg, lpPathSpec, nIDListBox, nIDStaticPath, uFileType);
            }
            return (int)mh$.invokeExact(hDlg, lpPathSpec, nIDListBox, nIDStaticPath, uFileType);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DlgDirListW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_INT,
            C_INT,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("DlgDirListW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int DlgDirListW(HWND hDlg, LPWSTR lpPathSpec, int nIDListBox, int nIDStaticPath, UINT uFileType)
     * }
     */
    public static FunctionDescriptor DlgDirListW$descriptor() {
        return DlgDirListW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int DlgDirListW(HWND hDlg, LPWSTR lpPathSpec, int nIDListBox, int nIDStaticPath, UINT uFileType)
     * }
     */
    public static MethodHandle DlgDirListW$handle() {
        return DlgDirListW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int DlgDirListW(HWND hDlg, LPWSTR lpPathSpec, int nIDListBox, int nIDStaticPath, UINT uFileType)
     * }
     */
    public static int DlgDirListW(MemorySegment hDlg, MemorySegment lpPathSpec, int nIDListBox, int nIDStaticPath, int uFileType) {
        var mh$ = DlgDirListW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DlgDirListW", hDlg, lpPathSpec, nIDListBox, nIDStaticPath, uFileType);
            }
            return (int)mh$.invokeExact(hDlg, lpPathSpec, nIDListBox, nIDStaticPath, uFileType);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DlgDirSelectExA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_INT,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("DlgDirSelectExA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL DlgDirSelectExA(HWND hwndDlg, LPSTR lpString, int chCount, int idListBox)
     * }
     */
    public static FunctionDescriptor DlgDirSelectExA$descriptor() {
        return DlgDirSelectExA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL DlgDirSelectExA(HWND hwndDlg, LPSTR lpString, int chCount, int idListBox)
     * }
     */
    public static MethodHandle DlgDirSelectExA$handle() {
        return DlgDirSelectExA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL DlgDirSelectExA(HWND hwndDlg, LPSTR lpString, int chCount, int idListBox)
     * }
     */
    public static int DlgDirSelectExA(MemorySegment hwndDlg, MemorySegment lpString, int chCount, int idListBox) {
        var mh$ = DlgDirSelectExA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DlgDirSelectExA", hwndDlg, lpString, chCount, idListBox);
            }
            return (int)mh$.invokeExact(hwndDlg, lpString, chCount, idListBox);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DlgDirSelectExW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_INT,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("DlgDirSelectExW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL DlgDirSelectExW(HWND hwndDlg, LPWSTR lpString, int chCount, int idListBox)
     * }
     */
    public static FunctionDescriptor DlgDirSelectExW$descriptor() {
        return DlgDirSelectExW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL DlgDirSelectExW(HWND hwndDlg, LPWSTR lpString, int chCount, int idListBox)
     * }
     */
    public static MethodHandle DlgDirSelectExW$handle() {
        return DlgDirSelectExW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL DlgDirSelectExW(HWND hwndDlg, LPWSTR lpString, int chCount, int idListBox)
     * }
     */
    public static int DlgDirSelectExW(MemorySegment hwndDlg, MemorySegment lpString, int chCount, int idListBox) {
        var mh$ = DlgDirSelectExW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DlgDirSelectExW", hwndDlg, lpString, chCount, idListBox);
            }
            return (int)mh$.invokeExact(hwndDlg, lpString, chCount, idListBox);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DlgDirListComboBoxA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_INT,
            C_INT,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("DlgDirListComboBoxA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int DlgDirListComboBoxA(HWND hDlg, LPSTR lpPathSpec, int nIDComboBox, int nIDStaticPath, UINT uFiletype)
     * }
     */
    public static FunctionDescriptor DlgDirListComboBoxA$descriptor() {
        return DlgDirListComboBoxA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int DlgDirListComboBoxA(HWND hDlg, LPSTR lpPathSpec, int nIDComboBox, int nIDStaticPath, UINT uFiletype)
     * }
     */
    public static MethodHandle DlgDirListComboBoxA$handle() {
        return DlgDirListComboBoxA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int DlgDirListComboBoxA(HWND hDlg, LPSTR lpPathSpec, int nIDComboBox, int nIDStaticPath, UINT uFiletype)
     * }
     */
    public static int DlgDirListComboBoxA(MemorySegment hDlg, MemorySegment lpPathSpec, int nIDComboBox, int nIDStaticPath, int uFiletype) {
        var mh$ = DlgDirListComboBoxA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DlgDirListComboBoxA", hDlg, lpPathSpec, nIDComboBox, nIDStaticPath, uFiletype);
            }
            return (int)mh$.invokeExact(hDlg, lpPathSpec, nIDComboBox, nIDStaticPath, uFiletype);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DlgDirListComboBoxW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_INT,
            C_INT,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("DlgDirListComboBoxW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int DlgDirListComboBoxW(HWND hDlg, LPWSTR lpPathSpec, int nIDComboBox, int nIDStaticPath, UINT uFiletype)
     * }
     */
    public static FunctionDescriptor DlgDirListComboBoxW$descriptor() {
        return DlgDirListComboBoxW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int DlgDirListComboBoxW(HWND hDlg, LPWSTR lpPathSpec, int nIDComboBox, int nIDStaticPath, UINT uFiletype)
     * }
     */
    public static MethodHandle DlgDirListComboBoxW$handle() {
        return DlgDirListComboBoxW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int DlgDirListComboBoxW(HWND hDlg, LPWSTR lpPathSpec, int nIDComboBox, int nIDStaticPath, UINT uFiletype)
     * }
     */
    public static int DlgDirListComboBoxW(MemorySegment hDlg, MemorySegment lpPathSpec, int nIDComboBox, int nIDStaticPath, int uFiletype) {
        var mh$ = DlgDirListComboBoxW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DlgDirListComboBoxW", hDlg, lpPathSpec, nIDComboBox, nIDStaticPath, uFiletype);
            }
            return (int)mh$.invokeExact(hDlg, lpPathSpec, nIDComboBox, nIDStaticPath, uFiletype);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DlgDirSelectComboBoxExA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_INT,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("DlgDirSelectComboBoxExA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL DlgDirSelectComboBoxExA(HWND hwndDlg, LPSTR lpString, int cchOut, int idComboBox)
     * }
     */
    public static FunctionDescriptor DlgDirSelectComboBoxExA$descriptor() {
        return DlgDirSelectComboBoxExA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL DlgDirSelectComboBoxExA(HWND hwndDlg, LPSTR lpString, int cchOut, int idComboBox)
     * }
     */
    public static MethodHandle DlgDirSelectComboBoxExA$handle() {
        return DlgDirSelectComboBoxExA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL DlgDirSelectComboBoxExA(HWND hwndDlg, LPSTR lpString, int cchOut, int idComboBox)
     * }
     */
    public static int DlgDirSelectComboBoxExA(MemorySegment hwndDlg, MemorySegment lpString, int cchOut, int idComboBox) {
        var mh$ = DlgDirSelectComboBoxExA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DlgDirSelectComboBoxExA", hwndDlg, lpString, cchOut, idComboBox);
            }
            return (int)mh$.invokeExact(hwndDlg, lpString, cchOut, idComboBox);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DlgDirSelectComboBoxExW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_INT,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("DlgDirSelectComboBoxExW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL DlgDirSelectComboBoxExW(HWND hwndDlg, LPWSTR lpString, int cchOut, int idComboBox)
     * }
     */
    public static FunctionDescriptor DlgDirSelectComboBoxExW$descriptor() {
        return DlgDirSelectComboBoxExW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL DlgDirSelectComboBoxExW(HWND hwndDlg, LPWSTR lpString, int cchOut, int idComboBox)
     * }
     */
    public static MethodHandle DlgDirSelectComboBoxExW$handle() {
        return DlgDirSelectComboBoxExW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL DlgDirSelectComboBoxExW(HWND hwndDlg, LPWSTR lpString, int cchOut, int idComboBox)
     * }
     */
    public static int DlgDirSelectComboBoxExW(MemorySegment hwndDlg, MemorySegment lpString, int cchOut, int idComboBox) {
        var mh$ = DlgDirSelectComboBoxExW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DlgDirSelectComboBoxExW", hwndDlg, lpString, cchOut, idComboBox);
            }
            return (int)mh$.invokeExact(hwndDlg, lpString, cchOut, idComboBox);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct tagSCROLLINFO {
     *     UINT cbSize;
     *     UINT fMask;
     *     int nMin;
     *     int nMax;
     *     UINT nPage;
     *     int nPos;
     *     int nTrackPos;
     * } *LPSCROLLINFO
     * }
     */
    public static final AddressLayout LPSCROLLINFO = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef const SCROLLINFO *LPCSCROLLINFO
     * }
     */
    public static final AddressLayout LPCSCROLLINFO = C_POINTER;

    private static class SetScrollInfo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_INT,
            C_POINTER,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("SetScrollInfo"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SetScrollInfo(HWND hwnd, int nBar, LPCSCROLLINFO lpsi, BOOL redraw)
     * }
     */
    public static FunctionDescriptor SetScrollInfo$descriptor() {
        return SetScrollInfo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SetScrollInfo(HWND hwnd, int nBar, LPCSCROLLINFO lpsi, BOOL redraw)
     * }
     */
    public static MethodHandle SetScrollInfo$handle() {
        return SetScrollInfo.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int SetScrollInfo(HWND hwnd, int nBar, LPCSCROLLINFO lpsi, BOOL redraw)
     * }
     */
    public static int SetScrollInfo(MemorySegment hwnd, int nBar, MemorySegment lpsi, int redraw) {
        var mh$ = SetScrollInfo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetScrollInfo", hwnd, nBar, lpsi, redraw);
            }
            return (int)mh$.invokeExact(hwnd, nBar, lpsi, redraw);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetScrollInfo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetScrollInfo"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetScrollInfo(HWND hwnd, int nBar, LPSCROLLINFO lpsi)
     * }
     */
    public static FunctionDescriptor GetScrollInfo$descriptor() {
        return GetScrollInfo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetScrollInfo(HWND hwnd, int nBar, LPSCROLLINFO lpsi)
     * }
     */
    public static MethodHandle GetScrollInfo$handle() {
        return GetScrollInfo.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL GetScrollInfo(HWND hwnd, int nBar, LPSCROLLINFO lpsi)
     * }
     */
    public static int GetScrollInfo(MemorySegment hwnd, int nBar, MemorySegment lpsi) {
        var mh$ = GetScrollInfo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetScrollInfo", hwnd, nBar, lpsi);
            }
            return (int)mh$.invokeExact(hwnd, nBar, lpsi);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct tagMDICREATESTRUCTA {
     *     LPCSTR szClass;
     *     LPCSTR szTitle;
     *     HANDLE hOwner;
     *     int x;
     *     int y;
     *     int cx;
     *     int cy;
     *     DWORD style;
     *     LPARAM lParam;
     * } *LPMDICREATESTRUCTA
     * }
     */
    public static final AddressLayout LPMDICREATESTRUCTA = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagMDICREATESTRUCTW {
     *     LPCWSTR szClass;
     *     LPCWSTR szTitle;
     *     HANDLE hOwner;
     *     int x;
     *     int y;
     *     int cx;
     *     int cy;
     *     DWORD style;
     *     LPARAM lParam;
     * } *LPMDICREATESTRUCTW
     * }
     */
    public static final AddressLayout LPMDICREATESTRUCTW = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef LPMDICREATESTRUCTA LPMDICREATESTRUCT
     * }
     */
    public static final AddressLayout LPMDICREATESTRUCT = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagCLIENTCREATESTRUCT {
     *     HANDLE hWindowMenu;
     *     UINT idFirstChild;
     * } *LPCLIENTCREATESTRUCT
     * }
     */
    public static final AddressLayout LPCLIENTCREATESTRUCT = C_POINTER;

    private static class DefFrameProcA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG_LONG,
            C_POINTER,
            C_POINTER,
            C_INT,
            C_LONG_LONG,
            C_LONG_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("DefFrameProcA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LRESULT DefFrameProcA(HWND hWnd, HWND hWndMDIClient, UINT uMsg, WPARAM wParam, LPARAM lParam)
     * }
     */
    public static FunctionDescriptor DefFrameProcA$descriptor() {
        return DefFrameProcA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LRESULT DefFrameProcA(HWND hWnd, HWND hWndMDIClient, UINT uMsg, WPARAM wParam, LPARAM lParam)
     * }
     */
    public static MethodHandle DefFrameProcA$handle() {
        return DefFrameProcA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * LRESULT DefFrameProcA(HWND hWnd, HWND hWndMDIClient, UINT uMsg, WPARAM wParam, LPARAM lParam)
     * }
     */
    public static long DefFrameProcA(MemorySegment hWnd, MemorySegment hWndMDIClient, int uMsg, long wParam, long lParam) {
        var mh$ = DefFrameProcA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DefFrameProcA", hWnd, hWndMDIClient, uMsg, wParam, lParam);
            }
            return (long)mh$.invokeExact(hWnd, hWndMDIClient, uMsg, wParam, lParam);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DefFrameProcW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG_LONG,
            C_POINTER,
            C_POINTER,
            C_INT,
            C_LONG_LONG,
            C_LONG_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("DefFrameProcW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LRESULT DefFrameProcW(HWND hWnd, HWND hWndMDIClient, UINT uMsg, WPARAM wParam, LPARAM lParam)
     * }
     */
    public static FunctionDescriptor DefFrameProcW$descriptor() {
        return DefFrameProcW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LRESULT DefFrameProcW(HWND hWnd, HWND hWndMDIClient, UINT uMsg, WPARAM wParam, LPARAM lParam)
     * }
     */
    public static MethodHandle DefFrameProcW$handle() {
        return DefFrameProcW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * LRESULT DefFrameProcW(HWND hWnd, HWND hWndMDIClient, UINT uMsg, WPARAM wParam, LPARAM lParam)
     * }
     */
    public static long DefFrameProcW(MemorySegment hWnd, MemorySegment hWndMDIClient, int uMsg, long wParam, long lParam) {
        var mh$ = DefFrameProcW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DefFrameProcW", hWnd, hWndMDIClient, uMsg, wParam, lParam);
            }
            return (long)mh$.invokeExact(hWnd, hWndMDIClient, uMsg, wParam, lParam);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DefMDIChildProcA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG_LONG,
            C_POINTER,
            C_INT,
            C_LONG_LONG,
            C_LONG_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("DefMDIChildProcA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LRESULT DefMDIChildProcA(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
     * }
     */
    public static FunctionDescriptor DefMDIChildProcA$descriptor() {
        return DefMDIChildProcA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LRESULT DefMDIChildProcA(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
     * }
     */
    public static MethodHandle DefMDIChildProcA$handle() {
        return DefMDIChildProcA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * LRESULT DefMDIChildProcA(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
     * }
     */
    public static long DefMDIChildProcA(MemorySegment hWnd, int uMsg, long wParam, long lParam) {
        var mh$ = DefMDIChildProcA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DefMDIChildProcA", hWnd, uMsg, wParam, lParam);
            }
            return (long)mh$.invokeExact(hWnd, uMsg, wParam, lParam);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DefMDIChildProcW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG_LONG,
            C_POINTER,
            C_INT,
            C_LONG_LONG,
            C_LONG_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("DefMDIChildProcW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LRESULT DefMDIChildProcW(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
     * }
     */
    public static FunctionDescriptor DefMDIChildProcW$descriptor() {
        return DefMDIChildProcW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LRESULT DefMDIChildProcW(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
     * }
     */
    public static MethodHandle DefMDIChildProcW$handle() {
        return DefMDIChildProcW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * LRESULT DefMDIChildProcW(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
     * }
     */
    public static long DefMDIChildProcW(MemorySegment hWnd, int uMsg, long wParam, long lParam) {
        var mh$ = DefMDIChildProcW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DefMDIChildProcW", hWnd, uMsg, wParam, lParam);
            }
            return (long)mh$.invokeExact(hWnd, uMsg, wParam, lParam);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TranslateMDISysAccel {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("TranslateMDISysAccel"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL TranslateMDISysAccel(HWND hWndClient, LPMSG lpMsg)
     * }
     */
    public static FunctionDescriptor TranslateMDISysAccel$descriptor() {
        return TranslateMDISysAccel.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL TranslateMDISysAccel(HWND hWndClient, LPMSG lpMsg)
     * }
     */
    public static MethodHandle TranslateMDISysAccel$handle() {
        return TranslateMDISysAccel.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL TranslateMDISysAccel(HWND hWndClient, LPMSG lpMsg)
     * }
     */
    public static int TranslateMDISysAccel(MemorySegment hWndClient, MemorySegment lpMsg) {
        var mh$ = TranslateMDISysAccel.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TranslateMDISysAccel", hWndClient, lpMsg);
            }
            return (int)mh$.invokeExact(hWndClient, lpMsg);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ArrangeIconicWindows {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("ArrangeIconicWindows"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * UINT ArrangeIconicWindows(HWND hWnd)
     * }
     */
    public static FunctionDescriptor ArrangeIconicWindows$descriptor() {
        return ArrangeIconicWindows.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * UINT ArrangeIconicWindows(HWND hWnd)
     * }
     */
    public static MethodHandle ArrangeIconicWindows$handle() {
        return ArrangeIconicWindows.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * UINT ArrangeIconicWindows(HWND hWnd)
     * }
     */
    public static int ArrangeIconicWindows(MemorySegment hWnd) {
        var mh$ = ArrangeIconicWindows.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ArrangeIconicWindows", hWnd);
            }
            return (int)mh$.invokeExact(hWnd);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateMDIWindowA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_LONG,
            C_INT,
            C_INT,
            C_INT,
            C_INT,
            C_POINTER,
            C_POINTER,
            C_LONG_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CreateMDIWindowA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HWND CreateMDIWindowA(LPCSTR lpClassName, LPCSTR lpWindowName, DWORD dwStyle, int X, int Y, int nWidth, int nHeight, HWND hWndParent, HINSTANCE hInstance, LPARAM lParam)
     * }
     */
    public static FunctionDescriptor CreateMDIWindowA$descriptor() {
        return CreateMDIWindowA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HWND CreateMDIWindowA(LPCSTR lpClassName, LPCSTR lpWindowName, DWORD dwStyle, int X, int Y, int nWidth, int nHeight, HWND hWndParent, HINSTANCE hInstance, LPARAM lParam)
     * }
     */
    public static MethodHandle CreateMDIWindowA$handle() {
        return CreateMDIWindowA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * HWND CreateMDIWindowA(LPCSTR lpClassName, LPCSTR lpWindowName, DWORD dwStyle, int X, int Y, int nWidth, int nHeight, HWND hWndParent, HINSTANCE hInstance, LPARAM lParam)
     * }
     */
    public static MemorySegment CreateMDIWindowA(MemorySegment lpClassName, MemorySegment lpWindowName, int dwStyle, int X, int Y, int nWidth, int nHeight, MemorySegment hWndParent, MemorySegment hInstance, long lParam) {
        var mh$ = CreateMDIWindowA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateMDIWindowA", lpClassName, lpWindowName, dwStyle, X, Y, nWidth, nHeight, hWndParent, hInstance, lParam);
            }
            return (MemorySegment)mh$.invokeExact(lpClassName, lpWindowName, dwStyle, X, Y, nWidth, nHeight, hWndParent, hInstance, lParam);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateMDIWindowW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_LONG,
            C_INT,
            C_INT,
            C_INT,
            C_INT,
            C_POINTER,
            C_POINTER,
            C_LONG_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CreateMDIWindowW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HWND CreateMDIWindowW(LPCWSTR lpClassName, LPCWSTR lpWindowName, DWORD dwStyle, int X, int Y, int nWidth, int nHeight, HWND hWndParent, HINSTANCE hInstance, LPARAM lParam)
     * }
     */
    public static FunctionDescriptor CreateMDIWindowW$descriptor() {
        return CreateMDIWindowW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HWND CreateMDIWindowW(LPCWSTR lpClassName, LPCWSTR lpWindowName, DWORD dwStyle, int X, int Y, int nWidth, int nHeight, HWND hWndParent, HINSTANCE hInstance, LPARAM lParam)
     * }
     */
    public static MethodHandle CreateMDIWindowW$handle() {
        return CreateMDIWindowW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * HWND CreateMDIWindowW(LPCWSTR lpClassName, LPCWSTR lpWindowName, DWORD dwStyle, int X, int Y, int nWidth, int nHeight, HWND hWndParent, HINSTANCE hInstance, LPARAM lParam)
     * }
     */
    public static MemorySegment CreateMDIWindowW(MemorySegment lpClassName, MemorySegment lpWindowName, int dwStyle, int X, int Y, int nWidth, int nHeight, MemorySegment hWndParent, MemorySegment hInstance, long lParam) {
        var mh$ = CreateMDIWindowW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateMDIWindowW", lpClassName, lpWindowName, dwStyle, X, Y, nWidth, nHeight, hWndParent, hInstance, lParam);
            }
            return (MemorySegment)mh$.invokeExact(lpClassName, lpWindowName, dwStyle, X, Y, nWidth, nHeight, hWndParent, hInstance, lParam);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TileWindows {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_SHORT,
            C_POINTER,
            C_INT,
            C_POINTER,
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("TileWindows"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * WORD TileWindows(HWND hwndParent, UINT wHow, const RECT *lpRect, UINT cKids, const HWND *lpKids)
     * }
     */
    public static FunctionDescriptor TileWindows$descriptor() {
        return TileWindows.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * WORD TileWindows(HWND hwndParent, UINT wHow, const RECT *lpRect, UINT cKids, const HWND *lpKids)
     * }
     */
    public static MethodHandle TileWindows$handle() {
        return TileWindows.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * WORD TileWindows(HWND hwndParent, UINT wHow, const RECT *lpRect, UINT cKids, const HWND *lpKids)
     * }
     */
    public static short TileWindows(MemorySegment hwndParent, int wHow, MemorySegment lpRect, int cKids, MemorySegment lpKids) {
        var mh$ = TileWindows.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TileWindows", hwndParent, wHow, lpRect, cKids, lpKids);
            }
            return (short)mh$.invokeExact(hwndParent, wHow, lpRect, cKids, lpKids);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CascadeWindows {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_SHORT,
            C_POINTER,
            C_INT,
            C_POINTER,
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CascadeWindows"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * WORD CascadeWindows(HWND hwndParent, UINT wHow, const RECT *lpRect, UINT cKids, const HWND *lpKids)
     * }
     */
    public static FunctionDescriptor CascadeWindows$descriptor() {
        return CascadeWindows.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * WORD CascadeWindows(HWND hwndParent, UINT wHow, const RECT *lpRect, UINT cKids, const HWND *lpKids)
     * }
     */
    public static MethodHandle CascadeWindows$handle() {
        return CascadeWindows.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * WORD CascadeWindows(HWND hwndParent, UINT wHow, const RECT *lpRect, UINT cKids, const HWND *lpKids)
     * }
     */
    public static short CascadeWindows(MemorySegment hwndParent, int wHow, MemorySegment lpRect, int cKids, MemorySegment lpKids) {
        var mh$ = CascadeWindows.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CascadeWindows", hwndParent, wHow, lpRect, cKids, lpKids);
            }
            return (short)mh$.invokeExact(hwndParent, wHow, lpRect, cKids, lpKids);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef DWORD HELPPOLY
     * }
     */
    public static final OfInt HELPPOLY = C_LONG;
    /**
     * {@snippet lang=c :
     * typedef struct tagMULTIKEYHELPA {
     *     DWORD mkSize;
     *     CHAR mkKeylist;
     *     CHAR szKeyphrase[1];
     * } *PMULTIKEYHELPA
     * }
     */
    public static final AddressLayout PMULTIKEYHELPA = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagMULTIKEYHELPA {
     *     DWORD mkSize;
     *     CHAR mkKeylist;
     *     CHAR szKeyphrase[1];
     * } *LPMULTIKEYHELPA
     * }
     */
    public static final AddressLayout LPMULTIKEYHELPA = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagMULTIKEYHELPW {
     *     DWORD mkSize;
     *     WCHAR mkKeylist;
     *     WCHAR szKeyphrase[1];
     * } *PMULTIKEYHELPW
     * }
     */
    public static final AddressLayout PMULTIKEYHELPW = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagMULTIKEYHELPW {
     *     DWORD mkSize;
     *     WCHAR mkKeylist;
     *     WCHAR szKeyphrase[1];
     * } *LPMULTIKEYHELPW
     * }
     */
    public static final AddressLayout LPMULTIKEYHELPW = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef PMULTIKEYHELPA PMULTIKEYHELP
     * }
     */
    public static final AddressLayout PMULTIKEYHELP = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef LPMULTIKEYHELPA LPMULTIKEYHELP
     * }
     */
    public static final AddressLayout LPMULTIKEYHELP = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagHELPWININFOA {
     *     int wStructSize;
     *     int x;
     *     int y;
     *     int dx;
     *     int dy;
     *     int wMax;
     *     CHAR rgchMember[2];
     * } *PHELPWININFOA
     * }
     */
    public static final AddressLayout PHELPWININFOA = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagHELPWININFOA {
     *     int wStructSize;
     *     int x;
     *     int y;
     *     int dx;
     *     int dy;
     *     int wMax;
     *     CHAR rgchMember[2];
     * } *LPHELPWININFOA
     * }
     */
    public static final AddressLayout LPHELPWININFOA = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagHELPWININFOW {
     *     int wStructSize;
     *     int x;
     *     int y;
     *     int dx;
     *     int dy;
     *     int wMax;
     *     WCHAR rgchMember[2];
     * } *PHELPWININFOW
     * }
     */
    public static final AddressLayout PHELPWININFOW = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagHELPWININFOW {
     *     int wStructSize;
     *     int x;
     *     int y;
     *     int dx;
     *     int dy;
     *     int wMax;
     *     WCHAR rgchMember[2];
     * } *LPHELPWININFOW
     * }
     */
    public static final AddressLayout LPHELPWININFOW = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef PHELPWININFOA PHELPWININFO
     * }
     */
    public static final AddressLayout PHELPWININFO = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef LPHELPWININFOA LPHELPWININFO
     * }
     */
    public static final AddressLayout LPHELPWININFO = C_POINTER;

    private static class WinHelpA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_INT,
            C_LONG_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("WinHelpA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL WinHelpA(HWND hWndMain, LPCSTR lpszHelp, UINT uCommand, ULONG_PTR dwData)
     * }
     */
    public static FunctionDescriptor WinHelpA$descriptor() {
        return WinHelpA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL WinHelpA(HWND hWndMain, LPCSTR lpszHelp, UINT uCommand, ULONG_PTR dwData)
     * }
     */
    public static MethodHandle WinHelpA$handle() {
        return WinHelpA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL WinHelpA(HWND hWndMain, LPCSTR lpszHelp, UINT uCommand, ULONG_PTR dwData)
     * }
     */
    public static int WinHelpA(MemorySegment hWndMain, MemorySegment lpszHelp, int uCommand, long dwData) {
        var mh$ = WinHelpA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WinHelpA", hWndMain, lpszHelp, uCommand, dwData);
            }
            return (int)mh$.invokeExact(hWndMain, lpszHelp, uCommand, dwData);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class WinHelpW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_INT,
            C_LONG_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("WinHelpW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL WinHelpW(HWND hWndMain, LPCWSTR lpszHelp, UINT uCommand, ULONG_PTR dwData)
     * }
     */
    public static FunctionDescriptor WinHelpW$descriptor() {
        return WinHelpW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL WinHelpW(HWND hWndMain, LPCWSTR lpszHelp, UINT uCommand, ULONG_PTR dwData)
     * }
     */
    public static MethodHandle WinHelpW$handle() {
        return WinHelpW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL WinHelpW(HWND hWndMain, LPCWSTR lpszHelp, UINT uCommand, ULONG_PTR dwData)
     * }
     */
    public static int WinHelpW(MemorySegment hWndMain, MemorySegment lpszHelp, int uCommand, long dwData) {
        var mh$ = WinHelpW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WinHelpW", hWndMain, lpszHelp, uCommand, dwData);
            }
            return (int)mh$.invokeExact(hWndMain, lpszHelp, uCommand, dwData);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetGuiResources {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_POINTER,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetGuiResources"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetGuiResources(HANDLE hProcess, DWORD uiFlags)
     * }
     */
    public static FunctionDescriptor GetGuiResources$descriptor() {
        return GetGuiResources.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetGuiResources(HANDLE hProcess, DWORD uiFlags)
     * }
     */
    public static MethodHandle GetGuiResources$handle() {
        return GetGuiResources.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * DWORD GetGuiResources(HANDLE hProcess, DWORD uiFlags)
     * }
     */
    public static int GetGuiResources(MemorySegment hProcess, int uiFlags) {
        var mh$ = GetGuiResources.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetGuiResources", hProcess, uiFlags);
            }
            return (int)mh$.invokeExact(hProcess, uiFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct tagTouchPredictionParameters {
     *     UINT cbSize;
     *     UINT dwLatency;
     *     UINT dwSampleTime;
     *     UINT bUseHWTimeStamp;
     * } *PTOUCHPREDICTIONPARAMETERS
     * }
     */
    public static final AddressLayout PTOUCHPREDICTIONPARAMETERS = C_POINTER;
    private static final int HANDEDNESS_LEFT = (int)0L;
    /**
     * {@snippet lang=c :
     * enum tagHANDEDNESS.HANDEDNESS_LEFT = 0
     * }
     */
    public static int HANDEDNESS_LEFT() {
        return HANDEDNESS_LEFT;
    }
    private static final int HANDEDNESS_RIGHT = (int)1L;
    /**
     * {@snippet lang=c :
     * enum tagHANDEDNESS.HANDEDNESS_RIGHT = 1
     * }
     */
    public static int HANDEDNESS_RIGHT() {
        return HANDEDNESS_RIGHT;
    }
    /**
     * {@snippet lang=c :
     * typedef enum tagHANDEDNESS {
     *     HANDEDNESS_LEFT = 0,
     *     HANDEDNESS_RIGHT
     * } *PHANDEDNESS
     * }
     */
    public static final AddressLayout PHANDEDNESS = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagNONCLIENTMETRICSA {
     *     UINT cbSize;
     *     int iBorderWidth;
     *     int iScrollWidth;
     *     int iScrollHeight;
     *     int iCaptionWidth;
     *     int iCaptionHeight;
     *     LOGFONTA lfCaptionFont;
     *     int iSmCaptionWidth;
     *     int iSmCaptionHeight;
     *     LOGFONTA lfSmCaptionFont;
     *     int iMenuWidth;
     *     int iMenuHeight;
     *     LOGFONTA lfMenuFont;
     *     LOGFONTA lfStatusFont;
     *     LOGFONTA lfMessageFont;
     *     int iPaddedBorderWidth;
     * } *PNONCLIENTMETRICSA
     * }
     */
    public static final AddressLayout PNONCLIENTMETRICSA = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagNONCLIENTMETRICSA {
     *     UINT cbSize;
     *     int iBorderWidth;
     *     int iScrollWidth;
     *     int iScrollHeight;
     *     int iCaptionWidth;
     *     int iCaptionHeight;
     *     LOGFONTA lfCaptionFont;
     *     int iSmCaptionWidth;
     *     int iSmCaptionHeight;
     *     LOGFONTA lfSmCaptionFont;
     *     int iMenuWidth;
     *     int iMenuHeight;
     *     LOGFONTA lfMenuFont;
     *     LOGFONTA lfStatusFont;
     *     LOGFONTA lfMessageFont;
     *     int iPaddedBorderWidth;
     * } *LPNONCLIENTMETRICSA
     * }
     */
    public static final AddressLayout LPNONCLIENTMETRICSA = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagNONCLIENTMETRICSW {
     *     UINT cbSize;
     *     int iBorderWidth;
     *     int iScrollWidth;
     *     int iScrollHeight;
     *     int iCaptionWidth;
     *     int iCaptionHeight;
     *     LOGFONTW lfCaptionFont;
     *     int iSmCaptionWidth;
     *     int iSmCaptionHeight;
     *     LOGFONTW lfSmCaptionFont;
     *     int iMenuWidth;
     *     int iMenuHeight;
     *     LOGFONTW lfMenuFont;
     *     LOGFONTW lfStatusFont;
     *     LOGFONTW lfMessageFont;
     *     int iPaddedBorderWidth;
     * } *PNONCLIENTMETRICSW
     * }
     */
    public static final AddressLayout PNONCLIENTMETRICSW = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagNONCLIENTMETRICSW {
     *     UINT cbSize;
     *     int iBorderWidth;
     *     int iScrollWidth;
     *     int iScrollHeight;
     *     int iCaptionWidth;
     *     int iCaptionHeight;
     *     LOGFONTW lfCaptionFont;
     *     int iSmCaptionWidth;
     *     int iSmCaptionHeight;
     *     LOGFONTW lfSmCaptionFont;
     *     int iMenuWidth;
     *     int iMenuHeight;
     *     LOGFONTW lfMenuFont;
     *     LOGFONTW lfStatusFont;
     *     LOGFONTW lfMessageFont;
     *     int iPaddedBorderWidth;
     * } *LPNONCLIENTMETRICSW
     * }
     */
    public static final AddressLayout LPNONCLIENTMETRICSW = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef PNONCLIENTMETRICSA PNONCLIENTMETRICS
     * }
     */
    public static final AddressLayout PNONCLIENTMETRICS = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef LPNONCLIENTMETRICSA LPNONCLIENTMETRICS
     * }
     */
    public static final AddressLayout LPNONCLIENTMETRICS = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagMINIMIZEDMETRICS {
     *     UINT cbSize;
     *     int iWidth;
     *     int iHorzGap;
     *     int iVertGap;
     *     int iArrange;
     * } *PMINIMIZEDMETRICS
     * }
     */
    public static final AddressLayout PMINIMIZEDMETRICS = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagMINIMIZEDMETRICS {
     *     UINT cbSize;
     *     int iWidth;
     *     int iHorzGap;
     *     int iVertGap;
     *     int iArrange;
     * } *LPMINIMIZEDMETRICS
     * }
     */
    public static final AddressLayout LPMINIMIZEDMETRICS = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagICONMETRICSA {
     *     UINT cbSize;
     *     int iHorzSpacing;
     *     int iVertSpacing;
     *     int iTitleWrap;
     *     LOGFONTA lfFont;
     * } *PICONMETRICSA
     * }
     */
    public static final AddressLayout PICONMETRICSA = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagICONMETRICSA {
     *     UINT cbSize;
     *     int iHorzSpacing;
     *     int iVertSpacing;
     *     int iTitleWrap;
     *     LOGFONTA lfFont;
     * } *LPICONMETRICSA
     * }
     */
    public static final AddressLayout LPICONMETRICSA = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagICONMETRICSW {
     *     UINT cbSize;
     *     int iHorzSpacing;
     *     int iVertSpacing;
     *     int iTitleWrap;
     *     LOGFONTW lfFont;
     * } *PICONMETRICSW
     * }
     */
    public static final AddressLayout PICONMETRICSW = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagICONMETRICSW {
     *     UINT cbSize;
     *     int iHorzSpacing;
     *     int iVertSpacing;
     *     int iTitleWrap;
     *     LOGFONTW lfFont;
     * } *LPICONMETRICSW
     * }
     */
    public static final AddressLayout LPICONMETRICSW = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef PICONMETRICSA PICONMETRICS
     * }
     */
    public static final AddressLayout PICONMETRICS = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef LPICONMETRICSA LPICONMETRICS
     * }
     */
    public static final AddressLayout LPICONMETRICS = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagANIMATIONINFO {
     *     UINT cbSize;
     *     int iMinAnimate;
     * } *LPANIMATIONINFO
     * }
     */
    public static final AddressLayout LPANIMATIONINFO = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagSERIALKEYSA {
     *     UINT cbSize;
     *     DWORD dwFlags;
     *     LPSTR lpszActivePort;
     *     LPSTR lpszPort;
     *     UINT iBaudRate;
     *     UINT iPortState;
     *     UINT iActive;
     * } *LPSERIALKEYSA
     * }
     */
    public static final AddressLayout LPSERIALKEYSA = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagSERIALKEYSW {
     *     UINT cbSize;
     *     DWORD dwFlags;
     *     LPWSTR lpszActivePort;
     *     LPWSTR lpszPort;
     *     UINT iBaudRate;
     *     UINT iPortState;
     *     UINT iActive;
     * } *LPSERIALKEYSW
     * }
     */
    public static final AddressLayout LPSERIALKEYSW = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef LPSERIALKEYSA LPSERIALKEYS
     * }
     */
    public static final AddressLayout LPSERIALKEYS = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagHIGHCONTRASTA {
     *     UINT cbSize;
     *     DWORD dwFlags;
     *     LPSTR lpszDefaultScheme;
     * } *LPHIGHCONTRASTA
     * }
     */
    public static final AddressLayout LPHIGHCONTRASTA = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagHIGHCONTRASTW {
     *     UINT cbSize;
     *     DWORD dwFlags;
     *     LPWSTR lpszDefaultScheme;
     * } *LPHIGHCONTRASTW
     * }
     */
    public static final AddressLayout LPHIGHCONTRASTW = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef LPHIGHCONTRASTA LPHIGHCONTRAST
     * }
     */
    public static final AddressLayout LPHIGHCONTRAST = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _VIDEOPARAMETERS {
     *     GUID Guid;
     *     ULONG dwOffset;
     *     ULONG dwCommand;
     *     ULONG dwFlags;
     *     ULONG dwMode;
     *     ULONG dwTVStandard;
     *     ULONG dwAvailableModes;
     *     ULONG dwAvailableTVStandard;
     *     ULONG dwFlickerFilter;
     *     ULONG dwOverScanX;
     *     ULONG dwOverScanY;
     *     ULONG dwMaxUnscaledX;
     *     ULONG dwMaxUnscaledY;
     *     ULONG dwPositionX;
     *     ULONG dwPositionY;
     *     ULONG dwBrightness;
     *     ULONG dwContrast;
     *     ULONG dwCPType;
     *     ULONG dwCPCommand;
     *     ULONG dwCPStandard;
     *     ULONG dwCPKey;
     *     ULONG bCP_APSTriggerBits;
     *     UCHAR bOEMCopyProtection[256];
     * } *PVIDEOPARAMETERS
     * }
     */
    public static final AddressLayout PVIDEOPARAMETERS = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _VIDEOPARAMETERS {
     *     GUID Guid;
     *     ULONG dwOffset;
     *     ULONG dwCommand;
     *     ULONG dwFlags;
     *     ULONG dwMode;
     *     ULONG dwTVStandard;
     *     ULONG dwAvailableModes;
     *     ULONG dwAvailableTVStandard;
     *     ULONG dwFlickerFilter;
     *     ULONG dwOverScanX;
     *     ULONG dwOverScanY;
     *     ULONG dwMaxUnscaledX;
     *     ULONG dwMaxUnscaledY;
     *     ULONG dwPositionX;
     *     ULONG dwPositionY;
     *     ULONG dwBrightness;
     *     ULONG dwContrast;
     *     ULONG dwCPType;
     *     ULONG dwCPCommand;
     *     ULONG dwCPStandard;
     *     ULONG dwCPKey;
     *     ULONG bCP_APSTriggerBits;
     *     UCHAR bOEMCopyProtection[256];
     * } *LPVIDEOPARAMETERS
     * }
     */
    public static final AddressLayout LPVIDEOPARAMETERS = C_POINTER;

    private static class ChangeDisplaySettingsA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_POINTER,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("ChangeDisplaySettingsA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LONG ChangeDisplaySettingsA(DEVMODEA *lpDevMode, DWORD dwFlags)
     * }
     */
    public static FunctionDescriptor ChangeDisplaySettingsA$descriptor() {
        return ChangeDisplaySettingsA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LONG ChangeDisplaySettingsA(DEVMODEA *lpDevMode, DWORD dwFlags)
     * }
     */
    public static MethodHandle ChangeDisplaySettingsA$handle() {
        return ChangeDisplaySettingsA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * LONG ChangeDisplaySettingsA(DEVMODEA *lpDevMode, DWORD dwFlags)
     * }
     */
    public static int ChangeDisplaySettingsA(MemorySegment lpDevMode, int dwFlags) {
        var mh$ = ChangeDisplaySettingsA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ChangeDisplaySettingsA", lpDevMode, dwFlags);
            }
            return (int)mh$.invokeExact(lpDevMode, dwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ChangeDisplaySettingsW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_POINTER,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("ChangeDisplaySettingsW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LONG ChangeDisplaySettingsW(DEVMODEW *lpDevMode, DWORD dwFlags)
     * }
     */
    public static FunctionDescriptor ChangeDisplaySettingsW$descriptor() {
        return ChangeDisplaySettingsW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LONG ChangeDisplaySettingsW(DEVMODEW *lpDevMode, DWORD dwFlags)
     * }
     */
    public static MethodHandle ChangeDisplaySettingsW$handle() {
        return ChangeDisplaySettingsW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * LONG ChangeDisplaySettingsW(DEVMODEW *lpDevMode, DWORD dwFlags)
     * }
     */
    public static int ChangeDisplaySettingsW(MemorySegment lpDevMode, int dwFlags) {
        var mh$ = ChangeDisplaySettingsW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ChangeDisplaySettingsW", lpDevMode, dwFlags);
            }
            return (int)mh$.invokeExact(lpDevMode, dwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ChangeDisplaySettingsExA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_LONG,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("ChangeDisplaySettingsExA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LONG ChangeDisplaySettingsExA(LPCSTR lpszDeviceName, DEVMODEA *lpDevMode, HWND hwnd, DWORD dwflags, LPVOID lParam)
     * }
     */
    public static FunctionDescriptor ChangeDisplaySettingsExA$descriptor() {
        return ChangeDisplaySettingsExA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LONG ChangeDisplaySettingsExA(LPCSTR lpszDeviceName, DEVMODEA *lpDevMode, HWND hwnd, DWORD dwflags, LPVOID lParam)
     * }
     */
    public static MethodHandle ChangeDisplaySettingsExA$handle() {
        return ChangeDisplaySettingsExA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * LONG ChangeDisplaySettingsExA(LPCSTR lpszDeviceName, DEVMODEA *lpDevMode, HWND hwnd, DWORD dwflags, LPVOID lParam)
     * }
     */
    public static int ChangeDisplaySettingsExA(MemorySegment lpszDeviceName, MemorySegment lpDevMode, MemorySegment hwnd, int dwflags, MemorySegment lParam) {
        var mh$ = ChangeDisplaySettingsExA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ChangeDisplaySettingsExA", lpszDeviceName, lpDevMode, hwnd, dwflags, lParam);
            }
            return (int)mh$.invokeExact(lpszDeviceName, lpDevMode, hwnd, dwflags, lParam);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ChangeDisplaySettingsExW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_LONG,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("ChangeDisplaySettingsExW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LONG ChangeDisplaySettingsExW(LPCWSTR lpszDeviceName, DEVMODEW *lpDevMode, HWND hwnd, DWORD dwflags, LPVOID lParam)
     * }
     */
    public static FunctionDescriptor ChangeDisplaySettingsExW$descriptor() {
        return ChangeDisplaySettingsExW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LONG ChangeDisplaySettingsExW(LPCWSTR lpszDeviceName, DEVMODEW *lpDevMode, HWND hwnd, DWORD dwflags, LPVOID lParam)
     * }
     */
    public static MethodHandle ChangeDisplaySettingsExW$handle() {
        return ChangeDisplaySettingsExW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * LONG ChangeDisplaySettingsExW(LPCWSTR lpszDeviceName, DEVMODEW *lpDevMode, HWND hwnd, DWORD dwflags, LPVOID lParam)
     * }
     */
    public static int ChangeDisplaySettingsExW(MemorySegment lpszDeviceName, MemorySegment lpDevMode, MemorySegment hwnd, int dwflags, MemorySegment lParam) {
        var mh$ = ChangeDisplaySettingsExW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ChangeDisplaySettingsExW", lpszDeviceName, lpDevMode, hwnd, dwflags, lParam);
            }
            return (int)mh$.invokeExact(lpszDeviceName, lpDevMode, hwnd, dwflags, lParam);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class EnumDisplaySettingsA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_LONG,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("EnumDisplaySettingsA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL EnumDisplaySettingsA(LPCSTR lpszDeviceName, DWORD iModeNum, DEVMODEA *lpDevMode)
     * }
     */
    public static FunctionDescriptor EnumDisplaySettingsA$descriptor() {
        return EnumDisplaySettingsA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL EnumDisplaySettingsA(LPCSTR lpszDeviceName, DWORD iModeNum, DEVMODEA *lpDevMode)
     * }
     */
    public static MethodHandle EnumDisplaySettingsA$handle() {
        return EnumDisplaySettingsA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL EnumDisplaySettingsA(LPCSTR lpszDeviceName, DWORD iModeNum, DEVMODEA *lpDevMode)
     * }
     */
    public static int EnumDisplaySettingsA(MemorySegment lpszDeviceName, int iModeNum, MemorySegment lpDevMode) {
        var mh$ = EnumDisplaySettingsA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("EnumDisplaySettingsA", lpszDeviceName, iModeNum, lpDevMode);
            }
            return (int)mh$.invokeExact(lpszDeviceName, iModeNum, lpDevMode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class EnumDisplaySettingsW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_LONG,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("EnumDisplaySettingsW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL EnumDisplaySettingsW(LPCWSTR lpszDeviceName, DWORD iModeNum, DEVMODEW *lpDevMode)
     * }
     */
    public static FunctionDescriptor EnumDisplaySettingsW$descriptor() {
        return EnumDisplaySettingsW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL EnumDisplaySettingsW(LPCWSTR lpszDeviceName, DWORD iModeNum, DEVMODEW *lpDevMode)
     * }
     */
    public static MethodHandle EnumDisplaySettingsW$handle() {
        return EnumDisplaySettingsW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL EnumDisplaySettingsW(LPCWSTR lpszDeviceName, DWORD iModeNum, DEVMODEW *lpDevMode)
     * }
     */
    public static int EnumDisplaySettingsW(MemorySegment lpszDeviceName, int iModeNum, MemorySegment lpDevMode) {
        var mh$ = EnumDisplaySettingsW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("EnumDisplaySettingsW", lpszDeviceName, iModeNum, lpDevMode);
            }
            return (int)mh$.invokeExact(lpszDeviceName, iModeNum, lpDevMode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class EnumDisplaySettingsExA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_LONG,
            C_POINTER,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("EnumDisplaySettingsExA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL EnumDisplaySettingsExA(LPCSTR lpszDeviceName, DWORD iModeNum, DEVMODEA *lpDevMode, DWORD dwFlags)
     * }
     */
    public static FunctionDescriptor EnumDisplaySettingsExA$descriptor() {
        return EnumDisplaySettingsExA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL EnumDisplaySettingsExA(LPCSTR lpszDeviceName, DWORD iModeNum, DEVMODEA *lpDevMode, DWORD dwFlags)
     * }
     */
    public static MethodHandle EnumDisplaySettingsExA$handle() {
        return EnumDisplaySettingsExA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL EnumDisplaySettingsExA(LPCSTR lpszDeviceName, DWORD iModeNum, DEVMODEA *lpDevMode, DWORD dwFlags)
     * }
     */
    public static int EnumDisplaySettingsExA(MemorySegment lpszDeviceName, int iModeNum, MemorySegment lpDevMode, int dwFlags) {
        var mh$ = EnumDisplaySettingsExA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("EnumDisplaySettingsExA", lpszDeviceName, iModeNum, lpDevMode, dwFlags);
            }
            return (int)mh$.invokeExact(lpszDeviceName, iModeNum, lpDevMode, dwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class EnumDisplaySettingsExW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_LONG,
            C_POINTER,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("EnumDisplaySettingsExW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL EnumDisplaySettingsExW(LPCWSTR lpszDeviceName, DWORD iModeNum, DEVMODEW *lpDevMode, DWORD dwFlags)
     * }
     */
    public static FunctionDescriptor EnumDisplaySettingsExW$descriptor() {
        return EnumDisplaySettingsExW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL EnumDisplaySettingsExW(LPCWSTR lpszDeviceName, DWORD iModeNum, DEVMODEW *lpDevMode, DWORD dwFlags)
     * }
     */
    public static MethodHandle EnumDisplaySettingsExW$handle() {
        return EnumDisplaySettingsExW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL EnumDisplaySettingsExW(LPCWSTR lpszDeviceName, DWORD iModeNum, DEVMODEW *lpDevMode, DWORD dwFlags)
     * }
     */
    public static int EnumDisplaySettingsExW(MemorySegment lpszDeviceName, int iModeNum, MemorySegment lpDevMode, int dwFlags) {
        var mh$ = EnumDisplaySettingsExW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("EnumDisplaySettingsExW", lpszDeviceName, iModeNum, lpDevMode, dwFlags);
            }
            return (int)mh$.invokeExact(lpszDeviceName, iModeNum, lpDevMode, dwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class EnumDisplayDevicesA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_LONG,
            C_POINTER,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("EnumDisplayDevicesA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL EnumDisplayDevicesA(LPCSTR lpDevice, DWORD iDevNum, PDISPLAY_DEVICEA lpDisplayDevice, DWORD dwFlags)
     * }
     */
    public static FunctionDescriptor EnumDisplayDevicesA$descriptor() {
        return EnumDisplayDevicesA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL EnumDisplayDevicesA(LPCSTR lpDevice, DWORD iDevNum, PDISPLAY_DEVICEA lpDisplayDevice, DWORD dwFlags)
     * }
     */
    public static MethodHandle EnumDisplayDevicesA$handle() {
        return EnumDisplayDevicesA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL EnumDisplayDevicesA(LPCSTR lpDevice, DWORD iDevNum, PDISPLAY_DEVICEA lpDisplayDevice, DWORD dwFlags)
     * }
     */
    public static int EnumDisplayDevicesA(MemorySegment lpDevice, int iDevNum, MemorySegment lpDisplayDevice, int dwFlags) {
        var mh$ = EnumDisplayDevicesA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("EnumDisplayDevicesA", lpDevice, iDevNum, lpDisplayDevice, dwFlags);
            }
            return (int)mh$.invokeExact(lpDevice, iDevNum, lpDisplayDevice, dwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class EnumDisplayDevicesW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_LONG,
            C_POINTER,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("EnumDisplayDevicesW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL EnumDisplayDevicesW(LPCWSTR lpDevice, DWORD iDevNum, PDISPLAY_DEVICEW lpDisplayDevice, DWORD dwFlags)
     * }
     */
    public static FunctionDescriptor EnumDisplayDevicesW$descriptor() {
        return EnumDisplayDevicesW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL EnumDisplayDevicesW(LPCWSTR lpDevice, DWORD iDevNum, PDISPLAY_DEVICEW lpDisplayDevice, DWORD dwFlags)
     * }
     */
    public static MethodHandle EnumDisplayDevicesW$handle() {
        return EnumDisplayDevicesW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL EnumDisplayDevicesW(LPCWSTR lpDevice, DWORD iDevNum, PDISPLAY_DEVICEW lpDisplayDevice, DWORD dwFlags)
     * }
     */
    public static int EnumDisplayDevicesW(MemorySegment lpDevice, int iDevNum, MemorySegment lpDisplayDevice, int dwFlags) {
        var mh$ = EnumDisplayDevicesW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("EnumDisplayDevicesW", lpDevice, iDevNum, lpDisplayDevice, dwFlags);
            }
            return (int)mh$.invokeExact(lpDevice, iDevNum, lpDisplayDevice, dwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetDisplayConfigBufferSizes {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_INT,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetDisplayConfigBufferSizes"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LONG GetDisplayConfigBufferSizes(UINT32 flags, UINT32 *numPathArrayElements, UINT32 *numModeInfoArrayElements)
     * }
     */
    public static FunctionDescriptor GetDisplayConfigBufferSizes$descriptor() {
        return GetDisplayConfigBufferSizes.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LONG GetDisplayConfigBufferSizes(UINT32 flags, UINT32 *numPathArrayElements, UINT32 *numModeInfoArrayElements)
     * }
     */
    public static MethodHandle GetDisplayConfigBufferSizes$handle() {
        return GetDisplayConfigBufferSizes.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * LONG GetDisplayConfigBufferSizes(UINT32 flags, UINT32 *numPathArrayElements, UINT32 *numModeInfoArrayElements)
     * }
     */
    public static int GetDisplayConfigBufferSizes(int flags, MemorySegment numPathArrayElements, MemorySegment numModeInfoArrayElements) {
        var mh$ = GetDisplayConfigBufferSizes.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetDisplayConfigBufferSizes", flags, numPathArrayElements, numModeInfoArrayElements);
            }
            return (int)mh$.invokeExact(flags, numPathArrayElements, numModeInfoArrayElements);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetDisplayConfig {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_INT,
            C_POINTER,
            C_INT,
            C_POINTER,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("SetDisplayConfig"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LONG SetDisplayConfig(UINT32 numPathArrayElements, DISPLAYCONFIG_PATH_INFO *pathArray, UINT32 numModeInfoArrayElements, DISPLAYCONFIG_MODE_INFO *modeInfoArray, UINT32 flags)
     * }
     */
    public static FunctionDescriptor SetDisplayConfig$descriptor() {
        return SetDisplayConfig.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LONG SetDisplayConfig(UINT32 numPathArrayElements, DISPLAYCONFIG_PATH_INFO *pathArray, UINT32 numModeInfoArrayElements, DISPLAYCONFIG_MODE_INFO *modeInfoArray, UINT32 flags)
     * }
     */
    public static MethodHandle SetDisplayConfig$handle() {
        return SetDisplayConfig.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * LONG SetDisplayConfig(UINT32 numPathArrayElements, DISPLAYCONFIG_PATH_INFO *pathArray, UINT32 numModeInfoArrayElements, DISPLAYCONFIG_MODE_INFO *modeInfoArray, UINT32 flags)
     * }
     */
    public static int SetDisplayConfig(int numPathArrayElements, MemorySegment pathArray, int numModeInfoArrayElements, MemorySegment modeInfoArray, int flags) {
        var mh$ = SetDisplayConfig.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetDisplayConfig", numPathArrayElements, pathArray, numModeInfoArrayElements, modeInfoArray, flags);
            }
            return (int)mh$.invokeExact(numPathArrayElements, pathArray, numModeInfoArrayElements, modeInfoArray, flags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class QueryDisplayConfig {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_INT,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("QueryDisplayConfig"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LONG QueryDisplayConfig(UINT32 flags, UINT32 *numPathArrayElements, DISPLAYCONFIG_PATH_INFO *pathArray, UINT32 *numModeInfoArrayElements, DISPLAYCONFIG_MODE_INFO *modeInfoArray, DISPLAYCONFIG_TOPOLOGY_ID *currentTopologyId)
     * }
     */
    public static FunctionDescriptor QueryDisplayConfig$descriptor() {
        return QueryDisplayConfig.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LONG QueryDisplayConfig(UINT32 flags, UINT32 *numPathArrayElements, DISPLAYCONFIG_PATH_INFO *pathArray, UINT32 *numModeInfoArrayElements, DISPLAYCONFIG_MODE_INFO *modeInfoArray, DISPLAYCONFIG_TOPOLOGY_ID *currentTopologyId)
     * }
     */
    public static MethodHandle QueryDisplayConfig$handle() {
        return QueryDisplayConfig.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * LONG QueryDisplayConfig(UINT32 flags, UINT32 *numPathArrayElements, DISPLAYCONFIG_PATH_INFO *pathArray, UINT32 *numModeInfoArrayElements, DISPLAYCONFIG_MODE_INFO *modeInfoArray, DISPLAYCONFIG_TOPOLOGY_ID *currentTopologyId)
     * }
     */
    public static int QueryDisplayConfig(int flags, MemorySegment numPathArrayElements, MemorySegment pathArray, MemorySegment numModeInfoArrayElements, MemorySegment modeInfoArray, MemorySegment currentTopologyId) {
        var mh$ = QueryDisplayConfig.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("QueryDisplayConfig", flags, numPathArrayElements, pathArray, numModeInfoArrayElements, modeInfoArray, currentTopologyId);
            }
            return (int)mh$.invokeExact(flags, numPathArrayElements, pathArray, numModeInfoArrayElements, modeInfoArray, currentTopologyId);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DisplayConfigGetDeviceInfo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("DisplayConfigGetDeviceInfo"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LONG DisplayConfigGetDeviceInfo(DISPLAYCONFIG_DEVICE_INFO_HEADER *requestPacket)
     * }
     */
    public static FunctionDescriptor DisplayConfigGetDeviceInfo$descriptor() {
        return DisplayConfigGetDeviceInfo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LONG DisplayConfigGetDeviceInfo(DISPLAYCONFIG_DEVICE_INFO_HEADER *requestPacket)
     * }
     */
    public static MethodHandle DisplayConfigGetDeviceInfo$handle() {
        return DisplayConfigGetDeviceInfo.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * LONG DisplayConfigGetDeviceInfo(DISPLAYCONFIG_DEVICE_INFO_HEADER *requestPacket)
     * }
     */
    public static int DisplayConfigGetDeviceInfo(MemorySegment requestPacket) {
        var mh$ = DisplayConfigGetDeviceInfo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DisplayConfigGetDeviceInfo", requestPacket);
            }
            return (int)mh$.invokeExact(requestPacket);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DisplayConfigSetDeviceInfo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("DisplayConfigSetDeviceInfo"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LONG DisplayConfigSetDeviceInfo(DISPLAYCONFIG_DEVICE_INFO_HEADER *setPacket)
     * }
     */
    public static FunctionDescriptor DisplayConfigSetDeviceInfo$descriptor() {
        return DisplayConfigSetDeviceInfo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LONG DisplayConfigSetDeviceInfo(DISPLAYCONFIG_DEVICE_INFO_HEADER *setPacket)
     * }
     */
    public static MethodHandle DisplayConfigSetDeviceInfo$handle() {
        return DisplayConfigSetDeviceInfo.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * LONG DisplayConfigSetDeviceInfo(DISPLAYCONFIG_DEVICE_INFO_HEADER *setPacket)
     * }
     */
    public static int DisplayConfigSetDeviceInfo(MemorySegment setPacket) {
        var mh$ = DisplayConfigSetDeviceInfo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DisplayConfigSetDeviceInfo", setPacket);
            }
            return (int)mh$.invokeExact(setPacket);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SystemParametersInfoA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_INT,
            C_INT,
            C_POINTER,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("SystemParametersInfoA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SystemParametersInfoA(UINT uiAction, UINT uiParam, PVOID pvParam, UINT fWinIni)
     * }
     */
    public static FunctionDescriptor SystemParametersInfoA$descriptor() {
        return SystemParametersInfoA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SystemParametersInfoA(UINT uiAction, UINT uiParam, PVOID pvParam, UINT fWinIni)
     * }
     */
    public static MethodHandle SystemParametersInfoA$handle() {
        return SystemParametersInfoA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL SystemParametersInfoA(UINT uiAction, UINT uiParam, PVOID pvParam, UINT fWinIni)
     * }
     */
    public static int SystemParametersInfoA(int uiAction, int uiParam, MemorySegment pvParam, int fWinIni) {
        var mh$ = SystemParametersInfoA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SystemParametersInfoA", uiAction, uiParam, pvParam, fWinIni);
            }
            return (int)mh$.invokeExact(uiAction, uiParam, pvParam, fWinIni);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SystemParametersInfoW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_INT,
            C_INT,
            C_POINTER,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("SystemParametersInfoW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SystemParametersInfoW(UINT uiAction, UINT uiParam, PVOID pvParam, UINT fWinIni)
     * }
     */
    public static FunctionDescriptor SystemParametersInfoW$descriptor() {
        return SystemParametersInfoW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SystemParametersInfoW(UINT uiAction, UINT uiParam, PVOID pvParam, UINT fWinIni)
     * }
     */
    public static MethodHandle SystemParametersInfoW$handle() {
        return SystemParametersInfoW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL SystemParametersInfoW(UINT uiAction, UINT uiParam, PVOID pvParam, UINT fWinIni)
     * }
     */
    public static int SystemParametersInfoW(int uiAction, int uiParam, MemorySegment pvParam, int fWinIni) {
        var mh$ = SystemParametersInfoW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SystemParametersInfoW", uiAction, uiParam, pvParam, fWinIni);
            }
            return (int)mh$.invokeExact(uiAction, uiParam, pvParam, fWinIni);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SystemParametersInfoForDpi {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_INT,
            C_INT,
            C_POINTER,
            C_INT,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("SystemParametersInfoForDpi"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SystemParametersInfoForDpi(UINT uiAction, UINT uiParam, PVOID pvParam, UINT fWinIni, UINT dpi)
     * }
     */
    public static FunctionDescriptor SystemParametersInfoForDpi$descriptor() {
        return SystemParametersInfoForDpi.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SystemParametersInfoForDpi(UINT uiAction, UINT uiParam, PVOID pvParam, UINT fWinIni, UINT dpi)
     * }
     */
    public static MethodHandle SystemParametersInfoForDpi$handle() {
        return SystemParametersInfoForDpi.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL SystemParametersInfoForDpi(UINT uiAction, UINT uiParam, PVOID pvParam, UINT fWinIni, UINT dpi)
     * }
     */
    public static int SystemParametersInfoForDpi(int uiAction, int uiParam, MemorySegment pvParam, int fWinIni, int dpi) {
        var mh$ = SystemParametersInfoForDpi.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SystemParametersInfoForDpi", uiAction, uiParam, pvParam, fWinIni, dpi);
            }
            return (int)mh$.invokeExact(uiAction, uiParam, pvParam, fWinIni, dpi);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct tagFILTERKEYS {
     *     UINT cbSize;
     *     DWORD dwFlags;
     *     DWORD iWaitMSec;
     *     DWORD iDelayMSec;
     *     DWORD iRepeatMSec;
     *     DWORD iBounceMSec;
     * } *LPFILTERKEYS
     * }
     */
    public static final AddressLayout LPFILTERKEYS = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagSTICKYKEYS {
     *     UINT cbSize;
     *     DWORD dwFlags;
     * } *LPSTICKYKEYS
     * }
     */
    public static final AddressLayout LPSTICKYKEYS = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagMOUSEKEYS {
     *     UINT cbSize;
     *     DWORD dwFlags;
     *     DWORD iMaxSpeed;
     *     DWORD iTimeToMaxSpeed;
     *     DWORD iCtrlSpeed;
     *     DWORD dwReserved1;
     *     DWORD dwReserved2;
     * } *LPMOUSEKEYS
     * }
     */
    public static final AddressLayout LPMOUSEKEYS = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagACCESSTIMEOUT {
     *     UINT cbSize;
     *     DWORD dwFlags;
     *     DWORD iTimeOutMSec;
     * } *LPACCESSTIMEOUT
     * }
     */
    public static final AddressLayout LPACCESSTIMEOUT = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagSOUNDSENTRYA {
     *     UINT cbSize;
     *     DWORD dwFlags;
     *     DWORD iFSTextEffect;
     *     DWORD iFSTextEffectMSec;
     *     DWORD iFSTextEffectColorBits;
     *     DWORD iFSGrafEffect;
     *     DWORD iFSGrafEffectMSec;
     *     DWORD iFSGrafEffectColor;
     *     DWORD iWindowsEffect;
     *     DWORD iWindowsEffectMSec;
     *     LPSTR lpszWindowsEffectDLL;
     *     DWORD iWindowsEffectOrdinal;
     * } *LPSOUNDSENTRYA
     * }
     */
    public static final AddressLayout LPSOUNDSENTRYA = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagSOUNDSENTRYW {
     *     UINT cbSize;
     *     DWORD dwFlags;
     *     DWORD iFSTextEffect;
     *     DWORD iFSTextEffectMSec;
     *     DWORD iFSTextEffectColorBits;
     *     DWORD iFSGrafEffect;
     *     DWORD iFSGrafEffectMSec;
     *     DWORD iFSGrafEffectColor;
     *     DWORD iWindowsEffect;
     *     DWORD iWindowsEffectMSec;
     *     LPWSTR lpszWindowsEffectDLL;
     *     DWORD iWindowsEffectOrdinal;
     * } *LPSOUNDSENTRYW
     * }
     */
    public static final AddressLayout LPSOUNDSENTRYW = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef LPSOUNDSENTRYA LPSOUNDSENTRY
     * }
     */
    public static final AddressLayout LPSOUNDSENTRY = C_POINTER;

    private static class SoundSentry {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT    );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("SoundSentry"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SoundSentry()
     * }
     */
    public static FunctionDescriptor SoundSentry$descriptor() {
        return SoundSentry.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SoundSentry()
     * }
     */
    public static MethodHandle SoundSentry$handle() {
        return SoundSentry.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL SoundSentry()
     * }
     */
    public static int SoundSentry() {
        var mh$ = SoundSentry.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SoundSentry");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct tagTOGGLEKEYS {
     *     UINT cbSize;
     *     DWORD dwFlags;
     * } *LPTOGGLEKEYS
     * }
     */
    public static final AddressLayout LPTOGGLEKEYS = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagAUDIODESCRIPTION {
     *     UINT cbSize;
     *     BOOL Enabled;
     *     LCID Locale;
     * } *LPAUDIODESCRIPTION
     * }
     */
    public static final AddressLayout LPAUDIODESCRIPTION = C_POINTER;

    private static class SetDebugErrorLevel {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("SetDebugErrorLevel"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SetDebugErrorLevel(DWORD dwLevel)
     * }
     */
    public static FunctionDescriptor SetDebugErrorLevel$descriptor() {
        return SetDebugErrorLevel.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SetDebugErrorLevel(DWORD dwLevel)
     * }
     */
    public static MethodHandle SetDebugErrorLevel$handle() {
        return SetDebugErrorLevel.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * void SetDebugErrorLevel(DWORD dwLevel)
     * }
     */
    public static void SetDebugErrorLevel(int dwLevel) {
        var mh$ = SetDebugErrorLevel.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetDebugErrorLevel", dwLevel);
            }
            mh$.invokeExact(dwLevel);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetLastErrorEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C_LONG,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("SetLastErrorEx"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SetLastErrorEx(DWORD dwErrCode, DWORD dwType)
     * }
     */
    public static FunctionDescriptor SetLastErrorEx$descriptor() {
        return SetLastErrorEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SetLastErrorEx(DWORD dwErrCode, DWORD dwType)
     * }
     */
    public static MethodHandle SetLastErrorEx$handle() {
        return SetLastErrorEx.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * void SetLastErrorEx(DWORD dwErrCode, DWORD dwType)
     * }
     */
    public static void SetLastErrorEx(int dwErrCode, int dwType) {
        var mh$ = SetLastErrorEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetLastErrorEx", dwErrCode, dwType);
            }
            mh$.invokeExact(dwErrCode, dwType);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class InternalGetWindowText {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("InternalGetWindowText"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int InternalGetWindowText(HWND hWnd, LPWSTR pString, int cchMaxCount)
     * }
     */
    public static FunctionDescriptor InternalGetWindowText$descriptor() {
        return InternalGetWindowText.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int InternalGetWindowText(HWND hWnd, LPWSTR pString, int cchMaxCount)
     * }
     */
    public static MethodHandle InternalGetWindowText$handle() {
        return InternalGetWindowText.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int InternalGetWindowText(HWND hWnd, LPWSTR pString, int cchMaxCount)
     * }
     */
    public static int InternalGetWindowText(MemorySegment hWnd, MemorySegment pString, int cchMaxCount) {
        var mh$ = InternalGetWindowText.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("InternalGetWindowText", hWnd, pString, cchMaxCount);
            }
            return (int)mh$.invokeExact(hWnd, pString, cchMaxCount);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CancelShutdown {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT    );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CancelShutdown"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CancelShutdown()
     * }
     */
    public static FunctionDescriptor CancelShutdown$descriptor() {
        return CancelShutdown.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CancelShutdown()
     * }
     */
    public static MethodHandle CancelShutdown$handle() {
        return CancelShutdown.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL CancelShutdown()
     * }
     */
    public static int CancelShutdown() {
        var mh$ = CancelShutdown.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CancelShutdown");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MonitorFromPoint {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            tagPOINT.layout(),
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("MonitorFromPoint"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HMONITOR MonitorFromPoint(POINT pt, DWORD dwFlags)
     * }
     */
    public static FunctionDescriptor MonitorFromPoint$descriptor() {
        return MonitorFromPoint.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HMONITOR MonitorFromPoint(POINT pt, DWORD dwFlags)
     * }
     */
    public static MethodHandle MonitorFromPoint$handle() {
        return MonitorFromPoint.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * HMONITOR MonitorFromPoint(POINT pt, DWORD dwFlags)
     * }
     */
    public static MemorySegment MonitorFromPoint(MemorySegment pt, int dwFlags) {
        var mh$ = MonitorFromPoint.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MonitorFromPoint", pt, dwFlags);
            }
            return (MemorySegment)mh$.invokeExact(pt, dwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MonitorFromRect {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("MonitorFromRect"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HMONITOR MonitorFromRect(LPCRECT lprc, DWORD dwFlags)
     * }
     */
    public static FunctionDescriptor MonitorFromRect$descriptor() {
        return MonitorFromRect.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HMONITOR MonitorFromRect(LPCRECT lprc, DWORD dwFlags)
     * }
     */
    public static MethodHandle MonitorFromRect$handle() {
        return MonitorFromRect.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * HMONITOR MonitorFromRect(LPCRECT lprc, DWORD dwFlags)
     * }
     */
    public static MemorySegment MonitorFromRect(MemorySegment lprc, int dwFlags) {
        var mh$ = MonitorFromRect.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MonitorFromRect", lprc, dwFlags);
            }
            return (MemorySegment)mh$.invokeExact(lprc, dwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MonitorFromWindow {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("MonitorFromWindow"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HMONITOR MonitorFromWindow(HWND hwnd, DWORD dwFlags)
     * }
     */
    public static FunctionDescriptor MonitorFromWindow$descriptor() {
        return MonitorFromWindow.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HMONITOR MonitorFromWindow(HWND hwnd, DWORD dwFlags)
     * }
     */
    public static MethodHandle MonitorFromWindow$handle() {
        return MonitorFromWindow.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * HMONITOR MonitorFromWindow(HWND hwnd, DWORD dwFlags)
     * }
     */
    public static MemorySegment MonitorFromWindow(MemorySegment hwnd, int dwFlags) {
        var mh$ = MonitorFromWindow.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MonitorFromWindow", hwnd, dwFlags);
            }
            return (MemorySegment)mh$.invokeExact(hwnd, dwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct tagMONITORINFO {
     *     DWORD cbSize;
     *     RECT rcMonitor;
     *     RECT rcWork;
     *     DWORD dwFlags;
     * } *LPMONITORINFO
     * }
     */
    public static final AddressLayout LPMONITORINFO = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagMONITORINFOEXA {
     *     CHAR szDevice[32];
     * } *LPMONITORINFOEXA
     * }
     */
    public static final AddressLayout LPMONITORINFOEXA = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagMONITORINFOEXW {
     *     WCHAR szDevice[32];
     * } *LPMONITORINFOEXW
     * }
     */
    public static final AddressLayout LPMONITORINFOEXW = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef LPMONITORINFOEXA LPMONITORINFOEX
     * }
     */
    public static final AddressLayout LPMONITORINFOEX = C_POINTER;

    private static class GetMonitorInfoA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetMonitorInfoA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetMonitorInfoA(HMONITOR hMonitor, LPMONITORINFO lpmi)
     * }
     */
    public static FunctionDescriptor GetMonitorInfoA$descriptor() {
        return GetMonitorInfoA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetMonitorInfoA(HMONITOR hMonitor, LPMONITORINFO lpmi)
     * }
     */
    public static MethodHandle GetMonitorInfoA$handle() {
        return GetMonitorInfoA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL GetMonitorInfoA(HMONITOR hMonitor, LPMONITORINFO lpmi)
     * }
     */
    public static int GetMonitorInfoA(MemorySegment hMonitor, MemorySegment lpmi) {
        var mh$ = GetMonitorInfoA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetMonitorInfoA", hMonitor, lpmi);
            }
            return (int)mh$.invokeExact(hMonitor, lpmi);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetMonitorInfoW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetMonitorInfoW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetMonitorInfoW(HMONITOR hMonitor, LPMONITORINFO lpmi)
     * }
     */
    public static FunctionDescriptor GetMonitorInfoW$descriptor() {
        return GetMonitorInfoW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetMonitorInfoW(HMONITOR hMonitor, LPMONITORINFO lpmi)
     * }
     */
    public static MethodHandle GetMonitorInfoW$handle() {
        return GetMonitorInfoW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL GetMonitorInfoW(HMONITOR hMonitor, LPMONITORINFO lpmi)
     * }
     */
    public static int GetMonitorInfoW(MemorySegment hMonitor, MemorySegment lpmi) {
        var mh$ = GetMonitorInfoW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetMonitorInfoW", hMonitor, lpmi);
            }
            return (int)mh$.invokeExact(hMonitor, lpmi);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class EnumDisplayMonitors {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_LONG_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("EnumDisplayMonitors"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL EnumDisplayMonitors(HDC hdc, LPCRECT lprcClip, MONITORENUMPROC lpfnEnum, LPARAM dwData)
     * }
     */
    public static FunctionDescriptor EnumDisplayMonitors$descriptor() {
        return EnumDisplayMonitors.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL EnumDisplayMonitors(HDC hdc, LPCRECT lprcClip, MONITORENUMPROC lpfnEnum, LPARAM dwData)
     * }
     */
    public static MethodHandle EnumDisplayMonitors$handle() {
        return EnumDisplayMonitors.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL EnumDisplayMonitors(HDC hdc, LPCRECT lprcClip, MONITORENUMPROC lpfnEnum, LPARAM dwData)
     * }
     */
    public static int EnumDisplayMonitors(MemorySegment hdc, MemorySegment lprcClip, MemorySegment lpfnEnum, long dwData) {
        var mh$ = EnumDisplayMonitors.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("EnumDisplayMonitors", hdc, lprcClip, lpfnEnum, dwData);
            }
            return (int)mh$.invokeExact(hdc, lprcClip, lpfnEnum, dwData);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class NotifyWinEvent {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C_LONG,
            C_POINTER,
            C_LONG,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("NotifyWinEvent"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void NotifyWinEvent(DWORD event, HWND hwnd, LONG idObject, LONG idChild)
     * }
     */
    public static FunctionDescriptor NotifyWinEvent$descriptor() {
        return NotifyWinEvent.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void NotifyWinEvent(DWORD event, HWND hwnd, LONG idObject, LONG idChild)
     * }
     */
    public static MethodHandle NotifyWinEvent$handle() {
        return NotifyWinEvent.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * void NotifyWinEvent(DWORD event, HWND hwnd, LONG idObject, LONG idChild)
     * }
     */
    public static void NotifyWinEvent(int event, MemorySegment hwnd, int idObject, int idChild) {
        var mh$ = NotifyWinEvent.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("NotifyWinEvent", event, hwnd, idObject, idChild);
            }
            mh$.invokeExact(event, hwnd, idObject, idChild);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetWinEventHook {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_LONG,
            C_LONG,
            C_POINTER,
            C_POINTER,
            C_LONG,
            C_LONG,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("SetWinEventHook"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HWINEVENTHOOK SetWinEventHook(DWORD eventMin, DWORD eventMax, HMODULE hmodWinEventProc, WINEVENTPROC pfnWinEventProc, DWORD idProcess, DWORD idThread, DWORD dwFlags)
     * }
     */
    public static FunctionDescriptor SetWinEventHook$descriptor() {
        return SetWinEventHook.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HWINEVENTHOOK SetWinEventHook(DWORD eventMin, DWORD eventMax, HMODULE hmodWinEventProc, WINEVENTPROC pfnWinEventProc, DWORD idProcess, DWORD idThread, DWORD dwFlags)
     * }
     */
    public static MethodHandle SetWinEventHook$handle() {
        return SetWinEventHook.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * HWINEVENTHOOK SetWinEventHook(DWORD eventMin, DWORD eventMax, HMODULE hmodWinEventProc, WINEVENTPROC pfnWinEventProc, DWORD idProcess, DWORD idThread, DWORD dwFlags)
     * }
     */
    public static MemorySegment SetWinEventHook(int eventMin, int eventMax, MemorySegment hmodWinEventProc, MemorySegment pfnWinEventProc, int idProcess, int idThread, int dwFlags) {
        var mh$ = SetWinEventHook.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetWinEventHook", eventMin, eventMax, hmodWinEventProc, pfnWinEventProc, idProcess, idThread, dwFlags);
            }
            return (MemorySegment)mh$.invokeExact(eventMin, eventMax, hmodWinEventProc, pfnWinEventProc, idProcess, idThread, dwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class IsWinEventHookInstalled {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("IsWinEventHookInstalled"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL IsWinEventHookInstalled(DWORD event)
     * }
     */
    public static FunctionDescriptor IsWinEventHookInstalled$descriptor() {
        return IsWinEventHookInstalled.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL IsWinEventHookInstalled(DWORD event)
     * }
     */
    public static MethodHandle IsWinEventHookInstalled$handle() {
        return IsWinEventHookInstalled.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL IsWinEventHookInstalled(DWORD event)
     * }
     */
    public static int IsWinEventHookInstalled(int event) {
        var mh$ = IsWinEventHookInstalled.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("IsWinEventHookInstalled", event);
            }
            return (int)mh$.invokeExact(event);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class UnhookWinEvent {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("UnhookWinEvent"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL UnhookWinEvent(HWINEVENTHOOK hWinEventHook)
     * }
     */
    public static FunctionDescriptor UnhookWinEvent$descriptor() {
        return UnhookWinEvent.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL UnhookWinEvent(HWINEVENTHOOK hWinEventHook)
     * }
     */
    public static MethodHandle UnhookWinEvent$handle() {
        return UnhookWinEvent.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL UnhookWinEvent(HWINEVENTHOOK hWinEventHook)
     * }
     */
    public static int UnhookWinEvent(MemorySegment hWinEventHook) {
        var mh$ = UnhookWinEvent.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("UnhookWinEvent", hWinEventHook);
            }
            return (int)mh$.invokeExact(hWinEventHook);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct tagGUITHREADINFO {
     *     DWORD cbSize;
     *     DWORD flags;
     *     HWND hwndActive;
     *     HWND hwndFocus;
     *     HWND hwndCapture;
     *     HWND hwndMenuOwner;
     *     HWND hwndMoveSize;
     *     HWND hwndCaret;
     *     RECT rcCaret;
     * } *PGUITHREADINFO
     * }
     */
    public static final AddressLayout PGUITHREADINFO = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagGUITHREADINFO {
     *     DWORD cbSize;
     *     DWORD flags;
     *     HWND hwndActive;
     *     HWND hwndFocus;
     *     HWND hwndCapture;
     *     HWND hwndMenuOwner;
     *     HWND hwndMoveSize;
     *     HWND hwndCaret;
     *     RECT rcCaret;
     * } *LPGUITHREADINFO
     * }
     */
    public static final AddressLayout LPGUITHREADINFO = C_POINTER;

    private static class GetGUIThreadInfo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_LONG,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetGUIThreadInfo"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetGUIThreadInfo(DWORD idThread, PGUITHREADINFO pgui)
     * }
     */
    public static FunctionDescriptor GetGUIThreadInfo$descriptor() {
        return GetGUIThreadInfo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetGUIThreadInfo(DWORD idThread, PGUITHREADINFO pgui)
     * }
     */
    public static MethodHandle GetGUIThreadInfo$handle() {
        return GetGUIThreadInfo.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL GetGUIThreadInfo(DWORD idThread, PGUITHREADINFO pgui)
     * }
     */
    public static int GetGUIThreadInfo(int idThread, MemorySegment pgui) {
        var mh$ = GetGUIThreadInfo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetGUIThreadInfo", idThread, pgui);
            }
            return (int)mh$.invokeExact(idThread, pgui);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class BlockInput {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("BlockInput"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL BlockInput(BOOL fBlockIt)
     * }
     */
    public static FunctionDescriptor BlockInput$descriptor() {
        return BlockInput.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL BlockInput(BOOL fBlockIt)
     * }
     */
    public static MethodHandle BlockInput$handle() {
        return BlockInput.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL BlockInput(BOOL fBlockIt)
     * }
     */
    public static int BlockInput(int fBlockIt) {
        var mh$ = BlockInput.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("BlockInput", fBlockIt);
            }
            return (int)mh$.invokeExact(fBlockIt);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetProcessDPIAware {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT    );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("SetProcessDPIAware"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetProcessDPIAware()
     * }
     */
    public static FunctionDescriptor SetProcessDPIAware$descriptor() {
        return SetProcessDPIAware.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetProcessDPIAware()
     * }
     */
    public static MethodHandle SetProcessDPIAware$handle() {
        return SetProcessDPIAware.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL SetProcessDPIAware()
     * }
     */
    public static int SetProcessDPIAware() {
        var mh$ = SetProcessDPIAware.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetProcessDPIAware");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class IsProcessDPIAware {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT    );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("IsProcessDPIAware"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL IsProcessDPIAware()
     * }
     */
    public static FunctionDescriptor IsProcessDPIAware$descriptor() {
        return IsProcessDPIAware.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL IsProcessDPIAware()
     * }
     */
    public static MethodHandle IsProcessDPIAware$handle() {
        return IsProcessDPIAware.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL IsProcessDPIAware()
     * }
     */
    public static int IsProcessDPIAware() {
        var mh$ = IsProcessDPIAware.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("IsProcessDPIAware");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetThreadDpiAwarenessContext {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("SetThreadDpiAwarenessContext"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DPI_AWARENESS_CONTEXT SetThreadDpiAwarenessContext(DPI_AWARENESS_CONTEXT dpiContext)
     * }
     */
    public static FunctionDescriptor SetThreadDpiAwarenessContext$descriptor() {
        return SetThreadDpiAwarenessContext.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DPI_AWARENESS_CONTEXT SetThreadDpiAwarenessContext(DPI_AWARENESS_CONTEXT dpiContext)
     * }
     */
    public static MethodHandle SetThreadDpiAwarenessContext$handle() {
        return SetThreadDpiAwarenessContext.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * DPI_AWARENESS_CONTEXT SetThreadDpiAwarenessContext(DPI_AWARENESS_CONTEXT dpiContext)
     * }
     */
    public static MemorySegment SetThreadDpiAwarenessContext(MemorySegment dpiContext) {
        var mh$ = SetThreadDpiAwarenessContext.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetThreadDpiAwarenessContext", dpiContext);
            }
            return (MemorySegment)mh$.invokeExact(dpiContext);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetThreadDpiAwarenessContext {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER    );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetThreadDpiAwarenessContext"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DPI_AWARENESS_CONTEXT GetThreadDpiAwarenessContext()
     * }
     */
    public static FunctionDescriptor GetThreadDpiAwarenessContext$descriptor() {
        return GetThreadDpiAwarenessContext.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DPI_AWARENESS_CONTEXT GetThreadDpiAwarenessContext()
     * }
     */
    public static MethodHandle GetThreadDpiAwarenessContext$handle() {
        return GetThreadDpiAwarenessContext.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * DPI_AWARENESS_CONTEXT GetThreadDpiAwarenessContext()
     * }
     */
    public static MemorySegment GetThreadDpiAwarenessContext() {
        var mh$ = GetThreadDpiAwarenessContext.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetThreadDpiAwarenessContext");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetWindowDpiAwarenessContext {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetWindowDpiAwarenessContext"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DPI_AWARENESS_CONTEXT GetWindowDpiAwarenessContext(HWND hwnd)
     * }
     */
    public static FunctionDescriptor GetWindowDpiAwarenessContext$descriptor() {
        return GetWindowDpiAwarenessContext.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DPI_AWARENESS_CONTEXT GetWindowDpiAwarenessContext(HWND hwnd)
     * }
     */
    public static MethodHandle GetWindowDpiAwarenessContext$handle() {
        return GetWindowDpiAwarenessContext.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * DPI_AWARENESS_CONTEXT GetWindowDpiAwarenessContext(HWND hwnd)
     * }
     */
    public static MemorySegment GetWindowDpiAwarenessContext(MemorySegment hwnd) {
        var mh$ = GetWindowDpiAwarenessContext.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetWindowDpiAwarenessContext", hwnd);
            }
            return (MemorySegment)mh$.invokeExact(hwnd);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetAwarenessFromDpiAwarenessContext {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetAwarenessFromDpiAwarenessContext"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DPI_AWARENESS GetAwarenessFromDpiAwarenessContext(DPI_AWARENESS_CONTEXT value)
     * }
     */
    public static FunctionDescriptor GetAwarenessFromDpiAwarenessContext$descriptor() {
        return GetAwarenessFromDpiAwarenessContext.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DPI_AWARENESS GetAwarenessFromDpiAwarenessContext(DPI_AWARENESS_CONTEXT value)
     * }
     */
    public static MethodHandle GetAwarenessFromDpiAwarenessContext$handle() {
        return GetAwarenessFromDpiAwarenessContext.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * DPI_AWARENESS GetAwarenessFromDpiAwarenessContext(DPI_AWARENESS_CONTEXT value)
     * }
     */
    public static int GetAwarenessFromDpiAwarenessContext(MemorySegment value) {
        var mh$ = GetAwarenessFromDpiAwarenessContext.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetAwarenessFromDpiAwarenessContext", value);
            }
            return (int)mh$.invokeExact(value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetDpiFromDpiAwarenessContext {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetDpiFromDpiAwarenessContext"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * UINT GetDpiFromDpiAwarenessContext(DPI_AWARENESS_CONTEXT value)
     * }
     */
    public static FunctionDescriptor GetDpiFromDpiAwarenessContext$descriptor() {
        return GetDpiFromDpiAwarenessContext.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * UINT GetDpiFromDpiAwarenessContext(DPI_AWARENESS_CONTEXT value)
     * }
     */
    public static MethodHandle GetDpiFromDpiAwarenessContext$handle() {
        return GetDpiFromDpiAwarenessContext.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * UINT GetDpiFromDpiAwarenessContext(DPI_AWARENESS_CONTEXT value)
     * }
     */
    public static int GetDpiFromDpiAwarenessContext(MemorySegment value) {
        var mh$ = GetDpiFromDpiAwarenessContext.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetDpiFromDpiAwarenessContext", value);
            }
            return (int)mh$.invokeExact(value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class AreDpiAwarenessContextsEqual {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("AreDpiAwarenessContextsEqual"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL AreDpiAwarenessContextsEqual(DPI_AWARENESS_CONTEXT dpiContextA, DPI_AWARENESS_CONTEXT dpiContextB)
     * }
     */
    public static FunctionDescriptor AreDpiAwarenessContextsEqual$descriptor() {
        return AreDpiAwarenessContextsEqual.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL AreDpiAwarenessContextsEqual(DPI_AWARENESS_CONTEXT dpiContextA, DPI_AWARENESS_CONTEXT dpiContextB)
     * }
     */
    public static MethodHandle AreDpiAwarenessContextsEqual$handle() {
        return AreDpiAwarenessContextsEqual.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL AreDpiAwarenessContextsEqual(DPI_AWARENESS_CONTEXT dpiContextA, DPI_AWARENESS_CONTEXT dpiContextB)
     * }
     */
    public static int AreDpiAwarenessContextsEqual(MemorySegment dpiContextA, MemorySegment dpiContextB) {
        var mh$ = AreDpiAwarenessContextsEqual.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("AreDpiAwarenessContextsEqual", dpiContextA, dpiContextB);
            }
            return (int)mh$.invokeExact(dpiContextA, dpiContextB);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class IsValidDpiAwarenessContext {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("IsValidDpiAwarenessContext"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL IsValidDpiAwarenessContext(DPI_AWARENESS_CONTEXT value)
     * }
     */
    public static FunctionDescriptor IsValidDpiAwarenessContext$descriptor() {
        return IsValidDpiAwarenessContext.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL IsValidDpiAwarenessContext(DPI_AWARENESS_CONTEXT value)
     * }
     */
    public static MethodHandle IsValidDpiAwarenessContext$handle() {
        return IsValidDpiAwarenessContext.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL IsValidDpiAwarenessContext(DPI_AWARENESS_CONTEXT value)
     * }
     */
    public static int IsValidDpiAwarenessContext(MemorySegment value) {
        var mh$ = IsValidDpiAwarenessContext.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("IsValidDpiAwarenessContext", value);
            }
            return (int)mh$.invokeExact(value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetDpiForWindow {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetDpiForWindow"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * UINT GetDpiForWindow(HWND hwnd)
     * }
     */
    public static FunctionDescriptor GetDpiForWindow$descriptor() {
        return GetDpiForWindow.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * UINT GetDpiForWindow(HWND hwnd)
     * }
     */
    public static MethodHandle GetDpiForWindow$handle() {
        return GetDpiForWindow.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * UINT GetDpiForWindow(HWND hwnd)
     * }
     */
    public static int GetDpiForWindow(MemorySegment hwnd) {
        var mh$ = GetDpiForWindow.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetDpiForWindow", hwnd);
            }
            return (int)mh$.invokeExact(hwnd);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetDpiForSystem {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT    );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetDpiForSystem"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * UINT GetDpiForSystem()
     * }
     */
    public static FunctionDescriptor GetDpiForSystem$descriptor() {
        return GetDpiForSystem.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * UINT GetDpiForSystem()
     * }
     */
    public static MethodHandle GetDpiForSystem$handle() {
        return GetDpiForSystem.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * UINT GetDpiForSystem()
     * }
     */
    public static int GetDpiForSystem() {
        var mh$ = GetDpiForSystem.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetDpiForSystem");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetSystemDpiForProcess {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetSystemDpiForProcess"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * UINT GetSystemDpiForProcess(HANDLE hProcess)
     * }
     */
    public static FunctionDescriptor GetSystemDpiForProcess$descriptor() {
        return GetSystemDpiForProcess.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * UINT GetSystemDpiForProcess(HANDLE hProcess)
     * }
     */
    public static MethodHandle GetSystemDpiForProcess$handle() {
        return GetSystemDpiForProcess.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * UINT GetSystemDpiForProcess(HANDLE hProcess)
     * }
     */
    public static int GetSystemDpiForProcess(MemorySegment hProcess) {
        var mh$ = GetSystemDpiForProcess.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetSystemDpiForProcess", hProcess);
            }
            return (int)mh$.invokeExact(hProcess);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class EnableNonClientDpiScaling {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("EnableNonClientDpiScaling"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL EnableNonClientDpiScaling(HWND hwnd)
     * }
     */
    public static FunctionDescriptor EnableNonClientDpiScaling$descriptor() {
        return EnableNonClientDpiScaling.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL EnableNonClientDpiScaling(HWND hwnd)
     * }
     */
    public static MethodHandle EnableNonClientDpiScaling$handle() {
        return EnableNonClientDpiScaling.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL EnableNonClientDpiScaling(HWND hwnd)
     * }
     */
    public static int EnableNonClientDpiScaling(MemorySegment hwnd) {
        var mh$ = EnableNonClientDpiScaling.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("EnableNonClientDpiScaling", hwnd);
            }
            return (int)mh$.invokeExact(hwnd);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class InheritWindowMonitor {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("InheritWindowMonitor"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL InheritWindowMonitor(HWND hwnd, HWND hwndInherit)
     * }
     */
    public static FunctionDescriptor InheritWindowMonitor$descriptor() {
        return InheritWindowMonitor.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL InheritWindowMonitor(HWND hwnd, HWND hwndInherit)
     * }
     */
    public static MethodHandle InheritWindowMonitor$handle() {
        return InheritWindowMonitor.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL InheritWindowMonitor(HWND hwnd, HWND hwndInherit)
     * }
     */
    public static int InheritWindowMonitor(MemorySegment hwnd, MemorySegment hwndInherit) {
        var mh$ = InheritWindowMonitor.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("InheritWindowMonitor", hwnd, hwndInherit);
            }
            return (int)mh$.invokeExact(hwnd, hwndInherit);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetProcessDpiAwarenessContext {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("SetProcessDpiAwarenessContext"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetProcessDpiAwarenessContext(DPI_AWARENESS_CONTEXT value)
     * }
     */
    public static FunctionDescriptor SetProcessDpiAwarenessContext$descriptor() {
        return SetProcessDpiAwarenessContext.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetProcessDpiAwarenessContext(DPI_AWARENESS_CONTEXT value)
     * }
     */
    public static MethodHandle SetProcessDpiAwarenessContext$handle() {
        return SetProcessDpiAwarenessContext.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL SetProcessDpiAwarenessContext(DPI_AWARENESS_CONTEXT value)
     * }
     */
    public static int SetProcessDpiAwarenessContext(MemorySegment value) {
        var mh$ = SetProcessDpiAwarenessContext.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetProcessDpiAwarenessContext", value);
            }
            return (int)mh$.invokeExact(value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetDpiAwarenessContextForProcess {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetDpiAwarenessContextForProcess"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DPI_AWARENESS_CONTEXT GetDpiAwarenessContextForProcess(HANDLE hProcess)
     * }
     */
    public static FunctionDescriptor GetDpiAwarenessContextForProcess$descriptor() {
        return GetDpiAwarenessContextForProcess.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DPI_AWARENESS_CONTEXT GetDpiAwarenessContextForProcess(HANDLE hProcess)
     * }
     */
    public static MethodHandle GetDpiAwarenessContextForProcess$handle() {
        return GetDpiAwarenessContextForProcess.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * DPI_AWARENESS_CONTEXT GetDpiAwarenessContextForProcess(HANDLE hProcess)
     * }
     */
    public static MemorySegment GetDpiAwarenessContextForProcess(MemorySegment hProcess) {
        var mh$ = GetDpiAwarenessContextForProcess.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetDpiAwarenessContextForProcess", hProcess);
            }
            return (MemorySegment)mh$.invokeExact(hProcess);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetThreadDpiHostingBehavior {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("SetThreadDpiHostingBehavior"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DPI_HOSTING_BEHAVIOR SetThreadDpiHostingBehavior(DPI_HOSTING_BEHAVIOR value)
     * }
     */
    public static FunctionDescriptor SetThreadDpiHostingBehavior$descriptor() {
        return SetThreadDpiHostingBehavior.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DPI_HOSTING_BEHAVIOR SetThreadDpiHostingBehavior(DPI_HOSTING_BEHAVIOR value)
     * }
     */
    public static MethodHandle SetThreadDpiHostingBehavior$handle() {
        return SetThreadDpiHostingBehavior.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * DPI_HOSTING_BEHAVIOR SetThreadDpiHostingBehavior(DPI_HOSTING_BEHAVIOR value)
     * }
     */
    public static int SetThreadDpiHostingBehavior(int value) {
        var mh$ = SetThreadDpiHostingBehavior.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetThreadDpiHostingBehavior", value);
            }
            return (int)mh$.invokeExact(value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetThreadDpiHostingBehavior {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT    );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetThreadDpiHostingBehavior"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DPI_HOSTING_BEHAVIOR GetThreadDpiHostingBehavior()
     * }
     */
    public static FunctionDescriptor GetThreadDpiHostingBehavior$descriptor() {
        return GetThreadDpiHostingBehavior.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DPI_HOSTING_BEHAVIOR GetThreadDpiHostingBehavior()
     * }
     */
    public static MethodHandle GetThreadDpiHostingBehavior$handle() {
        return GetThreadDpiHostingBehavior.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * DPI_HOSTING_BEHAVIOR GetThreadDpiHostingBehavior()
     * }
     */
    public static int GetThreadDpiHostingBehavior() {
        var mh$ = GetThreadDpiHostingBehavior.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetThreadDpiHostingBehavior");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetWindowDpiHostingBehavior {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetWindowDpiHostingBehavior"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DPI_HOSTING_BEHAVIOR GetWindowDpiHostingBehavior(HWND hwnd)
     * }
     */
    public static FunctionDescriptor GetWindowDpiHostingBehavior$descriptor() {
        return GetWindowDpiHostingBehavior.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DPI_HOSTING_BEHAVIOR GetWindowDpiHostingBehavior(HWND hwnd)
     * }
     */
    public static MethodHandle GetWindowDpiHostingBehavior$handle() {
        return GetWindowDpiHostingBehavior.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * DPI_HOSTING_BEHAVIOR GetWindowDpiHostingBehavior(HWND hwnd)
     * }
     */
    public static int GetWindowDpiHostingBehavior(MemorySegment hwnd) {
        var mh$ = GetWindowDpiHostingBehavior.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetWindowDpiHostingBehavior", hwnd);
            }
            return (int)mh$.invokeExact(hwnd);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetWindowModuleFileNameA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetWindowModuleFileNameA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * UINT GetWindowModuleFileNameA(HWND hwnd, LPSTR pszFileName, UINT cchFileNameMax)
     * }
     */
    public static FunctionDescriptor GetWindowModuleFileNameA$descriptor() {
        return GetWindowModuleFileNameA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * UINT GetWindowModuleFileNameA(HWND hwnd, LPSTR pszFileName, UINT cchFileNameMax)
     * }
     */
    public static MethodHandle GetWindowModuleFileNameA$handle() {
        return GetWindowModuleFileNameA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * UINT GetWindowModuleFileNameA(HWND hwnd, LPSTR pszFileName, UINT cchFileNameMax)
     * }
     */
    public static int GetWindowModuleFileNameA(MemorySegment hwnd, MemorySegment pszFileName, int cchFileNameMax) {
        var mh$ = GetWindowModuleFileNameA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetWindowModuleFileNameA", hwnd, pszFileName, cchFileNameMax);
            }
            return (int)mh$.invokeExact(hwnd, pszFileName, cchFileNameMax);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetWindowModuleFileNameW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetWindowModuleFileNameW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * UINT GetWindowModuleFileNameW(HWND hwnd, LPWSTR pszFileName, UINT cchFileNameMax)
     * }
     */
    public static FunctionDescriptor GetWindowModuleFileNameW$descriptor() {
        return GetWindowModuleFileNameW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * UINT GetWindowModuleFileNameW(HWND hwnd, LPWSTR pszFileName, UINT cchFileNameMax)
     * }
     */
    public static MethodHandle GetWindowModuleFileNameW$handle() {
        return GetWindowModuleFileNameW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * UINT GetWindowModuleFileNameW(HWND hwnd, LPWSTR pszFileName, UINT cchFileNameMax)
     * }
     */
    public static int GetWindowModuleFileNameW(MemorySegment hwnd, MemorySegment pszFileName, int cchFileNameMax) {
        var mh$ = GetWindowModuleFileNameW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetWindowModuleFileNameW", hwnd, pszFileName, cchFileNameMax);
            }
            return (int)mh$.invokeExact(hwnd, pszFileName, cchFileNameMax);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct tagCURSORINFO {
     *     DWORD cbSize;
     *     DWORD flags;
     *     HCURSOR hCursor;
     *     POINT ptScreenPos;
     * } *PCURSORINFO
     * }
     */
    public static final AddressLayout PCURSORINFO = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagCURSORINFO {
     *     DWORD cbSize;
     *     DWORD flags;
     *     HCURSOR hCursor;
     *     POINT ptScreenPos;
     * } *LPCURSORINFO
     * }
     */
    public static final AddressLayout LPCURSORINFO = C_POINTER;

    private static class GetCursorInfo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetCursorInfo"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetCursorInfo(PCURSORINFO pci)
     * }
     */
    public static FunctionDescriptor GetCursorInfo$descriptor() {
        return GetCursorInfo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetCursorInfo(PCURSORINFO pci)
     * }
     */
    public static MethodHandle GetCursorInfo$handle() {
        return GetCursorInfo.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL GetCursorInfo(PCURSORINFO pci)
     * }
     */
    public static int GetCursorInfo(MemorySegment pci) {
        var mh$ = GetCursorInfo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetCursorInfo", pci);
            }
            return (int)mh$.invokeExact(pci);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct tagWINDOWINFO {
     *     DWORD cbSize;
     *     RECT rcWindow;
     *     RECT rcClient;
     *     DWORD dwStyle;
     *     DWORD dwExStyle;
     *     DWORD dwWindowStatus;
     *     UINT cxWindowBorders;
     *     UINT cyWindowBorders;
     *     ATOM atomWindowType;
     *     WORD wCreatorVersion;
     * } *PWINDOWINFO
     * }
     */
    public static final AddressLayout PWINDOWINFO = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagWINDOWINFO {
     *     DWORD cbSize;
     *     RECT rcWindow;
     *     RECT rcClient;
     *     DWORD dwStyle;
     *     DWORD dwExStyle;
     *     DWORD dwWindowStatus;
     *     UINT cxWindowBorders;
     *     UINT cyWindowBorders;
     *     ATOM atomWindowType;
     *     WORD wCreatorVersion;
     * } *LPWINDOWINFO
     * }
     */
    public static final AddressLayout LPWINDOWINFO = C_POINTER;

    private static class GetWindowInfo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetWindowInfo"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetWindowInfo(HWND hwnd, PWINDOWINFO pwi)
     * }
     */
    public static FunctionDescriptor GetWindowInfo$descriptor() {
        return GetWindowInfo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetWindowInfo(HWND hwnd, PWINDOWINFO pwi)
     * }
     */
    public static MethodHandle GetWindowInfo$handle() {
        return GetWindowInfo.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL GetWindowInfo(HWND hwnd, PWINDOWINFO pwi)
     * }
     */
    public static int GetWindowInfo(MemorySegment hwnd, MemorySegment pwi) {
        var mh$ = GetWindowInfo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetWindowInfo", hwnd, pwi);
            }
            return (int)mh$.invokeExact(hwnd, pwi);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct tagTITLEBARINFO {
     *     DWORD cbSize;
     *     RECT rcTitleBar;
     *     DWORD rgstate[6];
     * } *PTITLEBARINFO
     * }
     */
    public static final AddressLayout PTITLEBARINFO = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagTITLEBARINFO {
     *     DWORD cbSize;
     *     RECT rcTitleBar;
     *     DWORD rgstate[6];
     * } *LPTITLEBARINFO
     * }
     */
    public static final AddressLayout LPTITLEBARINFO = C_POINTER;

    private static class GetTitleBarInfo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetTitleBarInfo"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetTitleBarInfo(HWND hwnd, PTITLEBARINFO pti)
     * }
     */
    public static FunctionDescriptor GetTitleBarInfo$descriptor() {
        return GetTitleBarInfo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetTitleBarInfo(HWND hwnd, PTITLEBARINFO pti)
     * }
     */
    public static MethodHandle GetTitleBarInfo$handle() {
        return GetTitleBarInfo.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL GetTitleBarInfo(HWND hwnd, PTITLEBARINFO pti)
     * }
     */
    public static int GetTitleBarInfo(MemorySegment hwnd, MemorySegment pti) {
        var mh$ = GetTitleBarInfo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetTitleBarInfo", hwnd, pti);
            }
            return (int)mh$.invokeExact(hwnd, pti);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct tagTITLEBARINFOEX {
     *     DWORD cbSize;
     *     RECT rcTitleBar;
     *     DWORD rgstate[6];
     *     RECT rgrect[6];
     * } *PTITLEBARINFOEX
     * }
     */
    public static final AddressLayout PTITLEBARINFOEX = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagTITLEBARINFOEX {
     *     DWORD cbSize;
     *     RECT rcTitleBar;
     *     DWORD rgstate[6];
     *     RECT rgrect[6];
     * } *LPTITLEBARINFOEX
     * }
     */
    public static final AddressLayout LPTITLEBARINFOEX = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagMENUBARINFO {
     *     DWORD cbSize;
     *     RECT rcBar;
     *     HMENU hMenu;
     *     HWND hwndMenu;
     *     BOOL fBarFocused : 1;
     *     BOOL fFocused : 1;
     *     BOOL fUnused : 30;
     * } *PMENUBARINFO
     * }
     */
    public static final AddressLayout PMENUBARINFO = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagMENUBARINFO {
     *     DWORD cbSize;
     *     RECT rcBar;
     *     HMENU hMenu;
     *     HWND hwndMenu;
     *     BOOL fBarFocused : 1;
     *     BOOL fFocused : 1;
     *     BOOL fUnused : 30;
     * } *LPMENUBARINFO
     * }
     */
    public static final AddressLayout LPMENUBARINFO = C_POINTER;

    private static class GetMenuBarInfo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_LONG,
            C_LONG,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetMenuBarInfo"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetMenuBarInfo(HWND hwnd, LONG idObject, LONG idItem, PMENUBARINFO pmbi)
     * }
     */
    public static FunctionDescriptor GetMenuBarInfo$descriptor() {
        return GetMenuBarInfo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetMenuBarInfo(HWND hwnd, LONG idObject, LONG idItem, PMENUBARINFO pmbi)
     * }
     */
    public static MethodHandle GetMenuBarInfo$handle() {
        return GetMenuBarInfo.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL GetMenuBarInfo(HWND hwnd, LONG idObject, LONG idItem, PMENUBARINFO pmbi)
     * }
     */
    public static int GetMenuBarInfo(MemorySegment hwnd, int idObject, int idItem, MemorySegment pmbi) {
        var mh$ = GetMenuBarInfo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetMenuBarInfo", hwnd, idObject, idItem, pmbi);
            }
            return (int)mh$.invokeExact(hwnd, idObject, idItem, pmbi);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct tagSCROLLBARINFO {
     *     DWORD cbSize;
     *     RECT rcScrollBar;
     *     int dxyLineButton;
     *     int xyThumbTop;
     *     int xyThumbBottom;
     *     int reserved;
     *     DWORD rgstate[6];
     * } *PSCROLLBARINFO
     * }
     */
    public static final AddressLayout PSCROLLBARINFO = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagSCROLLBARINFO {
     *     DWORD cbSize;
     *     RECT rcScrollBar;
     *     int dxyLineButton;
     *     int xyThumbTop;
     *     int xyThumbBottom;
     *     int reserved;
     *     DWORD rgstate[6];
     * } *LPSCROLLBARINFO
     * }
     */
    public static final AddressLayout LPSCROLLBARINFO = C_POINTER;

    private static class GetScrollBarInfo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_LONG,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetScrollBarInfo"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetScrollBarInfo(HWND hwnd, LONG idObject, PSCROLLBARINFO psbi)
     * }
     */
    public static FunctionDescriptor GetScrollBarInfo$descriptor() {
        return GetScrollBarInfo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetScrollBarInfo(HWND hwnd, LONG idObject, PSCROLLBARINFO psbi)
     * }
     */
    public static MethodHandle GetScrollBarInfo$handle() {
        return GetScrollBarInfo.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL GetScrollBarInfo(HWND hwnd, LONG idObject, PSCROLLBARINFO psbi)
     * }
     */
    public static int GetScrollBarInfo(MemorySegment hwnd, int idObject, MemorySegment psbi) {
        var mh$ = GetScrollBarInfo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetScrollBarInfo", hwnd, idObject, psbi);
            }
            return (int)mh$.invokeExact(hwnd, idObject, psbi);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct tagCOMBOBOXINFO {
     *     DWORD cbSize;
     *     RECT rcItem;
     *     RECT rcButton;
     *     DWORD stateButton;
     *     HWND hwndCombo;
     *     HWND hwndItem;
     *     HWND hwndList;
     * } *PCOMBOBOXINFO
     * }
     */
    public static final AddressLayout PCOMBOBOXINFO = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagCOMBOBOXINFO {
     *     DWORD cbSize;
     *     RECT rcItem;
     *     RECT rcButton;
     *     DWORD stateButton;
     *     HWND hwndCombo;
     *     HWND hwndItem;
     *     HWND hwndList;
     * } *LPCOMBOBOXINFO
     * }
     */
    public static final AddressLayout LPCOMBOBOXINFO = C_POINTER;

    private static class GetComboBoxInfo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetComboBoxInfo"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetComboBoxInfo(HWND hwndCombo, PCOMBOBOXINFO pcbi)
     * }
     */
    public static FunctionDescriptor GetComboBoxInfo$descriptor() {
        return GetComboBoxInfo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetComboBoxInfo(HWND hwndCombo, PCOMBOBOXINFO pcbi)
     * }
     */
    public static MethodHandle GetComboBoxInfo$handle() {
        return GetComboBoxInfo.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL GetComboBoxInfo(HWND hwndCombo, PCOMBOBOXINFO pcbi)
     * }
     */
    public static int GetComboBoxInfo(MemorySegment hwndCombo, MemorySegment pcbi) {
        var mh$ = GetComboBoxInfo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetComboBoxInfo", hwndCombo, pcbi);
            }
            return (int)mh$.invokeExact(hwndCombo, pcbi);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetAncestor {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetAncestor"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HWND GetAncestor(HWND hwnd, UINT gaFlags)
     * }
     */
    public static FunctionDescriptor GetAncestor$descriptor() {
        return GetAncestor.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HWND GetAncestor(HWND hwnd, UINT gaFlags)
     * }
     */
    public static MethodHandle GetAncestor$handle() {
        return GetAncestor.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * HWND GetAncestor(HWND hwnd, UINT gaFlags)
     * }
     */
    public static MemorySegment GetAncestor(MemorySegment hwnd, int gaFlags) {
        var mh$ = GetAncestor.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetAncestor", hwnd, gaFlags);
            }
            return (MemorySegment)mh$.invokeExact(hwnd, gaFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RealChildWindowFromPoint {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER,
            tagPOINT.layout()
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("RealChildWindowFromPoint"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HWND RealChildWindowFromPoint(HWND hwndParent, POINT ptParentClientCoords)
     * }
     */
    public static FunctionDescriptor RealChildWindowFromPoint$descriptor() {
        return RealChildWindowFromPoint.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HWND RealChildWindowFromPoint(HWND hwndParent, POINT ptParentClientCoords)
     * }
     */
    public static MethodHandle RealChildWindowFromPoint$handle() {
        return RealChildWindowFromPoint.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * HWND RealChildWindowFromPoint(HWND hwndParent, POINT ptParentClientCoords)
     * }
     */
    public static MemorySegment RealChildWindowFromPoint(MemorySegment hwndParent, MemorySegment ptParentClientCoords) {
        var mh$ = RealChildWindowFromPoint.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RealChildWindowFromPoint", hwndParent, ptParentClientCoords);
            }
            return (MemorySegment)mh$.invokeExact(hwndParent, ptParentClientCoords);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RealGetWindowClassA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("RealGetWindowClassA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * UINT RealGetWindowClassA(HWND hwnd, LPSTR ptszClassName, UINT cchClassNameMax)
     * }
     */
    public static FunctionDescriptor RealGetWindowClassA$descriptor() {
        return RealGetWindowClassA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * UINT RealGetWindowClassA(HWND hwnd, LPSTR ptszClassName, UINT cchClassNameMax)
     * }
     */
    public static MethodHandle RealGetWindowClassA$handle() {
        return RealGetWindowClassA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * UINT RealGetWindowClassA(HWND hwnd, LPSTR ptszClassName, UINT cchClassNameMax)
     * }
     */
    public static int RealGetWindowClassA(MemorySegment hwnd, MemorySegment ptszClassName, int cchClassNameMax) {
        var mh$ = RealGetWindowClassA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RealGetWindowClassA", hwnd, ptszClassName, cchClassNameMax);
            }
            return (int)mh$.invokeExact(hwnd, ptszClassName, cchClassNameMax);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RealGetWindowClassW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("RealGetWindowClassW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * UINT RealGetWindowClassW(HWND hwnd, LPWSTR ptszClassName, UINT cchClassNameMax)
     * }
     */
    public static FunctionDescriptor RealGetWindowClassW$descriptor() {
        return RealGetWindowClassW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * UINT RealGetWindowClassW(HWND hwnd, LPWSTR ptszClassName, UINT cchClassNameMax)
     * }
     */
    public static MethodHandle RealGetWindowClassW$handle() {
        return RealGetWindowClassW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * UINT RealGetWindowClassW(HWND hwnd, LPWSTR ptszClassName, UINT cchClassNameMax)
     * }
     */
    public static int RealGetWindowClassW(MemorySegment hwnd, MemorySegment ptszClassName, int cchClassNameMax) {
        var mh$ = RealGetWindowClassW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RealGetWindowClassW", hwnd, ptszClassName, cchClassNameMax);
            }
            return (int)mh$.invokeExact(hwnd, ptszClassName, cchClassNameMax);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct tagALTTABINFO {
     *     DWORD cbSize;
     *     int cItems;
     *     int cColumns;
     *     int cRows;
     *     int iColFocus;
     *     int iRowFocus;
     *     int cxItem;
     *     int cyItem;
     *     POINT ptStart;
     * } *PALTTABINFO
     * }
     */
    public static final AddressLayout PALTTABINFO = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagALTTABINFO {
     *     DWORD cbSize;
     *     int cItems;
     *     int cColumns;
     *     int cRows;
     *     int iColFocus;
     *     int iRowFocus;
     *     int cxItem;
     *     int cyItem;
     *     POINT ptStart;
     * } *LPALTTABINFO
     * }
     */
    public static final AddressLayout LPALTTABINFO = C_POINTER;

    private static class GetAltTabInfoA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_INT,
            C_POINTER,
            C_POINTER,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetAltTabInfoA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetAltTabInfoA(HWND hwnd, int iItem, PALTTABINFO pati, LPSTR pszItemText, UINT cchItemText)
     * }
     */
    public static FunctionDescriptor GetAltTabInfoA$descriptor() {
        return GetAltTabInfoA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetAltTabInfoA(HWND hwnd, int iItem, PALTTABINFO pati, LPSTR pszItemText, UINT cchItemText)
     * }
     */
    public static MethodHandle GetAltTabInfoA$handle() {
        return GetAltTabInfoA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL GetAltTabInfoA(HWND hwnd, int iItem, PALTTABINFO pati, LPSTR pszItemText, UINT cchItemText)
     * }
     */
    public static int GetAltTabInfoA(MemorySegment hwnd, int iItem, MemorySegment pati, MemorySegment pszItemText, int cchItemText) {
        var mh$ = GetAltTabInfoA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetAltTabInfoA", hwnd, iItem, pati, pszItemText, cchItemText);
            }
            return (int)mh$.invokeExact(hwnd, iItem, pati, pszItemText, cchItemText);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetAltTabInfoW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_INT,
            C_POINTER,
            C_POINTER,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetAltTabInfoW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetAltTabInfoW(HWND hwnd, int iItem, PALTTABINFO pati, LPWSTR pszItemText, UINT cchItemText)
     * }
     */
    public static FunctionDescriptor GetAltTabInfoW$descriptor() {
        return GetAltTabInfoW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetAltTabInfoW(HWND hwnd, int iItem, PALTTABINFO pati, LPWSTR pszItemText, UINT cchItemText)
     * }
     */
    public static MethodHandle GetAltTabInfoW$handle() {
        return GetAltTabInfoW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL GetAltTabInfoW(HWND hwnd, int iItem, PALTTABINFO pati, LPWSTR pszItemText, UINT cchItemText)
     * }
     */
    public static int GetAltTabInfoW(MemorySegment hwnd, int iItem, MemorySegment pati, MemorySegment pszItemText, int cchItemText) {
        var mh$ = GetAltTabInfoW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetAltTabInfoW", hwnd, iItem, pati, pszItemText, cchItemText);
            }
            return (int)mh$.invokeExact(hwnd, iItem, pati, pszItemText, cchItemText);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetListBoxInfo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetListBoxInfo"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetListBoxInfo(HWND hwnd)
     * }
     */
    public static FunctionDescriptor GetListBoxInfo$descriptor() {
        return GetListBoxInfo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetListBoxInfo(HWND hwnd)
     * }
     */
    public static MethodHandle GetListBoxInfo$handle() {
        return GetListBoxInfo.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * DWORD GetListBoxInfo(HWND hwnd)
     * }
     */
    public static int GetListBoxInfo(MemorySegment hwnd) {
        var mh$ = GetListBoxInfo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetListBoxInfo", hwnd);
            }
            return (int)mh$.invokeExact(hwnd);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LockWorkStation {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT    );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("LockWorkStation"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL LockWorkStation()
     * }
     */
    public static FunctionDescriptor LockWorkStation$descriptor() {
        return LockWorkStation.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL LockWorkStation()
     * }
     */
    public static MethodHandle LockWorkStation$handle() {
        return LockWorkStation.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL LockWorkStation()
     * }
     */
    public static int LockWorkStation() {
        var mh$ = LockWorkStation.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LockWorkStation");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class UserHandleGrantAccess {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("UserHandleGrantAccess"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL UserHandleGrantAccess(HANDLE hUserHandle, HANDLE hJob, BOOL bGrant)
     * }
     */
    public static FunctionDescriptor UserHandleGrantAccess$descriptor() {
        return UserHandleGrantAccess.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL UserHandleGrantAccess(HANDLE hUserHandle, HANDLE hJob, BOOL bGrant)
     * }
     */
    public static MethodHandle UserHandleGrantAccess$handle() {
        return UserHandleGrantAccess.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL UserHandleGrantAccess(HANDLE hUserHandle, HANDLE hJob, BOOL bGrant)
     * }
     */
    public static int UserHandleGrantAccess(MemorySegment hUserHandle, MemorySegment hJob, int bGrant) {
        var mh$ = UserHandleGrantAccess.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("UserHandleGrantAccess", hUserHandle, hJob, bGrant);
            }
            return (int)mh$.invokeExact(hUserHandle, hJob, bGrant);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct HRAWINPUT__ {
     *     int unused;
     * } *HRAWINPUT
     * }
     */
    public static final AddressLayout HRAWINPUT = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagRAWINPUTHEADER {
     *     DWORD dwType;
     *     DWORD dwSize;
     *     HANDLE hDevice;
     *     WPARAM wParam;
     * } *PRAWINPUTHEADER
     * }
     */
    public static final AddressLayout PRAWINPUTHEADER = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagRAWINPUTHEADER {
     *     DWORD dwType;
     *     DWORD dwSize;
     *     HANDLE hDevice;
     *     WPARAM wParam;
     * } *LPRAWINPUTHEADER
     * }
     */
    public static final AddressLayout LPRAWINPUTHEADER = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagRAWMOUSE {
     *     USHORT usFlags;
     *     union {
     *         ULONG ulButtons;
     *         struct {
     *             USHORT usButtonFlags;
     *             USHORT usButtonData;
     *         };
     *     };
     *     ULONG ulRawButtons;
     *     LONG lLastX;
     *     LONG lLastY;
     *     ULONG ulExtraInformation;
     * } *PRAWMOUSE
     * }
     */
    public static final AddressLayout PRAWMOUSE = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagRAWMOUSE {
     *     USHORT usFlags;
     *     union {
     *         ULONG ulButtons;
     *         struct {
     *             USHORT usButtonFlags;
     *             USHORT usButtonData;
     *         };
     *     };
     *     ULONG ulRawButtons;
     *     LONG lLastX;
     *     LONG lLastY;
     *     ULONG ulExtraInformation;
     * } *LPRAWMOUSE
     * }
     */
    public static final AddressLayout LPRAWMOUSE = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagRAWKEYBOARD {
     *     USHORT MakeCode;
     *     USHORT Flags;
     *     USHORT Reserved;
     *     USHORT VKey;
     *     UINT Message;
     *     ULONG ExtraInformation;
     * } *PRAWKEYBOARD
     * }
     */
    public static final AddressLayout PRAWKEYBOARD = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagRAWKEYBOARD {
     *     USHORT MakeCode;
     *     USHORT Flags;
     *     USHORT Reserved;
     *     USHORT VKey;
     *     UINT Message;
     *     ULONG ExtraInformation;
     * } *LPRAWKEYBOARD
     * }
     */
    public static final AddressLayout LPRAWKEYBOARD = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagRAWHID {
     *     DWORD dwSizeHid;
     *     DWORD dwCount;
     *     BYTE bRawData[1];
     * } *PRAWHID
     * }
     */
    public static final AddressLayout PRAWHID = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagRAWHID {
     *     DWORD dwSizeHid;
     *     DWORD dwCount;
     *     BYTE bRawData[1];
     * } *LPRAWHID
     * }
     */
    public static final AddressLayout LPRAWHID = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagRAWINPUT {
     *     RAWINPUTHEADER header;
     *     union {
     *         RAWMOUSE mouse;
     *         RAWKEYBOARD keyboard;
     *         RAWHID hid;
     *     } data;
     * } *PRAWINPUT
     * }
     */
    public static final AddressLayout PRAWINPUT = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagRAWINPUT {
     *     RAWINPUTHEADER header;
     *     union {
     *         RAWMOUSE mouse;
     *         RAWKEYBOARD keyboard;
     *         RAWHID hid;
     *     } data;
     * } *LPRAWINPUT
     * }
     */
    public static final AddressLayout LPRAWINPUT = C_POINTER;

    private static class GetRawInputData {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_INT,
            C_POINTER,
            C_POINTER,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetRawInputData"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * UINT GetRawInputData(HRAWINPUT hRawInput, UINT uiCommand, LPVOID pData, PUINT pcbSize, UINT cbSizeHeader)
     * }
     */
    public static FunctionDescriptor GetRawInputData$descriptor() {
        return GetRawInputData.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * UINT GetRawInputData(HRAWINPUT hRawInput, UINT uiCommand, LPVOID pData, PUINT pcbSize, UINT cbSizeHeader)
     * }
     */
    public static MethodHandle GetRawInputData$handle() {
        return GetRawInputData.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * UINT GetRawInputData(HRAWINPUT hRawInput, UINT uiCommand, LPVOID pData, PUINT pcbSize, UINT cbSizeHeader)
     * }
     */
    public static int GetRawInputData(MemorySegment hRawInput, int uiCommand, MemorySegment pData, MemorySegment pcbSize, int cbSizeHeader) {
        var mh$ = GetRawInputData.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetRawInputData", hRawInput, uiCommand, pData, pcbSize, cbSizeHeader);
            }
            return (int)mh$.invokeExact(hRawInput, uiCommand, pData, pcbSize, cbSizeHeader);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct tagRID_DEVICE_INFO_MOUSE {
     *     DWORD dwId;
     *     DWORD dwNumberOfButtons;
     *     DWORD dwSampleRate;
     *     BOOL fHasHorizontalWheel;
     * } *PRID_DEVICE_INFO_MOUSE
     * }
     */
    public static final AddressLayout PRID_DEVICE_INFO_MOUSE = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagRID_DEVICE_INFO_KEYBOARD {
     *     DWORD dwType;
     *     DWORD dwSubType;
     *     DWORD dwKeyboardMode;
     *     DWORD dwNumberOfFunctionKeys;
     *     DWORD dwNumberOfIndicators;
     *     DWORD dwNumberOfKeysTotal;
     * } *PRID_DEVICE_INFO_KEYBOARD
     * }
     */
    public static final AddressLayout PRID_DEVICE_INFO_KEYBOARD = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagRID_DEVICE_INFO_HID {
     *     DWORD dwVendorId;
     *     DWORD dwProductId;
     *     DWORD dwVersionNumber;
     *     USHORT usUsagePage;
     *     USHORT usUsage;
     * } *PRID_DEVICE_INFO_HID
     * }
     */
    public static final AddressLayout PRID_DEVICE_INFO_HID = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagRID_DEVICE_INFO {
     *     DWORD cbSize;
     *     DWORD dwType;
     *     union {
     *         RID_DEVICE_INFO_MOUSE mouse;
     *         RID_DEVICE_INFO_KEYBOARD keyboard;
     *         RID_DEVICE_INFO_HID hid;
     *     };
     * } *PRID_DEVICE_INFO
     * }
     */
    public static final AddressLayout PRID_DEVICE_INFO = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagRID_DEVICE_INFO {
     *     DWORD cbSize;
     *     DWORD dwType;
     *     union {
     *         RID_DEVICE_INFO_MOUSE mouse;
     *         RID_DEVICE_INFO_KEYBOARD keyboard;
     *         RID_DEVICE_INFO_HID hid;
     *     };
     * } *LPRID_DEVICE_INFO
     * }
     */
    public static final AddressLayout LPRID_DEVICE_INFO = C_POINTER;

    private static class GetRawInputDeviceInfoA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_INT,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetRawInputDeviceInfoA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * UINT GetRawInputDeviceInfoA(HANDLE hDevice, UINT uiCommand, LPVOID pData, PUINT pcbSize)
     * }
     */
    public static FunctionDescriptor GetRawInputDeviceInfoA$descriptor() {
        return GetRawInputDeviceInfoA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * UINT GetRawInputDeviceInfoA(HANDLE hDevice, UINT uiCommand, LPVOID pData, PUINT pcbSize)
     * }
     */
    public static MethodHandle GetRawInputDeviceInfoA$handle() {
        return GetRawInputDeviceInfoA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * UINT GetRawInputDeviceInfoA(HANDLE hDevice, UINT uiCommand, LPVOID pData, PUINT pcbSize)
     * }
     */
    public static int GetRawInputDeviceInfoA(MemorySegment hDevice, int uiCommand, MemorySegment pData, MemorySegment pcbSize) {
        var mh$ = GetRawInputDeviceInfoA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetRawInputDeviceInfoA", hDevice, uiCommand, pData, pcbSize);
            }
            return (int)mh$.invokeExact(hDevice, uiCommand, pData, pcbSize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetRawInputDeviceInfoW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_INT,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetRawInputDeviceInfoW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * UINT GetRawInputDeviceInfoW(HANDLE hDevice, UINT uiCommand, LPVOID pData, PUINT pcbSize)
     * }
     */
    public static FunctionDescriptor GetRawInputDeviceInfoW$descriptor() {
        return GetRawInputDeviceInfoW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * UINT GetRawInputDeviceInfoW(HANDLE hDevice, UINT uiCommand, LPVOID pData, PUINT pcbSize)
     * }
     */
    public static MethodHandle GetRawInputDeviceInfoW$handle() {
        return GetRawInputDeviceInfoW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * UINT GetRawInputDeviceInfoW(HANDLE hDevice, UINT uiCommand, LPVOID pData, PUINT pcbSize)
     * }
     */
    public static int GetRawInputDeviceInfoW(MemorySegment hDevice, int uiCommand, MemorySegment pData, MemorySegment pcbSize) {
        var mh$ = GetRawInputDeviceInfoW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetRawInputDeviceInfoW", hDevice, uiCommand, pData, pcbSize);
            }
            return (int)mh$.invokeExact(hDevice, uiCommand, pData, pcbSize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetRawInputBuffer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetRawInputBuffer"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * UINT GetRawInputBuffer(PRAWINPUT pData, PUINT pcbSize, UINT cbSizeHeader)
     * }
     */
    public static FunctionDescriptor GetRawInputBuffer$descriptor() {
        return GetRawInputBuffer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * UINT GetRawInputBuffer(PRAWINPUT pData, PUINT pcbSize, UINT cbSizeHeader)
     * }
     */
    public static MethodHandle GetRawInputBuffer$handle() {
        return GetRawInputBuffer.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * UINT GetRawInputBuffer(PRAWINPUT pData, PUINT pcbSize, UINT cbSizeHeader)
     * }
     */
    public static int GetRawInputBuffer(MemorySegment pData, MemorySegment pcbSize, int cbSizeHeader) {
        var mh$ = GetRawInputBuffer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetRawInputBuffer", pData, pcbSize, cbSizeHeader);
            }
            return (int)mh$.invokeExact(pData, pcbSize, cbSizeHeader);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct tagRAWINPUTDEVICE {
     *     USHORT usUsagePage;
     *     USHORT usUsage;
     *     DWORD dwFlags;
     *     HWND hwndTarget;
     * } *PRAWINPUTDEVICE
     * }
     */
    public static final AddressLayout PRAWINPUTDEVICE = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagRAWINPUTDEVICE {
     *     USHORT usUsagePage;
     *     USHORT usUsage;
     *     DWORD dwFlags;
     *     HWND hwndTarget;
     * } *LPRAWINPUTDEVICE
     * }
     */
    public static final AddressLayout LPRAWINPUTDEVICE = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef const RAWINPUTDEVICE *PCRAWINPUTDEVICE
     * }
     */
    public static final AddressLayout PCRAWINPUTDEVICE = C_POINTER;

    private static class RegisterRawInputDevices {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_INT,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("RegisterRawInputDevices"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL RegisterRawInputDevices(PCRAWINPUTDEVICE pRawInputDevices, UINT uiNumDevices, UINT cbSize)
     * }
     */
    public static FunctionDescriptor RegisterRawInputDevices$descriptor() {
        return RegisterRawInputDevices.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL RegisterRawInputDevices(PCRAWINPUTDEVICE pRawInputDevices, UINT uiNumDevices, UINT cbSize)
     * }
     */
    public static MethodHandle RegisterRawInputDevices$handle() {
        return RegisterRawInputDevices.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL RegisterRawInputDevices(PCRAWINPUTDEVICE pRawInputDevices, UINT uiNumDevices, UINT cbSize)
     * }
     */
    public static int RegisterRawInputDevices(MemorySegment pRawInputDevices, int uiNumDevices, int cbSize) {
        var mh$ = RegisterRawInputDevices.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RegisterRawInputDevices", pRawInputDevices, uiNumDevices, cbSize);
            }
            return (int)mh$.invokeExact(pRawInputDevices, uiNumDevices, cbSize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetRegisteredRawInputDevices {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetRegisteredRawInputDevices"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * UINT GetRegisteredRawInputDevices(PRAWINPUTDEVICE pRawInputDevices, PUINT puiNumDevices, UINT cbSize)
     * }
     */
    public static FunctionDescriptor GetRegisteredRawInputDevices$descriptor() {
        return GetRegisteredRawInputDevices.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * UINT GetRegisteredRawInputDevices(PRAWINPUTDEVICE pRawInputDevices, PUINT puiNumDevices, UINT cbSize)
     * }
     */
    public static MethodHandle GetRegisteredRawInputDevices$handle() {
        return GetRegisteredRawInputDevices.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * UINT GetRegisteredRawInputDevices(PRAWINPUTDEVICE pRawInputDevices, PUINT puiNumDevices, UINT cbSize)
     * }
     */
    public static int GetRegisteredRawInputDevices(MemorySegment pRawInputDevices, MemorySegment puiNumDevices, int cbSize) {
        var mh$ = GetRegisteredRawInputDevices.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetRegisteredRawInputDevices", pRawInputDevices, puiNumDevices, cbSize);
            }
            return (int)mh$.invokeExact(pRawInputDevices, puiNumDevices, cbSize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct tagRAWINPUTDEVICELIST {
     *     HANDLE hDevice;
     *     DWORD dwType;
     * } *PRAWINPUTDEVICELIST
     * }
     */
    public static final AddressLayout PRAWINPUTDEVICELIST = C_POINTER;

    private static class GetRawInputDeviceList {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetRawInputDeviceList"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * UINT GetRawInputDeviceList(PRAWINPUTDEVICELIST pRawInputDeviceList, PUINT puiNumDevices, UINT cbSize)
     * }
     */
    public static FunctionDescriptor GetRawInputDeviceList$descriptor() {
        return GetRawInputDeviceList.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * UINT GetRawInputDeviceList(PRAWINPUTDEVICELIST pRawInputDeviceList, PUINT puiNumDevices, UINT cbSize)
     * }
     */
    public static MethodHandle GetRawInputDeviceList$handle() {
        return GetRawInputDeviceList.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * UINT GetRawInputDeviceList(PRAWINPUTDEVICELIST pRawInputDeviceList, PUINT puiNumDevices, UINT cbSize)
     * }
     */
    public static int GetRawInputDeviceList(MemorySegment pRawInputDeviceList, MemorySegment puiNumDevices, int cbSize) {
        var mh$ = GetRawInputDeviceList.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetRawInputDeviceList", pRawInputDeviceList, puiNumDevices, cbSize);
            }
            return (int)mh$.invokeExact(pRawInputDeviceList, puiNumDevices, cbSize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DefRawInputProc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG_LONG,
            C_POINTER,
            C_INT,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("DefRawInputProc"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LRESULT DefRawInputProc(PRAWINPUT *paRawInput, INT nInput, UINT cbSizeHeader)
     * }
     */
    public static FunctionDescriptor DefRawInputProc$descriptor() {
        return DefRawInputProc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LRESULT DefRawInputProc(PRAWINPUT *paRawInput, INT nInput, UINT cbSizeHeader)
     * }
     */
    public static MethodHandle DefRawInputProc$handle() {
        return DefRawInputProc.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * LRESULT DefRawInputProc(PRAWINPUT *paRawInput, INT nInput, UINT cbSizeHeader)
     * }
     */
    public static long DefRawInputProc(MemorySegment paRawInput, int nInput, int cbSizeHeader) {
        var mh$ = DefRawInputProc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DefRawInputProc", paRawInput, nInput, cbSizeHeader);
            }
            return (long)mh$.invokeExact(paRawInput, nInput, cbSizeHeader);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int POINTER_DEVICE_TYPE_INTEGRATED_PEN = (int)1L;
    /**
     * {@snippet lang=c :
     * enum tagPOINTER_DEVICE_TYPE.POINTER_DEVICE_TYPE_INTEGRATED_PEN = 1
     * }
     */
    public static int POINTER_DEVICE_TYPE_INTEGRATED_PEN() {
        return POINTER_DEVICE_TYPE_INTEGRATED_PEN;
    }
    private static final int POINTER_DEVICE_TYPE_EXTERNAL_PEN = (int)2L;
    /**
     * {@snippet lang=c :
     * enum tagPOINTER_DEVICE_TYPE.POINTER_DEVICE_TYPE_EXTERNAL_PEN = 2
     * }
     */
    public static int POINTER_DEVICE_TYPE_EXTERNAL_PEN() {
        return POINTER_DEVICE_TYPE_EXTERNAL_PEN;
    }
    private static final int POINTER_DEVICE_TYPE_TOUCH = (int)3L;
    /**
     * {@snippet lang=c :
     * enum tagPOINTER_DEVICE_TYPE.POINTER_DEVICE_TYPE_TOUCH = 3
     * }
     */
    public static int POINTER_DEVICE_TYPE_TOUCH() {
        return POINTER_DEVICE_TYPE_TOUCH;
    }
    private static final int POINTER_DEVICE_TYPE_TOUCH_PAD = (int)4L;
    /**
     * {@snippet lang=c :
     * enum tagPOINTER_DEVICE_TYPE.POINTER_DEVICE_TYPE_TOUCH_PAD = 4
     * }
     */
    public static int POINTER_DEVICE_TYPE_TOUCH_PAD() {
        return POINTER_DEVICE_TYPE_TOUCH_PAD;
    }
    private static final int POINTER_DEVICE_TYPE_MAX = (int)-1L;
    /**
     * {@snippet lang=c :
     * enum tagPOINTER_DEVICE_TYPE.POINTER_DEVICE_TYPE_MAX = -1
     * }
     */
    public static int POINTER_DEVICE_TYPE_MAX() {
        return POINTER_DEVICE_TYPE_MAX;
    }
    private static final int POINTER_DEVICE_CURSOR_TYPE_UNKNOWN = (int)0L;
    /**
     * {@snippet lang=c :
     * enum tagPOINTER_DEVICE_CURSOR_TYPE.POINTER_DEVICE_CURSOR_TYPE_UNKNOWN = 0
     * }
     */
    public static int POINTER_DEVICE_CURSOR_TYPE_UNKNOWN() {
        return POINTER_DEVICE_CURSOR_TYPE_UNKNOWN;
    }
    private static final int POINTER_DEVICE_CURSOR_TYPE_TIP = (int)1L;
    /**
     * {@snippet lang=c :
     * enum tagPOINTER_DEVICE_CURSOR_TYPE.POINTER_DEVICE_CURSOR_TYPE_TIP = 1
     * }
     */
    public static int POINTER_DEVICE_CURSOR_TYPE_TIP() {
        return POINTER_DEVICE_CURSOR_TYPE_TIP;
    }
    private static final int POINTER_DEVICE_CURSOR_TYPE_ERASER = (int)2L;
    /**
     * {@snippet lang=c :
     * enum tagPOINTER_DEVICE_CURSOR_TYPE.POINTER_DEVICE_CURSOR_TYPE_ERASER = 2
     * }
     */
    public static int POINTER_DEVICE_CURSOR_TYPE_ERASER() {
        return POINTER_DEVICE_CURSOR_TYPE_ERASER;
    }
    private static final int POINTER_DEVICE_CURSOR_TYPE_MAX = (int)-1L;
    /**
     * {@snippet lang=c :
     * enum tagPOINTER_DEVICE_CURSOR_TYPE.POINTER_DEVICE_CURSOR_TYPE_MAX = -1
     * }
     */
    public static int POINTER_DEVICE_CURSOR_TYPE_MAX() {
        return POINTER_DEVICE_CURSOR_TYPE_MAX;
    }

    private static class GetPointerDevices {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetPointerDevices"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetPointerDevices(UINT32 *deviceCount, POINTER_DEVICE_INFO *pointerDevices)
     * }
     */
    public static FunctionDescriptor GetPointerDevices$descriptor() {
        return GetPointerDevices.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetPointerDevices(UINT32 *deviceCount, POINTER_DEVICE_INFO *pointerDevices)
     * }
     */
    public static MethodHandle GetPointerDevices$handle() {
        return GetPointerDevices.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL GetPointerDevices(UINT32 *deviceCount, POINTER_DEVICE_INFO *pointerDevices)
     * }
     */
    public static int GetPointerDevices(MemorySegment deviceCount, MemorySegment pointerDevices) {
        var mh$ = GetPointerDevices.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetPointerDevices", deviceCount, pointerDevices);
            }
            return (int)mh$.invokeExact(deviceCount, pointerDevices);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetPointerDevice {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetPointerDevice"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetPointerDevice(HANDLE device, POINTER_DEVICE_INFO *pointerDevice)
     * }
     */
    public static FunctionDescriptor GetPointerDevice$descriptor() {
        return GetPointerDevice.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetPointerDevice(HANDLE device, POINTER_DEVICE_INFO *pointerDevice)
     * }
     */
    public static MethodHandle GetPointerDevice$handle() {
        return GetPointerDevice.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL GetPointerDevice(HANDLE device, POINTER_DEVICE_INFO *pointerDevice)
     * }
     */
    public static int GetPointerDevice(MemorySegment device, MemorySegment pointerDevice) {
        var mh$ = GetPointerDevice.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetPointerDevice", device, pointerDevice);
            }
            return (int)mh$.invokeExact(device, pointerDevice);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetPointerDeviceProperties {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetPointerDeviceProperties"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetPointerDeviceProperties(HANDLE device, UINT32 *propertyCount, POINTER_DEVICE_PROPERTY *pointerProperties)
     * }
     */
    public static FunctionDescriptor GetPointerDeviceProperties$descriptor() {
        return GetPointerDeviceProperties.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetPointerDeviceProperties(HANDLE device, UINT32 *propertyCount, POINTER_DEVICE_PROPERTY *pointerProperties)
     * }
     */
    public static MethodHandle GetPointerDeviceProperties$handle() {
        return GetPointerDeviceProperties.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL GetPointerDeviceProperties(HANDLE device, UINT32 *propertyCount, POINTER_DEVICE_PROPERTY *pointerProperties)
     * }
     */
    public static int GetPointerDeviceProperties(MemorySegment device, MemorySegment propertyCount, MemorySegment pointerProperties) {
        var mh$ = GetPointerDeviceProperties.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetPointerDeviceProperties", device, propertyCount, pointerProperties);
            }
            return (int)mh$.invokeExact(device, propertyCount, pointerProperties);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RegisterPointerDeviceNotifications {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("RegisterPointerDeviceNotifications"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL RegisterPointerDeviceNotifications(HWND window, BOOL notifyRange)
     * }
     */
    public static FunctionDescriptor RegisterPointerDeviceNotifications$descriptor() {
        return RegisterPointerDeviceNotifications.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL RegisterPointerDeviceNotifications(HWND window, BOOL notifyRange)
     * }
     */
    public static MethodHandle RegisterPointerDeviceNotifications$handle() {
        return RegisterPointerDeviceNotifications.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL RegisterPointerDeviceNotifications(HWND window, BOOL notifyRange)
     * }
     */
    public static int RegisterPointerDeviceNotifications(MemorySegment window, int notifyRange) {
        var mh$ = RegisterPointerDeviceNotifications.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RegisterPointerDeviceNotifications", window, notifyRange);
            }
            return (int)mh$.invokeExact(window, notifyRange);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetPointerDeviceRects {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetPointerDeviceRects"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetPointerDeviceRects(HANDLE device, RECT *pointerDeviceRect, RECT *displayRect)
     * }
     */
    public static FunctionDescriptor GetPointerDeviceRects$descriptor() {
        return GetPointerDeviceRects.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetPointerDeviceRects(HANDLE device, RECT *pointerDeviceRect, RECT *displayRect)
     * }
     */
    public static MethodHandle GetPointerDeviceRects$handle() {
        return GetPointerDeviceRects.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL GetPointerDeviceRects(HANDLE device, RECT *pointerDeviceRect, RECT *displayRect)
     * }
     */
    public static int GetPointerDeviceRects(MemorySegment device, MemorySegment pointerDeviceRect, MemorySegment displayRect) {
        var mh$ = GetPointerDeviceRects.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetPointerDeviceRects", device, pointerDeviceRect, displayRect);
            }
            return (int)mh$.invokeExact(device, pointerDeviceRect, displayRect);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetPointerDeviceCursors {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetPointerDeviceCursors"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetPointerDeviceCursors(HANDLE device, UINT32 *cursorCount, POINTER_DEVICE_CURSOR_INFO *deviceCursors)
     * }
     */
    public static FunctionDescriptor GetPointerDeviceCursors$descriptor() {
        return GetPointerDeviceCursors.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetPointerDeviceCursors(HANDLE device, UINT32 *cursorCount, POINTER_DEVICE_CURSOR_INFO *deviceCursors)
     * }
     */
    public static MethodHandle GetPointerDeviceCursors$handle() {
        return GetPointerDeviceCursors.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL GetPointerDeviceCursors(HANDLE device, UINT32 *cursorCount, POINTER_DEVICE_CURSOR_INFO *deviceCursors)
     * }
     */
    public static int GetPointerDeviceCursors(MemorySegment device, MemorySegment cursorCount, MemorySegment deviceCursors) {
        var mh$ = GetPointerDeviceCursors.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetPointerDeviceCursors", device, cursorCount, deviceCursors);
            }
            return (int)mh$.invokeExact(device, cursorCount, deviceCursors);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetRawPointerDeviceData {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_INT,
            C_INT,
            C_INT,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetRawPointerDeviceData"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetRawPointerDeviceData(UINT32 pointerId, UINT32 historyCount, UINT32 propertiesCount, POINTER_DEVICE_PROPERTY *pProperties, LONG *pValues)
     * }
     */
    public static FunctionDescriptor GetRawPointerDeviceData$descriptor() {
        return GetRawPointerDeviceData.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetRawPointerDeviceData(UINT32 pointerId, UINT32 historyCount, UINT32 propertiesCount, POINTER_DEVICE_PROPERTY *pProperties, LONG *pValues)
     * }
     */
    public static MethodHandle GetRawPointerDeviceData$handle() {
        return GetRawPointerDeviceData.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL GetRawPointerDeviceData(UINT32 pointerId, UINT32 historyCount, UINT32 propertiesCount, POINTER_DEVICE_PROPERTY *pProperties, LONG *pValues)
     * }
     */
    public static int GetRawPointerDeviceData(int pointerId, int historyCount, int propertiesCount, MemorySegment pProperties, MemorySegment pValues) {
        var mh$ = GetRawPointerDeviceData.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetRawPointerDeviceData", pointerId, historyCount, propertiesCount, pProperties, pValues);
            }
            return (int)mh$.invokeExact(pointerId, historyCount, propertiesCount, pProperties, pValues);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ChangeWindowMessageFilter {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_INT,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("ChangeWindowMessageFilter"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL ChangeWindowMessageFilter(UINT message, DWORD dwFlag)
     * }
     */
    public static FunctionDescriptor ChangeWindowMessageFilter$descriptor() {
        return ChangeWindowMessageFilter.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL ChangeWindowMessageFilter(UINT message, DWORD dwFlag)
     * }
     */
    public static MethodHandle ChangeWindowMessageFilter$handle() {
        return ChangeWindowMessageFilter.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL ChangeWindowMessageFilter(UINT message, DWORD dwFlag)
     * }
     */
    public static int ChangeWindowMessageFilter(int message, int dwFlag) {
        var mh$ = ChangeWindowMessageFilter.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ChangeWindowMessageFilter", message, dwFlag);
            }
            return (int)mh$.invokeExact(message, dwFlag);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct tagCHANGEFILTERSTRUCT {
     *     DWORD cbSize;
     *     DWORD ExtStatus;
     * } *PCHANGEFILTERSTRUCT
     * }
     */
    public static final AddressLayout PCHANGEFILTERSTRUCT = C_POINTER;

    private static class ChangeWindowMessageFilterEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_INT,
            C_LONG,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("ChangeWindowMessageFilterEx"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL ChangeWindowMessageFilterEx(HWND hwnd, UINT message, DWORD action, PCHANGEFILTERSTRUCT pChangeFilterStruct)
     * }
     */
    public static FunctionDescriptor ChangeWindowMessageFilterEx$descriptor() {
        return ChangeWindowMessageFilterEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL ChangeWindowMessageFilterEx(HWND hwnd, UINT message, DWORD action, PCHANGEFILTERSTRUCT pChangeFilterStruct)
     * }
     */
    public static MethodHandle ChangeWindowMessageFilterEx$handle() {
        return ChangeWindowMessageFilterEx.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL ChangeWindowMessageFilterEx(HWND hwnd, UINT message, DWORD action, PCHANGEFILTERSTRUCT pChangeFilterStruct)
     * }
     */
    public static int ChangeWindowMessageFilterEx(MemorySegment hwnd, int message, int action, MemorySegment pChangeFilterStruct) {
        var mh$ = ChangeWindowMessageFilterEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ChangeWindowMessageFilterEx", hwnd, message, action, pChangeFilterStruct);
            }
            return (int)mh$.invokeExact(hwnd, message, action, pChangeFilterStruct);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct HGESTUREINFO__ {
     *     int unused;
     * } *HGESTUREINFO
     * }
     */
    public static final AddressLayout HGESTUREINFO = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagGESTUREINFO {
     *     UINT cbSize;
     *     DWORD dwFlags;
     *     DWORD dwID;
     *     HWND hwndTarget;
     *     POINTS ptsLocation;
     *     DWORD dwInstanceID;
     *     DWORD dwSequenceID;
     *     ULONGLONG ullArguments;
     *     UINT cbExtraArgs;
     * } *PGESTUREINFO
     * }
     */
    public static final AddressLayout PGESTUREINFO = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef const GESTUREINFO *PCGESTUREINFO
     * }
     */
    public static final AddressLayout PCGESTUREINFO = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagGESTURENOTIFYSTRUCT {
     *     UINT cbSize;
     *     DWORD dwFlags;
     *     HWND hwndTarget;
     *     POINTS ptsLocation;
     *     DWORD dwInstanceID;
     * } *PGESTURENOTIFYSTRUCT
     * }
     */
    public static final AddressLayout PGESTURENOTIFYSTRUCT = C_POINTER;

    private static class GetGestureInfo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetGestureInfo"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetGestureInfo(HGESTUREINFO hGestureInfo, PGESTUREINFO pGestureInfo)
     * }
     */
    public static FunctionDescriptor GetGestureInfo$descriptor() {
        return GetGestureInfo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetGestureInfo(HGESTUREINFO hGestureInfo, PGESTUREINFO pGestureInfo)
     * }
     */
    public static MethodHandle GetGestureInfo$handle() {
        return GetGestureInfo.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL GetGestureInfo(HGESTUREINFO hGestureInfo, PGESTUREINFO pGestureInfo)
     * }
     */
    public static int GetGestureInfo(MemorySegment hGestureInfo, MemorySegment pGestureInfo) {
        var mh$ = GetGestureInfo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetGestureInfo", hGestureInfo, pGestureInfo);
            }
            return (int)mh$.invokeExact(hGestureInfo, pGestureInfo);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetGestureExtraArgs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetGestureExtraArgs"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetGestureExtraArgs(HGESTUREINFO hGestureInfo, UINT cbExtraArgs, PBYTE pExtraArgs)
     * }
     */
    public static FunctionDescriptor GetGestureExtraArgs$descriptor() {
        return GetGestureExtraArgs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetGestureExtraArgs(HGESTUREINFO hGestureInfo, UINT cbExtraArgs, PBYTE pExtraArgs)
     * }
     */
    public static MethodHandle GetGestureExtraArgs$handle() {
        return GetGestureExtraArgs.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL GetGestureExtraArgs(HGESTUREINFO hGestureInfo, UINT cbExtraArgs, PBYTE pExtraArgs)
     * }
     */
    public static int GetGestureExtraArgs(MemorySegment hGestureInfo, int cbExtraArgs, MemorySegment pExtraArgs) {
        var mh$ = GetGestureExtraArgs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetGestureExtraArgs", hGestureInfo, cbExtraArgs, pExtraArgs);
            }
            return (int)mh$.invokeExact(hGestureInfo, cbExtraArgs, pExtraArgs);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CloseGestureInfoHandle {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CloseGestureInfoHandle"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CloseGestureInfoHandle(HGESTUREINFO hGestureInfo)
     * }
     */
    public static FunctionDescriptor CloseGestureInfoHandle$descriptor() {
        return CloseGestureInfoHandle.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CloseGestureInfoHandle(HGESTUREINFO hGestureInfo)
     * }
     */
    public static MethodHandle CloseGestureInfoHandle$handle() {
        return CloseGestureInfoHandle.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL CloseGestureInfoHandle(HGESTUREINFO hGestureInfo)
     * }
     */
    public static int CloseGestureInfoHandle(MemorySegment hGestureInfo) {
        var mh$ = CloseGestureInfoHandle.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CloseGestureInfoHandle", hGestureInfo);
            }
            return (int)mh$.invokeExact(hGestureInfo);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct tagGESTURECONFIG {
     *     DWORD dwID;
     *     DWORD dwWant;
     *     DWORD dwBlock;
     * } *PGESTURECONFIG
     * }
     */
    public static final AddressLayout PGESTURECONFIG = C_POINTER;

    private static class SetGestureConfig {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_LONG,
            C_INT,
            C_POINTER,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("SetGestureConfig"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetGestureConfig(HWND hwnd, DWORD dwReserved, UINT cIDs, PGESTURECONFIG pGestureConfig, UINT cbSize)
     * }
     */
    public static FunctionDescriptor SetGestureConfig$descriptor() {
        return SetGestureConfig.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetGestureConfig(HWND hwnd, DWORD dwReserved, UINT cIDs, PGESTURECONFIG pGestureConfig, UINT cbSize)
     * }
     */
    public static MethodHandle SetGestureConfig$handle() {
        return SetGestureConfig.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL SetGestureConfig(HWND hwnd, DWORD dwReserved, UINT cIDs, PGESTURECONFIG pGestureConfig, UINT cbSize)
     * }
     */
    public static int SetGestureConfig(MemorySegment hwnd, int dwReserved, int cIDs, MemorySegment pGestureConfig, int cbSize) {
        var mh$ = SetGestureConfig.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetGestureConfig", hwnd, dwReserved, cIDs, pGestureConfig, cbSize);
            }
            return (int)mh$.invokeExact(hwnd, dwReserved, cIDs, pGestureConfig, cbSize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetGestureConfig {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_LONG,
            C_LONG,
            C_POINTER,
            C_POINTER,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetGestureConfig"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetGestureConfig(HWND hwnd, DWORD dwReserved, DWORD dwFlags, PUINT pcIDs, PGESTURECONFIG pGestureConfig, UINT cbSize)
     * }
     */
    public static FunctionDescriptor GetGestureConfig$descriptor() {
        return GetGestureConfig.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetGestureConfig(HWND hwnd, DWORD dwReserved, DWORD dwFlags, PUINT pcIDs, PGESTURECONFIG pGestureConfig, UINT cbSize)
     * }
     */
    public static MethodHandle GetGestureConfig$handle() {
        return GetGestureConfig.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL GetGestureConfig(HWND hwnd, DWORD dwReserved, DWORD dwFlags, PUINT pcIDs, PGESTURECONFIG pGestureConfig, UINT cbSize)
     * }
     */
    public static int GetGestureConfig(MemorySegment hwnd, int dwReserved, int dwFlags, MemorySegment pcIDs, MemorySegment pGestureConfig, int cbSize) {
        var mh$ = GetGestureConfig.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetGestureConfig", hwnd, dwReserved, dwFlags, pcIDs, pGestureConfig, cbSize);
            }
            return (int)mh$.invokeExact(hwnd, dwReserved, dwFlags, pcIDs, pGestureConfig, cbSize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ShutdownBlockReasonCreate {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("ShutdownBlockReasonCreate"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL ShutdownBlockReasonCreate(HWND hWnd, LPCWSTR pwszReason)
     * }
     */
    public static FunctionDescriptor ShutdownBlockReasonCreate$descriptor() {
        return ShutdownBlockReasonCreate.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL ShutdownBlockReasonCreate(HWND hWnd, LPCWSTR pwszReason)
     * }
     */
    public static MethodHandle ShutdownBlockReasonCreate$handle() {
        return ShutdownBlockReasonCreate.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL ShutdownBlockReasonCreate(HWND hWnd, LPCWSTR pwszReason)
     * }
     */
    public static int ShutdownBlockReasonCreate(MemorySegment hWnd, MemorySegment pwszReason) {
        var mh$ = ShutdownBlockReasonCreate.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ShutdownBlockReasonCreate", hWnd, pwszReason);
            }
            return (int)mh$.invokeExact(hWnd, pwszReason);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ShutdownBlockReasonQuery {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("ShutdownBlockReasonQuery"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL ShutdownBlockReasonQuery(HWND hWnd, LPWSTR pwszBuff, DWORD *pcchBuff)
     * }
     */
    public static FunctionDescriptor ShutdownBlockReasonQuery$descriptor() {
        return ShutdownBlockReasonQuery.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL ShutdownBlockReasonQuery(HWND hWnd, LPWSTR pwszBuff, DWORD *pcchBuff)
     * }
     */
    public static MethodHandle ShutdownBlockReasonQuery$handle() {
        return ShutdownBlockReasonQuery.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL ShutdownBlockReasonQuery(HWND hWnd, LPWSTR pwszBuff, DWORD *pcchBuff)
     * }
     */
    public static int ShutdownBlockReasonQuery(MemorySegment hWnd, MemorySegment pwszBuff, MemorySegment pcchBuff) {
        var mh$ = ShutdownBlockReasonQuery.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ShutdownBlockReasonQuery", hWnd, pwszBuff, pcchBuff);
            }
            return (int)mh$.invokeExact(hWnd, pwszBuff, pcchBuff);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ShutdownBlockReasonDestroy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("ShutdownBlockReasonDestroy"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL ShutdownBlockReasonDestroy(HWND hWnd)
     * }
     */
    public static FunctionDescriptor ShutdownBlockReasonDestroy$descriptor() {
        return ShutdownBlockReasonDestroy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL ShutdownBlockReasonDestroy(HWND hWnd)
     * }
     */
    public static MethodHandle ShutdownBlockReasonDestroy$handle() {
        return ShutdownBlockReasonDestroy.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL ShutdownBlockReasonDestroy(HWND hWnd)
     * }
     */
    public static int ShutdownBlockReasonDestroy(MemorySegment hWnd) {
        var mh$ = ShutdownBlockReasonDestroy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ShutdownBlockReasonDestroy", hWnd);
            }
            return (int)mh$.invokeExact(hWnd);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int IMDT_UNAVAILABLE = (int)0L;
    /**
     * {@snippet lang=c :
     * enum tagINPUT_MESSAGE_DEVICE_TYPE.IMDT_UNAVAILABLE = 0
     * }
     */
    public static int IMDT_UNAVAILABLE() {
        return IMDT_UNAVAILABLE;
    }
    private static final int IMDT_KEYBOARD = (int)1L;
    /**
     * {@snippet lang=c :
     * enum tagINPUT_MESSAGE_DEVICE_TYPE.IMDT_KEYBOARD = 1
     * }
     */
    public static int IMDT_KEYBOARD() {
        return IMDT_KEYBOARD;
    }
    private static final int IMDT_MOUSE = (int)2L;
    /**
     * {@snippet lang=c :
     * enum tagINPUT_MESSAGE_DEVICE_TYPE.IMDT_MOUSE = 2
     * }
     */
    public static int IMDT_MOUSE() {
        return IMDT_MOUSE;
    }
    private static final int IMDT_TOUCH = (int)4L;
    /**
     * {@snippet lang=c :
     * enum tagINPUT_MESSAGE_DEVICE_TYPE.IMDT_TOUCH = 4
     * }
     */
    public static int IMDT_TOUCH() {
        return IMDT_TOUCH;
    }
    private static final int IMDT_PEN = (int)8L;
    /**
     * {@snippet lang=c :
     * enum tagINPUT_MESSAGE_DEVICE_TYPE.IMDT_PEN = 8
     * }
     */
    public static int IMDT_PEN() {
        return IMDT_PEN;
    }
    private static final int IMDT_TOUCHPAD = (int)16L;
    /**
     * {@snippet lang=c :
     * enum tagINPUT_MESSAGE_DEVICE_TYPE.IMDT_TOUCHPAD = 16
     * }
     */
    public static int IMDT_TOUCHPAD() {
        return IMDT_TOUCHPAD;
    }
    private static final int IMO_UNAVAILABLE = (int)0L;
    /**
     * {@snippet lang=c :
     * enum tagINPUT_MESSAGE_ORIGIN_ID.IMO_UNAVAILABLE = 0
     * }
     */
    public static int IMO_UNAVAILABLE() {
        return IMO_UNAVAILABLE;
    }
    private static final int IMO_HARDWARE = (int)1L;
    /**
     * {@snippet lang=c :
     * enum tagINPUT_MESSAGE_ORIGIN_ID.IMO_HARDWARE = 1
     * }
     */
    public static int IMO_HARDWARE() {
        return IMO_HARDWARE;
    }
    private static final int IMO_INJECTED = (int)2L;
    /**
     * {@snippet lang=c :
     * enum tagINPUT_MESSAGE_ORIGIN_ID.IMO_INJECTED = 2
     * }
     */
    public static int IMO_INJECTED() {
        return IMO_INJECTED;
    }
    private static final int IMO_SYSTEM = (int)4L;
    /**
     * {@snippet lang=c :
     * enum tagINPUT_MESSAGE_ORIGIN_ID.IMO_SYSTEM = 4
     * }
     */
    public static int IMO_SYSTEM() {
        return IMO_SYSTEM;
    }

    private static class GetCurrentInputMessageSource {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetCurrentInputMessageSource"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetCurrentInputMessageSource(INPUT_MESSAGE_SOURCE *inputMessageSource)
     * }
     */
    public static FunctionDescriptor GetCurrentInputMessageSource$descriptor() {
        return GetCurrentInputMessageSource.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetCurrentInputMessageSource(INPUT_MESSAGE_SOURCE *inputMessageSource)
     * }
     */
    public static MethodHandle GetCurrentInputMessageSource$handle() {
        return GetCurrentInputMessageSource.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL GetCurrentInputMessageSource(INPUT_MESSAGE_SOURCE *inputMessageSource)
     * }
     */
    public static int GetCurrentInputMessageSource(MemorySegment inputMessageSource) {
        var mh$ = GetCurrentInputMessageSource.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetCurrentInputMessageSource", inputMessageSource);
            }
            return (int)mh$.invokeExact(inputMessageSource);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetCIMSSM {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetCIMSSM"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetCIMSSM(INPUT_MESSAGE_SOURCE *inputMessageSource)
     * }
     */
    public static FunctionDescriptor GetCIMSSM$descriptor() {
        return GetCIMSSM.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetCIMSSM(INPUT_MESSAGE_SOURCE *inputMessageSource)
     * }
     */
    public static MethodHandle GetCIMSSM$handle() {
        return GetCIMSSM.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL GetCIMSSM(INPUT_MESSAGE_SOURCE *inputMessageSource)
     * }
     */
    public static int GetCIMSSM(MemorySegment inputMessageSource) {
        var mh$ = GetCIMSSM.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetCIMSSM", inputMessageSource);
            }
            return (int)mh$.invokeExact(inputMessageSource);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int AR_ENABLED = (int)0L;
    /**
     * {@snippet lang=c :
     * enum tagAR_STATE.AR_ENABLED = 0
     * }
     */
    public static int AR_ENABLED() {
        return AR_ENABLED;
    }
    private static final int AR_DISABLED = (int)1L;
    /**
     * {@snippet lang=c :
     * enum tagAR_STATE.AR_DISABLED = 1
     * }
     */
    public static int AR_DISABLED() {
        return AR_DISABLED;
    }
    private static final int AR_SUPPRESSED = (int)2L;
    /**
     * {@snippet lang=c :
     * enum tagAR_STATE.AR_SUPPRESSED = 2
     * }
     */
    public static int AR_SUPPRESSED() {
        return AR_SUPPRESSED;
    }
    private static final int AR_REMOTESESSION = (int)4L;
    /**
     * {@snippet lang=c :
     * enum tagAR_STATE.AR_REMOTESESSION = 4
     * }
     */
    public static int AR_REMOTESESSION() {
        return AR_REMOTESESSION;
    }
    private static final int AR_MULTIMON = (int)8L;
    /**
     * {@snippet lang=c :
     * enum tagAR_STATE.AR_MULTIMON = 8
     * }
     */
    public static int AR_MULTIMON() {
        return AR_MULTIMON;
    }
    private static final int AR_NOSENSOR = (int)16L;
    /**
     * {@snippet lang=c :
     * enum tagAR_STATE.AR_NOSENSOR = 16
     * }
     */
    public static int AR_NOSENSOR() {
        return AR_NOSENSOR;
    }
    private static final int AR_NOT_SUPPORTED = (int)32L;
    /**
     * {@snippet lang=c :
     * enum tagAR_STATE.AR_NOT_SUPPORTED = 32
     * }
     */
    public static int AR_NOT_SUPPORTED() {
        return AR_NOT_SUPPORTED;
    }
    private static final int AR_DOCKED = (int)64L;
    /**
     * {@snippet lang=c :
     * enum tagAR_STATE.AR_DOCKED = 64
     * }
     */
    public static int AR_DOCKED() {
        return AR_DOCKED;
    }
    private static final int AR_LAPTOP = (int)128L;
    /**
     * {@snippet lang=c :
     * enum tagAR_STATE.AR_LAPTOP = 128
     * }
     */
    public static int AR_LAPTOP() {
        return AR_LAPTOP;
    }
    /**
     * {@snippet lang=c :
     * typedef enum tagAR_STATE {
     *     AR_ENABLED = 0,
     *     AR_DISABLED = 1,
     *     AR_SUPPRESSED = 2,
     *     AR_REMOTESESSION = 4,
     *     AR_MULTIMON = 8,
     *     AR_NOSENSOR = 16,
     *     AR_NOT_SUPPORTED = 32,
     *     AR_DOCKED = 64,
     *     AR_LAPTOP = 128
     * } *PAR_STATE
     * }
     */
    public static final AddressLayout PAR_STATE = C_POINTER;
    private static final int ORIENTATION_PREFERENCE_NONE = (int)0L;
    /**
     * {@snippet lang=c :
     * enum ORIENTATION_PREFERENCE.ORIENTATION_PREFERENCE_NONE = 0
     * }
     */
    public static int ORIENTATION_PREFERENCE_NONE() {
        return ORIENTATION_PREFERENCE_NONE;
    }
    private static final int ORIENTATION_PREFERENCE_LANDSCAPE = (int)1L;
    /**
     * {@snippet lang=c :
     * enum ORIENTATION_PREFERENCE.ORIENTATION_PREFERENCE_LANDSCAPE = 1
     * }
     */
    public static int ORIENTATION_PREFERENCE_LANDSCAPE() {
        return ORIENTATION_PREFERENCE_LANDSCAPE;
    }
    private static final int ORIENTATION_PREFERENCE_PORTRAIT = (int)2L;
    /**
     * {@snippet lang=c :
     * enum ORIENTATION_PREFERENCE.ORIENTATION_PREFERENCE_PORTRAIT = 2
     * }
     */
    public static int ORIENTATION_PREFERENCE_PORTRAIT() {
        return ORIENTATION_PREFERENCE_PORTRAIT;
    }
    private static final int ORIENTATION_PREFERENCE_LANDSCAPE_FLIPPED = (int)4L;
    /**
     * {@snippet lang=c :
     * enum ORIENTATION_PREFERENCE.ORIENTATION_PREFERENCE_LANDSCAPE_FLIPPED = 4
     * }
     */
    public static int ORIENTATION_PREFERENCE_LANDSCAPE_FLIPPED() {
        return ORIENTATION_PREFERENCE_LANDSCAPE_FLIPPED;
    }
    private static final int ORIENTATION_PREFERENCE_PORTRAIT_FLIPPED = (int)8L;
    /**
     * {@snippet lang=c :
     * enum ORIENTATION_PREFERENCE.ORIENTATION_PREFERENCE_PORTRAIT_FLIPPED = 8
     * }
     */
    public static int ORIENTATION_PREFERENCE_PORTRAIT_FLIPPED() {
        return ORIENTATION_PREFERENCE_PORTRAIT_FLIPPED;
    }

    private static class GetAutoRotationState {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetAutoRotationState"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetAutoRotationState(PAR_STATE pState)
     * }
     */
    public static FunctionDescriptor GetAutoRotationState$descriptor() {
        return GetAutoRotationState.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetAutoRotationState(PAR_STATE pState)
     * }
     */
    public static MethodHandle GetAutoRotationState$handle() {
        return GetAutoRotationState.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL GetAutoRotationState(PAR_STATE pState)
     * }
     */
    public static int GetAutoRotationState(MemorySegment pState) {
        var mh$ = GetAutoRotationState.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetAutoRotationState", pState);
            }
            return (int)mh$.invokeExact(pState);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetDisplayAutoRotationPreferences {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetDisplayAutoRotationPreferences"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetDisplayAutoRotationPreferences(ORIENTATION_PREFERENCE *pOrientation)
     * }
     */
    public static FunctionDescriptor GetDisplayAutoRotationPreferences$descriptor() {
        return GetDisplayAutoRotationPreferences.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetDisplayAutoRotationPreferences(ORIENTATION_PREFERENCE *pOrientation)
     * }
     */
    public static MethodHandle GetDisplayAutoRotationPreferences$handle() {
        return GetDisplayAutoRotationPreferences.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL GetDisplayAutoRotationPreferences(ORIENTATION_PREFERENCE *pOrientation)
     * }
     */
    public static int GetDisplayAutoRotationPreferences(MemorySegment pOrientation) {
        var mh$ = GetDisplayAutoRotationPreferences.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetDisplayAutoRotationPreferences", pOrientation);
            }
            return (int)mh$.invokeExact(pOrientation);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetDisplayAutoRotationPreferencesByProcessId {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_LONG,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetDisplayAutoRotationPreferencesByProcessId"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetDisplayAutoRotationPreferencesByProcessId(DWORD dwProcessId, ORIENTATION_PREFERENCE *pOrientation, BOOL *fRotateScreen)
     * }
     */
    public static FunctionDescriptor GetDisplayAutoRotationPreferencesByProcessId$descriptor() {
        return GetDisplayAutoRotationPreferencesByProcessId.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetDisplayAutoRotationPreferencesByProcessId(DWORD dwProcessId, ORIENTATION_PREFERENCE *pOrientation, BOOL *fRotateScreen)
     * }
     */
    public static MethodHandle GetDisplayAutoRotationPreferencesByProcessId$handle() {
        return GetDisplayAutoRotationPreferencesByProcessId.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL GetDisplayAutoRotationPreferencesByProcessId(DWORD dwProcessId, ORIENTATION_PREFERENCE *pOrientation, BOOL *fRotateScreen)
     * }
     */
    public static int GetDisplayAutoRotationPreferencesByProcessId(int dwProcessId, MemorySegment pOrientation, MemorySegment fRotateScreen) {
        var mh$ = GetDisplayAutoRotationPreferencesByProcessId.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetDisplayAutoRotationPreferencesByProcessId", dwProcessId, pOrientation, fRotateScreen);
            }
            return (int)mh$.invokeExact(dwProcessId, pOrientation, fRotateScreen);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetDisplayAutoRotationPreferences {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("SetDisplayAutoRotationPreferences"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetDisplayAutoRotationPreferences(ORIENTATION_PREFERENCE orientation)
     * }
     */
    public static FunctionDescriptor SetDisplayAutoRotationPreferences$descriptor() {
        return SetDisplayAutoRotationPreferences.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetDisplayAutoRotationPreferences(ORIENTATION_PREFERENCE orientation)
     * }
     */
    public static MethodHandle SetDisplayAutoRotationPreferences$handle() {
        return SetDisplayAutoRotationPreferences.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL SetDisplayAutoRotationPreferences(ORIENTATION_PREFERENCE orientation)
     * }
     */
    public static int SetDisplayAutoRotationPreferences(int orientation) {
        var mh$ = SetDisplayAutoRotationPreferences.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetDisplayAutoRotationPreferences", orientation);
            }
            return (int)mh$.invokeExact(orientation);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class IsImmersiveProcess {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("IsImmersiveProcess"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL IsImmersiveProcess(HANDLE hProcess)
     * }
     */
    public static FunctionDescriptor IsImmersiveProcess$descriptor() {
        return IsImmersiveProcess.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL IsImmersiveProcess(HANDLE hProcess)
     * }
     */
    public static MethodHandle IsImmersiveProcess$handle() {
        return IsImmersiveProcess.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL IsImmersiveProcess(HANDLE hProcess)
     * }
     */
    public static int IsImmersiveProcess(MemorySegment hProcess) {
        var mh$ = IsImmersiveProcess.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("IsImmersiveProcess", hProcess);
            }
            return (int)mh$.invokeExact(hProcess);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetProcessRestrictionExemption {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("SetProcessRestrictionExemption"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetProcessRestrictionExemption(BOOL fEnableExemption)
     * }
     */
    public static FunctionDescriptor SetProcessRestrictionExemption$descriptor() {
        return SetProcessRestrictionExemption.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetProcessRestrictionExemption(BOOL fEnableExemption)
     * }
     */
    public static MethodHandle SetProcessRestrictionExemption$handle() {
        return SetProcessRestrictionExemption.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL SetProcessRestrictionExemption(BOOL fEnableExemption)
     * }
     */
    public static int SetProcessRestrictionExemption(int fEnableExemption) {
        var mh$ = SetProcessRestrictionExemption.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetProcessRestrictionExemption", fEnableExemption);
            }
            return (int)mh$.invokeExact(fEnableExemption);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetDateFormatA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_LONG,
            C_LONG,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetDateFormatA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int GetDateFormatA(LCID Locale, DWORD dwFlags, const SYSTEMTIME *lpDate, LPCSTR lpFormat, LPSTR lpDateStr, int cchDate)
     * }
     */
    public static FunctionDescriptor GetDateFormatA$descriptor() {
        return GetDateFormatA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int GetDateFormatA(LCID Locale, DWORD dwFlags, const SYSTEMTIME *lpDate, LPCSTR lpFormat, LPSTR lpDateStr, int cchDate)
     * }
     */
    public static MethodHandle GetDateFormatA$handle() {
        return GetDateFormatA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int GetDateFormatA(LCID Locale, DWORD dwFlags, const SYSTEMTIME *lpDate, LPCSTR lpFormat, LPSTR lpDateStr, int cchDate)
     * }
     */
    public static int GetDateFormatA(int Locale, int dwFlags, MemorySegment lpDate, MemorySegment lpFormat, MemorySegment lpDateStr, int cchDate) {
        var mh$ = GetDateFormatA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetDateFormatA", Locale, dwFlags, lpDate, lpFormat, lpDateStr, cchDate);
            }
            return (int)mh$.invokeExact(Locale, dwFlags, lpDate, lpFormat, lpDateStr, cchDate);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetDateFormatW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_LONG,
            C_LONG,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetDateFormatW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int GetDateFormatW(LCID Locale, DWORD dwFlags, const SYSTEMTIME *lpDate, LPCWSTR lpFormat, LPWSTR lpDateStr, int cchDate)
     * }
     */
    public static FunctionDescriptor GetDateFormatW$descriptor() {
        return GetDateFormatW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int GetDateFormatW(LCID Locale, DWORD dwFlags, const SYSTEMTIME *lpDate, LPCWSTR lpFormat, LPWSTR lpDateStr, int cchDate)
     * }
     */
    public static MethodHandle GetDateFormatW$handle() {
        return GetDateFormatW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int GetDateFormatW(LCID Locale, DWORD dwFlags, const SYSTEMTIME *lpDate, LPCWSTR lpFormat, LPWSTR lpDateStr, int cchDate)
     * }
     */
    public static int GetDateFormatW(int Locale, int dwFlags, MemorySegment lpDate, MemorySegment lpFormat, MemorySegment lpDateStr, int cchDate) {
        var mh$ = GetDateFormatW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetDateFormatW", Locale, dwFlags, lpDate, lpFormat, lpDateStr, cchDate);
            }
            return (int)mh$.invokeExact(Locale, dwFlags, lpDate, lpFormat, lpDateStr, cchDate);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetTimeFormatA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_LONG,
            C_LONG,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetTimeFormatA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int GetTimeFormatA(LCID Locale, DWORD dwFlags, const SYSTEMTIME *lpTime, LPCSTR lpFormat, LPSTR lpTimeStr, int cchTime)
     * }
     */
    public static FunctionDescriptor GetTimeFormatA$descriptor() {
        return GetTimeFormatA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int GetTimeFormatA(LCID Locale, DWORD dwFlags, const SYSTEMTIME *lpTime, LPCSTR lpFormat, LPSTR lpTimeStr, int cchTime)
     * }
     */
    public static MethodHandle GetTimeFormatA$handle() {
        return GetTimeFormatA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int GetTimeFormatA(LCID Locale, DWORD dwFlags, const SYSTEMTIME *lpTime, LPCSTR lpFormat, LPSTR lpTimeStr, int cchTime)
     * }
     */
    public static int GetTimeFormatA(int Locale, int dwFlags, MemorySegment lpTime, MemorySegment lpFormat, MemorySegment lpTimeStr, int cchTime) {
        var mh$ = GetTimeFormatA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetTimeFormatA", Locale, dwFlags, lpTime, lpFormat, lpTimeStr, cchTime);
            }
            return (int)mh$.invokeExact(Locale, dwFlags, lpTime, lpFormat, lpTimeStr, cchTime);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetTimeFormatW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_LONG,
            C_LONG,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetTimeFormatW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int GetTimeFormatW(LCID Locale, DWORD dwFlags, const SYSTEMTIME *lpTime, LPCWSTR lpFormat, LPWSTR lpTimeStr, int cchTime)
     * }
     */
    public static FunctionDescriptor GetTimeFormatW$descriptor() {
        return GetTimeFormatW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int GetTimeFormatW(LCID Locale, DWORD dwFlags, const SYSTEMTIME *lpTime, LPCWSTR lpFormat, LPWSTR lpTimeStr, int cchTime)
     * }
     */
    public static MethodHandle GetTimeFormatW$handle() {
        return GetTimeFormatW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int GetTimeFormatW(LCID Locale, DWORD dwFlags, const SYSTEMTIME *lpTime, LPCWSTR lpFormat, LPWSTR lpTimeStr, int cchTime)
     * }
     */
    public static int GetTimeFormatW(int Locale, int dwFlags, MemorySegment lpTime, MemorySegment lpFormat, MemorySegment lpTimeStr, int cchTime) {
        var mh$ = GetTimeFormatW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetTimeFormatW", Locale, dwFlags, lpTime, lpFormat, lpTimeStr, cchTime);
            }
            return (int)mh$.invokeExact(Locale, dwFlags, lpTime, lpFormat, lpTimeStr, cchTime);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetTimeFormatEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_LONG,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetTimeFormatEx"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int GetTimeFormatEx(LPCWSTR lpLocaleName, DWORD dwFlags, const SYSTEMTIME *lpTime, LPCWSTR lpFormat, LPWSTR lpTimeStr, int cchTime)
     * }
     */
    public static FunctionDescriptor GetTimeFormatEx$descriptor() {
        return GetTimeFormatEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int GetTimeFormatEx(LPCWSTR lpLocaleName, DWORD dwFlags, const SYSTEMTIME *lpTime, LPCWSTR lpFormat, LPWSTR lpTimeStr, int cchTime)
     * }
     */
    public static MethodHandle GetTimeFormatEx$handle() {
        return GetTimeFormatEx.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int GetTimeFormatEx(LPCWSTR lpLocaleName, DWORD dwFlags, const SYSTEMTIME *lpTime, LPCWSTR lpFormat, LPWSTR lpTimeStr, int cchTime)
     * }
     */
    public static int GetTimeFormatEx(MemorySegment lpLocaleName, int dwFlags, MemorySegment lpTime, MemorySegment lpFormat, MemorySegment lpTimeStr, int cchTime) {
        var mh$ = GetTimeFormatEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetTimeFormatEx", lpLocaleName, dwFlags, lpTime, lpFormat, lpTimeStr, cchTime);
            }
            return (int)mh$.invokeExact(lpLocaleName, dwFlags, lpTime, lpFormat, lpTimeStr, cchTime);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetDateFormatEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_LONG,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetDateFormatEx"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int GetDateFormatEx(LPCWSTR lpLocaleName, DWORD dwFlags, const SYSTEMTIME *lpDate, LPCWSTR lpFormat, LPWSTR lpDateStr, int cchDate, LPCWSTR lpCalendar)
     * }
     */
    public static FunctionDescriptor GetDateFormatEx$descriptor() {
        return GetDateFormatEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int GetDateFormatEx(LPCWSTR lpLocaleName, DWORD dwFlags, const SYSTEMTIME *lpDate, LPCWSTR lpFormat, LPWSTR lpDateStr, int cchDate, LPCWSTR lpCalendar)
     * }
     */
    public static MethodHandle GetDateFormatEx$handle() {
        return GetDateFormatEx.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int GetDateFormatEx(LPCWSTR lpLocaleName, DWORD dwFlags, const SYSTEMTIME *lpDate, LPCWSTR lpFormat, LPWSTR lpDateStr, int cchDate, LPCWSTR lpCalendar)
     * }
     */
    public static int GetDateFormatEx(MemorySegment lpLocaleName, int dwFlags, MemorySegment lpDate, MemorySegment lpFormat, MemorySegment lpDateStr, int cchDate, MemorySegment lpCalendar) {
        var mh$ = GetDateFormatEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetDateFormatEx", lpLocaleName, dwFlags, lpDate, lpFormat, lpDateStr, cchDate, lpCalendar);
            }
            return (int)mh$.invokeExact(lpLocaleName, dwFlags, lpDate, lpFormat, lpDateStr, cchDate, lpCalendar);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetDurationFormatEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_LONG,
            C_POINTER,
            C_LONG_LONG,
            C_POINTER,
            C_POINTER,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetDurationFormatEx"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int GetDurationFormatEx(LPCWSTR lpLocaleName, DWORD dwFlags, const SYSTEMTIME *lpDuration, ULONGLONG ullDuration, LPCWSTR lpFormat, LPWSTR lpDurationStr, int cchDuration)
     * }
     */
    public static FunctionDescriptor GetDurationFormatEx$descriptor() {
        return GetDurationFormatEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int GetDurationFormatEx(LPCWSTR lpLocaleName, DWORD dwFlags, const SYSTEMTIME *lpDuration, ULONGLONG ullDuration, LPCWSTR lpFormat, LPWSTR lpDurationStr, int cchDuration)
     * }
     */
    public static MethodHandle GetDurationFormatEx$handle() {
        return GetDurationFormatEx.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int GetDurationFormatEx(LPCWSTR lpLocaleName, DWORD dwFlags, const SYSTEMTIME *lpDuration, ULONGLONG ullDuration, LPCWSTR lpFormat, LPWSTR lpDurationStr, int cchDuration)
     * }
     */
    public static int GetDurationFormatEx(MemorySegment lpLocaleName, int dwFlags, MemorySegment lpDuration, long ullDuration, MemorySegment lpFormat, MemorySegment lpDurationStr, int cchDuration) {
        var mh$ = GetDurationFormatEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetDurationFormatEx", lpLocaleName, dwFlags, lpDuration, ullDuration, lpFormat, lpDurationStr, cchDuration);
            }
            return (int)mh$.invokeExact(lpLocaleName, dwFlags, lpDuration, ullDuration, lpFormat, lpDurationStr, cchDuration);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef DWORD LGRPID
     * }
     */
    public static final OfInt LGRPID = C_LONG;
    /**
     * {@snippet lang=c :
     * typedef DWORD LCTYPE
     * }
     */
    public static final OfInt LCTYPE = C_LONG;
    /**
     * {@snippet lang=c :
     * typedef DWORD CALTYPE
     * }
     */
    public static final OfInt CALTYPE = C_LONG;
    /**
     * {@snippet lang=c :
     * typedef DWORD CALID
     * }
     */
    public static final OfInt CALID = C_LONG;
    /**
     * {@snippet lang=c :
     * typedef struct _cpinfo {
     *     UINT MaxCharSize;
     *     BYTE DefaultChar[2];
     *     BYTE LeadByte[12];
     * } *LPCPINFO
     * }
     */
    public static final AddressLayout LPCPINFO = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef DWORD GEOTYPE
     * }
     */
    public static final OfInt GEOTYPE = C_LONG;
    /**
     * {@snippet lang=c :
     * typedef DWORD GEOCLASS
     * }
     */
    public static final OfInt GEOCLASS = C_LONG;
    /**
     * {@snippet lang=c :
     * typedef LONG GEOID
     * }
     */
    public static final OfInt GEOID = C_LONG;
    /**
     * {@snippet lang=c :
     * typedef struct _cpinfoexA {
     *     UINT MaxCharSize;
     *     BYTE DefaultChar[2];
     *     BYTE LeadByte[12];
     *     WCHAR UnicodeDefaultChar;
     *     UINT CodePage;
     *     CHAR CodePageName[260];
     * } *LPCPINFOEXA
     * }
     */
    public static final AddressLayout LPCPINFOEXA = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _cpinfoexW {
     *     UINT MaxCharSize;
     *     BYTE DefaultChar[2];
     *     BYTE LeadByte[12];
     *     WCHAR UnicodeDefaultChar;
     *     UINT CodePage;
     *     WCHAR CodePageName[260];
     * } *LPCPINFOEXW
     * }
     */
    public static final AddressLayout LPCPINFOEXW = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef LPCPINFOEXA LPCPINFOEX
     * }
     */
    public static final AddressLayout LPCPINFOEX = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _numberfmtA {
     *     UINT NumDigits;
     *     UINT LeadingZero;
     *     UINT Grouping;
     *     LPSTR lpDecimalSep;
     *     LPSTR lpThousandSep;
     *     UINT NegativeOrder;
     * } *LPNUMBERFMTA
     * }
     */
    public static final AddressLayout LPNUMBERFMTA = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _numberfmtW {
     *     UINT NumDigits;
     *     UINT LeadingZero;
     *     UINT Grouping;
     *     LPWSTR lpDecimalSep;
     *     LPWSTR lpThousandSep;
     *     UINT NegativeOrder;
     * } *LPNUMBERFMTW
     * }
     */
    public static final AddressLayout LPNUMBERFMTW = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef LPNUMBERFMTA LPNUMBERFMT
     * }
     */
    public static final AddressLayout LPNUMBERFMT = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _currencyfmtA {
     *     UINT NumDigits;
     *     UINT LeadingZero;
     *     UINT Grouping;
     *     LPSTR lpDecimalSep;
     *     LPSTR lpThousandSep;
     *     UINT NegativeOrder;
     *     UINT PositiveOrder;
     *     LPSTR lpCurrencySymbol;
     * } *LPCURRENCYFMTA
     * }
     */
    public static final AddressLayout LPCURRENCYFMTA = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _currencyfmtW {
     *     UINT NumDigits;
     *     UINT LeadingZero;
     *     UINT Grouping;
     *     LPWSTR lpDecimalSep;
     *     LPWSTR lpThousandSep;
     *     UINT NegativeOrder;
     *     UINT PositiveOrder;
     *     LPWSTR lpCurrencySymbol;
     * } *LPCURRENCYFMTW
     * }
     */
    public static final AddressLayout LPCURRENCYFMTW = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef LPCURRENCYFMTA LPCURRENCYFMT
     * }
     */
    public static final AddressLayout LPCURRENCYFMT = C_POINTER;
    private static final int COMPARE_STRING = (int)1L;
    /**
     * {@snippet lang=c :
     * enum SYSNLS_FUNCTION.COMPARE_STRING = 1
     * }
     */
    public static int COMPARE_STRING() {
        return COMPARE_STRING;
    }
    /**
     * {@snippet lang=c :
     * typedef DWORD NLS_FUNCTION
     * }
     */
    public static final OfInt NLS_FUNCTION = C_LONG;
    /**
     * {@snippet lang=c :
     * typedef struct _nlsversioninfo {
     *     DWORD dwNLSVersionInfoSize;
     *     DWORD dwNLSVersion;
     *     DWORD dwDefinedVersion;
     *     DWORD dwEffectiveId;
     *     GUID guidCustomVersion;
     * } *LPNLSVERSIONINFO
     * }
     */
    public static final AddressLayout LPNLSVERSIONINFO = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _nlsversioninfoex {
     *     DWORD dwNLSVersionInfoSize;
     *     DWORD dwNLSVersion;
     *     DWORD dwDefinedVersion;
     *     DWORD dwEffectiveId;
     *     GUID guidCustomVersion;
     * } *LPNLSVERSIONINFOEX
     * }
     */
    public static final AddressLayout LPNLSVERSIONINFOEX = C_POINTER;
    private static final int GEO_NATION = (int)1L;
    /**
     * {@snippet lang=c :
     * enum SYSGEOTYPE.GEO_NATION = 1
     * }
     */
    public static int GEO_NATION() {
        return GEO_NATION;
    }
    private static final int GEO_LATITUDE = (int)2L;
    /**
     * {@snippet lang=c :
     * enum SYSGEOTYPE.GEO_LATITUDE = 2
     * }
     */
    public static int GEO_LATITUDE() {
        return GEO_LATITUDE;
    }
    private static final int GEO_LONGITUDE = (int)3L;
    /**
     * {@snippet lang=c :
     * enum SYSGEOTYPE.GEO_LONGITUDE = 3
     * }
     */
    public static int GEO_LONGITUDE() {
        return GEO_LONGITUDE;
    }
    private static final int GEO_ISO2 = (int)4L;
    /**
     * {@snippet lang=c :
     * enum SYSGEOTYPE.GEO_ISO2 = 4
     * }
     */
    public static int GEO_ISO2() {
        return GEO_ISO2;
    }
    private static final int GEO_ISO3 = (int)5L;
    /**
     * {@snippet lang=c :
     * enum SYSGEOTYPE.GEO_ISO3 = 5
     * }
     */
    public static int GEO_ISO3() {
        return GEO_ISO3;
    }
    private static final int GEO_RFC1766 = (int)6L;
    /**
     * {@snippet lang=c :
     * enum SYSGEOTYPE.GEO_RFC1766 = 6
     * }
     */
    public static int GEO_RFC1766() {
        return GEO_RFC1766;
    }
    private static final int GEO_LCID = (int)7L;
    /**
     * {@snippet lang=c :
     * enum SYSGEOTYPE.GEO_LCID = 7
     * }
     */
    public static int GEO_LCID() {
        return GEO_LCID;
    }
    private static final int GEO_FRIENDLYNAME = (int)8L;
    /**
     * {@snippet lang=c :
     * enum SYSGEOTYPE.GEO_FRIENDLYNAME = 8
     * }
     */
    public static int GEO_FRIENDLYNAME() {
        return GEO_FRIENDLYNAME;
    }
    private static final int GEO_OFFICIALNAME = (int)9L;
    /**
     * {@snippet lang=c :
     * enum SYSGEOTYPE.GEO_OFFICIALNAME = 9
     * }
     */
    public static int GEO_OFFICIALNAME() {
        return GEO_OFFICIALNAME;
    }
    private static final int GEO_TIMEZONES = (int)10L;
    /**
     * {@snippet lang=c :
     * enum SYSGEOTYPE.GEO_TIMEZONES = 10
     * }
     */
    public static int GEO_TIMEZONES() {
        return GEO_TIMEZONES;
    }
    private static final int GEO_OFFICIALLANGUAGES = (int)11L;
    /**
     * {@snippet lang=c :
     * enum SYSGEOTYPE.GEO_OFFICIALLANGUAGES = 11
     * }
     */
    public static int GEO_OFFICIALLANGUAGES() {
        return GEO_OFFICIALLANGUAGES;
    }
    private static final int GEO_ISO_UN_NUMBER = (int)12L;
    /**
     * {@snippet lang=c :
     * enum SYSGEOTYPE.GEO_ISO_UN_NUMBER = 12
     * }
     */
    public static int GEO_ISO_UN_NUMBER() {
        return GEO_ISO_UN_NUMBER;
    }
    private static final int GEO_PARENT = (int)13L;
    /**
     * {@snippet lang=c :
     * enum SYSGEOTYPE.GEO_PARENT = 13
     * }
     */
    public static int GEO_PARENT() {
        return GEO_PARENT;
    }
    private static final int GEO_DIALINGCODE = (int)14L;
    /**
     * {@snippet lang=c :
     * enum SYSGEOTYPE.GEO_DIALINGCODE = 14
     * }
     */
    public static int GEO_DIALINGCODE() {
        return GEO_DIALINGCODE;
    }
    private static final int GEO_CURRENCYCODE = (int)15L;
    /**
     * {@snippet lang=c :
     * enum SYSGEOTYPE.GEO_CURRENCYCODE = 15
     * }
     */
    public static int GEO_CURRENCYCODE() {
        return GEO_CURRENCYCODE;
    }
    private static final int GEO_CURRENCYSYMBOL = (int)16L;
    /**
     * {@snippet lang=c :
     * enum SYSGEOTYPE.GEO_CURRENCYSYMBOL = 16
     * }
     */
    public static int GEO_CURRENCYSYMBOL() {
        return GEO_CURRENCYSYMBOL;
    }
    private static final int GEO_NAME = (int)17L;
    /**
     * {@snippet lang=c :
     * enum SYSGEOTYPE.GEO_NAME = 17
     * }
     */
    public static int GEO_NAME() {
        return GEO_NAME;
    }
    private static final int GEO_ID = (int)18L;
    /**
     * {@snippet lang=c :
     * enum SYSGEOTYPE.GEO_ID = 18
     * }
     */
    public static int GEO_ID() {
        return GEO_ID;
    }
    private static final int GEOCLASS_NATION = (int)16L;
    /**
     * {@snippet lang=c :
     * enum SYSGEOCLASS.GEOCLASS_NATION = 16
     * }
     */
    public static int GEOCLASS_NATION() {
        return GEOCLASS_NATION;
    }
    private static final int GEOCLASS_REGION = (int)14L;
    /**
     * {@snippet lang=c :
     * enum SYSGEOCLASS.GEOCLASS_REGION = 14
     * }
     */
    public static int GEOCLASS_REGION() {
        return GEOCLASS_REGION;
    }
    private static final int GEOCLASS_ALL = (int)0L;
    /**
     * {@snippet lang=c :
     * enum SYSGEOCLASS.GEOCLASS_ALL = 0
     * }
     */
    public static int GEOCLASS_ALL() {
        return GEOCLASS_ALL;
    }
    private static final int NormalizationOther = (int)0L;
    /**
     * {@snippet lang=c :
     * enum _NORM_FORM.NormalizationOther = 0
     * }
     */
    public static int NormalizationOther() {
        return NormalizationOther;
    }
    private static final int NormalizationC = (int)1L;
    /**
     * {@snippet lang=c :
     * enum _NORM_FORM.NormalizationC = 1
     * }
     */
    public static int NormalizationC() {
        return NormalizationC;
    }
    private static final int NormalizationD = (int)2L;
    /**
     * {@snippet lang=c :
     * enum _NORM_FORM.NormalizationD = 2
     * }
     */
    public static int NormalizationD() {
        return NormalizationD;
    }
    private static final int NormalizationKC = (int)5L;
    /**
     * {@snippet lang=c :
     * enum _NORM_FORM.NormalizationKC = 5
     * }
     */
    public static int NormalizationKC() {
        return NormalizationKC;
    }
    private static final int NormalizationKD = (int)6L;
    /**
     * {@snippet lang=c :
     * enum _NORM_FORM.NormalizationKD = 6
     * }
     */
    public static int NormalizationKD() {
        return NormalizationKD;
    }
    /**
     * {@snippet lang=c :
     * typedef struct _FILEMUIINFO {
     *     DWORD dwSize;
     *     DWORD dwVersion;
     *     DWORD dwFileType;
     *     BYTE pChecksum[16];
     *     BYTE pServiceChecksum[16];
     *     DWORD dwLanguageNameOffset;
     *     DWORD dwTypeIDMainSize;
     *     DWORD dwTypeIDMainOffset;
     *     DWORD dwTypeNameMainOffset;
     *     DWORD dwTypeIDMUISize;
     *     DWORD dwTypeIDMUIOffset;
     *     DWORD dwTypeNameMUIOffset;
     *     BYTE abBuffer[8];
     * } *PFILEMUIINFO
     * }
     */
    public static final AddressLayout PFILEMUIINFO = C_POINTER;

    private static class CompareStringEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_LONG,
            C_POINTER,
            C_INT,
            C_POINTER,
            C_INT,
            C_POINTER,
            C_POINTER,
            C_LONG_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CompareStringEx"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int CompareStringEx(LPCWSTR lpLocaleName, DWORD dwCmpFlags, LPCWCH lpString1, int cchCount1, LPCWCH lpString2, int cchCount2, LPNLSVERSIONINFO lpVersionInformation, LPVOID lpReserved, LPARAM lParam)
     * }
     */
    public static FunctionDescriptor CompareStringEx$descriptor() {
        return CompareStringEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int CompareStringEx(LPCWSTR lpLocaleName, DWORD dwCmpFlags, LPCWCH lpString1, int cchCount1, LPCWCH lpString2, int cchCount2, LPNLSVERSIONINFO lpVersionInformation, LPVOID lpReserved, LPARAM lParam)
     * }
     */
    public static MethodHandle CompareStringEx$handle() {
        return CompareStringEx.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int CompareStringEx(LPCWSTR lpLocaleName, DWORD dwCmpFlags, LPCWCH lpString1, int cchCount1, LPCWCH lpString2, int cchCount2, LPNLSVERSIONINFO lpVersionInformation, LPVOID lpReserved, LPARAM lParam)
     * }
     */
    public static int CompareStringEx(MemorySegment lpLocaleName, int dwCmpFlags, MemorySegment lpString1, int cchCount1, MemorySegment lpString2, int cchCount2, MemorySegment lpVersionInformation, MemorySegment lpReserved, long lParam) {
        var mh$ = CompareStringEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CompareStringEx", lpLocaleName, dwCmpFlags, lpString1, cchCount1, lpString2, cchCount2, lpVersionInformation, lpReserved, lParam);
            }
            return (int)mh$.invokeExact(lpLocaleName, dwCmpFlags, lpString1, cchCount1, lpString2, cchCount2, lpVersionInformation, lpReserved, lParam);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CompareStringOrdinal {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_INT,
            C_POINTER,
            C_INT,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CompareStringOrdinal"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int CompareStringOrdinal(LPCWCH lpString1, int cchCount1, LPCWCH lpString2, int cchCount2, BOOL bIgnoreCase)
     * }
     */
    public static FunctionDescriptor CompareStringOrdinal$descriptor() {
        return CompareStringOrdinal.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int CompareStringOrdinal(LPCWCH lpString1, int cchCount1, LPCWCH lpString2, int cchCount2, BOOL bIgnoreCase)
     * }
     */
    public static MethodHandle CompareStringOrdinal$handle() {
        return CompareStringOrdinal.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int CompareStringOrdinal(LPCWCH lpString1, int cchCount1, LPCWCH lpString2, int cchCount2, BOOL bIgnoreCase)
     * }
     */
    public static int CompareStringOrdinal(MemorySegment lpString1, int cchCount1, MemorySegment lpString2, int cchCount2, int bIgnoreCase) {
        var mh$ = CompareStringOrdinal.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CompareStringOrdinal", lpString1, cchCount1, lpString2, cchCount2, bIgnoreCase);
            }
            return (int)mh$.invokeExact(lpString1, cchCount1, lpString2, cchCount2, bIgnoreCase);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CompareStringW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_LONG,
            C_LONG,
            C_POINTER,
            C_INT,
            C_POINTER,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CompareStringW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int CompareStringW(LCID Locale, DWORD dwCmpFlags, PCNZWCH lpString1, int cchCount1, PCNZWCH lpString2, int cchCount2)
     * }
     */
    public static FunctionDescriptor CompareStringW$descriptor() {
        return CompareStringW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int CompareStringW(LCID Locale, DWORD dwCmpFlags, PCNZWCH lpString1, int cchCount1, PCNZWCH lpString2, int cchCount2)
     * }
     */
    public static MethodHandle CompareStringW$handle() {
        return CompareStringW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int CompareStringW(LCID Locale, DWORD dwCmpFlags, PCNZWCH lpString1, int cchCount1, PCNZWCH lpString2, int cchCount2)
     * }
     */
    public static int CompareStringW(int Locale, int dwCmpFlags, MemorySegment lpString1, int cchCount1, MemorySegment lpString2, int cchCount2) {
        var mh$ = CompareStringW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CompareStringW", Locale, dwCmpFlags, lpString1, cchCount1, lpString2, cchCount2);
            }
            return (int)mh$.invokeExact(Locale, dwCmpFlags, lpString1, cchCount1, lpString2, cchCount2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FoldStringW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_LONG,
            C_POINTER,
            C_INT,
            C_POINTER,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("FoldStringW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int FoldStringW(DWORD dwMapFlags, LPCWCH lpSrcStr, int cchSrc, LPWSTR lpDestStr, int cchDest)
     * }
     */
    public static FunctionDescriptor FoldStringW$descriptor() {
        return FoldStringW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int FoldStringW(DWORD dwMapFlags, LPCWCH lpSrcStr, int cchSrc, LPWSTR lpDestStr, int cchDest)
     * }
     */
    public static MethodHandle FoldStringW$handle() {
        return FoldStringW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int FoldStringW(DWORD dwMapFlags, LPCWCH lpSrcStr, int cchSrc, LPWSTR lpDestStr, int cchDest)
     * }
     */
    public static int FoldStringW(int dwMapFlags, MemorySegment lpSrcStr, int cchSrc, MemorySegment lpDestStr, int cchDest) {
        var mh$ = FoldStringW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FoldStringW", dwMapFlags, lpSrcStr, cchSrc, lpDestStr, cchDest);
            }
            return (int)mh$.invokeExact(dwMapFlags, lpSrcStr, cchSrc, lpDestStr, cchDest);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetStringTypeExW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_LONG,
            C_LONG,
            C_POINTER,
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetStringTypeExW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetStringTypeExW(LCID Locale, DWORD dwInfoType, LPCWCH lpSrcStr, int cchSrc, LPWORD lpCharType)
     * }
     */
    public static FunctionDescriptor GetStringTypeExW$descriptor() {
        return GetStringTypeExW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetStringTypeExW(LCID Locale, DWORD dwInfoType, LPCWCH lpSrcStr, int cchSrc, LPWORD lpCharType)
     * }
     */
    public static MethodHandle GetStringTypeExW$handle() {
        return GetStringTypeExW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL GetStringTypeExW(LCID Locale, DWORD dwInfoType, LPCWCH lpSrcStr, int cchSrc, LPWORD lpCharType)
     * }
     */
    public static int GetStringTypeExW(int Locale, int dwInfoType, MemorySegment lpSrcStr, int cchSrc, MemorySegment lpCharType) {
        var mh$ = GetStringTypeExW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetStringTypeExW", Locale, dwInfoType, lpSrcStr, cchSrc, lpCharType);
            }
            return (int)mh$.invokeExact(Locale, dwInfoType, lpSrcStr, cchSrc, lpCharType);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetStringTypeW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_LONG,
            C_POINTER,
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetStringTypeW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetStringTypeW(DWORD dwInfoType, LPCWCH lpSrcStr, int cchSrc, LPWORD lpCharType)
     * }
     */
    public static FunctionDescriptor GetStringTypeW$descriptor() {
        return GetStringTypeW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetStringTypeW(DWORD dwInfoType, LPCWCH lpSrcStr, int cchSrc, LPWORD lpCharType)
     * }
     */
    public static MethodHandle GetStringTypeW$handle() {
        return GetStringTypeW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL GetStringTypeW(DWORD dwInfoType, LPCWCH lpSrcStr, int cchSrc, LPWORD lpCharType)
     * }
     */
    public static int GetStringTypeW(int dwInfoType, MemorySegment lpSrcStr, int cchSrc, MemorySegment lpCharType) {
        var mh$ = GetStringTypeW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetStringTypeW", dwInfoType, lpSrcStr, cchSrc, lpCharType);
            }
            return (int)mh$.invokeExact(dwInfoType, lpSrcStr, cchSrc, lpCharType);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MultiByteToWideChar {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_INT,
            C_LONG,
            C_POINTER,
            C_INT,
            C_POINTER,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("MultiByteToWideChar"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int MultiByteToWideChar(UINT CodePage, DWORD dwFlags, LPCCH lpMultiByteStr, int cbMultiByte, LPWSTR lpWideCharStr, int cchWideChar)
     * }
     */
    public static FunctionDescriptor MultiByteToWideChar$descriptor() {
        return MultiByteToWideChar.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int MultiByteToWideChar(UINT CodePage, DWORD dwFlags, LPCCH lpMultiByteStr, int cbMultiByte, LPWSTR lpWideCharStr, int cchWideChar)
     * }
     */
    public static MethodHandle MultiByteToWideChar$handle() {
        return MultiByteToWideChar.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int MultiByteToWideChar(UINT CodePage, DWORD dwFlags, LPCCH lpMultiByteStr, int cbMultiByte, LPWSTR lpWideCharStr, int cchWideChar)
     * }
     */
    public static int MultiByteToWideChar(int CodePage, int dwFlags, MemorySegment lpMultiByteStr, int cbMultiByte, MemorySegment lpWideCharStr, int cchWideChar) {
        var mh$ = MultiByteToWideChar.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MultiByteToWideChar", CodePage, dwFlags, lpMultiByteStr, cbMultiByte, lpWideCharStr, cchWideChar);
            }
            return (int)mh$.invokeExact(CodePage, dwFlags, lpMultiByteStr, cbMultiByte, lpWideCharStr, cchWideChar);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class WideCharToMultiByte {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_INT,
            C_LONG,
            C_POINTER,
            C_INT,
            C_POINTER,
            C_INT,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("WideCharToMultiByte"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int WideCharToMultiByte(UINT CodePage, DWORD dwFlags, LPCWCH lpWideCharStr, int cchWideChar, LPSTR lpMultiByteStr, int cbMultiByte, LPCCH lpDefaultChar, LPBOOL lpUsedDefaultChar)
     * }
     */
    public static FunctionDescriptor WideCharToMultiByte$descriptor() {
        return WideCharToMultiByte.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int WideCharToMultiByte(UINT CodePage, DWORD dwFlags, LPCWCH lpWideCharStr, int cchWideChar, LPSTR lpMultiByteStr, int cbMultiByte, LPCCH lpDefaultChar, LPBOOL lpUsedDefaultChar)
     * }
     */
    public static MethodHandle WideCharToMultiByte$handle() {
        return WideCharToMultiByte.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int WideCharToMultiByte(UINT CodePage, DWORD dwFlags, LPCWCH lpWideCharStr, int cchWideChar, LPSTR lpMultiByteStr, int cbMultiByte, LPCCH lpDefaultChar, LPBOOL lpUsedDefaultChar)
     * }
     */
    public static int WideCharToMultiByte(int CodePage, int dwFlags, MemorySegment lpWideCharStr, int cchWideChar, MemorySegment lpMultiByteStr, int cbMultiByte, MemorySegment lpDefaultChar, MemorySegment lpUsedDefaultChar) {
        var mh$ = WideCharToMultiByte.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WideCharToMultiByte", CodePage, dwFlags, lpWideCharStr, cchWideChar, lpMultiByteStr, cbMultiByte, lpDefaultChar, lpUsedDefaultChar);
            }
            return (int)mh$.invokeExact(CodePage, dwFlags, lpWideCharStr, cchWideChar, lpMultiByteStr, cbMultiByte, lpDefaultChar, lpUsedDefaultChar);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class IsValidCodePage {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("IsValidCodePage"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL IsValidCodePage(UINT CodePage)
     * }
     */
    public static FunctionDescriptor IsValidCodePage$descriptor() {
        return IsValidCodePage.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL IsValidCodePage(UINT CodePage)
     * }
     */
    public static MethodHandle IsValidCodePage$handle() {
        return IsValidCodePage.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL IsValidCodePage(UINT CodePage)
     * }
     */
    public static int IsValidCodePage(int CodePage) {
        var mh$ = IsValidCodePage.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("IsValidCodePage", CodePage);
            }
            return (int)mh$.invokeExact(CodePage);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetACP {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT    );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetACP"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * UINT GetACP()
     * }
     */
    public static FunctionDescriptor GetACP$descriptor() {
        return GetACP.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * UINT GetACP()
     * }
     */
    public static MethodHandle GetACP$handle() {
        return GetACP.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * UINT GetACP()
     * }
     */
    public static int GetACP() {
        var mh$ = GetACP.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetACP");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetOEMCP {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT    );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetOEMCP"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * UINT GetOEMCP()
     * }
     */
    public static FunctionDescriptor GetOEMCP$descriptor() {
        return GetOEMCP.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * UINT GetOEMCP()
     * }
     */
    public static MethodHandle GetOEMCP$handle() {
        return GetOEMCP.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * UINT GetOEMCP()
     * }
     */
    public static int GetOEMCP() {
        var mh$ = GetOEMCP.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetOEMCP");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetCPInfo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetCPInfo"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetCPInfo(UINT CodePage, LPCPINFO lpCPInfo)
     * }
     */
    public static FunctionDescriptor GetCPInfo$descriptor() {
        return GetCPInfo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetCPInfo(UINT CodePage, LPCPINFO lpCPInfo)
     * }
     */
    public static MethodHandle GetCPInfo$handle() {
        return GetCPInfo.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL GetCPInfo(UINT CodePage, LPCPINFO lpCPInfo)
     * }
     */
    public static int GetCPInfo(int CodePage, MemorySegment lpCPInfo) {
        var mh$ = GetCPInfo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetCPInfo", CodePage, lpCPInfo);
            }
            return (int)mh$.invokeExact(CodePage, lpCPInfo);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetCPInfoExA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_INT,
            C_LONG,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetCPInfoExA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetCPInfoExA(UINT CodePage, DWORD dwFlags, LPCPINFOEXA lpCPInfoEx)
     * }
     */
    public static FunctionDescriptor GetCPInfoExA$descriptor() {
        return GetCPInfoExA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetCPInfoExA(UINT CodePage, DWORD dwFlags, LPCPINFOEXA lpCPInfoEx)
     * }
     */
    public static MethodHandle GetCPInfoExA$handle() {
        return GetCPInfoExA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL GetCPInfoExA(UINT CodePage, DWORD dwFlags, LPCPINFOEXA lpCPInfoEx)
     * }
     */
    public static int GetCPInfoExA(int CodePage, int dwFlags, MemorySegment lpCPInfoEx) {
        var mh$ = GetCPInfoExA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetCPInfoExA", CodePage, dwFlags, lpCPInfoEx);
            }
            return (int)mh$.invokeExact(CodePage, dwFlags, lpCPInfoEx);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetCPInfoExW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_INT,
            C_LONG,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetCPInfoExW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetCPInfoExW(UINT CodePage, DWORD dwFlags, LPCPINFOEXW lpCPInfoEx)
     * }
     */
    public static FunctionDescriptor GetCPInfoExW$descriptor() {
        return GetCPInfoExW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetCPInfoExW(UINT CodePage, DWORD dwFlags, LPCPINFOEXW lpCPInfoEx)
     * }
     */
    public static MethodHandle GetCPInfoExW$handle() {
        return GetCPInfoExW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL GetCPInfoExW(UINT CodePage, DWORD dwFlags, LPCPINFOEXW lpCPInfoEx)
     * }
     */
    public static int GetCPInfoExW(int CodePage, int dwFlags, MemorySegment lpCPInfoEx) {
        var mh$ = GetCPInfoExW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetCPInfoExW", CodePage, dwFlags, lpCPInfoEx);
            }
            return (int)mh$.invokeExact(CodePage, dwFlags, lpCPInfoEx);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CompareStringA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_LONG,
            C_LONG,
            C_POINTER,
            C_INT,
            C_POINTER,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CompareStringA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int CompareStringA(LCID Locale, DWORD dwCmpFlags, PCNZCH lpString1, int cchCount1, PCNZCH lpString2, int cchCount2)
     * }
     */
    public static FunctionDescriptor CompareStringA$descriptor() {
        return CompareStringA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int CompareStringA(LCID Locale, DWORD dwCmpFlags, PCNZCH lpString1, int cchCount1, PCNZCH lpString2, int cchCount2)
     * }
     */
    public static MethodHandle CompareStringA$handle() {
        return CompareStringA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int CompareStringA(LCID Locale, DWORD dwCmpFlags, PCNZCH lpString1, int cchCount1, PCNZCH lpString2, int cchCount2)
     * }
     */
    public static int CompareStringA(int Locale, int dwCmpFlags, MemorySegment lpString1, int cchCount1, MemorySegment lpString2, int cchCount2) {
        var mh$ = CompareStringA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CompareStringA", Locale, dwCmpFlags, lpString1, cchCount1, lpString2, cchCount2);
            }
            return (int)mh$.invokeExact(Locale, dwCmpFlags, lpString1, cchCount1, lpString2, cchCount2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FindNLSString {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_LONG,
            C_LONG,
            C_POINTER,
            C_INT,
            C_POINTER,
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("FindNLSString"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int FindNLSString(LCID Locale, DWORD dwFindNLSStringFlags, LPCWSTR lpStringSource, int cchSource, LPCWSTR lpStringValue, int cchValue, LPINT pcchFound)
     * }
     */
    public static FunctionDescriptor FindNLSString$descriptor() {
        return FindNLSString.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int FindNLSString(LCID Locale, DWORD dwFindNLSStringFlags, LPCWSTR lpStringSource, int cchSource, LPCWSTR lpStringValue, int cchValue, LPINT pcchFound)
     * }
     */
    public static MethodHandle FindNLSString$handle() {
        return FindNLSString.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int FindNLSString(LCID Locale, DWORD dwFindNLSStringFlags, LPCWSTR lpStringSource, int cchSource, LPCWSTR lpStringValue, int cchValue, LPINT pcchFound)
     * }
     */
    public static int FindNLSString(int Locale, int dwFindNLSStringFlags, MemorySegment lpStringSource, int cchSource, MemorySegment lpStringValue, int cchValue, MemorySegment pcchFound) {
        var mh$ = FindNLSString.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FindNLSString", Locale, dwFindNLSStringFlags, lpStringSource, cchSource, lpStringValue, cchValue, pcchFound);
            }
            return (int)mh$.invokeExact(Locale, dwFindNLSStringFlags, lpStringSource, cchSource, lpStringValue, cchValue, pcchFound);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LCMapStringW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_LONG,
            C_LONG,
            C_POINTER,
            C_INT,
            C_POINTER,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("LCMapStringW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LCMapStringW(LCID Locale, DWORD dwMapFlags, LPCWSTR lpSrcStr, int cchSrc, LPWSTR lpDestStr, int cchDest)
     * }
     */
    public static FunctionDescriptor LCMapStringW$descriptor() {
        return LCMapStringW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LCMapStringW(LCID Locale, DWORD dwMapFlags, LPCWSTR lpSrcStr, int cchSrc, LPWSTR lpDestStr, int cchDest)
     * }
     */
    public static MethodHandle LCMapStringW$handle() {
        return LCMapStringW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int LCMapStringW(LCID Locale, DWORD dwMapFlags, LPCWSTR lpSrcStr, int cchSrc, LPWSTR lpDestStr, int cchDest)
     * }
     */
    public static int LCMapStringW(int Locale, int dwMapFlags, MemorySegment lpSrcStr, int cchSrc, MemorySegment lpDestStr, int cchDest) {
        var mh$ = LCMapStringW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LCMapStringW", Locale, dwMapFlags, lpSrcStr, cchSrc, lpDestStr, cchDest);
            }
            return (int)mh$.invokeExact(Locale, dwMapFlags, lpSrcStr, cchSrc, lpDestStr, cchDest);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LCMapStringA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_LONG,
            C_LONG,
            C_POINTER,
            C_INT,
            C_POINTER,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("LCMapStringA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LCMapStringA(LCID Locale, DWORD dwMapFlags, LPCSTR lpSrcStr, int cchSrc, LPSTR lpDestStr, int cchDest)
     * }
     */
    public static FunctionDescriptor LCMapStringA$descriptor() {
        return LCMapStringA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LCMapStringA(LCID Locale, DWORD dwMapFlags, LPCSTR lpSrcStr, int cchSrc, LPSTR lpDestStr, int cchDest)
     * }
     */
    public static MethodHandle LCMapStringA$handle() {
        return LCMapStringA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int LCMapStringA(LCID Locale, DWORD dwMapFlags, LPCSTR lpSrcStr, int cchSrc, LPSTR lpDestStr, int cchDest)
     * }
     */
    public static int LCMapStringA(int Locale, int dwMapFlags, MemorySegment lpSrcStr, int cchSrc, MemorySegment lpDestStr, int cchDest) {
        var mh$ = LCMapStringA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LCMapStringA", Locale, dwMapFlags, lpSrcStr, cchSrc, lpDestStr, cchDest);
            }
            return (int)mh$.invokeExact(Locale, dwMapFlags, lpSrcStr, cchSrc, lpDestStr, cchDest);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetLocaleInfoW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_LONG,
            C_LONG,
            C_POINTER,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetLocaleInfoW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int GetLocaleInfoW(LCID Locale, LCTYPE LCType, LPWSTR lpLCData, int cchData)
     * }
     */
    public static FunctionDescriptor GetLocaleInfoW$descriptor() {
        return GetLocaleInfoW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int GetLocaleInfoW(LCID Locale, LCTYPE LCType, LPWSTR lpLCData, int cchData)
     * }
     */
    public static MethodHandle GetLocaleInfoW$handle() {
        return GetLocaleInfoW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int GetLocaleInfoW(LCID Locale, LCTYPE LCType, LPWSTR lpLCData, int cchData)
     * }
     */
    public static int GetLocaleInfoW(int Locale, int LCType, MemorySegment lpLCData, int cchData) {
        var mh$ = GetLocaleInfoW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetLocaleInfoW", Locale, LCType, lpLCData, cchData);
            }
            return (int)mh$.invokeExact(Locale, LCType, lpLCData, cchData);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetLocaleInfoA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_LONG,
            C_LONG,
            C_POINTER,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetLocaleInfoA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int GetLocaleInfoA(LCID Locale, LCTYPE LCType, LPSTR lpLCData, int cchData)
     * }
     */
    public static FunctionDescriptor GetLocaleInfoA$descriptor() {
        return GetLocaleInfoA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int GetLocaleInfoA(LCID Locale, LCTYPE LCType, LPSTR lpLCData, int cchData)
     * }
     */
    public static MethodHandle GetLocaleInfoA$handle() {
        return GetLocaleInfoA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int GetLocaleInfoA(LCID Locale, LCTYPE LCType, LPSTR lpLCData, int cchData)
     * }
     */
    public static int GetLocaleInfoA(int Locale, int LCType, MemorySegment lpLCData, int cchData) {
        var mh$ = GetLocaleInfoA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetLocaleInfoA", Locale, LCType, lpLCData, cchData);
            }
            return (int)mh$.invokeExact(Locale, LCType, lpLCData, cchData);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetLocaleInfoA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_LONG,
            C_LONG,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("SetLocaleInfoA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetLocaleInfoA(LCID Locale, LCTYPE LCType, LPCSTR lpLCData)
     * }
     */
    public static FunctionDescriptor SetLocaleInfoA$descriptor() {
        return SetLocaleInfoA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetLocaleInfoA(LCID Locale, LCTYPE LCType, LPCSTR lpLCData)
     * }
     */
    public static MethodHandle SetLocaleInfoA$handle() {
        return SetLocaleInfoA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL SetLocaleInfoA(LCID Locale, LCTYPE LCType, LPCSTR lpLCData)
     * }
     */
    public static int SetLocaleInfoA(int Locale, int LCType, MemorySegment lpLCData) {
        var mh$ = SetLocaleInfoA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetLocaleInfoA", Locale, LCType, lpLCData);
            }
            return (int)mh$.invokeExact(Locale, LCType, lpLCData);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetLocaleInfoW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_LONG,
            C_LONG,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("SetLocaleInfoW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetLocaleInfoW(LCID Locale, LCTYPE LCType, LPCWSTR lpLCData)
     * }
     */
    public static FunctionDescriptor SetLocaleInfoW$descriptor() {
        return SetLocaleInfoW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetLocaleInfoW(LCID Locale, LCTYPE LCType, LPCWSTR lpLCData)
     * }
     */
    public static MethodHandle SetLocaleInfoW$handle() {
        return SetLocaleInfoW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL SetLocaleInfoW(LCID Locale, LCTYPE LCType, LPCWSTR lpLCData)
     * }
     */
    public static int SetLocaleInfoW(int Locale, int LCType, MemorySegment lpLCData) {
        var mh$ = SetLocaleInfoW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetLocaleInfoW", Locale, LCType, lpLCData);
            }
            return (int)mh$.invokeExact(Locale, LCType, lpLCData);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetCalendarInfoA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_LONG,
            C_LONG,
            C_LONG,
            C_POINTER,
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetCalendarInfoA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int GetCalendarInfoA(LCID Locale, CALID Calendar, CALTYPE CalType, LPSTR lpCalData, int cchData, LPDWORD lpValue)
     * }
     */
    public static FunctionDescriptor GetCalendarInfoA$descriptor() {
        return GetCalendarInfoA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int GetCalendarInfoA(LCID Locale, CALID Calendar, CALTYPE CalType, LPSTR lpCalData, int cchData, LPDWORD lpValue)
     * }
     */
    public static MethodHandle GetCalendarInfoA$handle() {
        return GetCalendarInfoA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int GetCalendarInfoA(LCID Locale, CALID Calendar, CALTYPE CalType, LPSTR lpCalData, int cchData, LPDWORD lpValue)
     * }
     */
    public static int GetCalendarInfoA(int Locale, int Calendar, int CalType, MemorySegment lpCalData, int cchData, MemorySegment lpValue) {
        var mh$ = GetCalendarInfoA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetCalendarInfoA", Locale, Calendar, CalType, lpCalData, cchData, lpValue);
            }
            return (int)mh$.invokeExact(Locale, Calendar, CalType, lpCalData, cchData, lpValue);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetCalendarInfoW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_LONG,
            C_LONG,
            C_LONG,
            C_POINTER,
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetCalendarInfoW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int GetCalendarInfoW(LCID Locale, CALID Calendar, CALTYPE CalType, LPWSTR lpCalData, int cchData, LPDWORD lpValue)
     * }
     */
    public static FunctionDescriptor GetCalendarInfoW$descriptor() {
        return GetCalendarInfoW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int GetCalendarInfoW(LCID Locale, CALID Calendar, CALTYPE CalType, LPWSTR lpCalData, int cchData, LPDWORD lpValue)
     * }
     */
    public static MethodHandle GetCalendarInfoW$handle() {
        return GetCalendarInfoW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int GetCalendarInfoW(LCID Locale, CALID Calendar, CALTYPE CalType, LPWSTR lpCalData, int cchData, LPDWORD lpValue)
     * }
     */
    public static int GetCalendarInfoW(int Locale, int Calendar, int CalType, MemorySegment lpCalData, int cchData, MemorySegment lpValue) {
        var mh$ = GetCalendarInfoW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetCalendarInfoW", Locale, Calendar, CalType, lpCalData, cchData, lpValue);
            }
            return (int)mh$.invokeExact(Locale, Calendar, CalType, lpCalData, cchData, lpValue);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetCalendarInfoA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_LONG,
            C_LONG,
            C_LONG,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("SetCalendarInfoA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetCalendarInfoA(LCID Locale, CALID Calendar, CALTYPE CalType, LPCSTR lpCalData)
     * }
     */
    public static FunctionDescriptor SetCalendarInfoA$descriptor() {
        return SetCalendarInfoA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetCalendarInfoA(LCID Locale, CALID Calendar, CALTYPE CalType, LPCSTR lpCalData)
     * }
     */
    public static MethodHandle SetCalendarInfoA$handle() {
        return SetCalendarInfoA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL SetCalendarInfoA(LCID Locale, CALID Calendar, CALTYPE CalType, LPCSTR lpCalData)
     * }
     */
    public static int SetCalendarInfoA(int Locale, int Calendar, int CalType, MemorySegment lpCalData) {
        var mh$ = SetCalendarInfoA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetCalendarInfoA", Locale, Calendar, CalType, lpCalData);
            }
            return (int)mh$.invokeExact(Locale, Calendar, CalType, lpCalData);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetCalendarInfoW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_LONG,
            C_LONG,
            C_LONG,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("SetCalendarInfoW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetCalendarInfoW(LCID Locale, CALID Calendar, CALTYPE CalType, LPCWSTR lpCalData)
     * }
     */
    public static FunctionDescriptor SetCalendarInfoW$descriptor() {
        return SetCalendarInfoW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetCalendarInfoW(LCID Locale, CALID Calendar, CALTYPE CalType, LPCWSTR lpCalData)
     * }
     */
    public static MethodHandle SetCalendarInfoW$handle() {
        return SetCalendarInfoW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL SetCalendarInfoW(LCID Locale, CALID Calendar, CALTYPE CalType, LPCWSTR lpCalData)
     * }
     */
    public static int SetCalendarInfoW(int Locale, int Calendar, int CalType, MemorySegment lpCalData) {
        var mh$ = SetCalendarInfoW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetCalendarInfoW", Locale, Calendar, CalType, lpCalData);
            }
            return (int)mh$.invokeExact(Locale, Calendar, CalType, lpCalData);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LoadStringByReference {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_LONG,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_LONG,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("LoadStringByReference"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL LoadStringByReference(DWORD Flags, PCWSTR Language, PCWSTR SourceString, PWSTR Buffer, ULONG cchBuffer, PCWSTR Directory, PULONG pcchBufferOut)
     * }
     */
    public static FunctionDescriptor LoadStringByReference$descriptor() {
        return LoadStringByReference.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL LoadStringByReference(DWORD Flags, PCWSTR Language, PCWSTR SourceString, PWSTR Buffer, ULONG cchBuffer, PCWSTR Directory, PULONG pcchBufferOut)
     * }
     */
    public static MethodHandle LoadStringByReference$handle() {
        return LoadStringByReference.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL LoadStringByReference(DWORD Flags, PCWSTR Language, PCWSTR SourceString, PWSTR Buffer, ULONG cchBuffer, PCWSTR Directory, PULONG pcchBufferOut)
     * }
     */
    public static int LoadStringByReference(int Flags, MemorySegment Language, MemorySegment SourceString, MemorySegment Buffer, int cchBuffer, MemorySegment Directory, MemorySegment pcchBufferOut) {
        var mh$ = LoadStringByReference.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LoadStringByReference", Flags, Language, SourceString, Buffer, cchBuffer, Directory, pcchBufferOut);
            }
            return (int)mh$.invokeExact(Flags, Language, SourceString, Buffer, cchBuffer, Directory, pcchBufferOut);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class IsDBCSLeadByte {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_CHAR
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("IsDBCSLeadByte"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL IsDBCSLeadByte(BYTE TestChar)
     * }
     */
    public static FunctionDescriptor IsDBCSLeadByte$descriptor() {
        return IsDBCSLeadByte.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL IsDBCSLeadByte(BYTE TestChar)
     * }
     */
    public static MethodHandle IsDBCSLeadByte$handle() {
        return IsDBCSLeadByte.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL IsDBCSLeadByte(BYTE TestChar)
     * }
     */
    public static int IsDBCSLeadByte(byte TestChar) {
        var mh$ = IsDBCSLeadByte.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("IsDBCSLeadByte", TestChar);
            }
            return (int)mh$.invokeExact(TestChar);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class IsDBCSLeadByteEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_INT,
            C_CHAR
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("IsDBCSLeadByteEx"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL IsDBCSLeadByteEx(UINT CodePage, BYTE TestChar)
     * }
     */
    public static FunctionDescriptor IsDBCSLeadByteEx$descriptor() {
        return IsDBCSLeadByteEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL IsDBCSLeadByteEx(UINT CodePage, BYTE TestChar)
     * }
     */
    public static MethodHandle IsDBCSLeadByteEx$handle() {
        return IsDBCSLeadByteEx.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL IsDBCSLeadByteEx(UINT CodePage, BYTE TestChar)
     * }
     */
    public static int IsDBCSLeadByteEx(int CodePage, byte TestChar) {
        var mh$ = IsDBCSLeadByteEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("IsDBCSLeadByteEx", CodePage, TestChar);
            }
            return (int)mh$.invokeExact(CodePage, TestChar);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LocaleNameToLCID {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_POINTER,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("LocaleNameToLCID"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LCID LocaleNameToLCID(LPCWSTR lpName, DWORD dwFlags)
     * }
     */
    public static FunctionDescriptor LocaleNameToLCID$descriptor() {
        return LocaleNameToLCID.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LCID LocaleNameToLCID(LPCWSTR lpName, DWORD dwFlags)
     * }
     */
    public static MethodHandle LocaleNameToLCID$handle() {
        return LocaleNameToLCID.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * LCID LocaleNameToLCID(LPCWSTR lpName, DWORD dwFlags)
     * }
     */
    public static int LocaleNameToLCID(MemorySegment lpName, int dwFlags) {
        var mh$ = LocaleNameToLCID.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LocaleNameToLCID", lpName, dwFlags);
            }
            return (int)mh$.invokeExact(lpName, dwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LCIDToLocaleName {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_LONG,
            C_POINTER,
            C_INT,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("LCIDToLocaleName"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LCIDToLocaleName(LCID Locale, LPWSTR lpName, int cchName, DWORD dwFlags)
     * }
     */
    public static FunctionDescriptor LCIDToLocaleName$descriptor() {
        return LCIDToLocaleName.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LCIDToLocaleName(LCID Locale, LPWSTR lpName, int cchName, DWORD dwFlags)
     * }
     */
    public static MethodHandle LCIDToLocaleName$handle() {
        return LCIDToLocaleName.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int LCIDToLocaleName(LCID Locale, LPWSTR lpName, int cchName, DWORD dwFlags)
     * }
     */
    public static int LCIDToLocaleName(int Locale, MemorySegment lpName, int cchName, int dwFlags) {
        var mh$ = LCIDToLocaleName.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LCIDToLocaleName", Locale, lpName, cchName, dwFlags);
            }
            return (int)mh$.invokeExact(Locale, lpName, cchName, dwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetDurationFormat {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_LONG,
            C_LONG,
            C_POINTER,
            C_LONG_LONG,
            C_POINTER,
            C_POINTER,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetDurationFormat"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int GetDurationFormat(LCID Locale, DWORD dwFlags, const SYSTEMTIME *lpDuration, ULONGLONG ullDuration, LPCWSTR lpFormat, LPWSTR lpDurationStr, int cchDuration)
     * }
     */
    public static FunctionDescriptor GetDurationFormat$descriptor() {
        return GetDurationFormat.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int GetDurationFormat(LCID Locale, DWORD dwFlags, const SYSTEMTIME *lpDuration, ULONGLONG ullDuration, LPCWSTR lpFormat, LPWSTR lpDurationStr, int cchDuration)
     * }
     */
    public static MethodHandle GetDurationFormat$handle() {
        return GetDurationFormat.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int GetDurationFormat(LCID Locale, DWORD dwFlags, const SYSTEMTIME *lpDuration, ULONGLONG ullDuration, LPCWSTR lpFormat, LPWSTR lpDurationStr, int cchDuration)
     * }
     */
    public static int GetDurationFormat(int Locale, int dwFlags, MemorySegment lpDuration, long ullDuration, MemorySegment lpFormat, MemorySegment lpDurationStr, int cchDuration) {
        var mh$ = GetDurationFormat.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetDurationFormat", Locale, dwFlags, lpDuration, ullDuration, lpFormat, lpDurationStr, cchDuration);
            }
            return (int)mh$.invokeExact(Locale, dwFlags, lpDuration, ullDuration, lpFormat, lpDurationStr, cchDuration);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetNumberFormatA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_LONG,
            C_LONG,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetNumberFormatA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int GetNumberFormatA(LCID Locale, DWORD dwFlags, LPCSTR lpValue, const NUMBERFMTA *lpFormat, LPSTR lpNumberStr, int cchNumber)
     * }
     */
    public static FunctionDescriptor GetNumberFormatA$descriptor() {
        return GetNumberFormatA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int GetNumberFormatA(LCID Locale, DWORD dwFlags, LPCSTR lpValue, const NUMBERFMTA *lpFormat, LPSTR lpNumberStr, int cchNumber)
     * }
     */
    public static MethodHandle GetNumberFormatA$handle() {
        return GetNumberFormatA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int GetNumberFormatA(LCID Locale, DWORD dwFlags, LPCSTR lpValue, const NUMBERFMTA *lpFormat, LPSTR lpNumberStr, int cchNumber)
     * }
     */
    public static int GetNumberFormatA(int Locale, int dwFlags, MemorySegment lpValue, MemorySegment lpFormat, MemorySegment lpNumberStr, int cchNumber) {
        var mh$ = GetNumberFormatA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetNumberFormatA", Locale, dwFlags, lpValue, lpFormat, lpNumberStr, cchNumber);
            }
            return (int)mh$.invokeExact(Locale, dwFlags, lpValue, lpFormat, lpNumberStr, cchNumber);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetNumberFormatW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_LONG,
            C_LONG,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetNumberFormatW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int GetNumberFormatW(LCID Locale, DWORD dwFlags, LPCWSTR lpValue, const NUMBERFMTW *lpFormat, LPWSTR lpNumberStr, int cchNumber)
     * }
     */
    public static FunctionDescriptor GetNumberFormatW$descriptor() {
        return GetNumberFormatW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int GetNumberFormatW(LCID Locale, DWORD dwFlags, LPCWSTR lpValue, const NUMBERFMTW *lpFormat, LPWSTR lpNumberStr, int cchNumber)
     * }
     */
    public static MethodHandle GetNumberFormatW$handle() {
        return GetNumberFormatW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int GetNumberFormatW(LCID Locale, DWORD dwFlags, LPCWSTR lpValue, const NUMBERFMTW *lpFormat, LPWSTR lpNumberStr, int cchNumber)
     * }
     */
    public static int GetNumberFormatW(int Locale, int dwFlags, MemorySegment lpValue, MemorySegment lpFormat, MemorySegment lpNumberStr, int cchNumber) {
        var mh$ = GetNumberFormatW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetNumberFormatW", Locale, dwFlags, lpValue, lpFormat, lpNumberStr, cchNumber);
            }
            return (int)mh$.invokeExact(Locale, dwFlags, lpValue, lpFormat, lpNumberStr, cchNumber);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetCurrencyFormatA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_LONG,
            C_LONG,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetCurrencyFormatA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int GetCurrencyFormatA(LCID Locale, DWORD dwFlags, LPCSTR lpValue, const CURRENCYFMTA *lpFormat, LPSTR lpCurrencyStr, int cchCurrency)
     * }
     */
    public static FunctionDescriptor GetCurrencyFormatA$descriptor() {
        return GetCurrencyFormatA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int GetCurrencyFormatA(LCID Locale, DWORD dwFlags, LPCSTR lpValue, const CURRENCYFMTA *lpFormat, LPSTR lpCurrencyStr, int cchCurrency)
     * }
     */
    public static MethodHandle GetCurrencyFormatA$handle() {
        return GetCurrencyFormatA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int GetCurrencyFormatA(LCID Locale, DWORD dwFlags, LPCSTR lpValue, const CURRENCYFMTA *lpFormat, LPSTR lpCurrencyStr, int cchCurrency)
     * }
     */
    public static int GetCurrencyFormatA(int Locale, int dwFlags, MemorySegment lpValue, MemorySegment lpFormat, MemorySegment lpCurrencyStr, int cchCurrency) {
        var mh$ = GetCurrencyFormatA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetCurrencyFormatA", Locale, dwFlags, lpValue, lpFormat, lpCurrencyStr, cchCurrency);
            }
            return (int)mh$.invokeExact(Locale, dwFlags, lpValue, lpFormat, lpCurrencyStr, cchCurrency);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetCurrencyFormatW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_LONG,
            C_LONG,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetCurrencyFormatW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int GetCurrencyFormatW(LCID Locale, DWORD dwFlags, LPCWSTR lpValue, const CURRENCYFMTW *lpFormat, LPWSTR lpCurrencyStr, int cchCurrency)
     * }
     */
    public static FunctionDescriptor GetCurrencyFormatW$descriptor() {
        return GetCurrencyFormatW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int GetCurrencyFormatW(LCID Locale, DWORD dwFlags, LPCWSTR lpValue, const CURRENCYFMTW *lpFormat, LPWSTR lpCurrencyStr, int cchCurrency)
     * }
     */
    public static MethodHandle GetCurrencyFormatW$handle() {
        return GetCurrencyFormatW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int GetCurrencyFormatW(LCID Locale, DWORD dwFlags, LPCWSTR lpValue, const CURRENCYFMTW *lpFormat, LPWSTR lpCurrencyStr, int cchCurrency)
     * }
     */
    public static int GetCurrencyFormatW(int Locale, int dwFlags, MemorySegment lpValue, MemorySegment lpFormat, MemorySegment lpCurrencyStr, int cchCurrency) {
        var mh$ = GetCurrencyFormatW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetCurrencyFormatW", Locale, dwFlags, lpValue, lpFormat, lpCurrencyStr, cchCurrency);
            }
            return (int)mh$.invokeExact(Locale, dwFlags, lpValue, lpFormat, lpCurrencyStr, cchCurrency);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class EnumCalendarInfoA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_LONG,
            C_LONG,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("EnumCalendarInfoA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL EnumCalendarInfoA(CALINFO_ENUMPROCA lpCalInfoEnumProc, LCID Locale, CALID Calendar, CALTYPE CalType)
     * }
     */
    public static FunctionDescriptor EnumCalendarInfoA$descriptor() {
        return EnumCalendarInfoA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL EnumCalendarInfoA(CALINFO_ENUMPROCA lpCalInfoEnumProc, LCID Locale, CALID Calendar, CALTYPE CalType)
     * }
     */
    public static MethodHandle EnumCalendarInfoA$handle() {
        return EnumCalendarInfoA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL EnumCalendarInfoA(CALINFO_ENUMPROCA lpCalInfoEnumProc, LCID Locale, CALID Calendar, CALTYPE CalType)
     * }
     */
    public static int EnumCalendarInfoA(MemorySegment lpCalInfoEnumProc, int Locale, int Calendar, int CalType) {
        var mh$ = EnumCalendarInfoA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("EnumCalendarInfoA", lpCalInfoEnumProc, Locale, Calendar, CalType);
            }
            return (int)mh$.invokeExact(lpCalInfoEnumProc, Locale, Calendar, CalType);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class EnumCalendarInfoW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_LONG,
            C_LONG,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("EnumCalendarInfoW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL EnumCalendarInfoW(CALINFO_ENUMPROCW lpCalInfoEnumProc, LCID Locale, CALID Calendar, CALTYPE CalType)
     * }
     */
    public static FunctionDescriptor EnumCalendarInfoW$descriptor() {
        return EnumCalendarInfoW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL EnumCalendarInfoW(CALINFO_ENUMPROCW lpCalInfoEnumProc, LCID Locale, CALID Calendar, CALTYPE CalType)
     * }
     */
    public static MethodHandle EnumCalendarInfoW$handle() {
        return EnumCalendarInfoW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL EnumCalendarInfoW(CALINFO_ENUMPROCW lpCalInfoEnumProc, LCID Locale, CALID Calendar, CALTYPE CalType)
     * }
     */
    public static int EnumCalendarInfoW(MemorySegment lpCalInfoEnumProc, int Locale, int Calendar, int CalType) {
        var mh$ = EnumCalendarInfoW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("EnumCalendarInfoW", lpCalInfoEnumProc, Locale, Calendar, CalType);
            }
            return (int)mh$.invokeExact(lpCalInfoEnumProc, Locale, Calendar, CalType);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class EnumCalendarInfoExA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_LONG,
            C_LONG,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("EnumCalendarInfoExA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL EnumCalendarInfoExA(CALINFO_ENUMPROCEXA lpCalInfoEnumProcEx, LCID Locale, CALID Calendar, CALTYPE CalType)
     * }
     */
    public static FunctionDescriptor EnumCalendarInfoExA$descriptor() {
        return EnumCalendarInfoExA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL EnumCalendarInfoExA(CALINFO_ENUMPROCEXA lpCalInfoEnumProcEx, LCID Locale, CALID Calendar, CALTYPE CalType)
     * }
     */
    public static MethodHandle EnumCalendarInfoExA$handle() {
        return EnumCalendarInfoExA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL EnumCalendarInfoExA(CALINFO_ENUMPROCEXA lpCalInfoEnumProcEx, LCID Locale, CALID Calendar, CALTYPE CalType)
     * }
     */
    public static int EnumCalendarInfoExA(MemorySegment lpCalInfoEnumProcEx, int Locale, int Calendar, int CalType) {
        var mh$ = EnumCalendarInfoExA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("EnumCalendarInfoExA", lpCalInfoEnumProcEx, Locale, Calendar, CalType);
            }
            return (int)mh$.invokeExact(lpCalInfoEnumProcEx, Locale, Calendar, CalType);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class EnumCalendarInfoExW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_LONG,
            C_LONG,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("EnumCalendarInfoExW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL EnumCalendarInfoExW(CALINFO_ENUMPROCEXW lpCalInfoEnumProcEx, LCID Locale, CALID Calendar, CALTYPE CalType)
     * }
     */
    public static FunctionDescriptor EnumCalendarInfoExW$descriptor() {
        return EnumCalendarInfoExW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL EnumCalendarInfoExW(CALINFO_ENUMPROCEXW lpCalInfoEnumProcEx, LCID Locale, CALID Calendar, CALTYPE CalType)
     * }
     */
    public static MethodHandle EnumCalendarInfoExW$handle() {
        return EnumCalendarInfoExW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL EnumCalendarInfoExW(CALINFO_ENUMPROCEXW lpCalInfoEnumProcEx, LCID Locale, CALID Calendar, CALTYPE CalType)
     * }
     */
    public static int EnumCalendarInfoExW(MemorySegment lpCalInfoEnumProcEx, int Locale, int Calendar, int CalType) {
        var mh$ = EnumCalendarInfoExW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("EnumCalendarInfoExW", lpCalInfoEnumProcEx, Locale, Calendar, CalType);
            }
            return (int)mh$.invokeExact(lpCalInfoEnumProcEx, Locale, Calendar, CalType);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class EnumTimeFormatsA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_LONG,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("EnumTimeFormatsA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL EnumTimeFormatsA(TIMEFMT_ENUMPROCA lpTimeFmtEnumProc, LCID Locale, DWORD dwFlags)
     * }
     */
    public static FunctionDescriptor EnumTimeFormatsA$descriptor() {
        return EnumTimeFormatsA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL EnumTimeFormatsA(TIMEFMT_ENUMPROCA lpTimeFmtEnumProc, LCID Locale, DWORD dwFlags)
     * }
     */
    public static MethodHandle EnumTimeFormatsA$handle() {
        return EnumTimeFormatsA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL EnumTimeFormatsA(TIMEFMT_ENUMPROCA lpTimeFmtEnumProc, LCID Locale, DWORD dwFlags)
     * }
     */
    public static int EnumTimeFormatsA(MemorySegment lpTimeFmtEnumProc, int Locale, int dwFlags) {
        var mh$ = EnumTimeFormatsA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("EnumTimeFormatsA", lpTimeFmtEnumProc, Locale, dwFlags);
            }
            return (int)mh$.invokeExact(lpTimeFmtEnumProc, Locale, dwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class EnumTimeFormatsW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_LONG,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("EnumTimeFormatsW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL EnumTimeFormatsW(TIMEFMT_ENUMPROCW lpTimeFmtEnumProc, LCID Locale, DWORD dwFlags)
     * }
     */
    public static FunctionDescriptor EnumTimeFormatsW$descriptor() {
        return EnumTimeFormatsW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL EnumTimeFormatsW(TIMEFMT_ENUMPROCW lpTimeFmtEnumProc, LCID Locale, DWORD dwFlags)
     * }
     */
    public static MethodHandle EnumTimeFormatsW$handle() {
        return EnumTimeFormatsW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL EnumTimeFormatsW(TIMEFMT_ENUMPROCW lpTimeFmtEnumProc, LCID Locale, DWORD dwFlags)
     * }
     */
    public static int EnumTimeFormatsW(MemorySegment lpTimeFmtEnumProc, int Locale, int dwFlags) {
        var mh$ = EnumTimeFormatsW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("EnumTimeFormatsW", lpTimeFmtEnumProc, Locale, dwFlags);
            }
            return (int)mh$.invokeExact(lpTimeFmtEnumProc, Locale, dwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class EnumDateFormatsA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_LONG,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("EnumDateFormatsA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL EnumDateFormatsA(DATEFMT_ENUMPROCA lpDateFmtEnumProc, LCID Locale, DWORD dwFlags)
     * }
     */
    public static FunctionDescriptor EnumDateFormatsA$descriptor() {
        return EnumDateFormatsA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL EnumDateFormatsA(DATEFMT_ENUMPROCA lpDateFmtEnumProc, LCID Locale, DWORD dwFlags)
     * }
     */
    public static MethodHandle EnumDateFormatsA$handle() {
        return EnumDateFormatsA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL EnumDateFormatsA(DATEFMT_ENUMPROCA lpDateFmtEnumProc, LCID Locale, DWORD dwFlags)
     * }
     */
    public static int EnumDateFormatsA(MemorySegment lpDateFmtEnumProc, int Locale, int dwFlags) {
        var mh$ = EnumDateFormatsA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("EnumDateFormatsA", lpDateFmtEnumProc, Locale, dwFlags);
            }
            return (int)mh$.invokeExact(lpDateFmtEnumProc, Locale, dwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class EnumDateFormatsW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_LONG,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("EnumDateFormatsW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL EnumDateFormatsW(DATEFMT_ENUMPROCW lpDateFmtEnumProc, LCID Locale, DWORD dwFlags)
     * }
     */
    public static FunctionDescriptor EnumDateFormatsW$descriptor() {
        return EnumDateFormatsW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL EnumDateFormatsW(DATEFMT_ENUMPROCW lpDateFmtEnumProc, LCID Locale, DWORD dwFlags)
     * }
     */
    public static MethodHandle EnumDateFormatsW$handle() {
        return EnumDateFormatsW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL EnumDateFormatsW(DATEFMT_ENUMPROCW lpDateFmtEnumProc, LCID Locale, DWORD dwFlags)
     * }
     */
    public static int EnumDateFormatsW(MemorySegment lpDateFmtEnumProc, int Locale, int dwFlags) {
        var mh$ = EnumDateFormatsW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("EnumDateFormatsW", lpDateFmtEnumProc, Locale, dwFlags);
            }
            return (int)mh$.invokeExact(lpDateFmtEnumProc, Locale, dwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class EnumDateFormatsExA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_LONG,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("EnumDateFormatsExA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL EnumDateFormatsExA(DATEFMT_ENUMPROCEXA lpDateFmtEnumProcEx, LCID Locale, DWORD dwFlags)
     * }
     */
    public static FunctionDescriptor EnumDateFormatsExA$descriptor() {
        return EnumDateFormatsExA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL EnumDateFormatsExA(DATEFMT_ENUMPROCEXA lpDateFmtEnumProcEx, LCID Locale, DWORD dwFlags)
     * }
     */
    public static MethodHandle EnumDateFormatsExA$handle() {
        return EnumDateFormatsExA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL EnumDateFormatsExA(DATEFMT_ENUMPROCEXA lpDateFmtEnumProcEx, LCID Locale, DWORD dwFlags)
     * }
     */
    public static int EnumDateFormatsExA(MemorySegment lpDateFmtEnumProcEx, int Locale, int dwFlags) {
        var mh$ = EnumDateFormatsExA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("EnumDateFormatsExA", lpDateFmtEnumProcEx, Locale, dwFlags);
            }
            return (int)mh$.invokeExact(lpDateFmtEnumProcEx, Locale, dwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class EnumDateFormatsExW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_LONG,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("EnumDateFormatsExW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL EnumDateFormatsExW(DATEFMT_ENUMPROCEXW lpDateFmtEnumProcEx, LCID Locale, DWORD dwFlags)
     * }
     */
    public static FunctionDescriptor EnumDateFormatsExW$descriptor() {
        return EnumDateFormatsExW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL EnumDateFormatsExW(DATEFMT_ENUMPROCEXW lpDateFmtEnumProcEx, LCID Locale, DWORD dwFlags)
     * }
     */
    public static MethodHandle EnumDateFormatsExW$handle() {
        return EnumDateFormatsExW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL EnumDateFormatsExW(DATEFMT_ENUMPROCEXW lpDateFmtEnumProcEx, LCID Locale, DWORD dwFlags)
     * }
     */
    public static int EnumDateFormatsExW(MemorySegment lpDateFmtEnumProcEx, int Locale, int dwFlags) {
        var mh$ = EnumDateFormatsExW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("EnumDateFormatsExW", lpDateFmtEnumProcEx, Locale, dwFlags);
            }
            return (int)mh$.invokeExact(lpDateFmtEnumProcEx, Locale, dwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class IsValidLanguageGroup {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_LONG,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("IsValidLanguageGroup"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL IsValidLanguageGroup(LGRPID LanguageGroup, DWORD dwFlags)
     * }
     */
    public static FunctionDescriptor IsValidLanguageGroup$descriptor() {
        return IsValidLanguageGroup.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL IsValidLanguageGroup(LGRPID LanguageGroup, DWORD dwFlags)
     * }
     */
    public static MethodHandle IsValidLanguageGroup$handle() {
        return IsValidLanguageGroup.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL IsValidLanguageGroup(LGRPID LanguageGroup, DWORD dwFlags)
     * }
     */
    public static int IsValidLanguageGroup(int LanguageGroup, int dwFlags) {
        var mh$ = IsValidLanguageGroup.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("IsValidLanguageGroup", LanguageGroup, dwFlags);
            }
            return (int)mh$.invokeExact(LanguageGroup, dwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetNLSVersion {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_LONG,
            C_LONG,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetNLSVersion"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetNLSVersion(NLS_FUNCTION Function, LCID Locale, LPNLSVERSIONINFO lpVersionInformation)
     * }
     */
    public static FunctionDescriptor GetNLSVersion$descriptor() {
        return GetNLSVersion.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetNLSVersion(NLS_FUNCTION Function, LCID Locale, LPNLSVERSIONINFO lpVersionInformation)
     * }
     */
    public static MethodHandle GetNLSVersion$handle() {
        return GetNLSVersion.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL GetNLSVersion(NLS_FUNCTION Function, LCID Locale, LPNLSVERSIONINFO lpVersionInformation)
     * }
     */
    public static int GetNLSVersion(int Function, int Locale, MemorySegment lpVersionInformation) {
        var mh$ = GetNLSVersion.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetNLSVersion", Function, Locale, lpVersionInformation);
            }
            return (int)mh$.invokeExact(Function, Locale, lpVersionInformation);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class IsValidLocale {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_LONG,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("IsValidLocale"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL IsValidLocale(LCID Locale, DWORD dwFlags)
     * }
     */
    public static FunctionDescriptor IsValidLocale$descriptor() {
        return IsValidLocale.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL IsValidLocale(LCID Locale, DWORD dwFlags)
     * }
     */
    public static MethodHandle IsValidLocale$handle() {
        return IsValidLocale.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL IsValidLocale(LCID Locale, DWORD dwFlags)
     * }
     */
    public static int IsValidLocale(int Locale, int dwFlags) {
        var mh$ = IsValidLocale.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("IsValidLocale", Locale, dwFlags);
            }
            return (int)mh$.invokeExact(Locale, dwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetGeoInfoA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_LONG,
            C_LONG,
            C_POINTER,
            C_INT,
            C_SHORT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetGeoInfoA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int GetGeoInfoA(GEOID Location, GEOTYPE GeoType, LPSTR lpGeoData, int cchData, LANGID LangId)
     * }
     */
    public static FunctionDescriptor GetGeoInfoA$descriptor() {
        return GetGeoInfoA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int GetGeoInfoA(GEOID Location, GEOTYPE GeoType, LPSTR lpGeoData, int cchData, LANGID LangId)
     * }
     */
    public static MethodHandle GetGeoInfoA$handle() {
        return GetGeoInfoA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int GetGeoInfoA(GEOID Location, GEOTYPE GeoType, LPSTR lpGeoData, int cchData, LANGID LangId)
     * }
     */
    public static int GetGeoInfoA(int Location, int GeoType, MemorySegment lpGeoData, int cchData, short LangId) {
        var mh$ = GetGeoInfoA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetGeoInfoA", Location, GeoType, lpGeoData, cchData, LangId);
            }
            return (int)mh$.invokeExact(Location, GeoType, lpGeoData, cchData, LangId);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetGeoInfoW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_LONG,
            C_LONG,
            C_POINTER,
            C_INT,
            C_SHORT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetGeoInfoW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int GetGeoInfoW(GEOID Location, GEOTYPE GeoType, LPWSTR lpGeoData, int cchData, LANGID LangId)
     * }
     */
    public static FunctionDescriptor GetGeoInfoW$descriptor() {
        return GetGeoInfoW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int GetGeoInfoW(GEOID Location, GEOTYPE GeoType, LPWSTR lpGeoData, int cchData, LANGID LangId)
     * }
     */
    public static MethodHandle GetGeoInfoW$handle() {
        return GetGeoInfoW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int GetGeoInfoW(GEOID Location, GEOTYPE GeoType, LPWSTR lpGeoData, int cchData, LANGID LangId)
     * }
     */
    public static int GetGeoInfoW(int Location, int GeoType, MemorySegment lpGeoData, int cchData, short LangId) {
        var mh$ = GetGeoInfoW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetGeoInfoW", Location, GeoType, lpGeoData, cchData, LangId);
            }
            return (int)mh$.invokeExact(Location, GeoType, lpGeoData, cchData, LangId);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetGeoInfoEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_LONG,
            C_POINTER,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetGeoInfoEx"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int GetGeoInfoEx(PWSTR location, GEOTYPE geoType, PWSTR geoData, int geoDataCount)
     * }
     */
    public static FunctionDescriptor GetGeoInfoEx$descriptor() {
        return GetGeoInfoEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int GetGeoInfoEx(PWSTR location, GEOTYPE geoType, PWSTR geoData, int geoDataCount)
     * }
     */
    public static MethodHandle GetGeoInfoEx$handle() {
        return GetGeoInfoEx.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int GetGeoInfoEx(PWSTR location, GEOTYPE geoType, PWSTR geoData, int geoDataCount)
     * }
     */
    public static int GetGeoInfoEx(MemorySegment location, int geoType, MemorySegment geoData, int geoDataCount) {
        var mh$ = GetGeoInfoEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetGeoInfoEx", location, geoType, geoData, geoDataCount);
            }
            return (int)mh$.invokeExact(location, geoType, geoData, geoDataCount);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class EnumSystemGeoID {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_LONG,
            C_LONG,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("EnumSystemGeoID"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL EnumSystemGeoID(GEOCLASS GeoClass, GEOID ParentGeoId, GEO_ENUMPROC lpGeoEnumProc)
     * }
     */
    public static FunctionDescriptor EnumSystemGeoID$descriptor() {
        return EnumSystemGeoID.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL EnumSystemGeoID(GEOCLASS GeoClass, GEOID ParentGeoId, GEO_ENUMPROC lpGeoEnumProc)
     * }
     */
    public static MethodHandle EnumSystemGeoID$handle() {
        return EnumSystemGeoID.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL EnumSystemGeoID(GEOCLASS GeoClass, GEOID ParentGeoId, GEO_ENUMPROC lpGeoEnumProc)
     * }
     */
    public static int EnumSystemGeoID(int GeoClass, int ParentGeoId, MemorySegment lpGeoEnumProc) {
        var mh$ = EnumSystemGeoID.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("EnumSystemGeoID", GeoClass, ParentGeoId, lpGeoEnumProc);
            }
            return (int)mh$.invokeExact(GeoClass, ParentGeoId, lpGeoEnumProc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class EnumSystemGeoNames {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_LONG,
            C_POINTER,
            C_LONG_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("EnumSystemGeoNames"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL EnumSystemGeoNames(GEOCLASS geoClass, GEO_ENUMNAMEPROC geoEnumProc, LPARAM data)
     * }
     */
    public static FunctionDescriptor EnumSystemGeoNames$descriptor() {
        return EnumSystemGeoNames.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL EnumSystemGeoNames(GEOCLASS geoClass, GEO_ENUMNAMEPROC geoEnumProc, LPARAM data)
     * }
     */
    public static MethodHandle EnumSystemGeoNames$handle() {
        return EnumSystemGeoNames.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL EnumSystemGeoNames(GEOCLASS geoClass, GEO_ENUMNAMEPROC geoEnumProc, LPARAM data)
     * }
     */
    public static int EnumSystemGeoNames(int geoClass, MemorySegment geoEnumProc, long data) {
        var mh$ = EnumSystemGeoNames.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("EnumSystemGeoNames", geoClass, geoEnumProc, data);
            }
            return (int)mh$.invokeExact(geoClass, geoEnumProc, data);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetUserGeoID {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetUserGeoID"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * GEOID GetUserGeoID(GEOCLASS GeoClass)
     * }
     */
    public static FunctionDescriptor GetUserGeoID$descriptor() {
        return GetUserGeoID.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * GEOID GetUserGeoID(GEOCLASS GeoClass)
     * }
     */
    public static MethodHandle GetUserGeoID$handle() {
        return GetUserGeoID.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * GEOID GetUserGeoID(GEOCLASS GeoClass)
     * }
     */
    public static int GetUserGeoID(int GeoClass) {
        var mh$ = GetUserGeoID.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetUserGeoID", GeoClass);
            }
            return (int)mh$.invokeExact(GeoClass);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetUserDefaultGeoName {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetUserDefaultGeoName"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int GetUserDefaultGeoName(LPWSTR geoName, int geoNameCount)
     * }
     */
    public static FunctionDescriptor GetUserDefaultGeoName$descriptor() {
        return GetUserDefaultGeoName.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int GetUserDefaultGeoName(LPWSTR geoName, int geoNameCount)
     * }
     */
    public static MethodHandle GetUserDefaultGeoName$handle() {
        return GetUserDefaultGeoName.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int GetUserDefaultGeoName(LPWSTR geoName, int geoNameCount)
     * }
     */
    public static int GetUserDefaultGeoName(MemorySegment geoName, int geoNameCount) {
        var mh$ = GetUserDefaultGeoName.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetUserDefaultGeoName", geoName, geoNameCount);
            }
            return (int)mh$.invokeExact(geoName, geoNameCount);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetUserGeoID {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("SetUserGeoID"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetUserGeoID(GEOID GeoId)
     * }
     */
    public static FunctionDescriptor SetUserGeoID$descriptor() {
        return SetUserGeoID.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetUserGeoID(GEOID GeoId)
     * }
     */
    public static MethodHandle SetUserGeoID$handle() {
        return SetUserGeoID.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL SetUserGeoID(GEOID GeoId)
     * }
     */
    public static int SetUserGeoID(int GeoId) {
        var mh$ = SetUserGeoID.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetUserGeoID", GeoId);
            }
            return (int)mh$.invokeExact(GeoId);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetUserGeoName {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("SetUserGeoName"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetUserGeoName(PWSTR geoName)
     * }
     */
    public static FunctionDescriptor SetUserGeoName$descriptor() {
        return SetUserGeoName.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetUserGeoName(PWSTR geoName)
     * }
     */
    public static MethodHandle SetUserGeoName$handle() {
        return SetUserGeoName.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL SetUserGeoName(PWSTR geoName)
     * }
     */
    public static int SetUserGeoName(MemorySegment geoName) {
        var mh$ = SetUserGeoName.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetUserGeoName", geoName);
            }
            return (int)mh$.invokeExact(geoName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ConvertDefaultLocale {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("ConvertDefaultLocale"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LCID ConvertDefaultLocale(LCID Locale)
     * }
     */
    public static FunctionDescriptor ConvertDefaultLocale$descriptor() {
        return ConvertDefaultLocale.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LCID ConvertDefaultLocale(LCID Locale)
     * }
     */
    public static MethodHandle ConvertDefaultLocale$handle() {
        return ConvertDefaultLocale.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * LCID ConvertDefaultLocale(LCID Locale)
     * }
     */
    public static int ConvertDefaultLocale(int Locale) {
        var mh$ = ConvertDefaultLocale.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ConvertDefaultLocale", Locale);
            }
            return (int)mh$.invokeExact(Locale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetSystemDefaultUILanguage {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_SHORT    );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetSystemDefaultUILanguage"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LANGID GetSystemDefaultUILanguage()
     * }
     */
    public static FunctionDescriptor GetSystemDefaultUILanguage$descriptor() {
        return GetSystemDefaultUILanguage.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LANGID GetSystemDefaultUILanguage()
     * }
     */
    public static MethodHandle GetSystemDefaultUILanguage$handle() {
        return GetSystemDefaultUILanguage.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * LANGID GetSystemDefaultUILanguage()
     * }
     */
    public static short GetSystemDefaultUILanguage() {
        var mh$ = GetSystemDefaultUILanguage.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetSystemDefaultUILanguage");
            }
            return (short)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetThreadLocale {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG    );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetThreadLocale"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LCID GetThreadLocale()
     * }
     */
    public static FunctionDescriptor GetThreadLocale$descriptor() {
        return GetThreadLocale.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LCID GetThreadLocale()
     * }
     */
    public static MethodHandle GetThreadLocale$handle() {
        return GetThreadLocale.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * LCID GetThreadLocale()
     * }
     */
    public static int GetThreadLocale() {
        var mh$ = GetThreadLocale.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetThreadLocale");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetThreadLocale {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("SetThreadLocale"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetThreadLocale(LCID Locale)
     * }
     */
    public static FunctionDescriptor SetThreadLocale$descriptor() {
        return SetThreadLocale.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetThreadLocale(LCID Locale)
     * }
     */
    public static MethodHandle SetThreadLocale$handle() {
        return SetThreadLocale.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL SetThreadLocale(LCID Locale)
     * }
     */
    public static int SetThreadLocale(int Locale) {
        var mh$ = SetThreadLocale.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetThreadLocale", Locale);
            }
            return (int)mh$.invokeExact(Locale);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetUserDefaultUILanguage {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_SHORT    );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetUserDefaultUILanguage"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LANGID GetUserDefaultUILanguage()
     * }
     */
    public static FunctionDescriptor GetUserDefaultUILanguage$descriptor() {
        return GetUserDefaultUILanguage.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LANGID GetUserDefaultUILanguage()
     * }
     */
    public static MethodHandle GetUserDefaultUILanguage$handle() {
        return GetUserDefaultUILanguage.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * LANGID GetUserDefaultUILanguage()
     * }
     */
    public static short GetUserDefaultUILanguage() {
        var mh$ = GetUserDefaultUILanguage.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetUserDefaultUILanguage");
            }
            return (short)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetUserDefaultLangID {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_SHORT    );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetUserDefaultLangID"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LANGID GetUserDefaultLangID()
     * }
     */
    public static FunctionDescriptor GetUserDefaultLangID$descriptor() {
        return GetUserDefaultLangID.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LANGID GetUserDefaultLangID()
     * }
     */
    public static MethodHandle GetUserDefaultLangID$handle() {
        return GetUserDefaultLangID.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * LANGID GetUserDefaultLangID()
     * }
     */
    public static short GetUserDefaultLangID() {
        var mh$ = GetUserDefaultLangID.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetUserDefaultLangID");
            }
            return (short)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetSystemDefaultLangID {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_SHORT    );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetSystemDefaultLangID"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LANGID GetSystemDefaultLangID()
     * }
     */
    public static FunctionDescriptor GetSystemDefaultLangID$descriptor() {
        return GetSystemDefaultLangID.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LANGID GetSystemDefaultLangID()
     * }
     */
    public static MethodHandle GetSystemDefaultLangID$handle() {
        return GetSystemDefaultLangID.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * LANGID GetSystemDefaultLangID()
     * }
     */
    public static short GetSystemDefaultLangID() {
        var mh$ = GetSystemDefaultLangID.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetSystemDefaultLangID");
            }
            return (short)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetSystemDefaultLCID {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG    );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetSystemDefaultLCID"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LCID GetSystemDefaultLCID()
     * }
     */
    public static FunctionDescriptor GetSystemDefaultLCID$descriptor() {
        return GetSystemDefaultLCID.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LCID GetSystemDefaultLCID()
     * }
     */
    public static MethodHandle GetSystemDefaultLCID$handle() {
        return GetSystemDefaultLCID.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * LCID GetSystemDefaultLCID()
     * }
     */
    public static int GetSystemDefaultLCID() {
        var mh$ = GetSystemDefaultLCID.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetSystemDefaultLCID");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetUserDefaultLCID {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG    );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetUserDefaultLCID"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LCID GetUserDefaultLCID()
     * }
     */
    public static FunctionDescriptor GetUserDefaultLCID$descriptor() {
        return GetUserDefaultLCID.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LCID GetUserDefaultLCID()
     * }
     */
    public static MethodHandle GetUserDefaultLCID$handle() {
        return GetUserDefaultLCID.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * LCID GetUserDefaultLCID()
     * }
     */
    public static int GetUserDefaultLCID() {
        var mh$ = GetUserDefaultLCID.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetUserDefaultLCID");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetThreadUILanguage {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_SHORT,
            C_SHORT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("SetThreadUILanguage"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LANGID SetThreadUILanguage(LANGID LangId)
     * }
     */
    public static FunctionDescriptor SetThreadUILanguage$descriptor() {
        return SetThreadUILanguage.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LANGID SetThreadUILanguage(LANGID LangId)
     * }
     */
    public static MethodHandle SetThreadUILanguage$handle() {
        return SetThreadUILanguage.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * LANGID SetThreadUILanguage(LANGID LangId)
     * }
     */
    public static short SetThreadUILanguage(short LangId) {
        var mh$ = SetThreadUILanguage.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetThreadUILanguage", LangId);
            }
            return (short)mh$.invokeExact(LangId);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetThreadUILanguage {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_SHORT    );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetThreadUILanguage"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LANGID GetThreadUILanguage()
     * }
     */
    public static FunctionDescriptor GetThreadUILanguage$descriptor() {
        return GetThreadUILanguage.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LANGID GetThreadUILanguage()
     * }
     */
    public static MethodHandle GetThreadUILanguage$handle() {
        return GetThreadUILanguage.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * LANGID GetThreadUILanguage()
     * }
     */
    public static short GetThreadUILanguage() {
        var mh$ = GetThreadUILanguage.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetThreadUILanguage");
            }
            return (short)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetProcessPreferredUILanguages {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_LONG,
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetProcessPreferredUILanguages"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetProcessPreferredUILanguages(DWORD dwFlags, PULONG pulNumLanguages, PZZWSTR pwszLanguagesBuffer, PULONG pcchLanguagesBuffer)
     * }
     */
    public static FunctionDescriptor GetProcessPreferredUILanguages$descriptor() {
        return GetProcessPreferredUILanguages.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetProcessPreferredUILanguages(DWORD dwFlags, PULONG pulNumLanguages, PZZWSTR pwszLanguagesBuffer, PULONG pcchLanguagesBuffer)
     * }
     */
    public static MethodHandle GetProcessPreferredUILanguages$handle() {
        return GetProcessPreferredUILanguages.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL GetProcessPreferredUILanguages(DWORD dwFlags, PULONG pulNumLanguages, PZZWSTR pwszLanguagesBuffer, PULONG pcchLanguagesBuffer)
     * }
     */
    public static int GetProcessPreferredUILanguages(int dwFlags, MemorySegment pulNumLanguages, MemorySegment pwszLanguagesBuffer, MemorySegment pcchLanguagesBuffer) {
        var mh$ = GetProcessPreferredUILanguages.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetProcessPreferredUILanguages", dwFlags, pulNumLanguages, pwszLanguagesBuffer, pcchLanguagesBuffer);
            }
            return (int)mh$.invokeExact(dwFlags, pulNumLanguages, pwszLanguagesBuffer, pcchLanguagesBuffer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetProcessPreferredUILanguages {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_LONG,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("SetProcessPreferredUILanguages"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetProcessPreferredUILanguages(DWORD dwFlags, PCZZWSTR pwszLanguagesBuffer, PULONG pulNumLanguages)
     * }
     */
    public static FunctionDescriptor SetProcessPreferredUILanguages$descriptor() {
        return SetProcessPreferredUILanguages.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetProcessPreferredUILanguages(DWORD dwFlags, PCZZWSTR pwszLanguagesBuffer, PULONG pulNumLanguages)
     * }
     */
    public static MethodHandle SetProcessPreferredUILanguages$handle() {
        return SetProcessPreferredUILanguages.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL SetProcessPreferredUILanguages(DWORD dwFlags, PCZZWSTR pwszLanguagesBuffer, PULONG pulNumLanguages)
     * }
     */
    public static int SetProcessPreferredUILanguages(int dwFlags, MemorySegment pwszLanguagesBuffer, MemorySegment pulNumLanguages) {
        var mh$ = SetProcessPreferredUILanguages.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetProcessPreferredUILanguages", dwFlags, pwszLanguagesBuffer, pulNumLanguages);
            }
            return (int)mh$.invokeExact(dwFlags, pwszLanguagesBuffer, pulNumLanguages);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetUserPreferredUILanguages {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_LONG,
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetUserPreferredUILanguages"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetUserPreferredUILanguages(DWORD dwFlags, PULONG pulNumLanguages, PZZWSTR pwszLanguagesBuffer, PULONG pcchLanguagesBuffer)
     * }
     */
    public static FunctionDescriptor GetUserPreferredUILanguages$descriptor() {
        return GetUserPreferredUILanguages.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetUserPreferredUILanguages(DWORD dwFlags, PULONG pulNumLanguages, PZZWSTR pwszLanguagesBuffer, PULONG pcchLanguagesBuffer)
     * }
     */
    public static MethodHandle GetUserPreferredUILanguages$handle() {
        return GetUserPreferredUILanguages.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL GetUserPreferredUILanguages(DWORD dwFlags, PULONG pulNumLanguages, PZZWSTR pwszLanguagesBuffer, PULONG pcchLanguagesBuffer)
     * }
     */
    public static int GetUserPreferredUILanguages(int dwFlags, MemorySegment pulNumLanguages, MemorySegment pwszLanguagesBuffer, MemorySegment pcchLanguagesBuffer) {
        var mh$ = GetUserPreferredUILanguages.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetUserPreferredUILanguages", dwFlags, pulNumLanguages, pwszLanguagesBuffer, pcchLanguagesBuffer);
            }
            return (int)mh$.invokeExact(dwFlags, pulNumLanguages, pwszLanguagesBuffer, pcchLanguagesBuffer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetSystemPreferredUILanguages {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_LONG,
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetSystemPreferredUILanguages"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetSystemPreferredUILanguages(DWORD dwFlags, PULONG pulNumLanguages, PZZWSTR pwszLanguagesBuffer, PULONG pcchLanguagesBuffer)
     * }
     */
    public static FunctionDescriptor GetSystemPreferredUILanguages$descriptor() {
        return GetSystemPreferredUILanguages.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetSystemPreferredUILanguages(DWORD dwFlags, PULONG pulNumLanguages, PZZWSTR pwszLanguagesBuffer, PULONG pcchLanguagesBuffer)
     * }
     */
    public static MethodHandle GetSystemPreferredUILanguages$handle() {
        return GetSystemPreferredUILanguages.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL GetSystemPreferredUILanguages(DWORD dwFlags, PULONG pulNumLanguages, PZZWSTR pwszLanguagesBuffer, PULONG pcchLanguagesBuffer)
     * }
     */
    public static int GetSystemPreferredUILanguages(int dwFlags, MemorySegment pulNumLanguages, MemorySegment pwszLanguagesBuffer, MemorySegment pcchLanguagesBuffer) {
        var mh$ = GetSystemPreferredUILanguages.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetSystemPreferredUILanguages", dwFlags, pulNumLanguages, pwszLanguagesBuffer, pcchLanguagesBuffer);
            }
            return (int)mh$.invokeExact(dwFlags, pulNumLanguages, pwszLanguagesBuffer, pcchLanguagesBuffer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetThreadPreferredUILanguages {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_LONG,
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetThreadPreferredUILanguages"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetThreadPreferredUILanguages(DWORD dwFlags, PULONG pulNumLanguages, PZZWSTR pwszLanguagesBuffer, PULONG pcchLanguagesBuffer)
     * }
     */
    public static FunctionDescriptor GetThreadPreferredUILanguages$descriptor() {
        return GetThreadPreferredUILanguages.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetThreadPreferredUILanguages(DWORD dwFlags, PULONG pulNumLanguages, PZZWSTR pwszLanguagesBuffer, PULONG pcchLanguagesBuffer)
     * }
     */
    public static MethodHandle GetThreadPreferredUILanguages$handle() {
        return GetThreadPreferredUILanguages.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL GetThreadPreferredUILanguages(DWORD dwFlags, PULONG pulNumLanguages, PZZWSTR pwszLanguagesBuffer, PULONG pcchLanguagesBuffer)
     * }
     */
    public static int GetThreadPreferredUILanguages(int dwFlags, MemorySegment pulNumLanguages, MemorySegment pwszLanguagesBuffer, MemorySegment pcchLanguagesBuffer) {
        var mh$ = GetThreadPreferredUILanguages.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetThreadPreferredUILanguages", dwFlags, pulNumLanguages, pwszLanguagesBuffer, pcchLanguagesBuffer);
            }
            return (int)mh$.invokeExact(dwFlags, pulNumLanguages, pwszLanguagesBuffer, pcchLanguagesBuffer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetThreadPreferredUILanguages {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_LONG,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("SetThreadPreferredUILanguages"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetThreadPreferredUILanguages(DWORD dwFlags, PCZZWSTR pwszLanguagesBuffer, PULONG pulNumLanguages)
     * }
     */
    public static FunctionDescriptor SetThreadPreferredUILanguages$descriptor() {
        return SetThreadPreferredUILanguages.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetThreadPreferredUILanguages(DWORD dwFlags, PCZZWSTR pwszLanguagesBuffer, PULONG pulNumLanguages)
     * }
     */
    public static MethodHandle SetThreadPreferredUILanguages$handle() {
        return SetThreadPreferredUILanguages.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL SetThreadPreferredUILanguages(DWORD dwFlags, PCZZWSTR pwszLanguagesBuffer, PULONG pulNumLanguages)
     * }
     */
    public static int SetThreadPreferredUILanguages(int dwFlags, MemorySegment pwszLanguagesBuffer, MemorySegment pulNumLanguages) {
        var mh$ = SetThreadPreferredUILanguages.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetThreadPreferredUILanguages", dwFlags, pwszLanguagesBuffer, pulNumLanguages);
            }
            return (int)mh$.invokeExact(dwFlags, pwszLanguagesBuffer, pulNumLanguages);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetFileMUIInfo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_LONG,
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetFileMUIInfo"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetFileMUIInfo(DWORD dwFlags, PCWSTR pcwszFilePath, PFILEMUIINFO pFileMUIInfo, DWORD *pcbFileMUIInfo)
     * }
     */
    public static FunctionDescriptor GetFileMUIInfo$descriptor() {
        return GetFileMUIInfo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetFileMUIInfo(DWORD dwFlags, PCWSTR pcwszFilePath, PFILEMUIINFO pFileMUIInfo, DWORD *pcbFileMUIInfo)
     * }
     */
    public static MethodHandle GetFileMUIInfo$handle() {
        return GetFileMUIInfo.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL GetFileMUIInfo(DWORD dwFlags, PCWSTR pcwszFilePath, PFILEMUIINFO pFileMUIInfo, DWORD *pcbFileMUIInfo)
     * }
     */
    public static int GetFileMUIInfo(int dwFlags, MemorySegment pcwszFilePath, MemorySegment pFileMUIInfo, MemorySegment pcbFileMUIInfo) {
        var mh$ = GetFileMUIInfo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetFileMUIInfo", dwFlags, pcwszFilePath, pFileMUIInfo, pcbFileMUIInfo);
            }
            return (int)mh$.invokeExact(dwFlags, pcwszFilePath, pFileMUIInfo, pcbFileMUIInfo);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetFileMUIPath {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_LONG,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetFileMUIPath"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetFileMUIPath(DWORD dwFlags, PCWSTR pcwszFilePath, PWSTR pwszLanguage, PULONG pcchLanguage, PWSTR pwszFileMUIPath, PULONG pcchFileMUIPath, PULONGLONG pululEnumerator)
     * }
     */
    public static FunctionDescriptor GetFileMUIPath$descriptor() {
        return GetFileMUIPath.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetFileMUIPath(DWORD dwFlags, PCWSTR pcwszFilePath, PWSTR pwszLanguage, PULONG pcchLanguage, PWSTR pwszFileMUIPath, PULONG pcchFileMUIPath, PULONGLONG pululEnumerator)
     * }
     */
    public static MethodHandle GetFileMUIPath$handle() {
        return GetFileMUIPath.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL GetFileMUIPath(DWORD dwFlags, PCWSTR pcwszFilePath, PWSTR pwszLanguage, PULONG pcchLanguage, PWSTR pwszFileMUIPath, PULONG pcchFileMUIPath, PULONGLONG pululEnumerator)
     * }
     */
    public static int GetFileMUIPath(int dwFlags, MemorySegment pcwszFilePath, MemorySegment pwszLanguage, MemorySegment pcchLanguage, MemorySegment pwszFileMUIPath, MemorySegment pcchFileMUIPath, MemorySegment pululEnumerator) {
        var mh$ = GetFileMUIPath.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetFileMUIPath", dwFlags, pcwszFilePath, pwszLanguage, pcchLanguage, pwszFileMUIPath, pcchFileMUIPath, pululEnumerator);
            }
            return (int)mh$.invokeExact(dwFlags, pcwszFilePath, pwszLanguage, pcchLanguage, pwszFileMUIPath, pcchFileMUIPath, pululEnumerator);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetUILanguageInfo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_LONG,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetUILanguageInfo"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetUILanguageInfo(DWORD dwFlags, PCZZWSTR pwmszLanguage, PZZWSTR pwszFallbackLanguages, PDWORD pcchFallbackLanguages, PDWORD pAttributes)
     * }
     */
    public static FunctionDescriptor GetUILanguageInfo$descriptor() {
        return GetUILanguageInfo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetUILanguageInfo(DWORD dwFlags, PCZZWSTR pwmszLanguage, PZZWSTR pwszFallbackLanguages, PDWORD pcchFallbackLanguages, PDWORD pAttributes)
     * }
     */
    public static MethodHandle GetUILanguageInfo$handle() {
        return GetUILanguageInfo.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL GetUILanguageInfo(DWORD dwFlags, PCZZWSTR pwmszLanguage, PZZWSTR pwszFallbackLanguages, PDWORD pcchFallbackLanguages, PDWORD pAttributes)
     * }
     */
    public static int GetUILanguageInfo(int dwFlags, MemorySegment pwmszLanguage, MemorySegment pwszFallbackLanguages, MemorySegment pcchFallbackLanguages, MemorySegment pAttributes) {
        var mh$ = GetUILanguageInfo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetUILanguageInfo", dwFlags, pwmszLanguage, pwszFallbackLanguages, pcchFallbackLanguages, pAttributes);
            }
            return (int)mh$.invokeExact(dwFlags, pwmszLanguage, pwszFallbackLanguages, pcchFallbackLanguages, pAttributes);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct HSAVEDUILANGUAGES__ {
     *     int unused;
     * } *HSAVEDUILANGUAGES
     * }
     */
    public static final AddressLayout HSAVEDUILANGUAGES = C_POINTER;

    private static class SetThreadPreferredUILanguages2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_LONG,
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("SetThreadPreferredUILanguages2"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetThreadPreferredUILanguages2(ULONG flags, PCZZWSTR languages, PULONG numLanguagesSet, HSAVEDUILANGUAGES *snapshot)
     * }
     */
    public static FunctionDescriptor SetThreadPreferredUILanguages2$descriptor() {
        return SetThreadPreferredUILanguages2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetThreadPreferredUILanguages2(ULONG flags, PCZZWSTR languages, PULONG numLanguagesSet, HSAVEDUILANGUAGES *snapshot)
     * }
     */
    public static MethodHandle SetThreadPreferredUILanguages2$handle() {
        return SetThreadPreferredUILanguages2.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL SetThreadPreferredUILanguages2(ULONG flags, PCZZWSTR languages, PULONG numLanguagesSet, HSAVEDUILANGUAGES *snapshot)
     * }
     */
    public static int SetThreadPreferredUILanguages2(int flags, MemorySegment languages, MemorySegment numLanguagesSet, MemorySegment snapshot) {
        var mh$ = SetThreadPreferredUILanguages2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetThreadPreferredUILanguages2", flags, languages, numLanguagesSet, snapshot);
            }
            return (int)mh$.invokeExact(flags, languages, numLanguagesSet, snapshot);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RestoreThreadPreferredUILanguages {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("RestoreThreadPreferredUILanguages"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void RestoreThreadPreferredUILanguages(const HSAVEDUILANGUAGES snapshot)
     * }
     */
    public static FunctionDescriptor RestoreThreadPreferredUILanguages$descriptor() {
        return RestoreThreadPreferredUILanguages.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void RestoreThreadPreferredUILanguages(const HSAVEDUILANGUAGES snapshot)
     * }
     */
    public static MethodHandle RestoreThreadPreferredUILanguages$handle() {
        return RestoreThreadPreferredUILanguages.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * void RestoreThreadPreferredUILanguages(const HSAVEDUILANGUAGES snapshot)
     * }
     */
    public static void RestoreThreadPreferredUILanguages(MemorySegment snapshot) {
        var mh$ = RestoreThreadPreferredUILanguages.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RestoreThreadPreferredUILanguages", snapshot);
            }
            mh$.invokeExact(snapshot);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class NotifyUILanguageChange {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_LONG,
            C_POINTER,
            C_POINTER,
            C_LONG,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("NotifyUILanguageChange"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL NotifyUILanguageChange(DWORD dwFlags, PCWSTR pcwstrNewLanguage, PCWSTR pcwstrPreviousLanguage, DWORD dwReserved, PDWORD pdwStatusRtrn)
     * }
     */
    public static FunctionDescriptor NotifyUILanguageChange$descriptor() {
        return NotifyUILanguageChange.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL NotifyUILanguageChange(DWORD dwFlags, PCWSTR pcwstrNewLanguage, PCWSTR pcwstrPreviousLanguage, DWORD dwReserved, PDWORD pdwStatusRtrn)
     * }
     */
    public static MethodHandle NotifyUILanguageChange$handle() {
        return NotifyUILanguageChange.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL NotifyUILanguageChange(DWORD dwFlags, PCWSTR pcwstrNewLanguage, PCWSTR pcwstrPreviousLanguage, DWORD dwReserved, PDWORD pdwStatusRtrn)
     * }
     */
    public static int NotifyUILanguageChange(int dwFlags, MemorySegment pcwstrNewLanguage, MemorySegment pcwstrPreviousLanguage, int dwReserved, MemorySegment pdwStatusRtrn) {
        var mh$ = NotifyUILanguageChange.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("NotifyUILanguageChange", dwFlags, pcwstrNewLanguage, pcwstrPreviousLanguage, dwReserved, pdwStatusRtrn);
            }
            return (int)mh$.invokeExact(dwFlags, pcwstrNewLanguage, pcwstrPreviousLanguage, dwReserved, pdwStatusRtrn);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetStringTypeExA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_LONG,
            C_LONG,
            C_POINTER,
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetStringTypeExA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetStringTypeExA(LCID Locale, DWORD dwInfoType, LPCSTR lpSrcStr, int cchSrc, LPWORD lpCharType)
     * }
     */
    public static FunctionDescriptor GetStringTypeExA$descriptor() {
        return GetStringTypeExA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetStringTypeExA(LCID Locale, DWORD dwInfoType, LPCSTR lpSrcStr, int cchSrc, LPWORD lpCharType)
     * }
     */
    public static MethodHandle GetStringTypeExA$handle() {
        return GetStringTypeExA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL GetStringTypeExA(LCID Locale, DWORD dwInfoType, LPCSTR lpSrcStr, int cchSrc, LPWORD lpCharType)
     * }
     */
    public static int GetStringTypeExA(int Locale, int dwInfoType, MemorySegment lpSrcStr, int cchSrc, MemorySegment lpCharType) {
        var mh$ = GetStringTypeExA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetStringTypeExA", Locale, dwInfoType, lpSrcStr, cchSrc, lpCharType);
            }
            return (int)mh$.invokeExact(Locale, dwInfoType, lpSrcStr, cchSrc, lpCharType);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetStringTypeA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_LONG,
            C_LONG,
            C_POINTER,
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetStringTypeA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetStringTypeA(LCID Locale, DWORD dwInfoType, LPCSTR lpSrcStr, int cchSrc, LPWORD lpCharType)
     * }
     */
    public static FunctionDescriptor GetStringTypeA$descriptor() {
        return GetStringTypeA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetStringTypeA(LCID Locale, DWORD dwInfoType, LPCSTR lpSrcStr, int cchSrc, LPWORD lpCharType)
     * }
     */
    public static MethodHandle GetStringTypeA$handle() {
        return GetStringTypeA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL GetStringTypeA(LCID Locale, DWORD dwInfoType, LPCSTR lpSrcStr, int cchSrc, LPWORD lpCharType)
     * }
     */
    public static int GetStringTypeA(int Locale, int dwInfoType, MemorySegment lpSrcStr, int cchSrc, MemorySegment lpCharType) {
        var mh$ = GetStringTypeA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetStringTypeA", Locale, dwInfoType, lpSrcStr, cchSrc, lpCharType);
            }
            return (int)mh$.invokeExact(Locale, dwInfoType, lpSrcStr, cchSrc, lpCharType);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FoldStringA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_LONG,
            C_POINTER,
            C_INT,
            C_POINTER,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("FoldStringA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int FoldStringA(DWORD dwMapFlags, LPCSTR lpSrcStr, int cchSrc, LPSTR lpDestStr, int cchDest)
     * }
     */
    public static FunctionDescriptor FoldStringA$descriptor() {
        return FoldStringA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int FoldStringA(DWORD dwMapFlags, LPCSTR lpSrcStr, int cchSrc, LPSTR lpDestStr, int cchDest)
     * }
     */
    public static MethodHandle FoldStringA$handle() {
        return FoldStringA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int FoldStringA(DWORD dwMapFlags, LPCSTR lpSrcStr, int cchSrc, LPSTR lpDestStr, int cchDest)
     * }
     */
    public static int FoldStringA(int dwMapFlags, MemorySegment lpSrcStr, int cchSrc, MemorySegment lpDestStr, int cchDest) {
        var mh$ = FoldStringA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FoldStringA", dwMapFlags, lpSrcStr, cchSrc, lpDestStr, cchDest);
            }
            return (int)mh$.invokeExact(dwMapFlags, lpSrcStr, cchSrc, lpDestStr, cchDest);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class EnumSystemLocalesA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("EnumSystemLocalesA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL EnumSystemLocalesA(LOCALE_ENUMPROCA lpLocaleEnumProc, DWORD dwFlags)
     * }
     */
    public static FunctionDescriptor EnumSystemLocalesA$descriptor() {
        return EnumSystemLocalesA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL EnumSystemLocalesA(LOCALE_ENUMPROCA lpLocaleEnumProc, DWORD dwFlags)
     * }
     */
    public static MethodHandle EnumSystemLocalesA$handle() {
        return EnumSystemLocalesA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL EnumSystemLocalesA(LOCALE_ENUMPROCA lpLocaleEnumProc, DWORD dwFlags)
     * }
     */
    public static int EnumSystemLocalesA(MemorySegment lpLocaleEnumProc, int dwFlags) {
        var mh$ = EnumSystemLocalesA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("EnumSystemLocalesA", lpLocaleEnumProc, dwFlags);
            }
            return (int)mh$.invokeExact(lpLocaleEnumProc, dwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class EnumSystemLocalesW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("EnumSystemLocalesW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL EnumSystemLocalesW(LOCALE_ENUMPROCW lpLocaleEnumProc, DWORD dwFlags)
     * }
     */
    public static FunctionDescriptor EnumSystemLocalesW$descriptor() {
        return EnumSystemLocalesW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL EnumSystemLocalesW(LOCALE_ENUMPROCW lpLocaleEnumProc, DWORD dwFlags)
     * }
     */
    public static MethodHandle EnumSystemLocalesW$handle() {
        return EnumSystemLocalesW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL EnumSystemLocalesW(LOCALE_ENUMPROCW lpLocaleEnumProc, DWORD dwFlags)
     * }
     */
    public static int EnumSystemLocalesW(MemorySegment lpLocaleEnumProc, int dwFlags) {
        var mh$ = EnumSystemLocalesW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("EnumSystemLocalesW", lpLocaleEnumProc, dwFlags);
            }
            return (int)mh$.invokeExact(lpLocaleEnumProc, dwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class EnumSystemLanguageGroupsA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_LONG,
            C_LONG_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("EnumSystemLanguageGroupsA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL EnumSystemLanguageGroupsA(LANGUAGEGROUP_ENUMPROCA lpLanguageGroupEnumProc, DWORD dwFlags, LONG_PTR lParam)
     * }
     */
    public static FunctionDescriptor EnumSystemLanguageGroupsA$descriptor() {
        return EnumSystemLanguageGroupsA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL EnumSystemLanguageGroupsA(LANGUAGEGROUP_ENUMPROCA lpLanguageGroupEnumProc, DWORD dwFlags, LONG_PTR lParam)
     * }
     */
    public static MethodHandle EnumSystemLanguageGroupsA$handle() {
        return EnumSystemLanguageGroupsA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL EnumSystemLanguageGroupsA(LANGUAGEGROUP_ENUMPROCA lpLanguageGroupEnumProc, DWORD dwFlags, LONG_PTR lParam)
     * }
     */
    public static int EnumSystemLanguageGroupsA(MemorySegment lpLanguageGroupEnumProc, int dwFlags, long lParam) {
        var mh$ = EnumSystemLanguageGroupsA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("EnumSystemLanguageGroupsA", lpLanguageGroupEnumProc, dwFlags, lParam);
            }
            return (int)mh$.invokeExact(lpLanguageGroupEnumProc, dwFlags, lParam);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class EnumSystemLanguageGroupsW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_LONG,
            C_LONG_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("EnumSystemLanguageGroupsW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL EnumSystemLanguageGroupsW(LANGUAGEGROUP_ENUMPROCW lpLanguageGroupEnumProc, DWORD dwFlags, LONG_PTR lParam)
     * }
     */
    public static FunctionDescriptor EnumSystemLanguageGroupsW$descriptor() {
        return EnumSystemLanguageGroupsW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL EnumSystemLanguageGroupsW(LANGUAGEGROUP_ENUMPROCW lpLanguageGroupEnumProc, DWORD dwFlags, LONG_PTR lParam)
     * }
     */
    public static MethodHandle EnumSystemLanguageGroupsW$handle() {
        return EnumSystemLanguageGroupsW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL EnumSystemLanguageGroupsW(LANGUAGEGROUP_ENUMPROCW lpLanguageGroupEnumProc, DWORD dwFlags, LONG_PTR lParam)
     * }
     */
    public static int EnumSystemLanguageGroupsW(MemorySegment lpLanguageGroupEnumProc, int dwFlags, long lParam) {
        var mh$ = EnumSystemLanguageGroupsW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("EnumSystemLanguageGroupsW", lpLanguageGroupEnumProc, dwFlags, lParam);
            }
            return (int)mh$.invokeExact(lpLanguageGroupEnumProc, dwFlags, lParam);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class EnumLanguageGroupLocalesA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_LONG,
            C_LONG,
            C_LONG_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("EnumLanguageGroupLocalesA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL EnumLanguageGroupLocalesA(LANGGROUPLOCALE_ENUMPROCA lpLangGroupLocaleEnumProc, LGRPID LanguageGroup, DWORD dwFlags, LONG_PTR lParam)
     * }
     */
    public static FunctionDescriptor EnumLanguageGroupLocalesA$descriptor() {
        return EnumLanguageGroupLocalesA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL EnumLanguageGroupLocalesA(LANGGROUPLOCALE_ENUMPROCA lpLangGroupLocaleEnumProc, LGRPID LanguageGroup, DWORD dwFlags, LONG_PTR lParam)
     * }
     */
    public static MethodHandle EnumLanguageGroupLocalesA$handle() {
        return EnumLanguageGroupLocalesA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL EnumLanguageGroupLocalesA(LANGGROUPLOCALE_ENUMPROCA lpLangGroupLocaleEnumProc, LGRPID LanguageGroup, DWORD dwFlags, LONG_PTR lParam)
     * }
     */
    public static int EnumLanguageGroupLocalesA(MemorySegment lpLangGroupLocaleEnumProc, int LanguageGroup, int dwFlags, long lParam) {
        var mh$ = EnumLanguageGroupLocalesA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("EnumLanguageGroupLocalesA", lpLangGroupLocaleEnumProc, LanguageGroup, dwFlags, lParam);
            }
            return (int)mh$.invokeExact(lpLangGroupLocaleEnumProc, LanguageGroup, dwFlags, lParam);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class EnumLanguageGroupLocalesW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_LONG,
            C_LONG,
            C_LONG_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("EnumLanguageGroupLocalesW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL EnumLanguageGroupLocalesW(LANGGROUPLOCALE_ENUMPROCW lpLangGroupLocaleEnumProc, LGRPID LanguageGroup, DWORD dwFlags, LONG_PTR lParam)
     * }
     */
    public static FunctionDescriptor EnumLanguageGroupLocalesW$descriptor() {
        return EnumLanguageGroupLocalesW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL EnumLanguageGroupLocalesW(LANGGROUPLOCALE_ENUMPROCW lpLangGroupLocaleEnumProc, LGRPID LanguageGroup, DWORD dwFlags, LONG_PTR lParam)
     * }
     */
    public static MethodHandle EnumLanguageGroupLocalesW$handle() {
        return EnumLanguageGroupLocalesW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL EnumLanguageGroupLocalesW(LANGGROUPLOCALE_ENUMPROCW lpLangGroupLocaleEnumProc, LGRPID LanguageGroup, DWORD dwFlags, LONG_PTR lParam)
     * }
     */
    public static int EnumLanguageGroupLocalesW(MemorySegment lpLangGroupLocaleEnumProc, int LanguageGroup, int dwFlags, long lParam) {
        var mh$ = EnumLanguageGroupLocalesW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("EnumLanguageGroupLocalesW", lpLangGroupLocaleEnumProc, LanguageGroup, dwFlags, lParam);
            }
            return (int)mh$.invokeExact(lpLangGroupLocaleEnumProc, LanguageGroup, dwFlags, lParam);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class EnumUILanguagesA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_LONG,
            C_LONG_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("EnumUILanguagesA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL EnumUILanguagesA(UILANGUAGE_ENUMPROCA lpUILanguageEnumProc, DWORD dwFlags, LONG_PTR lParam)
     * }
     */
    public static FunctionDescriptor EnumUILanguagesA$descriptor() {
        return EnumUILanguagesA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL EnumUILanguagesA(UILANGUAGE_ENUMPROCA lpUILanguageEnumProc, DWORD dwFlags, LONG_PTR lParam)
     * }
     */
    public static MethodHandle EnumUILanguagesA$handle() {
        return EnumUILanguagesA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL EnumUILanguagesA(UILANGUAGE_ENUMPROCA lpUILanguageEnumProc, DWORD dwFlags, LONG_PTR lParam)
     * }
     */
    public static int EnumUILanguagesA(MemorySegment lpUILanguageEnumProc, int dwFlags, long lParam) {
        var mh$ = EnumUILanguagesA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("EnumUILanguagesA", lpUILanguageEnumProc, dwFlags, lParam);
            }
            return (int)mh$.invokeExact(lpUILanguageEnumProc, dwFlags, lParam);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class EnumUILanguagesW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_LONG,
            C_LONG_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("EnumUILanguagesW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL EnumUILanguagesW(UILANGUAGE_ENUMPROCW lpUILanguageEnumProc, DWORD dwFlags, LONG_PTR lParam)
     * }
     */
    public static FunctionDescriptor EnumUILanguagesW$descriptor() {
        return EnumUILanguagesW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL EnumUILanguagesW(UILANGUAGE_ENUMPROCW lpUILanguageEnumProc, DWORD dwFlags, LONG_PTR lParam)
     * }
     */
    public static MethodHandle EnumUILanguagesW$handle() {
        return EnumUILanguagesW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL EnumUILanguagesW(UILANGUAGE_ENUMPROCW lpUILanguageEnumProc, DWORD dwFlags, LONG_PTR lParam)
     * }
     */
    public static int EnumUILanguagesW(MemorySegment lpUILanguageEnumProc, int dwFlags, long lParam) {
        var mh$ = EnumUILanguagesW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("EnumUILanguagesW", lpUILanguageEnumProc, dwFlags, lParam);
            }
            return (int)mh$.invokeExact(lpUILanguageEnumProc, dwFlags, lParam);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class EnumSystemCodePagesA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("EnumSystemCodePagesA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL EnumSystemCodePagesA(CODEPAGE_ENUMPROCA lpCodePageEnumProc, DWORD dwFlags)
     * }
     */
    public static FunctionDescriptor EnumSystemCodePagesA$descriptor() {
        return EnumSystemCodePagesA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL EnumSystemCodePagesA(CODEPAGE_ENUMPROCA lpCodePageEnumProc, DWORD dwFlags)
     * }
     */
    public static MethodHandle EnumSystemCodePagesA$handle() {
        return EnumSystemCodePagesA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL EnumSystemCodePagesA(CODEPAGE_ENUMPROCA lpCodePageEnumProc, DWORD dwFlags)
     * }
     */
    public static int EnumSystemCodePagesA(MemorySegment lpCodePageEnumProc, int dwFlags) {
        var mh$ = EnumSystemCodePagesA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("EnumSystemCodePagesA", lpCodePageEnumProc, dwFlags);
            }
            return (int)mh$.invokeExact(lpCodePageEnumProc, dwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class EnumSystemCodePagesW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("EnumSystemCodePagesW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL EnumSystemCodePagesW(CODEPAGE_ENUMPROCW lpCodePageEnumProc, DWORD dwFlags)
     * }
     */
    public static FunctionDescriptor EnumSystemCodePagesW$descriptor() {
        return EnumSystemCodePagesW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL EnumSystemCodePagesW(CODEPAGE_ENUMPROCW lpCodePageEnumProc, DWORD dwFlags)
     * }
     */
    public static MethodHandle EnumSystemCodePagesW$handle() {
        return EnumSystemCodePagesW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL EnumSystemCodePagesW(CODEPAGE_ENUMPROCW lpCodePageEnumProc, DWORD dwFlags)
     * }
     */
    public static int EnumSystemCodePagesW(MemorySegment lpCodePageEnumProc, int dwFlags) {
        var mh$ = EnumSystemCodePagesW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("EnumSystemCodePagesW", lpCodePageEnumProc, dwFlags);
            }
            return (int)mh$.invokeExact(lpCodePageEnumProc, dwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class IdnToAscii {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_LONG,
            C_POINTER,
            C_INT,
            C_POINTER,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("IdnToAscii"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int IdnToAscii(DWORD dwFlags, LPCWSTR lpUnicodeCharStr, int cchUnicodeChar, LPWSTR lpASCIICharStr, int cchASCIIChar)
     * }
     */
    public static FunctionDescriptor IdnToAscii$descriptor() {
        return IdnToAscii.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int IdnToAscii(DWORD dwFlags, LPCWSTR lpUnicodeCharStr, int cchUnicodeChar, LPWSTR lpASCIICharStr, int cchASCIIChar)
     * }
     */
    public static MethodHandle IdnToAscii$handle() {
        return IdnToAscii.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int IdnToAscii(DWORD dwFlags, LPCWSTR lpUnicodeCharStr, int cchUnicodeChar, LPWSTR lpASCIICharStr, int cchASCIIChar)
     * }
     */
    public static int IdnToAscii(int dwFlags, MemorySegment lpUnicodeCharStr, int cchUnicodeChar, MemorySegment lpASCIICharStr, int cchASCIIChar) {
        var mh$ = IdnToAscii.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("IdnToAscii", dwFlags, lpUnicodeCharStr, cchUnicodeChar, lpASCIICharStr, cchASCIIChar);
            }
            return (int)mh$.invokeExact(dwFlags, lpUnicodeCharStr, cchUnicodeChar, lpASCIICharStr, cchASCIIChar);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class IdnToUnicode {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_LONG,
            C_POINTER,
            C_INT,
            C_POINTER,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("IdnToUnicode"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int IdnToUnicode(DWORD dwFlags, LPCWSTR lpASCIICharStr, int cchASCIIChar, LPWSTR lpUnicodeCharStr, int cchUnicodeChar)
     * }
     */
    public static FunctionDescriptor IdnToUnicode$descriptor() {
        return IdnToUnicode.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int IdnToUnicode(DWORD dwFlags, LPCWSTR lpASCIICharStr, int cchASCIIChar, LPWSTR lpUnicodeCharStr, int cchUnicodeChar)
     * }
     */
    public static MethodHandle IdnToUnicode$handle() {
        return IdnToUnicode.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int IdnToUnicode(DWORD dwFlags, LPCWSTR lpASCIICharStr, int cchASCIIChar, LPWSTR lpUnicodeCharStr, int cchUnicodeChar)
     * }
     */
    public static int IdnToUnicode(int dwFlags, MemorySegment lpASCIICharStr, int cchASCIIChar, MemorySegment lpUnicodeCharStr, int cchUnicodeChar) {
        var mh$ = IdnToUnicode.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("IdnToUnicode", dwFlags, lpASCIICharStr, cchASCIIChar, lpUnicodeCharStr, cchUnicodeChar);
            }
            return (int)mh$.invokeExact(dwFlags, lpASCIICharStr, cchASCIIChar, lpUnicodeCharStr, cchUnicodeChar);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class IdnToNameprepUnicode {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_LONG,
            C_POINTER,
            C_INT,
            C_POINTER,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("IdnToNameprepUnicode"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int IdnToNameprepUnicode(DWORD dwFlags, LPCWSTR lpUnicodeCharStr, int cchUnicodeChar, LPWSTR lpNameprepCharStr, int cchNameprepChar)
     * }
     */
    public static FunctionDescriptor IdnToNameprepUnicode$descriptor() {
        return IdnToNameprepUnicode.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int IdnToNameprepUnicode(DWORD dwFlags, LPCWSTR lpUnicodeCharStr, int cchUnicodeChar, LPWSTR lpNameprepCharStr, int cchNameprepChar)
     * }
     */
    public static MethodHandle IdnToNameprepUnicode$handle() {
        return IdnToNameprepUnicode.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int IdnToNameprepUnicode(DWORD dwFlags, LPCWSTR lpUnicodeCharStr, int cchUnicodeChar, LPWSTR lpNameprepCharStr, int cchNameprepChar)
     * }
     */
    public static int IdnToNameprepUnicode(int dwFlags, MemorySegment lpUnicodeCharStr, int cchUnicodeChar, MemorySegment lpNameprepCharStr, int cchNameprepChar) {
        var mh$ = IdnToNameprepUnicode.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("IdnToNameprepUnicode", dwFlags, lpUnicodeCharStr, cchUnicodeChar, lpNameprepCharStr, cchNameprepChar);
            }
            return (int)mh$.invokeExact(dwFlags, lpUnicodeCharStr, cchUnicodeChar, lpNameprepCharStr, cchNameprepChar);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class NormalizeString {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_INT,
            C_POINTER,
            C_INT,
            C_POINTER,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("NormalizeString"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int NormalizeString(NORM_FORM NormForm, LPCWSTR lpSrcString, int cwSrcLength, LPWSTR lpDstString, int cwDstLength)
     * }
     */
    public static FunctionDescriptor NormalizeString$descriptor() {
        return NormalizeString.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int NormalizeString(NORM_FORM NormForm, LPCWSTR lpSrcString, int cwSrcLength, LPWSTR lpDstString, int cwDstLength)
     * }
     */
    public static MethodHandle NormalizeString$handle() {
        return NormalizeString.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int NormalizeString(NORM_FORM NormForm, LPCWSTR lpSrcString, int cwSrcLength, LPWSTR lpDstString, int cwDstLength)
     * }
     */
    public static int NormalizeString(int NormForm, MemorySegment lpSrcString, int cwSrcLength, MemorySegment lpDstString, int cwDstLength) {
        var mh$ = NormalizeString.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("NormalizeString", NormForm, lpSrcString, cwSrcLength, lpDstString, cwDstLength);
            }
            return (int)mh$.invokeExact(NormForm, lpSrcString, cwSrcLength, lpDstString, cwDstLength);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class IsNormalizedString {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_INT,
            C_POINTER,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("IsNormalizedString"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL IsNormalizedString(NORM_FORM NormForm, LPCWSTR lpString, int cwLength)
     * }
     */
    public static FunctionDescriptor IsNormalizedString$descriptor() {
        return IsNormalizedString.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL IsNormalizedString(NORM_FORM NormForm, LPCWSTR lpString, int cwLength)
     * }
     */
    public static MethodHandle IsNormalizedString$handle() {
        return IsNormalizedString.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL IsNormalizedString(NORM_FORM NormForm, LPCWSTR lpString, int cwLength)
     * }
     */
    public static int IsNormalizedString(int NormForm, MemorySegment lpString, int cwLength) {
        var mh$ = IsNormalizedString.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("IsNormalizedString", NormForm, lpString, cwLength);
            }
            return (int)mh$.invokeExact(NormForm, lpString, cwLength);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class VerifyScripts {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_LONG,
            C_POINTER,
            C_INT,
            C_POINTER,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("VerifyScripts"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL VerifyScripts(DWORD dwFlags, LPCWSTR lpLocaleScripts, int cchLocaleScripts, LPCWSTR lpTestScripts, int cchTestScripts)
     * }
     */
    public static FunctionDescriptor VerifyScripts$descriptor() {
        return VerifyScripts.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL VerifyScripts(DWORD dwFlags, LPCWSTR lpLocaleScripts, int cchLocaleScripts, LPCWSTR lpTestScripts, int cchTestScripts)
     * }
     */
    public static MethodHandle VerifyScripts$handle() {
        return VerifyScripts.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL VerifyScripts(DWORD dwFlags, LPCWSTR lpLocaleScripts, int cchLocaleScripts, LPCWSTR lpTestScripts, int cchTestScripts)
     * }
     */
    public static int VerifyScripts(int dwFlags, MemorySegment lpLocaleScripts, int cchLocaleScripts, MemorySegment lpTestScripts, int cchTestScripts) {
        var mh$ = VerifyScripts.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("VerifyScripts", dwFlags, lpLocaleScripts, cchLocaleScripts, lpTestScripts, cchTestScripts);
            }
            return (int)mh$.invokeExact(dwFlags, lpLocaleScripts, cchLocaleScripts, lpTestScripts, cchTestScripts);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetStringScripts {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_LONG,
            C_POINTER,
            C_INT,
            C_POINTER,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetStringScripts"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int GetStringScripts(DWORD dwFlags, LPCWSTR lpString, int cchString, LPWSTR lpScripts, int cchScripts)
     * }
     */
    public static FunctionDescriptor GetStringScripts$descriptor() {
        return GetStringScripts.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int GetStringScripts(DWORD dwFlags, LPCWSTR lpString, int cchString, LPWSTR lpScripts, int cchScripts)
     * }
     */
    public static MethodHandle GetStringScripts$handle() {
        return GetStringScripts.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int GetStringScripts(DWORD dwFlags, LPCWSTR lpString, int cchString, LPWSTR lpScripts, int cchScripts)
     * }
     */
    public static int GetStringScripts(int dwFlags, MemorySegment lpString, int cchString, MemorySegment lpScripts, int cchScripts) {
        var mh$ = GetStringScripts.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetStringScripts", dwFlags, lpString, cchString, lpScripts, cchScripts);
            }
            return (int)mh$.invokeExact(dwFlags, lpString, cchString, lpScripts, cchScripts);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetLocaleInfoEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_LONG,
            C_POINTER,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetLocaleInfoEx"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int GetLocaleInfoEx(LPCWSTR lpLocaleName, LCTYPE LCType, LPWSTR lpLCData, int cchData)
     * }
     */
    public static FunctionDescriptor GetLocaleInfoEx$descriptor() {
        return GetLocaleInfoEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int GetLocaleInfoEx(LPCWSTR lpLocaleName, LCTYPE LCType, LPWSTR lpLCData, int cchData)
     * }
     */
    public static MethodHandle GetLocaleInfoEx$handle() {
        return GetLocaleInfoEx.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int GetLocaleInfoEx(LPCWSTR lpLocaleName, LCTYPE LCType, LPWSTR lpLCData, int cchData)
     * }
     */
    public static int GetLocaleInfoEx(MemorySegment lpLocaleName, int LCType, MemorySegment lpLCData, int cchData) {
        var mh$ = GetLocaleInfoEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetLocaleInfoEx", lpLocaleName, LCType, lpLCData, cchData);
            }
            return (int)mh$.invokeExact(lpLocaleName, LCType, lpLCData, cchData);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetCalendarInfoEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_LONG,
            C_POINTER,
            C_LONG,
            C_POINTER,
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetCalendarInfoEx"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int GetCalendarInfoEx(LPCWSTR lpLocaleName, CALID Calendar, LPCWSTR lpReserved, CALTYPE CalType, LPWSTR lpCalData, int cchData, LPDWORD lpValue)
     * }
     */
    public static FunctionDescriptor GetCalendarInfoEx$descriptor() {
        return GetCalendarInfoEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int GetCalendarInfoEx(LPCWSTR lpLocaleName, CALID Calendar, LPCWSTR lpReserved, CALTYPE CalType, LPWSTR lpCalData, int cchData, LPDWORD lpValue)
     * }
     */
    public static MethodHandle GetCalendarInfoEx$handle() {
        return GetCalendarInfoEx.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int GetCalendarInfoEx(LPCWSTR lpLocaleName, CALID Calendar, LPCWSTR lpReserved, CALTYPE CalType, LPWSTR lpCalData, int cchData, LPDWORD lpValue)
     * }
     */
    public static int GetCalendarInfoEx(MemorySegment lpLocaleName, int Calendar, MemorySegment lpReserved, int CalType, MemorySegment lpCalData, int cchData, MemorySegment lpValue) {
        var mh$ = GetCalendarInfoEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetCalendarInfoEx", lpLocaleName, Calendar, lpReserved, CalType, lpCalData, cchData, lpValue);
            }
            return (int)mh$.invokeExact(lpLocaleName, Calendar, lpReserved, CalType, lpCalData, cchData, lpValue);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetNumberFormatEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_LONG,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetNumberFormatEx"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int GetNumberFormatEx(LPCWSTR lpLocaleName, DWORD dwFlags, LPCWSTR lpValue, const NUMBERFMTW *lpFormat, LPWSTR lpNumberStr, int cchNumber)
     * }
     */
    public static FunctionDescriptor GetNumberFormatEx$descriptor() {
        return GetNumberFormatEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int GetNumberFormatEx(LPCWSTR lpLocaleName, DWORD dwFlags, LPCWSTR lpValue, const NUMBERFMTW *lpFormat, LPWSTR lpNumberStr, int cchNumber)
     * }
     */
    public static MethodHandle GetNumberFormatEx$handle() {
        return GetNumberFormatEx.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int GetNumberFormatEx(LPCWSTR lpLocaleName, DWORD dwFlags, LPCWSTR lpValue, const NUMBERFMTW *lpFormat, LPWSTR lpNumberStr, int cchNumber)
     * }
     */
    public static int GetNumberFormatEx(MemorySegment lpLocaleName, int dwFlags, MemorySegment lpValue, MemorySegment lpFormat, MemorySegment lpNumberStr, int cchNumber) {
        var mh$ = GetNumberFormatEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetNumberFormatEx", lpLocaleName, dwFlags, lpValue, lpFormat, lpNumberStr, cchNumber);
            }
            return (int)mh$.invokeExact(lpLocaleName, dwFlags, lpValue, lpFormat, lpNumberStr, cchNumber);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetCurrencyFormatEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_LONG,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetCurrencyFormatEx"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int GetCurrencyFormatEx(LPCWSTR lpLocaleName, DWORD dwFlags, LPCWSTR lpValue, const CURRENCYFMTW *lpFormat, LPWSTR lpCurrencyStr, int cchCurrency)
     * }
     */
    public static FunctionDescriptor GetCurrencyFormatEx$descriptor() {
        return GetCurrencyFormatEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int GetCurrencyFormatEx(LPCWSTR lpLocaleName, DWORD dwFlags, LPCWSTR lpValue, const CURRENCYFMTW *lpFormat, LPWSTR lpCurrencyStr, int cchCurrency)
     * }
     */
    public static MethodHandle GetCurrencyFormatEx$handle() {
        return GetCurrencyFormatEx.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int GetCurrencyFormatEx(LPCWSTR lpLocaleName, DWORD dwFlags, LPCWSTR lpValue, const CURRENCYFMTW *lpFormat, LPWSTR lpCurrencyStr, int cchCurrency)
     * }
     */
    public static int GetCurrencyFormatEx(MemorySegment lpLocaleName, int dwFlags, MemorySegment lpValue, MemorySegment lpFormat, MemorySegment lpCurrencyStr, int cchCurrency) {
        var mh$ = GetCurrencyFormatEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetCurrencyFormatEx", lpLocaleName, dwFlags, lpValue, lpFormat, lpCurrencyStr, cchCurrency);
            }
            return (int)mh$.invokeExact(lpLocaleName, dwFlags, lpValue, lpFormat, lpCurrencyStr, cchCurrency);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetUserDefaultLocaleName {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetUserDefaultLocaleName"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int GetUserDefaultLocaleName(LPWSTR lpLocaleName, int cchLocaleName)
     * }
     */
    public static FunctionDescriptor GetUserDefaultLocaleName$descriptor() {
        return GetUserDefaultLocaleName.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int GetUserDefaultLocaleName(LPWSTR lpLocaleName, int cchLocaleName)
     * }
     */
    public static MethodHandle GetUserDefaultLocaleName$handle() {
        return GetUserDefaultLocaleName.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int GetUserDefaultLocaleName(LPWSTR lpLocaleName, int cchLocaleName)
     * }
     */
    public static int GetUserDefaultLocaleName(MemorySegment lpLocaleName, int cchLocaleName) {
        var mh$ = GetUserDefaultLocaleName.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetUserDefaultLocaleName", lpLocaleName, cchLocaleName);
            }
            return (int)mh$.invokeExact(lpLocaleName, cchLocaleName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetSystemDefaultLocaleName {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetSystemDefaultLocaleName"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int GetSystemDefaultLocaleName(LPWSTR lpLocaleName, int cchLocaleName)
     * }
     */
    public static FunctionDescriptor GetSystemDefaultLocaleName$descriptor() {
        return GetSystemDefaultLocaleName.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int GetSystemDefaultLocaleName(LPWSTR lpLocaleName, int cchLocaleName)
     * }
     */
    public static MethodHandle GetSystemDefaultLocaleName$handle() {
        return GetSystemDefaultLocaleName.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int GetSystemDefaultLocaleName(LPWSTR lpLocaleName, int cchLocaleName)
     * }
     */
    public static int GetSystemDefaultLocaleName(MemorySegment lpLocaleName, int cchLocaleName) {
        var mh$ = GetSystemDefaultLocaleName.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetSystemDefaultLocaleName", lpLocaleName, cchLocaleName);
            }
            return (int)mh$.invokeExact(lpLocaleName, cchLocaleName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class IsNLSDefinedString {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_LONG,
            C_LONG,
            C_POINTER,
            C_POINTER,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("IsNLSDefinedString"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL IsNLSDefinedString(NLS_FUNCTION Function, DWORD dwFlags, LPNLSVERSIONINFO lpVersionInformation, LPCWSTR lpString, INT cchStr)
     * }
     */
    public static FunctionDescriptor IsNLSDefinedString$descriptor() {
        return IsNLSDefinedString.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL IsNLSDefinedString(NLS_FUNCTION Function, DWORD dwFlags, LPNLSVERSIONINFO lpVersionInformation, LPCWSTR lpString, INT cchStr)
     * }
     */
    public static MethodHandle IsNLSDefinedString$handle() {
        return IsNLSDefinedString.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL IsNLSDefinedString(NLS_FUNCTION Function, DWORD dwFlags, LPNLSVERSIONINFO lpVersionInformation, LPCWSTR lpString, INT cchStr)
     * }
     */
    public static int IsNLSDefinedString(int Function, int dwFlags, MemorySegment lpVersionInformation, MemorySegment lpString, int cchStr) {
        var mh$ = IsNLSDefinedString.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("IsNLSDefinedString", Function, dwFlags, lpVersionInformation, lpString, cchStr);
            }
            return (int)mh$.invokeExact(Function, dwFlags, lpVersionInformation, lpString, cchStr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetNLSVersionEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_LONG,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetNLSVersionEx"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetNLSVersionEx(NLS_FUNCTION function, LPCWSTR lpLocaleName, LPNLSVERSIONINFOEX lpVersionInformation)
     * }
     */
    public static FunctionDescriptor GetNLSVersionEx$descriptor() {
        return GetNLSVersionEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetNLSVersionEx(NLS_FUNCTION function, LPCWSTR lpLocaleName, LPNLSVERSIONINFOEX lpVersionInformation)
     * }
     */
    public static MethodHandle GetNLSVersionEx$handle() {
        return GetNLSVersionEx.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL GetNLSVersionEx(NLS_FUNCTION function, LPCWSTR lpLocaleName, LPNLSVERSIONINFOEX lpVersionInformation)
     * }
     */
    public static int GetNLSVersionEx(int function, MemorySegment lpLocaleName, MemorySegment lpVersionInformation) {
        var mh$ = GetNLSVersionEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetNLSVersionEx", function, lpLocaleName, lpVersionInformation);
            }
            return (int)mh$.invokeExact(function, lpLocaleName, lpVersionInformation);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class IsValidNLSVersion {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_LONG,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("IsValidNLSVersion"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD IsValidNLSVersion(NLS_FUNCTION function, LPCWSTR lpLocaleName, LPNLSVERSIONINFOEX lpVersionInformation)
     * }
     */
    public static FunctionDescriptor IsValidNLSVersion$descriptor() {
        return IsValidNLSVersion.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD IsValidNLSVersion(NLS_FUNCTION function, LPCWSTR lpLocaleName, LPNLSVERSIONINFOEX lpVersionInformation)
     * }
     */
    public static MethodHandle IsValidNLSVersion$handle() {
        return IsValidNLSVersion.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * DWORD IsValidNLSVersion(NLS_FUNCTION function, LPCWSTR lpLocaleName, LPNLSVERSIONINFOEX lpVersionInformation)
     * }
     */
    public static int IsValidNLSVersion(int function, MemorySegment lpLocaleName, MemorySegment lpVersionInformation) {
        var mh$ = IsValidNLSVersion.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("IsValidNLSVersion", function, lpLocaleName, lpVersionInformation);
            }
            return (int)mh$.invokeExact(function, lpLocaleName, lpVersionInformation);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FindNLSStringEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_LONG,
            C_POINTER,
            C_INT,
            C_POINTER,
            C_INT,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_LONG_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("FindNLSStringEx"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int FindNLSStringEx(LPCWSTR lpLocaleName, DWORD dwFindNLSStringFlags, LPCWSTR lpStringSource, int cchSource, LPCWSTR lpStringValue, int cchValue, LPINT pcchFound, LPNLSVERSIONINFO lpVersionInformation, LPVOID lpReserved, LPARAM sortHandle)
     * }
     */
    public static FunctionDescriptor FindNLSStringEx$descriptor() {
        return FindNLSStringEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int FindNLSStringEx(LPCWSTR lpLocaleName, DWORD dwFindNLSStringFlags, LPCWSTR lpStringSource, int cchSource, LPCWSTR lpStringValue, int cchValue, LPINT pcchFound, LPNLSVERSIONINFO lpVersionInformation, LPVOID lpReserved, LPARAM sortHandle)
     * }
     */
    public static MethodHandle FindNLSStringEx$handle() {
        return FindNLSStringEx.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int FindNLSStringEx(LPCWSTR lpLocaleName, DWORD dwFindNLSStringFlags, LPCWSTR lpStringSource, int cchSource, LPCWSTR lpStringValue, int cchValue, LPINT pcchFound, LPNLSVERSIONINFO lpVersionInformation, LPVOID lpReserved, LPARAM sortHandle)
     * }
     */
    public static int FindNLSStringEx(MemorySegment lpLocaleName, int dwFindNLSStringFlags, MemorySegment lpStringSource, int cchSource, MemorySegment lpStringValue, int cchValue, MemorySegment pcchFound, MemorySegment lpVersionInformation, MemorySegment lpReserved, long sortHandle) {
        var mh$ = FindNLSStringEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FindNLSStringEx", lpLocaleName, dwFindNLSStringFlags, lpStringSource, cchSource, lpStringValue, cchValue, pcchFound, lpVersionInformation, lpReserved, sortHandle);
            }
            return (int)mh$.invokeExact(lpLocaleName, dwFindNLSStringFlags, lpStringSource, cchSource, lpStringValue, cchValue, pcchFound, lpVersionInformation, lpReserved, sortHandle);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LCMapStringEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_LONG,
            C_POINTER,
            C_INT,
            C_POINTER,
            C_INT,
            C_POINTER,
            C_POINTER,
            C_LONG_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("LCMapStringEx"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LCMapStringEx(LPCWSTR lpLocaleName, DWORD dwMapFlags, LPCWSTR lpSrcStr, int cchSrc, LPWSTR lpDestStr, int cchDest, LPNLSVERSIONINFO lpVersionInformation, LPVOID lpReserved, LPARAM sortHandle)
     * }
     */
    public static FunctionDescriptor LCMapStringEx$descriptor() {
        return LCMapStringEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LCMapStringEx(LPCWSTR lpLocaleName, DWORD dwMapFlags, LPCWSTR lpSrcStr, int cchSrc, LPWSTR lpDestStr, int cchDest, LPNLSVERSIONINFO lpVersionInformation, LPVOID lpReserved, LPARAM sortHandle)
     * }
     */
    public static MethodHandle LCMapStringEx$handle() {
        return LCMapStringEx.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int LCMapStringEx(LPCWSTR lpLocaleName, DWORD dwMapFlags, LPCWSTR lpSrcStr, int cchSrc, LPWSTR lpDestStr, int cchDest, LPNLSVERSIONINFO lpVersionInformation, LPVOID lpReserved, LPARAM sortHandle)
     * }
     */
    public static int LCMapStringEx(MemorySegment lpLocaleName, int dwMapFlags, MemorySegment lpSrcStr, int cchSrc, MemorySegment lpDestStr, int cchDest, MemorySegment lpVersionInformation, MemorySegment lpReserved, long sortHandle) {
        var mh$ = LCMapStringEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LCMapStringEx", lpLocaleName, dwMapFlags, lpSrcStr, cchSrc, lpDestStr, cchDest, lpVersionInformation, lpReserved, sortHandle);
            }
            return (int)mh$.invokeExact(lpLocaleName, dwMapFlags, lpSrcStr, cchSrc, lpDestStr, cchDest, lpVersionInformation, lpReserved, sortHandle);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class IsValidLocaleName {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("IsValidLocaleName"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL IsValidLocaleName(LPCWSTR lpLocaleName)
     * }
     */
    public static FunctionDescriptor IsValidLocaleName$descriptor() {
        return IsValidLocaleName.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL IsValidLocaleName(LPCWSTR lpLocaleName)
     * }
     */
    public static MethodHandle IsValidLocaleName$handle() {
        return IsValidLocaleName.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL IsValidLocaleName(LPCWSTR lpLocaleName)
     * }
     */
    public static int IsValidLocaleName(MemorySegment lpLocaleName) {
        var mh$ = IsValidLocaleName.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("IsValidLocaleName", lpLocaleName);
            }
            return (int)mh$.invokeExact(lpLocaleName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class EnumCalendarInfoExEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_LONG,
            C_POINTER,
            C_LONG,
            C_LONG_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("EnumCalendarInfoExEx"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL EnumCalendarInfoExEx(CALINFO_ENUMPROCEXEX pCalInfoEnumProcExEx, LPCWSTR lpLocaleName, CALID Calendar, LPCWSTR lpReserved, CALTYPE CalType, LPARAM lParam)
     * }
     */
    public static FunctionDescriptor EnumCalendarInfoExEx$descriptor() {
        return EnumCalendarInfoExEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL EnumCalendarInfoExEx(CALINFO_ENUMPROCEXEX pCalInfoEnumProcExEx, LPCWSTR lpLocaleName, CALID Calendar, LPCWSTR lpReserved, CALTYPE CalType, LPARAM lParam)
     * }
     */
    public static MethodHandle EnumCalendarInfoExEx$handle() {
        return EnumCalendarInfoExEx.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL EnumCalendarInfoExEx(CALINFO_ENUMPROCEXEX pCalInfoEnumProcExEx, LPCWSTR lpLocaleName, CALID Calendar, LPCWSTR lpReserved, CALTYPE CalType, LPARAM lParam)
     * }
     */
    public static int EnumCalendarInfoExEx(MemorySegment pCalInfoEnumProcExEx, MemorySegment lpLocaleName, int Calendar, MemorySegment lpReserved, int CalType, long lParam) {
        var mh$ = EnumCalendarInfoExEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("EnumCalendarInfoExEx", pCalInfoEnumProcExEx, lpLocaleName, Calendar, lpReserved, CalType, lParam);
            }
            return (int)mh$.invokeExact(pCalInfoEnumProcExEx, lpLocaleName, Calendar, lpReserved, CalType, lParam);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class EnumDateFormatsExEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_LONG,
            C_LONG_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("EnumDateFormatsExEx"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL EnumDateFormatsExEx(DATEFMT_ENUMPROCEXEX lpDateFmtEnumProcExEx, LPCWSTR lpLocaleName, DWORD dwFlags, LPARAM lParam)
     * }
     */
    public static FunctionDescriptor EnumDateFormatsExEx$descriptor() {
        return EnumDateFormatsExEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL EnumDateFormatsExEx(DATEFMT_ENUMPROCEXEX lpDateFmtEnumProcExEx, LPCWSTR lpLocaleName, DWORD dwFlags, LPARAM lParam)
     * }
     */
    public static MethodHandle EnumDateFormatsExEx$handle() {
        return EnumDateFormatsExEx.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL EnumDateFormatsExEx(DATEFMT_ENUMPROCEXEX lpDateFmtEnumProcExEx, LPCWSTR lpLocaleName, DWORD dwFlags, LPARAM lParam)
     * }
     */
    public static int EnumDateFormatsExEx(MemorySegment lpDateFmtEnumProcExEx, MemorySegment lpLocaleName, int dwFlags, long lParam) {
        var mh$ = EnumDateFormatsExEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("EnumDateFormatsExEx", lpDateFmtEnumProcExEx, lpLocaleName, dwFlags, lParam);
            }
            return (int)mh$.invokeExact(lpDateFmtEnumProcExEx, lpLocaleName, dwFlags, lParam);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class EnumTimeFormatsEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_LONG,
            C_LONG_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("EnumTimeFormatsEx"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL EnumTimeFormatsEx(TIMEFMT_ENUMPROCEX lpTimeFmtEnumProcEx, LPCWSTR lpLocaleName, DWORD dwFlags, LPARAM lParam)
     * }
     */
    public static FunctionDescriptor EnumTimeFormatsEx$descriptor() {
        return EnumTimeFormatsEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL EnumTimeFormatsEx(TIMEFMT_ENUMPROCEX lpTimeFmtEnumProcEx, LPCWSTR lpLocaleName, DWORD dwFlags, LPARAM lParam)
     * }
     */
    public static MethodHandle EnumTimeFormatsEx$handle() {
        return EnumTimeFormatsEx.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL EnumTimeFormatsEx(TIMEFMT_ENUMPROCEX lpTimeFmtEnumProcEx, LPCWSTR lpLocaleName, DWORD dwFlags, LPARAM lParam)
     * }
     */
    public static int EnumTimeFormatsEx(MemorySegment lpTimeFmtEnumProcEx, MemorySegment lpLocaleName, int dwFlags, long lParam) {
        var mh$ = EnumTimeFormatsEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("EnumTimeFormatsEx", lpTimeFmtEnumProcEx, lpLocaleName, dwFlags, lParam);
            }
            return (int)mh$.invokeExact(lpTimeFmtEnumProcEx, lpLocaleName, dwFlags, lParam);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class EnumSystemLocalesEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_LONG,
            C_LONG_LONG,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("EnumSystemLocalesEx"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL EnumSystemLocalesEx(LOCALE_ENUMPROCEX lpLocaleEnumProcEx, DWORD dwFlags, LPARAM lParam, LPVOID lpReserved)
     * }
     */
    public static FunctionDescriptor EnumSystemLocalesEx$descriptor() {
        return EnumSystemLocalesEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL EnumSystemLocalesEx(LOCALE_ENUMPROCEX lpLocaleEnumProcEx, DWORD dwFlags, LPARAM lParam, LPVOID lpReserved)
     * }
     */
    public static MethodHandle EnumSystemLocalesEx$handle() {
        return EnumSystemLocalesEx.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL EnumSystemLocalesEx(LOCALE_ENUMPROCEX lpLocaleEnumProcEx, DWORD dwFlags, LPARAM lParam, LPVOID lpReserved)
     * }
     */
    public static int EnumSystemLocalesEx(MemorySegment lpLocaleEnumProcEx, int dwFlags, long lParam, MemorySegment lpReserved) {
        var mh$ = EnumSystemLocalesEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("EnumSystemLocalesEx", lpLocaleEnumProcEx, dwFlags, lParam, lpReserved);
            }
            return (int)mh$.invokeExact(lpLocaleEnumProcEx, dwFlags, lParam, lpReserved);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ResolveLocaleName {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("ResolveLocaleName"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int ResolveLocaleName(LPCWSTR lpNameToResolve, LPWSTR lpLocaleName, int cchLocaleName)
     * }
     */
    public static FunctionDescriptor ResolveLocaleName$descriptor() {
        return ResolveLocaleName.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int ResolveLocaleName(LPCWSTR lpNameToResolve, LPWSTR lpLocaleName, int cchLocaleName)
     * }
     */
    public static MethodHandle ResolveLocaleName$handle() {
        return ResolveLocaleName.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int ResolveLocaleName(LPCWSTR lpNameToResolve, LPWSTR lpLocaleName, int cchLocaleName)
     * }
     */
    public static int ResolveLocaleName(MemorySegment lpNameToResolve, MemorySegment lpLocaleName, int cchLocaleName) {
        var mh$ = ResolveLocaleName.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ResolveLocaleName", lpNameToResolve, lpLocaleName, cchLocaleName);
            }
            return (int)mh$.invokeExact(lpNameToResolve, lpLocaleName, cchLocaleName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct _COORD {
     *     SHORT X;
     *     SHORT Y;
     * } *PCOORD
     * }
     */
    public static final AddressLayout PCOORD = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _SMALL_RECT {
     *     SHORT Left;
     *     SHORT Top;
     *     SHORT Right;
     *     SHORT Bottom;
     * } *PSMALL_RECT
     * }
     */
    public static final AddressLayout PSMALL_RECT = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _KEY_EVENT_RECORD {
     *     BOOL bKeyDown;
     *     WORD wRepeatCount;
     *     WORD wVirtualKeyCode;
     *     WORD wVirtualScanCode;
     *     union {
     *         WCHAR UnicodeChar;
     *         CHAR AsciiChar;
     *     } uChar;
     *     DWORD dwControlKeyState;
     * } *PKEY_EVENT_RECORD
     * }
     */
    public static final AddressLayout PKEY_EVENT_RECORD = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _MOUSE_EVENT_RECORD {
     *     COORD dwMousePosition;
     *     DWORD dwButtonState;
     *     DWORD dwControlKeyState;
     *     DWORD dwEventFlags;
     * } *PMOUSE_EVENT_RECORD
     * }
     */
    public static final AddressLayout PMOUSE_EVENT_RECORD = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _WINDOW_BUFFER_SIZE_RECORD {
     *     COORD dwSize;
     * } *PWINDOW_BUFFER_SIZE_RECORD
     * }
     */
    public static final AddressLayout PWINDOW_BUFFER_SIZE_RECORD = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _MENU_EVENT_RECORD {
     *     UINT dwCommandId;
     * } *PMENU_EVENT_RECORD
     * }
     */
    public static final AddressLayout PMENU_EVENT_RECORD = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _FOCUS_EVENT_RECORD {
     *     BOOL bSetFocus;
     * } *PFOCUS_EVENT_RECORD
     * }
     */
    public static final AddressLayout PFOCUS_EVENT_RECORD = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _INPUT_RECORD {
     *     WORD EventType;
     *     union {
     *         KEY_EVENT_RECORD KeyEvent;
     *         MOUSE_EVENT_RECORD MouseEvent;
     *         WINDOW_BUFFER_SIZE_RECORD WindowBufferSizeEvent;
     *         MENU_EVENT_RECORD MenuEvent;
     *         FOCUS_EVENT_RECORD FocusEvent;
     *     } Event;
     * } *PINPUT_RECORD
     * }
     */
    public static final AddressLayout PINPUT_RECORD = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CHAR_INFO {
     *     union {
     *         WCHAR UnicodeChar;
     *         CHAR AsciiChar;
     *     } Char;
     *     WORD Attributes;
     * } *PCHAR_INFO
     * }
     */
    public static final AddressLayout PCHAR_INFO = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CONSOLE_FONT_INFO {
     *     DWORD nFont;
     *     COORD dwFontSize;
     * } *PCONSOLE_FONT_INFO
     * }
     */
    public static final AddressLayout PCONSOLE_FONT_INFO = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef void *HPCON
     * }
     */
    public static final AddressLayout HPCON = C_POINTER;

    private static class AllocConsole {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT    );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("AllocConsole"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL AllocConsole()
     * }
     */
    public static FunctionDescriptor AllocConsole$descriptor() {
        return AllocConsole.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL AllocConsole()
     * }
     */
    public static MethodHandle AllocConsole$handle() {
        return AllocConsole.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL AllocConsole()
     * }
     */
    public static int AllocConsole() {
        var mh$ = AllocConsole.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("AllocConsole");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FreeConsole {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT    );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("FreeConsole"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL FreeConsole()
     * }
     */
    public static FunctionDescriptor FreeConsole$descriptor() {
        return FreeConsole.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL FreeConsole()
     * }
     */
    public static MethodHandle FreeConsole$handle() {
        return FreeConsole.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL FreeConsole()
     * }
     */
    public static int FreeConsole() {
        var mh$ = FreeConsole.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FreeConsole");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class AttachConsole {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("AttachConsole"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL AttachConsole(DWORD dwProcessId)
     * }
     */
    public static FunctionDescriptor AttachConsole$descriptor() {
        return AttachConsole.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL AttachConsole(DWORD dwProcessId)
     * }
     */
    public static MethodHandle AttachConsole$handle() {
        return AttachConsole.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL AttachConsole(DWORD dwProcessId)
     * }
     */
    public static int AttachConsole(int dwProcessId) {
        var mh$ = AttachConsole.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("AttachConsole", dwProcessId);
            }
            return (int)mh$.invokeExact(dwProcessId);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetConsoleCP {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT    );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetConsoleCP"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * UINT GetConsoleCP()
     * }
     */
    public static FunctionDescriptor GetConsoleCP$descriptor() {
        return GetConsoleCP.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * UINT GetConsoleCP()
     * }
     */
    public static MethodHandle GetConsoleCP$handle() {
        return GetConsoleCP.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * UINT GetConsoleCP()
     * }
     */
    public static int GetConsoleCP() {
        var mh$ = GetConsoleCP.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetConsoleCP");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetConsoleOutputCP {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT    );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetConsoleOutputCP"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * UINT GetConsoleOutputCP()
     * }
     */
    public static FunctionDescriptor GetConsoleOutputCP$descriptor() {
        return GetConsoleOutputCP.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * UINT GetConsoleOutputCP()
     * }
     */
    public static MethodHandle GetConsoleOutputCP$handle() {
        return GetConsoleOutputCP.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * UINT GetConsoleOutputCP()
     * }
     */
    public static int GetConsoleOutputCP() {
        var mh$ = GetConsoleOutputCP.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetConsoleOutputCP");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetConsoleMode {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetConsoleMode"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetConsoleMode(HANDLE hConsoleHandle, LPDWORD lpMode)
     * }
     */
    public static FunctionDescriptor GetConsoleMode$descriptor() {
        return GetConsoleMode.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetConsoleMode(HANDLE hConsoleHandle, LPDWORD lpMode)
     * }
     */
    public static MethodHandle GetConsoleMode$handle() {
        return GetConsoleMode.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL GetConsoleMode(HANDLE hConsoleHandle, LPDWORD lpMode)
     * }
     */
    public static int GetConsoleMode(MemorySegment hConsoleHandle, MemorySegment lpMode) {
        var mh$ = GetConsoleMode.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetConsoleMode", hConsoleHandle, lpMode);
            }
            return (int)mh$.invokeExact(hConsoleHandle, lpMode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetConsoleMode {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("SetConsoleMode"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetConsoleMode(HANDLE hConsoleHandle, DWORD dwMode)
     * }
     */
    public static FunctionDescriptor SetConsoleMode$descriptor() {
        return SetConsoleMode.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetConsoleMode(HANDLE hConsoleHandle, DWORD dwMode)
     * }
     */
    public static MethodHandle SetConsoleMode$handle() {
        return SetConsoleMode.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL SetConsoleMode(HANDLE hConsoleHandle, DWORD dwMode)
     * }
     */
    public static int SetConsoleMode(MemorySegment hConsoleHandle, int dwMode) {
        var mh$ = SetConsoleMode.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetConsoleMode", hConsoleHandle, dwMode);
            }
            return (int)mh$.invokeExact(hConsoleHandle, dwMode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetNumberOfConsoleInputEvents {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetNumberOfConsoleInputEvents"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetNumberOfConsoleInputEvents(HANDLE hConsoleInput, LPDWORD lpNumberOfEvents)
     * }
     */
    public static FunctionDescriptor GetNumberOfConsoleInputEvents$descriptor() {
        return GetNumberOfConsoleInputEvents.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetNumberOfConsoleInputEvents(HANDLE hConsoleInput, LPDWORD lpNumberOfEvents)
     * }
     */
    public static MethodHandle GetNumberOfConsoleInputEvents$handle() {
        return GetNumberOfConsoleInputEvents.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL GetNumberOfConsoleInputEvents(HANDLE hConsoleInput, LPDWORD lpNumberOfEvents)
     * }
     */
    public static int GetNumberOfConsoleInputEvents(MemorySegment hConsoleInput, MemorySegment lpNumberOfEvents) {
        var mh$ = GetNumberOfConsoleInputEvents.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetNumberOfConsoleInputEvents", hConsoleInput, lpNumberOfEvents);
            }
            return (int)mh$.invokeExact(hConsoleInput, lpNumberOfEvents);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ReadConsoleInputA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_LONG,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("ReadConsoleInputA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL ReadConsoleInputA(HANDLE hConsoleInput, PINPUT_RECORD lpBuffer, DWORD nLength, LPDWORD lpNumberOfEventsRead)
     * }
     */
    public static FunctionDescriptor ReadConsoleInputA$descriptor() {
        return ReadConsoleInputA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL ReadConsoleInputA(HANDLE hConsoleInput, PINPUT_RECORD lpBuffer, DWORD nLength, LPDWORD lpNumberOfEventsRead)
     * }
     */
    public static MethodHandle ReadConsoleInputA$handle() {
        return ReadConsoleInputA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL ReadConsoleInputA(HANDLE hConsoleInput, PINPUT_RECORD lpBuffer, DWORD nLength, LPDWORD lpNumberOfEventsRead)
     * }
     */
    public static int ReadConsoleInputA(MemorySegment hConsoleInput, MemorySegment lpBuffer, int nLength, MemorySegment lpNumberOfEventsRead) {
        var mh$ = ReadConsoleInputA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ReadConsoleInputA", hConsoleInput, lpBuffer, nLength, lpNumberOfEventsRead);
            }
            return (int)mh$.invokeExact(hConsoleInput, lpBuffer, nLength, lpNumberOfEventsRead);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ReadConsoleInputW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_LONG,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("ReadConsoleInputW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL ReadConsoleInputW(HANDLE hConsoleInput, PINPUT_RECORD lpBuffer, DWORD nLength, LPDWORD lpNumberOfEventsRead)
     * }
     */
    public static FunctionDescriptor ReadConsoleInputW$descriptor() {
        return ReadConsoleInputW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL ReadConsoleInputW(HANDLE hConsoleInput, PINPUT_RECORD lpBuffer, DWORD nLength, LPDWORD lpNumberOfEventsRead)
     * }
     */
    public static MethodHandle ReadConsoleInputW$handle() {
        return ReadConsoleInputW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL ReadConsoleInputW(HANDLE hConsoleInput, PINPUT_RECORD lpBuffer, DWORD nLength, LPDWORD lpNumberOfEventsRead)
     * }
     */
    public static int ReadConsoleInputW(MemorySegment hConsoleInput, MemorySegment lpBuffer, int nLength, MemorySegment lpNumberOfEventsRead) {
        var mh$ = ReadConsoleInputW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ReadConsoleInputW", hConsoleInput, lpBuffer, nLength, lpNumberOfEventsRead);
            }
            return (int)mh$.invokeExact(hConsoleInput, lpBuffer, nLength, lpNumberOfEventsRead);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PeekConsoleInputA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_LONG,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("PeekConsoleInputA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL PeekConsoleInputA(HANDLE hConsoleInput, PINPUT_RECORD lpBuffer, DWORD nLength, LPDWORD lpNumberOfEventsRead)
     * }
     */
    public static FunctionDescriptor PeekConsoleInputA$descriptor() {
        return PeekConsoleInputA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL PeekConsoleInputA(HANDLE hConsoleInput, PINPUT_RECORD lpBuffer, DWORD nLength, LPDWORD lpNumberOfEventsRead)
     * }
     */
    public static MethodHandle PeekConsoleInputA$handle() {
        return PeekConsoleInputA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL PeekConsoleInputA(HANDLE hConsoleInput, PINPUT_RECORD lpBuffer, DWORD nLength, LPDWORD lpNumberOfEventsRead)
     * }
     */
    public static int PeekConsoleInputA(MemorySegment hConsoleInput, MemorySegment lpBuffer, int nLength, MemorySegment lpNumberOfEventsRead) {
        var mh$ = PeekConsoleInputA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PeekConsoleInputA", hConsoleInput, lpBuffer, nLength, lpNumberOfEventsRead);
            }
            return (int)mh$.invokeExact(hConsoleInput, lpBuffer, nLength, lpNumberOfEventsRead);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PeekConsoleInputW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_LONG,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("PeekConsoleInputW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL PeekConsoleInputW(HANDLE hConsoleInput, PINPUT_RECORD lpBuffer, DWORD nLength, LPDWORD lpNumberOfEventsRead)
     * }
     */
    public static FunctionDescriptor PeekConsoleInputW$descriptor() {
        return PeekConsoleInputW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL PeekConsoleInputW(HANDLE hConsoleInput, PINPUT_RECORD lpBuffer, DWORD nLength, LPDWORD lpNumberOfEventsRead)
     * }
     */
    public static MethodHandle PeekConsoleInputW$handle() {
        return PeekConsoleInputW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL PeekConsoleInputW(HANDLE hConsoleInput, PINPUT_RECORD lpBuffer, DWORD nLength, LPDWORD lpNumberOfEventsRead)
     * }
     */
    public static int PeekConsoleInputW(MemorySegment hConsoleInput, MemorySegment lpBuffer, int nLength, MemorySegment lpNumberOfEventsRead) {
        var mh$ = PeekConsoleInputW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PeekConsoleInputW", hConsoleInput, lpBuffer, nLength, lpNumberOfEventsRead);
            }
            return (int)mh$.invokeExact(hConsoleInput, lpBuffer, nLength, lpNumberOfEventsRead);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct _CONSOLE_READCONSOLE_CONTROL {
     *     ULONG nLength;
     *     ULONG nInitialChars;
     *     ULONG dwCtrlWakeupMask;
     *     ULONG dwControlKeyState;
     * } *PCONSOLE_READCONSOLE_CONTROL
     * }
     */
    public static final AddressLayout PCONSOLE_READCONSOLE_CONTROL = C_POINTER;

    private static class ReadConsoleA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_LONG,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("ReadConsoleA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL ReadConsoleA(HANDLE hConsoleInput, LPVOID lpBuffer, DWORD nNumberOfCharsToRead, LPDWORD lpNumberOfCharsRead, PCONSOLE_READCONSOLE_CONTROL pInputControl)
     * }
     */
    public static FunctionDescriptor ReadConsoleA$descriptor() {
        return ReadConsoleA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL ReadConsoleA(HANDLE hConsoleInput, LPVOID lpBuffer, DWORD nNumberOfCharsToRead, LPDWORD lpNumberOfCharsRead, PCONSOLE_READCONSOLE_CONTROL pInputControl)
     * }
     */
    public static MethodHandle ReadConsoleA$handle() {
        return ReadConsoleA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL ReadConsoleA(HANDLE hConsoleInput, LPVOID lpBuffer, DWORD nNumberOfCharsToRead, LPDWORD lpNumberOfCharsRead, PCONSOLE_READCONSOLE_CONTROL pInputControl)
     * }
     */
    public static int ReadConsoleA(MemorySegment hConsoleInput, MemorySegment lpBuffer, int nNumberOfCharsToRead, MemorySegment lpNumberOfCharsRead, MemorySegment pInputControl) {
        var mh$ = ReadConsoleA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ReadConsoleA", hConsoleInput, lpBuffer, nNumberOfCharsToRead, lpNumberOfCharsRead, pInputControl);
            }
            return (int)mh$.invokeExact(hConsoleInput, lpBuffer, nNumberOfCharsToRead, lpNumberOfCharsRead, pInputControl);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ReadConsoleW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_LONG,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("ReadConsoleW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL ReadConsoleW(HANDLE hConsoleInput, LPVOID lpBuffer, DWORD nNumberOfCharsToRead, LPDWORD lpNumberOfCharsRead, PCONSOLE_READCONSOLE_CONTROL pInputControl)
     * }
     */
    public static FunctionDescriptor ReadConsoleW$descriptor() {
        return ReadConsoleW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL ReadConsoleW(HANDLE hConsoleInput, LPVOID lpBuffer, DWORD nNumberOfCharsToRead, LPDWORD lpNumberOfCharsRead, PCONSOLE_READCONSOLE_CONTROL pInputControl)
     * }
     */
    public static MethodHandle ReadConsoleW$handle() {
        return ReadConsoleW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL ReadConsoleW(HANDLE hConsoleInput, LPVOID lpBuffer, DWORD nNumberOfCharsToRead, LPDWORD lpNumberOfCharsRead, PCONSOLE_READCONSOLE_CONTROL pInputControl)
     * }
     */
    public static int ReadConsoleW(MemorySegment hConsoleInput, MemorySegment lpBuffer, int nNumberOfCharsToRead, MemorySegment lpNumberOfCharsRead, MemorySegment pInputControl) {
        var mh$ = ReadConsoleW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ReadConsoleW", hConsoleInput, lpBuffer, nNumberOfCharsToRead, lpNumberOfCharsRead, pInputControl);
            }
            return (int)mh$.invokeExact(hConsoleInput, lpBuffer, nNumberOfCharsToRead, lpNumberOfCharsRead, pInputControl);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class WriteConsoleA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_LONG,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("WriteConsoleA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL WriteConsoleA(HANDLE hConsoleOutput, const void *lpBuffer, DWORD nNumberOfCharsToWrite, LPDWORD lpNumberOfCharsWritten, LPVOID lpReserved)
     * }
     */
    public static FunctionDescriptor WriteConsoleA$descriptor() {
        return WriteConsoleA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL WriteConsoleA(HANDLE hConsoleOutput, const void *lpBuffer, DWORD nNumberOfCharsToWrite, LPDWORD lpNumberOfCharsWritten, LPVOID lpReserved)
     * }
     */
    public static MethodHandle WriteConsoleA$handle() {
        return WriteConsoleA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL WriteConsoleA(HANDLE hConsoleOutput, const void *lpBuffer, DWORD nNumberOfCharsToWrite, LPDWORD lpNumberOfCharsWritten, LPVOID lpReserved)
     * }
     */
    public static int WriteConsoleA(MemorySegment hConsoleOutput, MemorySegment lpBuffer, int nNumberOfCharsToWrite, MemorySegment lpNumberOfCharsWritten, MemorySegment lpReserved) {
        var mh$ = WriteConsoleA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WriteConsoleA", hConsoleOutput, lpBuffer, nNumberOfCharsToWrite, lpNumberOfCharsWritten, lpReserved);
            }
            return (int)mh$.invokeExact(hConsoleOutput, lpBuffer, nNumberOfCharsToWrite, lpNumberOfCharsWritten, lpReserved);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class WriteConsoleW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_LONG,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("WriteConsoleW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL WriteConsoleW(HANDLE hConsoleOutput, const void *lpBuffer, DWORD nNumberOfCharsToWrite, LPDWORD lpNumberOfCharsWritten, LPVOID lpReserved)
     * }
     */
    public static FunctionDescriptor WriteConsoleW$descriptor() {
        return WriteConsoleW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL WriteConsoleW(HANDLE hConsoleOutput, const void *lpBuffer, DWORD nNumberOfCharsToWrite, LPDWORD lpNumberOfCharsWritten, LPVOID lpReserved)
     * }
     */
    public static MethodHandle WriteConsoleW$handle() {
        return WriteConsoleW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL WriteConsoleW(HANDLE hConsoleOutput, const void *lpBuffer, DWORD nNumberOfCharsToWrite, LPDWORD lpNumberOfCharsWritten, LPVOID lpReserved)
     * }
     */
    public static int WriteConsoleW(MemorySegment hConsoleOutput, MemorySegment lpBuffer, int nNumberOfCharsToWrite, MemorySegment lpNumberOfCharsWritten, MemorySegment lpReserved) {
        var mh$ = WriteConsoleW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WriteConsoleW", hConsoleOutput, lpBuffer, nNumberOfCharsToWrite, lpNumberOfCharsWritten, lpReserved);
            }
            return (int)mh$.invokeExact(hConsoleOutput, lpBuffer, nNumberOfCharsToWrite, lpNumberOfCharsWritten, lpReserved);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetConsoleCtrlHandler {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("SetConsoleCtrlHandler"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetConsoleCtrlHandler(PHANDLER_ROUTINE HandlerRoutine, BOOL Add)
     * }
     */
    public static FunctionDescriptor SetConsoleCtrlHandler$descriptor() {
        return SetConsoleCtrlHandler.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetConsoleCtrlHandler(PHANDLER_ROUTINE HandlerRoutine, BOOL Add)
     * }
     */
    public static MethodHandle SetConsoleCtrlHandler$handle() {
        return SetConsoleCtrlHandler.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL SetConsoleCtrlHandler(PHANDLER_ROUTINE HandlerRoutine, BOOL Add)
     * }
     */
    public static int SetConsoleCtrlHandler(MemorySegment HandlerRoutine, int Add) {
        var mh$ = SetConsoleCtrlHandler.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetConsoleCtrlHandler", HandlerRoutine, Add);
            }
            return (int)mh$.invokeExact(HandlerRoutine, Add);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreatePseudoConsole {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            _COORD.layout(),
            C_POINTER,
            C_POINTER,
            C_LONG,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CreatePseudoConsole"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HRESULT CreatePseudoConsole(COORD size, HANDLE hInput, HANDLE hOutput, DWORD dwFlags, HPCON *phPC)
     * }
     */
    public static FunctionDescriptor CreatePseudoConsole$descriptor() {
        return CreatePseudoConsole.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HRESULT CreatePseudoConsole(COORD size, HANDLE hInput, HANDLE hOutput, DWORD dwFlags, HPCON *phPC)
     * }
     */
    public static MethodHandle CreatePseudoConsole$handle() {
        return CreatePseudoConsole.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * HRESULT CreatePseudoConsole(COORD size, HANDLE hInput, HANDLE hOutput, DWORD dwFlags, HPCON *phPC)
     * }
     */
    public static int CreatePseudoConsole(MemorySegment size, MemorySegment hInput, MemorySegment hOutput, int dwFlags, MemorySegment phPC) {
        var mh$ = CreatePseudoConsole.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreatePseudoConsole", size, hInput, hOutput, dwFlags, phPC);
            }
            return (int)mh$.invokeExact(size, hInput, hOutput, dwFlags, phPC);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ResizePseudoConsole {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_POINTER,
            _COORD.layout()
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("ResizePseudoConsole"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HRESULT ResizePseudoConsole(HPCON hPC, COORD size)
     * }
     */
    public static FunctionDescriptor ResizePseudoConsole$descriptor() {
        return ResizePseudoConsole.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HRESULT ResizePseudoConsole(HPCON hPC, COORD size)
     * }
     */
    public static MethodHandle ResizePseudoConsole$handle() {
        return ResizePseudoConsole.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * HRESULT ResizePseudoConsole(HPCON hPC, COORD size)
     * }
     */
    public static int ResizePseudoConsole(MemorySegment hPC, MemorySegment size) {
        var mh$ = ResizePseudoConsole.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ResizePseudoConsole", hPC, size);
            }
            return (int)mh$.invokeExact(hPC, size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ClosePseudoConsole {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("ClosePseudoConsole"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ClosePseudoConsole(HPCON hPC)
     * }
     */
    public static FunctionDescriptor ClosePseudoConsole$descriptor() {
        return ClosePseudoConsole.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ClosePseudoConsole(HPCON hPC)
     * }
     */
    public static MethodHandle ClosePseudoConsole$handle() {
        return ClosePseudoConsole.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * void ClosePseudoConsole(HPCON hPC)
     * }
     */
    public static void ClosePseudoConsole(MemorySegment hPC) {
        var mh$ = ClosePseudoConsole.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ClosePseudoConsole", hPC);
            }
            mh$.invokeExact(hPC);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FillConsoleOutputCharacterA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_CHAR,
            C_LONG,
            _COORD.layout(),
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("FillConsoleOutputCharacterA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL FillConsoleOutputCharacterA(HANDLE hConsoleOutput, CHAR cCharacter, DWORD nLength, COORD dwWriteCoord, LPDWORD lpNumberOfCharsWritten)
     * }
     */
    public static FunctionDescriptor FillConsoleOutputCharacterA$descriptor() {
        return FillConsoleOutputCharacterA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL FillConsoleOutputCharacterA(HANDLE hConsoleOutput, CHAR cCharacter, DWORD nLength, COORD dwWriteCoord, LPDWORD lpNumberOfCharsWritten)
     * }
     */
    public static MethodHandle FillConsoleOutputCharacterA$handle() {
        return FillConsoleOutputCharacterA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL FillConsoleOutputCharacterA(HANDLE hConsoleOutput, CHAR cCharacter, DWORD nLength, COORD dwWriteCoord, LPDWORD lpNumberOfCharsWritten)
     * }
     */
    public static int FillConsoleOutputCharacterA(MemorySegment hConsoleOutput, byte cCharacter, int nLength, MemorySegment dwWriteCoord, MemorySegment lpNumberOfCharsWritten) {
        var mh$ = FillConsoleOutputCharacterA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FillConsoleOutputCharacterA", hConsoleOutput, cCharacter, nLength, dwWriteCoord, lpNumberOfCharsWritten);
            }
            return (int)mh$.invokeExact(hConsoleOutput, cCharacter, nLength, dwWriteCoord, lpNumberOfCharsWritten);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FillConsoleOutputCharacterW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_SHORT,
            C_LONG,
            _COORD.layout(),
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("FillConsoleOutputCharacterW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL FillConsoleOutputCharacterW(HANDLE hConsoleOutput, WCHAR cCharacter, DWORD nLength, COORD dwWriteCoord, LPDWORD lpNumberOfCharsWritten)
     * }
     */
    public static FunctionDescriptor FillConsoleOutputCharacterW$descriptor() {
        return FillConsoleOutputCharacterW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL FillConsoleOutputCharacterW(HANDLE hConsoleOutput, WCHAR cCharacter, DWORD nLength, COORD dwWriteCoord, LPDWORD lpNumberOfCharsWritten)
     * }
     */
    public static MethodHandle FillConsoleOutputCharacterW$handle() {
        return FillConsoleOutputCharacterW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL FillConsoleOutputCharacterW(HANDLE hConsoleOutput, WCHAR cCharacter, DWORD nLength, COORD dwWriteCoord, LPDWORD lpNumberOfCharsWritten)
     * }
     */
    public static int FillConsoleOutputCharacterW(MemorySegment hConsoleOutput, short cCharacter, int nLength, MemorySegment dwWriteCoord, MemorySegment lpNumberOfCharsWritten) {
        var mh$ = FillConsoleOutputCharacterW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FillConsoleOutputCharacterW", hConsoleOutput, cCharacter, nLength, dwWriteCoord, lpNumberOfCharsWritten);
            }
            return (int)mh$.invokeExact(hConsoleOutput, cCharacter, nLength, dwWriteCoord, lpNumberOfCharsWritten);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FillConsoleOutputAttribute {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_SHORT,
            C_LONG,
            _COORD.layout(),
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("FillConsoleOutputAttribute"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL FillConsoleOutputAttribute(HANDLE hConsoleOutput, WORD wAttribute, DWORD nLength, COORD dwWriteCoord, LPDWORD lpNumberOfAttrsWritten)
     * }
     */
    public static FunctionDescriptor FillConsoleOutputAttribute$descriptor() {
        return FillConsoleOutputAttribute.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL FillConsoleOutputAttribute(HANDLE hConsoleOutput, WORD wAttribute, DWORD nLength, COORD dwWriteCoord, LPDWORD lpNumberOfAttrsWritten)
     * }
     */
    public static MethodHandle FillConsoleOutputAttribute$handle() {
        return FillConsoleOutputAttribute.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL FillConsoleOutputAttribute(HANDLE hConsoleOutput, WORD wAttribute, DWORD nLength, COORD dwWriteCoord, LPDWORD lpNumberOfAttrsWritten)
     * }
     */
    public static int FillConsoleOutputAttribute(MemorySegment hConsoleOutput, short wAttribute, int nLength, MemorySegment dwWriteCoord, MemorySegment lpNumberOfAttrsWritten) {
        var mh$ = FillConsoleOutputAttribute.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FillConsoleOutputAttribute", hConsoleOutput, wAttribute, nLength, dwWriteCoord, lpNumberOfAttrsWritten);
            }
            return (int)mh$.invokeExact(hConsoleOutput, wAttribute, nLength, dwWriteCoord, lpNumberOfAttrsWritten);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GenerateConsoleCtrlEvent {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_LONG,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GenerateConsoleCtrlEvent"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GenerateConsoleCtrlEvent(DWORD dwCtrlEvent, DWORD dwProcessGroupId)
     * }
     */
    public static FunctionDescriptor GenerateConsoleCtrlEvent$descriptor() {
        return GenerateConsoleCtrlEvent.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GenerateConsoleCtrlEvent(DWORD dwCtrlEvent, DWORD dwProcessGroupId)
     * }
     */
    public static MethodHandle GenerateConsoleCtrlEvent$handle() {
        return GenerateConsoleCtrlEvent.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL GenerateConsoleCtrlEvent(DWORD dwCtrlEvent, DWORD dwProcessGroupId)
     * }
     */
    public static int GenerateConsoleCtrlEvent(int dwCtrlEvent, int dwProcessGroupId) {
        var mh$ = GenerateConsoleCtrlEvent.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GenerateConsoleCtrlEvent", dwCtrlEvent, dwProcessGroupId);
            }
            return (int)mh$.invokeExact(dwCtrlEvent, dwProcessGroupId);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateConsoleScreenBuffer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_LONG,
            C_LONG,
            C_POINTER,
            C_LONG,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CreateConsoleScreenBuffer"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HANDLE CreateConsoleScreenBuffer(DWORD dwDesiredAccess, DWORD dwShareMode, const SECURITY_ATTRIBUTES *lpSecurityAttributes, DWORD dwFlags, LPVOID lpScreenBufferData)
     * }
     */
    public static FunctionDescriptor CreateConsoleScreenBuffer$descriptor() {
        return CreateConsoleScreenBuffer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HANDLE CreateConsoleScreenBuffer(DWORD dwDesiredAccess, DWORD dwShareMode, const SECURITY_ATTRIBUTES *lpSecurityAttributes, DWORD dwFlags, LPVOID lpScreenBufferData)
     * }
     */
    public static MethodHandle CreateConsoleScreenBuffer$handle() {
        return CreateConsoleScreenBuffer.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * HANDLE CreateConsoleScreenBuffer(DWORD dwDesiredAccess, DWORD dwShareMode, const SECURITY_ATTRIBUTES *lpSecurityAttributes, DWORD dwFlags, LPVOID lpScreenBufferData)
     * }
     */
    public static MemorySegment CreateConsoleScreenBuffer(int dwDesiredAccess, int dwShareMode, MemorySegment lpSecurityAttributes, int dwFlags, MemorySegment lpScreenBufferData) {
        var mh$ = CreateConsoleScreenBuffer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateConsoleScreenBuffer", dwDesiredAccess, dwShareMode, lpSecurityAttributes, dwFlags, lpScreenBufferData);
            }
            return (MemorySegment)mh$.invokeExact(dwDesiredAccess, dwShareMode, lpSecurityAttributes, dwFlags, lpScreenBufferData);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetConsoleActiveScreenBuffer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("SetConsoleActiveScreenBuffer"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetConsoleActiveScreenBuffer(HANDLE hConsoleOutput)
     * }
     */
    public static FunctionDescriptor SetConsoleActiveScreenBuffer$descriptor() {
        return SetConsoleActiveScreenBuffer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetConsoleActiveScreenBuffer(HANDLE hConsoleOutput)
     * }
     */
    public static MethodHandle SetConsoleActiveScreenBuffer$handle() {
        return SetConsoleActiveScreenBuffer.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL SetConsoleActiveScreenBuffer(HANDLE hConsoleOutput)
     * }
     */
    public static int SetConsoleActiveScreenBuffer(MemorySegment hConsoleOutput) {
        var mh$ = SetConsoleActiveScreenBuffer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetConsoleActiveScreenBuffer", hConsoleOutput);
            }
            return (int)mh$.invokeExact(hConsoleOutput);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FlushConsoleInputBuffer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("FlushConsoleInputBuffer"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL FlushConsoleInputBuffer(HANDLE hConsoleInput)
     * }
     */
    public static FunctionDescriptor FlushConsoleInputBuffer$descriptor() {
        return FlushConsoleInputBuffer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL FlushConsoleInputBuffer(HANDLE hConsoleInput)
     * }
     */
    public static MethodHandle FlushConsoleInputBuffer$handle() {
        return FlushConsoleInputBuffer.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL FlushConsoleInputBuffer(HANDLE hConsoleInput)
     * }
     */
    public static int FlushConsoleInputBuffer(MemorySegment hConsoleInput) {
        var mh$ = FlushConsoleInputBuffer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FlushConsoleInputBuffer", hConsoleInput);
            }
            return (int)mh$.invokeExact(hConsoleInput);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetConsoleCP {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("SetConsoleCP"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetConsoleCP(UINT wCodePageID)
     * }
     */
    public static FunctionDescriptor SetConsoleCP$descriptor() {
        return SetConsoleCP.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetConsoleCP(UINT wCodePageID)
     * }
     */
    public static MethodHandle SetConsoleCP$handle() {
        return SetConsoleCP.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL SetConsoleCP(UINT wCodePageID)
     * }
     */
    public static int SetConsoleCP(int wCodePageID) {
        var mh$ = SetConsoleCP.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetConsoleCP", wCodePageID);
            }
            return (int)mh$.invokeExact(wCodePageID);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetConsoleOutputCP {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("SetConsoleOutputCP"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetConsoleOutputCP(UINT wCodePageID)
     * }
     */
    public static FunctionDescriptor SetConsoleOutputCP$descriptor() {
        return SetConsoleOutputCP.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetConsoleOutputCP(UINT wCodePageID)
     * }
     */
    public static MethodHandle SetConsoleOutputCP$handle() {
        return SetConsoleOutputCP.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL SetConsoleOutputCP(UINT wCodePageID)
     * }
     */
    public static int SetConsoleOutputCP(int wCodePageID) {
        var mh$ = SetConsoleOutputCP.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetConsoleOutputCP", wCodePageID);
            }
            return (int)mh$.invokeExact(wCodePageID);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct _CONSOLE_CURSOR_INFO {
     *     DWORD dwSize;
     *     BOOL bVisible;
     * } *PCONSOLE_CURSOR_INFO
     * }
     */
    public static final AddressLayout PCONSOLE_CURSOR_INFO = C_POINTER;

    private static class GetConsoleCursorInfo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetConsoleCursorInfo"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetConsoleCursorInfo(HANDLE hConsoleOutput, PCONSOLE_CURSOR_INFO lpConsoleCursorInfo)
     * }
     */
    public static FunctionDescriptor GetConsoleCursorInfo$descriptor() {
        return GetConsoleCursorInfo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetConsoleCursorInfo(HANDLE hConsoleOutput, PCONSOLE_CURSOR_INFO lpConsoleCursorInfo)
     * }
     */
    public static MethodHandle GetConsoleCursorInfo$handle() {
        return GetConsoleCursorInfo.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL GetConsoleCursorInfo(HANDLE hConsoleOutput, PCONSOLE_CURSOR_INFO lpConsoleCursorInfo)
     * }
     */
    public static int GetConsoleCursorInfo(MemorySegment hConsoleOutput, MemorySegment lpConsoleCursorInfo) {
        var mh$ = GetConsoleCursorInfo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetConsoleCursorInfo", hConsoleOutput, lpConsoleCursorInfo);
            }
            return (int)mh$.invokeExact(hConsoleOutput, lpConsoleCursorInfo);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetConsoleCursorInfo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("SetConsoleCursorInfo"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetConsoleCursorInfo(HANDLE hConsoleOutput, const CONSOLE_CURSOR_INFO *lpConsoleCursorInfo)
     * }
     */
    public static FunctionDescriptor SetConsoleCursorInfo$descriptor() {
        return SetConsoleCursorInfo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetConsoleCursorInfo(HANDLE hConsoleOutput, const CONSOLE_CURSOR_INFO *lpConsoleCursorInfo)
     * }
     */
    public static MethodHandle SetConsoleCursorInfo$handle() {
        return SetConsoleCursorInfo.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL SetConsoleCursorInfo(HANDLE hConsoleOutput, const CONSOLE_CURSOR_INFO *lpConsoleCursorInfo)
     * }
     */
    public static int SetConsoleCursorInfo(MemorySegment hConsoleOutput, MemorySegment lpConsoleCursorInfo) {
        var mh$ = SetConsoleCursorInfo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetConsoleCursorInfo", hConsoleOutput, lpConsoleCursorInfo);
            }
            return (int)mh$.invokeExact(hConsoleOutput, lpConsoleCursorInfo);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct _CONSOLE_SCREEN_BUFFER_INFO {
     *     COORD dwSize;
     *     COORD dwCursorPosition;
     *     WORD wAttributes;
     *     SMALL_RECT srWindow;
     *     COORD dwMaximumWindowSize;
     * } *PCONSOLE_SCREEN_BUFFER_INFO
     * }
     */
    public static final AddressLayout PCONSOLE_SCREEN_BUFFER_INFO = C_POINTER;

    private static class GetConsoleScreenBufferInfo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetConsoleScreenBufferInfo"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetConsoleScreenBufferInfo(HANDLE hConsoleOutput, PCONSOLE_SCREEN_BUFFER_INFO lpConsoleScreenBufferInfo)
     * }
     */
    public static FunctionDescriptor GetConsoleScreenBufferInfo$descriptor() {
        return GetConsoleScreenBufferInfo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetConsoleScreenBufferInfo(HANDLE hConsoleOutput, PCONSOLE_SCREEN_BUFFER_INFO lpConsoleScreenBufferInfo)
     * }
     */
    public static MethodHandle GetConsoleScreenBufferInfo$handle() {
        return GetConsoleScreenBufferInfo.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL GetConsoleScreenBufferInfo(HANDLE hConsoleOutput, PCONSOLE_SCREEN_BUFFER_INFO lpConsoleScreenBufferInfo)
     * }
     */
    public static int GetConsoleScreenBufferInfo(MemorySegment hConsoleOutput, MemorySegment lpConsoleScreenBufferInfo) {
        var mh$ = GetConsoleScreenBufferInfo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetConsoleScreenBufferInfo", hConsoleOutput, lpConsoleScreenBufferInfo);
            }
            return (int)mh$.invokeExact(hConsoleOutput, lpConsoleScreenBufferInfo);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct _CONSOLE_SCREEN_BUFFER_INFOEX {
     *     ULONG cbSize;
     *     COORD dwSize;
     *     COORD dwCursorPosition;
     *     WORD wAttributes;
     *     SMALL_RECT srWindow;
     *     COORD dwMaximumWindowSize;
     *     WORD wPopupAttributes;
     *     BOOL bFullscreenSupported;
     *     COLORREF ColorTable[16];
     * } *PCONSOLE_SCREEN_BUFFER_INFOEX
     * }
     */
    public static final AddressLayout PCONSOLE_SCREEN_BUFFER_INFOEX = C_POINTER;

    private static class GetConsoleScreenBufferInfoEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetConsoleScreenBufferInfoEx"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetConsoleScreenBufferInfoEx(HANDLE hConsoleOutput, PCONSOLE_SCREEN_BUFFER_INFOEX lpConsoleScreenBufferInfoEx)
     * }
     */
    public static FunctionDescriptor GetConsoleScreenBufferInfoEx$descriptor() {
        return GetConsoleScreenBufferInfoEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetConsoleScreenBufferInfoEx(HANDLE hConsoleOutput, PCONSOLE_SCREEN_BUFFER_INFOEX lpConsoleScreenBufferInfoEx)
     * }
     */
    public static MethodHandle GetConsoleScreenBufferInfoEx$handle() {
        return GetConsoleScreenBufferInfoEx.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL GetConsoleScreenBufferInfoEx(HANDLE hConsoleOutput, PCONSOLE_SCREEN_BUFFER_INFOEX lpConsoleScreenBufferInfoEx)
     * }
     */
    public static int GetConsoleScreenBufferInfoEx(MemorySegment hConsoleOutput, MemorySegment lpConsoleScreenBufferInfoEx) {
        var mh$ = GetConsoleScreenBufferInfoEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetConsoleScreenBufferInfoEx", hConsoleOutput, lpConsoleScreenBufferInfoEx);
            }
            return (int)mh$.invokeExact(hConsoleOutput, lpConsoleScreenBufferInfoEx);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetConsoleScreenBufferInfoEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("SetConsoleScreenBufferInfoEx"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetConsoleScreenBufferInfoEx(HANDLE hConsoleOutput, PCONSOLE_SCREEN_BUFFER_INFOEX lpConsoleScreenBufferInfoEx)
     * }
     */
    public static FunctionDescriptor SetConsoleScreenBufferInfoEx$descriptor() {
        return SetConsoleScreenBufferInfoEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetConsoleScreenBufferInfoEx(HANDLE hConsoleOutput, PCONSOLE_SCREEN_BUFFER_INFOEX lpConsoleScreenBufferInfoEx)
     * }
     */
    public static MethodHandle SetConsoleScreenBufferInfoEx$handle() {
        return SetConsoleScreenBufferInfoEx.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL SetConsoleScreenBufferInfoEx(HANDLE hConsoleOutput, PCONSOLE_SCREEN_BUFFER_INFOEX lpConsoleScreenBufferInfoEx)
     * }
     */
    public static int SetConsoleScreenBufferInfoEx(MemorySegment hConsoleOutput, MemorySegment lpConsoleScreenBufferInfoEx) {
        var mh$ = SetConsoleScreenBufferInfoEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetConsoleScreenBufferInfoEx", hConsoleOutput, lpConsoleScreenBufferInfoEx);
            }
            return (int)mh$.invokeExact(hConsoleOutput, lpConsoleScreenBufferInfoEx);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetConsoleScreenBufferSize {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            _COORD.layout()
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("SetConsoleScreenBufferSize"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetConsoleScreenBufferSize(HANDLE hConsoleOutput, COORD dwSize)
     * }
     */
    public static FunctionDescriptor SetConsoleScreenBufferSize$descriptor() {
        return SetConsoleScreenBufferSize.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetConsoleScreenBufferSize(HANDLE hConsoleOutput, COORD dwSize)
     * }
     */
    public static MethodHandle SetConsoleScreenBufferSize$handle() {
        return SetConsoleScreenBufferSize.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL SetConsoleScreenBufferSize(HANDLE hConsoleOutput, COORD dwSize)
     * }
     */
    public static int SetConsoleScreenBufferSize(MemorySegment hConsoleOutput, MemorySegment dwSize) {
        var mh$ = SetConsoleScreenBufferSize.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetConsoleScreenBufferSize", hConsoleOutput, dwSize);
            }
            return (int)mh$.invokeExact(hConsoleOutput, dwSize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetConsoleCursorPosition {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            _COORD.layout()
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("SetConsoleCursorPosition"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetConsoleCursorPosition(HANDLE hConsoleOutput, COORD dwCursorPosition)
     * }
     */
    public static FunctionDescriptor SetConsoleCursorPosition$descriptor() {
        return SetConsoleCursorPosition.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetConsoleCursorPosition(HANDLE hConsoleOutput, COORD dwCursorPosition)
     * }
     */
    public static MethodHandle SetConsoleCursorPosition$handle() {
        return SetConsoleCursorPosition.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL SetConsoleCursorPosition(HANDLE hConsoleOutput, COORD dwCursorPosition)
     * }
     */
    public static int SetConsoleCursorPosition(MemorySegment hConsoleOutput, MemorySegment dwCursorPosition) {
        var mh$ = SetConsoleCursorPosition.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetConsoleCursorPosition", hConsoleOutput, dwCursorPosition);
            }
            return (int)mh$.invokeExact(hConsoleOutput, dwCursorPosition);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetLargestConsoleWindowSize {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            _COORD.layout(),
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetLargestConsoleWindowSize"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * COORD GetLargestConsoleWindowSize(HANDLE hConsoleOutput)
     * }
     */
    public static FunctionDescriptor GetLargestConsoleWindowSize$descriptor() {
        return GetLargestConsoleWindowSize.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * COORD GetLargestConsoleWindowSize(HANDLE hConsoleOutput)
     * }
     */
    public static MethodHandle GetLargestConsoleWindowSize$handle() {
        return GetLargestConsoleWindowSize.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * COORD GetLargestConsoleWindowSize(HANDLE hConsoleOutput)
     * }
     */
    public static MemorySegment GetLargestConsoleWindowSize(SegmentAllocator allocator, MemorySegment hConsoleOutput) {
        var mh$ = GetLargestConsoleWindowSize.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetLargestConsoleWindowSize", allocator, hConsoleOutput);
            }
            return (MemorySegment)mh$.invokeExact(allocator, hConsoleOutput);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetConsoleTextAttribute {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_SHORT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("SetConsoleTextAttribute"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetConsoleTextAttribute(HANDLE hConsoleOutput, WORD wAttributes)
     * }
     */
    public static FunctionDescriptor SetConsoleTextAttribute$descriptor() {
        return SetConsoleTextAttribute.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetConsoleTextAttribute(HANDLE hConsoleOutput, WORD wAttributes)
     * }
     */
    public static MethodHandle SetConsoleTextAttribute$handle() {
        return SetConsoleTextAttribute.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL SetConsoleTextAttribute(HANDLE hConsoleOutput, WORD wAttributes)
     * }
     */
    public static int SetConsoleTextAttribute(MemorySegment hConsoleOutput, short wAttributes) {
        var mh$ = SetConsoleTextAttribute.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetConsoleTextAttribute", hConsoleOutput, wAttributes);
            }
            return (int)mh$.invokeExact(hConsoleOutput, wAttributes);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetConsoleWindowInfo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("SetConsoleWindowInfo"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetConsoleWindowInfo(HANDLE hConsoleOutput, BOOL bAbsolute, const SMALL_RECT *lpConsoleWindow)
     * }
     */
    public static FunctionDescriptor SetConsoleWindowInfo$descriptor() {
        return SetConsoleWindowInfo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetConsoleWindowInfo(HANDLE hConsoleOutput, BOOL bAbsolute, const SMALL_RECT *lpConsoleWindow)
     * }
     */
    public static MethodHandle SetConsoleWindowInfo$handle() {
        return SetConsoleWindowInfo.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL SetConsoleWindowInfo(HANDLE hConsoleOutput, BOOL bAbsolute, const SMALL_RECT *lpConsoleWindow)
     * }
     */
    public static int SetConsoleWindowInfo(MemorySegment hConsoleOutput, int bAbsolute, MemorySegment lpConsoleWindow) {
        var mh$ = SetConsoleWindowInfo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetConsoleWindowInfo", hConsoleOutput, bAbsolute, lpConsoleWindow);
            }
            return (int)mh$.invokeExact(hConsoleOutput, bAbsolute, lpConsoleWindow);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class WriteConsoleOutputCharacterA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_LONG,
            _COORD.layout(),
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("WriteConsoleOutputCharacterA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL WriteConsoleOutputCharacterA(HANDLE hConsoleOutput, LPCSTR lpCharacter, DWORD nLength, COORD dwWriteCoord, LPDWORD lpNumberOfCharsWritten)
     * }
     */
    public static FunctionDescriptor WriteConsoleOutputCharacterA$descriptor() {
        return WriteConsoleOutputCharacterA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL WriteConsoleOutputCharacterA(HANDLE hConsoleOutput, LPCSTR lpCharacter, DWORD nLength, COORD dwWriteCoord, LPDWORD lpNumberOfCharsWritten)
     * }
     */
    public static MethodHandle WriteConsoleOutputCharacterA$handle() {
        return WriteConsoleOutputCharacterA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL WriteConsoleOutputCharacterA(HANDLE hConsoleOutput, LPCSTR lpCharacter, DWORD nLength, COORD dwWriteCoord, LPDWORD lpNumberOfCharsWritten)
     * }
     */
    public static int WriteConsoleOutputCharacterA(MemorySegment hConsoleOutput, MemorySegment lpCharacter, int nLength, MemorySegment dwWriteCoord, MemorySegment lpNumberOfCharsWritten) {
        var mh$ = WriteConsoleOutputCharacterA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WriteConsoleOutputCharacterA", hConsoleOutput, lpCharacter, nLength, dwWriteCoord, lpNumberOfCharsWritten);
            }
            return (int)mh$.invokeExact(hConsoleOutput, lpCharacter, nLength, dwWriteCoord, lpNumberOfCharsWritten);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class WriteConsoleOutputCharacterW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_LONG,
            _COORD.layout(),
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("WriteConsoleOutputCharacterW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL WriteConsoleOutputCharacterW(HANDLE hConsoleOutput, LPCWSTR lpCharacter, DWORD nLength, COORD dwWriteCoord, LPDWORD lpNumberOfCharsWritten)
     * }
     */
    public static FunctionDescriptor WriteConsoleOutputCharacterW$descriptor() {
        return WriteConsoleOutputCharacterW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL WriteConsoleOutputCharacterW(HANDLE hConsoleOutput, LPCWSTR lpCharacter, DWORD nLength, COORD dwWriteCoord, LPDWORD lpNumberOfCharsWritten)
     * }
     */
    public static MethodHandle WriteConsoleOutputCharacterW$handle() {
        return WriteConsoleOutputCharacterW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL WriteConsoleOutputCharacterW(HANDLE hConsoleOutput, LPCWSTR lpCharacter, DWORD nLength, COORD dwWriteCoord, LPDWORD lpNumberOfCharsWritten)
     * }
     */
    public static int WriteConsoleOutputCharacterW(MemorySegment hConsoleOutput, MemorySegment lpCharacter, int nLength, MemorySegment dwWriteCoord, MemorySegment lpNumberOfCharsWritten) {
        var mh$ = WriteConsoleOutputCharacterW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WriteConsoleOutputCharacterW", hConsoleOutput, lpCharacter, nLength, dwWriteCoord, lpNumberOfCharsWritten);
            }
            return (int)mh$.invokeExact(hConsoleOutput, lpCharacter, nLength, dwWriteCoord, lpNumberOfCharsWritten);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class WriteConsoleOutputAttribute {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_LONG,
            _COORD.layout(),
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("WriteConsoleOutputAttribute"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL WriteConsoleOutputAttribute(HANDLE hConsoleOutput, const WORD *lpAttribute, DWORD nLength, COORD dwWriteCoord, LPDWORD lpNumberOfAttrsWritten)
     * }
     */
    public static FunctionDescriptor WriteConsoleOutputAttribute$descriptor() {
        return WriteConsoleOutputAttribute.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL WriteConsoleOutputAttribute(HANDLE hConsoleOutput, const WORD *lpAttribute, DWORD nLength, COORD dwWriteCoord, LPDWORD lpNumberOfAttrsWritten)
     * }
     */
    public static MethodHandle WriteConsoleOutputAttribute$handle() {
        return WriteConsoleOutputAttribute.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL WriteConsoleOutputAttribute(HANDLE hConsoleOutput, const WORD *lpAttribute, DWORD nLength, COORD dwWriteCoord, LPDWORD lpNumberOfAttrsWritten)
     * }
     */
    public static int WriteConsoleOutputAttribute(MemorySegment hConsoleOutput, MemorySegment lpAttribute, int nLength, MemorySegment dwWriteCoord, MemorySegment lpNumberOfAttrsWritten) {
        var mh$ = WriteConsoleOutputAttribute.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WriteConsoleOutputAttribute", hConsoleOutput, lpAttribute, nLength, dwWriteCoord, lpNumberOfAttrsWritten);
            }
            return (int)mh$.invokeExact(hConsoleOutput, lpAttribute, nLength, dwWriteCoord, lpNumberOfAttrsWritten);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ReadConsoleOutputCharacterA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_LONG,
            _COORD.layout(),
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("ReadConsoleOutputCharacterA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL ReadConsoleOutputCharacterA(HANDLE hConsoleOutput, LPSTR lpCharacter, DWORD nLength, COORD dwReadCoord, LPDWORD lpNumberOfCharsRead)
     * }
     */
    public static FunctionDescriptor ReadConsoleOutputCharacterA$descriptor() {
        return ReadConsoleOutputCharacterA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL ReadConsoleOutputCharacterA(HANDLE hConsoleOutput, LPSTR lpCharacter, DWORD nLength, COORD dwReadCoord, LPDWORD lpNumberOfCharsRead)
     * }
     */
    public static MethodHandle ReadConsoleOutputCharacterA$handle() {
        return ReadConsoleOutputCharacterA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL ReadConsoleOutputCharacterA(HANDLE hConsoleOutput, LPSTR lpCharacter, DWORD nLength, COORD dwReadCoord, LPDWORD lpNumberOfCharsRead)
     * }
     */
    public static int ReadConsoleOutputCharacterA(MemorySegment hConsoleOutput, MemorySegment lpCharacter, int nLength, MemorySegment dwReadCoord, MemorySegment lpNumberOfCharsRead) {
        var mh$ = ReadConsoleOutputCharacterA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ReadConsoleOutputCharacterA", hConsoleOutput, lpCharacter, nLength, dwReadCoord, lpNumberOfCharsRead);
            }
            return (int)mh$.invokeExact(hConsoleOutput, lpCharacter, nLength, dwReadCoord, lpNumberOfCharsRead);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ReadConsoleOutputCharacterW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_LONG,
            _COORD.layout(),
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("ReadConsoleOutputCharacterW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL ReadConsoleOutputCharacterW(HANDLE hConsoleOutput, LPWSTR lpCharacter, DWORD nLength, COORD dwReadCoord, LPDWORD lpNumberOfCharsRead)
     * }
     */
    public static FunctionDescriptor ReadConsoleOutputCharacterW$descriptor() {
        return ReadConsoleOutputCharacterW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL ReadConsoleOutputCharacterW(HANDLE hConsoleOutput, LPWSTR lpCharacter, DWORD nLength, COORD dwReadCoord, LPDWORD lpNumberOfCharsRead)
     * }
     */
    public static MethodHandle ReadConsoleOutputCharacterW$handle() {
        return ReadConsoleOutputCharacterW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL ReadConsoleOutputCharacterW(HANDLE hConsoleOutput, LPWSTR lpCharacter, DWORD nLength, COORD dwReadCoord, LPDWORD lpNumberOfCharsRead)
     * }
     */
    public static int ReadConsoleOutputCharacterW(MemorySegment hConsoleOutput, MemorySegment lpCharacter, int nLength, MemorySegment dwReadCoord, MemorySegment lpNumberOfCharsRead) {
        var mh$ = ReadConsoleOutputCharacterW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ReadConsoleOutputCharacterW", hConsoleOutput, lpCharacter, nLength, dwReadCoord, lpNumberOfCharsRead);
            }
            return (int)mh$.invokeExact(hConsoleOutput, lpCharacter, nLength, dwReadCoord, lpNumberOfCharsRead);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ReadConsoleOutputAttribute {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_LONG,
            _COORD.layout(),
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("ReadConsoleOutputAttribute"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL ReadConsoleOutputAttribute(HANDLE hConsoleOutput, LPWORD lpAttribute, DWORD nLength, COORD dwReadCoord, LPDWORD lpNumberOfAttrsRead)
     * }
     */
    public static FunctionDescriptor ReadConsoleOutputAttribute$descriptor() {
        return ReadConsoleOutputAttribute.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL ReadConsoleOutputAttribute(HANDLE hConsoleOutput, LPWORD lpAttribute, DWORD nLength, COORD dwReadCoord, LPDWORD lpNumberOfAttrsRead)
     * }
     */
    public static MethodHandle ReadConsoleOutputAttribute$handle() {
        return ReadConsoleOutputAttribute.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL ReadConsoleOutputAttribute(HANDLE hConsoleOutput, LPWORD lpAttribute, DWORD nLength, COORD dwReadCoord, LPDWORD lpNumberOfAttrsRead)
     * }
     */
    public static int ReadConsoleOutputAttribute(MemorySegment hConsoleOutput, MemorySegment lpAttribute, int nLength, MemorySegment dwReadCoord, MemorySegment lpNumberOfAttrsRead) {
        var mh$ = ReadConsoleOutputAttribute.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ReadConsoleOutputAttribute", hConsoleOutput, lpAttribute, nLength, dwReadCoord, lpNumberOfAttrsRead);
            }
            return (int)mh$.invokeExact(hConsoleOutput, lpAttribute, nLength, dwReadCoord, lpNumberOfAttrsRead);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class WriteConsoleInputA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_LONG,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("WriteConsoleInputA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL WriteConsoleInputA(HANDLE hConsoleInput, const INPUT_RECORD *lpBuffer, DWORD nLength, LPDWORD lpNumberOfEventsWritten)
     * }
     */
    public static FunctionDescriptor WriteConsoleInputA$descriptor() {
        return WriteConsoleInputA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL WriteConsoleInputA(HANDLE hConsoleInput, const INPUT_RECORD *lpBuffer, DWORD nLength, LPDWORD lpNumberOfEventsWritten)
     * }
     */
    public static MethodHandle WriteConsoleInputA$handle() {
        return WriteConsoleInputA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL WriteConsoleInputA(HANDLE hConsoleInput, const INPUT_RECORD *lpBuffer, DWORD nLength, LPDWORD lpNumberOfEventsWritten)
     * }
     */
    public static int WriteConsoleInputA(MemorySegment hConsoleInput, MemorySegment lpBuffer, int nLength, MemorySegment lpNumberOfEventsWritten) {
        var mh$ = WriteConsoleInputA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WriteConsoleInputA", hConsoleInput, lpBuffer, nLength, lpNumberOfEventsWritten);
            }
            return (int)mh$.invokeExact(hConsoleInput, lpBuffer, nLength, lpNumberOfEventsWritten);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class WriteConsoleInputW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_LONG,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("WriteConsoleInputW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL WriteConsoleInputW(HANDLE hConsoleInput, const INPUT_RECORD *lpBuffer, DWORD nLength, LPDWORD lpNumberOfEventsWritten)
     * }
     */
    public static FunctionDescriptor WriteConsoleInputW$descriptor() {
        return WriteConsoleInputW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL WriteConsoleInputW(HANDLE hConsoleInput, const INPUT_RECORD *lpBuffer, DWORD nLength, LPDWORD lpNumberOfEventsWritten)
     * }
     */
    public static MethodHandle WriteConsoleInputW$handle() {
        return WriteConsoleInputW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL WriteConsoleInputW(HANDLE hConsoleInput, const INPUT_RECORD *lpBuffer, DWORD nLength, LPDWORD lpNumberOfEventsWritten)
     * }
     */
    public static int WriteConsoleInputW(MemorySegment hConsoleInput, MemorySegment lpBuffer, int nLength, MemorySegment lpNumberOfEventsWritten) {
        var mh$ = WriteConsoleInputW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WriteConsoleInputW", hConsoleInput, lpBuffer, nLength, lpNumberOfEventsWritten);
            }
            return (int)mh$.invokeExact(hConsoleInput, lpBuffer, nLength, lpNumberOfEventsWritten);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ScrollConsoleScreenBufferA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            _COORD.layout(),
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("ScrollConsoleScreenBufferA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL ScrollConsoleScreenBufferA(HANDLE hConsoleOutput, const SMALL_RECT *lpScrollRectangle, const SMALL_RECT *lpClipRectangle, COORD dwDestinationOrigin, const CHAR_INFO *lpFill)
     * }
     */
    public static FunctionDescriptor ScrollConsoleScreenBufferA$descriptor() {
        return ScrollConsoleScreenBufferA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL ScrollConsoleScreenBufferA(HANDLE hConsoleOutput, const SMALL_RECT *lpScrollRectangle, const SMALL_RECT *lpClipRectangle, COORD dwDestinationOrigin, const CHAR_INFO *lpFill)
     * }
     */
    public static MethodHandle ScrollConsoleScreenBufferA$handle() {
        return ScrollConsoleScreenBufferA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL ScrollConsoleScreenBufferA(HANDLE hConsoleOutput, const SMALL_RECT *lpScrollRectangle, const SMALL_RECT *lpClipRectangle, COORD dwDestinationOrigin, const CHAR_INFO *lpFill)
     * }
     */
    public static int ScrollConsoleScreenBufferA(MemorySegment hConsoleOutput, MemorySegment lpScrollRectangle, MemorySegment lpClipRectangle, MemorySegment dwDestinationOrigin, MemorySegment lpFill) {
        var mh$ = ScrollConsoleScreenBufferA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ScrollConsoleScreenBufferA", hConsoleOutput, lpScrollRectangle, lpClipRectangle, dwDestinationOrigin, lpFill);
            }
            return (int)mh$.invokeExact(hConsoleOutput, lpScrollRectangle, lpClipRectangle, dwDestinationOrigin, lpFill);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ScrollConsoleScreenBufferW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            _COORD.layout(),
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("ScrollConsoleScreenBufferW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL ScrollConsoleScreenBufferW(HANDLE hConsoleOutput, const SMALL_RECT *lpScrollRectangle, const SMALL_RECT *lpClipRectangle, COORD dwDestinationOrigin, const CHAR_INFO *lpFill)
     * }
     */
    public static FunctionDescriptor ScrollConsoleScreenBufferW$descriptor() {
        return ScrollConsoleScreenBufferW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL ScrollConsoleScreenBufferW(HANDLE hConsoleOutput, const SMALL_RECT *lpScrollRectangle, const SMALL_RECT *lpClipRectangle, COORD dwDestinationOrigin, const CHAR_INFO *lpFill)
     * }
     */
    public static MethodHandle ScrollConsoleScreenBufferW$handle() {
        return ScrollConsoleScreenBufferW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL ScrollConsoleScreenBufferW(HANDLE hConsoleOutput, const SMALL_RECT *lpScrollRectangle, const SMALL_RECT *lpClipRectangle, COORD dwDestinationOrigin, const CHAR_INFO *lpFill)
     * }
     */
    public static int ScrollConsoleScreenBufferW(MemorySegment hConsoleOutput, MemorySegment lpScrollRectangle, MemorySegment lpClipRectangle, MemorySegment dwDestinationOrigin, MemorySegment lpFill) {
        var mh$ = ScrollConsoleScreenBufferW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ScrollConsoleScreenBufferW", hConsoleOutput, lpScrollRectangle, lpClipRectangle, dwDestinationOrigin, lpFill);
            }
            return (int)mh$.invokeExact(hConsoleOutput, lpScrollRectangle, lpClipRectangle, dwDestinationOrigin, lpFill);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class WriteConsoleOutputA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            _COORD.layout(),
            _COORD.layout(),
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("WriteConsoleOutputA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL WriteConsoleOutputA(HANDLE hConsoleOutput, const CHAR_INFO *lpBuffer, COORD dwBufferSize, COORD dwBufferCoord, PSMALL_RECT lpWriteRegion)
     * }
     */
    public static FunctionDescriptor WriteConsoleOutputA$descriptor() {
        return WriteConsoleOutputA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL WriteConsoleOutputA(HANDLE hConsoleOutput, const CHAR_INFO *lpBuffer, COORD dwBufferSize, COORD dwBufferCoord, PSMALL_RECT lpWriteRegion)
     * }
     */
    public static MethodHandle WriteConsoleOutputA$handle() {
        return WriteConsoleOutputA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL WriteConsoleOutputA(HANDLE hConsoleOutput, const CHAR_INFO *lpBuffer, COORD dwBufferSize, COORD dwBufferCoord, PSMALL_RECT lpWriteRegion)
     * }
     */
    public static int WriteConsoleOutputA(MemorySegment hConsoleOutput, MemorySegment lpBuffer, MemorySegment dwBufferSize, MemorySegment dwBufferCoord, MemorySegment lpWriteRegion) {
        var mh$ = WriteConsoleOutputA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WriteConsoleOutputA", hConsoleOutput, lpBuffer, dwBufferSize, dwBufferCoord, lpWriteRegion);
            }
            return (int)mh$.invokeExact(hConsoleOutput, lpBuffer, dwBufferSize, dwBufferCoord, lpWriteRegion);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class WriteConsoleOutputW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            _COORD.layout(),
            _COORD.layout(),
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("WriteConsoleOutputW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL WriteConsoleOutputW(HANDLE hConsoleOutput, const CHAR_INFO *lpBuffer, COORD dwBufferSize, COORD dwBufferCoord, PSMALL_RECT lpWriteRegion)
     * }
     */
    public static FunctionDescriptor WriteConsoleOutputW$descriptor() {
        return WriteConsoleOutputW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL WriteConsoleOutputW(HANDLE hConsoleOutput, const CHAR_INFO *lpBuffer, COORD dwBufferSize, COORD dwBufferCoord, PSMALL_RECT lpWriteRegion)
     * }
     */
    public static MethodHandle WriteConsoleOutputW$handle() {
        return WriteConsoleOutputW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL WriteConsoleOutputW(HANDLE hConsoleOutput, const CHAR_INFO *lpBuffer, COORD dwBufferSize, COORD dwBufferCoord, PSMALL_RECT lpWriteRegion)
     * }
     */
    public static int WriteConsoleOutputW(MemorySegment hConsoleOutput, MemorySegment lpBuffer, MemorySegment dwBufferSize, MemorySegment dwBufferCoord, MemorySegment lpWriteRegion) {
        var mh$ = WriteConsoleOutputW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WriteConsoleOutputW", hConsoleOutput, lpBuffer, dwBufferSize, dwBufferCoord, lpWriteRegion);
            }
            return (int)mh$.invokeExact(hConsoleOutput, lpBuffer, dwBufferSize, dwBufferCoord, lpWriteRegion);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ReadConsoleOutputA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            _COORD.layout(),
            _COORD.layout(),
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("ReadConsoleOutputA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL ReadConsoleOutputA(HANDLE hConsoleOutput, PCHAR_INFO lpBuffer, COORD dwBufferSize, COORD dwBufferCoord, PSMALL_RECT lpReadRegion)
     * }
     */
    public static FunctionDescriptor ReadConsoleOutputA$descriptor() {
        return ReadConsoleOutputA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL ReadConsoleOutputA(HANDLE hConsoleOutput, PCHAR_INFO lpBuffer, COORD dwBufferSize, COORD dwBufferCoord, PSMALL_RECT lpReadRegion)
     * }
     */
    public static MethodHandle ReadConsoleOutputA$handle() {
        return ReadConsoleOutputA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL ReadConsoleOutputA(HANDLE hConsoleOutput, PCHAR_INFO lpBuffer, COORD dwBufferSize, COORD dwBufferCoord, PSMALL_RECT lpReadRegion)
     * }
     */
    public static int ReadConsoleOutputA(MemorySegment hConsoleOutput, MemorySegment lpBuffer, MemorySegment dwBufferSize, MemorySegment dwBufferCoord, MemorySegment lpReadRegion) {
        var mh$ = ReadConsoleOutputA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ReadConsoleOutputA", hConsoleOutput, lpBuffer, dwBufferSize, dwBufferCoord, lpReadRegion);
            }
            return (int)mh$.invokeExact(hConsoleOutput, lpBuffer, dwBufferSize, dwBufferCoord, lpReadRegion);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ReadConsoleOutputW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            _COORD.layout(),
            _COORD.layout(),
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("ReadConsoleOutputW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL ReadConsoleOutputW(HANDLE hConsoleOutput, PCHAR_INFO lpBuffer, COORD dwBufferSize, COORD dwBufferCoord, PSMALL_RECT lpReadRegion)
     * }
     */
    public static FunctionDescriptor ReadConsoleOutputW$descriptor() {
        return ReadConsoleOutputW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL ReadConsoleOutputW(HANDLE hConsoleOutput, PCHAR_INFO lpBuffer, COORD dwBufferSize, COORD dwBufferCoord, PSMALL_RECT lpReadRegion)
     * }
     */
    public static MethodHandle ReadConsoleOutputW$handle() {
        return ReadConsoleOutputW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL ReadConsoleOutputW(HANDLE hConsoleOutput, PCHAR_INFO lpBuffer, COORD dwBufferSize, COORD dwBufferCoord, PSMALL_RECT lpReadRegion)
     * }
     */
    public static int ReadConsoleOutputW(MemorySegment hConsoleOutput, MemorySegment lpBuffer, MemorySegment dwBufferSize, MemorySegment dwBufferCoord, MemorySegment lpReadRegion) {
        var mh$ = ReadConsoleOutputW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ReadConsoleOutputW", hConsoleOutput, lpBuffer, dwBufferSize, dwBufferCoord, lpReadRegion);
            }
            return (int)mh$.invokeExact(hConsoleOutput, lpBuffer, dwBufferSize, dwBufferCoord, lpReadRegion);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetConsoleTitleA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_POINTER,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetConsoleTitleA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetConsoleTitleA(LPSTR lpConsoleTitle, DWORD nSize)
     * }
     */
    public static FunctionDescriptor GetConsoleTitleA$descriptor() {
        return GetConsoleTitleA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetConsoleTitleA(LPSTR lpConsoleTitle, DWORD nSize)
     * }
     */
    public static MethodHandle GetConsoleTitleA$handle() {
        return GetConsoleTitleA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * DWORD GetConsoleTitleA(LPSTR lpConsoleTitle, DWORD nSize)
     * }
     */
    public static int GetConsoleTitleA(MemorySegment lpConsoleTitle, int nSize) {
        var mh$ = GetConsoleTitleA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetConsoleTitleA", lpConsoleTitle, nSize);
            }
            return (int)mh$.invokeExact(lpConsoleTitle, nSize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetConsoleTitleW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_POINTER,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetConsoleTitleW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetConsoleTitleW(LPWSTR lpConsoleTitle, DWORD nSize)
     * }
     */
    public static FunctionDescriptor GetConsoleTitleW$descriptor() {
        return GetConsoleTitleW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetConsoleTitleW(LPWSTR lpConsoleTitle, DWORD nSize)
     * }
     */
    public static MethodHandle GetConsoleTitleW$handle() {
        return GetConsoleTitleW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * DWORD GetConsoleTitleW(LPWSTR lpConsoleTitle, DWORD nSize)
     * }
     */
    public static int GetConsoleTitleW(MemorySegment lpConsoleTitle, int nSize) {
        var mh$ = GetConsoleTitleW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetConsoleTitleW", lpConsoleTitle, nSize);
            }
            return (int)mh$.invokeExact(lpConsoleTitle, nSize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetConsoleOriginalTitleA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_POINTER,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetConsoleOriginalTitleA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetConsoleOriginalTitleA(LPSTR lpConsoleTitle, DWORD nSize)
     * }
     */
    public static FunctionDescriptor GetConsoleOriginalTitleA$descriptor() {
        return GetConsoleOriginalTitleA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetConsoleOriginalTitleA(LPSTR lpConsoleTitle, DWORD nSize)
     * }
     */
    public static MethodHandle GetConsoleOriginalTitleA$handle() {
        return GetConsoleOriginalTitleA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * DWORD GetConsoleOriginalTitleA(LPSTR lpConsoleTitle, DWORD nSize)
     * }
     */
    public static int GetConsoleOriginalTitleA(MemorySegment lpConsoleTitle, int nSize) {
        var mh$ = GetConsoleOriginalTitleA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetConsoleOriginalTitleA", lpConsoleTitle, nSize);
            }
            return (int)mh$.invokeExact(lpConsoleTitle, nSize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetConsoleOriginalTitleW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_POINTER,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetConsoleOriginalTitleW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetConsoleOriginalTitleW(LPWSTR lpConsoleTitle, DWORD nSize)
     * }
     */
    public static FunctionDescriptor GetConsoleOriginalTitleW$descriptor() {
        return GetConsoleOriginalTitleW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetConsoleOriginalTitleW(LPWSTR lpConsoleTitle, DWORD nSize)
     * }
     */
    public static MethodHandle GetConsoleOriginalTitleW$handle() {
        return GetConsoleOriginalTitleW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * DWORD GetConsoleOriginalTitleW(LPWSTR lpConsoleTitle, DWORD nSize)
     * }
     */
    public static int GetConsoleOriginalTitleW(MemorySegment lpConsoleTitle, int nSize) {
        var mh$ = GetConsoleOriginalTitleW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetConsoleOriginalTitleW", lpConsoleTitle, nSize);
            }
            return (int)mh$.invokeExact(lpConsoleTitle, nSize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetConsoleTitleA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("SetConsoleTitleA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetConsoleTitleA(LPCSTR lpConsoleTitle)
     * }
     */
    public static FunctionDescriptor SetConsoleTitleA$descriptor() {
        return SetConsoleTitleA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetConsoleTitleA(LPCSTR lpConsoleTitle)
     * }
     */
    public static MethodHandle SetConsoleTitleA$handle() {
        return SetConsoleTitleA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL SetConsoleTitleA(LPCSTR lpConsoleTitle)
     * }
     */
    public static int SetConsoleTitleA(MemorySegment lpConsoleTitle) {
        var mh$ = SetConsoleTitleA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetConsoleTitleA", lpConsoleTitle);
            }
            return (int)mh$.invokeExact(lpConsoleTitle);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetConsoleTitleW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("SetConsoleTitleW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetConsoleTitleW(LPCWSTR lpConsoleTitle)
     * }
     */
    public static FunctionDescriptor SetConsoleTitleW$descriptor() {
        return SetConsoleTitleW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetConsoleTitleW(LPCWSTR lpConsoleTitle)
     * }
     */
    public static MethodHandle SetConsoleTitleW$handle() {
        return SetConsoleTitleW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL SetConsoleTitleW(LPCWSTR lpConsoleTitle)
     * }
     */
    public static int SetConsoleTitleW(MemorySegment lpConsoleTitle) {
        var mh$ = SetConsoleTitleW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetConsoleTitleW", lpConsoleTitle);
            }
            return (int)mh$.invokeExact(lpConsoleTitle);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetNumberOfConsoleMouseButtons {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetNumberOfConsoleMouseButtons"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetNumberOfConsoleMouseButtons(LPDWORD lpNumberOfMouseButtons)
     * }
     */
    public static FunctionDescriptor GetNumberOfConsoleMouseButtons$descriptor() {
        return GetNumberOfConsoleMouseButtons.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetNumberOfConsoleMouseButtons(LPDWORD lpNumberOfMouseButtons)
     * }
     */
    public static MethodHandle GetNumberOfConsoleMouseButtons$handle() {
        return GetNumberOfConsoleMouseButtons.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL GetNumberOfConsoleMouseButtons(LPDWORD lpNumberOfMouseButtons)
     * }
     */
    public static int GetNumberOfConsoleMouseButtons(MemorySegment lpNumberOfMouseButtons) {
        var mh$ = GetNumberOfConsoleMouseButtons.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetNumberOfConsoleMouseButtons", lpNumberOfMouseButtons);
            }
            return (int)mh$.invokeExact(lpNumberOfMouseButtons);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetConsoleFontSize {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            _COORD.layout(),
            C_POINTER,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetConsoleFontSize"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * COORD GetConsoleFontSize(HANDLE hConsoleOutput, DWORD nFont)
     * }
     */
    public static FunctionDescriptor GetConsoleFontSize$descriptor() {
        return GetConsoleFontSize.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * COORD GetConsoleFontSize(HANDLE hConsoleOutput, DWORD nFont)
     * }
     */
    public static MethodHandle GetConsoleFontSize$handle() {
        return GetConsoleFontSize.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * COORD GetConsoleFontSize(HANDLE hConsoleOutput, DWORD nFont)
     * }
     */
    public static MemorySegment GetConsoleFontSize(SegmentAllocator allocator, MemorySegment hConsoleOutput, int nFont) {
        var mh$ = GetConsoleFontSize.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetConsoleFontSize", allocator, hConsoleOutput, nFont);
            }
            return (MemorySegment)mh$.invokeExact(allocator, hConsoleOutput, nFont);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetCurrentConsoleFont {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetCurrentConsoleFont"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetCurrentConsoleFont(HANDLE hConsoleOutput, BOOL bMaximumWindow, PCONSOLE_FONT_INFO lpConsoleCurrentFont)
     * }
     */
    public static FunctionDescriptor GetCurrentConsoleFont$descriptor() {
        return GetCurrentConsoleFont.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetCurrentConsoleFont(HANDLE hConsoleOutput, BOOL bMaximumWindow, PCONSOLE_FONT_INFO lpConsoleCurrentFont)
     * }
     */
    public static MethodHandle GetCurrentConsoleFont$handle() {
        return GetCurrentConsoleFont.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL GetCurrentConsoleFont(HANDLE hConsoleOutput, BOOL bMaximumWindow, PCONSOLE_FONT_INFO lpConsoleCurrentFont)
     * }
     */
    public static int GetCurrentConsoleFont(MemorySegment hConsoleOutput, int bMaximumWindow, MemorySegment lpConsoleCurrentFont) {
        var mh$ = GetCurrentConsoleFont.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetCurrentConsoleFont", hConsoleOutput, bMaximumWindow, lpConsoleCurrentFont);
            }
            return (int)mh$.invokeExact(hConsoleOutput, bMaximumWindow, lpConsoleCurrentFont);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct _CONSOLE_FONT_INFOEX {
     *     ULONG cbSize;
     *     DWORD nFont;
     *     COORD dwFontSize;
     *     UINT FontFamily;
     *     UINT FontWeight;
     *     WCHAR FaceName[32];
     * } *PCONSOLE_FONT_INFOEX
     * }
     */
    public static final AddressLayout PCONSOLE_FONT_INFOEX = C_POINTER;

    private static class GetCurrentConsoleFontEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetCurrentConsoleFontEx"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetCurrentConsoleFontEx(HANDLE hConsoleOutput, BOOL bMaximumWindow, PCONSOLE_FONT_INFOEX lpConsoleCurrentFontEx)
     * }
     */
    public static FunctionDescriptor GetCurrentConsoleFontEx$descriptor() {
        return GetCurrentConsoleFontEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetCurrentConsoleFontEx(HANDLE hConsoleOutput, BOOL bMaximumWindow, PCONSOLE_FONT_INFOEX lpConsoleCurrentFontEx)
     * }
     */
    public static MethodHandle GetCurrentConsoleFontEx$handle() {
        return GetCurrentConsoleFontEx.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL GetCurrentConsoleFontEx(HANDLE hConsoleOutput, BOOL bMaximumWindow, PCONSOLE_FONT_INFOEX lpConsoleCurrentFontEx)
     * }
     */
    public static int GetCurrentConsoleFontEx(MemorySegment hConsoleOutput, int bMaximumWindow, MemorySegment lpConsoleCurrentFontEx) {
        var mh$ = GetCurrentConsoleFontEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetCurrentConsoleFontEx", hConsoleOutput, bMaximumWindow, lpConsoleCurrentFontEx);
            }
            return (int)mh$.invokeExact(hConsoleOutput, bMaximumWindow, lpConsoleCurrentFontEx);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetCurrentConsoleFontEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("SetCurrentConsoleFontEx"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetCurrentConsoleFontEx(HANDLE hConsoleOutput, BOOL bMaximumWindow, PCONSOLE_FONT_INFOEX lpConsoleCurrentFontEx)
     * }
     */
    public static FunctionDescriptor SetCurrentConsoleFontEx$descriptor() {
        return SetCurrentConsoleFontEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetCurrentConsoleFontEx(HANDLE hConsoleOutput, BOOL bMaximumWindow, PCONSOLE_FONT_INFOEX lpConsoleCurrentFontEx)
     * }
     */
    public static MethodHandle SetCurrentConsoleFontEx$handle() {
        return SetCurrentConsoleFontEx.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL SetCurrentConsoleFontEx(HANDLE hConsoleOutput, BOOL bMaximumWindow, PCONSOLE_FONT_INFOEX lpConsoleCurrentFontEx)
     * }
     */
    public static int SetCurrentConsoleFontEx(MemorySegment hConsoleOutput, int bMaximumWindow, MemorySegment lpConsoleCurrentFontEx) {
        var mh$ = SetCurrentConsoleFontEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetCurrentConsoleFontEx", hConsoleOutput, bMaximumWindow, lpConsoleCurrentFontEx);
            }
            return (int)mh$.invokeExact(hConsoleOutput, bMaximumWindow, lpConsoleCurrentFontEx);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct _CONSOLE_SELECTION_INFO {
     *     DWORD dwFlags;
     *     COORD dwSelectionAnchor;
     *     SMALL_RECT srSelection;
     * } *PCONSOLE_SELECTION_INFO
     * }
     */
    public static final AddressLayout PCONSOLE_SELECTION_INFO = C_POINTER;

    private static class GetConsoleSelectionInfo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetConsoleSelectionInfo"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetConsoleSelectionInfo(PCONSOLE_SELECTION_INFO lpConsoleSelectionInfo)
     * }
     */
    public static FunctionDescriptor GetConsoleSelectionInfo$descriptor() {
        return GetConsoleSelectionInfo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetConsoleSelectionInfo(PCONSOLE_SELECTION_INFO lpConsoleSelectionInfo)
     * }
     */
    public static MethodHandle GetConsoleSelectionInfo$handle() {
        return GetConsoleSelectionInfo.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL GetConsoleSelectionInfo(PCONSOLE_SELECTION_INFO lpConsoleSelectionInfo)
     * }
     */
    public static int GetConsoleSelectionInfo(MemorySegment lpConsoleSelectionInfo) {
        var mh$ = GetConsoleSelectionInfo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetConsoleSelectionInfo", lpConsoleSelectionInfo);
            }
            return (int)mh$.invokeExact(lpConsoleSelectionInfo);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct _CONSOLE_HISTORY_INFO {
     *     UINT cbSize;
     *     UINT HistoryBufferSize;
     *     UINT NumberOfHistoryBuffers;
     *     DWORD dwFlags;
     * } *PCONSOLE_HISTORY_INFO
     * }
     */
    public static final AddressLayout PCONSOLE_HISTORY_INFO = C_POINTER;

    private static class GetConsoleHistoryInfo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetConsoleHistoryInfo"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetConsoleHistoryInfo(PCONSOLE_HISTORY_INFO lpConsoleHistoryInfo)
     * }
     */
    public static FunctionDescriptor GetConsoleHistoryInfo$descriptor() {
        return GetConsoleHistoryInfo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetConsoleHistoryInfo(PCONSOLE_HISTORY_INFO lpConsoleHistoryInfo)
     * }
     */
    public static MethodHandle GetConsoleHistoryInfo$handle() {
        return GetConsoleHistoryInfo.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL GetConsoleHistoryInfo(PCONSOLE_HISTORY_INFO lpConsoleHistoryInfo)
     * }
     */
    public static int GetConsoleHistoryInfo(MemorySegment lpConsoleHistoryInfo) {
        var mh$ = GetConsoleHistoryInfo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetConsoleHistoryInfo", lpConsoleHistoryInfo);
            }
            return (int)mh$.invokeExact(lpConsoleHistoryInfo);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetConsoleHistoryInfo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("SetConsoleHistoryInfo"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetConsoleHistoryInfo(PCONSOLE_HISTORY_INFO lpConsoleHistoryInfo)
     * }
     */
    public static FunctionDescriptor SetConsoleHistoryInfo$descriptor() {
        return SetConsoleHistoryInfo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetConsoleHistoryInfo(PCONSOLE_HISTORY_INFO lpConsoleHistoryInfo)
     * }
     */
    public static MethodHandle SetConsoleHistoryInfo$handle() {
        return SetConsoleHistoryInfo.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL SetConsoleHistoryInfo(PCONSOLE_HISTORY_INFO lpConsoleHistoryInfo)
     * }
     */
    public static int SetConsoleHistoryInfo(MemorySegment lpConsoleHistoryInfo) {
        var mh$ = SetConsoleHistoryInfo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetConsoleHistoryInfo", lpConsoleHistoryInfo);
            }
            return (int)mh$.invokeExact(lpConsoleHistoryInfo);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetConsoleDisplayMode {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetConsoleDisplayMode"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetConsoleDisplayMode(LPDWORD lpModeFlags)
     * }
     */
    public static FunctionDescriptor GetConsoleDisplayMode$descriptor() {
        return GetConsoleDisplayMode.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetConsoleDisplayMode(LPDWORD lpModeFlags)
     * }
     */
    public static MethodHandle GetConsoleDisplayMode$handle() {
        return GetConsoleDisplayMode.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL GetConsoleDisplayMode(LPDWORD lpModeFlags)
     * }
     */
    public static int GetConsoleDisplayMode(MemorySegment lpModeFlags) {
        var mh$ = GetConsoleDisplayMode.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetConsoleDisplayMode", lpModeFlags);
            }
            return (int)mh$.invokeExact(lpModeFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetConsoleDisplayMode {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_LONG,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("SetConsoleDisplayMode"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetConsoleDisplayMode(HANDLE hConsoleOutput, DWORD dwFlags, PCOORD lpNewScreenBufferDimensions)
     * }
     */
    public static FunctionDescriptor SetConsoleDisplayMode$descriptor() {
        return SetConsoleDisplayMode.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetConsoleDisplayMode(HANDLE hConsoleOutput, DWORD dwFlags, PCOORD lpNewScreenBufferDimensions)
     * }
     */
    public static MethodHandle SetConsoleDisplayMode$handle() {
        return SetConsoleDisplayMode.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL SetConsoleDisplayMode(HANDLE hConsoleOutput, DWORD dwFlags, PCOORD lpNewScreenBufferDimensions)
     * }
     */
    public static int SetConsoleDisplayMode(MemorySegment hConsoleOutput, int dwFlags, MemorySegment lpNewScreenBufferDimensions) {
        var mh$ = SetConsoleDisplayMode.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetConsoleDisplayMode", hConsoleOutput, dwFlags, lpNewScreenBufferDimensions);
            }
            return (int)mh$.invokeExact(hConsoleOutput, dwFlags, lpNewScreenBufferDimensions);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetConsoleWindow {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER    );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetConsoleWindow"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HWND GetConsoleWindow()
     * }
     */
    public static FunctionDescriptor GetConsoleWindow$descriptor() {
        return GetConsoleWindow.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HWND GetConsoleWindow()
     * }
     */
    public static MethodHandle GetConsoleWindow$handle() {
        return GetConsoleWindow.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * HWND GetConsoleWindow()
     * }
     */
    public static MemorySegment GetConsoleWindow() {
        var mh$ = GetConsoleWindow.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetConsoleWindow");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class AddConsoleAliasA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("AddConsoleAliasA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL AddConsoleAliasA(LPSTR Source, LPSTR Target, LPSTR ExeName)
     * }
     */
    public static FunctionDescriptor AddConsoleAliasA$descriptor() {
        return AddConsoleAliasA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL AddConsoleAliasA(LPSTR Source, LPSTR Target, LPSTR ExeName)
     * }
     */
    public static MethodHandle AddConsoleAliasA$handle() {
        return AddConsoleAliasA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL AddConsoleAliasA(LPSTR Source, LPSTR Target, LPSTR ExeName)
     * }
     */
    public static int AddConsoleAliasA(MemorySegment Source, MemorySegment Target, MemorySegment ExeName) {
        var mh$ = AddConsoleAliasA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("AddConsoleAliasA", Source, Target, ExeName);
            }
            return (int)mh$.invokeExact(Source, Target, ExeName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class AddConsoleAliasW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("AddConsoleAliasW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL AddConsoleAliasW(LPWSTR Source, LPWSTR Target, LPWSTR ExeName)
     * }
     */
    public static FunctionDescriptor AddConsoleAliasW$descriptor() {
        return AddConsoleAliasW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL AddConsoleAliasW(LPWSTR Source, LPWSTR Target, LPWSTR ExeName)
     * }
     */
    public static MethodHandle AddConsoleAliasW$handle() {
        return AddConsoleAliasW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL AddConsoleAliasW(LPWSTR Source, LPWSTR Target, LPWSTR ExeName)
     * }
     */
    public static int AddConsoleAliasW(MemorySegment Source, MemorySegment Target, MemorySegment ExeName) {
        var mh$ = AddConsoleAliasW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("AddConsoleAliasW", Source, Target, ExeName);
            }
            return (int)mh$.invokeExact(Source, Target, ExeName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetConsoleAliasA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_POINTER,
            C_POINTER,
            C_LONG,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetConsoleAliasA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetConsoleAliasA(LPSTR Source, LPSTR TargetBuffer, DWORD TargetBufferLength, LPSTR ExeName)
     * }
     */
    public static FunctionDescriptor GetConsoleAliasA$descriptor() {
        return GetConsoleAliasA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetConsoleAliasA(LPSTR Source, LPSTR TargetBuffer, DWORD TargetBufferLength, LPSTR ExeName)
     * }
     */
    public static MethodHandle GetConsoleAliasA$handle() {
        return GetConsoleAliasA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * DWORD GetConsoleAliasA(LPSTR Source, LPSTR TargetBuffer, DWORD TargetBufferLength, LPSTR ExeName)
     * }
     */
    public static int GetConsoleAliasA(MemorySegment Source, MemorySegment TargetBuffer, int TargetBufferLength, MemorySegment ExeName) {
        var mh$ = GetConsoleAliasA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetConsoleAliasA", Source, TargetBuffer, TargetBufferLength, ExeName);
            }
            return (int)mh$.invokeExact(Source, TargetBuffer, TargetBufferLength, ExeName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetConsoleAliasW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_POINTER,
            C_POINTER,
            C_LONG,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetConsoleAliasW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetConsoleAliasW(LPWSTR Source, LPWSTR TargetBuffer, DWORD TargetBufferLength, LPWSTR ExeName)
     * }
     */
    public static FunctionDescriptor GetConsoleAliasW$descriptor() {
        return GetConsoleAliasW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetConsoleAliasW(LPWSTR Source, LPWSTR TargetBuffer, DWORD TargetBufferLength, LPWSTR ExeName)
     * }
     */
    public static MethodHandle GetConsoleAliasW$handle() {
        return GetConsoleAliasW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * DWORD GetConsoleAliasW(LPWSTR Source, LPWSTR TargetBuffer, DWORD TargetBufferLength, LPWSTR ExeName)
     * }
     */
    public static int GetConsoleAliasW(MemorySegment Source, MemorySegment TargetBuffer, int TargetBufferLength, MemorySegment ExeName) {
        var mh$ = GetConsoleAliasW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetConsoleAliasW", Source, TargetBuffer, TargetBufferLength, ExeName);
            }
            return (int)mh$.invokeExact(Source, TargetBuffer, TargetBufferLength, ExeName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetConsoleAliasesLengthA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetConsoleAliasesLengthA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetConsoleAliasesLengthA(LPSTR ExeName)
     * }
     */
    public static FunctionDescriptor GetConsoleAliasesLengthA$descriptor() {
        return GetConsoleAliasesLengthA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetConsoleAliasesLengthA(LPSTR ExeName)
     * }
     */
    public static MethodHandle GetConsoleAliasesLengthA$handle() {
        return GetConsoleAliasesLengthA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * DWORD GetConsoleAliasesLengthA(LPSTR ExeName)
     * }
     */
    public static int GetConsoleAliasesLengthA(MemorySegment ExeName) {
        var mh$ = GetConsoleAliasesLengthA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetConsoleAliasesLengthA", ExeName);
            }
            return (int)mh$.invokeExact(ExeName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetConsoleAliasesLengthW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetConsoleAliasesLengthW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetConsoleAliasesLengthW(LPWSTR ExeName)
     * }
     */
    public static FunctionDescriptor GetConsoleAliasesLengthW$descriptor() {
        return GetConsoleAliasesLengthW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetConsoleAliasesLengthW(LPWSTR ExeName)
     * }
     */
    public static MethodHandle GetConsoleAliasesLengthW$handle() {
        return GetConsoleAliasesLengthW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * DWORD GetConsoleAliasesLengthW(LPWSTR ExeName)
     * }
     */
    public static int GetConsoleAliasesLengthW(MemorySegment ExeName) {
        var mh$ = GetConsoleAliasesLengthW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetConsoleAliasesLengthW", ExeName);
            }
            return (int)mh$.invokeExact(ExeName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetConsoleAliasExesLengthA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG    );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetConsoleAliasExesLengthA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetConsoleAliasExesLengthA()
     * }
     */
    public static FunctionDescriptor GetConsoleAliasExesLengthA$descriptor() {
        return GetConsoleAliasExesLengthA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetConsoleAliasExesLengthA()
     * }
     */
    public static MethodHandle GetConsoleAliasExesLengthA$handle() {
        return GetConsoleAliasExesLengthA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * DWORD GetConsoleAliasExesLengthA()
     * }
     */
    public static int GetConsoleAliasExesLengthA() {
        var mh$ = GetConsoleAliasExesLengthA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetConsoleAliasExesLengthA");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetConsoleAliasExesLengthW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG    );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetConsoleAliasExesLengthW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetConsoleAliasExesLengthW()
     * }
     */
    public static FunctionDescriptor GetConsoleAliasExesLengthW$descriptor() {
        return GetConsoleAliasExesLengthW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetConsoleAliasExesLengthW()
     * }
     */
    public static MethodHandle GetConsoleAliasExesLengthW$handle() {
        return GetConsoleAliasExesLengthW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * DWORD GetConsoleAliasExesLengthW()
     * }
     */
    public static int GetConsoleAliasExesLengthW() {
        var mh$ = GetConsoleAliasExesLengthW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetConsoleAliasExesLengthW");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetConsoleAliasesA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_POINTER,
            C_LONG,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetConsoleAliasesA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetConsoleAliasesA(LPSTR AliasBuffer, DWORD AliasBufferLength, LPSTR ExeName)
     * }
     */
    public static FunctionDescriptor GetConsoleAliasesA$descriptor() {
        return GetConsoleAliasesA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetConsoleAliasesA(LPSTR AliasBuffer, DWORD AliasBufferLength, LPSTR ExeName)
     * }
     */
    public static MethodHandle GetConsoleAliasesA$handle() {
        return GetConsoleAliasesA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * DWORD GetConsoleAliasesA(LPSTR AliasBuffer, DWORD AliasBufferLength, LPSTR ExeName)
     * }
     */
    public static int GetConsoleAliasesA(MemorySegment AliasBuffer, int AliasBufferLength, MemorySegment ExeName) {
        var mh$ = GetConsoleAliasesA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetConsoleAliasesA", AliasBuffer, AliasBufferLength, ExeName);
            }
            return (int)mh$.invokeExact(AliasBuffer, AliasBufferLength, ExeName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetConsoleAliasesW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_POINTER,
            C_LONG,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetConsoleAliasesW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetConsoleAliasesW(LPWSTR AliasBuffer, DWORD AliasBufferLength, LPWSTR ExeName)
     * }
     */
    public static FunctionDescriptor GetConsoleAliasesW$descriptor() {
        return GetConsoleAliasesW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetConsoleAliasesW(LPWSTR AliasBuffer, DWORD AliasBufferLength, LPWSTR ExeName)
     * }
     */
    public static MethodHandle GetConsoleAliasesW$handle() {
        return GetConsoleAliasesW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * DWORD GetConsoleAliasesW(LPWSTR AliasBuffer, DWORD AliasBufferLength, LPWSTR ExeName)
     * }
     */
    public static int GetConsoleAliasesW(MemorySegment AliasBuffer, int AliasBufferLength, MemorySegment ExeName) {
        var mh$ = GetConsoleAliasesW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetConsoleAliasesW", AliasBuffer, AliasBufferLength, ExeName);
            }
            return (int)mh$.invokeExact(AliasBuffer, AliasBufferLength, ExeName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetConsoleAliasExesA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_POINTER,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetConsoleAliasExesA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetConsoleAliasExesA(LPSTR ExeNameBuffer, DWORD ExeNameBufferLength)
     * }
     */
    public static FunctionDescriptor GetConsoleAliasExesA$descriptor() {
        return GetConsoleAliasExesA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetConsoleAliasExesA(LPSTR ExeNameBuffer, DWORD ExeNameBufferLength)
     * }
     */
    public static MethodHandle GetConsoleAliasExesA$handle() {
        return GetConsoleAliasExesA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * DWORD GetConsoleAliasExesA(LPSTR ExeNameBuffer, DWORD ExeNameBufferLength)
     * }
     */
    public static int GetConsoleAliasExesA(MemorySegment ExeNameBuffer, int ExeNameBufferLength) {
        var mh$ = GetConsoleAliasExesA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetConsoleAliasExesA", ExeNameBuffer, ExeNameBufferLength);
            }
            return (int)mh$.invokeExact(ExeNameBuffer, ExeNameBufferLength);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetConsoleAliasExesW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_POINTER,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetConsoleAliasExesW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetConsoleAliasExesW(LPWSTR ExeNameBuffer, DWORD ExeNameBufferLength)
     * }
     */
    public static FunctionDescriptor GetConsoleAliasExesW$descriptor() {
        return GetConsoleAliasExesW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetConsoleAliasExesW(LPWSTR ExeNameBuffer, DWORD ExeNameBufferLength)
     * }
     */
    public static MethodHandle GetConsoleAliasExesW$handle() {
        return GetConsoleAliasExesW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * DWORD GetConsoleAliasExesW(LPWSTR ExeNameBuffer, DWORD ExeNameBufferLength)
     * }
     */
    public static int GetConsoleAliasExesW(MemorySegment ExeNameBuffer, int ExeNameBufferLength) {
        var mh$ = GetConsoleAliasExesW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetConsoleAliasExesW", ExeNameBuffer, ExeNameBufferLength);
            }
            return (int)mh$.invokeExact(ExeNameBuffer, ExeNameBufferLength);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ExpungeConsoleCommandHistoryA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("ExpungeConsoleCommandHistoryA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ExpungeConsoleCommandHistoryA(LPSTR ExeName)
     * }
     */
    public static FunctionDescriptor ExpungeConsoleCommandHistoryA$descriptor() {
        return ExpungeConsoleCommandHistoryA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ExpungeConsoleCommandHistoryA(LPSTR ExeName)
     * }
     */
    public static MethodHandle ExpungeConsoleCommandHistoryA$handle() {
        return ExpungeConsoleCommandHistoryA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * void ExpungeConsoleCommandHistoryA(LPSTR ExeName)
     * }
     */
    public static void ExpungeConsoleCommandHistoryA(MemorySegment ExeName) {
        var mh$ = ExpungeConsoleCommandHistoryA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ExpungeConsoleCommandHistoryA", ExeName);
            }
            mh$.invokeExact(ExeName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ExpungeConsoleCommandHistoryW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("ExpungeConsoleCommandHistoryW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ExpungeConsoleCommandHistoryW(LPWSTR ExeName)
     * }
     */
    public static FunctionDescriptor ExpungeConsoleCommandHistoryW$descriptor() {
        return ExpungeConsoleCommandHistoryW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ExpungeConsoleCommandHistoryW(LPWSTR ExeName)
     * }
     */
    public static MethodHandle ExpungeConsoleCommandHistoryW$handle() {
        return ExpungeConsoleCommandHistoryW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * void ExpungeConsoleCommandHistoryW(LPWSTR ExeName)
     * }
     */
    public static void ExpungeConsoleCommandHistoryW(MemorySegment ExeName) {
        var mh$ = ExpungeConsoleCommandHistoryW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ExpungeConsoleCommandHistoryW", ExeName);
            }
            mh$.invokeExact(ExeName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetConsoleNumberOfCommandsA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_LONG,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("SetConsoleNumberOfCommandsA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetConsoleNumberOfCommandsA(DWORD Number, LPSTR ExeName)
     * }
     */
    public static FunctionDescriptor SetConsoleNumberOfCommandsA$descriptor() {
        return SetConsoleNumberOfCommandsA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetConsoleNumberOfCommandsA(DWORD Number, LPSTR ExeName)
     * }
     */
    public static MethodHandle SetConsoleNumberOfCommandsA$handle() {
        return SetConsoleNumberOfCommandsA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL SetConsoleNumberOfCommandsA(DWORD Number, LPSTR ExeName)
     * }
     */
    public static int SetConsoleNumberOfCommandsA(int Number, MemorySegment ExeName) {
        var mh$ = SetConsoleNumberOfCommandsA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetConsoleNumberOfCommandsA", Number, ExeName);
            }
            return (int)mh$.invokeExact(Number, ExeName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetConsoleNumberOfCommandsW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_LONG,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("SetConsoleNumberOfCommandsW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetConsoleNumberOfCommandsW(DWORD Number, LPWSTR ExeName)
     * }
     */
    public static FunctionDescriptor SetConsoleNumberOfCommandsW$descriptor() {
        return SetConsoleNumberOfCommandsW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetConsoleNumberOfCommandsW(DWORD Number, LPWSTR ExeName)
     * }
     */
    public static MethodHandle SetConsoleNumberOfCommandsW$handle() {
        return SetConsoleNumberOfCommandsW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL SetConsoleNumberOfCommandsW(DWORD Number, LPWSTR ExeName)
     * }
     */
    public static int SetConsoleNumberOfCommandsW(int Number, MemorySegment ExeName) {
        var mh$ = SetConsoleNumberOfCommandsW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetConsoleNumberOfCommandsW", Number, ExeName);
            }
            return (int)mh$.invokeExact(Number, ExeName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetConsoleCommandHistoryLengthA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetConsoleCommandHistoryLengthA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetConsoleCommandHistoryLengthA(LPSTR ExeName)
     * }
     */
    public static FunctionDescriptor GetConsoleCommandHistoryLengthA$descriptor() {
        return GetConsoleCommandHistoryLengthA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetConsoleCommandHistoryLengthA(LPSTR ExeName)
     * }
     */
    public static MethodHandle GetConsoleCommandHistoryLengthA$handle() {
        return GetConsoleCommandHistoryLengthA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * DWORD GetConsoleCommandHistoryLengthA(LPSTR ExeName)
     * }
     */
    public static int GetConsoleCommandHistoryLengthA(MemorySegment ExeName) {
        var mh$ = GetConsoleCommandHistoryLengthA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetConsoleCommandHistoryLengthA", ExeName);
            }
            return (int)mh$.invokeExact(ExeName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetConsoleCommandHistoryLengthW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetConsoleCommandHistoryLengthW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetConsoleCommandHistoryLengthW(LPWSTR ExeName)
     * }
     */
    public static FunctionDescriptor GetConsoleCommandHistoryLengthW$descriptor() {
        return GetConsoleCommandHistoryLengthW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetConsoleCommandHistoryLengthW(LPWSTR ExeName)
     * }
     */
    public static MethodHandle GetConsoleCommandHistoryLengthW$handle() {
        return GetConsoleCommandHistoryLengthW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * DWORD GetConsoleCommandHistoryLengthW(LPWSTR ExeName)
     * }
     */
    public static int GetConsoleCommandHistoryLengthW(MemorySegment ExeName) {
        var mh$ = GetConsoleCommandHistoryLengthW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetConsoleCommandHistoryLengthW", ExeName);
            }
            return (int)mh$.invokeExact(ExeName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetConsoleCommandHistoryA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_POINTER,
            C_LONG,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetConsoleCommandHistoryA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetConsoleCommandHistoryA(LPSTR Commands, DWORD CommandBufferLength, LPSTR ExeName)
     * }
     */
    public static FunctionDescriptor GetConsoleCommandHistoryA$descriptor() {
        return GetConsoleCommandHistoryA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetConsoleCommandHistoryA(LPSTR Commands, DWORD CommandBufferLength, LPSTR ExeName)
     * }
     */
    public static MethodHandle GetConsoleCommandHistoryA$handle() {
        return GetConsoleCommandHistoryA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * DWORD GetConsoleCommandHistoryA(LPSTR Commands, DWORD CommandBufferLength, LPSTR ExeName)
     * }
     */
    public static int GetConsoleCommandHistoryA(MemorySegment Commands, int CommandBufferLength, MemorySegment ExeName) {
        var mh$ = GetConsoleCommandHistoryA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetConsoleCommandHistoryA", Commands, CommandBufferLength, ExeName);
            }
            return (int)mh$.invokeExact(Commands, CommandBufferLength, ExeName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetConsoleCommandHistoryW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_POINTER,
            C_LONG,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetConsoleCommandHistoryW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetConsoleCommandHistoryW(LPWSTR Commands, DWORD CommandBufferLength, LPWSTR ExeName)
     * }
     */
    public static FunctionDescriptor GetConsoleCommandHistoryW$descriptor() {
        return GetConsoleCommandHistoryW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetConsoleCommandHistoryW(LPWSTR Commands, DWORD CommandBufferLength, LPWSTR ExeName)
     * }
     */
    public static MethodHandle GetConsoleCommandHistoryW$handle() {
        return GetConsoleCommandHistoryW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * DWORD GetConsoleCommandHistoryW(LPWSTR Commands, DWORD CommandBufferLength, LPWSTR ExeName)
     * }
     */
    public static int GetConsoleCommandHistoryW(MemorySegment Commands, int CommandBufferLength, MemorySegment ExeName) {
        var mh$ = GetConsoleCommandHistoryW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetConsoleCommandHistoryW", Commands, CommandBufferLength, ExeName);
            }
            return (int)mh$.invokeExact(Commands, CommandBufferLength, ExeName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetConsoleProcessList {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_POINTER,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetConsoleProcessList"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetConsoleProcessList(LPDWORD lpdwProcessList, DWORD dwProcessCount)
     * }
     */
    public static FunctionDescriptor GetConsoleProcessList$descriptor() {
        return GetConsoleProcessList.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetConsoleProcessList(LPDWORD lpdwProcessList, DWORD dwProcessCount)
     * }
     */
    public static MethodHandle GetConsoleProcessList$handle() {
        return GetConsoleProcessList.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * DWORD GetConsoleProcessList(LPDWORD lpdwProcessList, DWORD dwProcessCount)
     * }
     */
    public static int GetConsoleProcessList(MemorySegment lpdwProcessList, int dwProcessCount) {
        var mh$ = GetConsoleProcessList.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetConsoleProcessList", lpdwProcessList, dwProcessCount);
            }
            return (int)mh$.invokeExact(lpdwProcessList, dwProcessCount);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class VerFindFileA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_LONG,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("VerFindFileA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD VerFindFileA(DWORD uFlags, LPCSTR szFileName, LPCSTR szWinDir, LPCSTR szAppDir, LPSTR szCurDir, PUINT puCurDirLen, LPSTR szDestDir, PUINT puDestDirLen)
     * }
     */
    public static FunctionDescriptor VerFindFileA$descriptor() {
        return VerFindFileA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD VerFindFileA(DWORD uFlags, LPCSTR szFileName, LPCSTR szWinDir, LPCSTR szAppDir, LPSTR szCurDir, PUINT puCurDirLen, LPSTR szDestDir, PUINT puDestDirLen)
     * }
     */
    public static MethodHandle VerFindFileA$handle() {
        return VerFindFileA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * DWORD VerFindFileA(DWORD uFlags, LPCSTR szFileName, LPCSTR szWinDir, LPCSTR szAppDir, LPSTR szCurDir, PUINT puCurDirLen, LPSTR szDestDir, PUINT puDestDirLen)
     * }
     */
    public static int VerFindFileA(int uFlags, MemorySegment szFileName, MemorySegment szWinDir, MemorySegment szAppDir, MemorySegment szCurDir, MemorySegment puCurDirLen, MemorySegment szDestDir, MemorySegment puDestDirLen) {
        var mh$ = VerFindFileA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("VerFindFileA", uFlags, szFileName, szWinDir, szAppDir, szCurDir, puCurDirLen, szDestDir, puDestDirLen);
            }
            return (int)mh$.invokeExact(uFlags, szFileName, szWinDir, szAppDir, szCurDir, puCurDirLen, szDestDir, puDestDirLen);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class VerFindFileW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_LONG,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("VerFindFileW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD VerFindFileW(DWORD uFlags, LPCWSTR szFileName, LPCWSTR szWinDir, LPCWSTR szAppDir, LPWSTR szCurDir, PUINT puCurDirLen, LPWSTR szDestDir, PUINT puDestDirLen)
     * }
     */
    public static FunctionDescriptor VerFindFileW$descriptor() {
        return VerFindFileW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD VerFindFileW(DWORD uFlags, LPCWSTR szFileName, LPCWSTR szWinDir, LPCWSTR szAppDir, LPWSTR szCurDir, PUINT puCurDirLen, LPWSTR szDestDir, PUINT puDestDirLen)
     * }
     */
    public static MethodHandle VerFindFileW$handle() {
        return VerFindFileW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * DWORD VerFindFileW(DWORD uFlags, LPCWSTR szFileName, LPCWSTR szWinDir, LPCWSTR szAppDir, LPWSTR szCurDir, PUINT puCurDirLen, LPWSTR szDestDir, PUINT puDestDirLen)
     * }
     */
    public static int VerFindFileW(int uFlags, MemorySegment szFileName, MemorySegment szWinDir, MemorySegment szAppDir, MemorySegment szCurDir, MemorySegment puCurDirLen, MemorySegment szDestDir, MemorySegment puDestDirLen) {
        var mh$ = VerFindFileW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("VerFindFileW", uFlags, szFileName, szWinDir, szAppDir, szCurDir, puCurDirLen, szDestDir, puDestDirLen);
            }
            return (int)mh$.invokeExact(uFlags, szFileName, szWinDir, szAppDir, szCurDir, puCurDirLen, szDestDir, puDestDirLen);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class VerInstallFileA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_LONG,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("VerInstallFileA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD VerInstallFileA(DWORD uFlags, LPCSTR szSrcFileName, LPCSTR szDestFileName, LPCSTR szSrcDir, LPCSTR szDestDir, LPCSTR szCurDir, LPSTR szTmpFile, PUINT puTmpFileLen)
     * }
     */
    public static FunctionDescriptor VerInstallFileA$descriptor() {
        return VerInstallFileA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD VerInstallFileA(DWORD uFlags, LPCSTR szSrcFileName, LPCSTR szDestFileName, LPCSTR szSrcDir, LPCSTR szDestDir, LPCSTR szCurDir, LPSTR szTmpFile, PUINT puTmpFileLen)
     * }
     */
    public static MethodHandle VerInstallFileA$handle() {
        return VerInstallFileA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * DWORD VerInstallFileA(DWORD uFlags, LPCSTR szSrcFileName, LPCSTR szDestFileName, LPCSTR szSrcDir, LPCSTR szDestDir, LPCSTR szCurDir, LPSTR szTmpFile, PUINT puTmpFileLen)
     * }
     */
    public static int VerInstallFileA(int uFlags, MemorySegment szSrcFileName, MemorySegment szDestFileName, MemorySegment szSrcDir, MemorySegment szDestDir, MemorySegment szCurDir, MemorySegment szTmpFile, MemorySegment puTmpFileLen) {
        var mh$ = VerInstallFileA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("VerInstallFileA", uFlags, szSrcFileName, szDestFileName, szSrcDir, szDestDir, szCurDir, szTmpFile, puTmpFileLen);
            }
            return (int)mh$.invokeExact(uFlags, szSrcFileName, szDestFileName, szSrcDir, szDestDir, szCurDir, szTmpFile, puTmpFileLen);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class VerInstallFileW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_LONG,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("VerInstallFileW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD VerInstallFileW(DWORD uFlags, LPCWSTR szSrcFileName, LPCWSTR szDestFileName, LPCWSTR szSrcDir, LPCWSTR szDestDir, LPCWSTR szCurDir, LPWSTR szTmpFile, PUINT puTmpFileLen)
     * }
     */
    public static FunctionDescriptor VerInstallFileW$descriptor() {
        return VerInstallFileW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD VerInstallFileW(DWORD uFlags, LPCWSTR szSrcFileName, LPCWSTR szDestFileName, LPCWSTR szSrcDir, LPCWSTR szDestDir, LPCWSTR szCurDir, LPWSTR szTmpFile, PUINT puTmpFileLen)
     * }
     */
    public static MethodHandle VerInstallFileW$handle() {
        return VerInstallFileW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * DWORD VerInstallFileW(DWORD uFlags, LPCWSTR szSrcFileName, LPCWSTR szDestFileName, LPCWSTR szSrcDir, LPCWSTR szDestDir, LPCWSTR szCurDir, LPWSTR szTmpFile, PUINT puTmpFileLen)
     * }
     */
    public static int VerInstallFileW(int uFlags, MemorySegment szSrcFileName, MemorySegment szDestFileName, MemorySegment szSrcDir, MemorySegment szDestDir, MemorySegment szCurDir, MemorySegment szTmpFile, MemorySegment puTmpFileLen) {
        var mh$ = VerInstallFileW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("VerInstallFileW", uFlags, szSrcFileName, szDestFileName, szSrcDir, szDestDir, szCurDir, szTmpFile, puTmpFileLen);
            }
            return (int)mh$.invokeExact(uFlags, szSrcFileName, szDestFileName, szSrcDir, szDestDir, szCurDir, szTmpFile, puTmpFileLen);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetFileVersionInfoSizeA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetFileVersionInfoSizeA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetFileVersionInfoSizeA(LPCSTR lptstrFilename, LPDWORD lpdwHandle)
     * }
     */
    public static FunctionDescriptor GetFileVersionInfoSizeA$descriptor() {
        return GetFileVersionInfoSizeA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetFileVersionInfoSizeA(LPCSTR lptstrFilename, LPDWORD lpdwHandle)
     * }
     */
    public static MethodHandle GetFileVersionInfoSizeA$handle() {
        return GetFileVersionInfoSizeA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * DWORD GetFileVersionInfoSizeA(LPCSTR lptstrFilename, LPDWORD lpdwHandle)
     * }
     */
    public static int GetFileVersionInfoSizeA(MemorySegment lptstrFilename, MemorySegment lpdwHandle) {
        var mh$ = GetFileVersionInfoSizeA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetFileVersionInfoSizeA", lptstrFilename, lpdwHandle);
            }
            return (int)mh$.invokeExact(lptstrFilename, lpdwHandle);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetFileVersionInfoSizeW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetFileVersionInfoSizeW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetFileVersionInfoSizeW(LPCWSTR lptstrFilename, LPDWORD lpdwHandle)
     * }
     */
    public static FunctionDescriptor GetFileVersionInfoSizeW$descriptor() {
        return GetFileVersionInfoSizeW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetFileVersionInfoSizeW(LPCWSTR lptstrFilename, LPDWORD lpdwHandle)
     * }
     */
    public static MethodHandle GetFileVersionInfoSizeW$handle() {
        return GetFileVersionInfoSizeW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * DWORD GetFileVersionInfoSizeW(LPCWSTR lptstrFilename, LPDWORD lpdwHandle)
     * }
     */
    public static int GetFileVersionInfoSizeW(MemorySegment lptstrFilename, MemorySegment lpdwHandle) {
        var mh$ = GetFileVersionInfoSizeW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetFileVersionInfoSizeW", lptstrFilename, lpdwHandle);
            }
            return (int)mh$.invokeExact(lptstrFilename, lpdwHandle);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetFileVersionInfoA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_LONG,
            C_LONG,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetFileVersionInfoA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetFileVersionInfoA(LPCSTR lptstrFilename, DWORD dwHandle, DWORD dwLen, LPVOID lpData)
     * }
     */
    public static FunctionDescriptor GetFileVersionInfoA$descriptor() {
        return GetFileVersionInfoA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetFileVersionInfoA(LPCSTR lptstrFilename, DWORD dwHandle, DWORD dwLen, LPVOID lpData)
     * }
     */
    public static MethodHandle GetFileVersionInfoA$handle() {
        return GetFileVersionInfoA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL GetFileVersionInfoA(LPCSTR lptstrFilename, DWORD dwHandle, DWORD dwLen, LPVOID lpData)
     * }
     */
    public static int GetFileVersionInfoA(MemorySegment lptstrFilename, int dwHandle, int dwLen, MemorySegment lpData) {
        var mh$ = GetFileVersionInfoA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetFileVersionInfoA", lptstrFilename, dwHandle, dwLen, lpData);
            }
            return (int)mh$.invokeExact(lptstrFilename, dwHandle, dwLen, lpData);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetFileVersionInfoW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_LONG,
            C_LONG,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetFileVersionInfoW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetFileVersionInfoW(LPCWSTR lptstrFilename, DWORD dwHandle, DWORD dwLen, LPVOID lpData)
     * }
     */
    public static FunctionDescriptor GetFileVersionInfoW$descriptor() {
        return GetFileVersionInfoW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetFileVersionInfoW(LPCWSTR lptstrFilename, DWORD dwHandle, DWORD dwLen, LPVOID lpData)
     * }
     */
    public static MethodHandle GetFileVersionInfoW$handle() {
        return GetFileVersionInfoW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL GetFileVersionInfoW(LPCWSTR lptstrFilename, DWORD dwHandle, DWORD dwLen, LPVOID lpData)
     * }
     */
    public static int GetFileVersionInfoW(MemorySegment lptstrFilename, int dwHandle, int dwLen, MemorySegment lpData) {
        var mh$ = GetFileVersionInfoW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetFileVersionInfoW", lptstrFilename, dwHandle, dwLen, lpData);
            }
            return (int)mh$.invokeExact(lptstrFilename, dwHandle, dwLen, lpData);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetFileVersionInfoSizeExA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_LONG,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetFileVersionInfoSizeExA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetFileVersionInfoSizeExA(DWORD dwFlags, LPCSTR lpwstrFilename, LPDWORD lpdwHandle)
     * }
     */
    public static FunctionDescriptor GetFileVersionInfoSizeExA$descriptor() {
        return GetFileVersionInfoSizeExA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetFileVersionInfoSizeExA(DWORD dwFlags, LPCSTR lpwstrFilename, LPDWORD lpdwHandle)
     * }
     */
    public static MethodHandle GetFileVersionInfoSizeExA$handle() {
        return GetFileVersionInfoSizeExA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * DWORD GetFileVersionInfoSizeExA(DWORD dwFlags, LPCSTR lpwstrFilename, LPDWORD lpdwHandle)
     * }
     */
    public static int GetFileVersionInfoSizeExA(int dwFlags, MemorySegment lpwstrFilename, MemorySegment lpdwHandle) {
        var mh$ = GetFileVersionInfoSizeExA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetFileVersionInfoSizeExA", dwFlags, lpwstrFilename, lpdwHandle);
            }
            return (int)mh$.invokeExact(dwFlags, lpwstrFilename, lpdwHandle);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetFileVersionInfoSizeExW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_LONG,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetFileVersionInfoSizeExW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetFileVersionInfoSizeExW(DWORD dwFlags, LPCWSTR lpwstrFilename, LPDWORD lpdwHandle)
     * }
     */
    public static FunctionDescriptor GetFileVersionInfoSizeExW$descriptor() {
        return GetFileVersionInfoSizeExW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetFileVersionInfoSizeExW(DWORD dwFlags, LPCWSTR lpwstrFilename, LPDWORD lpdwHandle)
     * }
     */
    public static MethodHandle GetFileVersionInfoSizeExW$handle() {
        return GetFileVersionInfoSizeExW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * DWORD GetFileVersionInfoSizeExW(DWORD dwFlags, LPCWSTR lpwstrFilename, LPDWORD lpdwHandle)
     * }
     */
    public static int GetFileVersionInfoSizeExW(int dwFlags, MemorySegment lpwstrFilename, MemorySegment lpdwHandle) {
        var mh$ = GetFileVersionInfoSizeExW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetFileVersionInfoSizeExW", dwFlags, lpwstrFilename, lpdwHandle);
            }
            return (int)mh$.invokeExact(dwFlags, lpwstrFilename, lpdwHandle);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetFileVersionInfoExA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_LONG,
            C_POINTER,
            C_LONG,
            C_LONG,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetFileVersionInfoExA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetFileVersionInfoExA(DWORD dwFlags, LPCSTR lpwstrFilename, DWORD dwHandle, DWORD dwLen, LPVOID lpData)
     * }
     */
    public static FunctionDescriptor GetFileVersionInfoExA$descriptor() {
        return GetFileVersionInfoExA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetFileVersionInfoExA(DWORD dwFlags, LPCSTR lpwstrFilename, DWORD dwHandle, DWORD dwLen, LPVOID lpData)
     * }
     */
    public static MethodHandle GetFileVersionInfoExA$handle() {
        return GetFileVersionInfoExA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL GetFileVersionInfoExA(DWORD dwFlags, LPCSTR lpwstrFilename, DWORD dwHandle, DWORD dwLen, LPVOID lpData)
     * }
     */
    public static int GetFileVersionInfoExA(int dwFlags, MemorySegment lpwstrFilename, int dwHandle, int dwLen, MemorySegment lpData) {
        var mh$ = GetFileVersionInfoExA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetFileVersionInfoExA", dwFlags, lpwstrFilename, dwHandle, dwLen, lpData);
            }
            return (int)mh$.invokeExact(dwFlags, lpwstrFilename, dwHandle, dwLen, lpData);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetFileVersionInfoExW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_LONG,
            C_POINTER,
            C_LONG,
            C_LONG,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetFileVersionInfoExW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetFileVersionInfoExW(DWORD dwFlags, LPCWSTR lpwstrFilename, DWORD dwHandle, DWORD dwLen, LPVOID lpData)
     * }
     */
    public static FunctionDescriptor GetFileVersionInfoExW$descriptor() {
        return GetFileVersionInfoExW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetFileVersionInfoExW(DWORD dwFlags, LPCWSTR lpwstrFilename, DWORD dwHandle, DWORD dwLen, LPVOID lpData)
     * }
     */
    public static MethodHandle GetFileVersionInfoExW$handle() {
        return GetFileVersionInfoExW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL GetFileVersionInfoExW(DWORD dwFlags, LPCWSTR lpwstrFilename, DWORD dwHandle, DWORD dwLen, LPVOID lpData)
     * }
     */
    public static int GetFileVersionInfoExW(int dwFlags, MemorySegment lpwstrFilename, int dwHandle, int dwLen, MemorySegment lpData) {
        var mh$ = GetFileVersionInfoExW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetFileVersionInfoExW", dwFlags, lpwstrFilename, dwHandle, dwLen, lpData);
            }
            return (int)mh$.invokeExact(dwFlags, lpwstrFilename, dwHandle, dwLen, lpData);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class VerLanguageNameA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_LONG,
            C_POINTER,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("VerLanguageNameA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD VerLanguageNameA(DWORD wLang, LPSTR szLang, DWORD cchLang)
     * }
     */
    public static FunctionDescriptor VerLanguageNameA$descriptor() {
        return VerLanguageNameA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD VerLanguageNameA(DWORD wLang, LPSTR szLang, DWORD cchLang)
     * }
     */
    public static MethodHandle VerLanguageNameA$handle() {
        return VerLanguageNameA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * DWORD VerLanguageNameA(DWORD wLang, LPSTR szLang, DWORD cchLang)
     * }
     */
    public static int VerLanguageNameA(int wLang, MemorySegment szLang, int cchLang) {
        var mh$ = VerLanguageNameA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("VerLanguageNameA", wLang, szLang, cchLang);
            }
            return (int)mh$.invokeExact(wLang, szLang, cchLang);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class VerLanguageNameW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_LONG,
            C_POINTER,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("VerLanguageNameW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD VerLanguageNameW(DWORD wLang, LPWSTR szLang, DWORD cchLang)
     * }
     */
    public static FunctionDescriptor VerLanguageNameW$descriptor() {
        return VerLanguageNameW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD VerLanguageNameW(DWORD wLang, LPWSTR szLang, DWORD cchLang)
     * }
     */
    public static MethodHandle VerLanguageNameW$handle() {
        return VerLanguageNameW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * DWORD VerLanguageNameW(DWORD wLang, LPWSTR szLang, DWORD cchLang)
     * }
     */
    public static int VerLanguageNameW(int wLang, MemorySegment szLang, int cchLang) {
        var mh$ = VerLanguageNameW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("VerLanguageNameW", wLang, szLang, cchLang);
            }
            return (int)mh$.invokeExact(wLang, szLang, cchLang);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class VerQueryValueA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("VerQueryValueA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL VerQueryValueA(LPCVOID pBlock, LPCSTR lpSubBlock, LPVOID *lplpBuffer, PUINT puLen)
     * }
     */
    public static FunctionDescriptor VerQueryValueA$descriptor() {
        return VerQueryValueA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL VerQueryValueA(LPCVOID pBlock, LPCSTR lpSubBlock, LPVOID *lplpBuffer, PUINT puLen)
     * }
     */
    public static MethodHandle VerQueryValueA$handle() {
        return VerQueryValueA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL VerQueryValueA(LPCVOID pBlock, LPCSTR lpSubBlock, LPVOID *lplpBuffer, PUINT puLen)
     * }
     */
    public static int VerQueryValueA(MemorySegment pBlock, MemorySegment lpSubBlock, MemorySegment lplpBuffer, MemorySegment puLen) {
        var mh$ = VerQueryValueA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("VerQueryValueA", pBlock, lpSubBlock, lplpBuffer, puLen);
            }
            return (int)mh$.invokeExact(pBlock, lpSubBlock, lplpBuffer, puLen);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class VerQueryValueW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("VerQueryValueW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL VerQueryValueW(LPCVOID pBlock, LPCWSTR lpSubBlock, LPVOID *lplpBuffer, PUINT puLen)
     * }
     */
    public static FunctionDescriptor VerQueryValueW$descriptor() {
        return VerQueryValueW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL VerQueryValueW(LPCVOID pBlock, LPCWSTR lpSubBlock, LPVOID *lplpBuffer, PUINT puLen)
     * }
     */
    public static MethodHandle VerQueryValueW$handle() {
        return VerQueryValueW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL VerQueryValueW(LPCVOID pBlock, LPCWSTR lpSubBlock, LPVOID *lplpBuffer, PUINT puLen)
     * }
     */
    public static int VerQueryValueW(MemorySegment pBlock, MemorySegment lpSubBlock, MemorySegment lplpBuffer, MemorySegment puLen) {
        var mh$ = VerQueryValueW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("VerQueryValueW", pBlock, lpSubBlock, lplpBuffer, puLen);
            }
            return (int)mh$.invokeExact(pBlock, lpSubBlock, lplpBuffer, puLen);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef LONG LSTATUS
     * }
     */
    public static final OfInt LSTATUS = C_LONG;
    /**
     * {@snippet lang=c :
     * typedef ACCESS_MASK REGSAM
     * }
     */
    public static final OfInt REGSAM = C_LONG;
    /**
     * {@snippet lang=c :
     * typedef struct val_context {
     *     int valuelen;
     *     LPVOID value_context;
     *     LPVOID val_buff_ptr;
     * } *PVALCONTEXT
     * }
     */
    public static final AddressLayout PVALCONTEXT = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct pvalueA {
     *     LPSTR pv_valuename;
     *     int pv_valuelen;
     *     LPVOID pv_value_context;
     *     DWORD pv_type;
     * } *PPVALUEA
     * }
     */
    public static final AddressLayout PPVALUEA = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct pvalueW {
     *     LPWSTR pv_valuename;
     *     int pv_valuelen;
     *     LPVOID pv_value_context;
     *     DWORD pv_type;
     * } *PPVALUEW
     * }
     */
    public static final AddressLayout PPVALUEW = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef PPVALUEA PPVALUE
     * }
     */
    public static final AddressLayout PPVALUE = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct provider_info {
     *     PQUERYHANDLER pi_R0_1val;
     *     PQUERYHANDLER pi_R0_allvals;
     *     PQUERYHANDLER pi_R3_1val;
     *     PQUERYHANDLER pi_R3_allvals;
     *     DWORD pi_flags;
     *     LPVOID pi_key_context;
     * } *PPROVIDER
     * }
     */
    public static final AddressLayout PPROVIDER = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct value_entA {
     *     LPSTR ve_valuename;
     *     DWORD ve_valuelen;
     *     DWORD_PTR ve_valueptr;
     *     DWORD ve_type;
     * } *PVALENTA
     * }
     */
    public static final AddressLayout PVALENTA = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct value_entW {
     *     LPWSTR ve_valuename;
     *     DWORD ve_valuelen;
     *     DWORD_PTR ve_valueptr;
     *     DWORD ve_type;
     * } *PVALENTW
     * }
     */
    public static final AddressLayout PVALENTW = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef PVALENTA PVALENT
     * }
     */
    public static final AddressLayout PVALENT = C_POINTER;

    private static class RegCloseKey {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("RegCloseKey"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LSTATUS RegCloseKey(HKEY hKey)
     * }
     */
    public static FunctionDescriptor RegCloseKey$descriptor() {
        return RegCloseKey.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LSTATUS RegCloseKey(HKEY hKey)
     * }
     */
    public static MethodHandle RegCloseKey$handle() {
        return RegCloseKey.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * LSTATUS RegCloseKey(HKEY hKey)
     * }
     */
    public static int RegCloseKey(MemorySegment hKey) {
        var mh$ = RegCloseKey.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RegCloseKey", hKey);
            }
            return (int)mh$.invokeExact(hKey);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RegOverridePredefKey {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("RegOverridePredefKey"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LSTATUS RegOverridePredefKey(HKEY hKey, HKEY hNewHKey)
     * }
     */
    public static FunctionDescriptor RegOverridePredefKey$descriptor() {
        return RegOverridePredefKey.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LSTATUS RegOverridePredefKey(HKEY hKey, HKEY hNewHKey)
     * }
     */
    public static MethodHandle RegOverridePredefKey$handle() {
        return RegOverridePredefKey.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * LSTATUS RegOverridePredefKey(HKEY hKey, HKEY hNewHKey)
     * }
     */
    public static int RegOverridePredefKey(MemorySegment hKey, MemorySegment hNewHKey) {
        var mh$ = RegOverridePredefKey.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RegOverridePredefKey", hKey, hNewHKey);
            }
            return (int)mh$.invokeExact(hKey, hNewHKey);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RegOpenUserClassesRoot {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_POINTER,
            C_LONG,
            C_LONG,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("RegOpenUserClassesRoot"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LSTATUS RegOpenUserClassesRoot(HANDLE hToken, DWORD dwOptions, REGSAM samDesired, PHKEY phkResult)
     * }
     */
    public static FunctionDescriptor RegOpenUserClassesRoot$descriptor() {
        return RegOpenUserClassesRoot.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LSTATUS RegOpenUserClassesRoot(HANDLE hToken, DWORD dwOptions, REGSAM samDesired, PHKEY phkResult)
     * }
     */
    public static MethodHandle RegOpenUserClassesRoot$handle() {
        return RegOpenUserClassesRoot.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * LSTATUS RegOpenUserClassesRoot(HANDLE hToken, DWORD dwOptions, REGSAM samDesired, PHKEY phkResult)
     * }
     */
    public static int RegOpenUserClassesRoot(MemorySegment hToken, int dwOptions, int samDesired, MemorySegment phkResult) {
        var mh$ = RegOpenUserClassesRoot.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RegOpenUserClassesRoot", hToken, dwOptions, samDesired, phkResult);
            }
            return (int)mh$.invokeExact(hToken, dwOptions, samDesired, phkResult);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RegOpenCurrentUser {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_LONG,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("RegOpenCurrentUser"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LSTATUS RegOpenCurrentUser(REGSAM samDesired, PHKEY phkResult)
     * }
     */
    public static FunctionDescriptor RegOpenCurrentUser$descriptor() {
        return RegOpenCurrentUser.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LSTATUS RegOpenCurrentUser(REGSAM samDesired, PHKEY phkResult)
     * }
     */
    public static MethodHandle RegOpenCurrentUser$handle() {
        return RegOpenCurrentUser.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * LSTATUS RegOpenCurrentUser(REGSAM samDesired, PHKEY phkResult)
     * }
     */
    public static int RegOpenCurrentUser(int samDesired, MemorySegment phkResult) {
        var mh$ = RegOpenCurrentUser.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RegOpenCurrentUser", samDesired, phkResult);
            }
            return (int)mh$.invokeExact(samDesired, phkResult);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RegDisablePredefinedCache {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG    );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("RegDisablePredefinedCache"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LSTATUS RegDisablePredefinedCache()
     * }
     */
    public static FunctionDescriptor RegDisablePredefinedCache$descriptor() {
        return RegDisablePredefinedCache.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LSTATUS RegDisablePredefinedCache()
     * }
     */
    public static MethodHandle RegDisablePredefinedCache$handle() {
        return RegDisablePredefinedCache.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * LSTATUS RegDisablePredefinedCache()
     * }
     */
    public static int RegDisablePredefinedCache() {
        var mh$ = RegDisablePredefinedCache.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RegDisablePredefinedCache");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RegDisablePredefinedCacheEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG    );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("RegDisablePredefinedCacheEx"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LSTATUS RegDisablePredefinedCacheEx()
     * }
     */
    public static FunctionDescriptor RegDisablePredefinedCacheEx$descriptor() {
        return RegDisablePredefinedCacheEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LSTATUS RegDisablePredefinedCacheEx()
     * }
     */
    public static MethodHandle RegDisablePredefinedCacheEx$handle() {
        return RegDisablePredefinedCacheEx.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * LSTATUS RegDisablePredefinedCacheEx()
     * }
     */
    public static int RegDisablePredefinedCacheEx() {
        var mh$ = RegDisablePredefinedCacheEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RegDisablePredefinedCacheEx");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RegConnectRegistryA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("RegConnectRegistryA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LSTATUS RegConnectRegistryA(LPCSTR lpMachineName, HKEY hKey, PHKEY phkResult)
     * }
     */
    public static FunctionDescriptor RegConnectRegistryA$descriptor() {
        return RegConnectRegistryA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LSTATUS RegConnectRegistryA(LPCSTR lpMachineName, HKEY hKey, PHKEY phkResult)
     * }
     */
    public static MethodHandle RegConnectRegistryA$handle() {
        return RegConnectRegistryA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * LSTATUS RegConnectRegistryA(LPCSTR lpMachineName, HKEY hKey, PHKEY phkResult)
     * }
     */
    public static int RegConnectRegistryA(MemorySegment lpMachineName, MemorySegment hKey, MemorySegment phkResult) {
        var mh$ = RegConnectRegistryA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RegConnectRegistryA", lpMachineName, hKey, phkResult);
            }
            return (int)mh$.invokeExact(lpMachineName, hKey, phkResult);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RegConnectRegistryW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("RegConnectRegistryW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LSTATUS RegConnectRegistryW(LPCWSTR lpMachineName, HKEY hKey, PHKEY phkResult)
     * }
     */
    public static FunctionDescriptor RegConnectRegistryW$descriptor() {
        return RegConnectRegistryW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LSTATUS RegConnectRegistryW(LPCWSTR lpMachineName, HKEY hKey, PHKEY phkResult)
     * }
     */
    public static MethodHandle RegConnectRegistryW$handle() {
        return RegConnectRegistryW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * LSTATUS RegConnectRegistryW(LPCWSTR lpMachineName, HKEY hKey, PHKEY phkResult)
     * }
     */
    public static int RegConnectRegistryW(MemorySegment lpMachineName, MemorySegment hKey, MemorySegment phkResult) {
        var mh$ = RegConnectRegistryW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RegConnectRegistryW", lpMachineName, hKey, phkResult);
            }
            return (int)mh$.invokeExact(lpMachineName, hKey, phkResult);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RegConnectRegistryExA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_POINTER,
            C_POINTER,
            C_LONG,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("RegConnectRegistryExA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LSTATUS RegConnectRegistryExA(LPCSTR lpMachineName, HKEY hKey, ULONG Flags, PHKEY phkResult)
     * }
     */
    public static FunctionDescriptor RegConnectRegistryExA$descriptor() {
        return RegConnectRegistryExA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LSTATUS RegConnectRegistryExA(LPCSTR lpMachineName, HKEY hKey, ULONG Flags, PHKEY phkResult)
     * }
     */
    public static MethodHandle RegConnectRegistryExA$handle() {
        return RegConnectRegistryExA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * LSTATUS RegConnectRegistryExA(LPCSTR lpMachineName, HKEY hKey, ULONG Flags, PHKEY phkResult)
     * }
     */
    public static int RegConnectRegistryExA(MemorySegment lpMachineName, MemorySegment hKey, int Flags, MemorySegment phkResult) {
        var mh$ = RegConnectRegistryExA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RegConnectRegistryExA", lpMachineName, hKey, Flags, phkResult);
            }
            return (int)mh$.invokeExact(lpMachineName, hKey, Flags, phkResult);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RegConnectRegistryExW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_POINTER,
            C_POINTER,
            C_LONG,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("RegConnectRegistryExW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LSTATUS RegConnectRegistryExW(LPCWSTR lpMachineName, HKEY hKey, ULONG Flags, PHKEY phkResult)
     * }
     */
    public static FunctionDescriptor RegConnectRegistryExW$descriptor() {
        return RegConnectRegistryExW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LSTATUS RegConnectRegistryExW(LPCWSTR lpMachineName, HKEY hKey, ULONG Flags, PHKEY phkResult)
     * }
     */
    public static MethodHandle RegConnectRegistryExW$handle() {
        return RegConnectRegistryExW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * LSTATUS RegConnectRegistryExW(LPCWSTR lpMachineName, HKEY hKey, ULONG Flags, PHKEY phkResult)
     * }
     */
    public static int RegConnectRegistryExW(MemorySegment lpMachineName, MemorySegment hKey, int Flags, MemorySegment phkResult) {
        var mh$ = RegConnectRegistryExW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RegConnectRegistryExW", lpMachineName, hKey, Flags, phkResult);
            }
            return (int)mh$.invokeExact(lpMachineName, hKey, Flags, phkResult);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RegCreateKeyA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("RegCreateKeyA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LSTATUS RegCreateKeyA(HKEY hKey, LPCSTR lpSubKey, PHKEY phkResult)
     * }
     */
    public static FunctionDescriptor RegCreateKeyA$descriptor() {
        return RegCreateKeyA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LSTATUS RegCreateKeyA(HKEY hKey, LPCSTR lpSubKey, PHKEY phkResult)
     * }
     */
    public static MethodHandle RegCreateKeyA$handle() {
        return RegCreateKeyA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * LSTATUS RegCreateKeyA(HKEY hKey, LPCSTR lpSubKey, PHKEY phkResult)
     * }
     */
    public static int RegCreateKeyA(MemorySegment hKey, MemorySegment lpSubKey, MemorySegment phkResult) {
        var mh$ = RegCreateKeyA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RegCreateKeyA", hKey, lpSubKey, phkResult);
            }
            return (int)mh$.invokeExact(hKey, lpSubKey, phkResult);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RegCreateKeyW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("RegCreateKeyW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LSTATUS RegCreateKeyW(HKEY hKey, LPCWSTR lpSubKey, PHKEY phkResult)
     * }
     */
    public static FunctionDescriptor RegCreateKeyW$descriptor() {
        return RegCreateKeyW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LSTATUS RegCreateKeyW(HKEY hKey, LPCWSTR lpSubKey, PHKEY phkResult)
     * }
     */
    public static MethodHandle RegCreateKeyW$handle() {
        return RegCreateKeyW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * LSTATUS RegCreateKeyW(HKEY hKey, LPCWSTR lpSubKey, PHKEY phkResult)
     * }
     */
    public static int RegCreateKeyW(MemorySegment hKey, MemorySegment lpSubKey, MemorySegment phkResult) {
        var mh$ = RegCreateKeyW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RegCreateKeyW", hKey, lpSubKey, phkResult);
            }
            return (int)mh$.invokeExact(hKey, lpSubKey, phkResult);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RegCreateKeyExA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_POINTER,
            C_POINTER,
            C_LONG,
            C_POINTER,
            C_LONG,
            C_LONG,
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("RegCreateKeyExA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LSTATUS RegCreateKeyExA(HKEY hKey, LPCSTR lpSubKey, DWORD Reserved, LPSTR lpClass, DWORD dwOptions, REGSAM samDesired, const LPSECURITY_ATTRIBUTES lpSecurityAttributes, PHKEY phkResult, LPDWORD lpdwDisposition)
     * }
     */
    public static FunctionDescriptor RegCreateKeyExA$descriptor() {
        return RegCreateKeyExA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LSTATUS RegCreateKeyExA(HKEY hKey, LPCSTR lpSubKey, DWORD Reserved, LPSTR lpClass, DWORD dwOptions, REGSAM samDesired, const LPSECURITY_ATTRIBUTES lpSecurityAttributes, PHKEY phkResult, LPDWORD lpdwDisposition)
     * }
     */
    public static MethodHandle RegCreateKeyExA$handle() {
        return RegCreateKeyExA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * LSTATUS RegCreateKeyExA(HKEY hKey, LPCSTR lpSubKey, DWORD Reserved, LPSTR lpClass, DWORD dwOptions, REGSAM samDesired, const LPSECURITY_ATTRIBUTES lpSecurityAttributes, PHKEY phkResult, LPDWORD lpdwDisposition)
     * }
     */
    public static int RegCreateKeyExA(MemorySegment hKey, MemorySegment lpSubKey, int Reserved, MemorySegment lpClass, int dwOptions, int samDesired, MemorySegment lpSecurityAttributes, MemorySegment phkResult, MemorySegment lpdwDisposition) {
        var mh$ = RegCreateKeyExA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RegCreateKeyExA", hKey, lpSubKey, Reserved, lpClass, dwOptions, samDesired, lpSecurityAttributes, phkResult, lpdwDisposition);
            }
            return (int)mh$.invokeExact(hKey, lpSubKey, Reserved, lpClass, dwOptions, samDesired, lpSecurityAttributes, phkResult, lpdwDisposition);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RegCreateKeyExW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_POINTER,
            C_POINTER,
            C_LONG,
            C_POINTER,
            C_LONG,
            C_LONG,
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("RegCreateKeyExW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LSTATUS RegCreateKeyExW(HKEY hKey, LPCWSTR lpSubKey, DWORD Reserved, LPWSTR lpClass, DWORD dwOptions, REGSAM samDesired, const LPSECURITY_ATTRIBUTES lpSecurityAttributes, PHKEY phkResult, LPDWORD lpdwDisposition)
     * }
     */
    public static FunctionDescriptor RegCreateKeyExW$descriptor() {
        return RegCreateKeyExW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LSTATUS RegCreateKeyExW(HKEY hKey, LPCWSTR lpSubKey, DWORD Reserved, LPWSTR lpClass, DWORD dwOptions, REGSAM samDesired, const LPSECURITY_ATTRIBUTES lpSecurityAttributes, PHKEY phkResult, LPDWORD lpdwDisposition)
     * }
     */
    public static MethodHandle RegCreateKeyExW$handle() {
        return RegCreateKeyExW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * LSTATUS RegCreateKeyExW(HKEY hKey, LPCWSTR lpSubKey, DWORD Reserved, LPWSTR lpClass, DWORD dwOptions, REGSAM samDesired, const LPSECURITY_ATTRIBUTES lpSecurityAttributes, PHKEY phkResult, LPDWORD lpdwDisposition)
     * }
     */
    public static int RegCreateKeyExW(MemorySegment hKey, MemorySegment lpSubKey, int Reserved, MemorySegment lpClass, int dwOptions, int samDesired, MemorySegment lpSecurityAttributes, MemorySegment phkResult, MemorySegment lpdwDisposition) {
        var mh$ = RegCreateKeyExW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RegCreateKeyExW", hKey, lpSubKey, Reserved, lpClass, dwOptions, samDesired, lpSecurityAttributes, phkResult, lpdwDisposition);
            }
            return (int)mh$.invokeExact(hKey, lpSubKey, Reserved, lpClass, dwOptions, samDesired, lpSecurityAttributes, phkResult, lpdwDisposition);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RegCreateKeyTransactedA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_POINTER,
            C_POINTER,
            C_LONG,
            C_POINTER,
            C_LONG,
            C_LONG,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("RegCreateKeyTransactedA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LSTATUS RegCreateKeyTransactedA(HKEY hKey, LPCSTR lpSubKey, DWORD Reserved, LPSTR lpClass, DWORD dwOptions, REGSAM samDesired, const LPSECURITY_ATTRIBUTES lpSecurityAttributes, PHKEY phkResult, LPDWORD lpdwDisposition, HANDLE hTransaction, PVOID pExtendedParemeter)
     * }
     */
    public static FunctionDescriptor RegCreateKeyTransactedA$descriptor() {
        return RegCreateKeyTransactedA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LSTATUS RegCreateKeyTransactedA(HKEY hKey, LPCSTR lpSubKey, DWORD Reserved, LPSTR lpClass, DWORD dwOptions, REGSAM samDesired, const LPSECURITY_ATTRIBUTES lpSecurityAttributes, PHKEY phkResult, LPDWORD lpdwDisposition, HANDLE hTransaction, PVOID pExtendedParemeter)
     * }
     */
    public static MethodHandle RegCreateKeyTransactedA$handle() {
        return RegCreateKeyTransactedA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * LSTATUS RegCreateKeyTransactedA(HKEY hKey, LPCSTR lpSubKey, DWORD Reserved, LPSTR lpClass, DWORD dwOptions, REGSAM samDesired, const LPSECURITY_ATTRIBUTES lpSecurityAttributes, PHKEY phkResult, LPDWORD lpdwDisposition, HANDLE hTransaction, PVOID pExtendedParemeter)
     * }
     */
    public static int RegCreateKeyTransactedA(MemorySegment hKey, MemorySegment lpSubKey, int Reserved, MemorySegment lpClass, int dwOptions, int samDesired, MemorySegment lpSecurityAttributes, MemorySegment phkResult, MemorySegment lpdwDisposition, MemorySegment hTransaction, MemorySegment pExtendedParemeter) {
        var mh$ = RegCreateKeyTransactedA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RegCreateKeyTransactedA", hKey, lpSubKey, Reserved, lpClass, dwOptions, samDesired, lpSecurityAttributes, phkResult, lpdwDisposition, hTransaction, pExtendedParemeter);
            }
            return (int)mh$.invokeExact(hKey, lpSubKey, Reserved, lpClass, dwOptions, samDesired, lpSecurityAttributes, phkResult, lpdwDisposition, hTransaction, pExtendedParemeter);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RegCreateKeyTransactedW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_POINTER,
            C_POINTER,
            C_LONG,
            C_POINTER,
            C_LONG,
            C_LONG,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("RegCreateKeyTransactedW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LSTATUS RegCreateKeyTransactedW(HKEY hKey, LPCWSTR lpSubKey, DWORD Reserved, LPWSTR lpClass, DWORD dwOptions, REGSAM samDesired, const LPSECURITY_ATTRIBUTES lpSecurityAttributes, PHKEY phkResult, LPDWORD lpdwDisposition, HANDLE hTransaction, PVOID pExtendedParemeter)
     * }
     */
    public static FunctionDescriptor RegCreateKeyTransactedW$descriptor() {
        return RegCreateKeyTransactedW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LSTATUS RegCreateKeyTransactedW(HKEY hKey, LPCWSTR lpSubKey, DWORD Reserved, LPWSTR lpClass, DWORD dwOptions, REGSAM samDesired, const LPSECURITY_ATTRIBUTES lpSecurityAttributes, PHKEY phkResult, LPDWORD lpdwDisposition, HANDLE hTransaction, PVOID pExtendedParemeter)
     * }
     */
    public static MethodHandle RegCreateKeyTransactedW$handle() {
        return RegCreateKeyTransactedW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * LSTATUS RegCreateKeyTransactedW(HKEY hKey, LPCWSTR lpSubKey, DWORD Reserved, LPWSTR lpClass, DWORD dwOptions, REGSAM samDesired, const LPSECURITY_ATTRIBUTES lpSecurityAttributes, PHKEY phkResult, LPDWORD lpdwDisposition, HANDLE hTransaction, PVOID pExtendedParemeter)
     * }
     */
    public static int RegCreateKeyTransactedW(MemorySegment hKey, MemorySegment lpSubKey, int Reserved, MemorySegment lpClass, int dwOptions, int samDesired, MemorySegment lpSecurityAttributes, MemorySegment phkResult, MemorySegment lpdwDisposition, MemorySegment hTransaction, MemorySegment pExtendedParemeter) {
        var mh$ = RegCreateKeyTransactedW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RegCreateKeyTransactedW", hKey, lpSubKey, Reserved, lpClass, dwOptions, samDesired, lpSecurityAttributes, phkResult, lpdwDisposition, hTransaction, pExtendedParemeter);
            }
            return (int)mh$.invokeExact(hKey, lpSubKey, Reserved, lpClass, dwOptions, samDesired, lpSecurityAttributes, phkResult, lpdwDisposition, hTransaction, pExtendedParemeter);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RegDeleteKeyA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("RegDeleteKeyA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LSTATUS RegDeleteKeyA(HKEY hKey, LPCSTR lpSubKey)
     * }
     */
    public static FunctionDescriptor RegDeleteKeyA$descriptor() {
        return RegDeleteKeyA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LSTATUS RegDeleteKeyA(HKEY hKey, LPCSTR lpSubKey)
     * }
     */
    public static MethodHandle RegDeleteKeyA$handle() {
        return RegDeleteKeyA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * LSTATUS RegDeleteKeyA(HKEY hKey, LPCSTR lpSubKey)
     * }
     */
    public static int RegDeleteKeyA(MemorySegment hKey, MemorySegment lpSubKey) {
        var mh$ = RegDeleteKeyA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RegDeleteKeyA", hKey, lpSubKey);
            }
            return (int)mh$.invokeExact(hKey, lpSubKey);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RegDeleteKeyW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("RegDeleteKeyW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LSTATUS RegDeleteKeyW(HKEY hKey, LPCWSTR lpSubKey)
     * }
     */
    public static FunctionDescriptor RegDeleteKeyW$descriptor() {
        return RegDeleteKeyW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LSTATUS RegDeleteKeyW(HKEY hKey, LPCWSTR lpSubKey)
     * }
     */
    public static MethodHandle RegDeleteKeyW$handle() {
        return RegDeleteKeyW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * LSTATUS RegDeleteKeyW(HKEY hKey, LPCWSTR lpSubKey)
     * }
     */
    public static int RegDeleteKeyW(MemorySegment hKey, MemorySegment lpSubKey) {
        var mh$ = RegDeleteKeyW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RegDeleteKeyW", hKey, lpSubKey);
            }
            return (int)mh$.invokeExact(hKey, lpSubKey);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RegDeleteKeyExA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_POINTER,
            C_POINTER,
            C_LONG,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("RegDeleteKeyExA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LSTATUS RegDeleteKeyExA(HKEY hKey, LPCSTR lpSubKey, REGSAM samDesired, DWORD Reserved)
     * }
     */
    public static FunctionDescriptor RegDeleteKeyExA$descriptor() {
        return RegDeleteKeyExA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LSTATUS RegDeleteKeyExA(HKEY hKey, LPCSTR lpSubKey, REGSAM samDesired, DWORD Reserved)
     * }
     */
    public static MethodHandle RegDeleteKeyExA$handle() {
        return RegDeleteKeyExA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * LSTATUS RegDeleteKeyExA(HKEY hKey, LPCSTR lpSubKey, REGSAM samDesired, DWORD Reserved)
     * }
     */
    public static int RegDeleteKeyExA(MemorySegment hKey, MemorySegment lpSubKey, int samDesired, int Reserved) {
        var mh$ = RegDeleteKeyExA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RegDeleteKeyExA", hKey, lpSubKey, samDesired, Reserved);
            }
            return (int)mh$.invokeExact(hKey, lpSubKey, samDesired, Reserved);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RegDeleteKeyExW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_POINTER,
            C_POINTER,
            C_LONG,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("RegDeleteKeyExW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LSTATUS RegDeleteKeyExW(HKEY hKey, LPCWSTR lpSubKey, REGSAM samDesired, DWORD Reserved)
     * }
     */
    public static FunctionDescriptor RegDeleteKeyExW$descriptor() {
        return RegDeleteKeyExW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LSTATUS RegDeleteKeyExW(HKEY hKey, LPCWSTR lpSubKey, REGSAM samDesired, DWORD Reserved)
     * }
     */
    public static MethodHandle RegDeleteKeyExW$handle() {
        return RegDeleteKeyExW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * LSTATUS RegDeleteKeyExW(HKEY hKey, LPCWSTR lpSubKey, REGSAM samDesired, DWORD Reserved)
     * }
     */
    public static int RegDeleteKeyExW(MemorySegment hKey, MemorySegment lpSubKey, int samDesired, int Reserved) {
        var mh$ = RegDeleteKeyExW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RegDeleteKeyExW", hKey, lpSubKey, samDesired, Reserved);
            }
            return (int)mh$.invokeExact(hKey, lpSubKey, samDesired, Reserved);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RegDeleteKeyTransactedA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_POINTER,
            C_POINTER,
            C_LONG,
            C_LONG,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("RegDeleteKeyTransactedA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LSTATUS RegDeleteKeyTransactedA(HKEY hKey, LPCSTR lpSubKey, REGSAM samDesired, DWORD Reserved, HANDLE hTransaction, PVOID pExtendedParameter)
     * }
     */
    public static FunctionDescriptor RegDeleteKeyTransactedA$descriptor() {
        return RegDeleteKeyTransactedA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LSTATUS RegDeleteKeyTransactedA(HKEY hKey, LPCSTR lpSubKey, REGSAM samDesired, DWORD Reserved, HANDLE hTransaction, PVOID pExtendedParameter)
     * }
     */
    public static MethodHandle RegDeleteKeyTransactedA$handle() {
        return RegDeleteKeyTransactedA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * LSTATUS RegDeleteKeyTransactedA(HKEY hKey, LPCSTR lpSubKey, REGSAM samDesired, DWORD Reserved, HANDLE hTransaction, PVOID pExtendedParameter)
     * }
     */
    public static int RegDeleteKeyTransactedA(MemorySegment hKey, MemorySegment lpSubKey, int samDesired, int Reserved, MemorySegment hTransaction, MemorySegment pExtendedParameter) {
        var mh$ = RegDeleteKeyTransactedA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RegDeleteKeyTransactedA", hKey, lpSubKey, samDesired, Reserved, hTransaction, pExtendedParameter);
            }
            return (int)mh$.invokeExact(hKey, lpSubKey, samDesired, Reserved, hTransaction, pExtendedParameter);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RegDeleteKeyTransactedW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_POINTER,
            C_POINTER,
            C_LONG,
            C_LONG,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("RegDeleteKeyTransactedW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LSTATUS RegDeleteKeyTransactedW(HKEY hKey, LPCWSTR lpSubKey, REGSAM samDesired, DWORD Reserved, HANDLE hTransaction, PVOID pExtendedParameter)
     * }
     */
    public static FunctionDescriptor RegDeleteKeyTransactedW$descriptor() {
        return RegDeleteKeyTransactedW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LSTATUS RegDeleteKeyTransactedW(HKEY hKey, LPCWSTR lpSubKey, REGSAM samDesired, DWORD Reserved, HANDLE hTransaction, PVOID pExtendedParameter)
     * }
     */
    public static MethodHandle RegDeleteKeyTransactedW$handle() {
        return RegDeleteKeyTransactedW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * LSTATUS RegDeleteKeyTransactedW(HKEY hKey, LPCWSTR lpSubKey, REGSAM samDesired, DWORD Reserved, HANDLE hTransaction, PVOID pExtendedParameter)
     * }
     */
    public static int RegDeleteKeyTransactedW(MemorySegment hKey, MemorySegment lpSubKey, int samDesired, int Reserved, MemorySegment hTransaction, MemorySegment pExtendedParameter) {
        var mh$ = RegDeleteKeyTransactedW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RegDeleteKeyTransactedW", hKey, lpSubKey, samDesired, Reserved, hTransaction, pExtendedParameter);
            }
            return (int)mh$.invokeExact(hKey, lpSubKey, samDesired, Reserved, hTransaction, pExtendedParameter);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RegDisableReflectionKey {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("RegDisableReflectionKey"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LONG RegDisableReflectionKey(HKEY hBase)
     * }
     */
    public static FunctionDescriptor RegDisableReflectionKey$descriptor() {
        return RegDisableReflectionKey.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LONG RegDisableReflectionKey(HKEY hBase)
     * }
     */
    public static MethodHandle RegDisableReflectionKey$handle() {
        return RegDisableReflectionKey.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * LONG RegDisableReflectionKey(HKEY hBase)
     * }
     */
    public static int RegDisableReflectionKey(MemorySegment hBase) {
        var mh$ = RegDisableReflectionKey.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RegDisableReflectionKey", hBase);
            }
            return (int)mh$.invokeExact(hBase);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RegEnableReflectionKey {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("RegEnableReflectionKey"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LONG RegEnableReflectionKey(HKEY hBase)
     * }
     */
    public static FunctionDescriptor RegEnableReflectionKey$descriptor() {
        return RegEnableReflectionKey.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LONG RegEnableReflectionKey(HKEY hBase)
     * }
     */
    public static MethodHandle RegEnableReflectionKey$handle() {
        return RegEnableReflectionKey.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * LONG RegEnableReflectionKey(HKEY hBase)
     * }
     */
    public static int RegEnableReflectionKey(MemorySegment hBase) {
        var mh$ = RegEnableReflectionKey.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RegEnableReflectionKey", hBase);
            }
            return (int)mh$.invokeExact(hBase);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RegQueryReflectionKey {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("RegQueryReflectionKey"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LONG RegQueryReflectionKey(HKEY hBase, BOOL *bIsReflectionDisabled)
     * }
     */
    public static FunctionDescriptor RegQueryReflectionKey$descriptor() {
        return RegQueryReflectionKey.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LONG RegQueryReflectionKey(HKEY hBase, BOOL *bIsReflectionDisabled)
     * }
     */
    public static MethodHandle RegQueryReflectionKey$handle() {
        return RegQueryReflectionKey.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * LONG RegQueryReflectionKey(HKEY hBase, BOOL *bIsReflectionDisabled)
     * }
     */
    public static int RegQueryReflectionKey(MemorySegment hBase, MemorySegment bIsReflectionDisabled) {
        var mh$ = RegQueryReflectionKey.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RegQueryReflectionKey", hBase, bIsReflectionDisabled);
            }
            return (int)mh$.invokeExact(hBase, bIsReflectionDisabled);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RegDeleteValueA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("RegDeleteValueA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LSTATUS RegDeleteValueA(HKEY hKey, LPCSTR lpValueName)
     * }
     */
    public static FunctionDescriptor RegDeleteValueA$descriptor() {
        return RegDeleteValueA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LSTATUS RegDeleteValueA(HKEY hKey, LPCSTR lpValueName)
     * }
     */
    public static MethodHandle RegDeleteValueA$handle() {
        return RegDeleteValueA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * LSTATUS RegDeleteValueA(HKEY hKey, LPCSTR lpValueName)
     * }
     */
    public static int RegDeleteValueA(MemorySegment hKey, MemorySegment lpValueName) {
        var mh$ = RegDeleteValueA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RegDeleteValueA", hKey, lpValueName);
            }
            return (int)mh$.invokeExact(hKey, lpValueName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RegDeleteValueW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("RegDeleteValueW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LSTATUS RegDeleteValueW(HKEY hKey, LPCWSTR lpValueName)
     * }
     */
    public static FunctionDescriptor RegDeleteValueW$descriptor() {
        return RegDeleteValueW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LSTATUS RegDeleteValueW(HKEY hKey, LPCWSTR lpValueName)
     * }
     */
    public static MethodHandle RegDeleteValueW$handle() {
        return RegDeleteValueW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * LSTATUS RegDeleteValueW(HKEY hKey, LPCWSTR lpValueName)
     * }
     */
    public static int RegDeleteValueW(MemorySegment hKey, MemorySegment lpValueName) {
        var mh$ = RegDeleteValueW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RegDeleteValueW", hKey, lpValueName);
            }
            return (int)mh$.invokeExact(hKey, lpValueName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RegEnumKeyA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_POINTER,
            C_LONG,
            C_POINTER,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("RegEnumKeyA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LSTATUS RegEnumKeyA(HKEY hKey, DWORD dwIndex, LPSTR lpName, DWORD cchName)
     * }
     */
    public static FunctionDescriptor RegEnumKeyA$descriptor() {
        return RegEnumKeyA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LSTATUS RegEnumKeyA(HKEY hKey, DWORD dwIndex, LPSTR lpName, DWORD cchName)
     * }
     */
    public static MethodHandle RegEnumKeyA$handle() {
        return RegEnumKeyA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * LSTATUS RegEnumKeyA(HKEY hKey, DWORD dwIndex, LPSTR lpName, DWORD cchName)
     * }
     */
    public static int RegEnumKeyA(MemorySegment hKey, int dwIndex, MemorySegment lpName, int cchName) {
        var mh$ = RegEnumKeyA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RegEnumKeyA", hKey, dwIndex, lpName, cchName);
            }
            return (int)mh$.invokeExact(hKey, dwIndex, lpName, cchName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RegEnumKeyW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_POINTER,
            C_LONG,
            C_POINTER,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("RegEnumKeyW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LSTATUS RegEnumKeyW(HKEY hKey, DWORD dwIndex, LPWSTR lpName, DWORD cchName)
     * }
     */
    public static FunctionDescriptor RegEnumKeyW$descriptor() {
        return RegEnumKeyW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LSTATUS RegEnumKeyW(HKEY hKey, DWORD dwIndex, LPWSTR lpName, DWORD cchName)
     * }
     */
    public static MethodHandle RegEnumKeyW$handle() {
        return RegEnumKeyW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * LSTATUS RegEnumKeyW(HKEY hKey, DWORD dwIndex, LPWSTR lpName, DWORD cchName)
     * }
     */
    public static int RegEnumKeyW(MemorySegment hKey, int dwIndex, MemorySegment lpName, int cchName) {
        var mh$ = RegEnumKeyW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RegEnumKeyW", hKey, dwIndex, lpName, cchName);
            }
            return (int)mh$.invokeExact(hKey, dwIndex, lpName, cchName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RegEnumKeyExA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_POINTER,
            C_LONG,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("RegEnumKeyExA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LSTATUS RegEnumKeyExA(HKEY hKey, DWORD dwIndex, LPSTR lpName, LPDWORD lpcchName, LPDWORD lpReserved, LPSTR lpClass, LPDWORD lpcchClass, PFILETIME lpftLastWriteTime)
     * }
     */
    public static FunctionDescriptor RegEnumKeyExA$descriptor() {
        return RegEnumKeyExA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LSTATUS RegEnumKeyExA(HKEY hKey, DWORD dwIndex, LPSTR lpName, LPDWORD lpcchName, LPDWORD lpReserved, LPSTR lpClass, LPDWORD lpcchClass, PFILETIME lpftLastWriteTime)
     * }
     */
    public static MethodHandle RegEnumKeyExA$handle() {
        return RegEnumKeyExA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * LSTATUS RegEnumKeyExA(HKEY hKey, DWORD dwIndex, LPSTR lpName, LPDWORD lpcchName, LPDWORD lpReserved, LPSTR lpClass, LPDWORD lpcchClass, PFILETIME lpftLastWriteTime)
     * }
     */
    public static int RegEnumKeyExA(MemorySegment hKey, int dwIndex, MemorySegment lpName, MemorySegment lpcchName, MemorySegment lpReserved, MemorySegment lpClass, MemorySegment lpcchClass, MemorySegment lpftLastWriteTime) {
        var mh$ = RegEnumKeyExA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RegEnumKeyExA", hKey, dwIndex, lpName, lpcchName, lpReserved, lpClass, lpcchClass, lpftLastWriteTime);
            }
            return (int)mh$.invokeExact(hKey, dwIndex, lpName, lpcchName, lpReserved, lpClass, lpcchClass, lpftLastWriteTime);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RegEnumKeyExW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_POINTER,
            C_LONG,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("RegEnumKeyExW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LSTATUS RegEnumKeyExW(HKEY hKey, DWORD dwIndex, LPWSTR lpName, LPDWORD lpcchName, LPDWORD lpReserved, LPWSTR lpClass, LPDWORD lpcchClass, PFILETIME lpftLastWriteTime)
     * }
     */
    public static FunctionDescriptor RegEnumKeyExW$descriptor() {
        return RegEnumKeyExW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LSTATUS RegEnumKeyExW(HKEY hKey, DWORD dwIndex, LPWSTR lpName, LPDWORD lpcchName, LPDWORD lpReserved, LPWSTR lpClass, LPDWORD lpcchClass, PFILETIME lpftLastWriteTime)
     * }
     */
    public static MethodHandle RegEnumKeyExW$handle() {
        return RegEnumKeyExW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * LSTATUS RegEnumKeyExW(HKEY hKey, DWORD dwIndex, LPWSTR lpName, LPDWORD lpcchName, LPDWORD lpReserved, LPWSTR lpClass, LPDWORD lpcchClass, PFILETIME lpftLastWriteTime)
     * }
     */
    public static int RegEnumKeyExW(MemorySegment hKey, int dwIndex, MemorySegment lpName, MemorySegment lpcchName, MemorySegment lpReserved, MemorySegment lpClass, MemorySegment lpcchClass, MemorySegment lpftLastWriteTime) {
        var mh$ = RegEnumKeyExW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RegEnumKeyExW", hKey, dwIndex, lpName, lpcchName, lpReserved, lpClass, lpcchClass, lpftLastWriteTime);
            }
            return (int)mh$.invokeExact(hKey, dwIndex, lpName, lpcchName, lpReserved, lpClass, lpcchClass, lpftLastWriteTime);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RegEnumValueA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_POINTER,
            C_LONG,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("RegEnumValueA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LSTATUS RegEnumValueA(HKEY hKey, DWORD dwIndex, LPSTR lpValueName, LPDWORD lpcchValueName, LPDWORD lpReserved, LPDWORD lpType, LPBYTE lpData, LPDWORD lpcbData)
     * }
     */
    public static FunctionDescriptor RegEnumValueA$descriptor() {
        return RegEnumValueA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LSTATUS RegEnumValueA(HKEY hKey, DWORD dwIndex, LPSTR lpValueName, LPDWORD lpcchValueName, LPDWORD lpReserved, LPDWORD lpType, LPBYTE lpData, LPDWORD lpcbData)
     * }
     */
    public static MethodHandle RegEnumValueA$handle() {
        return RegEnumValueA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * LSTATUS RegEnumValueA(HKEY hKey, DWORD dwIndex, LPSTR lpValueName, LPDWORD lpcchValueName, LPDWORD lpReserved, LPDWORD lpType, LPBYTE lpData, LPDWORD lpcbData)
     * }
     */
    public static int RegEnumValueA(MemorySegment hKey, int dwIndex, MemorySegment lpValueName, MemorySegment lpcchValueName, MemorySegment lpReserved, MemorySegment lpType, MemorySegment lpData, MemorySegment lpcbData) {
        var mh$ = RegEnumValueA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RegEnumValueA", hKey, dwIndex, lpValueName, lpcchValueName, lpReserved, lpType, lpData, lpcbData);
            }
            return (int)mh$.invokeExact(hKey, dwIndex, lpValueName, lpcchValueName, lpReserved, lpType, lpData, lpcbData);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RegEnumValueW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_POINTER,
            C_LONG,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("RegEnumValueW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LSTATUS RegEnumValueW(HKEY hKey, DWORD dwIndex, LPWSTR lpValueName, LPDWORD lpcchValueName, LPDWORD lpReserved, LPDWORD lpType, LPBYTE lpData, LPDWORD lpcbData)
     * }
     */
    public static FunctionDescriptor RegEnumValueW$descriptor() {
        return RegEnumValueW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LSTATUS RegEnumValueW(HKEY hKey, DWORD dwIndex, LPWSTR lpValueName, LPDWORD lpcchValueName, LPDWORD lpReserved, LPDWORD lpType, LPBYTE lpData, LPDWORD lpcbData)
     * }
     */
    public static MethodHandle RegEnumValueW$handle() {
        return RegEnumValueW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * LSTATUS RegEnumValueW(HKEY hKey, DWORD dwIndex, LPWSTR lpValueName, LPDWORD lpcchValueName, LPDWORD lpReserved, LPDWORD lpType, LPBYTE lpData, LPDWORD lpcbData)
     * }
     */
    public static int RegEnumValueW(MemorySegment hKey, int dwIndex, MemorySegment lpValueName, MemorySegment lpcchValueName, MemorySegment lpReserved, MemorySegment lpType, MemorySegment lpData, MemorySegment lpcbData) {
        var mh$ = RegEnumValueW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RegEnumValueW", hKey, dwIndex, lpValueName, lpcchValueName, lpReserved, lpType, lpData, lpcbData);
            }
            return (int)mh$.invokeExact(hKey, dwIndex, lpValueName, lpcchValueName, lpReserved, lpType, lpData, lpcbData);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RegFlushKey {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("RegFlushKey"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LSTATUS RegFlushKey(HKEY hKey)
     * }
     */
    public static FunctionDescriptor RegFlushKey$descriptor() {
        return RegFlushKey.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LSTATUS RegFlushKey(HKEY hKey)
     * }
     */
    public static MethodHandle RegFlushKey$handle() {
        return RegFlushKey.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * LSTATUS RegFlushKey(HKEY hKey)
     * }
     */
    public static int RegFlushKey(MemorySegment hKey) {
        var mh$ = RegFlushKey.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RegFlushKey", hKey);
            }
            return (int)mh$.invokeExact(hKey);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RegGetKeySecurity {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_POINTER,
            C_LONG,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("RegGetKeySecurity"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LSTATUS RegGetKeySecurity(HKEY hKey, SECURITY_INFORMATION SecurityInformation, PSECURITY_DESCRIPTOR pSecurityDescriptor, LPDWORD lpcbSecurityDescriptor)
     * }
     */
    public static FunctionDescriptor RegGetKeySecurity$descriptor() {
        return RegGetKeySecurity.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LSTATUS RegGetKeySecurity(HKEY hKey, SECURITY_INFORMATION SecurityInformation, PSECURITY_DESCRIPTOR pSecurityDescriptor, LPDWORD lpcbSecurityDescriptor)
     * }
     */
    public static MethodHandle RegGetKeySecurity$handle() {
        return RegGetKeySecurity.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * LSTATUS RegGetKeySecurity(HKEY hKey, SECURITY_INFORMATION SecurityInformation, PSECURITY_DESCRIPTOR pSecurityDescriptor, LPDWORD lpcbSecurityDescriptor)
     * }
     */
    public static int RegGetKeySecurity(MemorySegment hKey, int SecurityInformation, MemorySegment pSecurityDescriptor, MemorySegment lpcbSecurityDescriptor) {
        var mh$ = RegGetKeySecurity.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RegGetKeySecurity", hKey, SecurityInformation, pSecurityDescriptor, lpcbSecurityDescriptor);
            }
            return (int)mh$.invokeExact(hKey, SecurityInformation, pSecurityDescriptor, lpcbSecurityDescriptor);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RegLoadKeyA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("RegLoadKeyA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LSTATUS RegLoadKeyA(HKEY hKey, LPCSTR lpSubKey, LPCSTR lpFile)
     * }
     */
    public static FunctionDescriptor RegLoadKeyA$descriptor() {
        return RegLoadKeyA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LSTATUS RegLoadKeyA(HKEY hKey, LPCSTR lpSubKey, LPCSTR lpFile)
     * }
     */
    public static MethodHandle RegLoadKeyA$handle() {
        return RegLoadKeyA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * LSTATUS RegLoadKeyA(HKEY hKey, LPCSTR lpSubKey, LPCSTR lpFile)
     * }
     */
    public static int RegLoadKeyA(MemorySegment hKey, MemorySegment lpSubKey, MemorySegment lpFile) {
        var mh$ = RegLoadKeyA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RegLoadKeyA", hKey, lpSubKey, lpFile);
            }
            return (int)mh$.invokeExact(hKey, lpSubKey, lpFile);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RegLoadKeyW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("RegLoadKeyW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LSTATUS RegLoadKeyW(HKEY hKey, LPCWSTR lpSubKey, LPCWSTR lpFile)
     * }
     */
    public static FunctionDescriptor RegLoadKeyW$descriptor() {
        return RegLoadKeyW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LSTATUS RegLoadKeyW(HKEY hKey, LPCWSTR lpSubKey, LPCWSTR lpFile)
     * }
     */
    public static MethodHandle RegLoadKeyW$handle() {
        return RegLoadKeyW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * LSTATUS RegLoadKeyW(HKEY hKey, LPCWSTR lpSubKey, LPCWSTR lpFile)
     * }
     */
    public static int RegLoadKeyW(MemorySegment hKey, MemorySegment lpSubKey, MemorySegment lpFile) {
        var mh$ = RegLoadKeyW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RegLoadKeyW", hKey, lpSubKey, lpFile);
            }
            return (int)mh$.invokeExact(hKey, lpSubKey, lpFile);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RegNotifyChangeKeyValue {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_POINTER,
            C_INT,
            C_LONG,
            C_POINTER,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("RegNotifyChangeKeyValue"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LSTATUS RegNotifyChangeKeyValue(HKEY hKey, BOOL bWatchSubtree, DWORD dwNotifyFilter, HANDLE hEvent, BOOL fAsynchronous)
     * }
     */
    public static FunctionDescriptor RegNotifyChangeKeyValue$descriptor() {
        return RegNotifyChangeKeyValue.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LSTATUS RegNotifyChangeKeyValue(HKEY hKey, BOOL bWatchSubtree, DWORD dwNotifyFilter, HANDLE hEvent, BOOL fAsynchronous)
     * }
     */
    public static MethodHandle RegNotifyChangeKeyValue$handle() {
        return RegNotifyChangeKeyValue.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * LSTATUS RegNotifyChangeKeyValue(HKEY hKey, BOOL bWatchSubtree, DWORD dwNotifyFilter, HANDLE hEvent, BOOL fAsynchronous)
     * }
     */
    public static int RegNotifyChangeKeyValue(MemorySegment hKey, int bWatchSubtree, int dwNotifyFilter, MemorySegment hEvent, int fAsynchronous) {
        var mh$ = RegNotifyChangeKeyValue.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RegNotifyChangeKeyValue", hKey, bWatchSubtree, dwNotifyFilter, hEvent, fAsynchronous);
            }
            return (int)mh$.invokeExact(hKey, bWatchSubtree, dwNotifyFilter, hEvent, fAsynchronous);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RegOpenKeyA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("RegOpenKeyA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LSTATUS RegOpenKeyA(HKEY hKey, LPCSTR lpSubKey, PHKEY phkResult)
     * }
     */
    public static FunctionDescriptor RegOpenKeyA$descriptor() {
        return RegOpenKeyA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LSTATUS RegOpenKeyA(HKEY hKey, LPCSTR lpSubKey, PHKEY phkResult)
     * }
     */
    public static MethodHandle RegOpenKeyA$handle() {
        return RegOpenKeyA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * LSTATUS RegOpenKeyA(HKEY hKey, LPCSTR lpSubKey, PHKEY phkResult)
     * }
     */
    public static int RegOpenKeyA(MemorySegment hKey, MemorySegment lpSubKey, MemorySegment phkResult) {
        var mh$ = RegOpenKeyA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RegOpenKeyA", hKey, lpSubKey, phkResult);
            }
            return (int)mh$.invokeExact(hKey, lpSubKey, phkResult);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RegOpenKeyW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("RegOpenKeyW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LSTATUS RegOpenKeyW(HKEY hKey, LPCWSTR lpSubKey, PHKEY phkResult)
     * }
     */
    public static FunctionDescriptor RegOpenKeyW$descriptor() {
        return RegOpenKeyW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LSTATUS RegOpenKeyW(HKEY hKey, LPCWSTR lpSubKey, PHKEY phkResult)
     * }
     */
    public static MethodHandle RegOpenKeyW$handle() {
        return RegOpenKeyW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * LSTATUS RegOpenKeyW(HKEY hKey, LPCWSTR lpSubKey, PHKEY phkResult)
     * }
     */
    public static int RegOpenKeyW(MemorySegment hKey, MemorySegment lpSubKey, MemorySegment phkResult) {
        var mh$ = RegOpenKeyW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RegOpenKeyW", hKey, lpSubKey, phkResult);
            }
            return (int)mh$.invokeExact(hKey, lpSubKey, phkResult);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RegOpenKeyExA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_POINTER,
            C_POINTER,
            C_LONG,
            C_LONG,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("RegOpenKeyExA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LSTATUS RegOpenKeyExA(HKEY hKey, LPCSTR lpSubKey, DWORD ulOptions, REGSAM samDesired, PHKEY phkResult)
     * }
     */
    public static FunctionDescriptor RegOpenKeyExA$descriptor() {
        return RegOpenKeyExA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LSTATUS RegOpenKeyExA(HKEY hKey, LPCSTR lpSubKey, DWORD ulOptions, REGSAM samDesired, PHKEY phkResult)
     * }
     */
    public static MethodHandle RegOpenKeyExA$handle() {
        return RegOpenKeyExA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * LSTATUS RegOpenKeyExA(HKEY hKey, LPCSTR lpSubKey, DWORD ulOptions, REGSAM samDesired, PHKEY phkResult)
     * }
     */
    public static int RegOpenKeyExA(MemorySegment hKey, MemorySegment lpSubKey, int ulOptions, int samDesired, MemorySegment phkResult) {
        var mh$ = RegOpenKeyExA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RegOpenKeyExA", hKey, lpSubKey, ulOptions, samDesired, phkResult);
            }
            return (int)mh$.invokeExact(hKey, lpSubKey, ulOptions, samDesired, phkResult);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RegOpenKeyExW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_POINTER,
            C_POINTER,
            C_LONG,
            C_LONG,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("RegOpenKeyExW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LSTATUS RegOpenKeyExW(HKEY hKey, LPCWSTR lpSubKey, DWORD ulOptions, REGSAM samDesired, PHKEY phkResult)
     * }
     */
    public static FunctionDescriptor RegOpenKeyExW$descriptor() {
        return RegOpenKeyExW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LSTATUS RegOpenKeyExW(HKEY hKey, LPCWSTR lpSubKey, DWORD ulOptions, REGSAM samDesired, PHKEY phkResult)
     * }
     */
    public static MethodHandle RegOpenKeyExW$handle() {
        return RegOpenKeyExW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * LSTATUS RegOpenKeyExW(HKEY hKey, LPCWSTR lpSubKey, DWORD ulOptions, REGSAM samDesired, PHKEY phkResult)
     * }
     */
    public static int RegOpenKeyExW(MemorySegment hKey, MemorySegment lpSubKey, int ulOptions, int samDesired, MemorySegment phkResult) {
        var mh$ = RegOpenKeyExW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RegOpenKeyExW", hKey, lpSubKey, ulOptions, samDesired, phkResult);
            }
            return (int)mh$.invokeExact(hKey, lpSubKey, ulOptions, samDesired, phkResult);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RegOpenKeyTransactedA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_POINTER,
            C_POINTER,
            C_LONG,
            C_LONG,
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("RegOpenKeyTransactedA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LSTATUS RegOpenKeyTransactedA(HKEY hKey, LPCSTR lpSubKey, DWORD ulOptions, REGSAM samDesired, PHKEY phkResult, HANDLE hTransaction, PVOID pExtendedParemeter)
     * }
     */
    public static FunctionDescriptor RegOpenKeyTransactedA$descriptor() {
        return RegOpenKeyTransactedA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LSTATUS RegOpenKeyTransactedA(HKEY hKey, LPCSTR lpSubKey, DWORD ulOptions, REGSAM samDesired, PHKEY phkResult, HANDLE hTransaction, PVOID pExtendedParemeter)
     * }
     */
    public static MethodHandle RegOpenKeyTransactedA$handle() {
        return RegOpenKeyTransactedA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * LSTATUS RegOpenKeyTransactedA(HKEY hKey, LPCSTR lpSubKey, DWORD ulOptions, REGSAM samDesired, PHKEY phkResult, HANDLE hTransaction, PVOID pExtendedParemeter)
     * }
     */
    public static int RegOpenKeyTransactedA(MemorySegment hKey, MemorySegment lpSubKey, int ulOptions, int samDesired, MemorySegment phkResult, MemorySegment hTransaction, MemorySegment pExtendedParemeter) {
        var mh$ = RegOpenKeyTransactedA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RegOpenKeyTransactedA", hKey, lpSubKey, ulOptions, samDesired, phkResult, hTransaction, pExtendedParemeter);
            }
            return (int)mh$.invokeExact(hKey, lpSubKey, ulOptions, samDesired, phkResult, hTransaction, pExtendedParemeter);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RegOpenKeyTransactedW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_POINTER,
            C_POINTER,
            C_LONG,
            C_LONG,
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("RegOpenKeyTransactedW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LSTATUS RegOpenKeyTransactedW(HKEY hKey, LPCWSTR lpSubKey, DWORD ulOptions, REGSAM samDesired, PHKEY phkResult, HANDLE hTransaction, PVOID pExtendedParemeter)
     * }
     */
    public static FunctionDescriptor RegOpenKeyTransactedW$descriptor() {
        return RegOpenKeyTransactedW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LSTATUS RegOpenKeyTransactedW(HKEY hKey, LPCWSTR lpSubKey, DWORD ulOptions, REGSAM samDesired, PHKEY phkResult, HANDLE hTransaction, PVOID pExtendedParemeter)
     * }
     */
    public static MethodHandle RegOpenKeyTransactedW$handle() {
        return RegOpenKeyTransactedW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * LSTATUS RegOpenKeyTransactedW(HKEY hKey, LPCWSTR lpSubKey, DWORD ulOptions, REGSAM samDesired, PHKEY phkResult, HANDLE hTransaction, PVOID pExtendedParemeter)
     * }
     */
    public static int RegOpenKeyTransactedW(MemorySegment hKey, MemorySegment lpSubKey, int ulOptions, int samDesired, MemorySegment phkResult, MemorySegment hTransaction, MemorySegment pExtendedParemeter) {
        var mh$ = RegOpenKeyTransactedW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RegOpenKeyTransactedW", hKey, lpSubKey, ulOptions, samDesired, phkResult, hTransaction, pExtendedParemeter);
            }
            return (int)mh$.invokeExact(hKey, lpSubKey, ulOptions, samDesired, phkResult, hTransaction, pExtendedParemeter);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RegQueryInfoKeyA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("RegQueryInfoKeyA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LSTATUS RegQueryInfoKeyA(HKEY hKey, LPSTR lpClass, LPDWORD lpcchClass, LPDWORD lpReserved, LPDWORD lpcSubKeys, LPDWORD lpcbMaxSubKeyLen, LPDWORD lpcbMaxClassLen, LPDWORD lpcValues, LPDWORD lpcbMaxValueNameLen, LPDWORD lpcbMaxValueLen, LPDWORD lpcbSecurityDescriptor, PFILETIME lpftLastWriteTime)
     * }
     */
    public static FunctionDescriptor RegQueryInfoKeyA$descriptor() {
        return RegQueryInfoKeyA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LSTATUS RegQueryInfoKeyA(HKEY hKey, LPSTR lpClass, LPDWORD lpcchClass, LPDWORD lpReserved, LPDWORD lpcSubKeys, LPDWORD lpcbMaxSubKeyLen, LPDWORD lpcbMaxClassLen, LPDWORD lpcValues, LPDWORD lpcbMaxValueNameLen, LPDWORD lpcbMaxValueLen, LPDWORD lpcbSecurityDescriptor, PFILETIME lpftLastWriteTime)
     * }
     */
    public static MethodHandle RegQueryInfoKeyA$handle() {
        return RegQueryInfoKeyA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * LSTATUS RegQueryInfoKeyA(HKEY hKey, LPSTR lpClass, LPDWORD lpcchClass, LPDWORD lpReserved, LPDWORD lpcSubKeys, LPDWORD lpcbMaxSubKeyLen, LPDWORD lpcbMaxClassLen, LPDWORD lpcValues, LPDWORD lpcbMaxValueNameLen, LPDWORD lpcbMaxValueLen, LPDWORD lpcbSecurityDescriptor, PFILETIME lpftLastWriteTime)
     * }
     */
    public static int RegQueryInfoKeyA(MemorySegment hKey, MemorySegment lpClass, MemorySegment lpcchClass, MemorySegment lpReserved, MemorySegment lpcSubKeys, MemorySegment lpcbMaxSubKeyLen, MemorySegment lpcbMaxClassLen, MemorySegment lpcValues, MemorySegment lpcbMaxValueNameLen, MemorySegment lpcbMaxValueLen, MemorySegment lpcbSecurityDescriptor, MemorySegment lpftLastWriteTime) {
        var mh$ = RegQueryInfoKeyA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RegQueryInfoKeyA", hKey, lpClass, lpcchClass, lpReserved, lpcSubKeys, lpcbMaxSubKeyLen, lpcbMaxClassLen, lpcValues, lpcbMaxValueNameLen, lpcbMaxValueLen, lpcbSecurityDescriptor, lpftLastWriteTime);
            }
            return (int)mh$.invokeExact(hKey, lpClass, lpcchClass, lpReserved, lpcSubKeys, lpcbMaxSubKeyLen, lpcbMaxClassLen, lpcValues, lpcbMaxValueNameLen, lpcbMaxValueLen, lpcbSecurityDescriptor, lpftLastWriteTime);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RegQueryInfoKeyW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("RegQueryInfoKeyW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LSTATUS RegQueryInfoKeyW(HKEY hKey, LPWSTR lpClass, LPDWORD lpcchClass, LPDWORD lpReserved, LPDWORD lpcSubKeys, LPDWORD lpcbMaxSubKeyLen, LPDWORD lpcbMaxClassLen, LPDWORD lpcValues, LPDWORD lpcbMaxValueNameLen, LPDWORD lpcbMaxValueLen, LPDWORD lpcbSecurityDescriptor, PFILETIME lpftLastWriteTime)
     * }
     */
    public static FunctionDescriptor RegQueryInfoKeyW$descriptor() {
        return RegQueryInfoKeyW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LSTATUS RegQueryInfoKeyW(HKEY hKey, LPWSTR lpClass, LPDWORD lpcchClass, LPDWORD lpReserved, LPDWORD lpcSubKeys, LPDWORD lpcbMaxSubKeyLen, LPDWORD lpcbMaxClassLen, LPDWORD lpcValues, LPDWORD lpcbMaxValueNameLen, LPDWORD lpcbMaxValueLen, LPDWORD lpcbSecurityDescriptor, PFILETIME lpftLastWriteTime)
     * }
     */
    public static MethodHandle RegQueryInfoKeyW$handle() {
        return RegQueryInfoKeyW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * LSTATUS RegQueryInfoKeyW(HKEY hKey, LPWSTR lpClass, LPDWORD lpcchClass, LPDWORD lpReserved, LPDWORD lpcSubKeys, LPDWORD lpcbMaxSubKeyLen, LPDWORD lpcbMaxClassLen, LPDWORD lpcValues, LPDWORD lpcbMaxValueNameLen, LPDWORD lpcbMaxValueLen, LPDWORD lpcbSecurityDescriptor, PFILETIME lpftLastWriteTime)
     * }
     */
    public static int RegQueryInfoKeyW(MemorySegment hKey, MemorySegment lpClass, MemorySegment lpcchClass, MemorySegment lpReserved, MemorySegment lpcSubKeys, MemorySegment lpcbMaxSubKeyLen, MemorySegment lpcbMaxClassLen, MemorySegment lpcValues, MemorySegment lpcbMaxValueNameLen, MemorySegment lpcbMaxValueLen, MemorySegment lpcbSecurityDescriptor, MemorySegment lpftLastWriteTime) {
        var mh$ = RegQueryInfoKeyW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RegQueryInfoKeyW", hKey, lpClass, lpcchClass, lpReserved, lpcSubKeys, lpcbMaxSubKeyLen, lpcbMaxClassLen, lpcValues, lpcbMaxValueNameLen, lpcbMaxValueLen, lpcbSecurityDescriptor, lpftLastWriteTime);
            }
            return (int)mh$.invokeExact(hKey, lpClass, lpcchClass, lpReserved, lpcSubKeys, lpcbMaxSubKeyLen, lpcbMaxClassLen, lpcValues, lpcbMaxValueNameLen, lpcbMaxValueLen, lpcbSecurityDescriptor, lpftLastWriteTime);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RegQueryValueA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("RegQueryValueA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LSTATUS RegQueryValueA(HKEY hKey, LPCSTR lpSubKey, LPSTR lpData, PLONG lpcbData)
     * }
     */
    public static FunctionDescriptor RegQueryValueA$descriptor() {
        return RegQueryValueA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LSTATUS RegQueryValueA(HKEY hKey, LPCSTR lpSubKey, LPSTR lpData, PLONG lpcbData)
     * }
     */
    public static MethodHandle RegQueryValueA$handle() {
        return RegQueryValueA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * LSTATUS RegQueryValueA(HKEY hKey, LPCSTR lpSubKey, LPSTR lpData, PLONG lpcbData)
     * }
     */
    public static int RegQueryValueA(MemorySegment hKey, MemorySegment lpSubKey, MemorySegment lpData, MemorySegment lpcbData) {
        var mh$ = RegQueryValueA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RegQueryValueA", hKey, lpSubKey, lpData, lpcbData);
            }
            return (int)mh$.invokeExact(hKey, lpSubKey, lpData, lpcbData);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RegQueryValueW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("RegQueryValueW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LSTATUS RegQueryValueW(HKEY hKey, LPCWSTR lpSubKey, LPWSTR lpData, PLONG lpcbData)
     * }
     */
    public static FunctionDescriptor RegQueryValueW$descriptor() {
        return RegQueryValueW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LSTATUS RegQueryValueW(HKEY hKey, LPCWSTR lpSubKey, LPWSTR lpData, PLONG lpcbData)
     * }
     */
    public static MethodHandle RegQueryValueW$handle() {
        return RegQueryValueW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * LSTATUS RegQueryValueW(HKEY hKey, LPCWSTR lpSubKey, LPWSTR lpData, PLONG lpcbData)
     * }
     */
    public static int RegQueryValueW(MemorySegment hKey, MemorySegment lpSubKey, MemorySegment lpData, MemorySegment lpcbData) {
        var mh$ = RegQueryValueW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RegQueryValueW", hKey, lpSubKey, lpData, lpcbData);
            }
            return (int)mh$.invokeExact(hKey, lpSubKey, lpData, lpcbData);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RegQueryMultipleValuesA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_POINTER,
            C_POINTER,
            C_LONG,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("RegQueryMultipleValuesA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LSTATUS RegQueryMultipleValuesA(HKEY hKey, PVALENTA val_list, DWORD num_vals, LPSTR lpValueBuf, LPDWORD ldwTotsize)
     * }
     */
    public static FunctionDescriptor RegQueryMultipleValuesA$descriptor() {
        return RegQueryMultipleValuesA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LSTATUS RegQueryMultipleValuesA(HKEY hKey, PVALENTA val_list, DWORD num_vals, LPSTR lpValueBuf, LPDWORD ldwTotsize)
     * }
     */
    public static MethodHandle RegQueryMultipleValuesA$handle() {
        return RegQueryMultipleValuesA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * LSTATUS RegQueryMultipleValuesA(HKEY hKey, PVALENTA val_list, DWORD num_vals, LPSTR lpValueBuf, LPDWORD ldwTotsize)
     * }
     */
    public static int RegQueryMultipleValuesA(MemorySegment hKey, MemorySegment val_list, int num_vals, MemorySegment lpValueBuf, MemorySegment ldwTotsize) {
        var mh$ = RegQueryMultipleValuesA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RegQueryMultipleValuesA", hKey, val_list, num_vals, lpValueBuf, ldwTotsize);
            }
            return (int)mh$.invokeExact(hKey, val_list, num_vals, lpValueBuf, ldwTotsize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RegQueryMultipleValuesW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_POINTER,
            C_POINTER,
            C_LONG,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("RegQueryMultipleValuesW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LSTATUS RegQueryMultipleValuesW(HKEY hKey, PVALENTW val_list, DWORD num_vals, LPWSTR lpValueBuf, LPDWORD ldwTotsize)
     * }
     */
    public static FunctionDescriptor RegQueryMultipleValuesW$descriptor() {
        return RegQueryMultipleValuesW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LSTATUS RegQueryMultipleValuesW(HKEY hKey, PVALENTW val_list, DWORD num_vals, LPWSTR lpValueBuf, LPDWORD ldwTotsize)
     * }
     */
    public static MethodHandle RegQueryMultipleValuesW$handle() {
        return RegQueryMultipleValuesW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * LSTATUS RegQueryMultipleValuesW(HKEY hKey, PVALENTW val_list, DWORD num_vals, LPWSTR lpValueBuf, LPDWORD ldwTotsize)
     * }
     */
    public static int RegQueryMultipleValuesW(MemorySegment hKey, MemorySegment val_list, int num_vals, MemorySegment lpValueBuf, MemorySegment ldwTotsize) {
        var mh$ = RegQueryMultipleValuesW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RegQueryMultipleValuesW", hKey, val_list, num_vals, lpValueBuf, ldwTotsize);
            }
            return (int)mh$.invokeExact(hKey, val_list, num_vals, lpValueBuf, ldwTotsize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RegQueryValueExA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("RegQueryValueExA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LSTATUS RegQueryValueExA(HKEY hKey, LPCSTR lpValueName, LPDWORD lpReserved, LPDWORD lpType, LPBYTE lpData, LPDWORD lpcbData)
     * }
     */
    public static FunctionDescriptor RegQueryValueExA$descriptor() {
        return RegQueryValueExA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LSTATUS RegQueryValueExA(HKEY hKey, LPCSTR lpValueName, LPDWORD lpReserved, LPDWORD lpType, LPBYTE lpData, LPDWORD lpcbData)
     * }
     */
    public static MethodHandle RegQueryValueExA$handle() {
        return RegQueryValueExA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * LSTATUS RegQueryValueExA(HKEY hKey, LPCSTR lpValueName, LPDWORD lpReserved, LPDWORD lpType, LPBYTE lpData, LPDWORD lpcbData)
     * }
     */
    public static int RegQueryValueExA(MemorySegment hKey, MemorySegment lpValueName, MemorySegment lpReserved, MemorySegment lpType, MemorySegment lpData, MemorySegment lpcbData) {
        var mh$ = RegQueryValueExA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RegQueryValueExA", hKey, lpValueName, lpReserved, lpType, lpData, lpcbData);
            }
            return (int)mh$.invokeExact(hKey, lpValueName, lpReserved, lpType, lpData, lpcbData);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RegQueryValueExW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("RegQueryValueExW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LSTATUS RegQueryValueExW(HKEY hKey, LPCWSTR lpValueName, LPDWORD lpReserved, LPDWORD lpType, LPBYTE lpData, LPDWORD lpcbData)
     * }
     */
    public static FunctionDescriptor RegQueryValueExW$descriptor() {
        return RegQueryValueExW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LSTATUS RegQueryValueExW(HKEY hKey, LPCWSTR lpValueName, LPDWORD lpReserved, LPDWORD lpType, LPBYTE lpData, LPDWORD lpcbData)
     * }
     */
    public static MethodHandle RegQueryValueExW$handle() {
        return RegQueryValueExW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * LSTATUS RegQueryValueExW(HKEY hKey, LPCWSTR lpValueName, LPDWORD lpReserved, LPDWORD lpType, LPBYTE lpData, LPDWORD lpcbData)
     * }
     */
    public static int RegQueryValueExW(MemorySegment hKey, MemorySegment lpValueName, MemorySegment lpReserved, MemorySegment lpType, MemorySegment lpData, MemorySegment lpcbData) {
        var mh$ = RegQueryValueExW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RegQueryValueExW", hKey, lpValueName, lpReserved, lpType, lpData, lpcbData);
            }
            return (int)mh$.invokeExact(hKey, lpValueName, lpReserved, lpType, lpData, lpcbData);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RegReplaceKeyA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("RegReplaceKeyA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LSTATUS RegReplaceKeyA(HKEY hKey, LPCSTR lpSubKey, LPCSTR lpNewFile, LPCSTR lpOldFile)
     * }
     */
    public static FunctionDescriptor RegReplaceKeyA$descriptor() {
        return RegReplaceKeyA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LSTATUS RegReplaceKeyA(HKEY hKey, LPCSTR lpSubKey, LPCSTR lpNewFile, LPCSTR lpOldFile)
     * }
     */
    public static MethodHandle RegReplaceKeyA$handle() {
        return RegReplaceKeyA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * LSTATUS RegReplaceKeyA(HKEY hKey, LPCSTR lpSubKey, LPCSTR lpNewFile, LPCSTR lpOldFile)
     * }
     */
    public static int RegReplaceKeyA(MemorySegment hKey, MemorySegment lpSubKey, MemorySegment lpNewFile, MemorySegment lpOldFile) {
        var mh$ = RegReplaceKeyA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RegReplaceKeyA", hKey, lpSubKey, lpNewFile, lpOldFile);
            }
            return (int)mh$.invokeExact(hKey, lpSubKey, lpNewFile, lpOldFile);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RegReplaceKeyW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("RegReplaceKeyW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LSTATUS RegReplaceKeyW(HKEY hKey, LPCWSTR lpSubKey, LPCWSTR lpNewFile, LPCWSTR lpOldFile)
     * }
     */
    public static FunctionDescriptor RegReplaceKeyW$descriptor() {
        return RegReplaceKeyW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LSTATUS RegReplaceKeyW(HKEY hKey, LPCWSTR lpSubKey, LPCWSTR lpNewFile, LPCWSTR lpOldFile)
     * }
     */
    public static MethodHandle RegReplaceKeyW$handle() {
        return RegReplaceKeyW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * LSTATUS RegReplaceKeyW(HKEY hKey, LPCWSTR lpSubKey, LPCWSTR lpNewFile, LPCWSTR lpOldFile)
     * }
     */
    public static int RegReplaceKeyW(MemorySegment hKey, MemorySegment lpSubKey, MemorySegment lpNewFile, MemorySegment lpOldFile) {
        var mh$ = RegReplaceKeyW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RegReplaceKeyW", hKey, lpSubKey, lpNewFile, lpOldFile);
            }
            return (int)mh$.invokeExact(hKey, lpSubKey, lpNewFile, lpOldFile);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RegRestoreKeyA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_POINTER,
            C_POINTER,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("RegRestoreKeyA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LSTATUS RegRestoreKeyA(HKEY hKey, LPCSTR lpFile, DWORD dwFlags)
     * }
     */
    public static FunctionDescriptor RegRestoreKeyA$descriptor() {
        return RegRestoreKeyA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LSTATUS RegRestoreKeyA(HKEY hKey, LPCSTR lpFile, DWORD dwFlags)
     * }
     */
    public static MethodHandle RegRestoreKeyA$handle() {
        return RegRestoreKeyA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * LSTATUS RegRestoreKeyA(HKEY hKey, LPCSTR lpFile, DWORD dwFlags)
     * }
     */
    public static int RegRestoreKeyA(MemorySegment hKey, MemorySegment lpFile, int dwFlags) {
        var mh$ = RegRestoreKeyA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RegRestoreKeyA", hKey, lpFile, dwFlags);
            }
            return (int)mh$.invokeExact(hKey, lpFile, dwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RegRestoreKeyW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_POINTER,
            C_POINTER,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("RegRestoreKeyW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LSTATUS RegRestoreKeyW(HKEY hKey, LPCWSTR lpFile, DWORD dwFlags)
     * }
     */
    public static FunctionDescriptor RegRestoreKeyW$descriptor() {
        return RegRestoreKeyW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LSTATUS RegRestoreKeyW(HKEY hKey, LPCWSTR lpFile, DWORD dwFlags)
     * }
     */
    public static MethodHandle RegRestoreKeyW$handle() {
        return RegRestoreKeyW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * LSTATUS RegRestoreKeyW(HKEY hKey, LPCWSTR lpFile, DWORD dwFlags)
     * }
     */
    public static int RegRestoreKeyW(MemorySegment hKey, MemorySegment lpFile, int dwFlags) {
        var mh$ = RegRestoreKeyW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RegRestoreKeyW", hKey, lpFile, dwFlags);
            }
            return (int)mh$.invokeExact(hKey, lpFile, dwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RegRenameKey {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("RegRenameKey"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LSTATUS RegRenameKey(HKEY hKey, LPCWSTR lpSubKeyName, LPCWSTR lpNewKeyName)
     * }
     */
    public static FunctionDescriptor RegRenameKey$descriptor() {
        return RegRenameKey.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LSTATUS RegRenameKey(HKEY hKey, LPCWSTR lpSubKeyName, LPCWSTR lpNewKeyName)
     * }
     */
    public static MethodHandle RegRenameKey$handle() {
        return RegRenameKey.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * LSTATUS RegRenameKey(HKEY hKey, LPCWSTR lpSubKeyName, LPCWSTR lpNewKeyName)
     * }
     */
    public static int RegRenameKey(MemorySegment hKey, MemorySegment lpSubKeyName, MemorySegment lpNewKeyName) {
        var mh$ = RegRenameKey.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RegRenameKey", hKey, lpSubKeyName, lpNewKeyName);
            }
            return (int)mh$.invokeExact(hKey, lpSubKeyName, lpNewKeyName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RegSaveKeyA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("RegSaveKeyA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LSTATUS RegSaveKeyA(HKEY hKey, LPCSTR lpFile, const LPSECURITY_ATTRIBUTES lpSecurityAttributes)
     * }
     */
    public static FunctionDescriptor RegSaveKeyA$descriptor() {
        return RegSaveKeyA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LSTATUS RegSaveKeyA(HKEY hKey, LPCSTR lpFile, const LPSECURITY_ATTRIBUTES lpSecurityAttributes)
     * }
     */
    public static MethodHandle RegSaveKeyA$handle() {
        return RegSaveKeyA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * LSTATUS RegSaveKeyA(HKEY hKey, LPCSTR lpFile, const LPSECURITY_ATTRIBUTES lpSecurityAttributes)
     * }
     */
    public static int RegSaveKeyA(MemorySegment hKey, MemorySegment lpFile, MemorySegment lpSecurityAttributes) {
        var mh$ = RegSaveKeyA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RegSaveKeyA", hKey, lpFile, lpSecurityAttributes);
            }
            return (int)mh$.invokeExact(hKey, lpFile, lpSecurityAttributes);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RegSaveKeyW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("RegSaveKeyW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LSTATUS RegSaveKeyW(HKEY hKey, LPCWSTR lpFile, const LPSECURITY_ATTRIBUTES lpSecurityAttributes)
     * }
     */
    public static FunctionDescriptor RegSaveKeyW$descriptor() {
        return RegSaveKeyW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LSTATUS RegSaveKeyW(HKEY hKey, LPCWSTR lpFile, const LPSECURITY_ATTRIBUTES lpSecurityAttributes)
     * }
     */
    public static MethodHandle RegSaveKeyW$handle() {
        return RegSaveKeyW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * LSTATUS RegSaveKeyW(HKEY hKey, LPCWSTR lpFile, const LPSECURITY_ATTRIBUTES lpSecurityAttributes)
     * }
     */
    public static int RegSaveKeyW(MemorySegment hKey, MemorySegment lpFile, MemorySegment lpSecurityAttributes) {
        var mh$ = RegSaveKeyW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RegSaveKeyW", hKey, lpFile, lpSecurityAttributes);
            }
            return (int)mh$.invokeExact(hKey, lpFile, lpSecurityAttributes);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RegSetKeySecurity {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_POINTER,
            C_LONG,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("RegSetKeySecurity"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LSTATUS RegSetKeySecurity(HKEY hKey, SECURITY_INFORMATION SecurityInformation, PSECURITY_DESCRIPTOR pSecurityDescriptor)
     * }
     */
    public static FunctionDescriptor RegSetKeySecurity$descriptor() {
        return RegSetKeySecurity.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LSTATUS RegSetKeySecurity(HKEY hKey, SECURITY_INFORMATION SecurityInformation, PSECURITY_DESCRIPTOR pSecurityDescriptor)
     * }
     */
    public static MethodHandle RegSetKeySecurity$handle() {
        return RegSetKeySecurity.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * LSTATUS RegSetKeySecurity(HKEY hKey, SECURITY_INFORMATION SecurityInformation, PSECURITY_DESCRIPTOR pSecurityDescriptor)
     * }
     */
    public static int RegSetKeySecurity(MemorySegment hKey, int SecurityInformation, MemorySegment pSecurityDescriptor) {
        var mh$ = RegSetKeySecurity.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RegSetKeySecurity", hKey, SecurityInformation, pSecurityDescriptor);
            }
            return (int)mh$.invokeExact(hKey, SecurityInformation, pSecurityDescriptor);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RegSetValueA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_POINTER,
            C_POINTER,
            C_LONG,
            C_POINTER,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("RegSetValueA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LSTATUS RegSetValueA(HKEY hKey, LPCSTR lpSubKey, DWORD dwType, LPCSTR lpData, DWORD cbData)
     * }
     */
    public static FunctionDescriptor RegSetValueA$descriptor() {
        return RegSetValueA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LSTATUS RegSetValueA(HKEY hKey, LPCSTR lpSubKey, DWORD dwType, LPCSTR lpData, DWORD cbData)
     * }
     */
    public static MethodHandle RegSetValueA$handle() {
        return RegSetValueA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * LSTATUS RegSetValueA(HKEY hKey, LPCSTR lpSubKey, DWORD dwType, LPCSTR lpData, DWORD cbData)
     * }
     */
    public static int RegSetValueA(MemorySegment hKey, MemorySegment lpSubKey, int dwType, MemorySegment lpData, int cbData) {
        var mh$ = RegSetValueA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RegSetValueA", hKey, lpSubKey, dwType, lpData, cbData);
            }
            return (int)mh$.invokeExact(hKey, lpSubKey, dwType, lpData, cbData);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RegSetValueW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_POINTER,
            C_POINTER,
            C_LONG,
            C_POINTER,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("RegSetValueW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LSTATUS RegSetValueW(HKEY hKey, LPCWSTR lpSubKey, DWORD dwType, LPCWSTR lpData, DWORD cbData)
     * }
     */
    public static FunctionDescriptor RegSetValueW$descriptor() {
        return RegSetValueW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LSTATUS RegSetValueW(HKEY hKey, LPCWSTR lpSubKey, DWORD dwType, LPCWSTR lpData, DWORD cbData)
     * }
     */
    public static MethodHandle RegSetValueW$handle() {
        return RegSetValueW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * LSTATUS RegSetValueW(HKEY hKey, LPCWSTR lpSubKey, DWORD dwType, LPCWSTR lpData, DWORD cbData)
     * }
     */
    public static int RegSetValueW(MemorySegment hKey, MemorySegment lpSubKey, int dwType, MemorySegment lpData, int cbData) {
        var mh$ = RegSetValueW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RegSetValueW", hKey, lpSubKey, dwType, lpData, cbData);
            }
            return (int)mh$.invokeExact(hKey, lpSubKey, dwType, lpData, cbData);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RegSetValueExA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_POINTER,
            C_POINTER,
            C_LONG,
            C_LONG,
            C_POINTER,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("RegSetValueExA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LSTATUS RegSetValueExA(HKEY hKey, LPCSTR lpValueName, DWORD Reserved, DWORD dwType, const BYTE *lpData, DWORD cbData)
     * }
     */
    public static FunctionDescriptor RegSetValueExA$descriptor() {
        return RegSetValueExA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LSTATUS RegSetValueExA(HKEY hKey, LPCSTR lpValueName, DWORD Reserved, DWORD dwType, const BYTE *lpData, DWORD cbData)
     * }
     */
    public static MethodHandle RegSetValueExA$handle() {
        return RegSetValueExA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * LSTATUS RegSetValueExA(HKEY hKey, LPCSTR lpValueName, DWORD Reserved, DWORD dwType, const BYTE *lpData, DWORD cbData)
     * }
     */
    public static int RegSetValueExA(MemorySegment hKey, MemorySegment lpValueName, int Reserved, int dwType, MemorySegment lpData, int cbData) {
        var mh$ = RegSetValueExA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RegSetValueExA", hKey, lpValueName, Reserved, dwType, lpData, cbData);
            }
            return (int)mh$.invokeExact(hKey, lpValueName, Reserved, dwType, lpData, cbData);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RegSetValueExW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_POINTER,
            C_POINTER,
            C_LONG,
            C_LONG,
            C_POINTER,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("RegSetValueExW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LSTATUS RegSetValueExW(HKEY hKey, LPCWSTR lpValueName, DWORD Reserved, DWORD dwType, const BYTE *lpData, DWORD cbData)
     * }
     */
    public static FunctionDescriptor RegSetValueExW$descriptor() {
        return RegSetValueExW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LSTATUS RegSetValueExW(HKEY hKey, LPCWSTR lpValueName, DWORD Reserved, DWORD dwType, const BYTE *lpData, DWORD cbData)
     * }
     */
    public static MethodHandle RegSetValueExW$handle() {
        return RegSetValueExW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * LSTATUS RegSetValueExW(HKEY hKey, LPCWSTR lpValueName, DWORD Reserved, DWORD dwType, const BYTE *lpData, DWORD cbData)
     * }
     */
    public static int RegSetValueExW(MemorySegment hKey, MemorySegment lpValueName, int Reserved, int dwType, MemorySegment lpData, int cbData) {
        var mh$ = RegSetValueExW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RegSetValueExW", hKey, lpValueName, Reserved, dwType, lpData, cbData);
            }
            return (int)mh$.invokeExact(hKey, lpValueName, Reserved, dwType, lpData, cbData);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RegUnLoadKeyA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("RegUnLoadKeyA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LSTATUS RegUnLoadKeyA(HKEY hKey, LPCSTR lpSubKey)
     * }
     */
    public static FunctionDescriptor RegUnLoadKeyA$descriptor() {
        return RegUnLoadKeyA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LSTATUS RegUnLoadKeyA(HKEY hKey, LPCSTR lpSubKey)
     * }
     */
    public static MethodHandle RegUnLoadKeyA$handle() {
        return RegUnLoadKeyA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * LSTATUS RegUnLoadKeyA(HKEY hKey, LPCSTR lpSubKey)
     * }
     */
    public static int RegUnLoadKeyA(MemorySegment hKey, MemorySegment lpSubKey) {
        var mh$ = RegUnLoadKeyA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RegUnLoadKeyA", hKey, lpSubKey);
            }
            return (int)mh$.invokeExact(hKey, lpSubKey);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RegUnLoadKeyW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("RegUnLoadKeyW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LSTATUS RegUnLoadKeyW(HKEY hKey, LPCWSTR lpSubKey)
     * }
     */
    public static FunctionDescriptor RegUnLoadKeyW$descriptor() {
        return RegUnLoadKeyW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LSTATUS RegUnLoadKeyW(HKEY hKey, LPCWSTR lpSubKey)
     * }
     */
    public static MethodHandle RegUnLoadKeyW$handle() {
        return RegUnLoadKeyW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * LSTATUS RegUnLoadKeyW(HKEY hKey, LPCWSTR lpSubKey)
     * }
     */
    public static int RegUnLoadKeyW(MemorySegment hKey, MemorySegment lpSubKey) {
        var mh$ = RegUnLoadKeyW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RegUnLoadKeyW", hKey, lpSubKey);
            }
            return (int)mh$.invokeExact(hKey, lpSubKey);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RegDeleteKeyValueA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("RegDeleteKeyValueA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LSTATUS RegDeleteKeyValueA(HKEY hKey, LPCSTR lpSubKey, LPCSTR lpValueName)
     * }
     */
    public static FunctionDescriptor RegDeleteKeyValueA$descriptor() {
        return RegDeleteKeyValueA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LSTATUS RegDeleteKeyValueA(HKEY hKey, LPCSTR lpSubKey, LPCSTR lpValueName)
     * }
     */
    public static MethodHandle RegDeleteKeyValueA$handle() {
        return RegDeleteKeyValueA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * LSTATUS RegDeleteKeyValueA(HKEY hKey, LPCSTR lpSubKey, LPCSTR lpValueName)
     * }
     */
    public static int RegDeleteKeyValueA(MemorySegment hKey, MemorySegment lpSubKey, MemorySegment lpValueName) {
        var mh$ = RegDeleteKeyValueA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RegDeleteKeyValueA", hKey, lpSubKey, lpValueName);
            }
            return (int)mh$.invokeExact(hKey, lpSubKey, lpValueName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RegDeleteKeyValueW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("RegDeleteKeyValueW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LSTATUS RegDeleteKeyValueW(HKEY hKey, LPCWSTR lpSubKey, LPCWSTR lpValueName)
     * }
     */
    public static FunctionDescriptor RegDeleteKeyValueW$descriptor() {
        return RegDeleteKeyValueW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LSTATUS RegDeleteKeyValueW(HKEY hKey, LPCWSTR lpSubKey, LPCWSTR lpValueName)
     * }
     */
    public static MethodHandle RegDeleteKeyValueW$handle() {
        return RegDeleteKeyValueW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * LSTATUS RegDeleteKeyValueW(HKEY hKey, LPCWSTR lpSubKey, LPCWSTR lpValueName)
     * }
     */
    public static int RegDeleteKeyValueW(MemorySegment hKey, MemorySegment lpSubKey, MemorySegment lpValueName) {
        var mh$ = RegDeleteKeyValueW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RegDeleteKeyValueW", hKey, lpSubKey, lpValueName);
            }
            return (int)mh$.invokeExact(hKey, lpSubKey, lpValueName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RegSetKeyValueA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_LONG,
            C_POINTER,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("RegSetKeyValueA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LSTATUS RegSetKeyValueA(HKEY hKey, LPCSTR lpSubKey, LPCSTR lpValueName, DWORD dwType, LPCVOID lpData, DWORD cbData)
     * }
     */
    public static FunctionDescriptor RegSetKeyValueA$descriptor() {
        return RegSetKeyValueA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LSTATUS RegSetKeyValueA(HKEY hKey, LPCSTR lpSubKey, LPCSTR lpValueName, DWORD dwType, LPCVOID lpData, DWORD cbData)
     * }
     */
    public static MethodHandle RegSetKeyValueA$handle() {
        return RegSetKeyValueA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * LSTATUS RegSetKeyValueA(HKEY hKey, LPCSTR lpSubKey, LPCSTR lpValueName, DWORD dwType, LPCVOID lpData, DWORD cbData)
     * }
     */
    public static int RegSetKeyValueA(MemorySegment hKey, MemorySegment lpSubKey, MemorySegment lpValueName, int dwType, MemorySegment lpData, int cbData) {
        var mh$ = RegSetKeyValueA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RegSetKeyValueA", hKey, lpSubKey, lpValueName, dwType, lpData, cbData);
            }
            return (int)mh$.invokeExact(hKey, lpSubKey, lpValueName, dwType, lpData, cbData);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
}

