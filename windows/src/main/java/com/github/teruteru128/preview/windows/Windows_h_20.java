// Generated by jextract

package com.github.teruteru128.preview.windows;

import java.lang.invoke.*;
import java.lang.foreign.*;
import java.nio.ByteOrder;
import java.util.*;
import java.util.function.*;
import java.util.stream.*;

import static java.lang.foreign.ValueLayout.*;
import static java.lang.foreign.MemoryLayout.PathElement.*;

public class Windows_h_20 extends Windows_h_21 {

    Windows_h_20() {
        // Should not be called directly
    }

    private static class RpcNsEntryObjectInqBeginW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_LONG,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("RpcNsEntryObjectInqBeginW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * RPC_STATUS RpcNsEntryObjectInqBeginW(unsigned long EntryNameSyntax, RPC_WSTR EntryName, RPC_NS_HANDLE *InquiryContext)
     * }
     */
    public static FunctionDescriptor RpcNsEntryObjectInqBeginW$descriptor() {
        return RpcNsEntryObjectInqBeginW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * RPC_STATUS RpcNsEntryObjectInqBeginW(unsigned long EntryNameSyntax, RPC_WSTR EntryName, RPC_NS_HANDLE *InquiryContext)
     * }
     */
    public static MethodHandle RpcNsEntryObjectInqBeginW$handle() {
        return RpcNsEntryObjectInqBeginW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * RPC_STATUS RpcNsEntryObjectInqBeginW(unsigned long EntryNameSyntax, RPC_WSTR EntryName, RPC_NS_HANDLE *InquiryContext)
     * }
     */
    public static int RpcNsEntryObjectInqBeginW(int EntryNameSyntax, MemorySegment EntryName, MemorySegment InquiryContext) {
        var mh$ = RpcNsEntryObjectInqBeginW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RpcNsEntryObjectInqBeginW", EntryNameSyntax, EntryName, InquiryContext);
            }
            return (int)mh$.invokeExact(EntryNameSyntax, EntryName, InquiryContext);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RpcNsEntryObjectInqNext {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("RpcNsEntryObjectInqNext"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * RPC_STATUS RpcNsEntryObjectInqNext(RPC_NS_HANDLE InquiryContext, UUID *ObjUuid)
     * }
     */
    public static FunctionDescriptor RpcNsEntryObjectInqNext$descriptor() {
        return RpcNsEntryObjectInqNext.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * RPC_STATUS RpcNsEntryObjectInqNext(RPC_NS_HANDLE InquiryContext, UUID *ObjUuid)
     * }
     */
    public static MethodHandle RpcNsEntryObjectInqNext$handle() {
        return RpcNsEntryObjectInqNext.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * RPC_STATUS RpcNsEntryObjectInqNext(RPC_NS_HANDLE InquiryContext, UUID *ObjUuid)
     * }
     */
    public static int RpcNsEntryObjectInqNext(MemorySegment InquiryContext, MemorySegment ObjUuid) {
        var mh$ = RpcNsEntryObjectInqNext.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RpcNsEntryObjectInqNext", InquiryContext, ObjUuid);
            }
            return (int)mh$.invokeExact(InquiryContext, ObjUuid);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RpcNsEntryObjectInqDone {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("RpcNsEntryObjectInqDone"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * RPC_STATUS RpcNsEntryObjectInqDone(RPC_NS_HANDLE *InquiryContext)
     * }
     */
    public static FunctionDescriptor RpcNsEntryObjectInqDone$descriptor() {
        return RpcNsEntryObjectInqDone.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * RPC_STATUS RpcNsEntryObjectInqDone(RPC_NS_HANDLE *InquiryContext)
     * }
     */
    public static MethodHandle RpcNsEntryObjectInqDone$handle() {
        return RpcNsEntryObjectInqDone.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * RPC_STATUS RpcNsEntryObjectInqDone(RPC_NS_HANDLE *InquiryContext)
     * }
     */
    public static int RpcNsEntryObjectInqDone(MemorySegment InquiryContext) {
        var mh$ = RpcNsEntryObjectInqDone.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RpcNsEntryObjectInqDone", InquiryContext);
            }
            return (int)mh$.invokeExact(InquiryContext);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RpcNsEntryExpandNameA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_LONG,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("RpcNsEntryExpandNameA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * RPC_STATUS RpcNsEntryExpandNameA(unsigned long EntryNameSyntax, RPC_CSTR EntryName, RPC_CSTR *ExpandedName)
     * }
     */
    public static FunctionDescriptor RpcNsEntryExpandNameA$descriptor() {
        return RpcNsEntryExpandNameA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * RPC_STATUS RpcNsEntryExpandNameA(unsigned long EntryNameSyntax, RPC_CSTR EntryName, RPC_CSTR *ExpandedName)
     * }
     */
    public static MethodHandle RpcNsEntryExpandNameA$handle() {
        return RpcNsEntryExpandNameA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * RPC_STATUS RpcNsEntryExpandNameA(unsigned long EntryNameSyntax, RPC_CSTR EntryName, RPC_CSTR *ExpandedName)
     * }
     */
    public static int RpcNsEntryExpandNameA(int EntryNameSyntax, MemorySegment EntryName, MemorySegment ExpandedName) {
        var mh$ = RpcNsEntryExpandNameA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RpcNsEntryExpandNameA", EntryNameSyntax, EntryName, ExpandedName);
            }
            return (int)mh$.invokeExact(EntryNameSyntax, EntryName, ExpandedName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RpcNsMgmtBindingUnexportA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_LONG,
            C_POINTER,
            C_POINTER,
            C_LONG,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("RpcNsMgmtBindingUnexportA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * RPC_STATUS RpcNsMgmtBindingUnexportA(unsigned long EntryNameSyntax, RPC_CSTR EntryName, RPC_IF_ID *IfId, unsigned long VersOption, UUID_VECTOR *ObjectUuidVec)
     * }
     */
    public static FunctionDescriptor RpcNsMgmtBindingUnexportA$descriptor() {
        return RpcNsMgmtBindingUnexportA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * RPC_STATUS RpcNsMgmtBindingUnexportA(unsigned long EntryNameSyntax, RPC_CSTR EntryName, RPC_IF_ID *IfId, unsigned long VersOption, UUID_VECTOR *ObjectUuidVec)
     * }
     */
    public static MethodHandle RpcNsMgmtBindingUnexportA$handle() {
        return RpcNsMgmtBindingUnexportA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * RPC_STATUS RpcNsMgmtBindingUnexportA(unsigned long EntryNameSyntax, RPC_CSTR EntryName, RPC_IF_ID *IfId, unsigned long VersOption, UUID_VECTOR *ObjectUuidVec)
     * }
     */
    public static int RpcNsMgmtBindingUnexportA(int EntryNameSyntax, MemorySegment EntryName, MemorySegment IfId, int VersOption, MemorySegment ObjectUuidVec) {
        var mh$ = RpcNsMgmtBindingUnexportA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RpcNsMgmtBindingUnexportA", EntryNameSyntax, EntryName, IfId, VersOption, ObjectUuidVec);
            }
            return (int)mh$.invokeExact(EntryNameSyntax, EntryName, IfId, VersOption, ObjectUuidVec);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RpcNsMgmtEntryCreateA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_LONG,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("RpcNsMgmtEntryCreateA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * RPC_STATUS RpcNsMgmtEntryCreateA(unsigned long EntryNameSyntax, RPC_CSTR EntryName)
     * }
     */
    public static FunctionDescriptor RpcNsMgmtEntryCreateA$descriptor() {
        return RpcNsMgmtEntryCreateA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * RPC_STATUS RpcNsMgmtEntryCreateA(unsigned long EntryNameSyntax, RPC_CSTR EntryName)
     * }
     */
    public static MethodHandle RpcNsMgmtEntryCreateA$handle() {
        return RpcNsMgmtEntryCreateA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * RPC_STATUS RpcNsMgmtEntryCreateA(unsigned long EntryNameSyntax, RPC_CSTR EntryName)
     * }
     */
    public static int RpcNsMgmtEntryCreateA(int EntryNameSyntax, MemorySegment EntryName) {
        var mh$ = RpcNsMgmtEntryCreateA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RpcNsMgmtEntryCreateA", EntryNameSyntax, EntryName);
            }
            return (int)mh$.invokeExact(EntryNameSyntax, EntryName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RpcNsMgmtEntryDeleteA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_LONG,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("RpcNsMgmtEntryDeleteA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * RPC_STATUS RpcNsMgmtEntryDeleteA(unsigned long EntryNameSyntax, RPC_CSTR EntryName)
     * }
     */
    public static FunctionDescriptor RpcNsMgmtEntryDeleteA$descriptor() {
        return RpcNsMgmtEntryDeleteA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * RPC_STATUS RpcNsMgmtEntryDeleteA(unsigned long EntryNameSyntax, RPC_CSTR EntryName)
     * }
     */
    public static MethodHandle RpcNsMgmtEntryDeleteA$handle() {
        return RpcNsMgmtEntryDeleteA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * RPC_STATUS RpcNsMgmtEntryDeleteA(unsigned long EntryNameSyntax, RPC_CSTR EntryName)
     * }
     */
    public static int RpcNsMgmtEntryDeleteA(int EntryNameSyntax, MemorySegment EntryName) {
        var mh$ = RpcNsMgmtEntryDeleteA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RpcNsMgmtEntryDeleteA", EntryNameSyntax, EntryName);
            }
            return (int)mh$.invokeExact(EntryNameSyntax, EntryName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RpcNsMgmtEntryInqIfIdsA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_LONG,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("RpcNsMgmtEntryInqIfIdsA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * RPC_STATUS RpcNsMgmtEntryInqIfIdsA(unsigned long EntryNameSyntax, RPC_CSTR EntryName, RPC_IF_ID_VECTOR **IfIdVec)
     * }
     */
    public static FunctionDescriptor RpcNsMgmtEntryInqIfIdsA$descriptor() {
        return RpcNsMgmtEntryInqIfIdsA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * RPC_STATUS RpcNsMgmtEntryInqIfIdsA(unsigned long EntryNameSyntax, RPC_CSTR EntryName, RPC_IF_ID_VECTOR **IfIdVec)
     * }
     */
    public static MethodHandle RpcNsMgmtEntryInqIfIdsA$handle() {
        return RpcNsMgmtEntryInqIfIdsA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * RPC_STATUS RpcNsMgmtEntryInqIfIdsA(unsigned long EntryNameSyntax, RPC_CSTR EntryName, RPC_IF_ID_VECTOR **IfIdVec)
     * }
     */
    public static int RpcNsMgmtEntryInqIfIdsA(int EntryNameSyntax, MemorySegment EntryName, MemorySegment IfIdVec) {
        var mh$ = RpcNsMgmtEntryInqIfIdsA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RpcNsMgmtEntryInqIfIdsA", EntryNameSyntax, EntryName, IfIdVec);
            }
            return (int)mh$.invokeExact(EntryNameSyntax, EntryName, IfIdVec);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RpcNsMgmtHandleSetExpAge {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_POINTER,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("RpcNsMgmtHandleSetExpAge"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * RPC_STATUS RpcNsMgmtHandleSetExpAge(RPC_NS_HANDLE NsHandle, unsigned long ExpirationAge)
     * }
     */
    public static FunctionDescriptor RpcNsMgmtHandleSetExpAge$descriptor() {
        return RpcNsMgmtHandleSetExpAge.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * RPC_STATUS RpcNsMgmtHandleSetExpAge(RPC_NS_HANDLE NsHandle, unsigned long ExpirationAge)
     * }
     */
    public static MethodHandle RpcNsMgmtHandleSetExpAge$handle() {
        return RpcNsMgmtHandleSetExpAge.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * RPC_STATUS RpcNsMgmtHandleSetExpAge(RPC_NS_HANDLE NsHandle, unsigned long ExpirationAge)
     * }
     */
    public static int RpcNsMgmtHandleSetExpAge(MemorySegment NsHandle, int ExpirationAge) {
        var mh$ = RpcNsMgmtHandleSetExpAge.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RpcNsMgmtHandleSetExpAge", NsHandle, ExpirationAge);
            }
            return (int)mh$.invokeExact(NsHandle, ExpirationAge);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RpcNsMgmtInqExpAge {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("RpcNsMgmtInqExpAge"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * RPC_STATUS RpcNsMgmtInqExpAge(unsigned long *ExpirationAge)
     * }
     */
    public static FunctionDescriptor RpcNsMgmtInqExpAge$descriptor() {
        return RpcNsMgmtInqExpAge.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * RPC_STATUS RpcNsMgmtInqExpAge(unsigned long *ExpirationAge)
     * }
     */
    public static MethodHandle RpcNsMgmtInqExpAge$handle() {
        return RpcNsMgmtInqExpAge.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * RPC_STATUS RpcNsMgmtInqExpAge(unsigned long *ExpirationAge)
     * }
     */
    public static int RpcNsMgmtInqExpAge(MemorySegment ExpirationAge) {
        var mh$ = RpcNsMgmtInqExpAge.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RpcNsMgmtInqExpAge", ExpirationAge);
            }
            return (int)mh$.invokeExact(ExpirationAge);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RpcNsMgmtSetExpAge {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("RpcNsMgmtSetExpAge"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * RPC_STATUS RpcNsMgmtSetExpAge(unsigned long ExpirationAge)
     * }
     */
    public static FunctionDescriptor RpcNsMgmtSetExpAge$descriptor() {
        return RpcNsMgmtSetExpAge.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * RPC_STATUS RpcNsMgmtSetExpAge(unsigned long ExpirationAge)
     * }
     */
    public static MethodHandle RpcNsMgmtSetExpAge$handle() {
        return RpcNsMgmtSetExpAge.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * RPC_STATUS RpcNsMgmtSetExpAge(unsigned long ExpirationAge)
     * }
     */
    public static int RpcNsMgmtSetExpAge(int ExpirationAge) {
        var mh$ = RpcNsMgmtSetExpAge.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RpcNsMgmtSetExpAge", ExpirationAge);
            }
            return (int)mh$.invokeExact(ExpirationAge);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RpcNsEntryExpandNameW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_LONG,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("RpcNsEntryExpandNameW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * RPC_STATUS RpcNsEntryExpandNameW(unsigned long EntryNameSyntax, RPC_WSTR EntryName, RPC_WSTR *ExpandedName)
     * }
     */
    public static FunctionDescriptor RpcNsEntryExpandNameW$descriptor() {
        return RpcNsEntryExpandNameW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * RPC_STATUS RpcNsEntryExpandNameW(unsigned long EntryNameSyntax, RPC_WSTR EntryName, RPC_WSTR *ExpandedName)
     * }
     */
    public static MethodHandle RpcNsEntryExpandNameW$handle() {
        return RpcNsEntryExpandNameW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * RPC_STATUS RpcNsEntryExpandNameW(unsigned long EntryNameSyntax, RPC_WSTR EntryName, RPC_WSTR *ExpandedName)
     * }
     */
    public static int RpcNsEntryExpandNameW(int EntryNameSyntax, MemorySegment EntryName, MemorySegment ExpandedName) {
        var mh$ = RpcNsEntryExpandNameW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RpcNsEntryExpandNameW", EntryNameSyntax, EntryName, ExpandedName);
            }
            return (int)mh$.invokeExact(EntryNameSyntax, EntryName, ExpandedName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RpcNsMgmtBindingUnexportW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_LONG,
            C_POINTER,
            C_POINTER,
            C_LONG,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("RpcNsMgmtBindingUnexportW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * RPC_STATUS RpcNsMgmtBindingUnexportW(unsigned long EntryNameSyntax, RPC_WSTR EntryName, RPC_IF_ID *IfId, unsigned long VersOption, UUID_VECTOR *ObjectUuidVec)
     * }
     */
    public static FunctionDescriptor RpcNsMgmtBindingUnexportW$descriptor() {
        return RpcNsMgmtBindingUnexportW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * RPC_STATUS RpcNsMgmtBindingUnexportW(unsigned long EntryNameSyntax, RPC_WSTR EntryName, RPC_IF_ID *IfId, unsigned long VersOption, UUID_VECTOR *ObjectUuidVec)
     * }
     */
    public static MethodHandle RpcNsMgmtBindingUnexportW$handle() {
        return RpcNsMgmtBindingUnexportW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * RPC_STATUS RpcNsMgmtBindingUnexportW(unsigned long EntryNameSyntax, RPC_WSTR EntryName, RPC_IF_ID *IfId, unsigned long VersOption, UUID_VECTOR *ObjectUuidVec)
     * }
     */
    public static int RpcNsMgmtBindingUnexportW(int EntryNameSyntax, MemorySegment EntryName, MemorySegment IfId, int VersOption, MemorySegment ObjectUuidVec) {
        var mh$ = RpcNsMgmtBindingUnexportW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RpcNsMgmtBindingUnexportW", EntryNameSyntax, EntryName, IfId, VersOption, ObjectUuidVec);
            }
            return (int)mh$.invokeExact(EntryNameSyntax, EntryName, IfId, VersOption, ObjectUuidVec);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RpcNsMgmtEntryCreateW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_LONG,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("RpcNsMgmtEntryCreateW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * RPC_STATUS RpcNsMgmtEntryCreateW(unsigned long EntryNameSyntax, RPC_WSTR EntryName)
     * }
     */
    public static FunctionDescriptor RpcNsMgmtEntryCreateW$descriptor() {
        return RpcNsMgmtEntryCreateW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * RPC_STATUS RpcNsMgmtEntryCreateW(unsigned long EntryNameSyntax, RPC_WSTR EntryName)
     * }
     */
    public static MethodHandle RpcNsMgmtEntryCreateW$handle() {
        return RpcNsMgmtEntryCreateW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * RPC_STATUS RpcNsMgmtEntryCreateW(unsigned long EntryNameSyntax, RPC_WSTR EntryName)
     * }
     */
    public static int RpcNsMgmtEntryCreateW(int EntryNameSyntax, MemorySegment EntryName) {
        var mh$ = RpcNsMgmtEntryCreateW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RpcNsMgmtEntryCreateW", EntryNameSyntax, EntryName);
            }
            return (int)mh$.invokeExact(EntryNameSyntax, EntryName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RpcNsMgmtEntryDeleteW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_LONG,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("RpcNsMgmtEntryDeleteW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * RPC_STATUS RpcNsMgmtEntryDeleteW(unsigned long EntryNameSyntax, RPC_WSTR EntryName)
     * }
     */
    public static FunctionDescriptor RpcNsMgmtEntryDeleteW$descriptor() {
        return RpcNsMgmtEntryDeleteW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * RPC_STATUS RpcNsMgmtEntryDeleteW(unsigned long EntryNameSyntax, RPC_WSTR EntryName)
     * }
     */
    public static MethodHandle RpcNsMgmtEntryDeleteW$handle() {
        return RpcNsMgmtEntryDeleteW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * RPC_STATUS RpcNsMgmtEntryDeleteW(unsigned long EntryNameSyntax, RPC_WSTR EntryName)
     * }
     */
    public static int RpcNsMgmtEntryDeleteW(int EntryNameSyntax, MemorySegment EntryName) {
        var mh$ = RpcNsMgmtEntryDeleteW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RpcNsMgmtEntryDeleteW", EntryNameSyntax, EntryName);
            }
            return (int)mh$.invokeExact(EntryNameSyntax, EntryName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RpcNsMgmtEntryInqIfIdsW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_LONG,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("RpcNsMgmtEntryInqIfIdsW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * RPC_STATUS RpcNsMgmtEntryInqIfIdsW(unsigned long EntryNameSyntax, RPC_WSTR EntryName, RPC_IF_ID_VECTOR **IfIdVec)
     * }
     */
    public static FunctionDescriptor RpcNsMgmtEntryInqIfIdsW$descriptor() {
        return RpcNsMgmtEntryInqIfIdsW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * RPC_STATUS RpcNsMgmtEntryInqIfIdsW(unsigned long EntryNameSyntax, RPC_WSTR EntryName, RPC_IF_ID_VECTOR **IfIdVec)
     * }
     */
    public static MethodHandle RpcNsMgmtEntryInqIfIdsW$handle() {
        return RpcNsMgmtEntryInqIfIdsW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * RPC_STATUS RpcNsMgmtEntryInqIfIdsW(unsigned long EntryNameSyntax, RPC_WSTR EntryName, RPC_IF_ID_VECTOR **IfIdVec)
     * }
     */
    public static int RpcNsMgmtEntryInqIfIdsW(int EntryNameSyntax, MemorySegment EntryName, MemorySegment IfIdVec) {
        var mh$ = RpcNsMgmtEntryInqIfIdsW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RpcNsMgmtEntryInqIfIdsW", EntryNameSyntax, EntryName, IfIdVec);
            }
            return (int)mh$.invokeExact(EntryNameSyntax, EntryName, IfIdVec);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RpcNsBindingImportBeginA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_LONG,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("RpcNsBindingImportBeginA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * RPC_STATUS RpcNsBindingImportBeginA(unsigned long EntryNameSyntax, RPC_CSTR EntryName, RPC_IF_HANDLE IfSpec, UUID *ObjUuid, RPC_NS_HANDLE *ImportContext)
     * }
     */
    public static FunctionDescriptor RpcNsBindingImportBeginA$descriptor() {
        return RpcNsBindingImportBeginA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * RPC_STATUS RpcNsBindingImportBeginA(unsigned long EntryNameSyntax, RPC_CSTR EntryName, RPC_IF_HANDLE IfSpec, UUID *ObjUuid, RPC_NS_HANDLE *ImportContext)
     * }
     */
    public static MethodHandle RpcNsBindingImportBeginA$handle() {
        return RpcNsBindingImportBeginA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * RPC_STATUS RpcNsBindingImportBeginA(unsigned long EntryNameSyntax, RPC_CSTR EntryName, RPC_IF_HANDLE IfSpec, UUID *ObjUuid, RPC_NS_HANDLE *ImportContext)
     * }
     */
    public static int RpcNsBindingImportBeginA(int EntryNameSyntax, MemorySegment EntryName, MemorySegment IfSpec, MemorySegment ObjUuid, MemorySegment ImportContext) {
        var mh$ = RpcNsBindingImportBeginA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RpcNsBindingImportBeginA", EntryNameSyntax, EntryName, IfSpec, ObjUuid, ImportContext);
            }
            return (int)mh$.invokeExact(EntryNameSyntax, EntryName, IfSpec, ObjUuid, ImportContext);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RpcNsBindingImportBeginW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_LONG,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("RpcNsBindingImportBeginW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * RPC_STATUS RpcNsBindingImportBeginW(unsigned long EntryNameSyntax, RPC_WSTR EntryName, RPC_IF_HANDLE IfSpec, UUID *ObjUuid, RPC_NS_HANDLE *ImportContext)
     * }
     */
    public static FunctionDescriptor RpcNsBindingImportBeginW$descriptor() {
        return RpcNsBindingImportBeginW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * RPC_STATUS RpcNsBindingImportBeginW(unsigned long EntryNameSyntax, RPC_WSTR EntryName, RPC_IF_HANDLE IfSpec, UUID *ObjUuid, RPC_NS_HANDLE *ImportContext)
     * }
     */
    public static MethodHandle RpcNsBindingImportBeginW$handle() {
        return RpcNsBindingImportBeginW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * RPC_STATUS RpcNsBindingImportBeginW(unsigned long EntryNameSyntax, RPC_WSTR EntryName, RPC_IF_HANDLE IfSpec, UUID *ObjUuid, RPC_NS_HANDLE *ImportContext)
     * }
     */
    public static int RpcNsBindingImportBeginW(int EntryNameSyntax, MemorySegment EntryName, MemorySegment IfSpec, MemorySegment ObjUuid, MemorySegment ImportContext) {
        var mh$ = RpcNsBindingImportBeginW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RpcNsBindingImportBeginW", EntryNameSyntax, EntryName, IfSpec, ObjUuid, ImportContext);
            }
            return (int)mh$.invokeExact(EntryNameSyntax, EntryName, IfSpec, ObjUuid, ImportContext);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RpcNsBindingImportNext {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("RpcNsBindingImportNext"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * RPC_STATUS RpcNsBindingImportNext(RPC_NS_HANDLE ImportContext, RPC_BINDING_HANDLE *Binding)
     * }
     */
    public static FunctionDescriptor RpcNsBindingImportNext$descriptor() {
        return RpcNsBindingImportNext.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * RPC_STATUS RpcNsBindingImportNext(RPC_NS_HANDLE ImportContext, RPC_BINDING_HANDLE *Binding)
     * }
     */
    public static MethodHandle RpcNsBindingImportNext$handle() {
        return RpcNsBindingImportNext.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * RPC_STATUS RpcNsBindingImportNext(RPC_NS_HANDLE ImportContext, RPC_BINDING_HANDLE *Binding)
     * }
     */
    public static int RpcNsBindingImportNext(MemorySegment ImportContext, MemorySegment Binding) {
        var mh$ = RpcNsBindingImportNext.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RpcNsBindingImportNext", ImportContext, Binding);
            }
            return (int)mh$.invokeExact(ImportContext, Binding);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RpcNsBindingImportDone {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("RpcNsBindingImportDone"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * RPC_STATUS RpcNsBindingImportDone(RPC_NS_HANDLE *ImportContext)
     * }
     */
    public static FunctionDescriptor RpcNsBindingImportDone$descriptor() {
        return RpcNsBindingImportDone.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * RPC_STATUS RpcNsBindingImportDone(RPC_NS_HANDLE *ImportContext)
     * }
     */
    public static MethodHandle RpcNsBindingImportDone$handle() {
        return RpcNsBindingImportDone.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * RPC_STATUS RpcNsBindingImportDone(RPC_NS_HANDLE *ImportContext)
     * }
     */
    public static int RpcNsBindingImportDone(MemorySegment ImportContext) {
        var mh$ = RpcNsBindingImportDone.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RpcNsBindingImportDone", ImportContext);
            }
            return (int)mh$.invokeExact(ImportContext);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RpcNsBindingSelect {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("RpcNsBindingSelect"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * RPC_STATUS RpcNsBindingSelect(RPC_BINDING_VECTOR *BindingVec, RPC_BINDING_HANDLE *Binding)
     * }
     */
    public static FunctionDescriptor RpcNsBindingSelect$descriptor() {
        return RpcNsBindingSelect.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * RPC_STATUS RpcNsBindingSelect(RPC_BINDING_VECTOR *BindingVec, RPC_BINDING_HANDLE *Binding)
     * }
     */
    public static MethodHandle RpcNsBindingSelect$handle() {
        return RpcNsBindingSelect.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * RPC_STATUS RpcNsBindingSelect(RPC_BINDING_VECTOR *BindingVec, RPC_BINDING_HANDLE *Binding)
     * }
     */
    public static int RpcNsBindingSelect(MemorySegment BindingVec, MemorySegment Binding) {
        var mh$ = RpcNsBindingSelect.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RpcNsBindingSelect", BindingVec, Binding);
            }
            return (int)mh$.invokeExact(BindingVec, Binding);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int RpcNotificationTypeNone = (int)0L;
    /**
     * {@snippet lang=c :
     * enum _RPC_NOTIFICATION_TYPES.RpcNotificationTypeNone = 0
     * }
     */
    public static int RpcNotificationTypeNone() {
        return RpcNotificationTypeNone;
    }
    private static final int RpcNotificationTypeEvent = (int)1L;
    /**
     * {@snippet lang=c :
     * enum _RPC_NOTIFICATION_TYPES.RpcNotificationTypeEvent = 1
     * }
     */
    public static int RpcNotificationTypeEvent() {
        return RpcNotificationTypeEvent;
    }
    private static final int RpcNotificationTypeApc = (int)2L;
    /**
     * {@snippet lang=c :
     * enum _RPC_NOTIFICATION_TYPES.RpcNotificationTypeApc = 2
     * }
     */
    public static int RpcNotificationTypeApc() {
        return RpcNotificationTypeApc;
    }
    private static final int RpcNotificationTypeIoc = (int)3L;
    /**
     * {@snippet lang=c :
     * enum _RPC_NOTIFICATION_TYPES.RpcNotificationTypeIoc = 3
     * }
     */
    public static int RpcNotificationTypeIoc() {
        return RpcNotificationTypeIoc;
    }
    private static final int RpcNotificationTypeHwnd = (int)4L;
    /**
     * {@snippet lang=c :
     * enum _RPC_NOTIFICATION_TYPES.RpcNotificationTypeHwnd = 4
     * }
     */
    public static int RpcNotificationTypeHwnd() {
        return RpcNotificationTypeHwnd;
    }
    private static final int RpcNotificationTypeCallback = (int)5L;
    /**
     * {@snippet lang=c :
     * enum _RPC_NOTIFICATION_TYPES.RpcNotificationTypeCallback = 5
     * }
     */
    public static int RpcNotificationTypeCallback() {
        return RpcNotificationTypeCallback;
    }
    private static final int RpcCallComplete = (int)0L;
    /**
     * {@snippet lang=c :
     * enum _RPC_ASYNC_EVENT.RpcCallComplete = 0
     * }
     */
    public static int RpcCallComplete() {
        return RpcCallComplete;
    }
    private static final int RpcSendComplete = (int)1L;
    /**
     * {@snippet lang=c :
     * enum _RPC_ASYNC_EVENT.RpcSendComplete = 1
     * }
     */
    public static int RpcSendComplete() {
        return RpcSendComplete;
    }
    private static final int RpcReceiveComplete = (int)2L;
    /**
     * {@snippet lang=c :
     * enum _RPC_ASYNC_EVENT.RpcReceiveComplete = 2
     * }
     */
    public static int RpcReceiveComplete() {
        return RpcReceiveComplete;
    }
    private static final int RpcClientDisconnect = (int)3L;
    /**
     * {@snippet lang=c :
     * enum _RPC_ASYNC_EVENT.RpcClientDisconnect = 3
     * }
     */
    public static int RpcClientDisconnect() {
        return RpcClientDisconnect;
    }
    private static final int RpcClientCancel = (int)4L;
    /**
     * {@snippet lang=c :
     * enum _RPC_ASYNC_EVENT.RpcClientCancel = 4
     * }
     */
    public static int RpcClientCancel() {
        return RpcClientCancel;
    }
    /**
     * {@snippet lang=c :
     * typedef union _RPC_ASYNC_NOTIFICATION_INFO {
     *     struct {
     *         PFN_RPCNOTIFICATION_ROUTINE NotificationRoutine;
     *         HANDLE hThread;
     *     } APC;
     *     struct {
     *         HANDLE hIOPort;
     *         DWORD dwNumberOfBytesTransferred;
     *         DWORD_PTR dwCompletionKey;
     *         LPOVERLAPPED lpOverlapped;
     *     } IOC;
     *     struct {
     *         HWND hWnd;
     *         UINT Msg;
     *     } HWND;
     *     HANDLE hEvent;
     *     PFN_RPCNOTIFICATION_ROUTINE NotificationRoutine;
     * } *PRPC_ASYNC_NOTIFICATION_INFO
     * }
     */
    public static final AddressLayout PRPC_ASYNC_NOTIFICATION_INFO = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _RPC_ASYNC_STATE {
     *     unsigned int Size;
     *     unsigned long Signature;
     *     long Lock;
     *     unsigned long Flags;
     *     void *StubInfo;
     *     void *UserInfo;
     *     void *RuntimeInfo;
     *     RPC_ASYNC_EVENT Event;
     *     RPC_NOTIFICATION_TYPES NotificationType;
     *     RPC_ASYNC_NOTIFICATION_INFO u;
     *     LONG_PTR Reserved[4];
     * } *PRPC_ASYNC_STATE
     * }
     */
    public static final AddressLayout PRPC_ASYNC_STATE = C_POINTER;

    private static class RpcAsyncRegisterInfo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("RpcAsyncRegisterInfo"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * RPC_STATUS RpcAsyncRegisterInfo(PRPC_ASYNC_STATE pAsync)
     * }
     */
    public static FunctionDescriptor RpcAsyncRegisterInfo$descriptor() {
        return RpcAsyncRegisterInfo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * RPC_STATUS RpcAsyncRegisterInfo(PRPC_ASYNC_STATE pAsync)
     * }
     */
    public static MethodHandle RpcAsyncRegisterInfo$handle() {
        return RpcAsyncRegisterInfo.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * RPC_STATUS RpcAsyncRegisterInfo(PRPC_ASYNC_STATE pAsync)
     * }
     */
    public static int RpcAsyncRegisterInfo(MemorySegment pAsync) {
        var mh$ = RpcAsyncRegisterInfo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RpcAsyncRegisterInfo", pAsync);
            }
            return (int)mh$.invokeExact(pAsync);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RpcAsyncInitializeHandle {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_POINTER,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("RpcAsyncInitializeHandle"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * RPC_STATUS RpcAsyncInitializeHandle(PRPC_ASYNC_STATE pAsync, unsigned int Size)
     * }
     */
    public static FunctionDescriptor RpcAsyncInitializeHandle$descriptor() {
        return RpcAsyncInitializeHandle.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * RPC_STATUS RpcAsyncInitializeHandle(PRPC_ASYNC_STATE pAsync, unsigned int Size)
     * }
     */
    public static MethodHandle RpcAsyncInitializeHandle$handle() {
        return RpcAsyncInitializeHandle.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * RPC_STATUS RpcAsyncInitializeHandle(PRPC_ASYNC_STATE pAsync, unsigned int Size)
     * }
     */
    public static int RpcAsyncInitializeHandle(MemorySegment pAsync, int Size) {
        var mh$ = RpcAsyncInitializeHandle.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RpcAsyncInitializeHandle", pAsync, Size);
            }
            return (int)mh$.invokeExact(pAsync, Size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RpcAsyncGetCallStatus {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("RpcAsyncGetCallStatus"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * RPC_STATUS RpcAsyncGetCallStatus(PRPC_ASYNC_STATE pAsync)
     * }
     */
    public static FunctionDescriptor RpcAsyncGetCallStatus$descriptor() {
        return RpcAsyncGetCallStatus.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * RPC_STATUS RpcAsyncGetCallStatus(PRPC_ASYNC_STATE pAsync)
     * }
     */
    public static MethodHandle RpcAsyncGetCallStatus$handle() {
        return RpcAsyncGetCallStatus.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * RPC_STATUS RpcAsyncGetCallStatus(PRPC_ASYNC_STATE pAsync)
     * }
     */
    public static int RpcAsyncGetCallStatus(MemorySegment pAsync) {
        var mh$ = RpcAsyncGetCallStatus.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RpcAsyncGetCallStatus", pAsync);
            }
            return (int)mh$.invokeExact(pAsync);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RpcAsyncCompleteCall {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("RpcAsyncCompleteCall"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * RPC_STATUS RpcAsyncCompleteCall(PRPC_ASYNC_STATE pAsync, void *Reply)
     * }
     */
    public static FunctionDescriptor RpcAsyncCompleteCall$descriptor() {
        return RpcAsyncCompleteCall.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * RPC_STATUS RpcAsyncCompleteCall(PRPC_ASYNC_STATE pAsync, void *Reply)
     * }
     */
    public static MethodHandle RpcAsyncCompleteCall$handle() {
        return RpcAsyncCompleteCall.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * RPC_STATUS RpcAsyncCompleteCall(PRPC_ASYNC_STATE pAsync, void *Reply)
     * }
     */
    public static int RpcAsyncCompleteCall(MemorySegment pAsync, MemorySegment Reply) {
        var mh$ = RpcAsyncCompleteCall.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RpcAsyncCompleteCall", pAsync, Reply);
            }
            return (int)mh$.invokeExact(pAsync, Reply);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RpcAsyncAbortCall {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_POINTER,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("RpcAsyncAbortCall"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * RPC_STATUS RpcAsyncAbortCall(PRPC_ASYNC_STATE pAsync, unsigned long ExceptionCode)
     * }
     */
    public static FunctionDescriptor RpcAsyncAbortCall$descriptor() {
        return RpcAsyncAbortCall.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * RPC_STATUS RpcAsyncAbortCall(PRPC_ASYNC_STATE pAsync, unsigned long ExceptionCode)
     * }
     */
    public static MethodHandle RpcAsyncAbortCall$handle() {
        return RpcAsyncAbortCall.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * RPC_STATUS RpcAsyncAbortCall(PRPC_ASYNC_STATE pAsync, unsigned long ExceptionCode)
     * }
     */
    public static int RpcAsyncAbortCall(MemorySegment pAsync, int ExceptionCode) {
        var mh$ = RpcAsyncAbortCall.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RpcAsyncAbortCall", pAsync, ExceptionCode);
            }
            return (int)mh$.invokeExact(pAsync, ExceptionCode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RpcAsyncCancelCall {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_POINTER,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("RpcAsyncCancelCall"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * RPC_STATUS RpcAsyncCancelCall(PRPC_ASYNC_STATE pAsync, BOOL fAbort)
     * }
     */
    public static FunctionDescriptor RpcAsyncCancelCall$descriptor() {
        return RpcAsyncCancelCall.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * RPC_STATUS RpcAsyncCancelCall(PRPC_ASYNC_STATE pAsync, BOOL fAbort)
     * }
     */
    public static MethodHandle RpcAsyncCancelCall$handle() {
        return RpcAsyncCancelCall.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * RPC_STATUS RpcAsyncCancelCall(PRPC_ASYNC_STATE pAsync, BOOL fAbort)
     * }
     */
    public static int RpcAsyncCancelCall(MemorySegment pAsync, int fAbort) {
        var mh$ = RpcAsyncCancelCall.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RpcAsyncCancelCall", pAsync, fAbort);
            }
            return (int)mh$.invokeExact(pAsync, fAbort);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int eeptAnsiString = (int)1L;
    /**
     * {@snippet lang=c :
     * enum tagExtendedErrorParamTypes.eeptAnsiString = 1
     * }
     */
    public static int eeptAnsiString() {
        return eeptAnsiString;
    }
    private static final int eeptUnicodeString = (int)2L;
    /**
     * {@snippet lang=c :
     * enum tagExtendedErrorParamTypes.eeptUnicodeString = 2
     * }
     */
    public static int eeptUnicodeString() {
        return eeptUnicodeString;
    }
    private static final int eeptLongVal = (int)3L;
    /**
     * {@snippet lang=c :
     * enum tagExtendedErrorParamTypes.eeptLongVal = 3
     * }
     */
    public static int eeptLongVal() {
        return eeptLongVal;
    }
    private static final int eeptShortVal = (int)4L;
    /**
     * {@snippet lang=c :
     * enum tagExtendedErrorParamTypes.eeptShortVal = 4
     * }
     */
    public static int eeptShortVal() {
        return eeptShortVal;
    }
    private static final int eeptPointerVal = (int)5L;
    /**
     * {@snippet lang=c :
     * enum tagExtendedErrorParamTypes.eeptPointerVal = 5
     * }
     */
    public static int eeptPointerVal() {
        return eeptPointerVal;
    }
    private static final int eeptNone = (int)6L;
    /**
     * {@snippet lang=c :
     * enum tagExtendedErrorParamTypes.eeptNone = 6
     * }
     */
    public static int eeptNone() {
        return eeptNone;
    }
    private static final int eeptBinary = (int)7L;
    /**
     * {@snippet lang=c :
     * enum tagExtendedErrorParamTypes.eeptBinary = 7
     * }
     */
    public static int eeptBinary() {
        return eeptBinary;
    }

    private static class RpcErrorStartEnumeration {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("RpcErrorStartEnumeration"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * RPC_STATUS RpcErrorStartEnumeration(RPC_ERROR_ENUM_HANDLE *EnumHandle)
     * }
     */
    public static FunctionDescriptor RpcErrorStartEnumeration$descriptor() {
        return RpcErrorStartEnumeration.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * RPC_STATUS RpcErrorStartEnumeration(RPC_ERROR_ENUM_HANDLE *EnumHandle)
     * }
     */
    public static MethodHandle RpcErrorStartEnumeration$handle() {
        return RpcErrorStartEnumeration.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * RPC_STATUS RpcErrorStartEnumeration(RPC_ERROR_ENUM_HANDLE *EnumHandle)
     * }
     */
    public static int RpcErrorStartEnumeration(MemorySegment EnumHandle) {
        var mh$ = RpcErrorStartEnumeration.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RpcErrorStartEnumeration", EnumHandle);
            }
            return (int)mh$.invokeExact(EnumHandle);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RpcErrorGetNextRecord {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_POINTER,
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("RpcErrorGetNextRecord"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * RPC_STATUS RpcErrorGetNextRecord(RPC_ERROR_ENUM_HANDLE *EnumHandle, BOOL CopyStrings, RPC_EXTENDED_ERROR_INFO *ErrorInfo)
     * }
     */
    public static FunctionDescriptor RpcErrorGetNextRecord$descriptor() {
        return RpcErrorGetNextRecord.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * RPC_STATUS RpcErrorGetNextRecord(RPC_ERROR_ENUM_HANDLE *EnumHandle, BOOL CopyStrings, RPC_EXTENDED_ERROR_INFO *ErrorInfo)
     * }
     */
    public static MethodHandle RpcErrorGetNextRecord$handle() {
        return RpcErrorGetNextRecord.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * RPC_STATUS RpcErrorGetNextRecord(RPC_ERROR_ENUM_HANDLE *EnumHandle, BOOL CopyStrings, RPC_EXTENDED_ERROR_INFO *ErrorInfo)
     * }
     */
    public static int RpcErrorGetNextRecord(MemorySegment EnumHandle, int CopyStrings, MemorySegment ErrorInfo) {
        var mh$ = RpcErrorGetNextRecord.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RpcErrorGetNextRecord", EnumHandle, CopyStrings, ErrorInfo);
            }
            return (int)mh$.invokeExact(EnumHandle, CopyStrings, ErrorInfo);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RpcErrorEndEnumeration {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("RpcErrorEndEnumeration"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * RPC_STATUS RpcErrorEndEnumeration(RPC_ERROR_ENUM_HANDLE *EnumHandle)
     * }
     */
    public static FunctionDescriptor RpcErrorEndEnumeration$descriptor() {
        return RpcErrorEndEnumeration.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * RPC_STATUS RpcErrorEndEnumeration(RPC_ERROR_ENUM_HANDLE *EnumHandle)
     * }
     */
    public static MethodHandle RpcErrorEndEnumeration$handle() {
        return RpcErrorEndEnumeration.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * RPC_STATUS RpcErrorEndEnumeration(RPC_ERROR_ENUM_HANDLE *EnumHandle)
     * }
     */
    public static int RpcErrorEndEnumeration(MemorySegment EnumHandle) {
        var mh$ = RpcErrorEndEnumeration.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RpcErrorEndEnumeration", EnumHandle);
            }
            return (int)mh$.invokeExact(EnumHandle);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RpcErrorResetEnumeration {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("RpcErrorResetEnumeration"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * RPC_STATUS RpcErrorResetEnumeration(RPC_ERROR_ENUM_HANDLE *EnumHandle)
     * }
     */
    public static FunctionDescriptor RpcErrorResetEnumeration$descriptor() {
        return RpcErrorResetEnumeration.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * RPC_STATUS RpcErrorResetEnumeration(RPC_ERROR_ENUM_HANDLE *EnumHandle)
     * }
     */
    public static MethodHandle RpcErrorResetEnumeration$handle() {
        return RpcErrorResetEnumeration.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * RPC_STATUS RpcErrorResetEnumeration(RPC_ERROR_ENUM_HANDLE *EnumHandle)
     * }
     */
    public static int RpcErrorResetEnumeration(MemorySegment EnumHandle) {
        var mh$ = RpcErrorResetEnumeration.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RpcErrorResetEnumeration", EnumHandle);
            }
            return (int)mh$.invokeExact(EnumHandle);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RpcErrorGetNumberOfRecords {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("RpcErrorGetNumberOfRecords"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * RPC_STATUS RpcErrorGetNumberOfRecords(RPC_ERROR_ENUM_HANDLE *EnumHandle, int *Records)
     * }
     */
    public static FunctionDescriptor RpcErrorGetNumberOfRecords$descriptor() {
        return RpcErrorGetNumberOfRecords.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * RPC_STATUS RpcErrorGetNumberOfRecords(RPC_ERROR_ENUM_HANDLE *EnumHandle, int *Records)
     * }
     */
    public static MethodHandle RpcErrorGetNumberOfRecords$handle() {
        return RpcErrorGetNumberOfRecords.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * RPC_STATUS RpcErrorGetNumberOfRecords(RPC_ERROR_ENUM_HANDLE *EnumHandle, int *Records)
     * }
     */
    public static int RpcErrorGetNumberOfRecords(MemorySegment EnumHandle, MemorySegment Records) {
        var mh$ = RpcErrorGetNumberOfRecords.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RpcErrorGetNumberOfRecords", EnumHandle, Records);
            }
            return (int)mh$.invokeExact(EnumHandle, Records);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RpcErrorSaveErrorInfo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("RpcErrorSaveErrorInfo"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * RPC_STATUS RpcErrorSaveErrorInfo(RPC_ERROR_ENUM_HANDLE *EnumHandle, PVOID *ErrorBlob, size_t *BlobSize)
     * }
     */
    public static FunctionDescriptor RpcErrorSaveErrorInfo$descriptor() {
        return RpcErrorSaveErrorInfo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * RPC_STATUS RpcErrorSaveErrorInfo(RPC_ERROR_ENUM_HANDLE *EnumHandle, PVOID *ErrorBlob, size_t *BlobSize)
     * }
     */
    public static MethodHandle RpcErrorSaveErrorInfo$handle() {
        return RpcErrorSaveErrorInfo.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * RPC_STATUS RpcErrorSaveErrorInfo(RPC_ERROR_ENUM_HANDLE *EnumHandle, PVOID *ErrorBlob, size_t *BlobSize)
     * }
     */
    public static int RpcErrorSaveErrorInfo(MemorySegment EnumHandle, MemorySegment ErrorBlob, MemorySegment BlobSize) {
        var mh$ = RpcErrorSaveErrorInfo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RpcErrorSaveErrorInfo", EnumHandle, ErrorBlob, BlobSize);
            }
            return (int)mh$.invokeExact(EnumHandle, ErrorBlob, BlobSize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RpcErrorLoadErrorInfo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_POINTER,
            C_LONG_LONG,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("RpcErrorLoadErrorInfo"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * RPC_STATUS RpcErrorLoadErrorInfo(PVOID ErrorBlob, size_t BlobSize, RPC_ERROR_ENUM_HANDLE *EnumHandle)
     * }
     */
    public static FunctionDescriptor RpcErrorLoadErrorInfo$descriptor() {
        return RpcErrorLoadErrorInfo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * RPC_STATUS RpcErrorLoadErrorInfo(PVOID ErrorBlob, size_t BlobSize, RPC_ERROR_ENUM_HANDLE *EnumHandle)
     * }
     */
    public static MethodHandle RpcErrorLoadErrorInfo$handle() {
        return RpcErrorLoadErrorInfo.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * RPC_STATUS RpcErrorLoadErrorInfo(PVOID ErrorBlob, size_t BlobSize, RPC_ERROR_ENUM_HANDLE *EnumHandle)
     * }
     */
    public static int RpcErrorLoadErrorInfo(MemorySegment ErrorBlob, long BlobSize, MemorySegment EnumHandle) {
        var mh$ = RpcErrorLoadErrorInfo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RpcErrorLoadErrorInfo", ErrorBlob, BlobSize, EnumHandle);
            }
            return (int)mh$.invokeExact(ErrorBlob, BlobSize, EnumHandle);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RpcErrorAddRecord {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("RpcErrorAddRecord"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * RPC_STATUS RpcErrorAddRecord(RPC_EXTENDED_ERROR_INFO *ErrorInfo)
     * }
     */
    public static FunctionDescriptor RpcErrorAddRecord$descriptor() {
        return RpcErrorAddRecord.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * RPC_STATUS RpcErrorAddRecord(RPC_EXTENDED_ERROR_INFO *ErrorInfo)
     * }
     */
    public static MethodHandle RpcErrorAddRecord$handle() {
        return RpcErrorAddRecord.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * RPC_STATUS RpcErrorAddRecord(RPC_EXTENDED_ERROR_INFO *ErrorInfo)
     * }
     */
    public static int RpcErrorAddRecord(MemorySegment ErrorInfo) {
        var mh$ = RpcErrorAddRecord.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RpcErrorAddRecord", ErrorInfo);
            }
            return (int)mh$.invokeExact(ErrorInfo);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RpcErrorClearInformation {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("RpcErrorClearInformation"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void RpcErrorClearInformation()
     * }
     */
    public static FunctionDescriptor RpcErrorClearInformation$descriptor() {
        return RpcErrorClearInformation.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void RpcErrorClearInformation()
     * }
     */
    public static MethodHandle RpcErrorClearInformation$handle() {
        return RpcErrorClearInformation.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * void RpcErrorClearInformation()
     * }
     */
    public static void RpcErrorClearInformation() {
        var mh$ = RpcErrorClearInformation.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RpcErrorClearInformation");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RpcAsyncCleanupThread {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("RpcAsyncCleanupThread"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * RPC_STATUS RpcAsyncCleanupThread(DWORD dwTimeout)
     * }
     */
    public static FunctionDescriptor RpcAsyncCleanupThread$descriptor() {
        return RpcAsyncCleanupThread.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * RPC_STATUS RpcAsyncCleanupThread(DWORD dwTimeout)
     * }
     */
    public static MethodHandle RpcAsyncCleanupThread$handle() {
        return RpcAsyncCleanupThread.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * RPC_STATUS RpcAsyncCleanupThread(DWORD dwTimeout)
     * }
     */
    public static int RpcAsyncCleanupThread(int dwTimeout) {
        var mh$ = RpcAsyncCleanupThread.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RpcAsyncCleanupThread", dwTimeout);
            }
            return (int)mh$.invokeExact(dwTimeout);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RpcGetAuthorizationContextForClient {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_POINTER,
            C_INT,
            C_POINTER,
            C_POINTER,
            _LUID.layout(),
            C_LONG,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("RpcGetAuthorizationContextForClient"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * RPC_STATUS RpcGetAuthorizationContextForClient(RPC_BINDING_HANDLE ClientBinding, BOOL ImpersonateOnReturn, PVOID Reserved1, PLARGE_INTEGER pExpirationTime, LUID Reserved2, DWORD Reserved3, PVOID Reserved4, PVOID *pAuthzClientContext)
     * }
     */
    public static FunctionDescriptor RpcGetAuthorizationContextForClient$descriptor() {
        return RpcGetAuthorizationContextForClient.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * RPC_STATUS RpcGetAuthorizationContextForClient(RPC_BINDING_HANDLE ClientBinding, BOOL ImpersonateOnReturn, PVOID Reserved1, PLARGE_INTEGER pExpirationTime, LUID Reserved2, DWORD Reserved3, PVOID Reserved4, PVOID *pAuthzClientContext)
     * }
     */
    public static MethodHandle RpcGetAuthorizationContextForClient$handle() {
        return RpcGetAuthorizationContextForClient.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * RPC_STATUS RpcGetAuthorizationContextForClient(RPC_BINDING_HANDLE ClientBinding, BOOL ImpersonateOnReturn, PVOID Reserved1, PLARGE_INTEGER pExpirationTime, LUID Reserved2, DWORD Reserved3, PVOID Reserved4, PVOID *pAuthzClientContext)
     * }
     */
    public static int RpcGetAuthorizationContextForClient(MemorySegment ClientBinding, int ImpersonateOnReturn, MemorySegment Reserved1, MemorySegment pExpirationTime, MemorySegment Reserved2, int Reserved3, MemorySegment Reserved4, MemorySegment pAuthzClientContext) {
        var mh$ = RpcGetAuthorizationContextForClient.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RpcGetAuthorizationContextForClient", ClientBinding, ImpersonateOnReturn, Reserved1, pExpirationTime, Reserved2, Reserved3, Reserved4, pAuthzClientContext);
            }
            return (int)mh$.invokeExact(ClientBinding, ImpersonateOnReturn, Reserved1, pExpirationTime, Reserved2, Reserved3, Reserved4, pAuthzClientContext);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RpcFreeAuthorizationContext {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("RpcFreeAuthorizationContext"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * RPC_STATUS RpcFreeAuthorizationContext(PVOID *pAuthzClientContext)
     * }
     */
    public static FunctionDescriptor RpcFreeAuthorizationContext$descriptor() {
        return RpcFreeAuthorizationContext.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * RPC_STATUS RpcFreeAuthorizationContext(PVOID *pAuthzClientContext)
     * }
     */
    public static MethodHandle RpcFreeAuthorizationContext$handle() {
        return RpcFreeAuthorizationContext.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * RPC_STATUS RpcFreeAuthorizationContext(PVOID *pAuthzClientContext)
     * }
     */
    public static int RpcFreeAuthorizationContext(MemorySegment pAuthzClientContext) {
        var mh$ = RpcFreeAuthorizationContext.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RpcFreeAuthorizationContext", pAuthzClientContext);
            }
            return (int)mh$.invokeExact(pAuthzClientContext);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RpcSsContextLockExclusive {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("RpcSsContextLockExclusive"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * RPC_STATUS RpcSsContextLockExclusive(RPC_BINDING_HANDLE ServerBindingHandle, PVOID UserContext)
     * }
     */
    public static FunctionDescriptor RpcSsContextLockExclusive$descriptor() {
        return RpcSsContextLockExclusive.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * RPC_STATUS RpcSsContextLockExclusive(RPC_BINDING_HANDLE ServerBindingHandle, PVOID UserContext)
     * }
     */
    public static MethodHandle RpcSsContextLockExclusive$handle() {
        return RpcSsContextLockExclusive.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * RPC_STATUS RpcSsContextLockExclusive(RPC_BINDING_HANDLE ServerBindingHandle, PVOID UserContext)
     * }
     */
    public static int RpcSsContextLockExclusive(MemorySegment ServerBindingHandle, MemorySegment UserContext) {
        var mh$ = RpcSsContextLockExclusive.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RpcSsContextLockExclusive", ServerBindingHandle, UserContext);
            }
            return (int)mh$.invokeExact(ServerBindingHandle, UserContext);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RpcSsContextLockShared {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("RpcSsContextLockShared"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * RPC_STATUS RpcSsContextLockShared(RPC_BINDING_HANDLE ServerBindingHandle, PVOID UserContext)
     * }
     */
    public static FunctionDescriptor RpcSsContextLockShared$descriptor() {
        return RpcSsContextLockShared.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * RPC_STATUS RpcSsContextLockShared(RPC_BINDING_HANDLE ServerBindingHandle, PVOID UserContext)
     * }
     */
    public static MethodHandle RpcSsContextLockShared$handle() {
        return RpcSsContextLockShared.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * RPC_STATUS RpcSsContextLockShared(RPC_BINDING_HANDLE ServerBindingHandle, PVOID UserContext)
     * }
     */
    public static int RpcSsContextLockShared(MemorySegment ServerBindingHandle, MemorySegment UserContext) {
        var mh$ = RpcSsContextLockShared.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RpcSsContextLockShared", ServerBindingHandle, UserContext);
            }
            return (int)mh$.invokeExact(ServerBindingHandle, UserContext);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int rlafInvalid = (int)0L;
    /**
     * {@snippet lang=c :
     * enum tagRpcLocalAddressFormat.rlafInvalid = 0
     * }
     */
    public static int rlafInvalid() {
        return rlafInvalid;
    }
    private static final int rlafIPv4 = (int)1L;
    /**
     * {@snippet lang=c :
     * enum tagRpcLocalAddressFormat.rlafIPv4 = 1
     * }
     */
    public static int rlafIPv4() {
        return rlafIPv4;
    }
    private static final int rlafIPv6 = (int)2L;
    /**
     * {@snippet lang=c :
     * enum tagRpcLocalAddressFormat.rlafIPv6 = 2
     * }
     */
    public static int rlafIPv6() {
        return rlafIPv6;
    }
    /**
     * {@snippet lang=c :
     * typedef struct _RPC_CALL_LOCAL_ADDRESS_V1 {
     *     unsigned int Version;
     *     void *Buffer;
     *     unsigned long BufferSize;
     *     RpcLocalAddressFormat AddressFormat;
     * } *PRPC_CALL_LOCAL_ADDRESS_V1
     * }
     */
    public static final AddressLayout PRPC_CALL_LOCAL_ADDRESS_V1 = C_POINTER;
    private static final int rctInvalid = (int)0L;
    /**
     * {@snippet lang=c :
     * enum tagRpcCallType.rctInvalid = 0
     * }
     */
    public static int rctInvalid() {
        return rctInvalid;
    }
    private static final int rctNormal = (int)1L;
    /**
     * {@snippet lang=c :
     * enum tagRpcCallType.rctNormal = 1
     * }
     */
    public static int rctNormal() {
        return rctNormal;
    }
    private static final int rctTraining = (int)2L;
    /**
     * {@snippet lang=c :
     * enum tagRpcCallType.rctTraining = 2
     * }
     */
    public static int rctTraining() {
        return rctTraining;
    }
    private static final int rctGuaranteed = (int)3L;
    /**
     * {@snippet lang=c :
     * enum tagRpcCallType.rctGuaranteed = 3
     * }
     */
    public static int rctGuaranteed() {
        return rctGuaranteed;
    }
    private static final int rcclInvalid = (int)0L;
    /**
     * {@snippet lang=c :
     * enum tagRpcCallClientLocality.rcclInvalid = 0
     * }
     */
    public static int rcclInvalid() {
        return rcclInvalid;
    }
    private static final int rcclLocal = (int)1L;
    /**
     * {@snippet lang=c :
     * enum tagRpcCallClientLocality.rcclLocal = 1
     * }
     */
    public static int rcclLocal() {
        return rcclLocal;
    }
    private static final int rcclRemote = (int)2L;
    /**
     * {@snippet lang=c :
     * enum tagRpcCallClientLocality.rcclRemote = 2
     * }
     */
    public static int rcclRemote() {
        return rcclRemote;
    }
    private static final int rcclClientUnknownLocality = (int)3L;
    /**
     * {@snippet lang=c :
     * enum tagRpcCallClientLocality.rcclClientUnknownLocality = 3
     * }
     */
    public static int rcclClientUnknownLocality() {
        return rcclClientUnknownLocality;
    }

    private static class RpcServerInqCallAttributesW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("RpcServerInqCallAttributesW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * RPC_STATUS RpcServerInqCallAttributesW(RPC_BINDING_HANDLE ClientBinding, void *RpcCallAttributes)
     * }
     */
    public static FunctionDescriptor RpcServerInqCallAttributesW$descriptor() {
        return RpcServerInqCallAttributesW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * RPC_STATUS RpcServerInqCallAttributesW(RPC_BINDING_HANDLE ClientBinding, void *RpcCallAttributes)
     * }
     */
    public static MethodHandle RpcServerInqCallAttributesW$handle() {
        return RpcServerInqCallAttributesW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * RPC_STATUS RpcServerInqCallAttributesW(RPC_BINDING_HANDLE ClientBinding, void *RpcCallAttributes)
     * }
     */
    public static int RpcServerInqCallAttributesW(MemorySegment ClientBinding, MemorySegment RpcCallAttributes) {
        var mh$ = RpcServerInqCallAttributesW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RpcServerInqCallAttributesW", ClientBinding, RpcCallAttributes);
            }
            return (int)mh$.invokeExact(ClientBinding, RpcCallAttributes);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RpcServerInqCallAttributesA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("RpcServerInqCallAttributesA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * RPC_STATUS RpcServerInqCallAttributesA(RPC_BINDING_HANDLE ClientBinding, void *RpcCallAttributes)
     * }
     */
    public static FunctionDescriptor RpcServerInqCallAttributesA$descriptor() {
        return RpcServerInqCallAttributesA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * RPC_STATUS RpcServerInqCallAttributesA(RPC_BINDING_HANDLE ClientBinding, void *RpcCallAttributes)
     * }
     */
    public static MethodHandle RpcServerInqCallAttributesA$handle() {
        return RpcServerInqCallAttributesA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * RPC_STATUS RpcServerInqCallAttributesA(RPC_BINDING_HANDLE ClientBinding, void *RpcCallAttributes)
     * }
     */
    public static int RpcServerInqCallAttributesA(MemorySegment ClientBinding, MemorySegment RpcCallAttributes) {
        var mh$ = RpcServerInqCallAttributesA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RpcServerInqCallAttributesA", ClientBinding, RpcCallAttributes);
            }
            return (int)mh$.invokeExact(ClientBinding, RpcCallAttributes);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int RpcNotificationCallNone = (int)0L;
    /**
     * {@snippet lang=c :
     * enum _RPC_NOTIFICATIONS.RpcNotificationCallNone = 0
     * }
     */
    public static int RpcNotificationCallNone() {
        return RpcNotificationCallNone;
    }
    private static final int RpcNotificationClientDisconnect = (int)1L;
    /**
     * {@snippet lang=c :
     * enum _RPC_NOTIFICATIONS.RpcNotificationClientDisconnect = 1
     * }
     */
    public static int RpcNotificationClientDisconnect() {
        return RpcNotificationClientDisconnect;
    }
    private static final int RpcNotificationCallCancel = (int)2L;
    /**
     * {@snippet lang=c :
     * enum _RPC_NOTIFICATIONS.RpcNotificationCallCancel = 2
     * }
     */
    public static int RpcNotificationCallCancel() {
        return RpcNotificationCallCancel;
    }

    private static class RpcServerSubscribeForNotification {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_POINTER,
            C_INT,
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("RpcServerSubscribeForNotification"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * RPC_STATUS RpcServerSubscribeForNotification(RPC_BINDING_HANDLE Binding, RPC_NOTIFICATIONS Notification, RPC_NOTIFICATION_TYPES NotificationType, RPC_ASYNC_NOTIFICATION_INFO *NotificationInfo)
     * }
     */
    public static FunctionDescriptor RpcServerSubscribeForNotification$descriptor() {
        return RpcServerSubscribeForNotification.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * RPC_STATUS RpcServerSubscribeForNotification(RPC_BINDING_HANDLE Binding, RPC_NOTIFICATIONS Notification, RPC_NOTIFICATION_TYPES NotificationType, RPC_ASYNC_NOTIFICATION_INFO *NotificationInfo)
     * }
     */
    public static MethodHandle RpcServerSubscribeForNotification$handle() {
        return RpcServerSubscribeForNotification.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * RPC_STATUS RpcServerSubscribeForNotification(RPC_BINDING_HANDLE Binding, RPC_NOTIFICATIONS Notification, RPC_NOTIFICATION_TYPES NotificationType, RPC_ASYNC_NOTIFICATION_INFO *NotificationInfo)
     * }
     */
    public static int RpcServerSubscribeForNotification(MemorySegment Binding, int Notification, int NotificationType, MemorySegment NotificationInfo) {
        var mh$ = RpcServerSubscribeForNotification.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RpcServerSubscribeForNotification", Binding, Notification, NotificationType, NotificationInfo);
            }
            return (int)mh$.invokeExact(Binding, Notification, NotificationType, NotificationInfo);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RpcServerUnsubscribeForNotification {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_POINTER,
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("RpcServerUnsubscribeForNotification"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * RPC_STATUS RpcServerUnsubscribeForNotification(RPC_BINDING_HANDLE Binding, RPC_NOTIFICATIONS Notification, unsigned long *NotificationsQueued)
     * }
     */
    public static FunctionDescriptor RpcServerUnsubscribeForNotification$descriptor() {
        return RpcServerUnsubscribeForNotification.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * RPC_STATUS RpcServerUnsubscribeForNotification(RPC_BINDING_HANDLE Binding, RPC_NOTIFICATIONS Notification, unsigned long *NotificationsQueued)
     * }
     */
    public static MethodHandle RpcServerUnsubscribeForNotification$handle() {
        return RpcServerUnsubscribeForNotification.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * RPC_STATUS RpcServerUnsubscribeForNotification(RPC_BINDING_HANDLE Binding, RPC_NOTIFICATIONS Notification, unsigned long *NotificationsQueued)
     * }
     */
    public static int RpcServerUnsubscribeForNotification(MemorySegment Binding, int Notification, MemorySegment NotificationsQueued) {
        var mh$ = RpcServerUnsubscribeForNotification.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RpcServerUnsubscribeForNotification", Binding, Notification, NotificationsQueued);
            }
            return (int)mh$.invokeExact(Binding, Notification, NotificationsQueued);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RpcBindingBind {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("RpcBindingBind"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * RPC_STATUS RpcBindingBind(PRPC_ASYNC_STATE pAsync, RPC_BINDING_HANDLE Binding, RPC_IF_HANDLE IfSpec)
     * }
     */
    public static FunctionDescriptor RpcBindingBind$descriptor() {
        return RpcBindingBind.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * RPC_STATUS RpcBindingBind(PRPC_ASYNC_STATE pAsync, RPC_BINDING_HANDLE Binding, RPC_IF_HANDLE IfSpec)
     * }
     */
    public static MethodHandle RpcBindingBind$handle() {
        return RpcBindingBind.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * RPC_STATUS RpcBindingBind(PRPC_ASYNC_STATE pAsync, RPC_BINDING_HANDLE Binding, RPC_IF_HANDLE IfSpec)
     * }
     */
    public static int RpcBindingBind(MemorySegment pAsync, MemorySegment Binding, MemorySegment IfSpec) {
        var mh$ = RpcBindingBind.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RpcBindingBind", pAsync, Binding, IfSpec);
            }
            return (int)mh$.invokeExact(pAsync, Binding, IfSpec);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RpcBindingUnbind {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("RpcBindingUnbind"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * RPC_STATUS RpcBindingUnbind(RPC_BINDING_HANDLE Binding)
     * }
     */
    public static FunctionDescriptor RpcBindingUnbind$descriptor() {
        return RpcBindingUnbind.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * RPC_STATUS RpcBindingUnbind(RPC_BINDING_HANDLE Binding)
     * }
     */
    public static MethodHandle RpcBindingUnbind$handle() {
        return RpcBindingUnbind.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * RPC_STATUS RpcBindingUnbind(RPC_BINDING_HANDLE Binding)
     * }
     */
    public static int RpcBindingUnbind(MemorySegment Binding) {
        var mh$ = RpcBindingUnbind.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RpcBindingUnbind", Binding);
            }
            return (int)mh$.invokeExact(Binding);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class I_RpcAsyncSetHandle {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("I_RpcAsyncSetHandle"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * RPC_STATUS I_RpcAsyncSetHandle(PRPC_MESSAGE Message, PRPC_ASYNC_STATE pAsync)
     * }
     */
    public static FunctionDescriptor I_RpcAsyncSetHandle$descriptor() {
        return I_RpcAsyncSetHandle.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * RPC_STATUS I_RpcAsyncSetHandle(PRPC_MESSAGE Message, PRPC_ASYNC_STATE pAsync)
     * }
     */
    public static MethodHandle I_RpcAsyncSetHandle$handle() {
        return I_RpcAsyncSetHandle.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * RPC_STATUS I_RpcAsyncSetHandle(PRPC_MESSAGE Message, PRPC_ASYNC_STATE pAsync)
     * }
     */
    public static int I_RpcAsyncSetHandle(MemorySegment Message, MemorySegment pAsync) {
        var mh$ = I_RpcAsyncSetHandle.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("I_RpcAsyncSetHandle", Message, pAsync);
            }
            return (int)mh$.invokeExact(Message, pAsync);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class I_RpcAsyncAbortCall {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_POINTER,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("I_RpcAsyncAbortCall"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * RPC_STATUS I_RpcAsyncAbortCall(PRPC_ASYNC_STATE pAsync, unsigned long ExceptionCode)
     * }
     */
    public static FunctionDescriptor I_RpcAsyncAbortCall$descriptor() {
        return I_RpcAsyncAbortCall.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * RPC_STATUS I_RpcAsyncAbortCall(PRPC_ASYNC_STATE pAsync, unsigned long ExceptionCode)
     * }
     */
    public static MethodHandle I_RpcAsyncAbortCall$handle() {
        return I_RpcAsyncAbortCall.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * RPC_STATUS I_RpcAsyncAbortCall(PRPC_ASYNC_STATE pAsync, unsigned long ExceptionCode)
     * }
     */
    public static int I_RpcAsyncAbortCall(MemorySegment pAsync, int ExceptionCode) {
        var mh$ = I_RpcAsyncAbortCall.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("I_RpcAsyncAbortCall", pAsync, ExceptionCode);
            }
            return (int)mh$.invokeExact(pAsync, ExceptionCode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class I_RpcExceptionFilter {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("I_RpcExceptionFilter"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int I_RpcExceptionFilter(unsigned long ExceptionCode)
     * }
     */
    public static FunctionDescriptor I_RpcExceptionFilter$descriptor() {
        return I_RpcExceptionFilter.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int I_RpcExceptionFilter(unsigned long ExceptionCode)
     * }
     */
    public static MethodHandle I_RpcExceptionFilter$handle() {
        return I_RpcExceptionFilter.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int I_RpcExceptionFilter(unsigned long ExceptionCode)
     * }
     */
    public static int I_RpcExceptionFilter(int ExceptionCode) {
        var mh$ = I_RpcExceptionFilter.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("I_RpcExceptionFilter", ExceptionCode);
            }
            return (int)mh$.invokeExact(ExceptionCode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class I_RpcBindingInqClientTokenAttributes {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("I_RpcBindingInqClientTokenAttributes"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * RPC_STATUS I_RpcBindingInqClientTokenAttributes(RPC_BINDING_HANDLE Binding, LUID *TokenId, LUID *AuthenticationId, LUID *ModifiedId)
     * }
     */
    public static FunctionDescriptor I_RpcBindingInqClientTokenAttributes$descriptor() {
        return I_RpcBindingInqClientTokenAttributes.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * RPC_STATUS I_RpcBindingInqClientTokenAttributes(RPC_BINDING_HANDLE Binding, LUID *TokenId, LUID *AuthenticationId, LUID *ModifiedId)
     * }
     */
    public static MethodHandle I_RpcBindingInqClientTokenAttributes$handle() {
        return I_RpcBindingInqClientTokenAttributes.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * RPC_STATUS I_RpcBindingInqClientTokenAttributes(RPC_BINDING_HANDLE Binding, LUID *TokenId, LUID *AuthenticationId, LUID *ModifiedId)
     * }
     */
    public static int I_RpcBindingInqClientTokenAttributes(MemorySegment Binding, MemorySegment TokenId, MemorySegment AuthenticationId, MemorySegment ModifiedId) {
        var mh$ = I_RpcBindingInqClientTokenAttributes.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("I_RpcBindingInqClientTokenAttributes", Binding, TokenId, AuthenticationId, ModifiedId);
            }
            return (int)mh$.invokeExact(Binding, TokenId, AuthenticationId, ModifiedId);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CommandLineToArgvW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CommandLineToArgvW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern LPWSTR *CommandLineToArgvW(LPCWSTR lpCmdLine, int *pNumArgs)
     * }
     */
    public static FunctionDescriptor CommandLineToArgvW$descriptor() {
        return CommandLineToArgvW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern LPWSTR *CommandLineToArgvW(LPCWSTR lpCmdLine, int *pNumArgs)
     * }
     */
    public static MethodHandle CommandLineToArgvW$handle() {
        return CommandLineToArgvW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern LPWSTR *CommandLineToArgvW(LPCWSTR lpCmdLine, int *pNumArgs)
     * }
     */
    public static MemorySegment CommandLineToArgvW(MemorySegment lpCmdLine, MemorySegment pNumArgs) {
        var mh$ = CommandLineToArgvW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CommandLineToArgvW", lpCmdLine, pNumArgs);
            }
            return (MemorySegment)mh$.invokeExact(lpCmdLine, pNumArgs);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct HDROP__ {
     *     int unused;
     * } *HDROP
     * }
     */
    public static final AddressLayout HDROP = C_POINTER;

    private static class DragQueryFileA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_INT,
            C_POINTER,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("DragQueryFileA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern UINT DragQueryFileA(HDROP hDrop, UINT iFile, LPSTR lpszFile, UINT cch)
     * }
     */
    public static FunctionDescriptor DragQueryFileA$descriptor() {
        return DragQueryFileA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern UINT DragQueryFileA(HDROP hDrop, UINT iFile, LPSTR lpszFile, UINT cch)
     * }
     */
    public static MethodHandle DragQueryFileA$handle() {
        return DragQueryFileA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern UINT DragQueryFileA(HDROP hDrop, UINT iFile, LPSTR lpszFile, UINT cch)
     * }
     */
    public static int DragQueryFileA(MemorySegment hDrop, int iFile, MemorySegment lpszFile, int cch) {
        var mh$ = DragQueryFileA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DragQueryFileA", hDrop, iFile, lpszFile, cch);
            }
            return (int)mh$.invokeExact(hDrop, iFile, lpszFile, cch);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DragQueryFileW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_INT,
            C_POINTER,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("DragQueryFileW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern UINT DragQueryFileW(HDROP hDrop, UINT iFile, LPWSTR lpszFile, UINT cch)
     * }
     */
    public static FunctionDescriptor DragQueryFileW$descriptor() {
        return DragQueryFileW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern UINT DragQueryFileW(HDROP hDrop, UINT iFile, LPWSTR lpszFile, UINT cch)
     * }
     */
    public static MethodHandle DragQueryFileW$handle() {
        return DragQueryFileW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern UINT DragQueryFileW(HDROP hDrop, UINT iFile, LPWSTR lpszFile, UINT cch)
     * }
     */
    public static int DragQueryFileW(MemorySegment hDrop, int iFile, MemorySegment lpszFile, int cch) {
        var mh$ = DragQueryFileW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DragQueryFileW", hDrop, iFile, lpszFile, cch);
            }
            return (int)mh$.invokeExact(hDrop, iFile, lpszFile, cch);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DragQueryPoint {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("DragQueryPoint"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern BOOL DragQueryPoint(HDROP hDrop, POINT *ppt)
     * }
     */
    public static FunctionDescriptor DragQueryPoint$descriptor() {
        return DragQueryPoint.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern BOOL DragQueryPoint(HDROP hDrop, POINT *ppt)
     * }
     */
    public static MethodHandle DragQueryPoint$handle() {
        return DragQueryPoint.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern BOOL DragQueryPoint(HDROP hDrop, POINT *ppt)
     * }
     */
    public static int DragQueryPoint(MemorySegment hDrop, MemorySegment ppt) {
        var mh$ = DragQueryPoint.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DragQueryPoint", hDrop, ppt);
            }
            return (int)mh$.invokeExact(hDrop, ppt);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DragFinish {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("DragFinish"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void DragFinish(HDROP hDrop)
     * }
     */
    public static FunctionDescriptor DragFinish$descriptor() {
        return DragFinish.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void DragFinish(HDROP hDrop)
     * }
     */
    public static MethodHandle DragFinish$handle() {
        return DragFinish.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern void DragFinish(HDROP hDrop)
     * }
     */
    public static void DragFinish(MemorySegment hDrop) {
        var mh$ = DragFinish.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DragFinish", hDrop);
            }
            mh$.invokeExact(hDrop);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DragAcceptFiles {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C_POINTER,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("DragAcceptFiles"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void DragAcceptFiles(HWND hWnd, BOOL fAccept)
     * }
     */
    public static FunctionDescriptor DragAcceptFiles$descriptor() {
        return DragAcceptFiles.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void DragAcceptFiles(HWND hWnd, BOOL fAccept)
     * }
     */
    public static MethodHandle DragAcceptFiles$handle() {
        return DragAcceptFiles.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern void DragAcceptFiles(HWND hWnd, BOOL fAccept)
     * }
     */
    public static void DragAcceptFiles(MemorySegment hWnd, int fAccept) {
        var mh$ = DragAcceptFiles.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DragAcceptFiles", hWnd, fAccept);
            }
            mh$.invokeExact(hWnd, fAccept);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ShellExecuteA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("ShellExecuteA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern HINSTANCE ShellExecuteA(HWND hwnd, LPCSTR lpOperation, LPCSTR lpFile, LPCSTR lpParameters, LPCSTR lpDirectory, INT nShowCmd)
     * }
     */
    public static FunctionDescriptor ShellExecuteA$descriptor() {
        return ShellExecuteA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern HINSTANCE ShellExecuteA(HWND hwnd, LPCSTR lpOperation, LPCSTR lpFile, LPCSTR lpParameters, LPCSTR lpDirectory, INT nShowCmd)
     * }
     */
    public static MethodHandle ShellExecuteA$handle() {
        return ShellExecuteA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern HINSTANCE ShellExecuteA(HWND hwnd, LPCSTR lpOperation, LPCSTR lpFile, LPCSTR lpParameters, LPCSTR lpDirectory, INT nShowCmd)
     * }
     */
    public static MemorySegment ShellExecuteA(MemorySegment hwnd, MemorySegment lpOperation, MemorySegment lpFile, MemorySegment lpParameters, MemorySegment lpDirectory, int nShowCmd) {
        var mh$ = ShellExecuteA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ShellExecuteA", hwnd, lpOperation, lpFile, lpParameters, lpDirectory, nShowCmd);
            }
            return (MemorySegment)mh$.invokeExact(hwnd, lpOperation, lpFile, lpParameters, lpDirectory, nShowCmd);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ShellExecuteW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("ShellExecuteW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern HINSTANCE ShellExecuteW(HWND hwnd, LPCWSTR lpOperation, LPCWSTR lpFile, LPCWSTR lpParameters, LPCWSTR lpDirectory, INT nShowCmd)
     * }
     */
    public static FunctionDescriptor ShellExecuteW$descriptor() {
        return ShellExecuteW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern HINSTANCE ShellExecuteW(HWND hwnd, LPCWSTR lpOperation, LPCWSTR lpFile, LPCWSTR lpParameters, LPCWSTR lpDirectory, INT nShowCmd)
     * }
     */
    public static MethodHandle ShellExecuteW$handle() {
        return ShellExecuteW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern HINSTANCE ShellExecuteW(HWND hwnd, LPCWSTR lpOperation, LPCWSTR lpFile, LPCWSTR lpParameters, LPCWSTR lpDirectory, INT nShowCmd)
     * }
     */
    public static MemorySegment ShellExecuteW(MemorySegment hwnd, MemorySegment lpOperation, MemorySegment lpFile, MemorySegment lpParameters, MemorySegment lpDirectory, int nShowCmd) {
        var mh$ = ShellExecuteW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ShellExecuteW", hwnd, lpOperation, lpFile, lpParameters, lpDirectory, nShowCmd);
            }
            return (MemorySegment)mh$.invokeExact(hwnd, lpOperation, lpFile, lpParameters, lpDirectory, nShowCmd);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FindExecutableA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("FindExecutableA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern HINSTANCE FindExecutableA(LPCSTR lpFile, LPCSTR lpDirectory, LPSTR lpResult)
     * }
     */
    public static FunctionDescriptor FindExecutableA$descriptor() {
        return FindExecutableA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern HINSTANCE FindExecutableA(LPCSTR lpFile, LPCSTR lpDirectory, LPSTR lpResult)
     * }
     */
    public static MethodHandle FindExecutableA$handle() {
        return FindExecutableA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern HINSTANCE FindExecutableA(LPCSTR lpFile, LPCSTR lpDirectory, LPSTR lpResult)
     * }
     */
    public static MemorySegment FindExecutableA(MemorySegment lpFile, MemorySegment lpDirectory, MemorySegment lpResult) {
        var mh$ = FindExecutableA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FindExecutableA", lpFile, lpDirectory, lpResult);
            }
            return (MemorySegment)mh$.invokeExact(lpFile, lpDirectory, lpResult);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FindExecutableW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("FindExecutableW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern HINSTANCE FindExecutableW(LPCWSTR lpFile, LPCWSTR lpDirectory, LPWSTR lpResult)
     * }
     */
    public static FunctionDescriptor FindExecutableW$descriptor() {
        return FindExecutableW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern HINSTANCE FindExecutableW(LPCWSTR lpFile, LPCWSTR lpDirectory, LPWSTR lpResult)
     * }
     */
    public static MethodHandle FindExecutableW$handle() {
        return FindExecutableW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern HINSTANCE FindExecutableW(LPCWSTR lpFile, LPCWSTR lpDirectory, LPWSTR lpResult)
     * }
     */
    public static MemorySegment FindExecutableW(MemorySegment lpFile, MemorySegment lpDirectory, MemorySegment lpResult) {
        var mh$ = FindExecutableW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FindExecutableW", lpFile, lpDirectory, lpResult);
            }
            return (MemorySegment)mh$.invokeExact(lpFile, lpDirectory, lpResult);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ShellAboutA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("ShellAboutA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern INT ShellAboutA(HWND hWnd, LPCSTR szApp, LPCSTR szOtherStuff, HICON hIcon)
     * }
     */
    public static FunctionDescriptor ShellAboutA$descriptor() {
        return ShellAboutA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern INT ShellAboutA(HWND hWnd, LPCSTR szApp, LPCSTR szOtherStuff, HICON hIcon)
     * }
     */
    public static MethodHandle ShellAboutA$handle() {
        return ShellAboutA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern INT ShellAboutA(HWND hWnd, LPCSTR szApp, LPCSTR szOtherStuff, HICON hIcon)
     * }
     */
    public static int ShellAboutA(MemorySegment hWnd, MemorySegment szApp, MemorySegment szOtherStuff, MemorySegment hIcon) {
        var mh$ = ShellAboutA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ShellAboutA", hWnd, szApp, szOtherStuff, hIcon);
            }
            return (int)mh$.invokeExact(hWnd, szApp, szOtherStuff, hIcon);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ShellAboutW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("ShellAboutW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern INT ShellAboutW(HWND hWnd, LPCWSTR szApp, LPCWSTR szOtherStuff, HICON hIcon)
     * }
     */
    public static FunctionDescriptor ShellAboutW$descriptor() {
        return ShellAboutW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern INT ShellAboutW(HWND hWnd, LPCWSTR szApp, LPCWSTR szOtherStuff, HICON hIcon)
     * }
     */
    public static MethodHandle ShellAboutW$handle() {
        return ShellAboutW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern INT ShellAboutW(HWND hWnd, LPCWSTR szApp, LPCWSTR szOtherStuff, HICON hIcon)
     * }
     */
    public static int ShellAboutW(MemorySegment hWnd, MemorySegment szApp, MemorySegment szOtherStuff, MemorySegment hIcon) {
        var mh$ = ShellAboutW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ShellAboutW", hWnd, szApp, szOtherStuff, hIcon);
            }
            return (int)mh$.invokeExact(hWnd, szApp, szOtherStuff, hIcon);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DuplicateIcon {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("DuplicateIcon"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern HICON DuplicateIcon(HINSTANCE hInst, HICON hIcon)
     * }
     */
    public static FunctionDescriptor DuplicateIcon$descriptor() {
        return DuplicateIcon.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern HICON DuplicateIcon(HINSTANCE hInst, HICON hIcon)
     * }
     */
    public static MethodHandle DuplicateIcon$handle() {
        return DuplicateIcon.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern HICON DuplicateIcon(HINSTANCE hInst, HICON hIcon)
     * }
     */
    public static MemorySegment DuplicateIcon(MemorySegment hInst, MemorySegment hIcon) {
        var mh$ = DuplicateIcon.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DuplicateIcon", hInst, hIcon);
            }
            return (MemorySegment)mh$.invokeExact(hInst, hIcon);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ExtractAssociatedIconA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("ExtractAssociatedIconA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern HICON ExtractAssociatedIconA(HINSTANCE hInst, LPSTR pszIconPath, WORD *piIcon)
     * }
     */
    public static FunctionDescriptor ExtractAssociatedIconA$descriptor() {
        return ExtractAssociatedIconA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern HICON ExtractAssociatedIconA(HINSTANCE hInst, LPSTR pszIconPath, WORD *piIcon)
     * }
     */
    public static MethodHandle ExtractAssociatedIconA$handle() {
        return ExtractAssociatedIconA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern HICON ExtractAssociatedIconA(HINSTANCE hInst, LPSTR pszIconPath, WORD *piIcon)
     * }
     */
    public static MemorySegment ExtractAssociatedIconA(MemorySegment hInst, MemorySegment pszIconPath, MemorySegment piIcon) {
        var mh$ = ExtractAssociatedIconA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ExtractAssociatedIconA", hInst, pszIconPath, piIcon);
            }
            return (MemorySegment)mh$.invokeExact(hInst, pszIconPath, piIcon);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ExtractAssociatedIconW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("ExtractAssociatedIconW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern HICON ExtractAssociatedIconW(HINSTANCE hInst, LPWSTR pszIconPath, WORD *piIcon)
     * }
     */
    public static FunctionDescriptor ExtractAssociatedIconW$descriptor() {
        return ExtractAssociatedIconW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern HICON ExtractAssociatedIconW(HINSTANCE hInst, LPWSTR pszIconPath, WORD *piIcon)
     * }
     */
    public static MethodHandle ExtractAssociatedIconW$handle() {
        return ExtractAssociatedIconW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern HICON ExtractAssociatedIconW(HINSTANCE hInst, LPWSTR pszIconPath, WORD *piIcon)
     * }
     */
    public static MemorySegment ExtractAssociatedIconW(MemorySegment hInst, MemorySegment pszIconPath, MemorySegment piIcon) {
        var mh$ = ExtractAssociatedIconW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ExtractAssociatedIconW", hInst, pszIconPath, piIcon);
            }
            return (MemorySegment)mh$.invokeExact(hInst, pszIconPath, piIcon);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ExtractAssociatedIconExA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("ExtractAssociatedIconExA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern HICON ExtractAssociatedIconExA(HINSTANCE hInst, LPSTR pszIconPath, WORD *piIconIndex, WORD *piIconId)
     * }
     */
    public static FunctionDescriptor ExtractAssociatedIconExA$descriptor() {
        return ExtractAssociatedIconExA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern HICON ExtractAssociatedIconExA(HINSTANCE hInst, LPSTR pszIconPath, WORD *piIconIndex, WORD *piIconId)
     * }
     */
    public static MethodHandle ExtractAssociatedIconExA$handle() {
        return ExtractAssociatedIconExA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern HICON ExtractAssociatedIconExA(HINSTANCE hInst, LPSTR pszIconPath, WORD *piIconIndex, WORD *piIconId)
     * }
     */
    public static MemorySegment ExtractAssociatedIconExA(MemorySegment hInst, MemorySegment pszIconPath, MemorySegment piIconIndex, MemorySegment piIconId) {
        var mh$ = ExtractAssociatedIconExA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ExtractAssociatedIconExA", hInst, pszIconPath, piIconIndex, piIconId);
            }
            return (MemorySegment)mh$.invokeExact(hInst, pszIconPath, piIconIndex, piIconId);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ExtractAssociatedIconExW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("ExtractAssociatedIconExW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern HICON ExtractAssociatedIconExW(HINSTANCE hInst, LPWSTR pszIconPath, WORD *piIconIndex, WORD *piIconId)
     * }
     */
    public static FunctionDescriptor ExtractAssociatedIconExW$descriptor() {
        return ExtractAssociatedIconExW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern HICON ExtractAssociatedIconExW(HINSTANCE hInst, LPWSTR pszIconPath, WORD *piIconIndex, WORD *piIconId)
     * }
     */
    public static MethodHandle ExtractAssociatedIconExW$handle() {
        return ExtractAssociatedIconExW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern HICON ExtractAssociatedIconExW(HINSTANCE hInst, LPWSTR pszIconPath, WORD *piIconIndex, WORD *piIconId)
     * }
     */
    public static MemorySegment ExtractAssociatedIconExW(MemorySegment hInst, MemorySegment pszIconPath, MemorySegment piIconIndex, MemorySegment piIconId) {
        var mh$ = ExtractAssociatedIconExW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ExtractAssociatedIconExW", hInst, pszIconPath, piIconIndex, piIconId);
            }
            return (MemorySegment)mh$.invokeExact(hInst, pszIconPath, piIconIndex, piIconId);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ExtractIconA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("ExtractIconA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern HICON ExtractIconA(HINSTANCE hInst, LPCSTR pszExeFileName, UINT nIconIndex)
     * }
     */
    public static FunctionDescriptor ExtractIconA$descriptor() {
        return ExtractIconA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern HICON ExtractIconA(HINSTANCE hInst, LPCSTR pszExeFileName, UINT nIconIndex)
     * }
     */
    public static MethodHandle ExtractIconA$handle() {
        return ExtractIconA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern HICON ExtractIconA(HINSTANCE hInst, LPCSTR pszExeFileName, UINT nIconIndex)
     * }
     */
    public static MemorySegment ExtractIconA(MemorySegment hInst, MemorySegment pszExeFileName, int nIconIndex) {
        var mh$ = ExtractIconA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ExtractIconA", hInst, pszExeFileName, nIconIndex);
            }
            return (MemorySegment)mh$.invokeExact(hInst, pszExeFileName, nIconIndex);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ExtractIconW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("ExtractIconW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern HICON ExtractIconW(HINSTANCE hInst, LPCWSTR pszExeFileName, UINT nIconIndex)
     * }
     */
    public static FunctionDescriptor ExtractIconW$descriptor() {
        return ExtractIconW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern HICON ExtractIconW(HINSTANCE hInst, LPCWSTR pszExeFileName, UINT nIconIndex)
     * }
     */
    public static MethodHandle ExtractIconW$handle() {
        return ExtractIconW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern HICON ExtractIconW(HINSTANCE hInst, LPCWSTR pszExeFileName, UINT nIconIndex)
     * }
     */
    public static MemorySegment ExtractIconW(MemorySegment hInst, MemorySegment pszExeFileName, int nIconIndex) {
        var mh$ = ExtractIconW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ExtractIconW", hInst, pszExeFileName, nIconIndex);
            }
            return (MemorySegment)mh$.invokeExact(hInst, pszExeFileName, nIconIndex);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct _DRAGINFOA {
     *     UINT uSize;
     *     POINT pt;
     *     BOOL fNC;
     *     PZZSTR lpFileList;
     *     DWORD grfKeyState;
     * } *LPDRAGINFOA
     * }
     */
    public static final AddressLayout LPDRAGINFOA = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _DRAGINFOW {
     *     UINT uSize;
     *     POINT pt;
     *     BOOL fNC;
     *     PZZWSTR lpFileList;
     *     DWORD grfKeyState;
     * } *LPDRAGINFOW
     * }
     */
    public static final AddressLayout LPDRAGINFOW = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef LPDRAGINFOA LPDRAGINFO
     * }
     */
    public static final AddressLayout LPDRAGINFO = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _AppBarData {
     *     DWORD cbSize;
     *     HWND hWnd;
     *     UINT uCallbackMessage;
     *     UINT uEdge;
     *     RECT rc;
     *     LPARAM lParam;
     * } *PAPPBARDATA
     * }
     */
    public static final AddressLayout PAPPBARDATA = C_POINTER;

    private static class SHAppBarMessage {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG_LONG,
            C_LONG,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("SHAppBarMessage"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern UINT_PTR SHAppBarMessage(DWORD dwMessage, PAPPBARDATA pData)
     * }
     */
    public static FunctionDescriptor SHAppBarMessage$descriptor() {
        return SHAppBarMessage.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern UINT_PTR SHAppBarMessage(DWORD dwMessage, PAPPBARDATA pData)
     * }
     */
    public static MethodHandle SHAppBarMessage$handle() {
        return SHAppBarMessage.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern UINT_PTR SHAppBarMessage(DWORD dwMessage, PAPPBARDATA pData)
     * }
     */
    public static long SHAppBarMessage(int dwMessage, MemorySegment pData) {
        var mh$ = SHAppBarMessage.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SHAppBarMessage", dwMessage, pData);
            }
            return (long)mh$.invokeExact(dwMessage, pData);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DoEnvironmentSubstA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_POINTER,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("DoEnvironmentSubstA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern DWORD DoEnvironmentSubstA(LPSTR pszSrc, UINT cchSrc)
     * }
     */
    public static FunctionDescriptor DoEnvironmentSubstA$descriptor() {
        return DoEnvironmentSubstA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern DWORD DoEnvironmentSubstA(LPSTR pszSrc, UINT cchSrc)
     * }
     */
    public static MethodHandle DoEnvironmentSubstA$handle() {
        return DoEnvironmentSubstA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern DWORD DoEnvironmentSubstA(LPSTR pszSrc, UINT cchSrc)
     * }
     */
    public static int DoEnvironmentSubstA(MemorySegment pszSrc, int cchSrc) {
        var mh$ = DoEnvironmentSubstA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DoEnvironmentSubstA", pszSrc, cchSrc);
            }
            return (int)mh$.invokeExact(pszSrc, cchSrc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DoEnvironmentSubstW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_POINTER,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("DoEnvironmentSubstW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern DWORD DoEnvironmentSubstW(LPWSTR pszSrc, UINT cchSrc)
     * }
     */
    public static FunctionDescriptor DoEnvironmentSubstW$descriptor() {
        return DoEnvironmentSubstW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern DWORD DoEnvironmentSubstW(LPWSTR pszSrc, UINT cchSrc)
     * }
     */
    public static MethodHandle DoEnvironmentSubstW$handle() {
        return DoEnvironmentSubstW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern DWORD DoEnvironmentSubstW(LPWSTR pszSrc, UINT cchSrc)
     * }
     */
    public static int DoEnvironmentSubstW(MemorySegment pszSrc, int cchSrc) {
        var mh$ = DoEnvironmentSubstW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DoEnvironmentSubstW", pszSrc, cchSrc);
            }
            return (int)mh$.invokeExact(pszSrc, cchSrc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ExtractIconExA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_INT,
            C_POINTER,
            C_POINTER,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("ExtractIconExA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern UINT ExtractIconExA(LPCSTR lpszFile, int nIconIndex, HICON *phiconLarge, HICON *phiconSmall, UINT nIcons)
     * }
     */
    public static FunctionDescriptor ExtractIconExA$descriptor() {
        return ExtractIconExA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern UINT ExtractIconExA(LPCSTR lpszFile, int nIconIndex, HICON *phiconLarge, HICON *phiconSmall, UINT nIcons)
     * }
     */
    public static MethodHandle ExtractIconExA$handle() {
        return ExtractIconExA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern UINT ExtractIconExA(LPCSTR lpszFile, int nIconIndex, HICON *phiconLarge, HICON *phiconSmall, UINT nIcons)
     * }
     */
    public static int ExtractIconExA(MemorySegment lpszFile, int nIconIndex, MemorySegment phiconLarge, MemorySegment phiconSmall, int nIcons) {
        var mh$ = ExtractIconExA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ExtractIconExA", lpszFile, nIconIndex, phiconLarge, phiconSmall, nIcons);
            }
            return (int)mh$.invokeExact(lpszFile, nIconIndex, phiconLarge, phiconSmall, nIcons);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ExtractIconExW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_INT,
            C_POINTER,
            C_POINTER,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("ExtractIconExW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern UINT ExtractIconExW(LPCWSTR lpszFile, int nIconIndex, HICON *phiconLarge, HICON *phiconSmall, UINT nIcons)
     * }
     */
    public static FunctionDescriptor ExtractIconExW$descriptor() {
        return ExtractIconExW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern UINT ExtractIconExW(LPCWSTR lpszFile, int nIconIndex, HICON *phiconLarge, HICON *phiconSmall, UINT nIcons)
     * }
     */
    public static MethodHandle ExtractIconExW$handle() {
        return ExtractIconExW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern UINT ExtractIconExW(LPCWSTR lpszFile, int nIconIndex, HICON *phiconLarge, HICON *phiconSmall, UINT nIcons)
     * }
     */
    public static int ExtractIconExW(MemorySegment lpszFile, int nIconIndex, MemorySegment phiconLarge, MemorySegment phiconSmall, int nIcons) {
        var mh$ = ExtractIconExW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ExtractIconExW", lpszFile, nIconIndex, phiconLarge, phiconSmall, nIcons);
            }
            return (int)mh$.invokeExact(lpszFile, nIconIndex, phiconLarge, phiconSmall, nIcons);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef WORD FILEOP_FLAGS
     * }
     */
    public static final OfShort FILEOP_FLAGS = C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef WORD PRINTEROP_FLAGS
     * }
     */
    public static final OfShort PRINTEROP_FLAGS = C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef struct _SHFILEOPSTRUCTA {
     *     HWND hwnd;
     *     UINT wFunc;
     *     PCZZSTR pFrom;
     *     PCZZSTR pTo;
     *     FILEOP_FLAGS fFlags;
     *     BOOL fAnyOperationsAborted;
     *     LPVOID hNameMappings;
     *     PCSTR lpszProgressTitle;
     * } *LPSHFILEOPSTRUCTA
     * }
     */
    public static final AddressLayout LPSHFILEOPSTRUCTA = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _SHFILEOPSTRUCTW {
     *     HWND hwnd;
     *     UINT wFunc;
     *     PCZZWSTR pFrom;
     *     PCZZWSTR pTo;
     *     FILEOP_FLAGS fFlags;
     *     BOOL fAnyOperationsAborted;
     *     LPVOID hNameMappings;
     *     PCWSTR lpszProgressTitle;
     * } *LPSHFILEOPSTRUCTW
     * }
     */
    public static final AddressLayout LPSHFILEOPSTRUCTW = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef LPSHFILEOPSTRUCTA LPSHFILEOPSTRUCT
     * }
     */
    public static final AddressLayout LPSHFILEOPSTRUCT = C_POINTER;

    private static class SHFileOperationA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("SHFileOperationA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int SHFileOperationA(LPSHFILEOPSTRUCTA lpFileOp)
     * }
     */
    public static FunctionDescriptor SHFileOperationA$descriptor() {
        return SHFileOperationA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int SHFileOperationA(LPSHFILEOPSTRUCTA lpFileOp)
     * }
     */
    public static MethodHandle SHFileOperationA$handle() {
        return SHFileOperationA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern int SHFileOperationA(LPSHFILEOPSTRUCTA lpFileOp)
     * }
     */
    public static int SHFileOperationA(MemorySegment lpFileOp) {
        var mh$ = SHFileOperationA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SHFileOperationA", lpFileOp);
            }
            return (int)mh$.invokeExact(lpFileOp);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SHFileOperationW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("SHFileOperationW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int SHFileOperationW(LPSHFILEOPSTRUCTW lpFileOp)
     * }
     */
    public static FunctionDescriptor SHFileOperationW$descriptor() {
        return SHFileOperationW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int SHFileOperationW(LPSHFILEOPSTRUCTW lpFileOp)
     * }
     */
    public static MethodHandle SHFileOperationW$handle() {
        return SHFileOperationW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern int SHFileOperationW(LPSHFILEOPSTRUCTW lpFileOp)
     * }
     */
    public static int SHFileOperationW(MemorySegment lpFileOp) {
        var mh$ = SHFileOperationW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SHFileOperationW", lpFileOp);
            }
            return (int)mh$.invokeExact(lpFileOp);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SHFreeNameMappings {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("SHFreeNameMappings"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void SHFreeNameMappings(HANDLE hNameMappings)
     * }
     */
    public static FunctionDescriptor SHFreeNameMappings$descriptor() {
        return SHFreeNameMappings.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void SHFreeNameMappings(HANDLE hNameMappings)
     * }
     */
    public static MethodHandle SHFreeNameMappings$handle() {
        return SHFreeNameMappings.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern void SHFreeNameMappings(HANDLE hNameMappings)
     * }
     */
    public static void SHFreeNameMappings(MemorySegment hNameMappings) {
        var mh$ = SHFreeNameMappings.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SHFreeNameMappings", hNameMappings);
            }
            mh$.invokeExact(hNameMappings);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct _SHNAMEMAPPINGA {
     *     LPSTR pszOldPath;
     *     LPSTR pszNewPath;
     *     int cchOldPath;
     *     int cchNewPath;
     * } *LPSHNAMEMAPPINGA
     * }
     */
    public static final AddressLayout LPSHNAMEMAPPINGA = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _SHNAMEMAPPINGW {
     *     LPWSTR pszOldPath;
     *     LPWSTR pszNewPath;
     *     int cchOldPath;
     *     int cchNewPath;
     * } *LPSHNAMEMAPPINGW
     * }
     */
    public static final AddressLayout LPSHNAMEMAPPINGW = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef LPSHNAMEMAPPINGA LPSHNAMEMAPPING
     * }
     */
    public static final AddressLayout LPSHNAMEMAPPING = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _SHELLEXECUTEINFOA {
     *     DWORD cbSize;
     *     ULONG fMask;
     *     HWND hwnd;
     *     LPCSTR lpVerb;
     *     LPCSTR lpFile;
     *     LPCSTR lpParameters;
     *     LPCSTR lpDirectory;
     *     int nShow;
     *     HINSTANCE hInstApp;
     *     void *lpIDList;
     *     LPCSTR lpClass;
     *     HKEY hkeyClass;
     *     DWORD dwHotKey;
     *     union {
     *         HANDLE hIcon;
     *         HANDLE hMonitor;
     *     };
     *     HANDLE hProcess;
     * } *LPSHELLEXECUTEINFOA
     * }
     */
    public static final AddressLayout LPSHELLEXECUTEINFOA = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _SHELLEXECUTEINFOW {
     *     DWORD cbSize;
     *     ULONG fMask;
     *     HWND hwnd;
     *     LPCWSTR lpVerb;
     *     LPCWSTR lpFile;
     *     LPCWSTR lpParameters;
     *     LPCWSTR lpDirectory;
     *     int nShow;
     *     HINSTANCE hInstApp;
     *     void *lpIDList;
     *     LPCWSTR lpClass;
     *     HKEY hkeyClass;
     *     DWORD dwHotKey;
     *     union {
     *         HANDLE hIcon;
     *         HANDLE hMonitor;
     *     };
     *     HANDLE hProcess;
     * } *LPSHELLEXECUTEINFOW
     * }
     */
    public static final AddressLayout LPSHELLEXECUTEINFOW = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef LPSHELLEXECUTEINFOA LPSHELLEXECUTEINFO
     * }
     */
    public static final AddressLayout LPSHELLEXECUTEINFO = C_POINTER;

    private static class ShellExecuteExA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("ShellExecuteExA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern BOOL ShellExecuteExA(SHELLEXECUTEINFOA *pExecInfo)
     * }
     */
    public static FunctionDescriptor ShellExecuteExA$descriptor() {
        return ShellExecuteExA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern BOOL ShellExecuteExA(SHELLEXECUTEINFOA *pExecInfo)
     * }
     */
    public static MethodHandle ShellExecuteExA$handle() {
        return ShellExecuteExA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern BOOL ShellExecuteExA(SHELLEXECUTEINFOA *pExecInfo)
     * }
     */
    public static int ShellExecuteExA(MemorySegment pExecInfo) {
        var mh$ = ShellExecuteExA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ShellExecuteExA", pExecInfo);
            }
            return (int)mh$.invokeExact(pExecInfo);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ShellExecuteExW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("ShellExecuteExW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern BOOL ShellExecuteExW(SHELLEXECUTEINFOW *pExecInfo)
     * }
     */
    public static FunctionDescriptor ShellExecuteExW$descriptor() {
        return ShellExecuteExW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern BOOL ShellExecuteExW(SHELLEXECUTEINFOW *pExecInfo)
     * }
     */
    public static MethodHandle ShellExecuteExW$handle() {
        return ShellExecuteExW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern BOOL ShellExecuteExW(SHELLEXECUTEINFOW *pExecInfo)
     * }
     */
    public static int ShellExecuteExW(MemorySegment pExecInfo) {
        var mh$ = ShellExecuteExW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ShellExecuteExW", pExecInfo);
            }
            return (int)mh$.invokeExact(pExecInfo);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct _SHCREATEPROCESSINFOW {
     *     DWORD cbSize;
     *     ULONG fMask;
     *     HWND hwnd;
     *     LPCWSTR pszFile;
     *     LPCWSTR pszParameters;
     *     LPCWSTR pszCurrentDirectory;
     *     HANDLE hUserToken;
     *     LPSECURITY_ATTRIBUTES lpProcessAttributes;
     *     LPSECURITY_ATTRIBUTES lpThreadAttributes;
     *     BOOL bInheritHandles;
     *     DWORD dwCreationFlags;
     *     LPSTARTUPINFOW lpStartupInfo;
     *     LPPROCESS_INFORMATION lpProcessInformation;
     * } *PSHCREATEPROCESSINFOW
     * }
     */
    public static final AddressLayout PSHCREATEPROCESSINFOW = C_POINTER;

    private static class SHCreateProcessAsUserW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("SHCreateProcessAsUserW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern BOOL SHCreateProcessAsUserW(PSHCREATEPROCESSINFOW pscpi)
     * }
     */
    public static FunctionDescriptor SHCreateProcessAsUserW$descriptor() {
        return SHCreateProcessAsUserW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern BOOL SHCreateProcessAsUserW(PSHCREATEPROCESSINFOW pscpi)
     * }
     */
    public static MethodHandle SHCreateProcessAsUserW$handle() {
        return SHCreateProcessAsUserW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern BOOL SHCreateProcessAsUserW(PSHCREATEPROCESSINFOW pscpi)
     * }
     */
    public static int SHCreateProcessAsUserW(MemorySegment pscpi) {
        var mh$ = SHCreateProcessAsUserW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SHCreateProcessAsUserW", pscpi);
            }
            return (int)mh$.invokeExact(pscpi);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SHEvaluateSystemCommandTemplate {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("SHEvaluateSystemCommandTemplate"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern HRESULT SHEvaluateSystemCommandTemplate(PCWSTR pszCmdTemplate, PWSTR *ppszApplication, PWSTR *ppszCommandLine, PWSTR *ppszParameters)
     * }
     */
    public static FunctionDescriptor SHEvaluateSystemCommandTemplate$descriptor() {
        return SHEvaluateSystemCommandTemplate.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern HRESULT SHEvaluateSystemCommandTemplate(PCWSTR pszCmdTemplate, PWSTR *ppszApplication, PWSTR *ppszCommandLine, PWSTR *ppszParameters)
     * }
     */
    public static MethodHandle SHEvaluateSystemCommandTemplate$handle() {
        return SHEvaluateSystemCommandTemplate.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern HRESULT SHEvaluateSystemCommandTemplate(PCWSTR pszCmdTemplate, PWSTR *ppszApplication, PWSTR *ppszCommandLine, PWSTR *ppszParameters)
     * }
     */
    public static int SHEvaluateSystemCommandTemplate(MemorySegment pszCmdTemplate, MemorySegment ppszApplication, MemorySegment ppszCommandLine, MemorySegment ppszParameters) {
        var mh$ = SHEvaluateSystemCommandTemplate.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SHEvaluateSystemCommandTemplate", pszCmdTemplate, ppszApplication, ppszCommandLine, ppszParameters);
            }
            return (int)mh$.invokeExact(pszCmdTemplate, ppszApplication, ppszCommandLine, ppszParameters);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int ASSOCCLASS_SHELL_KEY = (int)0L;
    /**
     * {@snippet lang=c :
     * enum ASSOCCLASS.ASSOCCLASS_SHELL_KEY = 0
     * }
     */
    public static int ASSOCCLASS_SHELL_KEY() {
        return ASSOCCLASS_SHELL_KEY;
    }
    private static final int ASSOCCLASS_PROGID_KEY = (int)1L;
    /**
     * {@snippet lang=c :
     * enum ASSOCCLASS.ASSOCCLASS_PROGID_KEY = 1
     * }
     */
    public static int ASSOCCLASS_PROGID_KEY() {
        return ASSOCCLASS_PROGID_KEY;
    }
    private static final int ASSOCCLASS_PROGID_STR = (int)2L;
    /**
     * {@snippet lang=c :
     * enum ASSOCCLASS.ASSOCCLASS_PROGID_STR = 2
     * }
     */
    public static int ASSOCCLASS_PROGID_STR() {
        return ASSOCCLASS_PROGID_STR;
    }
    private static final int ASSOCCLASS_CLSID_KEY = (int)3L;
    /**
     * {@snippet lang=c :
     * enum ASSOCCLASS.ASSOCCLASS_CLSID_KEY = 3
     * }
     */
    public static int ASSOCCLASS_CLSID_KEY() {
        return ASSOCCLASS_CLSID_KEY;
    }
    private static final int ASSOCCLASS_CLSID_STR = (int)4L;
    /**
     * {@snippet lang=c :
     * enum ASSOCCLASS.ASSOCCLASS_CLSID_STR = 4
     * }
     */
    public static int ASSOCCLASS_CLSID_STR() {
        return ASSOCCLASS_CLSID_STR;
    }
    private static final int ASSOCCLASS_APP_KEY = (int)5L;
    /**
     * {@snippet lang=c :
     * enum ASSOCCLASS.ASSOCCLASS_APP_KEY = 5
     * }
     */
    public static int ASSOCCLASS_APP_KEY() {
        return ASSOCCLASS_APP_KEY;
    }
    private static final int ASSOCCLASS_APP_STR = (int)6L;
    /**
     * {@snippet lang=c :
     * enum ASSOCCLASS.ASSOCCLASS_APP_STR = 6
     * }
     */
    public static int ASSOCCLASS_APP_STR() {
        return ASSOCCLASS_APP_STR;
    }
    private static final int ASSOCCLASS_SYSTEM_STR = (int)7L;
    /**
     * {@snippet lang=c :
     * enum ASSOCCLASS.ASSOCCLASS_SYSTEM_STR = 7
     * }
     */
    public static int ASSOCCLASS_SYSTEM_STR() {
        return ASSOCCLASS_SYSTEM_STR;
    }
    private static final int ASSOCCLASS_FOLDER = (int)8L;
    /**
     * {@snippet lang=c :
     * enum ASSOCCLASS.ASSOCCLASS_FOLDER = 8
     * }
     */
    public static int ASSOCCLASS_FOLDER() {
        return ASSOCCLASS_FOLDER;
    }
    private static final int ASSOCCLASS_STAR = (int)9L;
    /**
     * {@snippet lang=c :
     * enum ASSOCCLASS.ASSOCCLASS_STAR = 9
     * }
     */
    public static int ASSOCCLASS_STAR() {
        return ASSOCCLASS_STAR;
    }
    private static final int ASSOCCLASS_FIXED_PROGID_STR = (int)10L;
    /**
     * {@snippet lang=c :
     * enum ASSOCCLASS.ASSOCCLASS_FIXED_PROGID_STR = 10
     * }
     */
    public static int ASSOCCLASS_FIXED_PROGID_STR() {
        return ASSOCCLASS_FIXED_PROGID_STR;
    }
    private static final int ASSOCCLASS_PROTOCOL_STR = (int)11L;
    /**
     * {@snippet lang=c :
     * enum ASSOCCLASS.ASSOCCLASS_PROTOCOL_STR = 11
     * }
     */
    public static int ASSOCCLASS_PROTOCOL_STR() {
        return ASSOCCLASS_PROTOCOL_STR;
    }

    private static class AssocCreateForClasses {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_POINTER,
            C_LONG,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("AssocCreateForClasses"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern HRESULT AssocCreateForClasses(const ASSOCIATIONELEMENT *rgClasses, ULONG cClasses, const IID *const riid, void **ppv)
     * }
     */
    public static FunctionDescriptor AssocCreateForClasses$descriptor() {
        return AssocCreateForClasses.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern HRESULT AssocCreateForClasses(const ASSOCIATIONELEMENT *rgClasses, ULONG cClasses, const IID *const riid, void **ppv)
     * }
     */
    public static MethodHandle AssocCreateForClasses$handle() {
        return AssocCreateForClasses.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern HRESULT AssocCreateForClasses(const ASSOCIATIONELEMENT *rgClasses, ULONG cClasses, const IID *const riid, void **ppv)
     * }
     */
    public static int AssocCreateForClasses(MemorySegment rgClasses, int cClasses, MemorySegment riid, MemorySegment ppv) {
        var mh$ = AssocCreateForClasses.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("AssocCreateForClasses", rgClasses, cClasses, riid, ppv);
            }
            return (int)mh$.invokeExact(rgClasses, cClasses, riid, ppv);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct _SHQUERYRBINFO {
     *     DWORD cbSize;
     *     long long i64Size;
     *     long long i64NumItems;
     * } *LPSHQUERYRBINFO
     * }
     */
    public static final AddressLayout LPSHQUERYRBINFO = C_POINTER;

    private static class SHQueryRecycleBinA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("SHQueryRecycleBinA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern HRESULT SHQueryRecycleBinA(LPCSTR pszRootPath, LPSHQUERYRBINFO pSHQueryRBInfo)
     * }
     */
    public static FunctionDescriptor SHQueryRecycleBinA$descriptor() {
        return SHQueryRecycleBinA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern HRESULT SHQueryRecycleBinA(LPCSTR pszRootPath, LPSHQUERYRBINFO pSHQueryRBInfo)
     * }
     */
    public static MethodHandle SHQueryRecycleBinA$handle() {
        return SHQueryRecycleBinA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern HRESULT SHQueryRecycleBinA(LPCSTR pszRootPath, LPSHQUERYRBINFO pSHQueryRBInfo)
     * }
     */
    public static int SHQueryRecycleBinA(MemorySegment pszRootPath, MemorySegment pSHQueryRBInfo) {
        var mh$ = SHQueryRecycleBinA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SHQueryRecycleBinA", pszRootPath, pSHQueryRBInfo);
            }
            return (int)mh$.invokeExact(pszRootPath, pSHQueryRBInfo);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SHQueryRecycleBinW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("SHQueryRecycleBinW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern HRESULT SHQueryRecycleBinW(LPCWSTR pszRootPath, LPSHQUERYRBINFO pSHQueryRBInfo)
     * }
     */
    public static FunctionDescriptor SHQueryRecycleBinW$descriptor() {
        return SHQueryRecycleBinW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern HRESULT SHQueryRecycleBinW(LPCWSTR pszRootPath, LPSHQUERYRBINFO pSHQueryRBInfo)
     * }
     */
    public static MethodHandle SHQueryRecycleBinW$handle() {
        return SHQueryRecycleBinW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern HRESULT SHQueryRecycleBinW(LPCWSTR pszRootPath, LPSHQUERYRBINFO pSHQueryRBInfo)
     * }
     */
    public static int SHQueryRecycleBinW(MemorySegment pszRootPath, MemorySegment pSHQueryRBInfo) {
        var mh$ = SHQueryRecycleBinW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SHQueryRecycleBinW", pszRootPath, pSHQueryRBInfo);
            }
            return (int)mh$.invokeExact(pszRootPath, pSHQueryRBInfo);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SHEmptyRecycleBinA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_POINTER,
            C_POINTER,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("SHEmptyRecycleBinA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern HRESULT SHEmptyRecycleBinA(HWND hwnd, LPCSTR pszRootPath, DWORD dwFlags)
     * }
     */
    public static FunctionDescriptor SHEmptyRecycleBinA$descriptor() {
        return SHEmptyRecycleBinA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern HRESULT SHEmptyRecycleBinA(HWND hwnd, LPCSTR pszRootPath, DWORD dwFlags)
     * }
     */
    public static MethodHandle SHEmptyRecycleBinA$handle() {
        return SHEmptyRecycleBinA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern HRESULT SHEmptyRecycleBinA(HWND hwnd, LPCSTR pszRootPath, DWORD dwFlags)
     * }
     */
    public static int SHEmptyRecycleBinA(MemorySegment hwnd, MemorySegment pszRootPath, int dwFlags) {
        var mh$ = SHEmptyRecycleBinA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SHEmptyRecycleBinA", hwnd, pszRootPath, dwFlags);
            }
            return (int)mh$.invokeExact(hwnd, pszRootPath, dwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SHEmptyRecycleBinW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_POINTER,
            C_POINTER,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("SHEmptyRecycleBinW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern HRESULT SHEmptyRecycleBinW(HWND hwnd, LPCWSTR pszRootPath, DWORD dwFlags)
     * }
     */
    public static FunctionDescriptor SHEmptyRecycleBinW$descriptor() {
        return SHEmptyRecycleBinW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern HRESULT SHEmptyRecycleBinW(HWND hwnd, LPCWSTR pszRootPath, DWORD dwFlags)
     * }
     */
    public static MethodHandle SHEmptyRecycleBinW$handle() {
        return SHEmptyRecycleBinW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern HRESULT SHEmptyRecycleBinW(HWND hwnd, LPCWSTR pszRootPath, DWORD dwFlags)
     * }
     */
    public static int SHEmptyRecycleBinW(MemorySegment hwnd, MemorySegment pszRootPath, int dwFlags) {
        var mh$ = SHEmptyRecycleBinW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SHEmptyRecycleBinW", hwnd, pszRootPath, dwFlags);
            }
            return (int)mh$.invokeExact(hwnd, pszRootPath, dwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int QUNS_NOT_PRESENT = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.QUNS_NOT_PRESENT = 1
     * }
     */
    public static int QUNS_NOT_PRESENT() {
        return QUNS_NOT_PRESENT;
    }
    private static final int QUNS_BUSY = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.QUNS_BUSY = 2
     * }
     */
    public static int QUNS_BUSY() {
        return QUNS_BUSY;
    }
    private static final int QUNS_RUNNING_D3D_FULL_SCREEN = (int)3L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.QUNS_RUNNING_D3D_FULL_SCREEN = 3
     * }
     */
    public static int QUNS_RUNNING_D3D_FULL_SCREEN() {
        return QUNS_RUNNING_D3D_FULL_SCREEN;
    }
    private static final int QUNS_PRESENTATION_MODE = (int)4L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.QUNS_PRESENTATION_MODE = 4
     * }
     */
    public static int QUNS_PRESENTATION_MODE() {
        return QUNS_PRESENTATION_MODE;
    }
    private static final int QUNS_ACCEPTS_NOTIFICATIONS = (int)5L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.QUNS_ACCEPTS_NOTIFICATIONS = 5
     * }
     */
    public static int QUNS_ACCEPTS_NOTIFICATIONS() {
        return QUNS_ACCEPTS_NOTIFICATIONS;
    }
    private static final int QUNS_QUIET_TIME = (int)6L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.QUNS_QUIET_TIME = 6
     * }
     */
    public static int QUNS_QUIET_TIME() {
        return QUNS_QUIET_TIME;
    }
    private static final int QUNS_APP = (int)7L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.QUNS_APP = 7
     * }
     */
    public static int QUNS_APP() {
        return QUNS_APP;
    }

    private static class SHQueryUserNotificationState {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("SHQueryUserNotificationState"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern HRESULT SHQueryUserNotificationState(QUERY_USER_NOTIFICATION_STATE *pquns)
     * }
     */
    public static FunctionDescriptor SHQueryUserNotificationState$descriptor() {
        return SHQueryUserNotificationState.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern HRESULT SHQueryUserNotificationState(QUERY_USER_NOTIFICATION_STATE *pquns)
     * }
     */
    public static MethodHandle SHQueryUserNotificationState$handle() {
        return SHQueryUserNotificationState.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern HRESULT SHQueryUserNotificationState(QUERY_USER_NOTIFICATION_STATE *pquns)
     * }
     */
    public static int SHQueryUserNotificationState(MemorySegment pquns) {
        var mh$ = SHQueryUserNotificationState.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SHQueryUserNotificationState", pquns);
            }
            return (int)mh$.invokeExact(pquns);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SHGetPropertyStoreForWindow {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("SHGetPropertyStoreForWindow"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern HRESULT SHGetPropertyStoreForWindow(HWND hwnd, const IID *const riid, void **ppv)
     * }
     */
    public static FunctionDescriptor SHGetPropertyStoreForWindow$descriptor() {
        return SHGetPropertyStoreForWindow.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern HRESULT SHGetPropertyStoreForWindow(HWND hwnd, const IID *const riid, void **ppv)
     * }
     */
    public static MethodHandle SHGetPropertyStoreForWindow$handle() {
        return SHGetPropertyStoreForWindow.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern HRESULT SHGetPropertyStoreForWindow(HWND hwnd, const IID *const riid, void **ppv)
     * }
     */
    public static int SHGetPropertyStoreForWindow(MemorySegment hwnd, MemorySegment riid, MemorySegment ppv) {
        var mh$ = SHGetPropertyStoreForWindow.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SHGetPropertyStoreForWindow", hwnd, riid, ppv);
            }
            return (int)mh$.invokeExact(hwnd, riid, ppv);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct _NOTIFYICONDATAA {
     *     DWORD cbSize;
     *     HWND hWnd;
     *     UINT uID;
     *     UINT uFlags;
     *     UINT uCallbackMessage;
     *     HICON hIcon;
     *     CHAR szTip[128];
     *     DWORD dwState;
     *     DWORD dwStateMask;
     *     CHAR szInfo[256];
     *     union {
     *         UINT uTimeout;
     *         UINT uVersion;
     *     };
     *     CHAR szInfoTitle[64];
     *     DWORD dwInfoFlags;
     *     GUID guidItem;
     *     HICON hBalloonIcon;
     * } *PNOTIFYICONDATAA
     * }
     */
    public static final AddressLayout PNOTIFYICONDATAA = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _NOTIFYICONDATAW {
     *     DWORD cbSize;
     *     HWND hWnd;
     *     UINT uID;
     *     UINT uFlags;
     *     UINT uCallbackMessage;
     *     HICON hIcon;
     *     WCHAR szTip[128];
     *     DWORD dwState;
     *     DWORD dwStateMask;
     *     WCHAR szInfo[256];
     *     union {
     *         UINT uTimeout;
     *         UINT uVersion;
     *     };
     *     WCHAR szInfoTitle[64];
     *     DWORD dwInfoFlags;
     *     GUID guidItem;
     *     HICON hBalloonIcon;
     * } *PNOTIFYICONDATAW
     * }
     */
    public static final AddressLayout PNOTIFYICONDATAW = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef PNOTIFYICONDATAA PNOTIFYICONDATA
     * }
     */
    public static final AddressLayout PNOTIFYICONDATA = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _NOTIFYICONIDENTIFIER {
     *     DWORD cbSize;
     *     HWND hWnd;
     *     UINT uID;
     *     GUID guidItem;
     * } *PNOTIFYICONIDENTIFIER
     * }
     */
    public static final AddressLayout PNOTIFYICONIDENTIFIER = C_POINTER;

    private static class Shell_NotifyIconA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_LONG,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("Shell_NotifyIconA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern BOOL Shell_NotifyIconA(DWORD dwMessage, PNOTIFYICONDATAA lpData)
     * }
     */
    public static FunctionDescriptor Shell_NotifyIconA$descriptor() {
        return Shell_NotifyIconA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern BOOL Shell_NotifyIconA(DWORD dwMessage, PNOTIFYICONDATAA lpData)
     * }
     */
    public static MethodHandle Shell_NotifyIconA$handle() {
        return Shell_NotifyIconA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern BOOL Shell_NotifyIconA(DWORD dwMessage, PNOTIFYICONDATAA lpData)
     * }
     */
    public static int Shell_NotifyIconA(int dwMessage, MemorySegment lpData) {
        var mh$ = Shell_NotifyIconA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Shell_NotifyIconA", dwMessage, lpData);
            }
            return (int)mh$.invokeExact(dwMessage, lpData);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Shell_NotifyIconW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_LONG,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("Shell_NotifyIconW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern BOOL Shell_NotifyIconW(DWORD dwMessage, PNOTIFYICONDATAW lpData)
     * }
     */
    public static FunctionDescriptor Shell_NotifyIconW$descriptor() {
        return Shell_NotifyIconW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern BOOL Shell_NotifyIconW(DWORD dwMessage, PNOTIFYICONDATAW lpData)
     * }
     */
    public static MethodHandle Shell_NotifyIconW$handle() {
        return Shell_NotifyIconW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern BOOL Shell_NotifyIconW(DWORD dwMessage, PNOTIFYICONDATAW lpData)
     * }
     */
    public static int Shell_NotifyIconW(int dwMessage, MemorySegment lpData) {
        var mh$ = Shell_NotifyIconW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Shell_NotifyIconW", dwMessage, lpData);
            }
            return (int)mh$.invokeExact(dwMessage, lpData);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Shell_NotifyIconGetRect {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("Shell_NotifyIconGetRect"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern HRESULT Shell_NotifyIconGetRect(const NOTIFYICONIDENTIFIER *identifier, RECT *iconLocation)
     * }
     */
    public static FunctionDescriptor Shell_NotifyIconGetRect$descriptor() {
        return Shell_NotifyIconGetRect.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern HRESULT Shell_NotifyIconGetRect(const NOTIFYICONIDENTIFIER *identifier, RECT *iconLocation)
     * }
     */
    public static MethodHandle Shell_NotifyIconGetRect$handle() {
        return Shell_NotifyIconGetRect.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern HRESULT Shell_NotifyIconGetRect(const NOTIFYICONIDENTIFIER *identifier, RECT *iconLocation)
     * }
     */
    public static int Shell_NotifyIconGetRect(MemorySegment identifier, MemorySegment iconLocation) {
        var mh$ = Shell_NotifyIconGetRect.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Shell_NotifyIconGetRect", identifier, iconLocation);
            }
            return (int)mh$.invokeExact(identifier, iconLocation);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SHGetFileInfoA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG_LONG,
            C_POINTER,
            C_LONG,
            C_POINTER,
            C_INT,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("SHGetFileInfoA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern DWORD_PTR SHGetFileInfoA(LPCSTR pszPath, DWORD dwFileAttributes, SHFILEINFOA *psfi, UINT cbFileInfo, UINT uFlags)
     * }
     */
    public static FunctionDescriptor SHGetFileInfoA$descriptor() {
        return SHGetFileInfoA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern DWORD_PTR SHGetFileInfoA(LPCSTR pszPath, DWORD dwFileAttributes, SHFILEINFOA *psfi, UINT cbFileInfo, UINT uFlags)
     * }
     */
    public static MethodHandle SHGetFileInfoA$handle() {
        return SHGetFileInfoA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern DWORD_PTR SHGetFileInfoA(LPCSTR pszPath, DWORD dwFileAttributes, SHFILEINFOA *psfi, UINT cbFileInfo, UINT uFlags)
     * }
     */
    public static long SHGetFileInfoA(MemorySegment pszPath, int dwFileAttributes, MemorySegment psfi, int cbFileInfo, int uFlags) {
        var mh$ = SHGetFileInfoA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SHGetFileInfoA", pszPath, dwFileAttributes, psfi, cbFileInfo, uFlags);
            }
            return (long)mh$.invokeExact(pszPath, dwFileAttributes, psfi, cbFileInfo, uFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SHGetFileInfoW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG_LONG,
            C_POINTER,
            C_LONG,
            C_POINTER,
            C_INT,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("SHGetFileInfoW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern DWORD_PTR SHGetFileInfoW(LPCWSTR pszPath, DWORD dwFileAttributes, SHFILEINFOW *psfi, UINT cbFileInfo, UINT uFlags)
     * }
     */
    public static FunctionDescriptor SHGetFileInfoW$descriptor() {
        return SHGetFileInfoW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern DWORD_PTR SHGetFileInfoW(LPCWSTR pszPath, DWORD dwFileAttributes, SHFILEINFOW *psfi, UINT cbFileInfo, UINT uFlags)
     * }
     */
    public static MethodHandle SHGetFileInfoW$handle() {
        return SHGetFileInfoW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern DWORD_PTR SHGetFileInfoW(LPCWSTR pszPath, DWORD dwFileAttributes, SHFILEINFOW *psfi, UINT cbFileInfo, UINT uFlags)
     * }
     */
    public static long SHGetFileInfoW(MemorySegment pszPath, int dwFileAttributes, MemorySegment psfi, int cbFileInfo, int uFlags) {
        var mh$ = SHGetFileInfoW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SHGetFileInfoW", pszPath, dwFileAttributes, psfi, cbFileInfo, uFlags);
            }
            return (long)mh$.invokeExact(pszPath, dwFileAttributes, psfi, cbFileInfo, uFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int SIID_DOCNOASSOC = (int)0L;
    /**
     * {@snippet lang=c :
     * enum SHSTOCKICONID.SIID_DOCNOASSOC = 0
     * }
     */
    public static int SIID_DOCNOASSOC() {
        return SIID_DOCNOASSOC;
    }
    private static final int SIID_DOCASSOC = (int)1L;
    /**
     * {@snippet lang=c :
     * enum SHSTOCKICONID.SIID_DOCASSOC = 1
     * }
     */
    public static int SIID_DOCASSOC() {
        return SIID_DOCASSOC;
    }
    private static final int SIID_APPLICATION = (int)2L;
    /**
     * {@snippet lang=c :
     * enum SHSTOCKICONID.SIID_APPLICATION = 2
     * }
     */
    public static int SIID_APPLICATION() {
        return SIID_APPLICATION;
    }
    private static final int SIID_FOLDER = (int)3L;
    /**
     * {@snippet lang=c :
     * enum SHSTOCKICONID.SIID_FOLDER = 3
     * }
     */
    public static int SIID_FOLDER() {
        return SIID_FOLDER;
    }
    private static final int SIID_FOLDEROPEN = (int)4L;
    /**
     * {@snippet lang=c :
     * enum SHSTOCKICONID.SIID_FOLDEROPEN = 4
     * }
     */
    public static int SIID_FOLDEROPEN() {
        return SIID_FOLDEROPEN;
    }
    private static final int SIID_DRIVE525 = (int)5L;
    /**
     * {@snippet lang=c :
     * enum SHSTOCKICONID.SIID_DRIVE525 = 5
     * }
     */
    public static int SIID_DRIVE525() {
        return SIID_DRIVE525;
    }
    private static final int SIID_DRIVE35 = (int)6L;
    /**
     * {@snippet lang=c :
     * enum SHSTOCKICONID.SIID_DRIVE35 = 6
     * }
     */
    public static int SIID_DRIVE35() {
        return SIID_DRIVE35;
    }
    private static final int SIID_DRIVEREMOVE = (int)7L;
    /**
     * {@snippet lang=c :
     * enum SHSTOCKICONID.SIID_DRIVEREMOVE = 7
     * }
     */
    public static int SIID_DRIVEREMOVE() {
        return SIID_DRIVEREMOVE;
    }
    private static final int SIID_DRIVEFIXED = (int)8L;
    /**
     * {@snippet lang=c :
     * enum SHSTOCKICONID.SIID_DRIVEFIXED = 8
     * }
     */
    public static int SIID_DRIVEFIXED() {
        return SIID_DRIVEFIXED;
    }
    private static final int SIID_DRIVENET = (int)9L;
    /**
     * {@snippet lang=c :
     * enum SHSTOCKICONID.SIID_DRIVENET = 9
     * }
     */
    public static int SIID_DRIVENET() {
        return SIID_DRIVENET;
    }
    private static final int SIID_DRIVENETDISABLED = (int)10L;
    /**
     * {@snippet lang=c :
     * enum SHSTOCKICONID.SIID_DRIVENETDISABLED = 10
     * }
     */
    public static int SIID_DRIVENETDISABLED() {
        return SIID_DRIVENETDISABLED;
    }
    private static final int SIID_DRIVECD = (int)11L;
    /**
     * {@snippet lang=c :
     * enum SHSTOCKICONID.SIID_DRIVECD = 11
     * }
     */
    public static int SIID_DRIVECD() {
        return SIID_DRIVECD;
    }
    private static final int SIID_DRIVERAM = (int)12L;
    /**
     * {@snippet lang=c :
     * enum SHSTOCKICONID.SIID_DRIVERAM = 12
     * }
     */
    public static int SIID_DRIVERAM() {
        return SIID_DRIVERAM;
    }
    private static final int SIID_WORLD = (int)13L;
    /**
     * {@snippet lang=c :
     * enum SHSTOCKICONID.SIID_WORLD = 13
     * }
     */
    public static int SIID_WORLD() {
        return SIID_WORLD;
    }
    private static final int SIID_SERVER = (int)15L;
    /**
     * {@snippet lang=c :
     * enum SHSTOCKICONID.SIID_SERVER = 15
     * }
     */
    public static int SIID_SERVER() {
        return SIID_SERVER;
    }
    private static final int SIID_PRINTER = (int)16L;
    /**
     * {@snippet lang=c :
     * enum SHSTOCKICONID.SIID_PRINTER = 16
     * }
     */
    public static int SIID_PRINTER() {
        return SIID_PRINTER;
    }
    private static final int SIID_MYNETWORK = (int)17L;
    /**
     * {@snippet lang=c :
     * enum SHSTOCKICONID.SIID_MYNETWORK = 17
     * }
     */
    public static int SIID_MYNETWORK() {
        return SIID_MYNETWORK;
    }
    private static final int SIID_FIND = (int)22L;
    /**
     * {@snippet lang=c :
     * enum SHSTOCKICONID.SIID_FIND = 22
     * }
     */
    public static int SIID_FIND() {
        return SIID_FIND;
    }
    private static final int SIID_HELP = (int)23L;
    /**
     * {@snippet lang=c :
     * enum SHSTOCKICONID.SIID_HELP = 23
     * }
     */
    public static int SIID_HELP() {
        return SIID_HELP;
    }
    private static final int SIID_SHARE = (int)28L;
    /**
     * {@snippet lang=c :
     * enum SHSTOCKICONID.SIID_SHARE = 28
     * }
     */
    public static int SIID_SHARE() {
        return SIID_SHARE;
    }
    private static final int SIID_LINK = (int)29L;
    /**
     * {@snippet lang=c :
     * enum SHSTOCKICONID.SIID_LINK = 29
     * }
     */
    public static int SIID_LINK() {
        return SIID_LINK;
    }
    private static final int SIID_SLOWFILE = (int)30L;
    /**
     * {@snippet lang=c :
     * enum SHSTOCKICONID.SIID_SLOWFILE = 30
     * }
     */
    public static int SIID_SLOWFILE() {
        return SIID_SLOWFILE;
    }
    private static final int SIID_RECYCLER = (int)31L;
    /**
     * {@snippet lang=c :
     * enum SHSTOCKICONID.SIID_RECYCLER = 31
     * }
     */
    public static int SIID_RECYCLER() {
        return SIID_RECYCLER;
    }
    private static final int SIID_RECYCLERFULL = (int)32L;
    /**
     * {@snippet lang=c :
     * enum SHSTOCKICONID.SIID_RECYCLERFULL = 32
     * }
     */
    public static int SIID_RECYCLERFULL() {
        return SIID_RECYCLERFULL;
    }
    private static final int SIID_MEDIACDAUDIO = (int)40L;
    /**
     * {@snippet lang=c :
     * enum SHSTOCKICONID.SIID_MEDIACDAUDIO = 40
     * }
     */
    public static int SIID_MEDIACDAUDIO() {
        return SIID_MEDIACDAUDIO;
    }
    private static final int SIID_LOCK = (int)47L;
    /**
     * {@snippet lang=c :
     * enum SHSTOCKICONID.SIID_LOCK = 47
     * }
     */
    public static int SIID_LOCK() {
        return SIID_LOCK;
    }
    private static final int SIID_AUTOLIST = (int)49L;
    /**
     * {@snippet lang=c :
     * enum SHSTOCKICONID.SIID_AUTOLIST = 49
     * }
     */
    public static int SIID_AUTOLIST() {
        return SIID_AUTOLIST;
    }
    private static final int SIID_PRINTERNET = (int)50L;
    /**
     * {@snippet lang=c :
     * enum SHSTOCKICONID.SIID_PRINTERNET = 50
     * }
     */
    public static int SIID_PRINTERNET() {
        return SIID_PRINTERNET;
    }
    private static final int SIID_SERVERSHARE = (int)51L;
    /**
     * {@snippet lang=c :
     * enum SHSTOCKICONID.SIID_SERVERSHARE = 51
     * }
     */
    public static int SIID_SERVERSHARE() {
        return SIID_SERVERSHARE;
    }
    private static final int SIID_PRINTERFAX = (int)52L;
    /**
     * {@snippet lang=c :
     * enum SHSTOCKICONID.SIID_PRINTERFAX = 52
     * }
     */
    public static int SIID_PRINTERFAX() {
        return SIID_PRINTERFAX;
    }
    private static final int SIID_PRINTERFAXNET = (int)53L;
    /**
     * {@snippet lang=c :
     * enum SHSTOCKICONID.SIID_PRINTERFAXNET = 53
     * }
     */
    public static int SIID_PRINTERFAXNET() {
        return SIID_PRINTERFAXNET;
    }
    private static final int SIID_PRINTERFILE = (int)54L;
    /**
     * {@snippet lang=c :
     * enum SHSTOCKICONID.SIID_PRINTERFILE = 54
     * }
     */
    public static int SIID_PRINTERFILE() {
        return SIID_PRINTERFILE;
    }
    private static final int SIID_STACK = (int)55L;
    /**
     * {@snippet lang=c :
     * enum SHSTOCKICONID.SIID_STACK = 55
     * }
     */
    public static int SIID_STACK() {
        return SIID_STACK;
    }
    private static final int SIID_MEDIASVCD = (int)56L;
    /**
     * {@snippet lang=c :
     * enum SHSTOCKICONID.SIID_MEDIASVCD = 56
     * }
     */
    public static int SIID_MEDIASVCD() {
        return SIID_MEDIASVCD;
    }
    private static final int SIID_STUFFEDFOLDER = (int)57L;
    /**
     * {@snippet lang=c :
     * enum SHSTOCKICONID.SIID_STUFFEDFOLDER = 57
     * }
     */
    public static int SIID_STUFFEDFOLDER() {
        return SIID_STUFFEDFOLDER;
    }
    private static final int SIID_DRIVEUNKNOWN = (int)58L;
    /**
     * {@snippet lang=c :
     * enum SHSTOCKICONID.SIID_DRIVEUNKNOWN = 58
     * }
     */
    public static int SIID_DRIVEUNKNOWN() {
        return SIID_DRIVEUNKNOWN;
    }
    private static final int SIID_DRIVEDVD = (int)59L;
    /**
     * {@snippet lang=c :
     * enum SHSTOCKICONID.SIID_DRIVEDVD = 59
     * }
     */
    public static int SIID_DRIVEDVD() {
        return SIID_DRIVEDVD;
    }
    private static final int SIID_MEDIADVD = (int)60L;
    /**
     * {@snippet lang=c :
     * enum SHSTOCKICONID.SIID_MEDIADVD = 60
     * }
     */
    public static int SIID_MEDIADVD() {
        return SIID_MEDIADVD;
    }
    private static final int SIID_MEDIADVDRAM = (int)61L;
    /**
     * {@snippet lang=c :
     * enum SHSTOCKICONID.SIID_MEDIADVDRAM = 61
     * }
     */
    public static int SIID_MEDIADVDRAM() {
        return SIID_MEDIADVDRAM;
    }
    private static final int SIID_MEDIADVDRW = (int)62L;
    /**
     * {@snippet lang=c :
     * enum SHSTOCKICONID.SIID_MEDIADVDRW = 62
     * }
     */
    public static int SIID_MEDIADVDRW() {
        return SIID_MEDIADVDRW;
    }
    private static final int SIID_MEDIADVDR = (int)63L;
    /**
     * {@snippet lang=c :
     * enum SHSTOCKICONID.SIID_MEDIADVDR = 63
     * }
     */
    public static int SIID_MEDIADVDR() {
        return SIID_MEDIADVDR;
    }
    private static final int SIID_MEDIADVDROM = (int)64L;
    /**
     * {@snippet lang=c :
     * enum SHSTOCKICONID.SIID_MEDIADVDROM = 64
     * }
     */
    public static int SIID_MEDIADVDROM() {
        return SIID_MEDIADVDROM;
    }
    private static final int SIID_MEDIACDAUDIOPLUS = (int)65L;
    /**
     * {@snippet lang=c :
     * enum SHSTOCKICONID.SIID_MEDIACDAUDIOPLUS = 65
     * }
     */
    public static int SIID_MEDIACDAUDIOPLUS() {
        return SIID_MEDIACDAUDIOPLUS;
    }
    private static final int SIID_MEDIACDRW = (int)66L;
    /**
     * {@snippet lang=c :
     * enum SHSTOCKICONID.SIID_MEDIACDRW = 66
     * }
     */
    public static int SIID_MEDIACDRW() {
        return SIID_MEDIACDRW;
    }
    private static final int SIID_MEDIACDR = (int)67L;
    /**
     * {@snippet lang=c :
     * enum SHSTOCKICONID.SIID_MEDIACDR = 67
     * }
     */
    public static int SIID_MEDIACDR() {
        return SIID_MEDIACDR;
    }
    private static final int SIID_MEDIACDBURN = (int)68L;
    /**
     * {@snippet lang=c :
     * enum SHSTOCKICONID.SIID_MEDIACDBURN = 68
     * }
     */
    public static int SIID_MEDIACDBURN() {
        return SIID_MEDIACDBURN;
    }
    private static final int SIID_MEDIABLANKCD = (int)69L;
    /**
     * {@snippet lang=c :
     * enum SHSTOCKICONID.SIID_MEDIABLANKCD = 69
     * }
     */
    public static int SIID_MEDIABLANKCD() {
        return SIID_MEDIABLANKCD;
    }
    private static final int SIID_MEDIACDROM = (int)70L;
    /**
     * {@snippet lang=c :
     * enum SHSTOCKICONID.SIID_MEDIACDROM = 70
     * }
     */
    public static int SIID_MEDIACDROM() {
        return SIID_MEDIACDROM;
    }
    private static final int SIID_AUDIOFILES = (int)71L;
    /**
     * {@snippet lang=c :
     * enum SHSTOCKICONID.SIID_AUDIOFILES = 71
     * }
     */
    public static int SIID_AUDIOFILES() {
        return SIID_AUDIOFILES;
    }
    private static final int SIID_IMAGEFILES = (int)72L;
    /**
     * {@snippet lang=c :
     * enum SHSTOCKICONID.SIID_IMAGEFILES = 72
     * }
     */
    public static int SIID_IMAGEFILES() {
        return SIID_IMAGEFILES;
    }
    private static final int SIID_VIDEOFILES = (int)73L;
    /**
     * {@snippet lang=c :
     * enum SHSTOCKICONID.SIID_VIDEOFILES = 73
     * }
     */
    public static int SIID_VIDEOFILES() {
        return SIID_VIDEOFILES;
    }
    private static final int SIID_MIXEDFILES = (int)74L;
    /**
     * {@snippet lang=c :
     * enum SHSTOCKICONID.SIID_MIXEDFILES = 74
     * }
     */
    public static int SIID_MIXEDFILES() {
        return SIID_MIXEDFILES;
    }
    private static final int SIID_FOLDERBACK = (int)75L;
    /**
     * {@snippet lang=c :
     * enum SHSTOCKICONID.SIID_FOLDERBACK = 75
     * }
     */
    public static int SIID_FOLDERBACK() {
        return SIID_FOLDERBACK;
    }
    private static final int SIID_FOLDERFRONT = (int)76L;
    /**
     * {@snippet lang=c :
     * enum SHSTOCKICONID.SIID_FOLDERFRONT = 76
     * }
     */
    public static int SIID_FOLDERFRONT() {
        return SIID_FOLDERFRONT;
    }
    private static final int SIID_SHIELD = (int)77L;
    /**
     * {@snippet lang=c :
     * enum SHSTOCKICONID.SIID_SHIELD = 77
     * }
     */
    public static int SIID_SHIELD() {
        return SIID_SHIELD;
    }
    private static final int SIID_WARNING = (int)78L;
    /**
     * {@snippet lang=c :
     * enum SHSTOCKICONID.SIID_WARNING = 78
     * }
     */
    public static int SIID_WARNING() {
        return SIID_WARNING;
    }
    private static final int SIID_INFO = (int)79L;
    /**
     * {@snippet lang=c :
     * enum SHSTOCKICONID.SIID_INFO = 79
     * }
     */
    public static int SIID_INFO() {
        return SIID_INFO;
    }
    private static final int SIID_ERROR = (int)80L;
    /**
     * {@snippet lang=c :
     * enum SHSTOCKICONID.SIID_ERROR = 80
     * }
     */
    public static int SIID_ERROR() {
        return SIID_ERROR;
    }
    private static final int SIID_KEY = (int)81L;
    /**
     * {@snippet lang=c :
     * enum SHSTOCKICONID.SIID_KEY = 81
     * }
     */
    public static int SIID_KEY() {
        return SIID_KEY;
    }
    private static final int SIID_SOFTWARE = (int)82L;
    /**
     * {@snippet lang=c :
     * enum SHSTOCKICONID.SIID_SOFTWARE = 82
     * }
     */
    public static int SIID_SOFTWARE() {
        return SIID_SOFTWARE;
    }
    private static final int SIID_RENAME = (int)83L;
    /**
     * {@snippet lang=c :
     * enum SHSTOCKICONID.SIID_RENAME = 83
     * }
     */
    public static int SIID_RENAME() {
        return SIID_RENAME;
    }
    private static final int SIID_DELETE = (int)84L;
    /**
     * {@snippet lang=c :
     * enum SHSTOCKICONID.SIID_DELETE = 84
     * }
     */
    public static int SIID_DELETE() {
        return SIID_DELETE;
    }
    private static final int SIID_MEDIAAUDIODVD = (int)85L;
    /**
     * {@snippet lang=c :
     * enum SHSTOCKICONID.SIID_MEDIAAUDIODVD = 85
     * }
     */
    public static int SIID_MEDIAAUDIODVD() {
        return SIID_MEDIAAUDIODVD;
    }
    private static final int SIID_MEDIAMOVIEDVD = (int)86L;
    /**
     * {@snippet lang=c :
     * enum SHSTOCKICONID.SIID_MEDIAMOVIEDVD = 86
     * }
     */
    public static int SIID_MEDIAMOVIEDVD() {
        return SIID_MEDIAMOVIEDVD;
    }
    private static final int SIID_MEDIAENHANCEDCD = (int)87L;
    /**
     * {@snippet lang=c :
     * enum SHSTOCKICONID.SIID_MEDIAENHANCEDCD = 87
     * }
     */
    public static int SIID_MEDIAENHANCEDCD() {
        return SIID_MEDIAENHANCEDCD;
    }
    private static final int SIID_MEDIAENHANCEDDVD = (int)88L;
    /**
     * {@snippet lang=c :
     * enum SHSTOCKICONID.SIID_MEDIAENHANCEDDVD = 88
     * }
     */
    public static int SIID_MEDIAENHANCEDDVD() {
        return SIID_MEDIAENHANCEDDVD;
    }
    private static final int SIID_MEDIAHDDVD = (int)89L;
    /**
     * {@snippet lang=c :
     * enum SHSTOCKICONID.SIID_MEDIAHDDVD = 89
     * }
     */
    public static int SIID_MEDIAHDDVD() {
        return SIID_MEDIAHDDVD;
    }
    private static final int SIID_MEDIABLURAY = (int)90L;
    /**
     * {@snippet lang=c :
     * enum SHSTOCKICONID.SIID_MEDIABLURAY = 90
     * }
     */
    public static int SIID_MEDIABLURAY() {
        return SIID_MEDIABLURAY;
    }
    private static final int SIID_MEDIAVCD = (int)91L;
    /**
     * {@snippet lang=c :
     * enum SHSTOCKICONID.SIID_MEDIAVCD = 91
     * }
     */
    public static int SIID_MEDIAVCD() {
        return SIID_MEDIAVCD;
    }
    private static final int SIID_MEDIADVDPLUSR = (int)92L;
    /**
     * {@snippet lang=c :
     * enum SHSTOCKICONID.SIID_MEDIADVDPLUSR = 92
     * }
     */
    public static int SIID_MEDIADVDPLUSR() {
        return SIID_MEDIADVDPLUSR;
    }
    private static final int SIID_MEDIADVDPLUSRW = (int)93L;
    /**
     * {@snippet lang=c :
     * enum SHSTOCKICONID.SIID_MEDIADVDPLUSRW = 93
     * }
     */
    public static int SIID_MEDIADVDPLUSRW() {
        return SIID_MEDIADVDPLUSRW;
    }
    private static final int SIID_DESKTOPPC = (int)94L;
    /**
     * {@snippet lang=c :
     * enum SHSTOCKICONID.SIID_DESKTOPPC = 94
     * }
     */
    public static int SIID_DESKTOPPC() {
        return SIID_DESKTOPPC;
    }
    private static final int SIID_MOBILEPC = (int)95L;
    /**
     * {@snippet lang=c :
     * enum SHSTOCKICONID.SIID_MOBILEPC = 95
     * }
     */
    public static int SIID_MOBILEPC() {
        return SIID_MOBILEPC;
    }
    private static final int SIID_USERS = (int)96L;
    /**
     * {@snippet lang=c :
     * enum SHSTOCKICONID.SIID_USERS = 96
     * }
     */
    public static int SIID_USERS() {
        return SIID_USERS;
    }
    private static final int SIID_MEDIASMARTMEDIA = (int)97L;
    /**
     * {@snippet lang=c :
     * enum SHSTOCKICONID.SIID_MEDIASMARTMEDIA = 97
     * }
     */
    public static int SIID_MEDIASMARTMEDIA() {
        return SIID_MEDIASMARTMEDIA;
    }
    private static final int SIID_MEDIACOMPACTFLASH = (int)98L;
    /**
     * {@snippet lang=c :
     * enum SHSTOCKICONID.SIID_MEDIACOMPACTFLASH = 98
     * }
     */
    public static int SIID_MEDIACOMPACTFLASH() {
        return SIID_MEDIACOMPACTFLASH;
    }
    private static final int SIID_DEVICECELLPHONE = (int)99L;
    /**
     * {@snippet lang=c :
     * enum SHSTOCKICONID.SIID_DEVICECELLPHONE = 99
     * }
     */
    public static int SIID_DEVICECELLPHONE() {
        return SIID_DEVICECELLPHONE;
    }
    private static final int SIID_DEVICECAMERA = (int)100L;
    /**
     * {@snippet lang=c :
     * enum SHSTOCKICONID.SIID_DEVICECAMERA = 100
     * }
     */
    public static int SIID_DEVICECAMERA() {
        return SIID_DEVICECAMERA;
    }
    private static final int SIID_DEVICEVIDEOCAMERA = (int)101L;
    /**
     * {@snippet lang=c :
     * enum SHSTOCKICONID.SIID_DEVICEVIDEOCAMERA = 101
     * }
     */
    public static int SIID_DEVICEVIDEOCAMERA() {
        return SIID_DEVICEVIDEOCAMERA;
    }
    private static final int SIID_DEVICEAUDIOPLAYER = (int)102L;
    /**
     * {@snippet lang=c :
     * enum SHSTOCKICONID.SIID_DEVICEAUDIOPLAYER = 102
     * }
     */
    public static int SIID_DEVICEAUDIOPLAYER() {
        return SIID_DEVICEAUDIOPLAYER;
    }
    private static final int SIID_NETWORKCONNECT = (int)103L;
    /**
     * {@snippet lang=c :
     * enum SHSTOCKICONID.SIID_NETWORKCONNECT = 103
     * }
     */
    public static int SIID_NETWORKCONNECT() {
        return SIID_NETWORKCONNECT;
    }
    private static final int SIID_INTERNET = (int)104L;
    /**
     * {@snippet lang=c :
     * enum SHSTOCKICONID.SIID_INTERNET = 104
     * }
     */
    public static int SIID_INTERNET() {
        return SIID_INTERNET;
    }
    private static final int SIID_ZIPFILE = (int)105L;
    /**
     * {@snippet lang=c :
     * enum SHSTOCKICONID.SIID_ZIPFILE = 105
     * }
     */
    public static int SIID_ZIPFILE() {
        return SIID_ZIPFILE;
    }
    private static final int SIID_SETTINGS = (int)106L;
    /**
     * {@snippet lang=c :
     * enum SHSTOCKICONID.SIID_SETTINGS = 106
     * }
     */
    public static int SIID_SETTINGS() {
        return SIID_SETTINGS;
    }
    private static final int SIID_DRIVEHDDVD = (int)132L;
    /**
     * {@snippet lang=c :
     * enum SHSTOCKICONID.SIID_DRIVEHDDVD = 132
     * }
     */
    public static int SIID_DRIVEHDDVD() {
        return SIID_DRIVEHDDVD;
    }
    private static final int SIID_DRIVEBD = (int)133L;
    /**
     * {@snippet lang=c :
     * enum SHSTOCKICONID.SIID_DRIVEBD = 133
     * }
     */
    public static int SIID_DRIVEBD() {
        return SIID_DRIVEBD;
    }
    private static final int SIID_MEDIAHDDVDROM = (int)134L;
    /**
     * {@snippet lang=c :
     * enum SHSTOCKICONID.SIID_MEDIAHDDVDROM = 134
     * }
     */
    public static int SIID_MEDIAHDDVDROM() {
        return SIID_MEDIAHDDVDROM;
    }
    private static final int SIID_MEDIAHDDVDR = (int)135L;
    /**
     * {@snippet lang=c :
     * enum SHSTOCKICONID.SIID_MEDIAHDDVDR = 135
     * }
     */
    public static int SIID_MEDIAHDDVDR() {
        return SIID_MEDIAHDDVDR;
    }
    private static final int SIID_MEDIAHDDVDRAM = (int)136L;
    /**
     * {@snippet lang=c :
     * enum SHSTOCKICONID.SIID_MEDIAHDDVDRAM = 136
     * }
     */
    public static int SIID_MEDIAHDDVDRAM() {
        return SIID_MEDIAHDDVDRAM;
    }
    private static final int SIID_MEDIABDROM = (int)137L;
    /**
     * {@snippet lang=c :
     * enum SHSTOCKICONID.SIID_MEDIABDROM = 137
     * }
     */
    public static int SIID_MEDIABDROM() {
        return SIID_MEDIABDROM;
    }
    private static final int SIID_MEDIABDR = (int)138L;
    /**
     * {@snippet lang=c :
     * enum SHSTOCKICONID.SIID_MEDIABDR = 138
     * }
     */
    public static int SIID_MEDIABDR() {
        return SIID_MEDIABDR;
    }
    private static final int SIID_MEDIABDRE = (int)139L;
    /**
     * {@snippet lang=c :
     * enum SHSTOCKICONID.SIID_MEDIABDRE = 139
     * }
     */
    public static int SIID_MEDIABDRE() {
        return SIID_MEDIABDRE;
    }
    private static final int SIID_CLUSTEREDDRIVE = (int)140L;
    /**
     * {@snippet lang=c :
     * enum SHSTOCKICONID.SIID_CLUSTEREDDRIVE = 140
     * }
     */
    public static int SIID_CLUSTEREDDRIVE() {
        return SIID_CLUSTEREDDRIVE;
    }
    private static final int SIID_MAX_ICONS = (int)181L;
    /**
     * {@snippet lang=c :
     * enum SHSTOCKICONID.SIID_MAX_ICONS = 181
     * }
     */
    public static int SIID_MAX_ICONS() {
        return SIID_MAX_ICONS;
    }

    private static class SHGetStockIconInfo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_INT,
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("SHGetStockIconInfo"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern HRESULT SHGetStockIconInfo(SHSTOCKICONID siid, UINT uFlags, SHSTOCKICONINFO *psii)
     * }
     */
    public static FunctionDescriptor SHGetStockIconInfo$descriptor() {
        return SHGetStockIconInfo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern HRESULT SHGetStockIconInfo(SHSTOCKICONID siid, UINT uFlags, SHSTOCKICONINFO *psii)
     * }
     */
    public static MethodHandle SHGetStockIconInfo$handle() {
        return SHGetStockIconInfo.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern HRESULT SHGetStockIconInfo(SHSTOCKICONID siid, UINT uFlags, SHSTOCKICONINFO *psii)
     * }
     */
    public static int SHGetStockIconInfo(int siid, int uFlags, MemorySegment psii) {
        var mh$ = SHGetStockIconInfo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SHGetStockIconInfo", siid, uFlags, psii);
            }
            return (int)mh$.invokeExact(siid, uFlags, psii);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SHGetDiskFreeSpaceExA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("SHGetDiskFreeSpaceExA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern BOOL SHGetDiskFreeSpaceExA(LPCSTR pszDirectoryName, ULARGE_INTEGER *pulFreeBytesAvailableToCaller, ULARGE_INTEGER *pulTotalNumberOfBytes, ULARGE_INTEGER *pulTotalNumberOfFreeBytes)
     * }
     */
    public static FunctionDescriptor SHGetDiskFreeSpaceExA$descriptor() {
        return SHGetDiskFreeSpaceExA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern BOOL SHGetDiskFreeSpaceExA(LPCSTR pszDirectoryName, ULARGE_INTEGER *pulFreeBytesAvailableToCaller, ULARGE_INTEGER *pulTotalNumberOfBytes, ULARGE_INTEGER *pulTotalNumberOfFreeBytes)
     * }
     */
    public static MethodHandle SHGetDiskFreeSpaceExA$handle() {
        return SHGetDiskFreeSpaceExA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern BOOL SHGetDiskFreeSpaceExA(LPCSTR pszDirectoryName, ULARGE_INTEGER *pulFreeBytesAvailableToCaller, ULARGE_INTEGER *pulTotalNumberOfBytes, ULARGE_INTEGER *pulTotalNumberOfFreeBytes)
     * }
     */
    public static int SHGetDiskFreeSpaceExA(MemorySegment pszDirectoryName, MemorySegment pulFreeBytesAvailableToCaller, MemorySegment pulTotalNumberOfBytes, MemorySegment pulTotalNumberOfFreeBytes) {
        var mh$ = SHGetDiskFreeSpaceExA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SHGetDiskFreeSpaceExA", pszDirectoryName, pulFreeBytesAvailableToCaller, pulTotalNumberOfBytes, pulTotalNumberOfFreeBytes);
            }
            return (int)mh$.invokeExact(pszDirectoryName, pulFreeBytesAvailableToCaller, pulTotalNumberOfBytes, pulTotalNumberOfFreeBytes);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SHGetDiskFreeSpaceExW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("SHGetDiskFreeSpaceExW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern BOOL SHGetDiskFreeSpaceExW(LPCWSTR pszDirectoryName, ULARGE_INTEGER *pulFreeBytesAvailableToCaller, ULARGE_INTEGER *pulTotalNumberOfBytes, ULARGE_INTEGER *pulTotalNumberOfFreeBytes)
     * }
     */
    public static FunctionDescriptor SHGetDiskFreeSpaceExW$descriptor() {
        return SHGetDiskFreeSpaceExW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern BOOL SHGetDiskFreeSpaceExW(LPCWSTR pszDirectoryName, ULARGE_INTEGER *pulFreeBytesAvailableToCaller, ULARGE_INTEGER *pulTotalNumberOfBytes, ULARGE_INTEGER *pulTotalNumberOfFreeBytes)
     * }
     */
    public static MethodHandle SHGetDiskFreeSpaceExW$handle() {
        return SHGetDiskFreeSpaceExW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern BOOL SHGetDiskFreeSpaceExW(LPCWSTR pszDirectoryName, ULARGE_INTEGER *pulFreeBytesAvailableToCaller, ULARGE_INTEGER *pulTotalNumberOfBytes, ULARGE_INTEGER *pulTotalNumberOfFreeBytes)
     * }
     */
    public static int SHGetDiskFreeSpaceExW(MemorySegment pszDirectoryName, MemorySegment pulFreeBytesAvailableToCaller, MemorySegment pulTotalNumberOfBytes, MemorySegment pulTotalNumberOfFreeBytes) {
        var mh$ = SHGetDiskFreeSpaceExW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SHGetDiskFreeSpaceExW", pszDirectoryName, pulFreeBytesAvailableToCaller, pulTotalNumberOfBytes, pulTotalNumberOfFreeBytes);
            }
            return (int)mh$.invokeExact(pszDirectoryName, pulFreeBytesAvailableToCaller, pulTotalNumberOfBytes, pulTotalNumberOfFreeBytes);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SHGetNewLinkInfoA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("SHGetNewLinkInfoA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern BOOL SHGetNewLinkInfoA(LPCSTR pszLinkTo, LPCSTR pszDir, LPSTR pszName, BOOL *pfMustCopy, UINT uFlags)
     * }
     */
    public static FunctionDescriptor SHGetNewLinkInfoA$descriptor() {
        return SHGetNewLinkInfoA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern BOOL SHGetNewLinkInfoA(LPCSTR pszLinkTo, LPCSTR pszDir, LPSTR pszName, BOOL *pfMustCopy, UINT uFlags)
     * }
     */
    public static MethodHandle SHGetNewLinkInfoA$handle() {
        return SHGetNewLinkInfoA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern BOOL SHGetNewLinkInfoA(LPCSTR pszLinkTo, LPCSTR pszDir, LPSTR pszName, BOOL *pfMustCopy, UINT uFlags)
     * }
     */
    public static int SHGetNewLinkInfoA(MemorySegment pszLinkTo, MemorySegment pszDir, MemorySegment pszName, MemorySegment pfMustCopy, int uFlags) {
        var mh$ = SHGetNewLinkInfoA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SHGetNewLinkInfoA", pszLinkTo, pszDir, pszName, pfMustCopy, uFlags);
            }
            return (int)mh$.invokeExact(pszLinkTo, pszDir, pszName, pfMustCopy, uFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SHGetNewLinkInfoW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("SHGetNewLinkInfoW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern BOOL SHGetNewLinkInfoW(LPCWSTR pszLinkTo, LPCWSTR pszDir, LPWSTR pszName, BOOL *pfMustCopy, UINT uFlags)
     * }
     */
    public static FunctionDescriptor SHGetNewLinkInfoW$descriptor() {
        return SHGetNewLinkInfoW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern BOOL SHGetNewLinkInfoW(LPCWSTR pszLinkTo, LPCWSTR pszDir, LPWSTR pszName, BOOL *pfMustCopy, UINT uFlags)
     * }
     */
    public static MethodHandle SHGetNewLinkInfoW$handle() {
        return SHGetNewLinkInfoW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern BOOL SHGetNewLinkInfoW(LPCWSTR pszLinkTo, LPCWSTR pszDir, LPWSTR pszName, BOOL *pfMustCopy, UINT uFlags)
     * }
     */
    public static int SHGetNewLinkInfoW(MemorySegment pszLinkTo, MemorySegment pszDir, MemorySegment pszName, MemorySegment pfMustCopy, int uFlags) {
        var mh$ = SHGetNewLinkInfoW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SHGetNewLinkInfoW", pszLinkTo, pszDir, pszName, pfMustCopy, uFlags);
            }
            return (int)mh$.invokeExact(pszLinkTo, pszDir, pszName, pfMustCopy, uFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SHInvokePrinterCommandA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_INT,
            C_POINTER,
            C_POINTER,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("SHInvokePrinterCommandA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern BOOL SHInvokePrinterCommandA(HWND hwnd, UINT uAction, LPCSTR lpBuf1, LPCSTR lpBuf2, BOOL fModal)
     * }
     */
    public static FunctionDescriptor SHInvokePrinterCommandA$descriptor() {
        return SHInvokePrinterCommandA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern BOOL SHInvokePrinterCommandA(HWND hwnd, UINT uAction, LPCSTR lpBuf1, LPCSTR lpBuf2, BOOL fModal)
     * }
     */
    public static MethodHandle SHInvokePrinterCommandA$handle() {
        return SHInvokePrinterCommandA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern BOOL SHInvokePrinterCommandA(HWND hwnd, UINT uAction, LPCSTR lpBuf1, LPCSTR lpBuf2, BOOL fModal)
     * }
     */
    public static int SHInvokePrinterCommandA(MemorySegment hwnd, int uAction, MemorySegment lpBuf1, MemorySegment lpBuf2, int fModal) {
        var mh$ = SHInvokePrinterCommandA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SHInvokePrinterCommandA", hwnd, uAction, lpBuf1, lpBuf2, fModal);
            }
            return (int)mh$.invokeExact(hwnd, uAction, lpBuf1, lpBuf2, fModal);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SHInvokePrinterCommandW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_INT,
            C_POINTER,
            C_POINTER,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("SHInvokePrinterCommandW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern BOOL SHInvokePrinterCommandW(HWND hwnd, UINT uAction, LPCWSTR lpBuf1, LPCWSTR lpBuf2, BOOL fModal)
     * }
     */
    public static FunctionDescriptor SHInvokePrinterCommandW$descriptor() {
        return SHInvokePrinterCommandW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern BOOL SHInvokePrinterCommandW(HWND hwnd, UINT uAction, LPCWSTR lpBuf1, LPCWSTR lpBuf2, BOOL fModal)
     * }
     */
    public static MethodHandle SHInvokePrinterCommandW$handle() {
        return SHInvokePrinterCommandW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern BOOL SHInvokePrinterCommandW(HWND hwnd, UINT uAction, LPCWSTR lpBuf1, LPCWSTR lpBuf2, BOOL fModal)
     * }
     */
    public static int SHInvokePrinterCommandW(MemorySegment hwnd, int uAction, MemorySegment lpBuf1, MemorySegment lpBuf2, int fModal) {
        var mh$ = SHInvokePrinterCommandW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SHInvokePrinterCommandW", hwnd, uAction, lpBuf1, lpBuf2, fModal);
            }
            return (int)mh$.invokeExact(hwnd, uAction, lpBuf1, lpBuf2, fModal);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct _OPEN_PRINTER_PROPS_INFOA {
     *     DWORD dwSize;
     *     LPSTR pszSheetName;
     *     UINT uSheetIndex;
     *     DWORD dwFlags;
     *     BOOL bModal;
     * } *POPEN_PRINTER_PROPS_INFOA
     * }
     */
    public static final AddressLayout POPEN_PRINTER_PROPS_INFOA = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _OPEN_PRINTER_PROPS_INFOW {
     *     DWORD dwSize;
     *     LPWSTR pszSheetName;
     *     UINT uSheetIndex;
     *     DWORD dwFlags;
     *     BOOL bModal;
     * } *POPEN_PRINTER_PROPS_INFOW
     * }
     */
    public static final AddressLayout POPEN_PRINTER_PROPS_INFOW = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef POPEN_PRINTER_PROPS_INFOA POPEN_PRINTER_PROPS_INFO
     * }
     */
    public static final AddressLayout POPEN_PRINTER_PROPS_INFO = C_POINTER;

    private static class SHLoadNonloadedIconOverlayIdentifiers {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG    );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("SHLoadNonloadedIconOverlayIdentifiers"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern HRESULT SHLoadNonloadedIconOverlayIdentifiers()
     * }
     */
    public static FunctionDescriptor SHLoadNonloadedIconOverlayIdentifiers$descriptor() {
        return SHLoadNonloadedIconOverlayIdentifiers.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern HRESULT SHLoadNonloadedIconOverlayIdentifiers()
     * }
     */
    public static MethodHandle SHLoadNonloadedIconOverlayIdentifiers$handle() {
        return SHLoadNonloadedIconOverlayIdentifiers.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern HRESULT SHLoadNonloadedIconOverlayIdentifiers()
     * }
     */
    public static int SHLoadNonloadedIconOverlayIdentifiers() {
        var mh$ = SHLoadNonloadedIconOverlayIdentifiers.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SHLoadNonloadedIconOverlayIdentifiers");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SHIsFileAvailableOffline {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("SHIsFileAvailableOffline"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern HRESULT SHIsFileAvailableOffline(PCWSTR pwszPath, DWORD *pdwStatus)
     * }
     */
    public static FunctionDescriptor SHIsFileAvailableOffline$descriptor() {
        return SHIsFileAvailableOffline.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern HRESULT SHIsFileAvailableOffline(PCWSTR pwszPath, DWORD *pdwStatus)
     * }
     */
    public static MethodHandle SHIsFileAvailableOffline$handle() {
        return SHIsFileAvailableOffline.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern HRESULT SHIsFileAvailableOffline(PCWSTR pwszPath, DWORD *pdwStatus)
     * }
     */
    public static int SHIsFileAvailableOffline(MemorySegment pwszPath, MemorySegment pdwStatus) {
        var mh$ = SHIsFileAvailableOffline.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SHIsFileAvailableOffline", pwszPath, pdwStatus);
            }
            return (int)mh$.invokeExact(pwszPath, pdwStatus);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SHSetLocalizedName {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_POINTER,
            C_POINTER,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("SHSetLocalizedName"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern HRESULT SHSetLocalizedName(PCWSTR pszPath, PCWSTR pszResModule, int idsRes)
     * }
     */
    public static FunctionDescriptor SHSetLocalizedName$descriptor() {
        return SHSetLocalizedName.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern HRESULT SHSetLocalizedName(PCWSTR pszPath, PCWSTR pszResModule, int idsRes)
     * }
     */
    public static MethodHandle SHSetLocalizedName$handle() {
        return SHSetLocalizedName.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern HRESULT SHSetLocalizedName(PCWSTR pszPath, PCWSTR pszResModule, int idsRes)
     * }
     */
    public static int SHSetLocalizedName(MemorySegment pszPath, MemorySegment pszResModule, int idsRes) {
        var mh$ = SHSetLocalizedName.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SHSetLocalizedName", pszPath, pszResModule, idsRes);
            }
            return (int)mh$.invokeExact(pszPath, pszResModule, idsRes);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SHRemoveLocalizedName {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("SHRemoveLocalizedName"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern HRESULT SHRemoveLocalizedName(PCWSTR pszPath)
     * }
     */
    public static FunctionDescriptor SHRemoveLocalizedName$descriptor() {
        return SHRemoveLocalizedName.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern HRESULT SHRemoveLocalizedName(PCWSTR pszPath)
     * }
     */
    public static MethodHandle SHRemoveLocalizedName$handle() {
        return SHRemoveLocalizedName.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern HRESULT SHRemoveLocalizedName(PCWSTR pszPath)
     * }
     */
    public static int SHRemoveLocalizedName(MemorySegment pszPath) {
        var mh$ = SHRemoveLocalizedName.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SHRemoveLocalizedName", pszPath);
            }
            return (int)mh$.invokeExact(pszPath);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SHGetLocalizedName {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_POINTER,
            C_POINTER,
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("SHGetLocalizedName"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern HRESULT SHGetLocalizedName(PCWSTR pszPath, PWSTR pszResModule, UINT cch, int *pidsRes)
     * }
     */
    public static FunctionDescriptor SHGetLocalizedName$descriptor() {
        return SHGetLocalizedName.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern HRESULT SHGetLocalizedName(PCWSTR pszPath, PWSTR pszResModule, UINT cch, int *pidsRes)
     * }
     */
    public static MethodHandle SHGetLocalizedName$handle() {
        return SHGetLocalizedName.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern HRESULT SHGetLocalizedName(PCWSTR pszPath, PWSTR pszResModule, UINT cch, int *pidsRes)
     * }
     */
    public static int SHGetLocalizedName(MemorySegment pszPath, MemorySegment pszResModule, int cch, MemorySegment pidsRes) {
        var mh$ = SHGetLocalizedName.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SHGetLocalizedName", pszPath, pszResModule, cch, pidsRes);
            }
            return (int)mh$.invokeExact(pszPath, pszResModule, cch, pidsRes);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * extern int ShellMessageBoxA(HINSTANCE hAppInst, HWND hWnd, LPCSTR lpcText, LPCSTR lpcTitle, UINT fuStyle, ...)
     * }
     */
    public static class ShellMessageBoxA {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                C_INT,
                C_POINTER,
                C_POINTER,
                C_POINTER,
                C_POINTER,
                C_INT
            );
        private static final MemorySegment ADDR = findOrThrow("ShellMessageBoxA");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private ShellMessageBoxA(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * extern int ShellMessageBoxA(HINSTANCE hAppInst, HWND hWnd, LPCSTR lpcText, LPCSTR lpcTitle, UINT fuStyle, ...)
         * }
         */
        public static ShellMessageBoxA makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new ShellMessageBoxA(mh$, desc$, spreader$);
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public int apply(MemorySegment hAppInst, MemorySegment hWnd, MemorySegment lpcText, MemorySegment lpcTitle, int fuStyle, Object... x5) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("ShellMessageBoxA", hAppInst, hWnd, lpcText, lpcTitle, fuStyle, x5);
                }
                return (int)spreader.invokeExact(hAppInst, hWnd, lpcText, lpcTitle, fuStyle, x5);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * extern int ShellMessageBoxW(HINSTANCE hAppInst, HWND hWnd, LPCWSTR lpcText, LPCWSTR lpcTitle, UINT fuStyle, ...)
     * }
     */
    public static class ShellMessageBoxW {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                C_INT,
                C_POINTER,
                C_POINTER,
                C_POINTER,
                C_POINTER,
                C_INT
            );
        private static final MemorySegment ADDR = findOrThrow("ShellMessageBoxW");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private ShellMessageBoxW(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * extern int ShellMessageBoxW(HINSTANCE hAppInst, HWND hWnd, LPCWSTR lpcText, LPCWSTR lpcTitle, UINT fuStyle, ...)
         * }
         */
        public static ShellMessageBoxW makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new ShellMessageBoxW(mh$, desc$, spreader$);
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public int apply(MemorySegment hAppInst, MemorySegment hWnd, MemorySegment lpcText, MemorySegment lpcTitle, int fuStyle, Object... x5) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("ShellMessageBoxW", hAppInst, hWnd, lpcText, lpcTitle, fuStyle, x5);
                }
                return (int)spreader.invokeExact(hAppInst, hWnd, lpcText, lpcTitle, fuStyle, x5);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static class IsLFNDriveA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("IsLFNDriveA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern BOOL IsLFNDriveA(LPCSTR pszPath)
     * }
     */
    public static FunctionDescriptor IsLFNDriveA$descriptor() {
        return IsLFNDriveA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern BOOL IsLFNDriveA(LPCSTR pszPath)
     * }
     */
    public static MethodHandle IsLFNDriveA$handle() {
        return IsLFNDriveA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern BOOL IsLFNDriveA(LPCSTR pszPath)
     * }
     */
    public static int IsLFNDriveA(MemorySegment pszPath) {
        var mh$ = IsLFNDriveA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("IsLFNDriveA", pszPath);
            }
            return (int)mh$.invokeExact(pszPath);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class IsLFNDriveW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("IsLFNDriveW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern BOOL IsLFNDriveW(LPCWSTR pszPath)
     * }
     */
    public static FunctionDescriptor IsLFNDriveW$descriptor() {
        return IsLFNDriveW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern BOOL IsLFNDriveW(LPCWSTR pszPath)
     * }
     */
    public static MethodHandle IsLFNDriveW$handle() {
        return IsLFNDriveW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern BOOL IsLFNDriveW(LPCWSTR pszPath)
     * }
     */
    public static int IsLFNDriveW(MemorySegment pszPath) {
        var mh$ = IsLFNDriveW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("IsLFNDriveW", pszPath);
            }
            return (int)mh$.invokeExact(pszPath);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SHEnumerateUnreadMailAccountsA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_POINTER,
            C_LONG,
            C_POINTER,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("SHEnumerateUnreadMailAccountsA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern HRESULT SHEnumerateUnreadMailAccountsA(HKEY hKeyUser, DWORD dwIndex, LPSTR pszMailAddress, int cchMailAddress)
     * }
     */
    public static FunctionDescriptor SHEnumerateUnreadMailAccountsA$descriptor() {
        return SHEnumerateUnreadMailAccountsA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern HRESULT SHEnumerateUnreadMailAccountsA(HKEY hKeyUser, DWORD dwIndex, LPSTR pszMailAddress, int cchMailAddress)
     * }
     */
    public static MethodHandle SHEnumerateUnreadMailAccountsA$handle() {
        return SHEnumerateUnreadMailAccountsA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern HRESULT SHEnumerateUnreadMailAccountsA(HKEY hKeyUser, DWORD dwIndex, LPSTR pszMailAddress, int cchMailAddress)
     * }
     */
    public static int SHEnumerateUnreadMailAccountsA(MemorySegment hKeyUser, int dwIndex, MemorySegment pszMailAddress, int cchMailAddress) {
        var mh$ = SHEnumerateUnreadMailAccountsA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SHEnumerateUnreadMailAccountsA", hKeyUser, dwIndex, pszMailAddress, cchMailAddress);
            }
            return (int)mh$.invokeExact(hKeyUser, dwIndex, pszMailAddress, cchMailAddress);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SHEnumerateUnreadMailAccountsW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_POINTER,
            C_LONG,
            C_POINTER,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("SHEnumerateUnreadMailAccountsW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern HRESULT SHEnumerateUnreadMailAccountsW(HKEY hKeyUser, DWORD dwIndex, LPWSTR pszMailAddress, int cchMailAddress)
     * }
     */
    public static FunctionDescriptor SHEnumerateUnreadMailAccountsW$descriptor() {
        return SHEnumerateUnreadMailAccountsW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern HRESULT SHEnumerateUnreadMailAccountsW(HKEY hKeyUser, DWORD dwIndex, LPWSTR pszMailAddress, int cchMailAddress)
     * }
     */
    public static MethodHandle SHEnumerateUnreadMailAccountsW$handle() {
        return SHEnumerateUnreadMailAccountsW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern HRESULT SHEnumerateUnreadMailAccountsW(HKEY hKeyUser, DWORD dwIndex, LPWSTR pszMailAddress, int cchMailAddress)
     * }
     */
    public static int SHEnumerateUnreadMailAccountsW(MemorySegment hKeyUser, int dwIndex, MemorySegment pszMailAddress, int cchMailAddress) {
        var mh$ = SHEnumerateUnreadMailAccountsW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SHEnumerateUnreadMailAccountsW", hKeyUser, dwIndex, pszMailAddress, cchMailAddress);
            }
            return (int)mh$.invokeExact(hKeyUser, dwIndex, pszMailAddress, cchMailAddress);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SHGetUnreadMailCountA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("SHGetUnreadMailCountA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern HRESULT SHGetUnreadMailCountA(HKEY hKeyUser, LPCSTR pszMailAddress, DWORD *pdwCount, FILETIME *pFileTime, LPSTR pszShellExecuteCommand, int cchShellExecuteCommand)
     * }
     */
    public static FunctionDescriptor SHGetUnreadMailCountA$descriptor() {
        return SHGetUnreadMailCountA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern HRESULT SHGetUnreadMailCountA(HKEY hKeyUser, LPCSTR pszMailAddress, DWORD *pdwCount, FILETIME *pFileTime, LPSTR pszShellExecuteCommand, int cchShellExecuteCommand)
     * }
     */
    public static MethodHandle SHGetUnreadMailCountA$handle() {
        return SHGetUnreadMailCountA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern HRESULT SHGetUnreadMailCountA(HKEY hKeyUser, LPCSTR pszMailAddress, DWORD *pdwCount, FILETIME *pFileTime, LPSTR pszShellExecuteCommand, int cchShellExecuteCommand)
     * }
     */
    public static int SHGetUnreadMailCountA(MemorySegment hKeyUser, MemorySegment pszMailAddress, MemorySegment pdwCount, MemorySegment pFileTime, MemorySegment pszShellExecuteCommand, int cchShellExecuteCommand) {
        var mh$ = SHGetUnreadMailCountA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SHGetUnreadMailCountA", hKeyUser, pszMailAddress, pdwCount, pFileTime, pszShellExecuteCommand, cchShellExecuteCommand);
            }
            return (int)mh$.invokeExact(hKeyUser, pszMailAddress, pdwCount, pFileTime, pszShellExecuteCommand, cchShellExecuteCommand);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SHGetUnreadMailCountW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("SHGetUnreadMailCountW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern HRESULT SHGetUnreadMailCountW(HKEY hKeyUser, LPCWSTR pszMailAddress, DWORD *pdwCount, FILETIME *pFileTime, LPWSTR pszShellExecuteCommand, int cchShellExecuteCommand)
     * }
     */
    public static FunctionDescriptor SHGetUnreadMailCountW$descriptor() {
        return SHGetUnreadMailCountW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern HRESULT SHGetUnreadMailCountW(HKEY hKeyUser, LPCWSTR pszMailAddress, DWORD *pdwCount, FILETIME *pFileTime, LPWSTR pszShellExecuteCommand, int cchShellExecuteCommand)
     * }
     */
    public static MethodHandle SHGetUnreadMailCountW$handle() {
        return SHGetUnreadMailCountW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern HRESULT SHGetUnreadMailCountW(HKEY hKeyUser, LPCWSTR pszMailAddress, DWORD *pdwCount, FILETIME *pFileTime, LPWSTR pszShellExecuteCommand, int cchShellExecuteCommand)
     * }
     */
    public static int SHGetUnreadMailCountW(MemorySegment hKeyUser, MemorySegment pszMailAddress, MemorySegment pdwCount, MemorySegment pFileTime, MemorySegment pszShellExecuteCommand, int cchShellExecuteCommand) {
        var mh$ = SHGetUnreadMailCountW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SHGetUnreadMailCountW", hKeyUser, pszMailAddress, pdwCount, pFileTime, pszShellExecuteCommand, cchShellExecuteCommand);
            }
            return (int)mh$.invokeExact(hKeyUser, pszMailAddress, pdwCount, pFileTime, pszShellExecuteCommand, cchShellExecuteCommand);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SHSetUnreadMailCountA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_POINTER,
            C_LONG,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("SHSetUnreadMailCountA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern HRESULT SHSetUnreadMailCountA(LPCSTR pszMailAddress, DWORD dwCount, LPCSTR pszShellExecuteCommand)
     * }
     */
    public static FunctionDescriptor SHSetUnreadMailCountA$descriptor() {
        return SHSetUnreadMailCountA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern HRESULT SHSetUnreadMailCountA(LPCSTR pszMailAddress, DWORD dwCount, LPCSTR pszShellExecuteCommand)
     * }
     */
    public static MethodHandle SHSetUnreadMailCountA$handle() {
        return SHSetUnreadMailCountA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern HRESULT SHSetUnreadMailCountA(LPCSTR pszMailAddress, DWORD dwCount, LPCSTR pszShellExecuteCommand)
     * }
     */
    public static int SHSetUnreadMailCountA(MemorySegment pszMailAddress, int dwCount, MemorySegment pszShellExecuteCommand) {
        var mh$ = SHSetUnreadMailCountA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SHSetUnreadMailCountA", pszMailAddress, dwCount, pszShellExecuteCommand);
            }
            return (int)mh$.invokeExact(pszMailAddress, dwCount, pszShellExecuteCommand);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SHSetUnreadMailCountW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_POINTER,
            C_LONG,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("SHSetUnreadMailCountW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern HRESULT SHSetUnreadMailCountW(LPCWSTR pszMailAddress, DWORD dwCount, LPCWSTR pszShellExecuteCommand)
     * }
     */
    public static FunctionDescriptor SHSetUnreadMailCountW$descriptor() {
        return SHSetUnreadMailCountW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern HRESULT SHSetUnreadMailCountW(LPCWSTR pszMailAddress, DWORD dwCount, LPCWSTR pszShellExecuteCommand)
     * }
     */
    public static MethodHandle SHSetUnreadMailCountW$handle() {
        return SHSetUnreadMailCountW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern HRESULT SHSetUnreadMailCountW(LPCWSTR pszMailAddress, DWORD dwCount, LPCWSTR pszShellExecuteCommand)
     * }
     */
    public static int SHSetUnreadMailCountW(MemorySegment pszMailAddress, int dwCount, MemorySegment pszShellExecuteCommand) {
        var mh$ = SHSetUnreadMailCountW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SHSetUnreadMailCountW", pszMailAddress, dwCount, pszShellExecuteCommand);
            }
            return (int)mh$.invokeExact(pszMailAddress, dwCount, pszShellExecuteCommand);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SHTestTokenMembership {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("SHTestTokenMembership"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern BOOL SHTestTokenMembership(HANDLE hToken, ULONG ulRID)
     * }
     */
    public static FunctionDescriptor SHTestTokenMembership$descriptor() {
        return SHTestTokenMembership.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern BOOL SHTestTokenMembership(HANDLE hToken, ULONG ulRID)
     * }
     */
    public static MethodHandle SHTestTokenMembership$handle() {
        return SHTestTokenMembership.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern BOOL SHTestTokenMembership(HANDLE hToken, ULONG ulRID)
     * }
     */
    public static int SHTestTokenMembership(MemorySegment hToken, int ulRID) {
        var mh$ = SHTestTokenMembership.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SHTestTokenMembership", hToken, ulRID);
            }
            return (int)mh$.invokeExact(hToken, ulRID);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SHGetImageList {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_INT,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("SHGetImageList"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern HRESULT SHGetImageList(int iImageList, const IID *const riid, void **ppvObj)
     * }
     */
    public static FunctionDescriptor SHGetImageList$descriptor() {
        return SHGetImageList.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern HRESULT SHGetImageList(int iImageList, const IID *const riid, void **ppvObj)
     * }
     */
    public static MethodHandle SHGetImageList$handle() {
        return SHGetImageList.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern HRESULT SHGetImageList(int iImageList, const IID *const riid, void **ppvObj)
     * }
     */
    public static int SHGetImageList(int iImageList, MemorySegment riid, MemorySegment ppvObj) {
        var mh$ = SHGetImageList.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SHGetImageList", iImageList, riid, ppvObj);
            }
            return (int)mh$.invokeExact(iImageList, riid, ppvObj);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class InitNetworkAddressControl {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT    );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("InitNetworkAddressControl"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern BOOL InitNetworkAddressControl()
     * }
     */
    public static FunctionDescriptor InitNetworkAddressControl$descriptor() {
        return InitNetworkAddressControl.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern BOOL InitNetworkAddressControl()
     * }
     */
    public static MethodHandle InitNetworkAddressControl$handle() {
        return InitNetworkAddressControl.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern BOOL InitNetworkAddressControl()
     * }
     */
    public static int InitNetworkAddressControl() {
        var mh$ = InitNetworkAddressControl.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("InitNetworkAddressControl");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct tagNC_ADDRESS {
     *     struct NET_ADDRESS_INFO_ *pAddrInfo;
     *     USHORT PortNumber;
     *     BYTE PrefixLength;
     * } *PNC_ADDRESS
     * }
     */
    public static final AddressLayout PNC_ADDRESS = C_POINTER;

    private static class SHGetDriveMedia {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("SHGetDriveMedia"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern HRESULT SHGetDriveMedia(PCWSTR pszDrive, DWORD *pdwMediaContent)
     * }
     */
    public static FunctionDescriptor SHGetDriveMedia$descriptor() {
        return SHGetDriveMedia.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern HRESULT SHGetDriveMedia(PCWSTR pszDrive, DWORD *pdwMediaContent)
     * }
     */
    public static MethodHandle SHGetDriveMedia$handle() {
        return SHGetDriveMedia.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern HRESULT SHGetDriveMedia(PCWSTR pszDrive, DWORD *pdwMediaContent)
     * }
     */
    public static int SHGetDriveMedia(MemorySegment pszDrive, MemorySegment pdwMediaContent) {
        var mh$ = SHGetDriveMedia.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SHGetDriveMedia", pszDrive, pdwMediaContent);
            }
            return (int)mh$.invokeExact(pszDrive, pdwMediaContent);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct _PERF_DATA_BLOCK {
     *     WCHAR Signature[4];
     *     DWORD LittleEndian;
     *     DWORD Version;
     *     DWORD Revision;
     *     DWORD TotalByteLength;
     *     DWORD HeaderLength;
     *     DWORD NumObjectTypes;
     *     LONG DefaultObject;
     *     SYSTEMTIME SystemTime;
     *     LARGE_INTEGER PerfTime;
     *     LARGE_INTEGER PerfFreq;
     *     LARGE_INTEGER PerfTime100nSec;
     *     DWORD SystemNameLength;
     *     DWORD SystemNameOffset;
     * } *PPERF_DATA_BLOCK
     * }
     */
    public static final AddressLayout PPERF_DATA_BLOCK = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _PERF_OBJECT_TYPE {
     *     DWORD TotalByteLength;
     *     DWORD DefinitionLength;
     *     DWORD HeaderLength;
     *     DWORD ObjectNameTitleIndex;
     *     DWORD ObjectNameTitle;
     *     DWORD ObjectHelpTitleIndex;
     *     DWORD ObjectHelpTitle;
     *     DWORD DetailLevel;
     *     DWORD NumCounters;
     *     LONG DefaultCounter;
     *     LONG NumInstances;
     *     DWORD CodePage;
     *     LARGE_INTEGER PerfTime;
     *     LARGE_INTEGER PerfFreq;
     * } *PPERF_OBJECT_TYPE
     * }
     */
    public static final AddressLayout PPERF_OBJECT_TYPE = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _PERF_COUNTER_DEFINITION {
     *     DWORD ByteLength;
     *     DWORD CounterNameTitleIndex;
     *     DWORD CounterNameTitle;
     *     DWORD CounterHelpTitleIndex;
     *     DWORD CounterHelpTitle;
     *     LONG DefaultScale;
     *     DWORD DetailLevel;
     *     DWORD CounterType;
     *     DWORD CounterSize;
     *     DWORD CounterOffset;
     * } *PPERF_COUNTER_DEFINITION
     * }
     */
    public static final AddressLayout PPERF_COUNTER_DEFINITION = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _PERF_INSTANCE_DEFINITION {
     *     DWORD ByteLength;
     *     DWORD ParentObjectTitleIndex;
     *     DWORD ParentObjectInstance;
     *     LONG UniqueID;
     *     DWORD NameOffset;
     *     DWORD NameLength;
     * } *PPERF_INSTANCE_DEFINITION
     * }
     */
    public static final AddressLayout PPERF_INSTANCE_DEFINITION = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _PERF_COUNTER_BLOCK {
     *     DWORD ByteLength;
     * } *PPERF_COUNTER_BLOCK
     * }
     */
    public static final AddressLayout PPERF_COUNTER_BLOCK = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef unsigned char u_char
     * }
     */
    public static final OfByte u_char = C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef unsigned short u_short
     * }
     */
    public static final OfShort u_short = C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef unsigned int u_int
     * }
     */
    public static final OfInt u_int = C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned long u_long
     * }
     */
    public static final OfInt u_long = C_LONG;
    /**
     * {@snippet lang=c :
     * typedef UINT_PTR SOCKET
     * }
     */
    public static final OfLong SOCKET = C_LONG_LONG;

    private static class __WSAFDIsSet {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_LONG_LONG,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("__WSAFDIsSet"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int __WSAFDIsSet(SOCKET, fd_set *)
     * }
     */
    public static FunctionDescriptor __WSAFDIsSet$descriptor() {
        return __WSAFDIsSet.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int __WSAFDIsSet(SOCKET, fd_set *)
     * }
     */
    public static MethodHandle __WSAFDIsSet$handle() {
        return __WSAFDIsSet.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * extern int __WSAFDIsSet(SOCKET, fd_set *)
     * }
     */
    public static int __WSAFDIsSet(long x0, MemorySegment x1) {
        var mh$ = __WSAFDIsSet.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__WSAFDIsSet", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct in_addr {
     *     union {
     *         struct {
     *             UCHAR s_b1;
     *             UCHAR s_b2;
     *             UCHAR s_b3;
     *             UCHAR s_b4;
     *         } S_un_b;
     *         struct {
     *             USHORT s_w1;
     *             USHORT s_w2;
     *         } S_un_w;
     *         ULONG S_addr;
     *     } S_un;
     * } *PIN_ADDR
     * }
     */
    public static final AddressLayout PIN_ADDR = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct in_addr {
     *     union {
     *         struct {
     *             UCHAR s_b1;
     *             UCHAR s_b2;
     *             UCHAR s_b3;
     *             UCHAR s_b4;
     *         } S_un_b;
     *         struct {
     *             USHORT s_w1;
     *             USHORT s_w2;
     *         } S_un_w;
     *         ULONG S_addr;
     *     } S_un;
     * } *LPIN_ADDR
     * }
     */
    public static final AddressLayout LPIN_ADDR = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef WSADATA *LPWSADATA
     * }
     */
    public static final AddressLayout LPWSADATA = C_POINTER;

    private static class accept {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG_LONG,
            C_LONG_LONG,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("accept"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SOCKET accept(SOCKET s, struct sockaddr *addr, int *addrlen)
     * }
     */
    public static FunctionDescriptor accept$descriptor() {
        return accept.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SOCKET accept(SOCKET s, struct sockaddr *addr, int *addrlen)
     * }
     */
    public static MethodHandle accept$handle() {
        return accept.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * SOCKET accept(SOCKET s, struct sockaddr *addr, int *addrlen)
     * }
     */
    public static long accept(long s, MemorySegment addr, MemorySegment addrlen) {
        var mh$ = accept.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("accept", s, addr, addrlen);
            }
            return (long)mh$.invokeExact(s, addr, addrlen);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class bind {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_LONG_LONG,
            C_POINTER,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("bind"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int bind(SOCKET s, const struct sockaddr *addr, int namelen)
     * }
     */
    public static FunctionDescriptor bind$descriptor() {
        return bind.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int bind(SOCKET s, const struct sockaddr *addr, int namelen)
     * }
     */
    public static MethodHandle bind$handle() {
        return bind.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int bind(SOCKET s, const struct sockaddr *addr, int namelen)
     * }
     */
    public static int bind(long s, MemorySegment addr, int namelen) {
        var mh$ = bind.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("bind", s, addr, namelen);
            }
            return (int)mh$.invokeExact(s, addr, namelen);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class closesocket {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_LONG_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("closesocket"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int closesocket(SOCKET s)
     * }
     */
    public static FunctionDescriptor closesocket$descriptor() {
        return closesocket.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int closesocket(SOCKET s)
     * }
     */
    public static MethodHandle closesocket$handle() {
        return closesocket.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int closesocket(SOCKET s)
     * }
     */
    public static int closesocket(long s) {
        var mh$ = closesocket.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("closesocket", s);
            }
            return (int)mh$.invokeExact(s);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class connect {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_LONG_LONG,
            C_POINTER,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("connect"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int connect(SOCKET s, const struct sockaddr *name, int namelen)
     * }
     */
    public static FunctionDescriptor connect$descriptor() {
        return connect.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int connect(SOCKET s, const struct sockaddr *name, int namelen)
     * }
     */
    public static MethodHandle connect$handle() {
        return connect.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int connect(SOCKET s, const struct sockaddr *name, int namelen)
     * }
     */
    public static int connect(long s, MemorySegment name, int namelen) {
        var mh$ = connect.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("connect", s, name, namelen);
            }
            return (int)mh$.invokeExact(s, name, namelen);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ioctlsocket {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_LONG_LONG,
            C_LONG,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("ioctlsocket"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int ioctlsocket(SOCKET s, long cmd, u_long *argp)
     * }
     */
    public static FunctionDescriptor ioctlsocket$descriptor() {
        return ioctlsocket.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int ioctlsocket(SOCKET s, long cmd, u_long *argp)
     * }
     */
    public static MethodHandle ioctlsocket$handle() {
        return ioctlsocket.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int ioctlsocket(SOCKET s, long cmd, u_long *argp)
     * }
     */
    public static int ioctlsocket(long s, int cmd, MemorySegment argp) {
        var mh$ = ioctlsocket.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ioctlsocket", s, cmd, argp);
            }
            return (int)mh$.invokeExact(s, cmd, argp);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getpeername {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_LONG_LONG,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("getpeername"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int getpeername(SOCKET s, struct sockaddr *name, int *namelen)
     * }
     */
    public static FunctionDescriptor getpeername$descriptor() {
        return getpeername.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int getpeername(SOCKET s, struct sockaddr *name, int *namelen)
     * }
     */
    public static MethodHandle getpeername$handle() {
        return getpeername.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int getpeername(SOCKET s, struct sockaddr *name, int *namelen)
     * }
     */
    public static int getpeername(long s, MemorySegment name, MemorySegment namelen) {
        var mh$ = getpeername.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getpeername", s, name, namelen);
            }
            return (int)mh$.invokeExact(s, name, namelen);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getsockname {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_LONG_LONG,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("getsockname"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int getsockname(SOCKET s, struct sockaddr *name, int *namelen)
     * }
     */
    public static FunctionDescriptor getsockname$descriptor() {
        return getsockname.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int getsockname(SOCKET s, struct sockaddr *name, int *namelen)
     * }
     */
    public static MethodHandle getsockname$handle() {
        return getsockname.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int getsockname(SOCKET s, struct sockaddr *name, int *namelen)
     * }
     */
    public static int getsockname(long s, MemorySegment name, MemorySegment namelen) {
        var mh$ = getsockname.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getsockname", s, name, namelen);
            }
            return (int)mh$.invokeExact(s, name, namelen);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getsockopt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_LONG_LONG,
            C_INT,
            C_INT,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("getsockopt"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int getsockopt(SOCKET s, int level, int optname, char *optval, int *optlen)
     * }
     */
    public static FunctionDescriptor getsockopt$descriptor() {
        return getsockopt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int getsockopt(SOCKET s, int level, int optname, char *optval, int *optlen)
     * }
     */
    public static MethodHandle getsockopt$handle() {
        return getsockopt.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int getsockopt(SOCKET s, int level, int optname, char *optval, int *optlen)
     * }
     */
    public static int getsockopt(long s, int level, int optname, MemorySegment optval, MemorySegment optlen) {
        var mh$ = getsockopt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getsockopt", s, level, optname, optval, optlen);
            }
            return (int)mh$.invokeExact(s, level, optname, optval, optlen);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class htonl {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("htonl"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * u_long htonl(u_long hostlong)
     * }
     */
    public static FunctionDescriptor htonl$descriptor() {
        return htonl.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * u_long htonl(u_long hostlong)
     * }
     */
    public static MethodHandle htonl$handle() {
        return htonl.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * u_long htonl(u_long hostlong)
     * }
     */
    public static int htonl(int hostlong) {
        var mh$ = htonl.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("htonl", hostlong);
            }
            return (int)mh$.invokeExact(hostlong);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class htons {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_SHORT,
            C_SHORT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("htons"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * u_short htons(u_short hostshort)
     * }
     */
    public static FunctionDescriptor htons$descriptor() {
        return htons.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * u_short htons(u_short hostshort)
     * }
     */
    public static MethodHandle htons$handle() {
        return htons.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * u_short htons(u_short hostshort)
     * }
     */
    public static short htons(short hostshort) {
        var mh$ = htons.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("htons", hostshort);
            }
            return (short)mh$.invokeExact(hostshort);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class inet_addr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("inet_addr"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned long inet_addr(const char *cp)
     * }
     */
    public static FunctionDescriptor inet_addr$descriptor() {
        return inet_addr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned long inet_addr(const char *cp)
     * }
     */
    public static MethodHandle inet_addr$handle() {
        return inet_addr.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * unsigned long inet_addr(const char *cp)
     * }
     */
    public static int inet_addr(MemorySegment cp) {
        var mh$ = inet_addr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("inet_addr", cp);
            }
            return (int)mh$.invokeExact(cp);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class inet_ntoa {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            in_addr.layout()
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("inet_ntoa"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *inet_ntoa(struct in_addr in)
     * }
     */
    public static FunctionDescriptor inet_ntoa$descriptor() {
        return inet_ntoa.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *inet_ntoa(struct in_addr in)
     * }
     */
    public static MethodHandle inet_ntoa$handle() {
        return inet_ntoa.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * char *inet_ntoa(struct in_addr in)
     * }
     */
    public static MemorySegment inet_ntoa(MemorySegment in) {
        var mh$ = inet_ntoa.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("inet_ntoa", in);
            }
            return (MemorySegment)mh$.invokeExact(in);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class listen {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_LONG_LONG,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("listen"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int listen(SOCKET s, int backlog)
     * }
     */
    public static FunctionDescriptor listen$descriptor() {
        return listen.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int listen(SOCKET s, int backlog)
     * }
     */
    public static MethodHandle listen$handle() {
        return listen.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int listen(SOCKET s, int backlog)
     * }
     */
    public static int listen(long s, int backlog) {
        var mh$ = listen.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("listen", s, backlog);
            }
            return (int)mh$.invokeExact(s, backlog);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ntohl {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("ntohl"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * u_long ntohl(u_long netlong)
     * }
     */
    public static FunctionDescriptor ntohl$descriptor() {
        return ntohl.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * u_long ntohl(u_long netlong)
     * }
     */
    public static MethodHandle ntohl$handle() {
        return ntohl.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * u_long ntohl(u_long netlong)
     * }
     */
    public static int ntohl(int netlong) {
        var mh$ = ntohl.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ntohl", netlong);
            }
            return (int)mh$.invokeExact(netlong);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ntohs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_SHORT,
            C_SHORT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("ntohs"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * u_short ntohs(u_short netshort)
     * }
     */
    public static FunctionDescriptor ntohs$descriptor() {
        return ntohs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * u_short ntohs(u_short netshort)
     * }
     */
    public static MethodHandle ntohs$handle() {
        return ntohs.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * u_short ntohs(u_short netshort)
     * }
     */
    public static short ntohs(short netshort) {
        var mh$ = ntohs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ntohs", netshort);
            }
            return (short)mh$.invokeExact(netshort);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class recv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_LONG_LONG,
            C_POINTER,
            C_INT,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("recv"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int recv(SOCKET s, char *buf, int len, int flags)
     * }
     */
    public static FunctionDescriptor recv$descriptor() {
        return recv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int recv(SOCKET s, char *buf, int len, int flags)
     * }
     */
    public static MethodHandle recv$handle() {
        return recv.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int recv(SOCKET s, char *buf, int len, int flags)
     * }
     */
    public static int recv(long s, MemorySegment buf, int len, int flags) {
        var mh$ = recv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("recv", s, buf, len, flags);
            }
            return (int)mh$.invokeExact(s, buf, len, flags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class recvfrom {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_LONG_LONG,
            C_POINTER,
            C_INT,
            C_INT,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("recvfrom"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int recvfrom(SOCKET s, char *buf, int len, int flags, struct sockaddr *from, int *fromlen)
     * }
     */
    public static FunctionDescriptor recvfrom$descriptor() {
        return recvfrom.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int recvfrom(SOCKET s, char *buf, int len, int flags, struct sockaddr *from, int *fromlen)
     * }
     */
    public static MethodHandle recvfrom$handle() {
        return recvfrom.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int recvfrom(SOCKET s, char *buf, int len, int flags, struct sockaddr *from, int *fromlen)
     * }
     */
    public static int recvfrom(long s, MemorySegment buf, int len, int flags, MemorySegment from, MemorySegment fromlen) {
        var mh$ = recvfrom.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("recvfrom", s, buf, len, flags, from, fromlen);
            }
            return (int)mh$.invokeExact(s, buf, len, flags, from, fromlen);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class select {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_INT,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("select"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int select(int nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, const struct timeval *timeout)
     * }
     */
    public static FunctionDescriptor select$descriptor() {
        return select.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int select(int nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, const struct timeval *timeout)
     * }
     */
    public static MethodHandle select$handle() {
        return select.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int select(int nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, const struct timeval *timeout)
     * }
     */
    public static int select(int nfds, MemorySegment readfds, MemorySegment writefds, MemorySegment exceptfds, MemorySegment timeout) {
        var mh$ = select.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("select", nfds, readfds, writefds, exceptfds, timeout);
            }
            return (int)mh$.invokeExact(nfds, readfds, writefds, exceptfds, timeout);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class send {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_LONG_LONG,
            C_POINTER,
            C_INT,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("send"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int send(SOCKET s, const char *buf, int len, int flags)
     * }
     */
    public static FunctionDescriptor send$descriptor() {
        return send.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int send(SOCKET s, const char *buf, int len, int flags)
     * }
     */
    public static MethodHandle send$handle() {
        return send.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int send(SOCKET s, const char *buf, int len, int flags)
     * }
     */
    public static int send(long s, MemorySegment buf, int len, int flags) {
        var mh$ = send.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("send", s, buf, len, flags);
            }
            return (int)mh$.invokeExact(s, buf, len, flags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sendto {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_LONG_LONG,
            C_POINTER,
            C_INT,
            C_INT,
            C_POINTER,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("sendto"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int sendto(SOCKET s, const char *buf, int len, int flags, const struct sockaddr *to, int tolen)
     * }
     */
    public static FunctionDescriptor sendto$descriptor() {
        return sendto.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int sendto(SOCKET s, const char *buf, int len, int flags, const struct sockaddr *to, int tolen)
     * }
     */
    public static MethodHandle sendto$handle() {
        return sendto.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int sendto(SOCKET s, const char *buf, int len, int flags, const struct sockaddr *to, int tolen)
     * }
     */
    public static int sendto(long s, MemorySegment buf, int len, int flags, MemorySegment to, int tolen) {
        var mh$ = sendto.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sendto", s, buf, len, flags, to, tolen);
            }
            return (int)mh$.invokeExact(s, buf, len, flags, to, tolen);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class setsockopt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_LONG_LONG,
            C_INT,
            C_INT,
            C_POINTER,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("setsockopt"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int setsockopt(SOCKET s, int level, int optname, const char *optval, int optlen)
     * }
     */
    public static FunctionDescriptor setsockopt$descriptor() {
        return setsockopt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int setsockopt(SOCKET s, int level, int optname, const char *optval, int optlen)
     * }
     */
    public static MethodHandle setsockopt$handle() {
        return setsockopt.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int setsockopt(SOCKET s, int level, int optname, const char *optval, int optlen)
     * }
     */
    public static int setsockopt(long s, int level, int optname, MemorySegment optval, int optlen) {
        var mh$ = setsockopt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("setsockopt", s, level, optname, optval, optlen);
            }
            return (int)mh$.invokeExact(s, level, optname, optval, optlen);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class shutdown {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_LONG_LONG,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("shutdown"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int shutdown(SOCKET s, int how)
     * }
     */
    public static FunctionDescriptor shutdown$descriptor() {
        return shutdown.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int shutdown(SOCKET s, int how)
     * }
     */
    public static MethodHandle shutdown$handle() {
        return shutdown.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int shutdown(SOCKET s, int how)
     * }
     */
    public static int shutdown(long s, int how) {
        var mh$ = shutdown.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("shutdown", s, how);
            }
            return (int)mh$.invokeExact(s, how);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class socket {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG_LONG,
            C_INT,
            C_INT,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("socket"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SOCKET socket(int af, int type, int protocol)
     * }
     */
    public static FunctionDescriptor socket$descriptor() {
        return socket.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SOCKET socket(int af, int type, int protocol)
     * }
     */
    public static MethodHandle socket$handle() {
        return socket.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * SOCKET socket(int af, int type, int protocol)
     * }
     */
    public static long socket(int af, int type, int protocol) {
        var mh$ = socket.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("socket", af, type, protocol);
            }
            return (long)mh$.invokeExact(af, type, protocol);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class gethostbyaddr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER,
            C_INT,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("gethostbyaddr"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * struct hostent *gethostbyaddr(const char *addr, int len, int type)
     * }
     */
    public static FunctionDescriptor gethostbyaddr$descriptor() {
        return gethostbyaddr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * struct hostent *gethostbyaddr(const char *addr, int len, int type)
     * }
     */
    public static MethodHandle gethostbyaddr$handle() {
        return gethostbyaddr.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * struct hostent *gethostbyaddr(const char *addr, int len, int type)
     * }
     */
    public static MemorySegment gethostbyaddr(MemorySegment addr, int len, int type) {
        var mh$ = gethostbyaddr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("gethostbyaddr", addr, len, type);
            }
            return (MemorySegment)mh$.invokeExact(addr, len, type);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class gethostbyname {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("gethostbyname"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * struct hostent *gethostbyname(const char *name)
     * }
     */
    public static FunctionDescriptor gethostbyname$descriptor() {
        return gethostbyname.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * struct hostent *gethostbyname(const char *name)
     * }
     */
    public static MethodHandle gethostbyname$handle() {
        return gethostbyname.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * struct hostent *gethostbyname(const char *name)
     * }
     */
    public static MemorySegment gethostbyname(MemorySegment name) {
        var mh$ = gethostbyname.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("gethostbyname", name);
            }
            return (MemorySegment)mh$.invokeExact(name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class gethostname {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("gethostname"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int gethostname(char *name, int namelen)
     * }
     */
    public static FunctionDescriptor gethostname$descriptor() {
        return gethostname.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int gethostname(char *name, int namelen)
     * }
     */
    public static MethodHandle gethostname$handle() {
        return gethostname.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int gethostname(char *name, int namelen)
     * }
     */
    public static int gethostname(MemorySegment name, int namelen) {
        var mh$ = gethostname.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("gethostname", name, namelen);
            }
            return (int)mh$.invokeExact(name, namelen);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getservbyport {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("getservbyport"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * struct servent *getservbyport(int port, const char *proto)
     * }
     */
    public static FunctionDescriptor getservbyport$descriptor() {
        return getservbyport.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * struct servent *getservbyport(int port, const char *proto)
     * }
     */
    public static MethodHandle getservbyport$handle() {
        return getservbyport.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * struct servent *getservbyport(int port, const char *proto)
     * }
     */
    public static MemorySegment getservbyport(int port, MemorySegment proto) {
        var mh$ = getservbyport.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getservbyport", port, proto);
            }
            return (MemorySegment)mh$.invokeExact(port, proto);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getservbyname {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("getservbyname"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * struct servent *getservbyname(const char *name, const char *proto)
     * }
     */
    public static FunctionDescriptor getservbyname$descriptor() {
        return getservbyname.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * struct servent *getservbyname(const char *name, const char *proto)
     * }
     */
    public static MethodHandle getservbyname$handle() {
        return getservbyname.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * struct servent *getservbyname(const char *name, const char *proto)
     * }
     */
    public static MemorySegment getservbyname(MemorySegment name, MemorySegment proto) {
        var mh$ = getservbyname.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getservbyname", name, proto);
            }
            return (MemorySegment)mh$.invokeExact(name, proto);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getprotobynumber {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("getprotobynumber"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * struct protoent *getprotobynumber(int proto)
     * }
     */
    public static FunctionDescriptor getprotobynumber$descriptor() {
        return getprotobynumber.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * struct protoent *getprotobynumber(int proto)
     * }
     */
    public static MethodHandle getprotobynumber$handle() {
        return getprotobynumber.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * struct protoent *getprotobynumber(int proto)
     * }
     */
    public static MemorySegment getprotobynumber(int proto) {
        var mh$ = getprotobynumber.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getprotobynumber", proto);
            }
            return (MemorySegment)mh$.invokeExact(proto);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getprotobyname {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("getprotobyname"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * struct protoent *getprotobyname(const char *name)
     * }
     */
    public static FunctionDescriptor getprotobyname$descriptor() {
        return getprotobyname.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * struct protoent *getprotobyname(const char *name)
     * }
     */
    public static MethodHandle getprotobyname$handle() {
        return getprotobyname.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * struct protoent *getprotobyname(const char *name)
     * }
     */
    public static MemorySegment getprotobyname(MemorySegment name) {
        var mh$ = getprotobyname.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getprotobyname", name);
            }
            return (MemorySegment)mh$.invokeExact(name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class WSAStartup {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_SHORT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("WSAStartup"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int WSAStartup(WORD wVersionRequired, LPWSADATA lpWSAData)
     * }
     */
    public static FunctionDescriptor WSAStartup$descriptor() {
        return WSAStartup.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int WSAStartup(WORD wVersionRequired, LPWSADATA lpWSAData)
     * }
     */
    public static MethodHandle WSAStartup$handle() {
        return WSAStartup.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int WSAStartup(WORD wVersionRequired, LPWSADATA lpWSAData)
     * }
     */
    public static int WSAStartup(short wVersionRequired, MemorySegment lpWSAData) {
        var mh$ = WSAStartup.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WSAStartup", wVersionRequired, lpWSAData);
            }
            return (int)mh$.invokeExact(wVersionRequired, lpWSAData);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class WSACleanup {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT    );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("WSACleanup"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int WSACleanup()
     * }
     */
    public static FunctionDescriptor WSACleanup$descriptor() {
        return WSACleanup.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int WSACleanup()
     * }
     */
    public static MethodHandle WSACleanup$handle() {
        return WSACleanup.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int WSACleanup()
     * }
     */
    public static int WSACleanup() {
        var mh$ = WSACleanup.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WSACleanup");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class WSASetLastError {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("WSASetLastError"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void WSASetLastError(int iError)
     * }
     */
    public static FunctionDescriptor WSASetLastError$descriptor() {
        return WSASetLastError.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void WSASetLastError(int iError)
     * }
     */
    public static MethodHandle WSASetLastError$handle() {
        return WSASetLastError.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * void WSASetLastError(int iError)
     * }
     */
    public static void WSASetLastError(int iError) {
        var mh$ = WSASetLastError.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WSASetLastError", iError);
            }
            mh$.invokeExact(iError);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class WSAGetLastError {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT    );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("WSAGetLastError"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int WSAGetLastError()
     * }
     */
    public static FunctionDescriptor WSAGetLastError$descriptor() {
        return WSAGetLastError.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int WSAGetLastError()
     * }
     */
    public static MethodHandle WSAGetLastError$handle() {
        return WSAGetLastError.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int WSAGetLastError()
     * }
     */
    public static int WSAGetLastError() {
        var mh$ = WSAGetLastError.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WSAGetLastError");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class WSAIsBlocking {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT    );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("WSAIsBlocking"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL WSAIsBlocking()
     * }
     */
    public static FunctionDescriptor WSAIsBlocking$descriptor() {
        return WSAIsBlocking.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL WSAIsBlocking()
     * }
     */
    public static MethodHandle WSAIsBlocking$handle() {
        return WSAIsBlocking.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL WSAIsBlocking()
     * }
     */
    public static int WSAIsBlocking() {
        var mh$ = WSAIsBlocking.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WSAIsBlocking");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class WSAUnhookBlockingHook {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT    );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("WSAUnhookBlockingHook"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int WSAUnhookBlockingHook()
     * }
     */
    public static FunctionDescriptor WSAUnhookBlockingHook$descriptor() {
        return WSAUnhookBlockingHook.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int WSAUnhookBlockingHook()
     * }
     */
    public static MethodHandle WSAUnhookBlockingHook$handle() {
        return WSAUnhookBlockingHook.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int WSAUnhookBlockingHook()
     * }
     */
    public static int WSAUnhookBlockingHook() {
        var mh$ = WSAUnhookBlockingHook.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WSAUnhookBlockingHook");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class WSASetBlockingHook {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("WSASetBlockingHook"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * FARPROC WSASetBlockingHook(FARPROC lpBlockFunc)
     * }
     */
    public static FunctionDescriptor WSASetBlockingHook$descriptor() {
        return WSASetBlockingHook.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * FARPROC WSASetBlockingHook(FARPROC lpBlockFunc)
     * }
     */
    public static MethodHandle WSASetBlockingHook$handle() {
        return WSASetBlockingHook.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * FARPROC WSASetBlockingHook(FARPROC lpBlockFunc)
     * }
     */
    public static MemorySegment WSASetBlockingHook(MemorySegment lpBlockFunc) {
        var mh$ = WSASetBlockingHook.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WSASetBlockingHook", lpBlockFunc);
            }
            return (MemorySegment)mh$.invokeExact(lpBlockFunc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class WSACancelBlockingCall {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT    );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("WSACancelBlockingCall"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int WSACancelBlockingCall()
     * }
     */
    public static FunctionDescriptor WSACancelBlockingCall$descriptor() {
        return WSACancelBlockingCall.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int WSACancelBlockingCall()
     * }
     */
    public static MethodHandle WSACancelBlockingCall$handle() {
        return WSACancelBlockingCall.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int WSACancelBlockingCall()
     * }
     */
    public static int WSACancelBlockingCall() {
        var mh$ = WSACancelBlockingCall.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WSACancelBlockingCall");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class WSAAsyncGetServByName {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER,
            C_INT,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("WSAAsyncGetServByName"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HANDLE WSAAsyncGetServByName(HWND hWnd, u_int wMsg, const char *name, const char *proto, char *buf, int buflen)
     * }
     */
    public static FunctionDescriptor WSAAsyncGetServByName$descriptor() {
        return WSAAsyncGetServByName.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HANDLE WSAAsyncGetServByName(HWND hWnd, u_int wMsg, const char *name, const char *proto, char *buf, int buflen)
     * }
     */
    public static MethodHandle WSAAsyncGetServByName$handle() {
        return WSAAsyncGetServByName.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * HANDLE WSAAsyncGetServByName(HWND hWnd, u_int wMsg, const char *name, const char *proto, char *buf, int buflen)
     * }
     */
    public static MemorySegment WSAAsyncGetServByName(MemorySegment hWnd, int wMsg, MemorySegment name, MemorySegment proto, MemorySegment buf, int buflen) {
        var mh$ = WSAAsyncGetServByName.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WSAAsyncGetServByName", hWnd, wMsg, name, proto, buf, buflen);
            }
            return (MemorySegment)mh$.invokeExact(hWnd, wMsg, name, proto, buf, buflen);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class WSAAsyncGetServByPort {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER,
            C_INT,
            C_INT,
            C_POINTER,
            C_POINTER,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("WSAAsyncGetServByPort"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HANDLE WSAAsyncGetServByPort(HWND hWnd, u_int wMsg, int port, const char *proto, char *buf, int buflen)
     * }
     */
    public static FunctionDescriptor WSAAsyncGetServByPort$descriptor() {
        return WSAAsyncGetServByPort.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HANDLE WSAAsyncGetServByPort(HWND hWnd, u_int wMsg, int port, const char *proto, char *buf, int buflen)
     * }
     */
    public static MethodHandle WSAAsyncGetServByPort$handle() {
        return WSAAsyncGetServByPort.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * HANDLE WSAAsyncGetServByPort(HWND hWnd, u_int wMsg, int port, const char *proto, char *buf, int buflen)
     * }
     */
    public static MemorySegment WSAAsyncGetServByPort(MemorySegment hWnd, int wMsg, int port, MemorySegment proto, MemorySegment buf, int buflen) {
        var mh$ = WSAAsyncGetServByPort.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WSAAsyncGetServByPort", hWnd, wMsg, port, proto, buf, buflen);
            }
            return (MemorySegment)mh$.invokeExact(hWnd, wMsg, port, proto, buf, buflen);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class WSAAsyncGetProtoByName {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER,
            C_INT,
            C_POINTER,
            C_POINTER,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("WSAAsyncGetProtoByName"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HANDLE WSAAsyncGetProtoByName(HWND hWnd, u_int wMsg, const char *name, char *buf, int buflen)
     * }
     */
    public static FunctionDescriptor WSAAsyncGetProtoByName$descriptor() {
        return WSAAsyncGetProtoByName.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HANDLE WSAAsyncGetProtoByName(HWND hWnd, u_int wMsg, const char *name, char *buf, int buflen)
     * }
     */
    public static MethodHandle WSAAsyncGetProtoByName$handle() {
        return WSAAsyncGetProtoByName.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * HANDLE WSAAsyncGetProtoByName(HWND hWnd, u_int wMsg, const char *name, char *buf, int buflen)
     * }
     */
    public static MemorySegment WSAAsyncGetProtoByName(MemorySegment hWnd, int wMsg, MemorySegment name, MemorySegment buf, int buflen) {
        var mh$ = WSAAsyncGetProtoByName.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WSAAsyncGetProtoByName", hWnd, wMsg, name, buf, buflen);
            }
            return (MemorySegment)mh$.invokeExact(hWnd, wMsg, name, buf, buflen);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class WSAAsyncGetProtoByNumber {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER,
            C_INT,
            C_INT,
            C_POINTER,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("WSAAsyncGetProtoByNumber"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HANDLE WSAAsyncGetProtoByNumber(HWND hWnd, u_int wMsg, int number, char *buf, int buflen)
     * }
     */
    public static FunctionDescriptor WSAAsyncGetProtoByNumber$descriptor() {
        return WSAAsyncGetProtoByNumber.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HANDLE WSAAsyncGetProtoByNumber(HWND hWnd, u_int wMsg, int number, char *buf, int buflen)
     * }
     */
    public static MethodHandle WSAAsyncGetProtoByNumber$handle() {
        return WSAAsyncGetProtoByNumber.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * HANDLE WSAAsyncGetProtoByNumber(HWND hWnd, u_int wMsg, int number, char *buf, int buflen)
     * }
     */
    public static MemorySegment WSAAsyncGetProtoByNumber(MemorySegment hWnd, int wMsg, int number, MemorySegment buf, int buflen) {
        var mh$ = WSAAsyncGetProtoByNumber.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WSAAsyncGetProtoByNumber", hWnd, wMsg, number, buf, buflen);
            }
            return (MemorySegment)mh$.invokeExact(hWnd, wMsg, number, buf, buflen);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class WSAAsyncGetHostByName {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER,
            C_INT,
            C_POINTER,
            C_POINTER,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("WSAAsyncGetHostByName"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HANDLE WSAAsyncGetHostByName(HWND hWnd, u_int wMsg, const char *name, char *buf, int buflen)
     * }
     */
    public static FunctionDescriptor WSAAsyncGetHostByName$descriptor() {
        return WSAAsyncGetHostByName.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HANDLE WSAAsyncGetHostByName(HWND hWnd, u_int wMsg, const char *name, char *buf, int buflen)
     * }
     */
    public static MethodHandle WSAAsyncGetHostByName$handle() {
        return WSAAsyncGetHostByName.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * HANDLE WSAAsyncGetHostByName(HWND hWnd, u_int wMsg, const char *name, char *buf, int buflen)
     * }
     */
    public static MemorySegment WSAAsyncGetHostByName(MemorySegment hWnd, int wMsg, MemorySegment name, MemorySegment buf, int buflen) {
        var mh$ = WSAAsyncGetHostByName.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WSAAsyncGetHostByName", hWnd, wMsg, name, buf, buflen);
            }
            return (MemorySegment)mh$.invokeExact(hWnd, wMsg, name, buf, buflen);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class WSAAsyncGetHostByAddr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER,
            C_INT,
            C_POINTER,
            C_INT,
            C_INT,
            C_POINTER,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("WSAAsyncGetHostByAddr"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HANDLE WSAAsyncGetHostByAddr(HWND hWnd, u_int wMsg, const char *addr, int len, int type, char *buf, int buflen)
     * }
     */
    public static FunctionDescriptor WSAAsyncGetHostByAddr$descriptor() {
        return WSAAsyncGetHostByAddr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HANDLE WSAAsyncGetHostByAddr(HWND hWnd, u_int wMsg, const char *addr, int len, int type, char *buf, int buflen)
     * }
     */
    public static MethodHandle WSAAsyncGetHostByAddr$handle() {
        return WSAAsyncGetHostByAddr.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * HANDLE WSAAsyncGetHostByAddr(HWND hWnd, u_int wMsg, const char *addr, int len, int type, char *buf, int buflen)
     * }
     */
    public static MemorySegment WSAAsyncGetHostByAddr(MemorySegment hWnd, int wMsg, MemorySegment addr, int len, int type, MemorySegment buf, int buflen) {
        var mh$ = WSAAsyncGetHostByAddr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WSAAsyncGetHostByAddr", hWnd, wMsg, addr, len, type, buf, buflen);
            }
            return (MemorySegment)mh$.invokeExact(hWnd, wMsg, addr, len, type, buf, buflen);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class WSACancelAsyncRequest {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("WSACancelAsyncRequest"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int WSACancelAsyncRequest(HANDLE hAsyncTaskHandle)
     * }
     */
    public static FunctionDescriptor WSACancelAsyncRequest$descriptor() {
        return WSACancelAsyncRequest.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int WSACancelAsyncRequest(HANDLE hAsyncTaskHandle)
     * }
     */
    public static MethodHandle WSACancelAsyncRequest$handle() {
        return WSACancelAsyncRequest.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int WSACancelAsyncRequest(HANDLE hAsyncTaskHandle)
     * }
     */
    public static int WSACancelAsyncRequest(MemorySegment hAsyncTaskHandle) {
        var mh$ = WSACancelAsyncRequest.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WSACancelAsyncRequest", hAsyncTaskHandle);
            }
            return (int)mh$.invokeExact(hAsyncTaskHandle);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class WSAAsyncSelect {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_LONG_LONG,
            C_POINTER,
            C_INT,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("WSAAsyncSelect"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int WSAAsyncSelect(SOCKET s, HWND hWnd, u_int wMsg, long lEvent)
     * }
     */
    public static FunctionDescriptor WSAAsyncSelect$descriptor() {
        return WSAAsyncSelect.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int WSAAsyncSelect(SOCKET s, HWND hWnd, u_int wMsg, long lEvent)
     * }
     */
    public static MethodHandle WSAAsyncSelect$handle() {
        return WSAAsyncSelect.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int WSAAsyncSelect(SOCKET s, HWND hWnd, u_int wMsg, long lEvent)
     * }
     */
    public static int WSAAsyncSelect(long s, MemorySegment hWnd, int wMsg, int lEvent) {
        var mh$ = WSAAsyncSelect.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WSAAsyncSelect", s, hWnd, wMsg, lEvent);
            }
            return (int)mh$.invokeExact(s, hWnd, wMsg, lEvent);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class WSARecvEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_LONG_LONG,
            C_POINTER,
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("WSARecvEx"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int WSARecvEx(SOCKET s, char *buf, int len, int *flags)
     * }
     */
    public static FunctionDescriptor WSARecvEx$descriptor() {
        return WSARecvEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int WSARecvEx(SOCKET s, char *buf, int len, int *flags)
     * }
     */
    public static MethodHandle WSARecvEx$handle() {
        return WSARecvEx.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int WSARecvEx(SOCKET s, char *buf, int len, int *flags)
     * }
     */
    public static int WSARecvEx(long s, MemorySegment buf, int len, MemorySegment flags) {
        var mh$ = WSARecvEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WSARecvEx", s, buf, len, flags);
            }
            return (int)mh$.invokeExact(s, buf, len, flags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct _TRANSMIT_FILE_BUFFERS {
     *     PVOID Head;
     *     DWORD HeadLength;
     *     PVOID Tail;
     *     DWORD TailLength;
     * } *PTRANSMIT_FILE_BUFFERS
     * }
     */
    public static final AddressLayout PTRANSMIT_FILE_BUFFERS = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _TRANSMIT_FILE_BUFFERS {
     *     PVOID Head;
     *     DWORD HeadLength;
     *     PVOID Tail;
     *     DWORD TailLength;
     * } *LPTRANSMIT_FILE_BUFFERS
     * }
     */
    public static final AddressLayout LPTRANSMIT_FILE_BUFFERS = C_POINTER;

    private static class TransmitFile {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_LONG_LONG,
            C_POINTER,
            C_LONG,
            C_LONG,
            C_POINTER,
            C_POINTER,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("TransmitFile"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL TransmitFile(SOCKET hSocket, HANDLE hFile, DWORD nNumberOfBytesToWrite, DWORD nNumberOfBytesPerSend, LPOVERLAPPED lpOverlapped, LPTRANSMIT_FILE_BUFFERS lpTransmitBuffers, DWORD dwReserved)
     * }
     */
    public static FunctionDescriptor TransmitFile$descriptor() {
        return TransmitFile.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL TransmitFile(SOCKET hSocket, HANDLE hFile, DWORD nNumberOfBytesToWrite, DWORD nNumberOfBytesPerSend, LPOVERLAPPED lpOverlapped, LPTRANSMIT_FILE_BUFFERS lpTransmitBuffers, DWORD dwReserved)
     * }
     */
    public static MethodHandle TransmitFile$handle() {
        return TransmitFile.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL TransmitFile(SOCKET hSocket, HANDLE hFile, DWORD nNumberOfBytesToWrite, DWORD nNumberOfBytesPerSend, LPOVERLAPPED lpOverlapped, LPTRANSMIT_FILE_BUFFERS lpTransmitBuffers, DWORD dwReserved)
     * }
     */
    public static int TransmitFile(long hSocket, MemorySegment hFile, int nNumberOfBytesToWrite, int nNumberOfBytesPerSend, MemorySegment lpOverlapped, MemorySegment lpTransmitBuffers, int dwReserved) {
        var mh$ = TransmitFile.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TransmitFile", hSocket, hFile, nNumberOfBytesToWrite, nNumberOfBytesPerSend, lpOverlapped, lpTransmitBuffers, dwReserved);
            }
            return (int)mh$.invokeExact(hSocket, hFile, nNumberOfBytesToWrite, nNumberOfBytesPerSend, lpOverlapped, lpTransmitBuffers, dwReserved);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class AcceptEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_LONG_LONG,
            C_LONG_LONG,
            C_POINTER,
            C_LONG,
            C_LONG,
            C_LONG,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("AcceptEx"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL AcceptEx(SOCKET sListenSocket, SOCKET sAcceptSocket, PVOID lpOutputBuffer, DWORD dwReceiveDataLength, DWORD dwLocalAddressLength, DWORD dwRemoteAddressLength, LPDWORD lpdwBytesReceived, LPOVERLAPPED lpOverlapped)
     * }
     */
    public static FunctionDescriptor AcceptEx$descriptor() {
        return AcceptEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL AcceptEx(SOCKET sListenSocket, SOCKET sAcceptSocket, PVOID lpOutputBuffer, DWORD dwReceiveDataLength, DWORD dwLocalAddressLength, DWORD dwRemoteAddressLength, LPDWORD lpdwBytesReceived, LPOVERLAPPED lpOverlapped)
     * }
     */
    public static MethodHandle AcceptEx$handle() {
        return AcceptEx.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL AcceptEx(SOCKET sListenSocket, SOCKET sAcceptSocket, PVOID lpOutputBuffer, DWORD dwReceiveDataLength, DWORD dwLocalAddressLength, DWORD dwRemoteAddressLength, LPDWORD lpdwBytesReceived, LPOVERLAPPED lpOverlapped)
     * }
     */
    public static int AcceptEx(long sListenSocket, long sAcceptSocket, MemorySegment lpOutputBuffer, int dwReceiveDataLength, int dwLocalAddressLength, int dwRemoteAddressLength, MemorySegment lpdwBytesReceived, MemorySegment lpOverlapped) {
        var mh$ = AcceptEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("AcceptEx", sListenSocket, sAcceptSocket, lpOutputBuffer, dwReceiveDataLength, dwLocalAddressLength, dwRemoteAddressLength, lpdwBytesReceived, lpOverlapped);
            }
            return (int)mh$.invokeExact(sListenSocket, sAcceptSocket, lpOutputBuffer, dwReceiveDataLength, dwLocalAddressLength, dwRemoteAddressLength, lpdwBytesReceived, lpOverlapped);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetAcceptExSockaddrs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C_POINTER,
            C_LONG,
            C_LONG,
            C_LONG,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetAcceptExSockaddrs"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void GetAcceptExSockaddrs(PVOID lpOutputBuffer, DWORD dwReceiveDataLength, DWORD dwLocalAddressLength, DWORD dwRemoteAddressLength, struct sockaddr **LocalSockaddr, LPINT LocalSockaddrLength, struct sockaddr **RemoteSockaddr, LPINT RemoteSockaddrLength)
     * }
     */
    public static FunctionDescriptor GetAcceptExSockaddrs$descriptor() {
        return GetAcceptExSockaddrs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void GetAcceptExSockaddrs(PVOID lpOutputBuffer, DWORD dwReceiveDataLength, DWORD dwLocalAddressLength, DWORD dwRemoteAddressLength, struct sockaddr **LocalSockaddr, LPINT LocalSockaddrLength, struct sockaddr **RemoteSockaddr, LPINT RemoteSockaddrLength)
     * }
     */
    public static MethodHandle GetAcceptExSockaddrs$handle() {
        return GetAcceptExSockaddrs.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * void GetAcceptExSockaddrs(PVOID lpOutputBuffer, DWORD dwReceiveDataLength, DWORD dwLocalAddressLength, DWORD dwRemoteAddressLength, struct sockaddr **LocalSockaddr, LPINT LocalSockaddrLength, struct sockaddr **RemoteSockaddr, LPINT RemoteSockaddrLength)
     * }
     */
    public static void GetAcceptExSockaddrs(MemorySegment lpOutputBuffer, int dwReceiveDataLength, int dwLocalAddressLength, int dwRemoteAddressLength, MemorySegment LocalSockaddr, MemorySegment LocalSockaddrLength, MemorySegment RemoteSockaddr, MemorySegment RemoteSockaddrLength) {
        var mh$ = GetAcceptExSockaddrs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetAcceptExSockaddrs", lpOutputBuffer, dwReceiveDataLength, dwLocalAddressLength, dwRemoteAddressLength, LocalSockaddr, LocalSockaddrLength, RemoteSockaddr, RemoteSockaddrLength);
            }
            mh$.invokeExact(lpOutputBuffer, dwReceiveDataLength, dwLocalAddressLength, dwRemoteAddressLength, LocalSockaddr, LocalSockaddrLength, RemoteSockaddr, RemoteSockaddrLength);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct sockaddr {
     *     u_short sa_family;
     *     char sa_data[14];
     * } *PSOCKADDR
     * }
     */
    public static final AddressLayout PSOCKADDR = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct sockaddr {
     *     u_short sa_family;
     *     char sa_data[14];
     * } *LPSOCKADDR
     * }
     */
    public static final AddressLayout LPSOCKADDR = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct sockaddr_in {
     *     short sin_family;
     *     u_short sin_port;
     *     struct in_addr sin_addr;
     *     char sin_zero[8];
     * } *PSOCKADDR_IN
     * }
     */
    public static final AddressLayout PSOCKADDR_IN = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct sockaddr_in {
     *     short sin_family;
     *     u_short sin_port;
     *     struct in_addr sin_addr;
     *     char sin_zero[8];
     * } *LPSOCKADDR_IN
     * }
     */
    public static final AddressLayout LPSOCKADDR_IN = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct linger {
     *     u_short l_onoff;
     *     u_short l_linger;
     * } *PLINGER
     * }
     */
    public static final AddressLayout PLINGER = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct linger {
     *     u_short l_onoff;
     *     u_short l_linger;
     * } *LPLINGER
     * }
     */
    public static final AddressLayout LPLINGER = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct fd_set {
     *     u_int fd_count;
     *     SOCKET fd_array[64];
     * } *PFD_SET
     * }
     */
    public static final AddressLayout PFD_SET = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct fd_set {
     *     u_int fd_count;
     *     SOCKET fd_array[64];
     * } *LPFD_SET
     * }
     */
    public static final AddressLayout LPFD_SET = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct hostent {
     *     char *h_name;
     *     char **h_aliases;
     *     short h_addrtype;
     *     short h_length;
     *     char **h_addr_list;
     * } *PHOSTENT
     * }
     */
    public static final AddressLayout PHOSTENT = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct hostent {
     *     char *h_name;
     *     char **h_aliases;
     *     short h_addrtype;
     *     short h_length;
     *     char **h_addr_list;
     * } *LPHOSTENT
     * }
     */
    public static final AddressLayout LPHOSTENT = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct servent {
     *     char *s_name;
     *     char **s_aliases;
     *     char *s_proto;
     *     short s_port;
     * } *PSERVENT
     * }
     */
    public static final AddressLayout PSERVENT = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct servent {
     *     char *s_name;
     *     char **s_aliases;
     *     char *s_proto;
     *     short s_port;
     * } *LPSERVENT
     * }
     */
    public static final AddressLayout LPSERVENT = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct protoent {
     *     char *p_name;
     *     char **p_aliases;
     *     short p_proto;
     * } *PPROTOENT
     * }
     */
    public static final AddressLayout PPROTOENT = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct protoent {
     *     char *p_name;
     *     char **p_aliases;
     *     short p_proto;
     * } *LPPROTOENT
     * }
     */
    public static final AddressLayout LPPROTOENT = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct timeval {
     *     long tv_sec;
     *     long tv_usec;
     * } *PTIMEVAL
     * }
     */
    public static final AddressLayout PTIMEVAL = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct timeval {
     *     long tv_sec;
     *     long tv_usec;
     * } *LPTIMEVAL
     * }
     */
    public static final AddressLayout LPTIMEVAL = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef unsigned int ALG_ID
     * }
     */
    public static final OfInt ALG_ID = C_INT;
    /**
     * {@snippet lang=c :
     * typedef ULONG_PTR HCRYPTPROV
     * }
     */
    public static final OfLong HCRYPTPROV = C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef ULONG_PTR HCRYPTKEY
     * }
     */
    public static final OfLong HCRYPTKEY = C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef ULONG_PTR HCRYPTHASH
     * }
     */
    public static final OfLong HCRYPTHASH = C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef struct _CMS_KEY_INFO {
     *     DWORD dwVersion;
     *     ALG_ID Algid;
     *     BYTE *pbOID;
     *     DWORD cbOID;
     * } *PCMS_KEY_INFO
     * }
     */
    public static final AddressLayout PCMS_KEY_INFO = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _HMAC_Info {
     *     ALG_ID HashAlgid;
     *     BYTE *pbInnerString;
     *     DWORD cbInnerString;
     *     BYTE *pbOuterString;
     *     DWORD cbOuterString;
     * } *PHMAC_INFO
     * }
     */
    public static final AddressLayout PHMAC_INFO = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _SCHANNEL_ALG {
     *     DWORD dwUse;
     *     ALG_ID Algid;
     *     DWORD cBits;
     *     DWORD dwFlags;
     *     DWORD dwReserved;
     * } *PSCHANNEL_ALG
     * }
     */
    public static final AddressLayout PSCHANNEL_ALG = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _KEY_TYPE_SUBTYPE {
     *     DWORD dwKeySpec;
     *     GUID Type;
     *     GUID Subtype;
     * } *PKEY_TYPE_SUBTYPE
     * }
     */
    public static final AddressLayout PKEY_TYPE_SUBTYPE = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CRYPT_RC4_KEY_STATE {
     *     unsigned char Key[16];
     *     unsigned char SBox[256];
     *     unsigned char i;
     *     unsigned char j;
     * } *PCRYPT_RC4_KEY_STATE
     * }
     */
    public static final AddressLayout PCRYPT_RC4_KEY_STATE = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CRYPT_DES_KEY_STATE {
     *     unsigned char Key[8];
     *     unsigned char IV[8];
     *     unsigned char Feedback[8];
     * } *PCRYPT_DES_KEY_STATE
     * }
     */
    public static final AddressLayout PCRYPT_DES_KEY_STATE = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CRYPT_3DES_KEY_STATE {
     *     unsigned char Key[24];
     *     unsigned char IV[8];
     *     unsigned char Feedback[8];
     * } *PCRYPT_3DES_KEY_STATE
     * }
     */
    public static final AddressLayout PCRYPT_3DES_KEY_STATE = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CRYPT_AES_128_KEY_STATE {
     *     unsigned char Key[16];
     *     unsigned char IV[16];
     *     unsigned char EncryptionState[11][16];
     *     unsigned char DecryptionState[11][16];
     *     unsigned char Feedback[16];
     * } *PCRYPT_AES_128_KEY_STATE
     * }
     */
    public static final AddressLayout PCRYPT_AES_128_KEY_STATE = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CRYPT_AES_256_KEY_STATE {
     *     unsigned char Key[32];
     *     unsigned char IV[16];
     *     unsigned char EncryptionState[15][16];
     *     unsigned char DecryptionState[15][16];
     *     unsigned char Feedback[16];
     * } *PCRYPT_AES_256_KEY_STATE
     * }
     */
    public static final AddressLayout PCRYPT_AES_256_KEY_STATE = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CRYPTOAPI_BLOB {
     *     DWORD cbData;
     *     BYTE *pbData;
     * } *PCRYPT_INTEGER_BLOB
     * }
     */
    public static final AddressLayout PCRYPT_INTEGER_BLOB = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CRYPTOAPI_BLOB {
     *     DWORD cbData;
     *     BYTE *pbData;
     * } *PCRYPT_UINT_BLOB
     * }
     */
    public static final AddressLayout PCRYPT_UINT_BLOB = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CRYPTOAPI_BLOB {
     *     DWORD cbData;
     *     BYTE *pbData;
     * } *PCRYPT_OBJID_BLOB
     * }
     */
    public static final AddressLayout PCRYPT_OBJID_BLOB = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CRYPTOAPI_BLOB {
     *     DWORD cbData;
     *     BYTE *pbData;
     * } *PCERT_NAME_BLOB
     * }
     */
    public static final AddressLayout PCERT_NAME_BLOB = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CRYPTOAPI_BLOB {
     *     DWORD cbData;
     *     BYTE *pbData;
     * } *PCERT_RDN_VALUE_BLOB
     * }
     */
    public static final AddressLayout PCERT_RDN_VALUE_BLOB = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CRYPTOAPI_BLOB {
     *     DWORD cbData;
     *     BYTE *pbData;
     * } *PCERT_BLOB
     * }
     */
    public static final AddressLayout PCERT_BLOB = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CRYPTOAPI_BLOB {
     *     DWORD cbData;
     *     BYTE *pbData;
     * } *PCRL_BLOB
     * }
     */
    public static final AddressLayout PCRL_BLOB = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CRYPTOAPI_BLOB {
     *     DWORD cbData;
     *     BYTE *pbData;
     * } *PDATA_BLOB
     * }
     */
    public static final AddressLayout PDATA_BLOB = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CRYPTOAPI_BLOB {
     *     DWORD cbData;
     *     BYTE *pbData;
     * } *PCRYPT_DATA_BLOB
     * }
     */
    public static final AddressLayout PCRYPT_DATA_BLOB = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CRYPTOAPI_BLOB {
     *     DWORD cbData;
     *     BYTE *pbData;
     * } *PCRYPT_HASH_BLOB
     * }
     */
    public static final AddressLayout PCRYPT_HASH_BLOB = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CRYPTOAPI_BLOB {
     *     DWORD cbData;
     *     BYTE *pbData;
     * } *PCRYPT_DIGEST_BLOB
     * }
     */
    public static final AddressLayout PCRYPT_DIGEST_BLOB = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CRYPTOAPI_BLOB {
     *     DWORD cbData;
     *     BYTE *pbData;
     * } *PCRYPT_DER_BLOB
     * }
     */
    public static final AddressLayout PCRYPT_DER_BLOB = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CRYPTOAPI_BLOB {
     *     DWORD cbData;
     *     BYTE *pbData;
     * } *PCRYPT_ATTR_BLOB
     * }
     */
    public static final AddressLayout PCRYPT_ATTR_BLOB = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CMS_DH_KEY_INFO {
     *     DWORD dwVersion;
     *     ALG_ID Algid;
     *     LPSTR pszContentEncObjId;
     *     CRYPT_DATA_BLOB PubInfo;
     *     void *pReserved;
     * } *PCMS_DH_KEY_INFO
     * }
     */
    public static final AddressLayout PCMS_DH_KEY_INFO = C_POINTER;

    private static class CryptAcquireContextA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_LONG,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CryptAcquireContextA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CryptAcquireContextA(HCRYPTPROV *phProv, LPCSTR szContainer, LPCSTR szProvider, DWORD dwProvType, DWORD dwFlags)
     * }
     */
    public static FunctionDescriptor CryptAcquireContextA$descriptor() {
        return CryptAcquireContextA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CryptAcquireContextA(HCRYPTPROV *phProv, LPCSTR szContainer, LPCSTR szProvider, DWORD dwProvType, DWORD dwFlags)
     * }
     */
    public static MethodHandle CryptAcquireContextA$handle() {
        return CryptAcquireContextA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL CryptAcquireContextA(HCRYPTPROV *phProv, LPCSTR szContainer, LPCSTR szProvider, DWORD dwProvType, DWORD dwFlags)
     * }
     */
    public static int CryptAcquireContextA(MemorySegment phProv, MemorySegment szContainer, MemorySegment szProvider, int dwProvType, int dwFlags) {
        var mh$ = CryptAcquireContextA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CryptAcquireContextA", phProv, szContainer, szProvider, dwProvType, dwFlags);
            }
            return (int)mh$.invokeExact(phProv, szContainer, szProvider, dwProvType, dwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CryptAcquireContextW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_LONG,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CryptAcquireContextW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CryptAcquireContextW(HCRYPTPROV *phProv, LPCWSTR szContainer, LPCWSTR szProvider, DWORD dwProvType, DWORD dwFlags)
     * }
     */
    public static FunctionDescriptor CryptAcquireContextW$descriptor() {
        return CryptAcquireContextW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CryptAcquireContextW(HCRYPTPROV *phProv, LPCWSTR szContainer, LPCWSTR szProvider, DWORD dwProvType, DWORD dwFlags)
     * }
     */
    public static MethodHandle CryptAcquireContextW$handle() {
        return CryptAcquireContextW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL CryptAcquireContextW(HCRYPTPROV *phProv, LPCWSTR szContainer, LPCWSTR szProvider, DWORD dwProvType, DWORD dwFlags)
     * }
     */
    public static int CryptAcquireContextW(MemorySegment phProv, MemorySegment szContainer, MemorySegment szProvider, int dwProvType, int dwFlags) {
        var mh$ = CryptAcquireContextW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CryptAcquireContextW", phProv, szContainer, szProvider, dwProvType, dwFlags);
            }
            return (int)mh$.invokeExact(phProv, szContainer, szProvider, dwProvType, dwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CryptReleaseContext {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_LONG_LONG,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CryptReleaseContext"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CryptReleaseContext(HCRYPTPROV hProv, DWORD dwFlags)
     * }
     */
    public static FunctionDescriptor CryptReleaseContext$descriptor() {
        return CryptReleaseContext.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CryptReleaseContext(HCRYPTPROV hProv, DWORD dwFlags)
     * }
     */
    public static MethodHandle CryptReleaseContext$handle() {
        return CryptReleaseContext.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL CryptReleaseContext(HCRYPTPROV hProv, DWORD dwFlags)
     * }
     */
    public static int CryptReleaseContext(long hProv, int dwFlags) {
        var mh$ = CryptReleaseContext.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CryptReleaseContext", hProv, dwFlags);
            }
            return (int)mh$.invokeExact(hProv, dwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CryptGenKey {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_LONG_LONG,
            C_INT,
            C_LONG,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CryptGenKey"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CryptGenKey(HCRYPTPROV hProv, ALG_ID Algid, DWORD dwFlags, HCRYPTKEY *phKey)
     * }
     */
    public static FunctionDescriptor CryptGenKey$descriptor() {
        return CryptGenKey.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CryptGenKey(HCRYPTPROV hProv, ALG_ID Algid, DWORD dwFlags, HCRYPTKEY *phKey)
     * }
     */
    public static MethodHandle CryptGenKey$handle() {
        return CryptGenKey.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL CryptGenKey(HCRYPTPROV hProv, ALG_ID Algid, DWORD dwFlags, HCRYPTKEY *phKey)
     * }
     */
    public static int CryptGenKey(long hProv, int Algid, int dwFlags, MemorySegment phKey) {
        var mh$ = CryptGenKey.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CryptGenKey", hProv, Algid, dwFlags, phKey);
            }
            return (int)mh$.invokeExact(hProv, Algid, dwFlags, phKey);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CryptDeriveKey {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_LONG_LONG,
            C_INT,
            C_LONG_LONG,
            C_LONG,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CryptDeriveKey"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CryptDeriveKey(HCRYPTPROV hProv, ALG_ID Algid, HCRYPTHASH hBaseData, DWORD dwFlags, HCRYPTKEY *phKey)
     * }
     */
    public static FunctionDescriptor CryptDeriveKey$descriptor() {
        return CryptDeriveKey.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CryptDeriveKey(HCRYPTPROV hProv, ALG_ID Algid, HCRYPTHASH hBaseData, DWORD dwFlags, HCRYPTKEY *phKey)
     * }
     */
    public static MethodHandle CryptDeriveKey$handle() {
        return CryptDeriveKey.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL CryptDeriveKey(HCRYPTPROV hProv, ALG_ID Algid, HCRYPTHASH hBaseData, DWORD dwFlags, HCRYPTKEY *phKey)
     * }
     */
    public static int CryptDeriveKey(long hProv, int Algid, long hBaseData, int dwFlags, MemorySegment phKey) {
        var mh$ = CryptDeriveKey.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CryptDeriveKey", hProv, Algid, hBaseData, dwFlags, phKey);
            }
            return (int)mh$.invokeExact(hProv, Algid, hBaseData, dwFlags, phKey);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CryptDestroyKey {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_LONG_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CryptDestroyKey"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CryptDestroyKey(HCRYPTKEY hKey)
     * }
     */
    public static FunctionDescriptor CryptDestroyKey$descriptor() {
        return CryptDestroyKey.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CryptDestroyKey(HCRYPTKEY hKey)
     * }
     */
    public static MethodHandle CryptDestroyKey$handle() {
        return CryptDestroyKey.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL CryptDestroyKey(HCRYPTKEY hKey)
     * }
     */
    public static int CryptDestroyKey(long hKey) {
        var mh$ = CryptDestroyKey.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CryptDestroyKey", hKey);
            }
            return (int)mh$.invokeExact(hKey);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CryptSetKeyParam {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_LONG_LONG,
            C_LONG,
            C_POINTER,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CryptSetKeyParam"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CryptSetKeyParam(HCRYPTKEY hKey, DWORD dwParam, const BYTE *pbData, DWORD dwFlags)
     * }
     */
    public static FunctionDescriptor CryptSetKeyParam$descriptor() {
        return CryptSetKeyParam.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CryptSetKeyParam(HCRYPTKEY hKey, DWORD dwParam, const BYTE *pbData, DWORD dwFlags)
     * }
     */
    public static MethodHandle CryptSetKeyParam$handle() {
        return CryptSetKeyParam.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL CryptSetKeyParam(HCRYPTKEY hKey, DWORD dwParam, const BYTE *pbData, DWORD dwFlags)
     * }
     */
    public static int CryptSetKeyParam(long hKey, int dwParam, MemorySegment pbData, int dwFlags) {
        var mh$ = CryptSetKeyParam.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CryptSetKeyParam", hKey, dwParam, pbData, dwFlags);
            }
            return (int)mh$.invokeExact(hKey, dwParam, pbData, dwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CryptGetKeyParam {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_LONG_LONG,
            C_LONG,
            C_POINTER,
            C_POINTER,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CryptGetKeyParam"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CryptGetKeyParam(HCRYPTKEY hKey, DWORD dwParam, BYTE *pbData, DWORD *pdwDataLen, DWORD dwFlags)
     * }
     */
    public static FunctionDescriptor CryptGetKeyParam$descriptor() {
        return CryptGetKeyParam.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CryptGetKeyParam(HCRYPTKEY hKey, DWORD dwParam, BYTE *pbData, DWORD *pdwDataLen, DWORD dwFlags)
     * }
     */
    public static MethodHandle CryptGetKeyParam$handle() {
        return CryptGetKeyParam.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL CryptGetKeyParam(HCRYPTKEY hKey, DWORD dwParam, BYTE *pbData, DWORD *pdwDataLen, DWORD dwFlags)
     * }
     */
    public static int CryptGetKeyParam(long hKey, int dwParam, MemorySegment pbData, MemorySegment pdwDataLen, int dwFlags) {
        var mh$ = CryptGetKeyParam.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CryptGetKeyParam", hKey, dwParam, pbData, pdwDataLen, dwFlags);
            }
            return (int)mh$.invokeExact(hKey, dwParam, pbData, pdwDataLen, dwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CryptSetHashParam {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_LONG_LONG,
            C_LONG,
            C_POINTER,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CryptSetHashParam"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CryptSetHashParam(HCRYPTHASH hHash, DWORD dwParam, const BYTE *pbData, DWORD dwFlags)
     * }
     */
    public static FunctionDescriptor CryptSetHashParam$descriptor() {
        return CryptSetHashParam.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CryptSetHashParam(HCRYPTHASH hHash, DWORD dwParam, const BYTE *pbData, DWORD dwFlags)
     * }
     */
    public static MethodHandle CryptSetHashParam$handle() {
        return CryptSetHashParam.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL CryptSetHashParam(HCRYPTHASH hHash, DWORD dwParam, const BYTE *pbData, DWORD dwFlags)
     * }
     */
    public static int CryptSetHashParam(long hHash, int dwParam, MemorySegment pbData, int dwFlags) {
        var mh$ = CryptSetHashParam.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CryptSetHashParam", hHash, dwParam, pbData, dwFlags);
            }
            return (int)mh$.invokeExact(hHash, dwParam, pbData, dwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CryptGetHashParam {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_LONG_LONG,
            C_LONG,
            C_POINTER,
            C_POINTER,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CryptGetHashParam"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CryptGetHashParam(HCRYPTHASH hHash, DWORD dwParam, BYTE *pbData, DWORD *pdwDataLen, DWORD dwFlags)
     * }
     */
    public static FunctionDescriptor CryptGetHashParam$descriptor() {
        return CryptGetHashParam.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CryptGetHashParam(HCRYPTHASH hHash, DWORD dwParam, BYTE *pbData, DWORD *pdwDataLen, DWORD dwFlags)
     * }
     */
    public static MethodHandle CryptGetHashParam$handle() {
        return CryptGetHashParam.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL CryptGetHashParam(HCRYPTHASH hHash, DWORD dwParam, BYTE *pbData, DWORD *pdwDataLen, DWORD dwFlags)
     * }
     */
    public static int CryptGetHashParam(long hHash, int dwParam, MemorySegment pbData, MemorySegment pdwDataLen, int dwFlags) {
        var mh$ = CryptGetHashParam.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CryptGetHashParam", hHash, dwParam, pbData, pdwDataLen, dwFlags);
            }
            return (int)mh$.invokeExact(hHash, dwParam, pbData, pdwDataLen, dwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CryptSetProvParam {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_LONG_LONG,
            C_LONG,
            C_POINTER,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CryptSetProvParam"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CryptSetProvParam(HCRYPTPROV hProv, DWORD dwParam, const BYTE *pbData, DWORD dwFlags)
     * }
     */
    public static FunctionDescriptor CryptSetProvParam$descriptor() {
        return CryptSetProvParam.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CryptSetProvParam(HCRYPTPROV hProv, DWORD dwParam, const BYTE *pbData, DWORD dwFlags)
     * }
     */
    public static MethodHandle CryptSetProvParam$handle() {
        return CryptSetProvParam.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL CryptSetProvParam(HCRYPTPROV hProv, DWORD dwParam, const BYTE *pbData, DWORD dwFlags)
     * }
     */
    public static int CryptSetProvParam(long hProv, int dwParam, MemorySegment pbData, int dwFlags) {
        var mh$ = CryptSetProvParam.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CryptSetProvParam", hProv, dwParam, pbData, dwFlags);
            }
            return (int)mh$.invokeExact(hProv, dwParam, pbData, dwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CryptGetProvParam {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_LONG_LONG,
            C_LONG,
            C_POINTER,
            C_POINTER,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CryptGetProvParam"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CryptGetProvParam(HCRYPTPROV hProv, DWORD dwParam, BYTE *pbData, DWORD *pdwDataLen, DWORD dwFlags)
     * }
     */
    public static FunctionDescriptor CryptGetProvParam$descriptor() {
        return CryptGetProvParam.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CryptGetProvParam(HCRYPTPROV hProv, DWORD dwParam, BYTE *pbData, DWORD *pdwDataLen, DWORD dwFlags)
     * }
     */
    public static MethodHandle CryptGetProvParam$handle() {
        return CryptGetProvParam.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL CryptGetProvParam(HCRYPTPROV hProv, DWORD dwParam, BYTE *pbData, DWORD *pdwDataLen, DWORD dwFlags)
     * }
     */
    public static int CryptGetProvParam(long hProv, int dwParam, MemorySegment pbData, MemorySegment pdwDataLen, int dwFlags) {
        var mh$ = CryptGetProvParam.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CryptGetProvParam", hProv, dwParam, pbData, pdwDataLen, dwFlags);
            }
            return (int)mh$.invokeExact(hProv, dwParam, pbData, pdwDataLen, dwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CryptGenRandom {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_LONG_LONG,
            C_LONG,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CryptGenRandom"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CryptGenRandom(HCRYPTPROV hProv, DWORD dwLen, BYTE *pbBuffer)
     * }
     */
    public static FunctionDescriptor CryptGenRandom$descriptor() {
        return CryptGenRandom.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CryptGenRandom(HCRYPTPROV hProv, DWORD dwLen, BYTE *pbBuffer)
     * }
     */
    public static MethodHandle CryptGenRandom$handle() {
        return CryptGenRandom.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL CryptGenRandom(HCRYPTPROV hProv, DWORD dwLen, BYTE *pbBuffer)
     * }
     */
    public static int CryptGenRandom(long hProv, int dwLen, MemorySegment pbBuffer) {
        var mh$ = CryptGenRandom.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CryptGenRandom", hProv, dwLen, pbBuffer);
            }
            return (int)mh$.invokeExact(hProv, dwLen, pbBuffer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CryptGetUserKey {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_LONG_LONG,
            C_LONG,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CryptGetUserKey"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CryptGetUserKey(HCRYPTPROV hProv, DWORD dwKeySpec, HCRYPTKEY *phUserKey)
     * }
     */
    public static FunctionDescriptor CryptGetUserKey$descriptor() {
        return CryptGetUserKey.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CryptGetUserKey(HCRYPTPROV hProv, DWORD dwKeySpec, HCRYPTKEY *phUserKey)
     * }
     */
    public static MethodHandle CryptGetUserKey$handle() {
        return CryptGetUserKey.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL CryptGetUserKey(HCRYPTPROV hProv, DWORD dwKeySpec, HCRYPTKEY *phUserKey)
     * }
     */
    public static int CryptGetUserKey(long hProv, int dwKeySpec, MemorySegment phUserKey) {
        var mh$ = CryptGetUserKey.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CryptGetUserKey", hProv, dwKeySpec, phUserKey);
            }
            return (int)mh$.invokeExact(hProv, dwKeySpec, phUserKey);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CryptExportKey {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_LONG_LONG,
            C_LONG_LONG,
            C_LONG,
            C_LONG,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CryptExportKey"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CryptExportKey(HCRYPTKEY hKey, HCRYPTKEY hExpKey, DWORD dwBlobType, DWORD dwFlags, BYTE *pbData, DWORD *pdwDataLen)
     * }
     */
    public static FunctionDescriptor CryptExportKey$descriptor() {
        return CryptExportKey.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CryptExportKey(HCRYPTKEY hKey, HCRYPTKEY hExpKey, DWORD dwBlobType, DWORD dwFlags, BYTE *pbData, DWORD *pdwDataLen)
     * }
     */
    public static MethodHandle CryptExportKey$handle() {
        return CryptExportKey.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL CryptExportKey(HCRYPTKEY hKey, HCRYPTKEY hExpKey, DWORD dwBlobType, DWORD dwFlags, BYTE *pbData, DWORD *pdwDataLen)
     * }
     */
    public static int CryptExportKey(long hKey, long hExpKey, int dwBlobType, int dwFlags, MemorySegment pbData, MemorySegment pdwDataLen) {
        var mh$ = CryptExportKey.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CryptExportKey", hKey, hExpKey, dwBlobType, dwFlags, pbData, pdwDataLen);
            }
            return (int)mh$.invokeExact(hKey, hExpKey, dwBlobType, dwFlags, pbData, pdwDataLen);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CryptImportKey {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_LONG_LONG,
            C_POINTER,
            C_LONG,
            C_LONG_LONG,
            C_LONG,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CryptImportKey"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CryptImportKey(HCRYPTPROV hProv, const BYTE *pbData, DWORD dwDataLen, HCRYPTKEY hPubKey, DWORD dwFlags, HCRYPTKEY *phKey)
     * }
     */
    public static FunctionDescriptor CryptImportKey$descriptor() {
        return CryptImportKey.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CryptImportKey(HCRYPTPROV hProv, const BYTE *pbData, DWORD dwDataLen, HCRYPTKEY hPubKey, DWORD dwFlags, HCRYPTKEY *phKey)
     * }
     */
    public static MethodHandle CryptImportKey$handle() {
        return CryptImportKey.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL CryptImportKey(HCRYPTPROV hProv, const BYTE *pbData, DWORD dwDataLen, HCRYPTKEY hPubKey, DWORD dwFlags, HCRYPTKEY *phKey)
     * }
     */
    public static int CryptImportKey(long hProv, MemorySegment pbData, int dwDataLen, long hPubKey, int dwFlags, MemorySegment phKey) {
        var mh$ = CryptImportKey.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CryptImportKey", hProv, pbData, dwDataLen, hPubKey, dwFlags, phKey);
            }
            return (int)mh$.invokeExact(hProv, pbData, dwDataLen, hPubKey, dwFlags, phKey);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CryptEncrypt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_LONG_LONG,
            C_LONG_LONG,
            C_INT,
            C_LONG,
            C_POINTER,
            C_POINTER,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CryptEncrypt"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CryptEncrypt(HCRYPTKEY hKey, HCRYPTHASH hHash, BOOL Final, DWORD dwFlags, BYTE *pbData, DWORD *pdwDataLen, DWORD dwBufLen)
     * }
     */
    public static FunctionDescriptor CryptEncrypt$descriptor() {
        return CryptEncrypt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CryptEncrypt(HCRYPTKEY hKey, HCRYPTHASH hHash, BOOL Final, DWORD dwFlags, BYTE *pbData, DWORD *pdwDataLen, DWORD dwBufLen)
     * }
     */
    public static MethodHandle CryptEncrypt$handle() {
        return CryptEncrypt.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL CryptEncrypt(HCRYPTKEY hKey, HCRYPTHASH hHash, BOOL Final, DWORD dwFlags, BYTE *pbData, DWORD *pdwDataLen, DWORD dwBufLen)
     * }
     */
    public static int CryptEncrypt(long hKey, long hHash, int Final, int dwFlags, MemorySegment pbData, MemorySegment pdwDataLen, int dwBufLen) {
        var mh$ = CryptEncrypt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CryptEncrypt", hKey, hHash, Final, dwFlags, pbData, pdwDataLen, dwBufLen);
            }
            return (int)mh$.invokeExact(hKey, hHash, Final, dwFlags, pbData, pdwDataLen, dwBufLen);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CryptDecrypt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_LONG_LONG,
            C_LONG_LONG,
            C_INT,
            C_LONG,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CryptDecrypt"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CryptDecrypt(HCRYPTKEY hKey, HCRYPTHASH hHash, BOOL Final, DWORD dwFlags, BYTE *pbData, DWORD *pdwDataLen)
     * }
     */
    public static FunctionDescriptor CryptDecrypt$descriptor() {
        return CryptDecrypt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CryptDecrypt(HCRYPTKEY hKey, HCRYPTHASH hHash, BOOL Final, DWORD dwFlags, BYTE *pbData, DWORD *pdwDataLen)
     * }
     */
    public static MethodHandle CryptDecrypt$handle() {
        return CryptDecrypt.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL CryptDecrypt(HCRYPTKEY hKey, HCRYPTHASH hHash, BOOL Final, DWORD dwFlags, BYTE *pbData, DWORD *pdwDataLen)
     * }
     */
    public static int CryptDecrypt(long hKey, long hHash, int Final, int dwFlags, MemorySegment pbData, MemorySegment pdwDataLen) {
        var mh$ = CryptDecrypt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CryptDecrypt", hKey, hHash, Final, dwFlags, pbData, pdwDataLen);
            }
            return (int)mh$.invokeExact(hKey, hHash, Final, dwFlags, pbData, pdwDataLen);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CryptCreateHash {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_LONG_LONG,
            C_INT,
            C_LONG_LONG,
            C_LONG,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CryptCreateHash"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CryptCreateHash(HCRYPTPROV hProv, ALG_ID Algid, HCRYPTKEY hKey, DWORD dwFlags, HCRYPTHASH *phHash)
     * }
     */
    public static FunctionDescriptor CryptCreateHash$descriptor() {
        return CryptCreateHash.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CryptCreateHash(HCRYPTPROV hProv, ALG_ID Algid, HCRYPTKEY hKey, DWORD dwFlags, HCRYPTHASH *phHash)
     * }
     */
    public static MethodHandle CryptCreateHash$handle() {
        return CryptCreateHash.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL CryptCreateHash(HCRYPTPROV hProv, ALG_ID Algid, HCRYPTKEY hKey, DWORD dwFlags, HCRYPTHASH *phHash)
     * }
     */
    public static int CryptCreateHash(long hProv, int Algid, long hKey, int dwFlags, MemorySegment phHash) {
        var mh$ = CryptCreateHash.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CryptCreateHash", hProv, Algid, hKey, dwFlags, phHash);
            }
            return (int)mh$.invokeExact(hProv, Algid, hKey, dwFlags, phHash);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CryptHashData {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_LONG_LONG,
            C_POINTER,
            C_LONG,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CryptHashData"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CryptHashData(HCRYPTHASH hHash, const BYTE *pbData, DWORD dwDataLen, DWORD dwFlags)
     * }
     */
    public static FunctionDescriptor CryptHashData$descriptor() {
        return CryptHashData.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CryptHashData(HCRYPTHASH hHash, const BYTE *pbData, DWORD dwDataLen, DWORD dwFlags)
     * }
     */
    public static MethodHandle CryptHashData$handle() {
        return CryptHashData.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL CryptHashData(HCRYPTHASH hHash, const BYTE *pbData, DWORD dwDataLen, DWORD dwFlags)
     * }
     */
    public static int CryptHashData(long hHash, MemorySegment pbData, int dwDataLen, int dwFlags) {
        var mh$ = CryptHashData.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CryptHashData", hHash, pbData, dwDataLen, dwFlags);
            }
            return (int)mh$.invokeExact(hHash, pbData, dwDataLen, dwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CryptHashSessionKey {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_LONG_LONG,
            C_LONG_LONG,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CryptHashSessionKey"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CryptHashSessionKey(HCRYPTHASH hHash, HCRYPTKEY hKey, DWORD dwFlags)
     * }
     */
    public static FunctionDescriptor CryptHashSessionKey$descriptor() {
        return CryptHashSessionKey.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CryptHashSessionKey(HCRYPTHASH hHash, HCRYPTKEY hKey, DWORD dwFlags)
     * }
     */
    public static MethodHandle CryptHashSessionKey$handle() {
        return CryptHashSessionKey.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL CryptHashSessionKey(HCRYPTHASH hHash, HCRYPTKEY hKey, DWORD dwFlags)
     * }
     */
    public static int CryptHashSessionKey(long hHash, long hKey, int dwFlags) {
        var mh$ = CryptHashSessionKey.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CryptHashSessionKey", hHash, hKey, dwFlags);
            }
            return (int)mh$.invokeExact(hHash, hKey, dwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CryptDestroyHash {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_LONG_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CryptDestroyHash"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CryptDestroyHash(HCRYPTHASH hHash)
     * }
     */
    public static FunctionDescriptor CryptDestroyHash$descriptor() {
        return CryptDestroyHash.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CryptDestroyHash(HCRYPTHASH hHash)
     * }
     */
    public static MethodHandle CryptDestroyHash$handle() {
        return CryptDestroyHash.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL CryptDestroyHash(HCRYPTHASH hHash)
     * }
     */
    public static int CryptDestroyHash(long hHash) {
        var mh$ = CryptDestroyHash.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CryptDestroyHash", hHash);
            }
            return (int)mh$.invokeExact(hHash);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CryptSignHashA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_LONG_LONG,
            C_LONG,
            C_POINTER,
            C_LONG,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CryptSignHashA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CryptSignHashA(HCRYPTHASH hHash, DWORD dwKeySpec, LPCSTR szDescription, DWORD dwFlags, BYTE *pbSignature, DWORD *pdwSigLen)
     * }
     */
    public static FunctionDescriptor CryptSignHashA$descriptor() {
        return CryptSignHashA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CryptSignHashA(HCRYPTHASH hHash, DWORD dwKeySpec, LPCSTR szDescription, DWORD dwFlags, BYTE *pbSignature, DWORD *pdwSigLen)
     * }
     */
    public static MethodHandle CryptSignHashA$handle() {
        return CryptSignHashA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL CryptSignHashA(HCRYPTHASH hHash, DWORD dwKeySpec, LPCSTR szDescription, DWORD dwFlags, BYTE *pbSignature, DWORD *pdwSigLen)
     * }
     */
    public static int CryptSignHashA(long hHash, int dwKeySpec, MemorySegment szDescription, int dwFlags, MemorySegment pbSignature, MemorySegment pdwSigLen) {
        var mh$ = CryptSignHashA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CryptSignHashA", hHash, dwKeySpec, szDescription, dwFlags, pbSignature, pdwSigLen);
            }
            return (int)mh$.invokeExact(hHash, dwKeySpec, szDescription, dwFlags, pbSignature, pdwSigLen);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CryptSignHashW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_LONG_LONG,
            C_LONG,
            C_POINTER,
            C_LONG,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CryptSignHashW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CryptSignHashW(HCRYPTHASH hHash, DWORD dwKeySpec, LPCWSTR szDescription, DWORD dwFlags, BYTE *pbSignature, DWORD *pdwSigLen)
     * }
     */
    public static FunctionDescriptor CryptSignHashW$descriptor() {
        return CryptSignHashW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CryptSignHashW(HCRYPTHASH hHash, DWORD dwKeySpec, LPCWSTR szDescription, DWORD dwFlags, BYTE *pbSignature, DWORD *pdwSigLen)
     * }
     */
    public static MethodHandle CryptSignHashW$handle() {
        return CryptSignHashW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL CryptSignHashW(HCRYPTHASH hHash, DWORD dwKeySpec, LPCWSTR szDescription, DWORD dwFlags, BYTE *pbSignature, DWORD *pdwSigLen)
     * }
     */
    public static int CryptSignHashW(long hHash, int dwKeySpec, MemorySegment szDescription, int dwFlags, MemorySegment pbSignature, MemorySegment pdwSigLen) {
        var mh$ = CryptSignHashW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CryptSignHashW", hHash, dwKeySpec, szDescription, dwFlags, pbSignature, pdwSigLen);
            }
            return (int)mh$.invokeExact(hHash, dwKeySpec, szDescription, dwFlags, pbSignature, pdwSigLen);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CryptVerifySignatureA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_LONG_LONG,
            C_POINTER,
            C_LONG,
            C_LONG_LONG,
            C_POINTER,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CryptVerifySignatureA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CryptVerifySignatureA(HCRYPTHASH hHash, const BYTE *pbSignature, DWORD dwSigLen, HCRYPTKEY hPubKey, LPCSTR szDescription, DWORD dwFlags)
     * }
     */
    public static FunctionDescriptor CryptVerifySignatureA$descriptor() {
        return CryptVerifySignatureA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CryptVerifySignatureA(HCRYPTHASH hHash, const BYTE *pbSignature, DWORD dwSigLen, HCRYPTKEY hPubKey, LPCSTR szDescription, DWORD dwFlags)
     * }
     */
    public static MethodHandle CryptVerifySignatureA$handle() {
        return CryptVerifySignatureA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL CryptVerifySignatureA(HCRYPTHASH hHash, const BYTE *pbSignature, DWORD dwSigLen, HCRYPTKEY hPubKey, LPCSTR szDescription, DWORD dwFlags)
     * }
     */
    public static int CryptVerifySignatureA(long hHash, MemorySegment pbSignature, int dwSigLen, long hPubKey, MemorySegment szDescription, int dwFlags) {
        var mh$ = CryptVerifySignatureA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CryptVerifySignatureA", hHash, pbSignature, dwSigLen, hPubKey, szDescription, dwFlags);
            }
            return (int)mh$.invokeExact(hHash, pbSignature, dwSigLen, hPubKey, szDescription, dwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CryptVerifySignatureW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_LONG_LONG,
            C_POINTER,
            C_LONG,
            C_LONG_LONG,
            C_POINTER,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CryptVerifySignatureW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CryptVerifySignatureW(HCRYPTHASH hHash, const BYTE *pbSignature, DWORD dwSigLen, HCRYPTKEY hPubKey, LPCWSTR szDescription, DWORD dwFlags)
     * }
     */
    public static FunctionDescriptor CryptVerifySignatureW$descriptor() {
        return CryptVerifySignatureW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CryptVerifySignatureW(HCRYPTHASH hHash, const BYTE *pbSignature, DWORD dwSigLen, HCRYPTKEY hPubKey, LPCWSTR szDescription, DWORD dwFlags)
     * }
     */
    public static MethodHandle CryptVerifySignatureW$handle() {
        return CryptVerifySignatureW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL CryptVerifySignatureW(HCRYPTHASH hHash, const BYTE *pbSignature, DWORD dwSigLen, HCRYPTKEY hPubKey, LPCWSTR szDescription, DWORD dwFlags)
     * }
     */
    public static int CryptVerifySignatureW(long hHash, MemorySegment pbSignature, int dwSigLen, long hPubKey, MemorySegment szDescription, int dwFlags) {
        var mh$ = CryptVerifySignatureW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CryptVerifySignatureW", hHash, pbSignature, dwSigLen, hPubKey, szDescription, dwFlags);
            }
            return (int)mh$.invokeExact(hHash, pbSignature, dwSigLen, hPubKey, szDescription, dwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CryptSetProviderA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CryptSetProviderA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CryptSetProviderA(LPCSTR pszProvName, DWORD dwProvType)
     * }
     */
    public static FunctionDescriptor CryptSetProviderA$descriptor() {
        return CryptSetProviderA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CryptSetProviderA(LPCSTR pszProvName, DWORD dwProvType)
     * }
     */
    public static MethodHandle CryptSetProviderA$handle() {
        return CryptSetProviderA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL CryptSetProviderA(LPCSTR pszProvName, DWORD dwProvType)
     * }
     */
    public static int CryptSetProviderA(MemorySegment pszProvName, int dwProvType) {
        var mh$ = CryptSetProviderA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CryptSetProviderA", pszProvName, dwProvType);
            }
            return (int)mh$.invokeExact(pszProvName, dwProvType);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CryptSetProviderW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CryptSetProviderW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CryptSetProviderW(LPCWSTR pszProvName, DWORD dwProvType)
     * }
     */
    public static FunctionDescriptor CryptSetProviderW$descriptor() {
        return CryptSetProviderW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CryptSetProviderW(LPCWSTR pszProvName, DWORD dwProvType)
     * }
     */
    public static MethodHandle CryptSetProviderW$handle() {
        return CryptSetProviderW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL CryptSetProviderW(LPCWSTR pszProvName, DWORD dwProvType)
     * }
     */
    public static int CryptSetProviderW(MemorySegment pszProvName, int dwProvType) {
        var mh$ = CryptSetProviderW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CryptSetProviderW", pszProvName, dwProvType);
            }
            return (int)mh$.invokeExact(pszProvName, dwProvType);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CryptSetProviderExA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_LONG,
            C_POINTER,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CryptSetProviderExA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CryptSetProviderExA(LPCSTR pszProvName, DWORD dwProvType, DWORD *pdwReserved, DWORD dwFlags)
     * }
     */
    public static FunctionDescriptor CryptSetProviderExA$descriptor() {
        return CryptSetProviderExA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CryptSetProviderExA(LPCSTR pszProvName, DWORD dwProvType, DWORD *pdwReserved, DWORD dwFlags)
     * }
     */
    public static MethodHandle CryptSetProviderExA$handle() {
        return CryptSetProviderExA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL CryptSetProviderExA(LPCSTR pszProvName, DWORD dwProvType, DWORD *pdwReserved, DWORD dwFlags)
     * }
     */
    public static int CryptSetProviderExA(MemorySegment pszProvName, int dwProvType, MemorySegment pdwReserved, int dwFlags) {
        var mh$ = CryptSetProviderExA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CryptSetProviderExA", pszProvName, dwProvType, pdwReserved, dwFlags);
            }
            return (int)mh$.invokeExact(pszProvName, dwProvType, pdwReserved, dwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CryptSetProviderExW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_LONG,
            C_POINTER,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CryptSetProviderExW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CryptSetProviderExW(LPCWSTR pszProvName, DWORD dwProvType, DWORD *pdwReserved, DWORD dwFlags)
     * }
     */
    public static FunctionDescriptor CryptSetProviderExW$descriptor() {
        return CryptSetProviderExW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CryptSetProviderExW(LPCWSTR pszProvName, DWORD dwProvType, DWORD *pdwReserved, DWORD dwFlags)
     * }
     */
    public static MethodHandle CryptSetProviderExW$handle() {
        return CryptSetProviderExW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL CryptSetProviderExW(LPCWSTR pszProvName, DWORD dwProvType, DWORD *pdwReserved, DWORD dwFlags)
     * }
     */
    public static int CryptSetProviderExW(MemorySegment pszProvName, int dwProvType, MemorySegment pdwReserved, int dwFlags) {
        var mh$ = CryptSetProviderExW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CryptSetProviderExW", pszProvName, dwProvType, pdwReserved, dwFlags);
            }
            return (int)mh$.invokeExact(pszProvName, dwProvType, pdwReserved, dwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CryptGetDefaultProviderA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_LONG,
            C_POINTER,
            C_LONG,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CryptGetDefaultProviderA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CryptGetDefaultProviderA(DWORD dwProvType, DWORD *pdwReserved, DWORD dwFlags, LPSTR pszProvName, DWORD *pcbProvName)
     * }
     */
    public static FunctionDescriptor CryptGetDefaultProviderA$descriptor() {
        return CryptGetDefaultProviderA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CryptGetDefaultProviderA(DWORD dwProvType, DWORD *pdwReserved, DWORD dwFlags, LPSTR pszProvName, DWORD *pcbProvName)
     * }
     */
    public static MethodHandle CryptGetDefaultProviderA$handle() {
        return CryptGetDefaultProviderA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL CryptGetDefaultProviderA(DWORD dwProvType, DWORD *pdwReserved, DWORD dwFlags, LPSTR pszProvName, DWORD *pcbProvName)
     * }
     */
    public static int CryptGetDefaultProviderA(int dwProvType, MemorySegment pdwReserved, int dwFlags, MemorySegment pszProvName, MemorySegment pcbProvName) {
        var mh$ = CryptGetDefaultProviderA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CryptGetDefaultProviderA", dwProvType, pdwReserved, dwFlags, pszProvName, pcbProvName);
            }
            return (int)mh$.invokeExact(dwProvType, pdwReserved, dwFlags, pszProvName, pcbProvName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CryptGetDefaultProviderW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_LONG,
            C_POINTER,
            C_LONG,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CryptGetDefaultProviderW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CryptGetDefaultProviderW(DWORD dwProvType, DWORD *pdwReserved, DWORD dwFlags, LPWSTR pszProvName, DWORD *pcbProvName)
     * }
     */
    public static FunctionDescriptor CryptGetDefaultProviderW$descriptor() {
        return CryptGetDefaultProviderW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CryptGetDefaultProviderW(DWORD dwProvType, DWORD *pdwReserved, DWORD dwFlags, LPWSTR pszProvName, DWORD *pcbProvName)
     * }
     */
    public static MethodHandle CryptGetDefaultProviderW$handle() {
        return CryptGetDefaultProviderW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL CryptGetDefaultProviderW(DWORD dwProvType, DWORD *pdwReserved, DWORD dwFlags, LPWSTR pszProvName, DWORD *pcbProvName)
     * }
     */
    public static int CryptGetDefaultProviderW(int dwProvType, MemorySegment pdwReserved, int dwFlags, MemorySegment pszProvName, MemorySegment pcbProvName) {
        var mh$ = CryptGetDefaultProviderW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CryptGetDefaultProviderW", dwProvType, pdwReserved, dwFlags, pszProvName, pcbProvName);
            }
            return (int)mh$.invokeExact(dwProvType, pdwReserved, dwFlags, pszProvName, pcbProvName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CryptEnumProviderTypesA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_LONG,
            C_POINTER,
            C_LONG,
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CryptEnumProviderTypesA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CryptEnumProviderTypesA(DWORD dwIndex, DWORD *pdwReserved, DWORD dwFlags, DWORD *pdwProvType, LPSTR szTypeName, DWORD *pcbTypeName)
     * }
     */
    public static FunctionDescriptor CryptEnumProviderTypesA$descriptor() {
        return CryptEnumProviderTypesA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CryptEnumProviderTypesA(DWORD dwIndex, DWORD *pdwReserved, DWORD dwFlags, DWORD *pdwProvType, LPSTR szTypeName, DWORD *pcbTypeName)
     * }
     */
    public static MethodHandle CryptEnumProviderTypesA$handle() {
        return CryptEnumProviderTypesA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL CryptEnumProviderTypesA(DWORD dwIndex, DWORD *pdwReserved, DWORD dwFlags, DWORD *pdwProvType, LPSTR szTypeName, DWORD *pcbTypeName)
     * }
     */
    public static int CryptEnumProviderTypesA(int dwIndex, MemorySegment pdwReserved, int dwFlags, MemorySegment pdwProvType, MemorySegment szTypeName, MemorySegment pcbTypeName) {
        var mh$ = CryptEnumProviderTypesA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CryptEnumProviderTypesA", dwIndex, pdwReserved, dwFlags, pdwProvType, szTypeName, pcbTypeName);
            }
            return (int)mh$.invokeExact(dwIndex, pdwReserved, dwFlags, pdwProvType, szTypeName, pcbTypeName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CryptEnumProviderTypesW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_LONG,
            C_POINTER,
            C_LONG,
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CryptEnumProviderTypesW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CryptEnumProviderTypesW(DWORD dwIndex, DWORD *pdwReserved, DWORD dwFlags, DWORD *pdwProvType, LPWSTR szTypeName, DWORD *pcbTypeName)
     * }
     */
    public static FunctionDescriptor CryptEnumProviderTypesW$descriptor() {
        return CryptEnumProviderTypesW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CryptEnumProviderTypesW(DWORD dwIndex, DWORD *pdwReserved, DWORD dwFlags, DWORD *pdwProvType, LPWSTR szTypeName, DWORD *pcbTypeName)
     * }
     */
    public static MethodHandle CryptEnumProviderTypesW$handle() {
        return CryptEnumProviderTypesW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL CryptEnumProviderTypesW(DWORD dwIndex, DWORD *pdwReserved, DWORD dwFlags, DWORD *pdwProvType, LPWSTR szTypeName, DWORD *pcbTypeName)
     * }
     */
    public static int CryptEnumProviderTypesW(int dwIndex, MemorySegment pdwReserved, int dwFlags, MemorySegment pdwProvType, MemorySegment szTypeName, MemorySegment pcbTypeName) {
        var mh$ = CryptEnumProviderTypesW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CryptEnumProviderTypesW", dwIndex, pdwReserved, dwFlags, pdwProvType, szTypeName, pcbTypeName);
            }
            return (int)mh$.invokeExact(dwIndex, pdwReserved, dwFlags, pdwProvType, szTypeName, pcbTypeName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CryptEnumProvidersA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_LONG,
            C_POINTER,
            C_LONG,
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CryptEnumProvidersA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CryptEnumProvidersA(DWORD dwIndex, DWORD *pdwReserved, DWORD dwFlags, DWORD *pdwProvType, LPSTR szProvName, DWORD *pcbProvName)
     * }
     */
    public static FunctionDescriptor CryptEnumProvidersA$descriptor() {
        return CryptEnumProvidersA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CryptEnumProvidersA(DWORD dwIndex, DWORD *pdwReserved, DWORD dwFlags, DWORD *pdwProvType, LPSTR szProvName, DWORD *pcbProvName)
     * }
     */
    public static MethodHandle CryptEnumProvidersA$handle() {
        return CryptEnumProvidersA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL CryptEnumProvidersA(DWORD dwIndex, DWORD *pdwReserved, DWORD dwFlags, DWORD *pdwProvType, LPSTR szProvName, DWORD *pcbProvName)
     * }
     */
    public static int CryptEnumProvidersA(int dwIndex, MemorySegment pdwReserved, int dwFlags, MemorySegment pdwProvType, MemorySegment szProvName, MemorySegment pcbProvName) {
        var mh$ = CryptEnumProvidersA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CryptEnumProvidersA", dwIndex, pdwReserved, dwFlags, pdwProvType, szProvName, pcbProvName);
            }
            return (int)mh$.invokeExact(dwIndex, pdwReserved, dwFlags, pdwProvType, szProvName, pcbProvName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CryptEnumProvidersW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_LONG,
            C_POINTER,
            C_LONG,
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CryptEnumProvidersW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CryptEnumProvidersW(DWORD dwIndex, DWORD *pdwReserved, DWORD dwFlags, DWORD *pdwProvType, LPWSTR szProvName, DWORD *pcbProvName)
     * }
     */
    public static FunctionDescriptor CryptEnumProvidersW$descriptor() {
        return CryptEnumProvidersW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CryptEnumProvidersW(DWORD dwIndex, DWORD *pdwReserved, DWORD dwFlags, DWORD *pdwProvType, LPWSTR szProvName, DWORD *pcbProvName)
     * }
     */
    public static MethodHandle CryptEnumProvidersW$handle() {
        return CryptEnumProvidersW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL CryptEnumProvidersW(DWORD dwIndex, DWORD *pdwReserved, DWORD dwFlags, DWORD *pdwProvType, LPWSTR szProvName, DWORD *pcbProvName)
     * }
     */
    public static int CryptEnumProvidersW(int dwIndex, MemorySegment pdwReserved, int dwFlags, MemorySegment pdwProvType, MemorySegment szProvName, MemorySegment pcbProvName) {
        var mh$ = CryptEnumProvidersW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CryptEnumProvidersW", dwIndex, pdwReserved, dwFlags, pdwProvType, szProvName, pcbProvName);
            }
            return (int)mh$.invokeExact(dwIndex, pdwReserved, dwFlags, pdwProvType, szProvName, pcbProvName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CryptContextAddRef {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_LONG_LONG,
            C_POINTER,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CryptContextAddRef"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CryptContextAddRef(HCRYPTPROV hProv, DWORD *pdwReserved, DWORD dwFlags)
     * }
     */
    public static FunctionDescriptor CryptContextAddRef$descriptor() {
        return CryptContextAddRef.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CryptContextAddRef(HCRYPTPROV hProv, DWORD *pdwReserved, DWORD dwFlags)
     * }
     */
    public static MethodHandle CryptContextAddRef$handle() {
        return CryptContextAddRef.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL CryptContextAddRef(HCRYPTPROV hProv, DWORD *pdwReserved, DWORD dwFlags)
     * }
     */
    public static int CryptContextAddRef(long hProv, MemorySegment pdwReserved, int dwFlags) {
        var mh$ = CryptContextAddRef.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CryptContextAddRef", hProv, pdwReserved, dwFlags);
            }
            return (int)mh$.invokeExact(hProv, pdwReserved, dwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CryptDuplicateKey {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_LONG_LONG,
            C_POINTER,
            C_LONG,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CryptDuplicateKey"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CryptDuplicateKey(HCRYPTKEY hKey, DWORD *pdwReserved, DWORD dwFlags, HCRYPTKEY *phKey)
     * }
     */
    public static FunctionDescriptor CryptDuplicateKey$descriptor() {
        return CryptDuplicateKey.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CryptDuplicateKey(HCRYPTKEY hKey, DWORD *pdwReserved, DWORD dwFlags, HCRYPTKEY *phKey)
     * }
     */
    public static MethodHandle CryptDuplicateKey$handle() {
        return CryptDuplicateKey.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL CryptDuplicateKey(HCRYPTKEY hKey, DWORD *pdwReserved, DWORD dwFlags, HCRYPTKEY *phKey)
     * }
     */
    public static int CryptDuplicateKey(long hKey, MemorySegment pdwReserved, int dwFlags, MemorySegment phKey) {
        var mh$ = CryptDuplicateKey.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CryptDuplicateKey", hKey, pdwReserved, dwFlags, phKey);
            }
            return (int)mh$.invokeExact(hKey, pdwReserved, dwFlags, phKey);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CryptDuplicateHash {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_LONG_LONG,
            C_POINTER,
            C_LONG,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CryptDuplicateHash"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CryptDuplicateHash(HCRYPTHASH hHash, DWORD *pdwReserved, DWORD dwFlags, HCRYPTHASH *phHash)
     * }
     */
    public static FunctionDescriptor CryptDuplicateHash$descriptor() {
        return CryptDuplicateHash.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CryptDuplicateHash(HCRYPTHASH hHash, DWORD *pdwReserved, DWORD dwFlags, HCRYPTHASH *phHash)
     * }
     */
    public static MethodHandle CryptDuplicateHash$handle() {
        return CryptDuplicateHash.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL CryptDuplicateHash(HCRYPTHASH hHash, DWORD *pdwReserved, DWORD dwFlags, HCRYPTHASH *phHash)
     * }
     */
    public static int CryptDuplicateHash(long hHash, MemorySegment pdwReserved, int dwFlags, MemorySegment phHash) {
        var mh$ = CryptDuplicateHash.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CryptDuplicateHash", hHash, pdwReserved, dwFlags, phHash);
            }
            return (int)mh$.invokeExact(hHash, pdwReserved, dwFlags, phHash);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetEncSChannel {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetEncSChannel"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetEncSChannel(BYTE **pData, DWORD *dwDecSize)
     * }
     */
    public static FunctionDescriptor GetEncSChannel$descriptor() {
        return GetEncSChannel.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetEncSChannel(BYTE **pData, DWORD *dwDecSize)
     * }
     */
    public static MethodHandle GetEncSChannel$handle() {
        return GetEncSChannel.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL GetEncSChannel(BYTE **pData, DWORD *dwDecSize)
     * }
     */
    public static int GetEncSChannel(MemorySegment pData, MemorySegment dwDecSize) {
        var mh$ = GetEncSChannel.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetEncSChannel", pData, dwDecSize);
            }
            return (int)mh$.invokeExact(pData, dwDecSize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef LONG NTSTATUS
     * }
     */
    public static final OfInt NTSTATUS = C_LONG;
    /**
     * {@snippet lang=c :
     * typedef NTSTATUS *PNTSTATUS
     * }
     */
    public static final AddressLayout PNTSTATUS = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _BCRYPT_AUTHENTICATED_CIPHER_MODE_INFO {
     *     ULONG cbSize;
     *     ULONG dwInfoVersion;
     *     PUCHAR pbNonce;
     *     ULONG cbNonce;
     *     PUCHAR pbAuthData;
     *     ULONG cbAuthData;
     *     PUCHAR pbTag;
     *     ULONG cbTag;
     *     PUCHAR pbMacContext;
     *     ULONG cbMacContext;
     *     ULONG cbAAD;
     *     ULONGLONG cbData;
     *     ULONG dwFlags;
     * } *PBCRYPT_AUTHENTICATED_CIPHER_MODE_INFO
     * }
     */
    public static final AddressLayout PBCRYPT_AUTHENTICATED_CIPHER_MODE_INFO = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _BCryptBuffer {
     *     ULONG cbBuffer;
     *     ULONG BufferType;
     *     PVOID pvBuffer;
     * } *PBCryptBuffer
     * }
     */
    public static final AddressLayout PBCryptBuffer = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _BCryptBufferDesc {
     *     ULONG ulVersion;
     *     ULONG cBuffers;
     *     PBCryptBuffer pBuffers;
     * } *PBCryptBufferDesc
     * }
     */
    public static final AddressLayout PBCryptBufferDesc = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef PVOID BCRYPT_HANDLE
     * }
     */
    public static final AddressLayout BCRYPT_HANDLE = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef PVOID BCRYPT_ALG_HANDLE
     * }
     */
    public static final AddressLayout BCRYPT_ALG_HANDLE = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef PVOID BCRYPT_KEY_HANDLE
     * }
     */
    public static final AddressLayout BCRYPT_KEY_HANDLE = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef PVOID BCRYPT_HASH_HANDLE
     * }
     */
    public static final AddressLayout BCRYPT_HASH_HANDLE = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef PVOID BCRYPT_SECRET_HANDLE
     * }
     */
    public static final AddressLayout BCRYPT_SECRET_HANDLE = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _BCRYPT_ECCKEY_BLOB {
     *     ULONG dwMagic;
     *     ULONG cbKey;
     * } *PBCRYPT_ECCKEY_BLOB
     * }
     */
    public static final AddressLayout PBCRYPT_ECCKEY_BLOB = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _SSL_ECCKEY_BLOB {
     *     ULONG dwCurveType;
     *     ULONG cbKey;
     * } *PSSL_ECCKEY_BLOB
     * }
     */
    public static final AddressLayout PSSL_ECCKEY_BLOB = C_POINTER;
    private static final int BCRYPT_ECC_PRIME_SHORT_WEIERSTRASS_CURVE = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.BCRYPT_ECC_PRIME_SHORT_WEIERSTRASS_CURVE = 1
     * }
     */
    public static int BCRYPT_ECC_PRIME_SHORT_WEIERSTRASS_CURVE() {
        return BCRYPT_ECC_PRIME_SHORT_WEIERSTRASS_CURVE;
    }
    private static final int BCRYPT_ECC_PRIME_TWISTED_EDWARDS_CURVE = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.BCRYPT_ECC_PRIME_TWISTED_EDWARDS_CURVE = 2
     * }
     */
    public static int BCRYPT_ECC_PRIME_TWISTED_EDWARDS_CURVE() {
        return BCRYPT_ECC_PRIME_TWISTED_EDWARDS_CURVE;
    }
    private static final int BCRYPT_ECC_PRIME_MONTGOMERY_CURVE = (int)3L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.BCRYPT_ECC_PRIME_MONTGOMERY_CURVE = 3
     * }
     */
    public static int BCRYPT_ECC_PRIME_MONTGOMERY_CURVE() {
        return BCRYPT_ECC_PRIME_MONTGOMERY_CURVE;
    }
    private static final int BCRYPT_NO_CURVE_GENERATION_ALG_ID = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.BCRYPT_NO_CURVE_GENERATION_ALG_ID = 0
     * }
     */
    public static int BCRYPT_NO_CURVE_GENERATION_ALG_ID() {
        return BCRYPT_NO_CURVE_GENERATION_ALG_ID;
    }
    /**
     * {@snippet lang=c :
     * typedef struct _BCRYPT_ECCFULLKEY_BLOB {
     *     ULONG dwMagic;
     *     ULONG dwVersion;
     *     ECC_CURVE_TYPE_ENUM dwCurveType;
     *     ECC_CURVE_ALG_ID_ENUM dwCurveGenerationAlgId;
     *     ULONG cbFieldLength;
     *     ULONG cbSubgroupOrder;
     *     ULONG cbCofactor;
     *     ULONG cbSeed;
     * } *PBCRYPT_ECCFULLKEY_BLOB
     * }
     */
    public static final AddressLayout PBCRYPT_ECCFULLKEY_BLOB = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _BCRYPT_DH_KEY_BLOB {
     *     ULONG dwMagic;
     *     ULONG cbKey;
     * } *PBCRYPT_DH_KEY_BLOB
     * }
     */
    public static final AddressLayout PBCRYPT_DH_KEY_BLOB = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _BCRYPT_DSA_KEY_BLOB {
     *     ULONG dwMagic;
     *     ULONG cbKey;
     *     UCHAR Count[4];
     *     UCHAR Seed[20];
     *     UCHAR q[20];
     * } *PBCRYPT_DSA_KEY_BLOB
     * }
     */
    public static final AddressLayout PBCRYPT_DSA_KEY_BLOB = C_POINTER;
    private static final int DSA_HASH_ALGORITHM_SHA1 = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.DSA_HASH_ALGORITHM_SHA1 = 0
     * }
     */
    public static int DSA_HASH_ALGORITHM_SHA1() {
        return DSA_HASH_ALGORITHM_SHA1;
    }
    private static final int DSA_HASH_ALGORITHM_SHA256 = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.DSA_HASH_ALGORITHM_SHA256 = 1
     * }
     */
    public static int DSA_HASH_ALGORITHM_SHA256() {
        return DSA_HASH_ALGORITHM_SHA256;
    }
    private static final int DSA_HASH_ALGORITHM_SHA512 = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.DSA_HASH_ALGORITHM_SHA512 = 2
     * }
     */
    public static int DSA_HASH_ALGORITHM_SHA512() {
        return DSA_HASH_ALGORITHM_SHA512;
    }
    private static final int DSA_FIPS186_2 = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.DSA_FIPS186_2 = 0
     * }
     */
    public static int DSA_FIPS186_2() {
        return DSA_FIPS186_2;
    }
    private static final int DSA_FIPS186_3 = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.DSA_FIPS186_3 = 1
     * }
     */
    public static int DSA_FIPS186_3() {
        return DSA_FIPS186_3;
    }
    /**
     * {@snippet lang=c :
     * typedef struct _BCRYPT_DSA_KEY_BLOB_V2 {
     *     ULONG dwMagic;
     *     ULONG cbKey;
     *     HASHALGORITHM_ENUM hashAlgorithm;
     *     DSAFIPSVERSION_ENUM standardVersion;
     *     ULONG cbSeedLength;
     *     ULONG cbGroupSize;
     *     UCHAR Count[4];
     * } *PBCRYPT_DSA_KEY_BLOB_V2
     * }
     */
    public static final AddressLayout PBCRYPT_DSA_KEY_BLOB_V2 = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _BCRYPT_KEY_DATA_BLOB_HEADER {
     *     ULONG dwMagic;
     *     ULONG dwVersion;
     *     ULONG cbKeyData;
     * } *PBCRYPT_KEY_DATA_BLOB_HEADER
     * }
     */
    public static final AddressLayout PBCRYPT_KEY_DATA_BLOB_HEADER = C_POINTER;
    private static final int BCRYPT_HASH_OPERATION_HASH_DATA = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.BCRYPT_HASH_OPERATION_HASH_DATA = 1
     * }
     */
    public static int BCRYPT_HASH_OPERATION_HASH_DATA() {
        return BCRYPT_HASH_OPERATION_HASH_DATA;
    }
    private static final int BCRYPT_HASH_OPERATION_FINISH_HASH = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.BCRYPT_HASH_OPERATION_FINISH_HASH = 2
     * }
     */
    public static int BCRYPT_HASH_OPERATION_FINISH_HASH() {
        return BCRYPT_HASH_OPERATION_FINISH_HASH;
    }
    private static final int BCRYPT_OPERATION_TYPE_HASH = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.BCRYPT_OPERATION_TYPE_HASH = 1
     * }
     */
    public static int BCRYPT_OPERATION_TYPE_HASH() {
        return BCRYPT_OPERATION_TYPE_HASH;
    }

    private static class BCryptOpenAlgorithmProvider {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("BCryptOpenAlgorithmProvider"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * NTSTATUS BCryptOpenAlgorithmProvider(BCRYPT_ALG_HANDLE *phAlgorithm, LPCWSTR pszAlgId, LPCWSTR pszImplementation, ULONG dwFlags)
     * }
     */
    public static FunctionDescriptor BCryptOpenAlgorithmProvider$descriptor() {
        return BCryptOpenAlgorithmProvider.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * NTSTATUS BCryptOpenAlgorithmProvider(BCRYPT_ALG_HANDLE *phAlgorithm, LPCWSTR pszAlgId, LPCWSTR pszImplementation, ULONG dwFlags)
     * }
     */
    public static MethodHandle BCryptOpenAlgorithmProvider$handle() {
        return BCryptOpenAlgorithmProvider.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * NTSTATUS BCryptOpenAlgorithmProvider(BCRYPT_ALG_HANDLE *phAlgorithm, LPCWSTR pszAlgId, LPCWSTR pszImplementation, ULONG dwFlags)
     * }
     */
    public static int BCryptOpenAlgorithmProvider(MemorySegment phAlgorithm, MemorySegment pszAlgId, MemorySegment pszImplementation, int dwFlags) {
        var mh$ = BCryptOpenAlgorithmProvider.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("BCryptOpenAlgorithmProvider", phAlgorithm, pszAlgId, pszImplementation, dwFlags);
            }
            return (int)mh$.invokeExact(phAlgorithm, pszAlgId, pszImplementation, dwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class BCryptEnumAlgorithms {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_LONG,
            C_POINTER,
            C_POINTER,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("BCryptEnumAlgorithms"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * NTSTATUS BCryptEnumAlgorithms(ULONG dwAlgOperations, ULONG *pAlgCount, BCRYPT_ALGORITHM_IDENTIFIER **ppAlgList, ULONG dwFlags)
     * }
     */
    public static FunctionDescriptor BCryptEnumAlgorithms$descriptor() {
        return BCryptEnumAlgorithms.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * NTSTATUS BCryptEnumAlgorithms(ULONG dwAlgOperations, ULONG *pAlgCount, BCRYPT_ALGORITHM_IDENTIFIER **ppAlgList, ULONG dwFlags)
     * }
     */
    public static MethodHandle BCryptEnumAlgorithms$handle() {
        return BCryptEnumAlgorithms.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * NTSTATUS BCryptEnumAlgorithms(ULONG dwAlgOperations, ULONG *pAlgCount, BCRYPT_ALGORITHM_IDENTIFIER **ppAlgList, ULONG dwFlags)
     * }
     */
    public static int BCryptEnumAlgorithms(int dwAlgOperations, MemorySegment pAlgCount, MemorySegment ppAlgList, int dwFlags) {
        var mh$ = BCryptEnumAlgorithms.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("BCryptEnumAlgorithms", dwAlgOperations, pAlgCount, ppAlgList, dwFlags);
            }
            return (int)mh$.invokeExact(dwAlgOperations, pAlgCount, ppAlgList, dwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class BCryptEnumProviders {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("BCryptEnumProviders"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * NTSTATUS BCryptEnumProviders(LPCWSTR pszAlgId, ULONG *pImplCount, BCRYPT_PROVIDER_NAME **ppImplList, ULONG dwFlags)
     * }
     */
    public static FunctionDescriptor BCryptEnumProviders$descriptor() {
        return BCryptEnumProviders.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * NTSTATUS BCryptEnumProviders(LPCWSTR pszAlgId, ULONG *pImplCount, BCRYPT_PROVIDER_NAME **ppImplList, ULONG dwFlags)
     * }
     */
    public static MethodHandle BCryptEnumProviders$handle() {
        return BCryptEnumProviders.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * NTSTATUS BCryptEnumProviders(LPCWSTR pszAlgId, ULONG *pImplCount, BCRYPT_PROVIDER_NAME **ppImplList, ULONG dwFlags)
     * }
     */
    public static int BCryptEnumProviders(MemorySegment pszAlgId, MemorySegment pImplCount, MemorySegment ppImplList, int dwFlags) {
        var mh$ = BCryptEnumProviders.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("BCryptEnumProviders", pszAlgId, pImplCount, ppImplList, dwFlags);
            }
            return (int)mh$.invokeExact(pszAlgId, pImplCount, ppImplList, dwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class BCryptGetProperty {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_LONG,
            C_POINTER,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("BCryptGetProperty"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * NTSTATUS BCryptGetProperty(BCRYPT_HANDLE hObject, LPCWSTR pszProperty, PUCHAR pbOutput, ULONG cbOutput, ULONG *pcbResult, ULONG dwFlags)
     * }
     */
    public static FunctionDescriptor BCryptGetProperty$descriptor() {
        return BCryptGetProperty.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * NTSTATUS BCryptGetProperty(BCRYPT_HANDLE hObject, LPCWSTR pszProperty, PUCHAR pbOutput, ULONG cbOutput, ULONG *pcbResult, ULONG dwFlags)
     * }
     */
    public static MethodHandle BCryptGetProperty$handle() {
        return BCryptGetProperty.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * NTSTATUS BCryptGetProperty(BCRYPT_HANDLE hObject, LPCWSTR pszProperty, PUCHAR pbOutput, ULONG cbOutput, ULONG *pcbResult, ULONG dwFlags)
     * }
     */
    public static int BCryptGetProperty(MemorySegment hObject, MemorySegment pszProperty, MemorySegment pbOutput, int cbOutput, MemorySegment pcbResult, int dwFlags) {
        var mh$ = BCryptGetProperty.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("BCryptGetProperty", hObject, pszProperty, pbOutput, cbOutput, pcbResult, dwFlags);
            }
            return (int)mh$.invokeExact(hObject, pszProperty, pbOutput, cbOutput, pcbResult, dwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class BCryptSetProperty {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_LONG,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("BCryptSetProperty"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * NTSTATUS BCryptSetProperty(BCRYPT_HANDLE hObject, LPCWSTR pszProperty, PUCHAR pbInput, ULONG cbInput, ULONG dwFlags)
     * }
     */
    public static FunctionDescriptor BCryptSetProperty$descriptor() {
        return BCryptSetProperty.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * NTSTATUS BCryptSetProperty(BCRYPT_HANDLE hObject, LPCWSTR pszProperty, PUCHAR pbInput, ULONG cbInput, ULONG dwFlags)
     * }
     */
    public static MethodHandle BCryptSetProperty$handle() {
        return BCryptSetProperty.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * NTSTATUS BCryptSetProperty(BCRYPT_HANDLE hObject, LPCWSTR pszProperty, PUCHAR pbInput, ULONG cbInput, ULONG dwFlags)
     * }
     */
    public static int BCryptSetProperty(MemorySegment hObject, MemorySegment pszProperty, MemorySegment pbInput, int cbInput, int dwFlags) {
        var mh$ = BCryptSetProperty.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("BCryptSetProperty", hObject, pszProperty, pbInput, cbInput, dwFlags);
            }
            return (int)mh$.invokeExact(hObject, pszProperty, pbInput, cbInput, dwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class BCryptCloseAlgorithmProvider {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_POINTER,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("BCryptCloseAlgorithmProvider"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * NTSTATUS BCryptCloseAlgorithmProvider(BCRYPT_ALG_HANDLE hAlgorithm, ULONG dwFlags)
     * }
     */
    public static FunctionDescriptor BCryptCloseAlgorithmProvider$descriptor() {
        return BCryptCloseAlgorithmProvider.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * NTSTATUS BCryptCloseAlgorithmProvider(BCRYPT_ALG_HANDLE hAlgorithm, ULONG dwFlags)
     * }
     */
    public static MethodHandle BCryptCloseAlgorithmProvider$handle() {
        return BCryptCloseAlgorithmProvider.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * NTSTATUS BCryptCloseAlgorithmProvider(BCRYPT_ALG_HANDLE hAlgorithm, ULONG dwFlags)
     * }
     */
    public static int BCryptCloseAlgorithmProvider(MemorySegment hAlgorithm, int dwFlags) {
        var mh$ = BCryptCloseAlgorithmProvider.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("BCryptCloseAlgorithmProvider", hAlgorithm, dwFlags);
            }
            return (int)mh$.invokeExact(hAlgorithm, dwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class BCryptFreeBuffer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("BCryptFreeBuffer"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void BCryptFreeBuffer(PVOID pvBuffer)
     * }
     */
    public static FunctionDescriptor BCryptFreeBuffer$descriptor() {
        return BCryptFreeBuffer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void BCryptFreeBuffer(PVOID pvBuffer)
     * }
     */
    public static MethodHandle BCryptFreeBuffer$handle() {
        return BCryptFreeBuffer.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * void BCryptFreeBuffer(PVOID pvBuffer)
     * }
     */
    public static void BCryptFreeBuffer(MemorySegment pvBuffer) {
        var mh$ = BCryptFreeBuffer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("BCryptFreeBuffer", pvBuffer);
            }
            mh$.invokeExact(pvBuffer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class BCryptGenerateSymmetricKey {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_LONG,
            C_POINTER,
            C_LONG,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("BCryptGenerateSymmetricKey"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * NTSTATUS BCryptGenerateSymmetricKey(BCRYPT_ALG_HANDLE hAlgorithm, BCRYPT_KEY_HANDLE *phKey, PUCHAR pbKeyObject, ULONG cbKeyObject, PUCHAR pbSecret, ULONG cbSecret, ULONG dwFlags)
     * }
     */
    public static FunctionDescriptor BCryptGenerateSymmetricKey$descriptor() {
        return BCryptGenerateSymmetricKey.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * NTSTATUS BCryptGenerateSymmetricKey(BCRYPT_ALG_HANDLE hAlgorithm, BCRYPT_KEY_HANDLE *phKey, PUCHAR pbKeyObject, ULONG cbKeyObject, PUCHAR pbSecret, ULONG cbSecret, ULONG dwFlags)
     * }
     */
    public static MethodHandle BCryptGenerateSymmetricKey$handle() {
        return BCryptGenerateSymmetricKey.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * NTSTATUS BCryptGenerateSymmetricKey(BCRYPT_ALG_HANDLE hAlgorithm, BCRYPT_KEY_HANDLE *phKey, PUCHAR pbKeyObject, ULONG cbKeyObject, PUCHAR pbSecret, ULONG cbSecret, ULONG dwFlags)
     * }
     */
    public static int BCryptGenerateSymmetricKey(MemorySegment hAlgorithm, MemorySegment phKey, MemorySegment pbKeyObject, int cbKeyObject, MemorySegment pbSecret, int cbSecret, int dwFlags) {
        var mh$ = BCryptGenerateSymmetricKey.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("BCryptGenerateSymmetricKey", hAlgorithm, phKey, pbKeyObject, cbKeyObject, pbSecret, cbSecret, dwFlags);
            }
            return (int)mh$.invokeExact(hAlgorithm, phKey, pbKeyObject, cbKeyObject, pbSecret, cbSecret, dwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class BCryptGenerateKeyPair {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_POINTER,
            C_POINTER,
            C_LONG,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("BCryptGenerateKeyPair"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * NTSTATUS BCryptGenerateKeyPair(BCRYPT_ALG_HANDLE hAlgorithm, BCRYPT_KEY_HANDLE *phKey, ULONG dwLength, ULONG dwFlags)
     * }
     */
    public static FunctionDescriptor BCryptGenerateKeyPair$descriptor() {
        return BCryptGenerateKeyPair.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * NTSTATUS BCryptGenerateKeyPair(BCRYPT_ALG_HANDLE hAlgorithm, BCRYPT_KEY_HANDLE *phKey, ULONG dwLength, ULONG dwFlags)
     * }
     */
    public static MethodHandle BCryptGenerateKeyPair$handle() {
        return BCryptGenerateKeyPair.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * NTSTATUS BCryptGenerateKeyPair(BCRYPT_ALG_HANDLE hAlgorithm, BCRYPT_KEY_HANDLE *phKey, ULONG dwLength, ULONG dwFlags)
     * }
     */
    public static int BCryptGenerateKeyPair(MemorySegment hAlgorithm, MemorySegment phKey, int dwLength, int dwFlags) {
        var mh$ = BCryptGenerateKeyPair.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("BCryptGenerateKeyPair", hAlgorithm, phKey, dwLength, dwFlags);
            }
            return (int)mh$.invokeExact(hAlgorithm, phKey, dwLength, dwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class BCryptEncrypt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_POINTER,
            C_POINTER,
            C_LONG,
            C_POINTER,
            C_POINTER,
            C_LONG,
            C_POINTER,
            C_LONG,
            C_POINTER,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("BCryptEncrypt"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * NTSTATUS BCryptEncrypt(BCRYPT_KEY_HANDLE hKey, PUCHAR pbInput, ULONG cbInput, void *pPaddingInfo, PUCHAR pbIV, ULONG cbIV, PUCHAR pbOutput, ULONG cbOutput, ULONG *pcbResult, ULONG dwFlags)
     * }
     */
    public static FunctionDescriptor BCryptEncrypt$descriptor() {
        return BCryptEncrypt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * NTSTATUS BCryptEncrypt(BCRYPT_KEY_HANDLE hKey, PUCHAR pbInput, ULONG cbInput, void *pPaddingInfo, PUCHAR pbIV, ULONG cbIV, PUCHAR pbOutput, ULONG cbOutput, ULONG *pcbResult, ULONG dwFlags)
     * }
     */
    public static MethodHandle BCryptEncrypt$handle() {
        return BCryptEncrypt.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * NTSTATUS BCryptEncrypt(BCRYPT_KEY_HANDLE hKey, PUCHAR pbInput, ULONG cbInput, void *pPaddingInfo, PUCHAR pbIV, ULONG cbIV, PUCHAR pbOutput, ULONG cbOutput, ULONG *pcbResult, ULONG dwFlags)
     * }
     */
    public static int BCryptEncrypt(MemorySegment hKey, MemorySegment pbInput, int cbInput, MemorySegment pPaddingInfo, MemorySegment pbIV, int cbIV, MemorySegment pbOutput, int cbOutput, MemorySegment pcbResult, int dwFlags) {
        var mh$ = BCryptEncrypt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("BCryptEncrypt", hKey, pbInput, cbInput, pPaddingInfo, pbIV, cbIV, pbOutput, cbOutput, pcbResult, dwFlags);
            }
            return (int)mh$.invokeExact(hKey, pbInput, cbInput, pPaddingInfo, pbIV, cbIV, pbOutput, cbOutput, pcbResult, dwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class BCryptDecrypt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_POINTER,
            C_POINTER,
            C_LONG,
            C_POINTER,
            C_POINTER,
            C_LONG,
            C_POINTER,
            C_LONG,
            C_POINTER,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("BCryptDecrypt"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * NTSTATUS BCryptDecrypt(BCRYPT_KEY_HANDLE hKey, PUCHAR pbInput, ULONG cbInput, void *pPaddingInfo, PUCHAR pbIV, ULONG cbIV, PUCHAR pbOutput, ULONG cbOutput, ULONG *pcbResult, ULONG dwFlags)
     * }
     */
    public static FunctionDescriptor BCryptDecrypt$descriptor() {
        return BCryptDecrypt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * NTSTATUS BCryptDecrypt(BCRYPT_KEY_HANDLE hKey, PUCHAR pbInput, ULONG cbInput, void *pPaddingInfo, PUCHAR pbIV, ULONG cbIV, PUCHAR pbOutput, ULONG cbOutput, ULONG *pcbResult, ULONG dwFlags)
     * }
     */
    public static MethodHandle BCryptDecrypt$handle() {
        return BCryptDecrypt.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * NTSTATUS BCryptDecrypt(BCRYPT_KEY_HANDLE hKey, PUCHAR pbInput, ULONG cbInput, void *pPaddingInfo, PUCHAR pbIV, ULONG cbIV, PUCHAR pbOutput, ULONG cbOutput, ULONG *pcbResult, ULONG dwFlags)
     * }
     */
    public static int BCryptDecrypt(MemorySegment hKey, MemorySegment pbInput, int cbInput, MemorySegment pPaddingInfo, MemorySegment pbIV, int cbIV, MemorySegment pbOutput, int cbOutput, MemorySegment pcbResult, int dwFlags) {
        var mh$ = BCryptDecrypt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("BCryptDecrypt", hKey, pbInput, cbInput, pPaddingInfo, pbIV, cbIV, pbOutput, cbOutput, pcbResult, dwFlags);
            }
            return (int)mh$.invokeExact(hKey, pbInput, cbInput, pPaddingInfo, pbIV, cbIV, pbOutput, cbOutput, pcbResult, dwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class BCryptExportKey {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_LONG,
            C_POINTER,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("BCryptExportKey"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * NTSTATUS BCryptExportKey(BCRYPT_KEY_HANDLE hKey, BCRYPT_KEY_HANDLE hExportKey, LPCWSTR pszBlobType, PUCHAR pbOutput, ULONG cbOutput, ULONG *pcbResult, ULONG dwFlags)
     * }
     */
    public static FunctionDescriptor BCryptExportKey$descriptor() {
        return BCryptExportKey.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * NTSTATUS BCryptExportKey(BCRYPT_KEY_HANDLE hKey, BCRYPT_KEY_HANDLE hExportKey, LPCWSTR pszBlobType, PUCHAR pbOutput, ULONG cbOutput, ULONG *pcbResult, ULONG dwFlags)
     * }
     */
    public static MethodHandle BCryptExportKey$handle() {
        return BCryptExportKey.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * NTSTATUS BCryptExportKey(BCRYPT_KEY_HANDLE hKey, BCRYPT_KEY_HANDLE hExportKey, LPCWSTR pszBlobType, PUCHAR pbOutput, ULONG cbOutput, ULONG *pcbResult, ULONG dwFlags)
     * }
     */
    public static int BCryptExportKey(MemorySegment hKey, MemorySegment hExportKey, MemorySegment pszBlobType, MemorySegment pbOutput, int cbOutput, MemorySegment pcbResult, int dwFlags) {
        var mh$ = BCryptExportKey.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("BCryptExportKey", hKey, hExportKey, pszBlobType, pbOutput, cbOutput, pcbResult, dwFlags);
            }
            return (int)mh$.invokeExact(hKey, hExportKey, pszBlobType, pbOutput, cbOutput, pcbResult, dwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class BCryptImportKey {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_LONG,
            C_POINTER,
            C_LONG,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("BCryptImportKey"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * NTSTATUS BCryptImportKey(BCRYPT_ALG_HANDLE hAlgorithm, BCRYPT_KEY_HANDLE hImportKey, LPCWSTR pszBlobType, BCRYPT_KEY_HANDLE *phKey, PUCHAR pbKeyObject, ULONG cbKeyObject, PUCHAR pbInput, ULONG cbInput, ULONG dwFlags)
     * }
     */
    public static FunctionDescriptor BCryptImportKey$descriptor() {
        return BCryptImportKey.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * NTSTATUS BCryptImportKey(BCRYPT_ALG_HANDLE hAlgorithm, BCRYPT_KEY_HANDLE hImportKey, LPCWSTR pszBlobType, BCRYPT_KEY_HANDLE *phKey, PUCHAR pbKeyObject, ULONG cbKeyObject, PUCHAR pbInput, ULONG cbInput, ULONG dwFlags)
     * }
     */
    public static MethodHandle BCryptImportKey$handle() {
        return BCryptImportKey.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * NTSTATUS BCryptImportKey(BCRYPT_ALG_HANDLE hAlgorithm, BCRYPT_KEY_HANDLE hImportKey, LPCWSTR pszBlobType, BCRYPT_KEY_HANDLE *phKey, PUCHAR pbKeyObject, ULONG cbKeyObject, PUCHAR pbInput, ULONG cbInput, ULONG dwFlags)
     * }
     */
    public static int BCryptImportKey(MemorySegment hAlgorithm, MemorySegment hImportKey, MemorySegment pszBlobType, MemorySegment phKey, MemorySegment pbKeyObject, int cbKeyObject, MemorySegment pbInput, int cbInput, int dwFlags) {
        var mh$ = BCryptImportKey.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("BCryptImportKey", hAlgorithm, hImportKey, pszBlobType, phKey, pbKeyObject, cbKeyObject, pbInput, cbInput, dwFlags);
            }
            return (int)mh$.invokeExact(hAlgorithm, hImportKey, pszBlobType, phKey, pbKeyObject, cbKeyObject, pbInput, cbInput, dwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class BCryptImportKeyPair {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_LONG,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("BCryptImportKeyPair"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * NTSTATUS BCryptImportKeyPair(BCRYPT_ALG_HANDLE hAlgorithm, BCRYPT_KEY_HANDLE hImportKey, LPCWSTR pszBlobType, BCRYPT_KEY_HANDLE *phKey, PUCHAR pbInput, ULONG cbInput, ULONG dwFlags)
     * }
     */
    public static FunctionDescriptor BCryptImportKeyPair$descriptor() {
        return BCryptImportKeyPair.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * NTSTATUS BCryptImportKeyPair(BCRYPT_ALG_HANDLE hAlgorithm, BCRYPT_KEY_HANDLE hImportKey, LPCWSTR pszBlobType, BCRYPT_KEY_HANDLE *phKey, PUCHAR pbInput, ULONG cbInput, ULONG dwFlags)
     * }
     */
    public static MethodHandle BCryptImportKeyPair$handle() {
        return BCryptImportKeyPair.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * NTSTATUS BCryptImportKeyPair(BCRYPT_ALG_HANDLE hAlgorithm, BCRYPT_KEY_HANDLE hImportKey, LPCWSTR pszBlobType, BCRYPT_KEY_HANDLE *phKey, PUCHAR pbInput, ULONG cbInput, ULONG dwFlags)
     * }
     */
    public static int BCryptImportKeyPair(MemorySegment hAlgorithm, MemorySegment hImportKey, MemorySegment pszBlobType, MemorySegment phKey, MemorySegment pbInput, int cbInput, int dwFlags) {
        var mh$ = BCryptImportKeyPair.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("BCryptImportKeyPair", hAlgorithm, hImportKey, pszBlobType, phKey, pbInput, cbInput, dwFlags);
            }
            return (int)mh$.invokeExact(hAlgorithm, hImportKey, pszBlobType, phKey, pbInput, cbInput, dwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class BCryptDuplicateKey {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_LONG,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("BCryptDuplicateKey"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * NTSTATUS BCryptDuplicateKey(BCRYPT_KEY_HANDLE hKey, BCRYPT_KEY_HANDLE *phNewKey, PUCHAR pbKeyObject, ULONG cbKeyObject, ULONG dwFlags)
     * }
     */
    public static FunctionDescriptor BCryptDuplicateKey$descriptor() {
        return BCryptDuplicateKey.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * NTSTATUS BCryptDuplicateKey(BCRYPT_KEY_HANDLE hKey, BCRYPT_KEY_HANDLE *phNewKey, PUCHAR pbKeyObject, ULONG cbKeyObject, ULONG dwFlags)
     * }
     */
    public static MethodHandle BCryptDuplicateKey$handle() {
        return BCryptDuplicateKey.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * NTSTATUS BCryptDuplicateKey(BCRYPT_KEY_HANDLE hKey, BCRYPT_KEY_HANDLE *phNewKey, PUCHAR pbKeyObject, ULONG cbKeyObject, ULONG dwFlags)
     * }
     */
    public static int BCryptDuplicateKey(MemorySegment hKey, MemorySegment phNewKey, MemorySegment pbKeyObject, int cbKeyObject, int dwFlags) {
        var mh$ = BCryptDuplicateKey.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("BCryptDuplicateKey", hKey, phNewKey, pbKeyObject, cbKeyObject, dwFlags);
            }
            return (int)mh$.invokeExact(hKey, phNewKey, pbKeyObject, cbKeyObject, dwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class BCryptFinalizeKeyPair {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_POINTER,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("BCryptFinalizeKeyPair"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * NTSTATUS BCryptFinalizeKeyPair(BCRYPT_KEY_HANDLE hKey, ULONG dwFlags)
     * }
     */
    public static FunctionDescriptor BCryptFinalizeKeyPair$descriptor() {
        return BCryptFinalizeKeyPair.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * NTSTATUS BCryptFinalizeKeyPair(BCRYPT_KEY_HANDLE hKey, ULONG dwFlags)
     * }
     */
    public static MethodHandle BCryptFinalizeKeyPair$handle() {
        return BCryptFinalizeKeyPair.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * NTSTATUS BCryptFinalizeKeyPair(BCRYPT_KEY_HANDLE hKey, ULONG dwFlags)
     * }
     */
    public static int BCryptFinalizeKeyPair(MemorySegment hKey, int dwFlags) {
        var mh$ = BCryptFinalizeKeyPair.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("BCryptFinalizeKeyPair", hKey, dwFlags);
            }
            return (int)mh$.invokeExact(hKey, dwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class BCryptDestroyKey {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("BCryptDestroyKey"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * NTSTATUS BCryptDestroyKey(BCRYPT_KEY_HANDLE hKey)
     * }
     */
    public static FunctionDescriptor BCryptDestroyKey$descriptor() {
        return BCryptDestroyKey.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * NTSTATUS BCryptDestroyKey(BCRYPT_KEY_HANDLE hKey)
     * }
     */
    public static MethodHandle BCryptDestroyKey$handle() {
        return BCryptDestroyKey.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * NTSTATUS BCryptDestroyKey(BCRYPT_KEY_HANDLE hKey)
     * }
     */
    public static int BCryptDestroyKey(MemorySegment hKey) {
        var mh$ = BCryptDestroyKey.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("BCryptDestroyKey", hKey);
            }
            return (int)mh$.invokeExact(hKey);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class BCryptDestroySecret {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("BCryptDestroySecret"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * NTSTATUS BCryptDestroySecret(BCRYPT_SECRET_HANDLE hSecret)
     * }
     */
    public static FunctionDescriptor BCryptDestroySecret$descriptor() {
        return BCryptDestroySecret.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * NTSTATUS BCryptDestroySecret(BCRYPT_SECRET_HANDLE hSecret)
     * }
     */
    public static MethodHandle BCryptDestroySecret$handle() {
        return BCryptDestroySecret.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * NTSTATUS BCryptDestroySecret(BCRYPT_SECRET_HANDLE hSecret)
     * }
     */
    public static int BCryptDestroySecret(MemorySegment hSecret) {
        var mh$ = BCryptDestroySecret.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("BCryptDestroySecret", hSecret);
            }
            return (int)mh$.invokeExact(hSecret);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class BCryptSignHash {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_LONG,
            C_POINTER,
            C_LONG,
            C_POINTER,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("BCryptSignHash"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * NTSTATUS BCryptSignHash(BCRYPT_KEY_HANDLE hKey, void *pPaddingInfo, PUCHAR pbInput, ULONG cbInput, PUCHAR pbOutput, ULONG cbOutput, ULONG *pcbResult, ULONG dwFlags)
     * }
     */
    public static FunctionDescriptor BCryptSignHash$descriptor() {
        return BCryptSignHash.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * NTSTATUS BCryptSignHash(BCRYPT_KEY_HANDLE hKey, void *pPaddingInfo, PUCHAR pbInput, ULONG cbInput, PUCHAR pbOutput, ULONG cbOutput, ULONG *pcbResult, ULONG dwFlags)
     * }
     */
    public static MethodHandle BCryptSignHash$handle() {
        return BCryptSignHash.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * NTSTATUS BCryptSignHash(BCRYPT_KEY_HANDLE hKey, void *pPaddingInfo, PUCHAR pbInput, ULONG cbInput, PUCHAR pbOutput, ULONG cbOutput, ULONG *pcbResult, ULONG dwFlags)
     * }
     */
    public static int BCryptSignHash(MemorySegment hKey, MemorySegment pPaddingInfo, MemorySegment pbInput, int cbInput, MemorySegment pbOutput, int cbOutput, MemorySegment pcbResult, int dwFlags) {
        var mh$ = BCryptSignHash.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("BCryptSignHash", hKey, pPaddingInfo, pbInput, cbInput, pbOutput, cbOutput, pcbResult, dwFlags);
            }
            return (int)mh$.invokeExact(hKey, pPaddingInfo, pbInput, cbInput, pbOutput, cbOutput, pcbResult, dwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class BCryptVerifySignature {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_LONG,
            C_POINTER,
            C_LONG,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("BCryptVerifySignature"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * NTSTATUS BCryptVerifySignature(BCRYPT_KEY_HANDLE hKey, void *pPaddingInfo, PUCHAR pbHash, ULONG cbHash, PUCHAR pbSignature, ULONG cbSignature, ULONG dwFlags)
     * }
     */
    public static FunctionDescriptor BCryptVerifySignature$descriptor() {
        return BCryptVerifySignature.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * NTSTATUS BCryptVerifySignature(BCRYPT_KEY_HANDLE hKey, void *pPaddingInfo, PUCHAR pbHash, ULONG cbHash, PUCHAR pbSignature, ULONG cbSignature, ULONG dwFlags)
     * }
     */
    public static MethodHandle BCryptVerifySignature$handle() {
        return BCryptVerifySignature.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * NTSTATUS BCryptVerifySignature(BCRYPT_KEY_HANDLE hKey, void *pPaddingInfo, PUCHAR pbHash, ULONG cbHash, PUCHAR pbSignature, ULONG cbSignature, ULONG dwFlags)
     * }
     */
    public static int BCryptVerifySignature(MemorySegment hKey, MemorySegment pPaddingInfo, MemorySegment pbHash, int cbHash, MemorySegment pbSignature, int cbSignature, int dwFlags) {
        var mh$ = BCryptVerifySignature.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("BCryptVerifySignature", hKey, pPaddingInfo, pbHash, cbHash, pbSignature, cbSignature, dwFlags);
            }
            return (int)mh$.invokeExact(hKey, pPaddingInfo, pbHash, cbHash, pbSignature, cbSignature, dwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class BCryptSecretAgreement {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("BCryptSecretAgreement"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * NTSTATUS BCryptSecretAgreement(BCRYPT_KEY_HANDLE hPrivKey, BCRYPT_KEY_HANDLE hPubKey, BCRYPT_SECRET_HANDLE *phAgreedSecret, ULONG dwFlags)
     * }
     */
    public static FunctionDescriptor BCryptSecretAgreement$descriptor() {
        return BCryptSecretAgreement.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * NTSTATUS BCryptSecretAgreement(BCRYPT_KEY_HANDLE hPrivKey, BCRYPT_KEY_HANDLE hPubKey, BCRYPT_SECRET_HANDLE *phAgreedSecret, ULONG dwFlags)
     * }
     */
    public static MethodHandle BCryptSecretAgreement$handle() {
        return BCryptSecretAgreement.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * NTSTATUS BCryptSecretAgreement(BCRYPT_KEY_HANDLE hPrivKey, BCRYPT_KEY_HANDLE hPubKey, BCRYPT_SECRET_HANDLE *phAgreedSecret, ULONG dwFlags)
     * }
     */
    public static int BCryptSecretAgreement(MemorySegment hPrivKey, MemorySegment hPubKey, MemorySegment phAgreedSecret, int dwFlags) {
        var mh$ = BCryptSecretAgreement.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("BCryptSecretAgreement", hPrivKey, hPubKey, phAgreedSecret, dwFlags);
            }
            return (int)mh$.invokeExact(hPrivKey, hPubKey, phAgreedSecret, dwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class BCryptDeriveKey {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_LONG,
            C_POINTER,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("BCryptDeriveKey"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * NTSTATUS BCryptDeriveKey(BCRYPT_SECRET_HANDLE hSharedSecret, LPCWSTR pwszKDF, BCryptBufferDesc *pParameterList, PUCHAR pbDerivedKey, ULONG cbDerivedKey, ULONG *pcbResult, ULONG dwFlags)
     * }
     */
    public static FunctionDescriptor BCryptDeriveKey$descriptor() {
        return BCryptDeriveKey.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * NTSTATUS BCryptDeriveKey(BCRYPT_SECRET_HANDLE hSharedSecret, LPCWSTR pwszKDF, BCryptBufferDesc *pParameterList, PUCHAR pbDerivedKey, ULONG cbDerivedKey, ULONG *pcbResult, ULONG dwFlags)
     * }
     */
    public static MethodHandle BCryptDeriveKey$handle() {
        return BCryptDeriveKey.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * NTSTATUS BCryptDeriveKey(BCRYPT_SECRET_HANDLE hSharedSecret, LPCWSTR pwszKDF, BCryptBufferDesc *pParameterList, PUCHAR pbDerivedKey, ULONG cbDerivedKey, ULONG *pcbResult, ULONG dwFlags)
     * }
     */
    public static int BCryptDeriveKey(MemorySegment hSharedSecret, MemorySegment pwszKDF, MemorySegment pParameterList, MemorySegment pbDerivedKey, int cbDerivedKey, MemorySegment pcbResult, int dwFlags) {
        var mh$ = BCryptDeriveKey.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("BCryptDeriveKey", hSharedSecret, pwszKDF, pParameterList, pbDerivedKey, cbDerivedKey, pcbResult, dwFlags);
            }
            return (int)mh$.invokeExact(hSharedSecret, pwszKDF, pParameterList, pbDerivedKey, cbDerivedKey, pcbResult, dwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class BCryptKeyDerivation {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_LONG,
            C_POINTER,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("BCryptKeyDerivation"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * NTSTATUS BCryptKeyDerivation(BCRYPT_KEY_HANDLE hKey, BCryptBufferDesc *pParameterList, PUCHAR pbDerivedKey, ULONG cbDerivedKey, ULONG *pcbResult, ULONG dwFlags)
     * }
     */
    public static FunctionDescriptor BCryptKeyDerivation$descriptor() {
        return BCryptKeyDerivation.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * NTSTATUS BCryptKeyDerivation(BCRYPT_KEY_HANDLE hKey, BCryptBufferDesc *pParameterList, PUCHAR pbDerivedKey, ULONG cbDerivedKey, ULONG *pcbResult, ULONG dwFlags)
     * }
     */
    public static MethodHandle BCryptKeyDerivation$handle() {
        return BCryptKeyDerivation.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * NTSTATUS BCryptKeyDerivation(BCRYPT_KEY_HANDLE hKey, BCryptBufferDesc *pParameterList, PUCHAR pbDerivedKey, ULONG cbDerivedKey, ULONG *pcbResult, ULONG dwFlags)
     * }
     */
    public static int BCryptKeyDerivation(MemorySegment hKey, MemorySegment pParameterList, MemorySegment pbDerivedKey, int cbDerivedKey, MemorySegment pcbResult, int dwFlags) {
        var mh$ = BCryptKeyDerivation.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("BCryptKeyDerivation", hKey, pParameterList, pbDerivedKey, cbDerivedKey, pcbResult, dwFlags);
            }
            return (int)mh$.invokeExact(hKey, pParameterList, pbDerivedKey, cbDerivedKey, pcbResult, dwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class BCryptCreateHash {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_LONG,
            C_POINTER,
            C_LONG,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("BCryptCreateHash"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * NTSTATUS BCryptCreateHash(BCRYPT_ALG_HANDLE hAlgorithm, BCRYPT_HASH_HANDLE *phHash, PUCHAR pbHashObject, ULONG cbHashObject, PUCHAR pbSecret, ULONG cbSecret, ULONG dwFlags)
     * }
     */
    public static FunctionDescriptor BCryptCreateHash$descriptor() {
        return BCryptCreateHash.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * NTSTATUS BCryptCreateHash(BCRYPT_ALG_HANDLE hAlgorithm, BCRYPT_HASH_HANDLE *phHash, PUCHAR pbHashObject, ULONG cbHashObject, PUCHAR pbSecret, ULONG cbSecret, ULONG dwFlags)
     * }
     */
    public static MethodHandle BCryptCreateHash$handle() {
        return BCryptCreateHash.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * NTSTATUS BCryptCreateHash(BCRYPT_ALG_HANDLE hAlgorithm, BCRYPT_HASH_HANDLE *phHash, PUCHAR pbHashObject, ULONG cbHashObject, PUCHAR pbSecret, ULONG cbSecret, ULONG dwFlags)
     * }
     */
    public static int BCryptCreateHash(MemorySegment hAlgorithm, MemorySegment phHash, MemorySegment pbHashObject, int cbHashObject, MemorySegment pbSecret, int cbSecret, int dwFlags) {
        var mh$ = BCryptCreateHash.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("BCryptCreateHash", hAlgorithm, phHash, pbHashObject, cbHashObject, pbSecret, cbSecret, dwFlags);
            }
            return (int)mh$.invokeExact(hAlgorithm, phHash, pbHashObject, cbHashObject, pbSecret, cbSecret, dwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class BCryptHashData {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_POINTER,
            C_POINTER,
            C_LONG,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("BCryptHashData"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * NTSTATUS BCryptHashData(BCRYPT_HASH_HANDLE hHash, PUCHAR pbInput, ULONG cbInput, ULONG dwFlags)
     * }
     */
    public static FunctionDescriptor BCryptHashData$descriptor() {
        return BCryptHashData.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * NTSTATUS BCryptHashData(BCRYPT_HASH_HANDLE hHash, PUCHAR pbInput, ULONG cbInput, ULONG dwFlags)
     * }
     */
    public static MethodHandle BCryptHashData$handle() {
        return BCryptHashData.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * NTSTATUS BCryptHashData(BCRYPT_HASH_HANDLE hHash, PUCHAR pbInput, ULONG cbInput, ULONG dwFlags)
     * }
     */
    public static int BCryptHashData(MemorySegment hHash, MemorySegment pbInput, int cbInput, int dwFlags) {
        var mh$ = BCryptHashData.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("BCryptHashData", hHash, pbInput, cbInput, dwFlags);
            }
            return (int)mh$.invokeExact(hHash, pbInput, cbInput, dwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class BCryptFinishHash {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_POINTER,
            C_POINTER,
            C_LONG,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("BCryptFinishHash"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * NTSTATUS BCryptFinishHash(BCRYPT_HASH_HANDLE hHash, PUCHAR pbOutput, ULONG cbOutput, ULONG dwFlags)
     * }
     */
    public static FunctionDescriptor BCryptFinishHash$descriptor() {
        return BCryptFinishHash.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * NTSTATUS BCryptFinishHash(BCRYPT_HASH_HANDLE hHash, PUCHAR pbOutput, ULONG cbOutput, ULONG dwFlags)
     * }
     */
    public static MethodHandle BCryptFinishHash$handle() {
        return BCryptFinishHash.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * NTSTATUS BCryptFinishHash(BCRYPT_HASH_HANDLE hHash, PUCHAR pbOutput, ULONG cbOutput, ULONG dwFlags)
     * }
     */
    public static int BCryptFinishHash(MemorySegment hHash, MemorySegment pbOutput, int cbOutput, int dwFlags) {
        var mh$ = BCryptFinishHash.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("BCryptFinishHash", hHash, pbOutput, cbOutput, dwFlags);
            }
            return (int)mh$.invokeExact(hHash, pbOutput, cbOutput, dwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class BCryptCreateMultiHash {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_POINTER,
            C_POINTER,
            C_LONG,
            C_POINTER,
            C_LONG,
            C_POINTER,
            C_LONG,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("BCryptCreateMultiHash"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * NTSTATUS BCryptCreateMultiHash(BCRYPT_ALG_HANDLE hAlgorithm, BCRYPT_HASH_HANDLE *phHash, ULONG nHashes, PUCHAR pbHashObject, ULONG cbHashObject, PUCHAR pbSecret, ULONG cbSecret, ULONG dwFlags)
     * }
     */
    public static FunctionDescriptor BCryptCreateMultiHash$descriptor() {
        return BCryptCreateMultiHash.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * NTSTATUS BCryptCreateMultiHash(BCRYPT_ALG_HANDLE hAlgorithm, BCRYPT_HASH_HANDLE *phHash, ULONG nHashes, PUCHAR pbHashObject, ULONG cbHashObject, PUCHAR pbSecret, ULONG cbSecret, ULONG dwFlags)
     * }
     */
    public static MethodHandle BCryptCreateMultiHash$handle() {
        return BCryptCreateMultiHash.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * NTSTATUS BCryptCreateMultiHash(BCRYPT_ALG_HANDLE hAlgorithm, BCRYPT_HASH_HANDLE *phHash, ULONG nHashes, PUCHAR pbHashObject, ULONG cbHashObject, PUCHAR pbSecret, ULONG cbSecret, ULONG dwFlags)
     * }
     */
    public static int BCryptCreateMultiHash(MemorySegment hAlgorithm, MemorySegment phHash, int nHashes, MemorySegment pbHashObject, int cbHashObject, MemorySegment pbSecret, int cbSecret, int dwFlags) {
        var mh$ = BCryptCreateMultiHash.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("BCryptCreateMultiHash", hAlgorithm, phHash, nHashes, pbHashObject, cbHashObject, pbSecret, cbSecret, dwFlags);
            }
            return (int)mh$.invokeExact(hAlgorithm, phHash, nHashes, pbHashObject, cbHashObject, pbSecret, cbSecret, dwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class BCryptProcessMultiOperations {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_POINTER,
            C_INT,
            C_POINTER,
            C_LONG,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("BCryptProcessMultiOperations"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * NTSTATUS BCryptProcessMultiOperations(BCRYPT_HANDLE hObject, BCRYPT_MULTI_OPERATION_TYPE operationType, PVOID pOperations, ULONG cbOperations, ULONG dwFlags)
     * }
     */
    public static FunctionDescriptor BCryptProcessMultiOperations$descriptor() {
        return BCryptProcessMultiOperations.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * NTSTATUS BCryptProcessMultiOperations(BCRYPT_HANDLE hObject, BCRYPT_MULTI_OPERATION_TYPE operationType, PVOID pOperations, ULONG cbOperations, ULONG dwFlags)
     * }
     */
    public static MethodHandle BCryptProcessMultiOperations$handle() {
        return BCryptProcessMultiOperations.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * NTSTATUS BCryptProcessMultiOperations(BCRYPT_HANDLE hObject, BCRYPT_MULTI_OPERATION_TYPE operationType, PVOID pOperations, ULONG cbOperations, ULONG dwFlags)
     * }
     */
    public static int BCryptProcessMultiOperations(MemorySegment hObject, int operationType, MemorySegment pOperations, int cbOperations, int dwFlags) {
        var mh$ = BCryptProcessMultiOperations.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("BCryptProcessMultiOperations", hObject, operationType, pOperations, cbOperations, dwFlags);
            }
            return (int)mh$.invokeExact(hObject, operationType, pOperations, cbOperations, dwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class BCryptDuplicateHash {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_LONG,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("BCryptDuplicateHash"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * NTSTATUS BCryptDuplicateHash(BCRYPT_HASH_HANDLE hHash, BCRYPT_HASH_HANDLE *phNewHash, PUCHAR pbHashObject, ULONG cbHashObject, ULONG dwFlags)
     * }
     */
    public static FunctionDescriptor BCryptDuplicateHash$descriptor() {
        return BCryptDuplicateHash.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * NTSTATUS BCryptDuplicateHash(BCRYPT_HASH_HANDLE hHash, BCRYPT_HASH_HANDLE *phNewHash, PUCHAR pbHashObject, ULONG cbHashObject, ULONG dwFlags)
     * }
     */
    public static MethodHandle BCryptDuplicateHash$handle() {
        return BCryptDuplicateHash.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * NTSTATUS BCryptDuplicateHash(BCRYPT_HASH_HANDLE hHash, BCRYPT_HASH_HANDLE *phNewHash, PUCHAR pbHashObject, ULONG cbHashObject, ULONG dwFlags)
     * }
     */
    public static int BCryptDuplicateHash(MemorySegment hHash, MemorySegment phNewHash, MemorySegment pbHashObject, int cbHashObject, int dwFlags) {
        var mh$ = BCryptDuplicateHash.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("BCryptDuplicateHash", hHash, phNewHash, pbHashObject, cbHashObject, dwFlags);
            }
            return (int)mh$.invokeExact(hHash, phNewHash, pbHashObject, cbHashObject, dwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class BCryptDestroyHash {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("BCryptDestroyHash"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * NTSTATUS BCryptDestroyHash(BCRYPT_HASH_HANDLE hHash)
     * }
     */
    public static FunctionDescriptor BCryptDestroyHash$descriptor() {
        return BCryptDestroyHash.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * NTSTATUS BCryptDestroyHash(BCRYPT_HASH_HANDLE hHash)
     * }
     */
    public static MethodHandle BCryptDestroyHash$handle() {
        return BCryptDestroyHash.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * NTSTATUS BCryptDestroyHash(BCRYPT_HASH_HANDLE hHash)
     * }
     */
    public static int BCryptDestroyHash(MemorySegment hHash) {
        var mh$ = BCryptDestroyHash.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("BCryptDestroyHash", hHash);
            }
            return (int)mh$.invokeExact(hHash);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class BCryptHash {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_POINTER,
            C_POINTER,
            C_LONG,
            C_POINTER,
            C_LONG,
            C_POINTER,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("BCryptHash"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * NTSTATUS BCryptHash(BCRYPT_ALG_HANDLE hAlgorithm, PUCHAR pbSecret, ULONG cbSecret, PUCHAR pbInput, ULONG cbInput, PUCHAR pbOutput, ULONG cbOutput)
     * }
     */
    public static FunctionDescriptor BCryptHash$descriptor() {
        return BCryptHash.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * NTSTATUS BCryptHash(BCRYPT_ALG_HANDLE hAlgorithm, PUCHAR pbSecret, ULONG cbSecret, PUCHAR pbInput, ULONG cbInput, PUCHAR pbOutput, ULONG cbOutput)
     * }
     */
    public static MethodHandle BCryptHash$handle() {
        return BCryptHash.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * NTSTATUS BCryptHash(BCRYPT_ALG_HANDLE hAlgorithm, PUCHAR pbSecret, ULONG cbSecret, PUCHAR pbInput, ULONG cbInput, PUCHAR pbOutput, ULONG cbOutput)
     * }
     */
    public static int BCryptHash(MemorySegment hAlgorithm, MemorySegment pbSecret, int cbSecret, MemorySegment pbInput, int cbInput, MemorySegment pbOutput, int cbOutput) {
        var mh$ = BCryptHash.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("BCryptHash", hAlgorithm, pbSecret, cbSecret, pbInput, cbInput, pbOutput, cbOutput);
            }
            return (int)mh$.invokeExact(hAlgorithm, pbSecret, cbSecret, pbInput, cbInput, pbOutput, cbOutput);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class BCryptGenRandom {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_POINTER,
            C_POINTER,
            C_LONG,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("BCryptGenRandom"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * NTSTATUS BCryptGenRandom(BCRYPT_ALG_HANDLE hAlgorithm, PUCHAR pbBuffer, ULONG cbBuffer, ULONG dwFlags)
     * }
     */
    public static FunctionDescriptor BCryptGenRandom$descriptor() {
        return BCryptGenRandom.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * NTSTATUS BCryptGenRandom(BCRYPT_ALG_HANDLE hAlgorithm, PUCHAR pbBuffer, ULONG cbBuffer, ULONG dwFlags)
     * }
     */
    public static MethodHandle BCryptGenRandom$handle() {
        return BCryptGenRandom.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * NTSTATUS BCryptGenRandom(BCRYPT_ALG_HANDLE hAlgorithm, PUCHAR pbBuffer, ULONG cbBuffer, ULONG dwFlags)
     * }
     */
    public static int BCryptGenRandom(MemorySegment hAlgorithm, MemorySegment pbBuffer, int cbBuffer, int dwFlags) {
        var mh$ = BCryptGenRandom.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("BCryptGenRandom", hAlgorithm, pbBuffer, cbBuffer, dwFlags);
            }
            return (int)mh$.invokeExact(hAlgorithm, pbBuffer, cbBuffer, dwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class BCryptDeriveKeyCapi {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_LONG,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("BCryptDeriveKeyCapi"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * NTSTATUS BCryptDeriveKeyCapi(BCRYPT_HASH_HANDLE hHash, BCRYPT_ALG_HANDLE hTargetAlg, PUCHAR pbDerivedKey, ULONG cbDerivedKey, ULONG dwFlags)
     * }
     */
    public static FunctionDescriptor BCryptDeriveKeyCapi$descriptor() {
        return BCryptDeriveKeyCapi.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * NTSTATUS BCryptDeriveKeyCapi(BCRYPT_HASH_HANDLE hHash, BCRYPT_ALG_HANDLE hTargetAlg, PUCHAR pbDerivedKey, ULONG cbDerivedKey, ULONG dwFlags)
     * }
     */
    public static MethodHandle BCryptDeriveKeyCapi$handle() {
        return BCryptDeriveKeyCapi.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * NTSTATUS BCryptDeriveKeyCapi(BCRYPT_HASH_HANDLE hHash, BCRYPT_ALG_HANDLE hTargetAlg, PUCHAR pbDerivedKey, ULONG cbDerivedKey, ULONG dwFlags)
     * }
     */
    public static int BCryptDeriveKeyCapi(MemorySegment hHash, MemorySegment hTargetAlg, MemorySegment pbDerivedKey, int cbDerivedKey, int dwFlags) {
        var mh$ = BCryptDeriveKeyCapi.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("BCryptDeriveKeyCapi", hHash, hTargetAlg, pbDerivedKey, cbDerivedKey, dwFlags);
            }
            return (int)mh$.invokeExact(hHash, hTargetAlg, pbDerivedKey, cbDerivedKey, dwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class BCryptDeriveKeyPBKDF2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_POINTER,
            C_POINTER,
            C_LONG,
            C_POINTER,
            C_LONG,
            C_LONG_LONG,
            C_POINTER,
            C_LONG,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("BCryptDeriveKeyPBKDF2"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * NTSTATUS BCryptDeriveKeyPBKDF2(BCRYPT_ALG_HANDLE hPrf, PUCHAR pbPassword, ULONG cbPassword, PUCHAR pbSalt, ULONG cbSalt, ULONGLONG cIterations, PUCHAR pbDerivedKey, ULONG cbDerivedKey, ULONG dwFlags)
     * }
     */
    public static FunctionDescriptor BCryptDeriveKeyPBKDF2$descriptor() {
        return BCryptDeriveKeyPBKDF2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * NTSTATUS BCryptDeriveKeyPBKDF2(BCRYPT_ALG_HANDLE hPrf, PUCHAR pbPassword, ULONG cbPassword, PUCHAR pbSalt, ULONG cbSalt, ULONGLONG cIterations, PUCHAR pbDerivedKey, ULONG cbDerivedKey, ULONG dwFlags)
     * }
     */
    public static MethodHandle BCryptDeriveKeyPBKDF2$handle() {
        return BCryptDeriveKeyPBKDF2.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * NTSTATUS BCryptDeriveKeyPBKDF2(BCRYPT_ALG_HANDLE hPrf, PUCHAR pbPassword, ULONG cbPassword, PUCHAR pbSalt, ULONG cbSalt, ULONGLONG cIterations, PUCHAR pbDerivedKey, ULONG cbDerivedKey, ULONG dwFlags)
     * }
     */
    public static int BCryptDeriveKeyPBKDF2(MemorySegment hPrf, MemorySegment pbPassword, int cbPassword, MemorySegment pbSalt, int cbSalt, long cIterations, MemorySegment pbDerivedKey, int cbDerivedKey, int dwFlags) {
        var mh$ = BCryptDeriveKeyPBKDF2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("BCryptDeriveKeyPBKDF2", hPrf, pbPassword, cbPassword, pbSalt, cbSalt, cIterations, pbDerivedKey, cbDerivedKey, dwFlags);
            }
            return (int)mh$.invokeExact(hPrf, pbPassword, cbPassword, pbSalt, cbSalt, cIterations, pbDerivedKey, cbDerivedKey, dwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct _BCRYPT_INTERFACE_VERSION {
     *     USHORT MajorVersion;
     *     USHORT MinorVersion;
     * } *PBCRYPT_INTERFACE_VERSION
     * }
     */
    public static final AddressLayout PBCRYPT_INTERFACE_VERSION = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CRYPT_INTERFACE_REG {
     *     ULONG dwInterface;
     *     ULONG dwFlags;
     *     ULONG cFunctions;
     *     PWSTR *rgpszFunctions;
     * } *PCRYPT_INTERFACE_REG
     * }
     */
    public static final AddressLayout PCRYPT_INTERFACE_REG = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CRYPT_IMAGE_REG {
     *     PWSTR pszImage;
     *     ULONG cInterfaces;
     *     PCRYPT_INTERFACE_REG *rgpInterfaces;
     * } *PCRYPT_IMAGE_REG
     * }
     */
    public static final AddressLayout PCRYPT_IMAGE_REG = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CRYPT_PROVIDER_REG {
     *     ULONG cAliases;
     *     PWSTR *rgpszAliases;
     *     PCRYPT_IMAGE_REG pUM;
     *     PCRYPT_IMAGE_REG pKM;
     * } *PCRYPT_PROVIDER_REG
     * }
     */
    public static final AddressLayout PCRYPT_PROVIDER_REG = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CRYPT_PROVIDERS {
     *     ULONG cProviders;
     *     PWSTR *rgpszProviders;
     * } *PCRYPT_PROVIDERS
     * }
     */
    public static final AddressLayout PCRYPT_PROVIDERS = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CRYPT_CONTEXT_CONFIG {
     *     ULONG dwFlags;
     *     ULONG dwReserved;
     * } *PCRYPT_CONTEXT_CONFIG
     * }
     */
    public static final AddressLayout PCRYPT_CONTEXT_CONFIG = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CRYPT_CONTEXT_FUNCTION_CONFIG {
     *     ULONG dwFlags;
     *     ULONG dwReserved;
     * } *PCRYPT_CONTEXT_FUNCTION_CONFIG
     * }
     */
    public static final AddressLayout PCRYPT_CONTEXT_FUNCTION_CONFIG = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CRYPT_CONTEXTS {
     *     ULONG cContexts;
     *     PWSTR *rgpszContexts;
     * } *PCRYPT_CONTEXTS
     * }
     */
    public static final AddressLayout PCRYPT_CONTEXTS = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CRYPT_CONTEXT_FUNCTIONS {
     *     ULONG cFunctions;
     *     PWSTR *rgpszFunctions;
     * } *PCRYPT_CONTEXT_FUNCTIONS
     * }
     */
    public static final AddressLayout PCRYPT_CONTEXT_FUNCTIONS = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CRYPT_CONTEXT_FUNCTION_PROVIDERS {
     *     ULONG cProviders;
     *     PWSTR *rgpszProviders;
     * } *PCRYPT_CONTEXT_FUNCTION_PROVIDERS
     * }
     */
    public static final AddressLayout PCRYPT_CONTEXT_FUNCTION_PROVIDERS = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CRYPT_PROPERTY_REF {
     *     PWSTR pszProperty;
     *     ULONG cbValue;
     *     PUCHAR pbValue;
     * } *PCRYPT_PROPERTY_REF
     * }
     */
    public static final AddressLayout PCRYPT_PROPERTY_REF = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CRYPT_IMAGE_REF {
     *     PWSTR pszImage;
     *     ULONG dwFlags;
     * } *PCRYPT_IMAGE_REF
     * }
     */
    public static final AddressLayout PCRYPT_IMAGE_REF = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CRYPT_PROVIDER_REF {
     *     ULONG dwInterface;
     *     PWSTR pszFunction;
     *     PWSTR pszProvider;
     *     ULONG cProperties;
     *     PCRYPT_PROPERTY_REF *rgpProperties;
     *     PCRYPT_IMAGE_REF pUM;
     *     PCRYPT_IMAGE_REF pKM;
     * } *PCRYPT_PROVIDER_REF
     * }
     */
    public static final AddressLayout PCRYPT_PROVIDER_REF = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CRYPT_PROVIDER_REFS {
     *     ULONG cProviders;
     *     PCRYPT_PROVIDER_REF *rgpProviders;
     * } *PCRYPT_PROVIDER_REFS
     * }
     */
    public static final AddressLayout PCRYPT_PROVIDER_REFS = C_POINTER;

    private static class BCryptQueryProviderRegistration {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_POINTER,
            C_LONG,
            C_LONG,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("BCryptQueryProviderRegistration"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * NTSTATUS BCryptQueryProviderRegistration(LPCWSTR pszProvider, ULONG dwMode, ULONG dwInterface, ULONG *pcbBuffer, PCRYPT_PROVIDER_REG *ppBuffer)
     * }
     */
    public static FunctionDescriptor BCryptQueryProviderRegistration$descriptor() {
        return BCryptQueryProviderRegistration.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * NTSTATUS BCryptQueryProviderRegistration(LPCWSTR pszProvider, ULONG dwMode, ULONG dwInterface, ULONG *pcbBuffer, PCRYPT_PROVIDER_REG *ppBuffer)
     * }
     */
    public static MethodHandle BCryptQueryProviderRegistration$handle() {
        return BCryptQueryProviderRegistration.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * NTSTATUS BCryptQueryProviderRegistration(LPCWSTR pszProvider, ULONG dwMode, ULONG dwInterface, ULONG *pcbBuffer, PCRYPT_PROVIDER_REG *ppBuffer)
     * }
     */
    public static int BCryptQueryProviderRegistration(MemorySegment pszProvider, int dwMode, int dwInterface, MemorySegment pcbBuffer, MemorySegment ppBuffer) {
        var mh$ = BCryptQueryProviderRegistration.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("BCryptQueryProviderRegistration", pszProvider, dwMode, dwInterface, pcbBuffer, ppBuffer);
            }
            return (int)mh$.invokeExact(pszProvider, dwMode, dwInterface, pcbBuffer, ppBuffer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class BCryptEnumRegisteredProviders {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("BCryptEnumRegisteredProviders"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * NTSTATUS BCryptEnumRegisteredProviders(ULONG *pcbBuffer, PCRYPT_PROVIDERS *ppBuffer)
     * }
     */
    public static FunctionDescriptor BCryptEnumRegisteredProviders$descriptor() {
        return BCryptEnumRegisteredProviders.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * NTSTATUS BCryptEnumRegisteredProviders(ULONG *pcbBuffer, PCRYPT_PROVIDERS *ppBuffer)
     * }
     */
    public static MethodHandle BCryptEnumRegisteredProviders$handle() {
        return BCryptEnumRegisteredProviders.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * NTSTATUS BCryptEnumRegisteredProviders(ULONG *pcbBuffer, PCRYPT_PROVIDERS *ppBuffer)
     * }
     */
    public static int BCryptEnumRegisteredProviders(MemorySegment pcbBuffer, MemorySegment ppBuffer) {
        var mh$ = BCryptEnumRegisteredProviders.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("BCryptEnumRegisteredProviders", pcbBuffer, ppBuffer);
            }
            return (int)mh$.invokeExact(pcbBuffer, ppBuffer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class BCryptCreateContext {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_LONG,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("BCryptCreateContext"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * NTSTATUS BCryptCreateContext(ULONG dwTable, LPCWSTR pszContext, PCRYPT_CONTEXT_CONFIG pConfig)
     * }
     */
    public static FunctionDescriptor BCryptCreateContext$descriptor() {
        return BCryptCreateContext.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * NTSTATUS BCryptCreateContext(ULONG dwTable, LPCWSTR pszContext, PCRYPT_CONTEXT_CONFIG pConfig)
     * }
     */
    public static MethodHandle BCryptCreateContext$handle() {
        return BCryptCreateContext.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * NTSTATUS BCryptCreateContext(ULONG dwTable, LPCWSTR pszContext, PCRYPT_CONTEXT_CONFIG pConfig)
     * }
     */
    public static int BCryptCreateContext(int dwTable, MemorySegment pszContext, MemorySegment pConfig) {
        var mh$ = BCryptCreateContext.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("BCryptCreateContext", dwTable, pszContext, pConfig);
            }
            return (int)mh$.invokeExact(dwTable, pszContext, pConfig);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class BCryptDeleteContext {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_LONG,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("BCryptDeleteContext"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * NTSTATUS BCryptDeleteContext(ULONG dwTable, LPCWSTR pszContext)
     * }
     */
    public static FunctionDescriptor BCryptDeleteContext$descriptor() {
        return BCryptDeleteContext.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * NTSTATUS BCryptDeleteContext(ULONG dwTable, LPCWSTR pszContext)
     * }
     */
    public static MethodHandle BCryptDeleteContext$handle() {
        return BCryptDeleteContext.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * NTSTATUS BCryptDeleteContext(ULONG dwTable, LPCWSTR pszContext)
     * }
     */
    public static int BCryptDeleteContext(int dwTable, MemorySegment pszContext) {
        var mh$ = BCryptDeleteContext.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("BCryptDeleteContext", dwTable, pszContext);
            }
            return (int)mh$.invokeExact(dwTable, pszContext);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class BCryptEnumContexts {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_LONG,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("BCryptEnumContexts"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * NTSTATUS BCryptEnumContexts(ULONG dwTable, ULONG *pcbBuffer, PCRYPT_CONTEXTS *ppBuffer)
     * }
     */
    public static FunctionDescriptor BCryptEnumContexts$descriptor() {
        return BCryptEnumContexts.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * NTSTATUS BCryptEnumContexts(ULONG dwTable, ULONG *pcbBuffer, PCRYPT_CONTEXTS *ppBuffer)
     * }
     */
    public static MethodHandle BCryptEnumContexts$handle() {
        return BCryptEnumContexts.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * NTSTATUS BCryptEnumContexts(ULONG dwTable, ULONG *pcbBuffer, PCRYPT_CONTEXTS *ppBuffer)
     * }
     */
    public static int BCryptEnumContexts(int dwTable, MemorySegment pcbBuffer, MemorySegment ppBuffer) {
        var mh$ = BCryptEnumContexts.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("BCryptEnumContexts", dwTable, pcbBuffer, ppBuffer);
            }
            return (int)mh$.invokeExact(dwTable, pcbBuffer, ppBuffer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class BCryptConfigureContext {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_LONG,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("BCryptConfigureContext"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * NTSTATUS BCryptConfigureContext(ULONG dwTable, LPCWSTR pszContext, PCRYPT_CONTEXT_CONFIG pConfig)
     * }
     */
    public static FunctionDescriptor BCryptConfigureContext$descriptor() {
        return BCryptConfigureContext.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * NTSTATUS BCryptConfigureContext(ULONG dwTable, LPCWSTR pszContext, PCRYPT_CONTEXT_CONFIG pConfig)
     * }
     */
    public static MethodHandle BCryptConfigureContext$handle() {
        return BCryptConfigureContext.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * NTSTATUS BCryptConfigureContext(ULONG dwTable, LPCWSTR pszContext, PCRYPT_CONTEXT_CONFIG pConfig)
     * }
     */
    public static int BCryptConfigureContext(int dwTable, MemorySegment pszContext, MemorySegment pConfig) {
        var mh$ = BCryptConfigureContext.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("BCryptConfigureContext", dwTable, pszContext, pConfig);
            }
            return (int)mh$.invokeExact(dwTable, pszContext, pConfig);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class BCryptQueryContextConfiguration {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_LONG,
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("BCryptQueryContextConfiguration"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * NTSTATUS BCryptQueryContextConfiguration(ULONG dwTable, LPCWSTR pszContext, ULONG *pcbBuffer, PCRYPT_CONTEXT_CONFIG *ppBuffer)
     * }
     */
    public static FunctionDescriptor BCryptQueryContextConfiguration$descriptor() {
        return BCryptQueryContextConfiguration.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * NTSTATUS BCryptQueryContextConfiguration(ULONG dwTable, LPCWSTR pszContext, ULONG *pcbBuffer, PCRYPT_CONTEXT_CONFIG *ppBuffer)
     * }
     */
    public static MethodHandle BCryptQueryContextConfiguration$handle() {
        return BCryptQueryContextConfiguration.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * NTSTATUS BCryptQueryContextConfiguration(ULONG dwTable, LPCWSTR pszContext, ULONG *pcbBuffer, PCRYPT_CONTEXT_CONFIG *ppBuffer)
     * }
     */
    public static int BCryptQueryContextConfiguration(int dwTable, MemorySegment pszContext, MemorySegment pcbBuffer, MemorySegment ppBuffer) {
        var mh$ = BCryptQueryContextConfiguration.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("BCryptQueryContextConfiguration", dwTable, pszContext, pcbBuffer, ppBuffer);
            }
            return (int)mh$.invokeExact(dwTable, pszContext, pcbBuffer, ppBuffer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class BCryptAddContextFunction {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_LONG,
            C_POINTER,
            C_LONG,
            C_POINTER,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("BCryptAddContextFunction"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * NTSTATUS BCryptAddContextFunction(ULONG dwTable, LPCWSTR pszContext, ULONG dwInterface, LPCWSTR pszFunction, ULONG dwPosition)
     * }
     */
    public static FunctionDescriptor BCryptAddContextFunction$descriptor() {
        return BCryptAddContextFunction.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * NTSTATUS BCryptAddContextFunction(ULONG dwTable, LPCWSTR pszContext, ULONG dwInterface, LPCWSTR pszFunction, ULONG dwPosition)
     * }
     */
    public static MethodHandle BCryptAddContextFunction$handle() {
        return BCryptAddContextFunction.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * NTSTATUS BCryptAddContextFunction(ULONG dwTable, LPCWSTR pszContext, ULONG dwInterface, LPCWSTR pszFunction, ULONG dwPosition)
     * }
     */
    public static int BCryptAddContextFunction(int dwTable, MemorySegment pszContext, int dwInterface, MemorySegment pszFunction, int dwPosition) {
        var mh$ = BCryptAddContextFunction.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("BCryptAddContextFunction", dwTable, pszContext, dwInterface, pszFunction, dwPosition);
            }
            return (int)mh$.invokeExact(dwTable, pszContext, dwInterface, pszFunction, dwPosition);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class BCryptRemoveContextFunction {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_LONG,
            C_POINTER,
            C_LONG,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("BCryptRemoveContextFunction"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * NTSTATUS BCryptRemoveContextFunction(ULONG dwTable, LPCWSTR pszContext, ULONG dwInterface, LPCWSTR pszFunction)
     * }
     */
    public static FunctionDescriptor BCryptRemoveContextFunction$descriptor() {
        return BCryptRemoveContextFunction.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * NTSTATUS BCryptRemoveContextFunction(ULONG dwTable, LPCWSTR pszContext, ULONG dwInterface, LPCWSTR pszFunction)
     * }
     */
    public static MethodHandle BCryptRemoveContextFunction$handle() {
        return BCryptRemoveContextFunction.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * NTSTATUS BCryptRemoveContextFunction(ULONG dwTable, LPCWSTR pszContext, ULONG dwInterface, LPCWSTR pszFunction)
     * }
     */
    public static int BCryptRemoveContextFunction(int dwTable, MemorySegment pszContext, int dwInterface, MemorySegment pszFunction) {
        var mh$ = BCryptRemoveContextFunction.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("BCryptRemoveContextFunction", dwTable, pszContext, dwInterface, pszFunction);
            }
            return (int)mh$.invokeExact(dwTable, pszContext, dwInterface, pszFunction);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class BCryptEnumContextFunctions {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_LONG,
            C_POINTER,
            C_LONG,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("BCryptEnumContextFunctions"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * NTSTATUS BCryptEnumContextFunctions(ULONG dwTable, LPCWSTR pszContext, ULONG dwInterface, ULONG *pcbBuffer, PCRYPT_CONTEXT_FUNCTIONS *ppBuffer)
     * }
     */
    public static FunctionDescriptor BCryptEnumContextFunctions$descriptor() {
        return BCryptEnumContextFunctions.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * NTSTATUS BCryptEnumContextFunctions(ULONG dwTable, LPCWSTR pszContext, ULONG dwInterface, ULONG *pcbBuffer, PCRYPT_CONTEXT_FUNCTIONS *ppBuffer)
     * }
     */
    public static MethodHandle BCryptEnumContextFunctions$handle() {
        return BCryptEnumContextFunctions.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * NTSTATUS BCryptEnumContextFunctions(ULONG dwTable, LPCWSTR pszContext, ULONG dwInterface, ULONG *pcbBuffer, PCRYPT_CONTEXT_FUNCTIONS *ppBuffer)
     * }
     */
    public static int BCryptEnumContextFunctions(int dwTable, MemorySegment pszContext, int dwInterface, MemorySegment pcbBuffer, MemorySegment ppBuffer) {
        var mh$ = BCryptEnumContextFunctions.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("BCryptEnumContextFunctions", dwTable, pszContext, dwInterface, pcbBuffer, ppBuffer);
            }
            return (int)mh$.invokeExact(dwTable, pszContext, dwInterface, pcbBuffer, ppBuffer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class BCryptConfigureContextFunction {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_LONG,
            C_POINTER,
            C_LONG,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("BCryptConfigureContextFunction"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * NTSTATUS BCryptConfigureContextFunction(ULONG dwTable, LPCWSTR pszContext, ULONG dwInterface, LPCWSTR pszFunction, PCRYPT_CONTEXT_FUNCTION_CONFIG pConfig)
     * }
     */
    public static FunctionDescriptor BCryptConfigureContextFunction$descriptor() {
        return BCryptConfigureContextFunction.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * NTSTATUS BCryptConfigureContextFunction(ULONG dwTable, LPCWSTR pszContext, ULONG dwInterface, LPCWSTR pszFunction, PCRYPT_CONTEXT_FUNCTION_CONFIG pConfig)
     * }
     */
    public static MethodHandle BCryptConfigureContextFunction$handle() {
        return BCryptConfigureContextFunction.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * NTSTATUS BCryptConfigureContextFunction(ULONG dwTable, LPCWSTR pszContext, ULONG dwInterface, LPCWSTR pszFunction, PCRYPT_CONTEXT_FUNCTION_CONFIG pConfig)
     * }
     */
    public static int BCryptConfigureContextFunction(int dwTable, MemorySegment pszContext, int dwInterface, MemorySegment pszFunction, MemorySegment pConfig) {
        var mh$ = BCryptConfigureContextFunction.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("BCryptConfigureContextFunction", dwTable, pszContext, dwInterface, pszFunction, pConfig);
            }
            return (int)mh$.invokeExact(dwTable, pszContext, dwInterface, pszFunction, pConfig);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class BCryptQueryContextFunctionConfiguration {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_LONG,
            C_POINTER,
            C_LONG,
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("BCryptQueryContextFunctionConfiguration"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * NTSTATUS BCryptQueryContextFunctionConfiguration(ULONG dwTable, LPCWSTR pszContext, ULONG dwInterface, LPCWSTR pszFunction, ULONG *pcbBuffer, PCRYPT_CONTEXT_FUNCTION_CONFIG *ppBuffer)
     * }
     */
    public static FunctionDescriptor BCryptQueryContextFunctionConfiguration$descriptor() {
        return BCryptQueryContextFunctionConfiguration.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * NTSTATUS BCryptQueryContextFunctionConfiguration(ULONG dwTable, LPCWSTR pszContext, ULONG dwInterface, LPCWSTR pszFunction, ULONG *pcbBuffer, PCRYPT_CONTEXT_FUNCTION_CONFIG *ppBuffer)
     * }
     */
    public static MethodHandle BCryptQueryContextFunctionConfiguration$handle() {
        return BCryptQueryContextFunctionConfiguration.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * NTSTATUS BCryptQueryContextFunctionConfiguration(ULONG dwTable, LPCWSTR pszContext, ULONG dwInterface, LPCWSTR pszFunction, ULONG *pcbBuffer, PCRYPT_CONTEXT_FUNCTION_CONFIG *ppBuffer)
     * }
     */
    public static int BCryptQueryContextFunctionConfiguration(int dwTable, MemorySegment pszContext, int dwInterface, MemorySegment pszFunction, MemorySegment pcbBuffer, MemorySegment ppBuffer) {
        var mh$ = BCryptQueryContextFunctionConfiguration.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("BCryptQueryContextFunctionConfiguration", dwTable, pszContext, dwInterface, pszFunction, pcbBuffer, ppBuffer);
            }
            return (int)mh$.invokeExact(dwTable, pszContext, dwInterface, pszFunction, pcbBuffer, ppBuffer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class BCryptEnumContextFunctionProviders {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_LONG,
            C_POINTER,
            C_LONG,
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("BCryptEnumContextFunctionProviders"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * NTSTATUS BCryptEnumContextFunctionProviders(ULONG dwTable, LPCWSTR pszContext, ULONG dwInterface, LPCWSTR pszFunction, ULONG *pcbBuffer, PCRYPT_CONTEXT_FUNCTION_PROVIDERS *ppBuffer)
     * }
     */
    public static FunctionDescriptor BCryptEnumContextFunctionProviders$descriptor() {
        return BCryptEnumContextFunctionProviders.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * NTSTATUS BCryptEnumContextFunctionProviders(ULONG dwTable, LPCWSTR pszContext, ULONG dwInterface, LPCWSTR pszFunction, ULONG *pcbBuffer, PCRYPT_CONTEXT_FUNCTION_PROVIDERS *ppBuffer)
     * }
     */
    public static MethodHandle BCryptEnumContextFunctionProviders$handle() {
        return BCryptEnumContextFunctionProviders.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * NTSTATUS BCryptEnumContextFunctionProviders(ULONG dwTable, LPCWSTR pszContext, ULONG dwInterface, LPCWSTR pszFunction, ULONG *pcbBuffer, PCRYPT_CONTEXT_FUNCTION_PROVIDERS *ppBuffer)
     * }
     */
    public static int BCryptEnumContextFunctionProviders(int dwTable, MemorySegment pszContext, int dwInterface, MemorySegment pszFunction, MemorySegment pcbBuffer, MemorySegment ppBuffer) {
        var mh$ = BCryptEnumContextFunctionProviders.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("BCryptEnumContextFunctionProviders", dwTable, pszContext, dwInterface, pszFunction, pcbBuffer, ppBuffer);
            }
            return (int)mh$.invokeExact(dwTable, pszContext, dwInterface, pszFunction, pcbBuffer, ppBuffer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class BCryptSetContextFunctionProperty {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_LONG,
            C_POINTER,
            C_LONG,
            C_POINTER,
            C_POINTER,
            C_LONG,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("BCryptSetContextFunctionProperty"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * NTSTATUS BCryptSetContextFunctionProperty(ULONG dwTable, LPCWSTR pszContext, ULONG dwInterface, LPCWSTR pszFunction, LPCWSTR pszProperty, ULONG cbValue, PUCHAR pbValue)
     * }
     */
    public static FunctionDescriptor BCryptSetContextFunctionProperty$descriptor() {
        return BCryptSetContextFunctionProperty.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * NTSTATUS BCryptSetContextFunctionProperty(ULONG dwTable, LPCWSTR pszContext, ULONG dwInterface, LPCWSTR pszFunction, LPCWSTR pszProperty, ULONG cbValue, PUCHAR pbValue)
     * }
     */
    public static MethodHandle BCryptSetContextFunctionProperty$handle() {
        return BCryptSetContextFunctionProperty.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * NTSTATUS BCryptSetContextFunctionProperty(ULONG dwTable, LPCWSTR pszContext, ULONG dwInterface, LPCWSTR pszFunction, LPCWSTR pszProperty, ULONG cbValue, PUCHAR pbValue)
     * }
     */
    public static int BCryptSetContextFunctionProperty(int dwTable, MemorySegment pszContext, int dwInterface, MemorySegment pszFunction, MemorySegment pszProperty, int cbValue, MemorySegment pbValue) {
        var mh$ = BCryptSetContextFunctionProperty.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("BCryptSetContextFunctionProperty", dwTable, pszContext, dwInterface, pszFunction, pszProperty, cbValue, pbValue);
            }
            return (int)mh$.invokeExact(dwTable, pszContext, dwInterface, pszFunction, pszProperty, cbValue, pbValue);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class BCryptQueryContextFunctionProperty {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_LONG,
            C_POINTER,
            C_LONG,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("BCryptQueryContextFunctionProperty"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * NTSTATUS BCryptQueryContextFunctionProperty(ULONG dwTable, LPCWSTR pszContext, ULONG dwInterface, LPCWSTR pszFunction, LPCWSTR pszProperty, ULONG *pcbValue, PUCHAR *ppbValue)
     * }
     */
    public static FunctionDescriptor BCryptQueryContextFunctionProperty$descriptor() {
        return BCryptQueryContextFunctionProperty.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * NTSTATUS BCryptQueryContextFunctionProperty(ULONG dwTable, LPCWSTR pszContext, ULONG dwInterface, LPCWSTR pszFunction, LPCWSTR pszProperty, ULONG *pcbValue, PUCHAR *ppbValue)
     * }
     */
    public static MethodHandle BCryptQueryContextFunctionProperty$handle() {
        return BCryptQueryContextFunctionProperty.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * NTSTATUS BCryptQueryContextFunctionProperty(ULONG dwTable, LPCWSTR pszContext, ULONG dwInterface, LPCWSTR pszFunction, LPCWSTR pszProperty, ULONG *pcbValue, PUCHAR *ppbValue)
     * }
     */
    public static int BCryptQueryContextFunctionProperty(int dwTable, MemorySegment pszContext, int dwInterface, MemorySegment pszFunction, MemorySegment pszProperty, MemorySegment pcbValue, MemorySegment ppbValue) {
        var mh$ = BCryptQueryContextFunctionProperty.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("BCryptQueryContextFunctionProperty", dwTable, pszContext, dwInterface, pszFunction, pszProperty, pcbValue, ppbValue);
            }
            return (int)mh$.invokeExact(dwTable, pszContext, dwInterface, pszFunction, pszProperty, pcbValue, ppbValue);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class BCryptRegisterConfigChangeNotify {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("BCryptRegisterConfigChangeNotify"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * NTSTATUS BCryptRegisterConfigChangeNotify(HANDLE *phEvent)
     * }
     */
    public static FunctionDescriptor BCryptRegisterConfigChangeNotify$descriptor() {
        return BCryptRegisterConfigChangeNotify.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * NTSTATUS BCryptRegisterConfigChangeNotify(HANDLE *phEvent)
     * }
     */
    public static MethodHandle BCryptRegisterConfigChangeNotify$handle() {
        return BCryptRegisterConfigChangeNotify.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * NTSTATUS BCryptRegisterConfigChangeNotify(HANDLE *phEvent)
     * }
     */
    public static int BCryptRegisterConfigChangeNotify(MemorySegment phEvent) {
        var mh$ = BCryptRegisterConfigChangeNotify.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("BCryptRegisterConfigChangeNotify", phEvent);
            }
            return (int)mh$.invokeExact(phEvent);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class BCryptUnregisterConfigChangeNotify {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("BCryptUnregisterConfigChangeNotify"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * NTSTATUS BCryptUnregisterConfigChangeNotify(HANDLE hEvent)
     * }
     */
    public static FunctionDescriptor BCryptUnregisterConfigChangeNotify$descriptor() {
        return BCryptUnregisterConfigChangeNotify.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * NTSTATUS BCryptUnregisterConfigChangeNotify(HANDLE hEvent)
     * }
     */
    public static MethodHandle BCryptUnregisterConfigChangeNotify$handle() {
        return BCryptUnregisterConfigChangeNotify.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * NTSTATUS BCryptUnregisterConfigChangeNotify(HANDLE hEvent)
     * }
     */
    public static int BCryptUnregisterConfigChangeNotify(MemorySegment hEvent) {
        var mh$ = BCryptUnregisterConfigChangeNotify.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("BCryptUnregisterConfigChangeNotify", hEvent);
            }
            return (int)mh$.invokeExact(hEvent);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class BCryptResolveProviders {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_POINTER,
            C_LONG,
            C_POINTER,
            C_POINTER,
            C_LONG,
            C_LONG,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("BCryptResolveProviders"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * NTSTATUS BCryptResolveProviders(LPCWSTR pszContext, ULONG dwInterface, LPCWSTR pszFunction, LPCWSTR pszProvider, ULONG dwMode, ULONG dwFlags, ULONG *pcbBuffer, PCRYPT_PROVIDER_REFS *ppBuffer)
     * }
     */
    public static FunctionDescriptor BCryptResolveProviders$descriptor() {
        return BCryptResolveProviders.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * NTSTATUS BCryptResolveProviders(LPCWSTR pszContext, ULONG dwInterface, LPCWSTR pszFunction, LPCWSTR pszProvider, ULONG dwMode, ULONG dwFlags, ULONG *pcbBuffer, PCRYPT_PROVIDER_REFS *ppBuffer)
     * }
     */
    public static MethodHandle BCryptResolveProviders$handle() {
        return BCryptResolveProviders.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * NTSTATUS BCryptResolveProviders(LPCWSTR pszContext, ULONG dwInterface, LPCWSTR pszFunction, LPCWSTR pszProvider, ULONG dwMode, ULONG dwFlags, ULONG *pcbBuffer, PCRYPT_PROVIDER_REFS *ppBuffer)
     * }
     */
    public static int BCryptResolveProviders(MemorySegment pszContext, int dwInterface, MemorySegment pszFunction, MemorySegment pszProvider, int dwMode, int dwFlags, MemorySegment pcbBuffer, MemorySegment ppBuffer) {
        var mh$ = BCryptResolveProviders.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("BCryptResolveProviders", pszContext, dwInterface, pszFunction, pszProvider, dwMode, dwFlags, pcbBuffer, ppBuffer);
            }
            return (int)mh$.invokeExact(pszContext, dwInterface, pszFunction, pszProvider, dwMode, dwFlags, pcbBuffer, ppBuffer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class BCryptGetFipsAlgorithmMode {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("BCryptGetFipsAlgorithmMode"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * NTSTATUS BCryptGetFipsAlgorithmMode(BOOLEAN *pfEnabled)
     * }
     */
    public static FunctionDescriptor BCryptGetFipsAlgorithmMode$descriptor() {
        return BCryptGetFipsAlgorithmMode.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * NTSTATUS BCryptGetFipsAlgorithmMode(BOOLEAN *pfEnabled)
     * }
     */
    public static MethodHandle BCryptGetFipsAlgorithmMode$handle() {
        return BCryptGetFipsAlgorithmMode.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * NTSTATUS BCryptGetFipsAlgorithmMode(BOOLEAN *pfEnabled)
     * }
     */
    public static int BCryptGetFipsAlgorithmMode(MemorySegment pfEnabled) {
        var mh$ = BCryptGetFipsAlgorithmMode.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("BCryptGetFipsAlgorithmMode", pfEnabled);
            }
            return (int)mh$.invokeExact(pfEnabled);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CngGetFipsAlgorithmMode {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_CHAR    );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CngGetFipsAlgorithmMode"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOLEAN CngGetFipsAlgorithmMode()
     * }
     */
    public static FunctionDescriptor CngGetFipsAlgorithmMode$descriptor() {
        return CngGetFipsAlgorithmMode.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOLEAN CngGetFipsAlgorithmMode()
     * }
     */
    public static MethodHandle CngGetFipsAlgorithmMode$handle() {
        return CngGetFipsAlgorithmMode.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOLEAN CngGetFipsAlgorithmMode()
     * }
     */
    public static byte CngGetFipsAlgorithmMode() {
        var mh$ = CngGetFipsAlgorithmMode.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CngGetFipsAlgorithmMode");
            }
            return (byte)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef LONG SECURITY_STATUS
     * }
     */
    public static final OfInt SECURITY_STATUS = C_LONG;
    /**
     * {@snippet lang=c :
     * typedef BCryptBuffer *PNCryptBuffer
     * }
     */
    public static final AddressLayout PNCryptBuffer = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef BCryptBufferDesc *PNCryptBufferDesc
     * }
     */
    public static final AddressLayout PNCryptBufferDesc = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef ULONG_PTR NCRYPT_HANDLE
     * }
     */
    public static final OfLong NCRYPT_HANDLE = C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef ULONG_PTR NCRYPT_PROV_HANDLE
     * }
     */
    public static final OfLong NCRYPT_PROV_HANDLE = C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef ULONG_PTR NCRYPT_KEY_HANDLE
     * }
     */
    public static final OfLong NCRYPT_KEY_HANDLE = C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef ULONG_PTR NCRYPT_HASH_HANDLE
     * }
     */
    public static final OfLong NCRYPT_HASH_HANDLE = C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef ULONG_PTR NCRYPT_SECRET_HANDLE
     * }
     */
    public static final OfLong NCRYPT_SECRET_HANDLE = C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef struct _NCRYPT_CIPHER_PADDING_INFO {
     *     ULONG cbSize;
     *     DWORD dwFlags;
     *     PUCHAR pbIV;
     *     ULONG cbIV;
     *     PUCHAR pbOtherInfo;
     *     ULONG cbOtherInfo;
     * } *PNCRYPT_CIPHER_PADDING_INFO
     * }
     */
    public static final AddressLayout PNCRYPT_CIPHER_PADDING_INFO = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _NCRYPT_ISOLATED_KEY_ATTESTED_ATTRIBUTES {
     *     ULONG Version;
     *     ULONG Flags;
     *     ULONG cbPublicKeyBlob;
     * } *PNCRYPT_ISOLATED_KEY_ATTESTED_ATTRIBUTES
     * }
     */
    public static final AddressLayout PNCRYPT_ISOLATED_KEY_ATTESTED_ATTRIBUTES = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _NCRYPT_VSM_KEY_ATTESTATION_STATEMENT {
     *     ULONG Magic;
     *     ULONG Version;
     *     ULONG cbSignature;
     *     ULONG cbReport;
     *     ULONG cbAttributes;
     * } *PNCRYPT_VSM_KEY_ATTESTATION_STATEMENT
     * }
     */
    public static final AddressLayout PNCRYPT_VSM_KEY_ATTESTATION_STATEMENT = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _NCRYPT_VSM_KEY_ATTESTATION_CLAIM_RESTRICTIONS {
     *     ULONG Version;
     *     ULONGLONG TrustletId;
     *     ULONG MinSvn;
     *     ULONG FlagsMask;
     *     ULONG FlagsExpected;
     *     ULONG AllowDebugging : 1;
     *     ULONG Reserved : 31;
     * } *PNCRYPT_VSM_KEY_ATTESTATION_CLAIM_RESTRICTIONS
     * }
     */
    public static final AddressLayout PNCRYPT_VSM_KEY_ATTESTATION_CLAIM_RESTRICTIONS = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _NCRYPT_EXPORTED_ISOLATED_KEY_HEADER {
     *     ULONG Version;
     *     ULONG KeyUsage;
     *     ULONG PerBootKey : 1;
     *     ULONG Reserved : 31;
     *     ULONG cbAlgName;
     *     ULONG cbNonce;
     *     ULONG cbAuthTag;
     *     ULONG cbWrappingKey;
     *     ULONG cbIsolatedKey;
     * } *PNCRYPT_EXPORTED_ISOLATED_KEY_HEADER
     * }
     */
    public static final AddressLayout PNCRYPT_EXPORTED_ISOLATED_KEY_HEADER = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _NCRYPT_EXPORTED_ISOLATED_KEY_ENVELOPE {
     *     NCRYPT_EXPORTED_ISOLATED_KEY_HEADER Header;
     * } *PNCRYPT_EXPORTED_ISOLATED_KEY_ENVELOPE
     * }
     */
    public static final AddressLayout PNCRYPT_EXPORTED_ISOLATED_KEY_ENVELOPE = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct __NCRYPT_PCP_TPM_WEB_AUTHN_ATTESTATION_STATEMENT {
     *     UINT32 Magic;
     *     UINT32 Version;
     *     UINT32 HeaderSize;
     *     UINT32 cbCertifyInfo;
     *     UINT32 cbSignature;
     *     UINT32 cbTpmPublic;
     * } *PNCRYPT_PCP_TPM_WEB_AUTHN_ATTESTATION_STATEMENT
     * }
     */
    public static final AddressLayout PNCRYPT_PCP_TPM_WEB_AUTHN_ATTESTATION_STATEMENT = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _NCRYPT_TPM_PLATFORM_ATTESTATION_STATEMENT {
     *     ULONG Magic;
     *     ULONG Version;
     *     ULONG pcrAlg;
     *     ULONG cbSignature;
     *     ULONG cbQuote;
     *     ULONG cbPcrs;
     * } *PNCRYPT_TPM_PLATFORM_ATTESTATION_STATEMENT
     * }
     */
    public static final AddressLayout PNCRYPT_TPM_PLATFORM_ATTESTATION_STATEMENT = C_POINTER;

    private static class NCryptOpenStorageProvider {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_POINTER,
            C_POINTER,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("NCryptOpenStorageProvider"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SECURITY_STATUS NCryptOpenStorageProvider(NCRYPT_PROV_HANDLE *phProvider, LPCWSTR pszProviderName, DWORD dwFlags)
     * }
     */
    public static FunctionDescriptor NCryptOpenStorageProvider$descriptor() {
        return NCryptOpenStorageProvider.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SECURITY_STATUS NCryptOpenStorageProvider(NCRYPT_PROV_HANDLE *phProvider, LPCWSTR pszProviderName, DWORD dwFlags)
     * }
     */
    public static MethodHandle NCryptOpenStorageProvider$handle() {
        return NCryptOpenStorageProvider.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * SECURITY_STATUS NCryptOpenStorageProvider(NCRYPT_PROV_HANDLE *phProvider, LPCWSTR pszProviderName, DWORD dwFlags)
     * }
     */
    public static int NCryptOpenStorageProvider(MemorySegment phProvider, MemorySegment pszProviderName, int dwFlags) {
        var mh$ = NCryptOpenStorageProvider.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("NCryptOpenStorageProvider", phProvider, pszProviderName, dwFlags);
            }
            return (int)mh$.invokeExact(phProvider, pszProviderName, dwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class NCryptEnumAlgorithms {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_LONG_LONG,
            C_LONG,
            C_POINTER,
            C_POINTER,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("NCryptEnumAlgorithms"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SECURITY_STATUS NCryptEnumAlgorithms(NCRYPT_PROV_HANDLE hProvider, DWORD dwAlgOperations, DWORD *pdwAlgCount, NCryptAlgorithmName **ppAlgList, DWORD dwFlags)
     * }
     */
    public static FunctionDescriptor NCryptEnumAlgorithms$descriptor() {
        return NCryptEnumAlgorithms.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SECURITY_STATUS NCryptEnumAlgorithms(NCRYPT_PROV_HANDLE hProvider, DWORD dwAlgOperations, DWORD *pdwAlgCount, NCryptAlgorithmName **ppAlgList, DWORD dwFlags)
     * }
     */
    public static MethodHandle NCryptEnumAlgorithms$handle() {
        return NCryptEnumAlgorithms.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * SECURITY_STATUS NCryptEnumAlgorithms(NCRYPT_PROV_HANDLE hProvider, DWORD dwAlgOperations, DWORD *pdwAlgCount, NCryptAlgorithmName **ppAlgList, DWORD dwFlags)
     * }
     */
    public static int NCryptEnumAlgorithms(long hProvider, int dwAlgOperations, MemorySegment pdwAlgCount, MemorySegment ppAlgList, int dwFlags) {
        var mh$ = NCryptEnumAlgorithms.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("NCryptEnumAlgorithms", hProvider, dwAlgOperations, pdwAlgCount, ppAlgList, dwFlags);
            }
            return (int)mh$.invokeExact(hProvider, dwAlgOperations, pdwAlgCount, ppAlgList, dwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class NCryptIsAlgSupported {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_LONG_LONG,
            C_POINTER,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("NCryptIsAlgSupported"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SECURITY_STATUS NCryptIsAlgSupported(NCRYPT_PROV_HANDLE hProvider, LPCWSTR pszAlgId, DWORD dwFlags)
     * }
     */
    public static FunctionDescriptor NCryptIsAlgSupported$descriptor() {
        return NCryptIsAlgSupported.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SECURITY_STATUS NCryptIsAlgSupported(NCRYPT_PROV_HANDLE hProvider, LPCWSTR pszAlgId, DWORD dwFlags)
     * }
     */
    public static MethodHandle NCryptIsAlgSupported$handle() {
        return NCryptIsAlgSupported.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * SECURITY_STATUS NCryptIsAlgSupported(NCRYPT_PROV_HANDLE hProvider, LPCWSTR pszAlgId, DWORD dwFlags)
     * }
     */
    public static int NCryptIsAlgSupported(long hProvider, MemorySegment pszAlgId, int dwFlags) {
        var mh$ = NCryptIsAlgSupported.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("NCryptIsAlgSupported", hProvider, pszAlgId, dwFlags);
            }
            return (int)mh$.invokeExact(hProvider, pszAlgId, dwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class NCryptEnumKeys {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_LONG_LONG,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("NCryptEnumKeys"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SECURITY_STATUS NCryptEnumKeys(NCRYPT_PROV_HANDLE hProvider, LPCWSTR pszScope, NCryptKeyName **ppKeyName, PVOID *ppEnumState, DWORD dwFlags)
     * }
     */
    public static FunctionDescriptor NCryptEnumKeys$descriptor() {
        return NCryptEnumKeys.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SECURITY_STATUS NCryptEnumKeys(NCRYPT_PROV_HANDLE hProvider, LPCWSTR pszScope, NCryptKeyName **ppKeyName, PVOID *ppEnumState, DWORD dwFlags)
     * }
     */
    public static MethodHandle NCryptEnumKeys$handle() {
        return NCryptEnumKeys.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * SECURITY_STATUS NCryptEnumKeys(NCRYPT_PROV_HANDLE hProvider, LPCWSTR pszScope, NCryptKeyName **ppKeyName, PVOID *ppEnumState, DWORD dwFlags)
     * }
     */
    public static int NCryptEnumKeys(long hProvider, MemorySegment pszScope, MemorySegment ppKeyName, MemorySegment ppEnumState, int dwFlags) {
        var mh$ = NCryptEnumKeys.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("NCryptEnumKeys", hProvider, pszScope, ppKeyName, ppEnumState, dwFlags);
            }
            return (int)mh$.invokeExact(hProvider, pszScope, ppKeyName, ppEnumState, dwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class NCryptEnumStorageProviders {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_POINTER,
            C_POINTER,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("NCryptEnumStorageProviders"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SECURITY_STATUS NCryptEnumStorageProviders(DWORD *pdwProviderCount, NCryptProviderName **ppProviderList, DWORD dwFlags)
     * }
     */
    public static FunctionDescriptor NCryptEnumStorageProviders$descriptor() {
        return NCryptEnumStorageProviders.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SECURITY_STATUS NCryptEnumStorageProviders(DWORD *pdwProviderCount, NCryptProviderName **ppProviderList, DWORD dwFlags)
     * }
     */
    public static MethodHandle NCryptEnumStorageProviders$handle() {
        return NCryptEnumStorageProviders.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * SECURITY_STATUS NCryptEnumStorageProviders(DWORD *pdwProviderCount, NCryptProviderName **ppProviderList, DWORD dwFlags)
     * }
     */
    public static int NCryptEnumStorageProviders(MemorySegment pdwProviderCount, MemorySegment ppProviderList, int dwFlags) {
        var mh$ = NCryptEnumStorageProviders.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("NCryptEnumStorageProviders", pdwProviderCount, ppProviderList, dwFlags);
            }
            return (int)mh$.invokeExact(pdwProviderCount, ppProviderList, dwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class NCryptFreeBuffer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("NCryptFreeBuffer"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SECURITY_STATUS NCryptFreeBuffer(PVOID pvInput)
     * }
     */
    public static FunctionDescriptor NCryptFreeBuffer$descriptor() {
        return NCryptFreeBuffer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SECURITY_STATUS NCryptFreeBuffer(PVOID pvInput)
     * }
     */
    public static MethodHandle NCryptFreeBuffer$handle() {
        return NCryptFreeBuffer.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * SECURITY_STATUS NCryptFreeBuffer(PVOID pvInput)
     * }
     */
    public static int NCryptFreeBuffer(MemorySegment pvInput) {
        var mh$ = NCryptFreeBuffer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("NCryptFreeBuffer", pvInput);
            }
            return (int)mh$.invokeExact(pvInput);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class NCryptOpenKey {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_LONG_LONG,
            C_POINTER,
            C_POINTER,
            C_LONG,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("NCryptOpenKey"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SECURITY_STATUS NCryptOpenKey(NCRYPT_PROV_HANDLE hProvider, NCRYPT_KEY_HANDLE *phKey, LPCWSTR pszKeyName, DWORD dwLegacyKeySpec, DWORD dwFlags)
     * }
     */
    public static FunctionDescriptor NCryptOpenKey$descriptor() {
        return NCryptOpenKey.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SECURITY_STATUS NCryptOpenKey(NCRYPT_PROV_HANDLE hProvider, NCRYPT_KEY_HANDLE *phKey, LPCWSTR pszKeyName, DWORD dwLegacyKeySpec, DWORD dwFlags)
     * }
     */
    public static MethodHandle NCryptOpenKey$handle() {
        return NCryptOpenKey.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * SECURITY_STATUS NCryptOpenKey(NCRYPT_PROV_HANDLE hProvider, NCRYPT_KEY_HANDLE *phKey, LPCWSTR pszKeyName, DWORD dwLegacyKeySpec, DWORD dwFlags)
     * }
     */
    public static int NCryptOpenKey(long hProvider, MemorySegment phKey, MemorySegment pszKeyName, int dwLegacyKeySpec, int dwFlags) {
        var mh$ = NCryptOpenKey.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("NCryptOpenKey", hProvider, phKey, pszKeyName, dwLegacyKeySpec, dwFlags);
            }
            return (int)mh$.invokeExact(hProvider, phKey, pszKeyName, dwLegacyKeySpec, dwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class NCryptCreatePersistedKey {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_LONG_LONG,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_LONG,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("NCryptCreatePersistedKey"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SECURITY_STATUS NCryptCreatePersistedKey(NCRYPT_PROV_HANDLE hProvider, NCRYPT_KEY_HANDLE *phKey, LPCWSTR pszAlgId, LPCWSTR pszKeyName, DWORD dwLegacyKeySpec, DWORD dwFlags)
     * }
     */
    public static FunctionDescriptor NCryptCreatePersistedKey$descriptor() {
        return NCryptCreatePersistedKey.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SECURITY_STATUS NCryptCreatePersistedKey(NCRYPT_PROV_HANDLE hProvider, NCRYPT_KEY_HANDLE *phKey, LPCWSTR pszAlgId, LPCWSTR pszKeyName, DWORD dwLegacyKeySpec, DWORD dwFlags)
     * }
     */
    public static MethodHandle NCryptCreatePersistedKey$handle() {
        return NCryptCreatePersistedKey.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * SECURITY_STATUS NCryptCreatePersistedKey(NCRYPT_PROV_HANDLE hProvider, NCRYPT_KEY_HANDLE *phKey, LPCWSTR pszAlgId, LPCWSTR pszKeyName, DWORD dwLegacyKeySpec, DWORD dwFlags)
     * }
     */
    public static int NCryptCreatePersistedKey(long hProvider, MemorySegment phKey, MemorySegment pszAlgId, MemorySegment pszKeyName, int dwLegacyKeySpec, int dwFlags) {
        var mh$ = NCryptCreatePersistedKey.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("NCryptCreatePersistedKey", hProvider, phKey, pszAlgId, pszKeyName, dwLegacyKeySpec, dwFlags);
            }
            return (int)mh$.invokeExact(hProvider, phKey, pszAlgId, pszKeyName, dwLegacyKeySpec, dwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class NCryptGetProperty {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_LONG_LONG,
            C_POINTER,
            C_POINTER,
            C_LONG,
            C_POINTER,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("NCryptGetProperty"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SECURITY_STATUS NCryptGetProperty(NCRYPT_HANDLE hObject, LPCWSTR pszProperty, PBYTE pbOutput, DWORD cbOutput, DWORD *pcbResult, DWORD dwFlags)
     * }
     */
    public static FunctionDescriptor NCryptGetProperty$descriptor() {
        return NCryptGetProperty.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SECURITY_STATUS NCryptGetProperty(NCRYPT_HANDLE hObject, LPCWSTR pszProperty, PBYTE pbOutput, DWORD cbOutput, DWORD *pcbResult, DWORD dwFlags)
     * }
     */
    public static MethodHandle NCryptGetProperty$handle() {
        return NCryptGetProperty.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * SECURITY_STATUS NCryptGetProperty(NCRYPT_HANDLE hObject, LPCWSTR pszProperty, PBYTE pbOutput, DWORD cbOutput, DWORD *pcbResult, DWORD dwFlags)
     * }
     */
    public static int NCryptGetProperty(long hObject, MemorySegment pszProperty, MemorySegment pbOutput, int cbOutput, MemorySegment pcbResult, int dwFlags) {
        var mh$ = NCryptGetProperty.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("NCryptGetProperty", hObject, pszProperty, pbOutput, cbOutput, pcbResult, dwFlags);
            }
            return (int)mh$.invokeExact(hObject, pszProperty, pbOutput, cbOutput, pcbResult, dwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class NCryptSetProperty {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_LONG_LONG,
            C_POINTER,
            C_POINTER,
            C_LONG,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("NCryptSetProperty"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SECURITY_STATUS NCryptSetProperty(NCRYPT_HANDLE hObject, LPCWSTR pszProperty, PBYTE pbInput, DWORD cbInput, DWORD dwFlags)
     * }
     */
    public static FunctionDescriptor NCryptSetProperty$descriptor() {
        return NCryptSetProperty.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SECURITY_STATUS NCryptSetProperty(NCRYPT_HANDLE hObject, LPCWSTR pszProperty, PBYTE pbInput, DWORD cbInput, DWORD dwFlags)
     * }
     */
    public static MethodHandle NCryptSetProperty$handle() {
        return NCryptSetProperty.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * SECURITY_STATUS NCryptSetProperty(NCRYPT_HANDLE hObject, LPCWSTR pszProperty, PBYTE pbInput, DWORD cbInput, DWORD dwFlags)
     * }
     */
    public static int NCryptSetProperty(long hObject, MemorySegment pszProperty, MemorySegment pbInput, int cbInput, int dwFlags) {
        var mh$ = NCryptSetProperty.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("NCryptSetProperty", hObject, pszProperty, pbInput, cbInput, dwFlags);
            }
            return (int)mh$.invokeExact(hObject, pszProperty, pbInput, cbInput, dwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class NCryptFinalizeKey {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_LONG_LONG,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("NCryptFinalizeKey"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SECURITY_STATUS NCryptFinalizeKey(NCRYPT_KEY_HANDLE hKey, DWORD dwFlags)
     * }
     */
    public static FunctionDescriptor NCryptFinalizeKey$descriptor() {
        return NCryptFinalizeKey.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SECURITY_STATUS NCryptFinalizeKey(NCRYPT_KEY_HANDLE hKey, DWORD dwFlags)
     * }
     */
    public static MethodHandle NCryptFinalizeKey$handle() {
        return NCryptFinalizeKey.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * SECURITY_STATUS NCryptFinalizeKey(NCRYPT_KEY_HANDLE hKey, DWORD dwFlags)
     * }
     */
    public static int NCryptFinalizeKey(long hKey, int dwFlags) {
        var mh$ = NCryptFinalizeKey.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("NCryptFinalizeKey", hKey, dwFlags);
            }
            return (int)mh$.invokeExact(hKey, dwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class NCryptEncrypt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_LONG_LONG,
            C_POINTER,
            C_LONG,
            C_POINTER,
            C_POINTER,
            C_LONG,
            C_POINTER,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("NCryptEncrypt"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SECURITY_STATUS NCryptEncrypt(NCRYPT_KEY_HANDLE hKey, PBYTE pbInput, DWORD cbInput, void *pPaddingInfo, PBYTE pbOutput, DWORD cbOutput, DWORD *pcbResult, DWORD dwFlags)
     * }
     */
    public static FunctionDescriptor NCryptEncrypt$descriptor() {
        return NCryptEncrypt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SECURITY_STATUS NCryptEncrypt(NCRYPT_KEY_HANDLE hKey, PBYTE pbInput, DWORD cbInput, void *pPaddingInfo, PBYTE pbOutput, DWORD cbOutput, DWORD *pcbResult, DWORD dwFlags)
     * }
     */
    public static MethodHandle NCryptEncrypt$handle() {
        return NCryptEncrypt.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * SECURITY_STATUS NCryptEncrypt(NCRYPT_KEY_HANDLE hKey, PBYTE pbInput, DWORD cbInput, void *pPaddingInfo, PBYTE pbOutput, DWORD cbOutput, DWORD *pcbResult, DWORD dwFlags)
     * }
     */
    public static int NCryptEncrypt(long hKey, MemorySegment pbInput, int cbInput, MemorySegment pPaddingInfo, MemorySegment pbOutput, int cbOutput, MemorySegment pcbResult, int dwFlags) {
        var mh$ = NCryptEncrypt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("NCryptEncrypt", hKey, pbInput, cbInput, pPaddingInfo, pbOutput, cbOutput, pcbResult, dwFlags);
            }
            return (int)mh$.invokeExact(hKey, pbInput, cbInput, pPaddingInfo, pbOutput, cbOutput, pcbResult, dwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class NCryptDecrypt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_LONG_LONG,
            C_POINTER,
            C_LONG,
            C_POINTER,
            C_POINTER,
            C_LONG,
            C_POINTER,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("NCryptDecrypt"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SECURITY_STATUS NCryptDecrypt(NCRYPT_KEY_HANDLE hKey, PBYTE pbInput, DWORD cbInput, void *pPaddingInfo, PBYTE pbOutput, DWORD cbOutput, DWORD *pcbResult, DWORD dwFlags)
     * }
     */
    public static FunctionDescriptor NCryptDecrypt$descriptor() {
        return NCryptDecrypt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SECURITY_STATUS NCryptDecrypt(NCRYPT_KEY_HANDLE hKey, PBYTE pbInput, DWORD cbInput, void *pPaddingInfo, PBYTE pbOutput, DWORD cbOutput, DWORD *pcbResult, DWORD dwFlags)
     * }
     */
    public static MethodHandle NCryptDecrypt$handle() {
        return NCryptDecrypt.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * SECURITY_STATUS NCryptDecrypt(NCRYPT_KEY_HANDLE hKey, PBYTE pbInput, DWORD cbInput, void *pPaddingInfo, PBYTE pbOutput, DWORD cbOutput, DWORD *pcbResult, DWORD dwFlags)
     * }
     */
    public static int NCryptDecrypt(long hKey, MemorySegment pbInput, int cbInput, MemorySegment pPaddingInfo, MemorySegment pbOutput, int cbOutput, MemorySegment pcbResult, int dwFlags) {
        var mh$ = NCryptDecrypt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("NCryptDecrypt", hKey, pbInput, cbInput, pPaddingInfo, pbOutput, cbOutput, pcbResult, dwFlags);
            }
            return (int)mh$.invokeExact(hKey, pbInput, cbInput, pPaddingInfo, pbOutput, cbOutput, pcbResult, dwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct _NCRYPT_KEY_BLOB_HEADER {
     *     ULONG cbSize;
     *     ULONG dwMagic;
     *     ULONG cbAlgName;
     *     ULONG cbKeyData;
     * } *PNCRYPT_KEY_BLOB_HEADER
     * }
     */
    public static final AddressLayout PNCRYPT_KEY_BLOB_HEADER = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct NCRYPT_TPM_LOADABLE_KEY_BLOB_HEADER {
     *     DWORD magic;
     *     DWORD cbHeader;
     *     DWORD cbPublic;
     *     DWORD cbPrivate;
     *     DWORD cbName;
     * } *PNCRYPT_TPM_LOADABLE_KEY_BLOB_HEADER
     * }
     */
    public static final AddressLayout PNCRYPT_TPM_LOADABLE_KEY_BLOB_HEADER = C_POINTER;

    private static class NCryptImportKey {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_LONG_LONG,
            C_LONG_LONG,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_LONG,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("NCryptImportKey"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SECURITY_STATUS NCryptImportKey(NCRYPT_PROV_HANDLE hProvider, NCRYPT_KEY_HANDLE hImportKey, LPCWSTR pszBlobType, NCryptBufferDesc *pParameterList, NCRYPT_KEY_HANDLE *phKey, PBYTE pbData, DWORD cbData, DWORD dwFlags)
     * }
     */
    public static FunctionDescriptor NCryptImportKey$descriptor() {
        return NCryptImportKey.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SECURITY_STATUS NCryptImportKey(NCRYPT_PROV_HANDLE hProvider, NCRYPT_KEY_HANDLE hImportKey, LPCWSTR pszBlobType, NCryptBufferDesc *pParameterList, NCRYPT_KEY_HANDLE *phKey, PBYTE pbData, DWORD cbData, DWORD dwFlags)
     * }
     */
    public static MethodHandle NCryptImportKey$handle() {
        return NCryptImportKey.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * SECURITY_STATUS NCryptImportKey(NCRYPT_PROV_HANDLE hProvider, NCRYPT_KEY_HANDLE hImportKey, LPCWSTR pszBlobType, NCryptBufferDesc *pParameterList, NCRYPT_KEY_HANDLE *phKey, PBYTE pbData, DWORD cbData, DWORD dwFlags)
     * }
     */
    public static int NCryptImportKey(long hProvider, long hImportKey, MemorySegment pszBlobType, MemorySegment pParameterList, MemorySegment phKey, MemorySegment pbData, int cbData, int dwFlags) {
        var mh$ = NCryptImportKey.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("NCryptImportKey", hProvider, hImportKey, pszBlobType, pParameterList, phKey, pbData, cbData, dwFlags);
            }
            return (int)mh$.invokeExact(hProvider, hImportKey, pszBlobType, pParameterList, phKey, pbData, cbData, dwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class NCryptExportKey {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_LONG_LONG,
            C_LONG_LONG,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_LONG,
            C_POINTER,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("NCryptExportKey"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SECURITY_STATUS NCryptExportKey(NCRYPT_KEY_HANDLE hKey, NCRYPT_KEY_HANDLE hExportKey, LPCWSTR pszBlobType, NCryptBufferDesc *pParameterList, PBYTE pbOutput, DWORD cbOutput, DWORD *pcbResult, DWORD dwFlags)
     * }
     */
    public static FunctionDescriptor NCryptExportKey$descriptor() {
        return NCryptExportKey.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SECURITY_STATUS NCryptExportKey(NCRYPT_KEY_HANDLE hKey, NCRYPT_KEY_HANDLE hExportKey, LPCWSTR pszBlobType, NCryptBufferDesc *pParameterList, PBYTE pbOutput, DWORD cbOutput, DWORD *pcbResult, DWORD dwFlags)
     * }
     */
    public static MethodHandle NCryptExportKey$handle() {
        return NCryptExportKey.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * SECURITY_STATUS NCryptExportKey(NCRYPT_KEY_HANDLE hKey, NCRYPT_KEY_HANDLE hExportKey, LPCWSTR pszBlobType, NCryptBufferDesc *pParameterList, PBYTE pbOutput, DWORD cbOutput, DWORD *pcbResult, DWORD dwFlags)
     * }
     */
    public static int NCryptExportKey(long hKey, long hExportKey, MemorySegment pszBlobType, MemorySegment pParameterList, MemorySegment pbOutput, int cbOutput, MemorySegment pcbResult, int dwFlags) {
        var mh$ = NCryptExportKey.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("NCryptExportKey", hKey, hExportKey, pszBlobType, pParameterList, pbOutput, cbOutput, pcbResult, dwFlags);
            }
            return (int)mh$.invokeExact(hKey, hExportKey, pszBlobType, pParameterList, pbOutput, cbOutput, pcbResult, dwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class NCryptSignHash {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_LONG_LONG,
            C_POINTER,
            C_POINTER,
            C_LONG,
            C_POINTER,
            C_LONG,
            C_POINTER,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("NCryptSignHash"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SECURITY_STATUS NCryptSignHash(NCRYPT_KEY_HANDLE hKey, void *pPaddingInfo, PBYTE pbHashValue, DWORD cbHashValue, PBYTE pbSignature, DWORD cbSignature, DWORD *pcbResult, DWORD dwFlags)
     * }
     */
    public static FunctionDescriptor NCryptSignHash$descriptor() {
        return NCryptSignHash.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SECURITY_STATUS NCryptSignHash(NCRYPT_KEY_HANDLE hKey, void *pPaddingInfo, PBYTE pbHashValue, DWORD cbHashValue, PBYTE pbSignature, DWORD cbSignature, DWORD *pcbResult, DWORD dwFlags)
     * }
     */
    public static MethodHandle NCryptSignHash$handle() {
        return NCryptSignHash.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * SECURITY_STATUS NCryptSignHash(NCRYPT_KEY_HANDLE hKey, void *pPaddingInfo, PBYTE pbHashValue, DWORD cbHashValue, PBYTE pbSignature, DWORD cbSignature, DWORD *pcbResult, DWORD dwFlags)
     * }
     */
    public static int NCryptSignHash(long hKey, MemorySegment pPaddingInfo, MemorySegment pbHashValue, int cbHashValue, MemorySegment pbSignature, int cbSignature, MemorySegment pcbResult, int dwFlags) {
        var mh$ = NCryptSignHash.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("NCryptSignHash", hKey, pPaddingInfo, pbHashValue, cbHashValue, pbSignature, cbSignature, pcbResult, dwFlags);
            }
            return (int)mh$.invokeExact(hKey, pPaddingInfo, pbHashValue, cbHashValue, pbSignature, cbSignature, pcbResult, dwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class NCryptVerifySignature {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_LONG_LONG,
            C_POINTER,
            C_POINTER,
            C_LONG,
            C_POINTER,
            C_LONG,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("NCryptVerifySignature"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SECURITY_STATUS NCryptVerifySignature(NCRYPT_KEY_HANDLE hKey, void *pPaddingInfo, PBYTE pbHashValue, DWORD cbHashValue, PBYTE pbSignature, DWORD cbSignature, DWORD dwFlags)
     * }
     */
    public static FunctionDescriptor NCryptVerifySignature$descriptor() {
        return NCryptVerifySignature.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SECURITY_STATUS NCryptVerifySignature(NCRYPT_KEY_HANDLE hKey, void *pPaddingInfo, PBYTE pbHashValue, DWORD cbHashValue, PBYTE pbSignature, DWORD cbSignature, DWORD dwFlags)
     * }
     */
    public static MethodHandle NCryptVerifySignature$handle() {
        return NCryptVerifySignature.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * SECURITY_STATUS NCryptVerifySignature(NCRYPT_KEY_HANDLE hKey, void *pPaddingInfo, PBYTE pbHashValue, DWORD cbHashValue, PBYTE pbSignature, DWORD cbSignature, DWORD dwFlags)
     * }
     */
    public static int NCryptVerifySignature(long hKey, MemorySegment pPaddingInfo, MemorySegment pbHashValue, int cbHashValue, MemorySegment pbSignature, int cbSignature, int dwFlags) {
        var mh$ = NCryptVerifySignature.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("NCryptVerifySignature", hKey, pPaddingInfo, pbHashValue, cbHashValue, pbSignature, cbSignature, dwFlags);
            }
            return (int)mh$.invokeExact(hKey, pPaddingInfo, pbHashValue, cbHashValue, pbSignature, cbSignature, dwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class NCryptDeleteKey {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_LONG_LONG,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("NCryptDeleteKey"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SECURITY_STATUS NCryptDeleteKey(NCRYPT_KEY_HANDLE hKey, DWORD dwFlags)
     * }
     */
    public static FunctionDescriptor NCryptDeleteKey$descriptor() {
        return NCryptDeleteKey.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SECURITY_STATUS NCryptDeleteKey(NCRYPT_KEY_HANDLE hKey, DWORD dwFlags)
     * }
     */
    public static MethodHandle NCryptDeleteKey$handle() {
        return NCryptDeleteKey.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * SECURITY_STATUS NCryptDeleteKey(NCRYPT_KEY_HANDLE hKey, DWORD dwFlags)
     * }
     */
    public static int NCryptDeleteKey(long hKey, int dwFlags) {
        var mh$ = NCryptDeleteKey.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("NCryptDeleteKey", hKey, dwFlags);
            }
            return (int)mh$.invokeExact(hKey, dwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class NCryptFreeObject {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_LONG_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("NCryptFreeObject"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SECURITY_STATUS NCryptFreeObject(NCRYPT_HANDLE hObject)
     * }
     */
    public static FunctionDescriptor NCryptFreeObject$descriptor() {
        return NCryptFreeObject.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SECURITY_STATUS NCryptFreeObject(NCRYPT_HANDLE hObject)
     * }
     */
    public static MethodHandle NCryptFreeObject$handle() {
        return NCryptFreeObject.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * SECURITY_STATUS NCryptFreeObject(NCRYPT_HANDLE hObject)
     * }
     */
    public static int NCryptFreeObject(long hObject) {
        var mh$ = NCryptFreeObject.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("NCryptFreeObject", hObject);
            }
            return (int)mh$.invokeExact(hObject);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class NCryptIsKeyHandle {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_LONG_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("NCryptIsKeyHandle"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL NCryptIsKeyHandle(NCRYPT_KEY_HANDLE hKey)
     * }
     */
    public static FunctionDescriptor NCryptIsKeyHandle$descriptor() {
        return NCryptIsKeyHandle.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL NCryptIsKeyHandle(NCRYPT_KEY_HANDLE hKey)
     * }
     */
    public static MethodHandle NCryptIsKeyHandle$handle() {
        return NCryptIsKeyHandle.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL NCryptIsKeyHandle(NCRYPT_KEY_HANDLE hKey)
     * }
     */
    public static int NCryptIsKeyHandle(long hKey) {
        var mh$ = NCryptIsKeyHandle.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("NCryptIsKeyHandle", hKey);
            }
            return (int)mh$.invokeExact(hKey);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class NCryptTranslateHandle {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_POINTER,
            C_POINTER,
            C_LONG_LONG,
            C_LONG_LONG,
            C_LONG,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("NCryptTranslateHandle"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SECURITY_STATUS NCryptTranslateHandle(NCRYPT_PROV_HANDLE *phProvider, NCRYPT_KEY_HANDLE *phKey, HCRYPTPROV hLegacyProv, HCRYPTKEY hLegacyKey, DWORD dwLegacyKeySpec, DWORD dwFlags)
     * }
     */
    public static FunctionDescriptor NCryptTranslateHandle$descriptor() {
        return NCryptTranslateHandle.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SECURITY_STATUS NCryptTranslateHandle(NCRYPT_PROV_HANDLE *phProvider, NCRYPT_KEY_HANDLE *phKey, HCRYPTPROV hLegacyProv, HCRYPTKEY hLegacyKey, DWORD dwLegacyKeySpec, DWORD dwFlags)
     * }
     */
    public static MethodHandle NCryptTranslateHandle$handle() {
        return NCryptTranslateHandle.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * SECURITY_STATUS NCryptTranslateHandle(NCRYPT_PROV_HANDLE *phProvider, NCRYPT_KEY_HANDLE *phKey, HCRYPTPROV hLegacyProv, HCRYPTKEY hLegacyKey, DWORD dwLegacyKeySpec, DWORD dwFlags)
     * }
     */
    public static int NCryptTranslateHandle(MemorySegment phProvider, MemorySegment phKey, long hLegacyProv, long hLegacyKey, int dwLegacyKeySpec, int dwFlags) {
        var mh$ = NCryptTranslateHandle.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("NCryptTranslateHandle", phProvider, phKey, hLegacyProv, hLegacyKey, dwLegacyKeySpec, dwFlags);
            }
            return (int)mh$.invokeExact(phProvider, phKey, hLegacyProv, hLegacyKey, dwLegacyKeySpec, dwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class NCryptNotifyChangeKey {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_LONG_LONG,
            C_POINTER,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("NCryptNotifyChangeKey"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SECURITY_STATUS NCryptNotifyChangeKey(NCRYPT_PROV_HANDLE hProvider, HANDLE *phEvent, DWORD dwFlags)
     * }
     */
    public static FunctionDescriptor NCryptNotifyChangeKey$descriptor() {
        return NCryptNotifyChangeKey.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SECURITY_STATUS NCryptNotifyChangeKey(NCRYPT_PROV_HANDLE hProvider, HANDLE *phEvent, DWORD dwFlags)
     * }
     */
    public static MethodHandle NCryptNotifyChangeKey$handle() {
        return NCryptNotifyChangeKey.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * SECURITY_STATUS NCryptNotifyChangeKey(NCRYPT_PROV_HANDLE hProvider, HANDLE *phEvent, DWORD dwFlags)
     * }
     */
    public static int NCryptNotifyChangeKey(long hProvider, MemorySegment phEvent, int dwFlags) {
        var mh$ = NCryptNotifyChangeKey.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("NCryptNotifyChangeKey", hProvider, phEvent, dwFlags);
            }
            return (int)mh$.invokeExact(hProvider, phEvent, dwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class NCryptSecretAgreement {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_LONG_LONG,
            C_LONG_LONG,
            C_POINTER,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("NCryptSecretAgreement"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SECURITY_STATUS NCryptSecretAgreement(NCRYPT_KEY_HANDLE hPrivKey, NCRYPT_KEY_HANDLE hPubKey, NCRYPT_SECRET_HANDLE *phAgreedSecret, DWORD dwFlags)
     * }
     */
    public static FunctionDescriptor NCryptSecretAgreement$descriptor() {
        return NCryptSecretAgreement.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SECURITY_STATUS NCryptSecretAgreement(NCRYPT_KEY_HANDLE hPrivKey, NCRYPT_KEY_HANDLE hPubKey, NCRYPT_SECRET_HANDLE *phAgreedSecret, DWORD dwFlags)
     * }
     */
    public static MethodHandle NCryptSecretAgreement$handle() {
        return NCryptSecretAgreement.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * SECURITY_STATUS NCryptSecretAgreement(NCRYPT_KEY_HANDLE hPrivKey, NCRYPT_KEY_HANDLE hPubKey, NCRYPT_SECRET_HANDLE *phAgreedSecret, DWORD dwFlags)
     * }
     */
    public static int NCryptSecretAgreement(long hPrivKey, long hPubKey, MemorySegment phAgreedSecret, int dwFlags) {
        var mh$ = NCryptSecretAgreement.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("NCryptSecretAgreement", hPrivKey, hPubKey, phAgreedSecret, dwFlags);
            }
            return (int)mh$.invokeExact(hPrivKey, hPubKey, phAgreedSecret, dwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class NCryptDeriveKey {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_LONG_LONG,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_LONG,
            C_POINTER,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("NCryptDeriveKey"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SECURITY_STATUS NCryptDeriveKey(NCRYPT_SECRET_HANDLE hSharedSecret, LPCWSTR pwszKDF, NCryptBufferDesc *pParameterList, PBYTE pbDerivedKey, DWORD cbDerivedKey, DWORD *pcbResult, ULONG dwFlags)
     * }
     */
    public static FunctionDescriptor NCryptDeriveKey$descriptor() {
        return NCryptDeriveKey.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SECURITY_STATUS NCryptDeriveKey(NCRYPT_SECRET_HANDLE hSharedSecret, LPCWSTR pwszKDF, NCryptBufferDesc *pParameterList, PBYTE pbDerivedKey, DWORD cbDerivedKey, DWORD *pcbResult, ULONG dwFlags)
     * }
     */
    public static MethodHandle NCryptDeriveKey$handle() {
        return NCryptDeriveKey.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * SECURITY_STATUS NCryptDeriveKey(NCRYPT_SECRET_HANDLE hSharedSecret, LPCWSTR pwszKDF, NCryptBufferDesc *pParameterList, PBYTE pbDerivedKey, DWORD cbDerivedKey, DWORD *pcbResult, ULONG dwFlags)
     * }
     */
    public static int NCryptDeriveKey(long hSharedSecret, MemorySegment pwszKDF, MemorySegment pParameterList, MemorySegment pbDerivedKey, int cbDerivedKey, MemorySegment pcbResult, int dwFlags) {
        var mh$ = NCryptDeriveKey.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("NCryptDeriveKey", hSharedSecret, pwszKDF, pParameterList, pbDerivedKey, cbDerivedKey, pcbResult, dwFlags);
            }
            return (int)mh$.invokeExact(hSharedSecret, pwszKDF, pParameterList, pbDerivedKey, cbDerivedKey, pcbResult, dwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class NCryptKeyDerivation {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_LONG_LONG,
            C_POINTER,
            C_POINTER,
            C_LONG,
            C_POINTER,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("NCryptKeyDerivation"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SECURITY_STATUS NCryptKeyDerivation(NCRYPT_KEY_HANDLE hKey, NCryptBufferDesc *pParameterList, PUCHAR pbDerivedKey, DWORD cbDerivedKey, DWORD *pcbResult, ULONG dwFlags)
     * }
     */
    public static FunctionDescriptor NCryptKeyDerivation$descriptor() {
        return NCryptKeyDerivation.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SECURITY_STATUS NCryptKeyDerivation(NCRYPT_KEY_HANDLE hKey, NCryptBufferDesc *pParameterList, PUCHAR pbDerivedKey, DWORD cbDerivedKey, DWORD *pcbResult, ULONG dwFlags)
     * }
     */
    public static MethodHandle NCryptKeyDerivation$handle() {
        return NCryptKeyDerivation.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * SECURITY_STATUS NCryptKeyDerivation(NCRYPT_KEY_HANDLE hKey, NCryptBufferDesc *pParameterList, PUCHAR pbDerivedKey, DWORD cbDerivedKey, DWORD *pcbResult, ULONG dwFlags)
     * }
     */
    public static int NCryptKeyDerivation(long hKey, MemorySegment pParameterList, MemorySegment pbDerivedKey, int cbDerivedKey, MemorySegment pcbResult, int dwFlags) {
        var mh$ = NCryptKeyDerivation.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("NCryptKeyDerivation", hKey, pParameterList, pbDerivedKey, cbDerivedKey, pcbResult, dwFlags);
            }
            return (int)mh$.invokeExact(hKey, pParameterList, pbDerivedKey, cbDerivedKey, pcbResult, dwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class NCryptCreateClaim {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_LONG_LONG,
            C_LONG_LONG,
            C_LONG,
            C_POINTER,
            C_POINTER,
            C_LONG,
            C_POINTER,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("NCryptCreateClaim"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SECURITY_STATUS NCryptCreateClaim(NCRYPT_KEY_HANDLE hSubjectKey, NCRYPT_KEY_HANDLE hAuthorityKey, DWORD dwClaimType, NCryptBufferDesc *pParameterList, PBYTE pbClaimBlob, DWORD cbClaimBlob, DWORD *pcbResult, DWORD dwFlags)
     * }
     */
    public static FunctionDescriptor NCryptCreateClaim$descriptor() {
        return NCryptCreateClaim.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SECURITY_STATUS NCryptCreateClaim(NCRYPT_KEY_HANDLE hSubjectKey, NCRYPT_KEY_HANDLE hAuthorityKey, DWORD dwClaimType, NCryptBufferDesc *pParameterList, PBYTE pbClaimBlob, DWORD cbClaimBlob, DWORD *pcbResult, DWORD dwFlags)
     * }
     */
    public static MethodHandle NCryptCreateClaim$handle() {
        return NCryptCreateClaim.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * SECURITY_STATUS NCryptCreateClaim(NCRYPT_KEY_HANDLE hSubjectKey, NCRYPT_KEY_HANDLE hAuthorityKey, DWORD dwClaimType, NCryptBufferDesc *pParameterList, PBYTE pbClaimBlob, DWORD cbClaimBlob, DWORD *pcbResult, DWORD dwFlags)
     * }
     */
    public static int NCryptCreateClaim(long hSubjectKey, long hAuthorityKey, int dwClaimType, MemorySegment pParameterList, MemorySegment pbClaimBlob, int cbClaimBlob, MemorySegment pcbResult, int dwFlags) {
        var mh$ = NCryptCreateClaim.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("NCryptCreateClaim", hSubjectKey, hAuthorityKey, dwClaimType, pParameterList, pbClaimBlob, cbClaimBlob, pcbResult, dwFlags);
            }
            return (int)mh$.invokeExact(hSubjectKey, hAuthorityKey, dwClaimType, pParameterList, pbClaimBlob, cbClaimBlob, pcbResult, dwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class NCryptVerifyClaim {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_LONG_LONG,
            C_LONG_LONG,
            C_LONG,
            C_POINTER,
            C_POINTER,
            C_LONG,
            C_POINTER,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("NCryptVerifyClaim"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SECURITY_STATUS NCryptVerifyClaim(NCRYPT_KEY_HANDLE hSubjectKey, NCRYPT_KEY_HANDLE hAuthorityKey, DWORD dwClaimType, NCryptBufferDesc *pParameterList, PBYTE pbClaimBlob, DWORD cbClaimBlob, NCryptBufferDesc *pOutput, DWORD dwFlags)
     * }
     */
    public static FunctionDescriptor NCryptVerifyClaim$descriptor() {
        return NCryptVerifyClaim.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SECURITY_STATUS NCryptVerifyClaim(NCRYPT_KEY_HANDLE hSubjectKey, NCRYPT_KEY_HANDLE hAuthorityKey, DWORD dwClaimType, NCryptBufferDesc *pParameterList, PBYTE pbClaimBlob, DWORD cbClaimBlob, NCryptBufferDesc *pOutput, DWORD dwFlags)
     * }
     */
    public static MethodHandle NCryptVerifyClaim$handle() {
        return NCryptVerifyClaim.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * SECURITY_STATUS NCryptVerifyClaim(NCRYPT_KEY_HANDLE hSubjectKey, NCRYPT_KEY_HANDLE hAuthorityKey, DWORD dwClaimType, NCryptBufferDesc *pParameterList, PBYTE pbClaimBlob, DWORD cbClaimBlob, NCryptBufferDesc *pOutput, DWORD dwFlags)
     * }
     */
    public static int NCryptVerifyClaim(long hSubjectKey, long hAuthorityKey, int dwClaimType, MemorySegment pParameterList, MemorySegment pbClaimBlob, int cbClaimBlob, MemorySegment pOutput, int dwFlags) {
        var mh$ = NCryptVerifyClaim.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("NCryptVerifyClaim", hSubjectKey, hAuthorityKey, dwClaimType, pParameterList, pbClaimBlob, cbClaimBlob, pOutput, dwFlags);
            }
            return (int)mh$.invokeExact(hSubjectKey, hAuthorityKey, dwClaimType, pParameterList, pbClaimBlob, cbClaimBlob, pOutput, dwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef ULONG_PTR HCRYPTPROV_OR_NCRYPT_KEY_HANDLE
     * }
     */
    public static final OfLong HCRYPTPROV_OR_NCRYPT_KEY_HANDLE = C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef ULONG_PTR HCRYPTPROV_LEGACY
     * }
     */
    public static final OfLong HCRYPTPROV_LEGACY = C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef struct _CRYPT_BIT_BLOB {
     *     DWORD cbData;
     *     BYTE *pbData;
     *     DWORD cUnusedBits;
     * } *PCRYPT_BIT_BLOB
     * }
     */
    public static final AddressLayout PCRYPT_BIT_BLOB = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CRYPT_ALGORITHM_IDENTIFIER {
     *     LPSTR pszObjId;
     *     CRYPT_OBJID_BLOB Parameters;
     * } *PCRYPT_ALGORITHM_IDENTIFIER
     * }
     */
    public static final AddressLayout PCRYPT_ALGORITHM_IDENTIFIER = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CRYPT_OBJID_TABLE {
     *     DWORD dwAlgId;
     *     LPCSTR pszObjId;
     * } *PCRYPT_OBJID_TABLE
     * }
     */
    public static final AddressLayout PCRYPT_OBJID_TABLE = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CRYPT_HASH_INFO {
     *     CRYPT_ALGORITHM_IDENTIFIER HashAlgorithm;
     *     CRYPT_HASH_BLOB Hash;
     * } *PCRYPT_HASH_INFO
     * }
     */
    public static final AddressLayout PCRYPT_HASH_INFO = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CERT_EXTENSION {
     *     LPSTR pszObjId;
     *     BOOL fCritical;
     *     CRYPT_OBJID_BLOB Value;
     * } *PCERT_EXTENSION
     * }
     */
    public static final AddressLayout PCERT_EXTENSION = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef const CERT_EXTENSION *PCCERT_EXTENSION
     * }
     */
    public static final AddressLayout PCCERT_EXTENSION = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CRYPT_ATTRIBUTE_TYPE_VALUE {
     *     LPSTR pszObjId;
     *     CRYPT_OBJID_BLOB Value;
     * } *PCRYPT_ATTRIBUTE_TYPE_VALUE
     * }
     */
    public static final AddressLayout PCRYPT_ATTRIBUTE_TYPE_VALUE = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CRYPT_ATTRIBUTE {
     *     LPSTR pszObjId;
     *     DWORD cValue;
     *     PCRYPT_ATTR_BLOB rgValue;
     * } *PCRYPT_ATTRIBUTE
     * }
     */
    public static final AddressLayout PCRYPT_ATTRIBUTE = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CRYPT_ATTRIBUTES {
     *     DWORD cAttr;
     *     PCRYPT_ATTRIBUTE rgAttr;
     * } *PCRYPT_ATTRIBUTES
     * }
     */
    public static final AddressLayout PCRYPT_ATTRIBUTES = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CERT_RDN_ATTR {
     *     LPSTR pszObjId;
     *     DWORD dwValueType;
     *     CERT_RDN_VALUE_BLOB Value;
     * } *PCERT_RDN_ATTR
     * }
     */
    public static final AddressLayout PCERT_RDN_ATTR = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CERT_RDN {
     *     DWORD cRDNAttr;
     *     PCERT_RDN_ATTR rgRDNAttr;
     * } *PCERT_RDN
     * }
     */
    public static final AddressLayout PCERT_RDN = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CERT_NAME_INFO {
     *     DWORD cRDN;
     *     PCERT_RDN rgRDN;
     * } *PCERT_NAME_INFO
     * }
     */
    public static final AddressLayout PCERT_NAME_INFO = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CERT_NAME_VALUE {
     *     DWORD dwValueType;
     *     CERT_RDN_VALUE_BLOB Value;
     * } *PCERT_NAME_VALUE
     * }
     */
    public static final AddressLayout PCERT_NAME_VALUE = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CERT_PUBLIC_KEY_INFO {
     *     CRYPT_ALGORITHM_IDENTIFIER Algorithm;
     *     CRYPT_BIT_BLOB PublicKey;
     * } *PCERT_PUBLIC_KEY_INFO
     * }
     */
    public static final AddressLayout PCERT_PUBLIC_KEY_INFO = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CRYPT_ECC_PRIVATE_KEY_INFO {
     *     DWORD dwVersion;
     *     CRYPT_DER_BLOB PrivateKey;
     *     LPSTR szCurveOid;
     *     CRYPT_BIT_BLOB PublicKey;
     * } *PCRYPT_ECC_PRIVATE_KEY_INFO
     * }
     */
    public static final AddressLayout PCRYPT_ECC_PRIVATE_KEY_INFO = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CRYPT_PRIVATE_KEY_INFO {
     *     DWORD Version;
     *     CRYPT_ALGORITHM_IDENTIFIER Algorithm;
     *     CRYPT_DER_BLOB PrivateKey;
     *     PCRYPT_ATTRIBUTES pAttributes;
     * } *PCRYPT_PRIVATE_KEY_INFO
     * }
     */
    public static final AddressLayout PCRYPT_PRIVATE_KEY_INFO = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CRYPT_ENCRYPTED_PRIVATE_KEY_INFO {
     *     CRYPT_ALGORITHM_IDENTIFIER EncryptionAlgorithm;
     *     CRYPT_DATA_BLOB EncryptedPrivateKey;
     * } *PCRYPT_ENCRYPTED_PRIVATE_KEY_INFO
     * }
     */
    public static final AddressLayout PCRYPT_ENCRYPTED_PRIVATE_KEY_INFO = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CRYPT_PKCS8_IMPORT_PARAMS {
     *     CRYPT_DIGEST_BLOB PrivateKey;
     *     PCRYPT_RESOLVE_HCRYPTPROV_FUNC pResolvehCryptProvFunc;
     *     LPVOID pVoidResolveFunc;
     *     PCRYPT_DECRYPT_PRIVATE_KEY_FUNC pDecryptPrivateKeyFunc;
     *     LPVOID pVoidDecryptFunc;
     * } *PCRYPT_PKCS8_IMPORT_PARAMS
     * }
     */
    public static final AddressLayout PCRYPT_PKCS8_IMPORT_PARAMS = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CRYPT_PKCS8_IMPORT_PARAMS {
     *     CRYPT_DIGEST_BLOB PrivateKey;
     *     PCRYPT_RESOLVE_HCRYPTPROV_FUNC pResolvehCryptProvFunc;
     *     LPVOID pVoidResolveFunc;
     *     PCRYPT_DECRYPT_PRIVATE_KEY_FUNC pDecryptPrivateKeyFunc;
     *     LPVOID pVoidDecryptFunc;
     * } *PCRYPT_PRIVATE_KEY_BLOB_AND_PARAMS
     * }
     */
    public static final AddressLayout PCRYPT_PRIVATE_KEY_BLOB_AND_PARAMS = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CRYPT_PKCS8_EXPORT_PARAMS {
     *     HCRYPTPROV hCryptProv;
     *     DWORD dwKeySpec;
     *     LPSTR pszPrivateKeyObjId;
     *     PCRYPT_ENCRYPT_PRIVATE_KEY_FUNC pEncryptPrivateKeyFunc;
     *     LPVOID pVoidEncryptFunc;
     * } *PCRYPT_PKCS8_EXPORT_PARAMS
     * }
     */
    public static final AddressLayout PCRYPT_PKCS8_EXPORT_PARAMS = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CERT_INFO {
     *     DWORD dwVersion;
     *     CRYPT_INTEGER_BLOB SerialNumber;
     *     CRYPT_ALGORITHM_IDENTIFIER SignatureAlgorithm;
     *     CERT_NAME_BLOB Issuer;
     *     FILETIME NotBefore;
     *     FILETIME NotAfter;
     *     CERT_NAME_BLOB Subject;
     *     CERT_PUBLIC_KEY_INFO SubjectPublicKeyInfo;
     *     CRYPT_BIT_BLOB IssuerUniqueId;
     *     CRYPT_BIT_BLOB SubjectUniqueId;
     *     DWORD cExtension;
     *     PCERT_EXTENSION rgExtension;
     * } *PCERT_INFO
     * }
     */
    public static final AddressLayout PCERT_INFO = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CRL_ENTRY {
     *     CRYPT_INTEGER_BLOB SerialNumber;
     *     FILETIME RevocationDate;
     *     DWORD cExtension;
     *     PCERT_EXTENSION rgExtension;
     * } *PCRL_ENTRY
     * }
     */
    public static final AddressLayout PCRL_ENTRY = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CRL_INFO {
     *     DWORD dwVersion;
     *     CRYPT_ALGORITHM_IDENTIFIER SignatureAlgorithm;
     *     CERT_NAME_BLOB Issuer;
     *     FILETIME ThisUpdate;
     *     FILETIME NextUpdate;
     *     DWORD cCRLEntry;
     *     PCRL_ENTRY rgCRLEntry;
     *     DWORD cExtension;
     *     PCERT_EXTENSION rgExtension;
     * } *PCRL_INFO
     * }
     */
    public static final AddressLayout PCRL_INFO = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CERT_OR_CRL_BLOB {
     *     DWORD dwChoice;
     *     DWORD cbEncoded;
     *     BYTE *pbEncoded;
     * } *PCERT_OR_CRL_BLOB
     * }
     */
    public static final AddressLayout PCERT_OR_CRL_BLOB = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CERT_OR_CRL_BUNDLE {
     *     DWORD cItem;
     *     PCERT_OR_CRL_BLOB rgItem;
     * } *PCERT_OR_CRL_BUNDLE
     * }
     */
    public static final AddressLayout PCERT_OR_CRL_BUNDLE = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CERT_REQUEST_INFO {
     *     DWORD dwVersion;
     *     CERT_NAME_BLOB Subject;
     *     CERT_PUBLIC_KEY_INFO SubjectPublicKeyInfo;
     *     DWORD cAttribute;
     *     PCRYPT_ATTRIBUTE rgAttribute;
     * } *PCERT_REQUEST_INFO
     * }
     */
    public static final AddressLayout PCERT_REQUEST_INFO = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CERT_KEYGEN_REQUEST_INFO {
     *     DWORD dwVersion;
     *     CERT_PUBLIC_KEY_INFO SubjectPublicKeyInfo;
     *     LPWSTR pwszChallengeString;
     * } *PCERT_KEYGEN_REQUEST_INFO
     * }
     */
    public static final AddressLayout PCERT_KEYGEN_REQUEST_INFO = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CERT_SIGNED_CONTENT_INFO {
     *     CRYPT_DER_BLOB ToBeSigned;
     *     CRYPT_ALGORITHM_IDENTIFIER SignatureAlgorithm;
     *     CRYPT_BIT_BLOB Signature;
     * } *PCERT_SIGNED_CONTENT_INFO
     * }
     */
    public static final AddressLayout PCERT_SIGNED_CONTENT_INFO = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CTL_USAGE {
     *     DWORD cUsageIdentifier;
     *     LPSTR *rgpszUsageIdentifier;
     * } *PCTL_USAGE
     * }
     */
    public static final AddressLayout PCTL_USAGE = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CTL_USAGE {
     *     DWORD cUsageIdentifier;
     *     LPSTR *rgpszUsageIdentifier;
     * } *PCERT_ENHKEY_USAGE
     * }
     */
    public static final AddressLayout PCERT_ENHKEY_USAGE = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef const CTL_USAGE *PCCTL_USAGE
     * }
     */
    public static final AddressLayout PCCTL_USAGE = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef const CERT_ENHKEY_USAGE *PCCERT_ENHKEY_USAGE
     * }
     */
    public static final AddressLayout PCCERT_ENHKEY_USAGE = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CTL_ENTRY {
     *     CRYPT_DATA_BLOB SubjectIdentifier;
     *     DWORD cAttribute;
     *     PCRYPT_ATTRIBUTE rgAttribute;
     * } *PCTL_ENTRY
     * }
     */
    public static final AddressLayout PCTL_ENTRY = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CTL_INFO {
     *     DWORD dwVersion;
     *     CTL_USAGE SubjectUsage;
     *     CRYPT_DATA_BLOB ListIdentifier;
     *     CRYPT_INTEGER_BLOB SequenceNumber;
     *     FILETIME ThisUpdate;
     *     FILETIME NextUpdate;
     *     CRYPT_ALGORITHM_IDENTIFIER SubjectAlgorithm;
     *     DWORD cCTLEntry;
     *     PCTL_ENTRY rgCTLEntry;
     *     DWORD cExtension;
     *     PCERT_EXTENSION rgExtension;
     * } *PCTL_INFO
     * }
     */
    public static final AddressLayout PCTL_INFO = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CRYPT_TIME_STAMP_REQUEST_INFO {
     *     LPSTR pszTimeStampAlgorithm;
     *     LPSTR pszContentType;
     *     CRYPT_OBJID_BLOB Content;
     *     DWORD cAttribute;
     *     PCRYPT_ATTRIBUTE rgAttribute;
     * } *PCRYPT_TIME_STAMP_REQUEST_INFO
     * }
     */
    public static final AddressLayout PCRYPT_TIME_STAMP_REQUEST_INFO = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CRYPT_ENROLLMENT_NAME_VALUE_PAIR {
     *     LPWSTR pwszName;
     *     LPWSTR pwszValue;
     * } *PCRYPT_ENROLLMENT_NAME_VALUE_PAIR
     * }
     */
    public static final AddressLayout PCRYPT_ENROLLMENT_NAME_VALUE_PAIR = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CRYPT_CSP_PROVIDER {
     *     DWORD dwKeySpec;
     *     LPWSTR pwszProviderName;
     *     CRYPT_BIT_BLOB Signature;
     * } *PCRYPT_CSP_PROVIDER
     * }
     */
    public static final AddressLayout PCRYPT_CSP_PROVIDER = C_POINTER;

    private static class CryptFormatObject {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_LONG,
            C_LONG,
            C_LONG,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_LONG,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CryptFormatObject"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CryptFormatObject(DWORD dwCertEncodingType, DWORD dwFormatType, DWORD dwFormatStrType, void *pFormatStruct, LPCSTR lpszStructType, const BYTE *pbEncoded, DWORD cbEncoded, void *pbFormat, DWORD *pcbFormat)
     * }
     */
    public static FunctionDescriptor CryptFormatObject$descriptor() {
        return CryptFormatObject.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CryptFormatObject(DWORD dwCertEncodingType, DWORD dwFormatType, DWORD dwFormatStrType, void *pFormatStruct, LPCSTR lpszStructType, const BYTE *pbEncoded, DWORD cbEncoded, void *pbFormat, DWORD *pcbFormat)
     * }
     */
    public static MethodHandle CryptFormatObject$handle() {
        return CryptFormatObject.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL CryptFormatObject(DWORD dwCertEncodingType, DWORD dwFormatType, DWORD dwFormatStrType, void *pFormatStruct, LPCSTR lpszStructType, const BYTE *pbEncoded, DWORD cbEncoded, void *pbFormat, DWORD *pcbFormat)
     * }
     */
    public static int CryptFormatObject(int dwCertEncodingType, int dwFormatType, int dwFormatStrType, MemorySegment pFormatStruct, MemorySegment lpszStructType, MemorySegment pbEncoded, int cbEncoded, MemorySegment pbFormat, MemorySegment pcbFormat) {
        var mh$ = CryptFormatObject.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CryptFormatObject", dwCertEncodingType, dwFormatType, dwFormatStrType, pFormatStruct, lpszStructType, pbEncoded, cbEncoded, pbFormat, pcbFormat);
            }
            return (int)mh$.invokeExact(dwCertEncodingType, dwFormatType, dwFormatStrType, pFormatStruct, lpszStructType, pbEncoded, cbEncoded, pbFormat, pcbFormat);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct _CRYPT_ENCODE_PARA {
     *     DWORD cbSize;
     *     PFN_CRYPT_ALLOC pfnAlloc;
     *     PFN_CRYPT_FREE pfnFree;
     * } *PCRYPT_ENCODE_PARA
     * }
     */
    public static final AddressLayout PCRYPT_ENCODE_PARA = C_POINTER;

    private static class CryptEncodeObjectEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_LONG,
            C_POINTER,
            C_POINTER,
            C_LONG,
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CryptEncodeObjectEx"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CryptEncodeObjectEx(DWORD dwCertEncodingType, LPCSTR lpszStructType, const void *pvStructInfo, DWORD dwFlags, PCRYPT_ENCODE_PARA pEncodePara, void *pvEncoded, DWORD *pcbEncoded)
     * }
     */
    public static FunctionDescriptor CryptEncodeObjectEx$descriptor() {
        return CryptEncodeObjectEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CryptEncodeObjectEx(DWORD dwCertEncodingType, LPCSTR lpszStructType, const void *pvStructInfo, DWORD dwFlags, PCRYPT_ENCODE_PARA pEncodePara, void *pvEncoded, DWORD *pcbEncoded)
     * }
     */
    public static MethodHandle CryptEncodeObjectEx$handle() {
        return CryptEncodeObjectEx.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL CryptEncodeObjectEx(DWORD dwCertEncodingType, LPCSTR lpszStructType, const void *pvStructInfo, DWORD dwFlags, PCRYPT_ENCODE_PARA pEncodePara, void *pvEncoded, DWORD *pcbEncoded)
     * }
     */
    public static int CryptEncodeObjectEx(int dwCertEncodingType, MemorySegment lpszStructType, MemorySegment pvStructInfo, int dwFlags, MemorySegment pEncodePara, MemorySegment pvEncoded, MemorySegment pcbEncoded) {
        var mh$ = CryptEncodeObjectEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CryptEncodeObjectEx", dwCertEncodingType, lpszStructType, pvStructInfo, dwFlags, pEncodePara, pvEncoded, pcbEncoded);
            }
            return (int)mh$.invokeExact(dwCertEncodingType, lpszStructType, pvStructInfo, dwFlags, pEncodePara, pvEncoded, pcbEncoded);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CryptEncodeObject {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_LONG,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CryptEncodeObject"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CryptEncodeObject(DWORD dwCertEncodingType, LPCSTR lpszStructType, const void *pvStructInfo, BYTE *pbEncoded, DWORD *pcbEncoded)
     * }
     */
    public static FunctionDescriptor CryptEncodeObject$descriptor() {
        return CryptEncodeObject.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CryptEncodeObject(DWORD dwCertEncodingType, LPCSTR lpszStructType, const void *pvStructInfo, BYTE *pbEncoded, DWORD *pcbEncoded)
     * }
     */
    public static MethodHandle CryptEncodeObject$handle() {
        return CryptEncodeObject.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL CryptEncodeObject(DWORD dwCertEncodingType, LPCSTR lpszStructType, const void *pvStructInfo, BYTE *pbEncoded, DWORD *pcbEncoded)
     * }
     */
    public static int CryptEncodeObject(int dwCertEncodingType, MemorySegment lpszStructType, MemorySegment pvStructInfo, MemorySegment pbEncoded, MemorySegment pcbEncoded) {
        var mh$ = CryptEncodeObject.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CryptEncodeObject", dwCertEncodingType, lpszStructType, pvStructInfo, pbEncoded, pcbEncoded);
            }
            return (int)mh$.invokeExact(dwCertEncodingType, lpszStructType, pvStructInfo, pbEncoded, pcbEncoded);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct _CRYPT_DECODE_PARA {
     *     DWORD cbSize;
     *     PFN_CRYPT_ALLOC pfnAlloc;
     *     PFN_CRYPT_FREE pfnFree;
     * } *PCRYPT_DECODE_PARA
     * }
     */
    public static final AddressLayout PCRYPT_DECODE_PARA = C_POINTER;

    private static class CryptDecodeObjectEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_LONG,
            C_POINTER,
            C_POINTER,
            C_LONG,
            C_LONG,
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CryptDecodeObjectEx"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CryptDecodeObjectEx(DWORD dwCertEncodingType, LPCSTR lpszStructType, const BYTE *pbEncoded, DWORD cbEncoded, DWORD dwFlags, PCRYPT_DECODE_PARA pDecodePara, void *pvStructInfo, DWORD *pcbStructInfo)
     * }
     */
    public static FunctionDescriptor CryptDecodeObjectEx$descriptor() {
        return CryptDecodeObjectEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CryptDecodeObjectEx(DWORD dwCertEncodingType, LPCSTR lpszStructType, const BYTE *pbEncoded, DWORD cbEncoded, DWORD dwFlags, PCRYPT_DECODE_PARA pDecodePara, void *pvStructInfo, DWORD *pcbStructInfo)
     * }
     */
    public static MethodHandle CryptDecodeObjectEx$handle() {
        return CryptDecodeObjectEx.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL CryptDecodeObjectEx(DWORD dwCertEncodingType, LPCSTR lpszStructType, const BYTE *pbEncoded, DWORD cbEncoded, DWORD dwFlags, PCRYPT_DECODE_PARA pDecodePara, void *pvStructInfo, DWORD *pcbStructInfo)
     * }
     */
    public static int CryptDecodeObjectEx(int dwCertEncodingType, MemorySegment lpszStructType, MemorySegment pbEncoded, int cbEncoded, int dwFlags, MemorySegment pDecodePara, MemorySegment pvStructInfo, MemorySegment pcbStructInfo) {
        var mh$ = CryptDecodeObjectEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CryptDecodeObjectEx", dwCertEncodingType, lpszStructType, pbEncoded, cbEncoded, dwFlags, pDecodePara, pvStructInfo, pcbStructInfo);
            }
            return (int)mh$.invokeExact(dwCertEncodingType, lpszStructType, pbEncoded, cbEncoded, dwFlags, pDecodePara, pvStructInfo, pcbStructInfo);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CryptDecodeObject {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_LONG,
            C_POINTER,
            C_POINTER,
            C_LONG,
            C_LONG,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CryptDecodeObject"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CryptDecodeObject(DWORD dwCertEncodingType, LPCSTR lpszStructType, const BYTE *pbEncoded, DWORD cbEncoded, DWORD dwFlags, void *pvStructInfo, DWORD *pcbStructInfo)
     * }
     */
    public static FunctionDescriptor CryptDecodeObject$descriptor() {
        return CryptDecodeObject.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CryptDecodeObject(DWORD dwCertEncodingType, LPCSTR lpszStructType, const BYTE *pbEncoded, DWORD cbEncoded, DWORD dwFlags, void *pvStructInfo, DWORD *pcbStructInfo)
     * }
     */
    public static MethodHandle CryptDecodeObject$handle() {
        return CryptDecodeObject.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL CryptDecodeObject(DWORD dwCertEncodingType, LPCSTR lpszStructType, const BYTE *pbEncoded, DWORD cbEncoded, DWORD dwFlags, void *pvStructInfo, DWORD *pcbStructInfo)
     * }
     */
    public static int CryptDecodeObject(int dwCertEncodingType, MemorySegment lpszStructType, MemorySegment pbEncoded, int cbEncoded, int dwFlags, MemorySegment pvStructInfo, MemorySegment pcbStructInfo) {
        var mh$ = CryptDecodeObject.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CryptDecodeObject", dwCertEncodingType, lpszStructType, pbEncoded, cbEncoded, dwFlags, pvStructInfo, pcbStructInfo);
            }
            return (int)mh$.invokeExact(dwCertEncodingType, lpszStructType, pbEncoded, cbEncoded, dwFlags, pvStructInfo, pcbStructInfo);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct _CERT_EXTENSIONS {
     *     DWORD cExtension;
     *     PCERT_EXTENSION rgExtension;
     * } *PCERT_EXTENSIONS
     * }
     */
    public static final AddressLayout PCERT_EXTENSIONS = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CERT_AUTHORITY_KEY_ID_INFO {
     *     CRYPT_DATA_BLOB KeyId;
     *     CERT_NAME_BLOB CertIssuer;
     *     CRYPT_INTEGER_BLOB CertSerialNumber;
     * } *PCERT_AUTHORITY_KEY_ID_INFO
     * }
     */
    public static final AddressLayout PCERT_AUTHORITY_KEY_ID_INFO = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CERT_PRIVATE_KEY_VALIDITY {
     *     FILETIME NotBefore;
     *     FILETIME NotAfter;
     * } *PCERT_PRIVATE_KEY_VALIDITY
     * }
     */
    public static final AddressLayout PCERT_PRIVATE_KEY_VALIDITY = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CERT_KEY_ATTRIBUTES_INFO {
     *     CRYPT_DATA_BLOB KeyId;
     *     CRYPT_BIT_BLOB IntendedKeyUsage;
     *     PCERT_PRIVATE_KEY_VALIDITY pPrivateKeyUsagePeriod;
     * } *PCERT_KEY_ATTRIBUTES_INFO
     * }
     */
    public static final AddressLayout PCERT_KEY_ATTRIBUTES_INFO = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CERT_POLICY_ID {
     *     DWORD cCertPolicyElementId;
     *     LPSTR *rgpszCertPolicyElementId;
     * } *PCERT_POLICY_ID
     * }
     */
    public static final AddressLayout PCERT_POLICY_ID = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CERT_KEY_USAGE_RESTRICTION_INFO {
     *     DWORD cCertPolicyId;
     *     PCERT_POLICY_ID rgCertPolicyId;
     *     CRYPT_BIT_BLOB RestrictedKeyUsage;
     * } *PCERT_KEY_USAGE_RESTRICTION_INFO
     * }
     */
    public static final AddressLayout PCERT_KEY_USAGE_RESTRICTION_INFO = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CERT_OTHER_NAME {
     *     LPSTR pszObjId;
     *     CRYPT_OBJID_BLOB Value;
     * } *PCERT_OTHER_NAME
     * }
     */
    public static final AddressLayout PCERT_OTHER_NAME = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CERT_ALT_NAME_ENTRY {
     *     DWORD dwAltNameChoice;
     *     union {
     *         PCERT_OTHER_NAME pOtherName;
     *         LPWSTR pwszRfc822Name;
     *         LPWSTR pwszDNSName;
     *         CERT_NAME_BLOB DirectoryName;
     *         LPWSTR pwszURL;
     *         CRYPT_DATA_BLOB IPAddress;
     *         LPSTR pszRegisteredID;
     *     };
     * } *PCERT_ALT_NAME_ENTRY
     * }
     */
    public static final AddressLayout PCERT_ALT_NAME_ENTRY = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CERT_ALT_NAME_INFO {
     *     DWORD cAltEntry;
     *     PCERT_ALT_NAME_ENTRY rgAltEntry;
     * } *PCERT_ALT_NAME_INFO
     * }
     */
    public static final AddressLayout PCERT_ALT_NAME_INFO = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CERT_BASIC_CONSTRAINTS_INFO {
     *     CRYPT_BIT_BLOB SubjectType;
     *     BOOL fPathLenConstraint;
     *     DWORD dwPathLenConstraint;
     *     DWORD cSubtreesConstraint;
     *     CERT_NAME_BLOB *rgSubtreesConstraint;
     * } *PCERT_BASIC_CONSTRAINTS_INFO
     * }
     */
    public static final AddressLayout PCERT_BASIC_CONSTRAINTS_INFO = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CERT_BASIC_CONSTRAINTS2_INFO {
     *     BOOL fCA;
     *     BOOL fPathLenConstraint;
     *     DWORD dwPathLenConstraint;
     * } *PCERT_BASIC_CONSTRAINTS2_INFO
     * }
     */
    public static final AddressLayout PCERT_BASIC_CONSTRAINTS2_INFO = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CERT_POLICY_QUALIFIER_INFO {
     *     LPSTR pszPolicyQualifierId;
     *     CRYPT_OBJID_BLOB Qualifier;
     * } *PCERT_POLICY_QUALIFIER_INFO
     * }
     */
    public static final AddressLayout PCERT_POLICY_QUALIFIER_INFO = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CERT_POLICY_INFO {
     *     LPSTR pszPolicyIdentifier;
     *     DWORD cPolicyQualifier;
     *     CERT_POLICY_QUALIFIER_INFO *rgPolicyQualifier;
     * } *PCERT_POLICY_INFO
     * }
     */
    public static final AddressLayout PCERT_POLICY_INFO = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CERT_POLICIES_INFO {
     *     DWORD cPolicyInfo;
     *     CERT_POLICY_INFO *rgPolicyInfo;
     * } *PCERT_POLICIES_INFO
     * }
     */
    public static final AddressLayout PCERT_POLICIES_INFO = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CERT_POLICY_QUALIFIER_NOTICE_REFERENCE {
     *     LPSTR pszOrganization;
     *     DWORD cNoticeNumbers;
     *     int *rgNoticeNumbers;
     * } *PCERT_POLICY_QUALIFIER_NOTICE_REFERENCE
     * }
     */
    public static final AddressLayout PCERT_POLICY_QUALIFIER_NOTICE_REFERENCE = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CERT_POLICY_QUALIFIER_USER_NOTICE {
     *     CERT_POLICY_QUALIFIER_NOTICE_REFERENCE *pNoticeReference;
     *     LPWSTR pszDisplayText;
     * } *PCERT_POLICY_QUALIFIER_USER_NOTICE
     * }
     */
    public static final AddressLayout PCERT_POLICY_QUALIFIER_USER_NOTICE = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CPS_URLS {
     *     LPWSTR pszURL;
     *     CRYPT_ALGORITHM_IDENTIFIER *pAlgorithm;
     *     CRYPT_DATA_BLOB *pDigest;
     * } *PCPS_URLS
     * }
     */
    public static final AddressLayout PCPS_URLS = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CERT_POLICY95_QUALIFIER1 {
     *     LPWSTR pszPracticesReference;
     *     LPSTR pszNoticeIdentifier;
     *     LPSTR pszNSINoticeIdentifier;
     *     DWORD cCPSURLs;
     *     CPS_URLS *rgCPSURLs;
     * } *PCERT_POLICY95_QUALIFIER1
     * }
     */
    public static final AddressLayout PCERT_POLICY95_QUALIFIER1 = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CERT_POLICY_MAPPING {
     *     LPSTR pszIssuerDomainPolicy;
     *     LPSTR pszSubjectDomainPolicy;
     * } *PCERT_POLICY_MAPPING
     * }
     */
    public static final AddressLayout PCERT_POLICY_MAPPING = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CERT_POLICY_MAPPINGS_INFO {
     *     DWORD cPolicyMapping;
     *     PCERT_POLICY_MAPPING rgPolicyMapping;
     * } *PCERT_POLICY_MAPPINGS_INFO
     * }
     */
    public static final AddressLayout PCERT_POLICY_MAPPINGS_INFO = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CERT_POLICY_CONSTRAINTS_INFO {
     *     BOOL fRequireExplicitPolicy;
     *     DWORD dwRequireExplicitPolicySkipCerts;
     *     BOOL fInhibitPolicyMapping;
     *     DWORD dwInhibitPolicyMappingSkipCerts;
     * } *PCERT_POLICY_CONSTRAINTS_INFO
     * }
     */
    public static final AddressLayout PCERT_POLICY_CONSTRAINTS_INFO = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CRYPT_CONTENT_INFO_SEQUENCE_OF_ANY {
     *     LPSTR pszObjId;
     *     DWORD cValue;
     *     PCRYPT_DER_BLOB rgValue;
     * } *PCRYPT_CONTENT_INFO_SEQUENCE_OF_ANY
     * }
     */
    public static final AddressLayout PCRYPT_CONTENT_INFO_SEQUENCE_OF_ANY = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CRYPT_CONTENT_INFO {
     *     LPSTR pszObjId;
     *     CRYPT_DER_BLOB Content;
     * } *PCRYPT_CONTENT_INFO
     * }
     */
    public static final AddressLayout PCRYPT_CONTENT_INFO = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CRYPT_SEQUENCE_OF_ANY {
     *     DWORD cValue;
     *     PCRYPT_DER_BLOB rgValue;
     * } *PCRYPT_SEQUENCE_OF_ANY
     * }
     */
    public static final AddressLayout PCRYPT_SEQUENCE_OF_ANY = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CERT_AUTHORITY_KEY_ID2_INFO {
     *     CRYPT_DATA_BLOB KeyId;
     *     CERT_ALT_NAME_INFO AuthorityCertIssuer;
     *     CRYPT_INTEGER_BLOB AuthorityCertSerialNumber;
     * } *PCERT_AUTHORITY_KEY_ID2_INFO
     * }
     */
    public static final AddressLayout PCERT_AUTHORITY_KEY_ID2_INFO = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CERT_ACCESS_DESCRIPTION {
     *     LPSTR pszAccessMethod;
     *     CERT_ALT_NAME_ENTRY AccessLocation;
     * } *PCERT_ACCESS_DESCRIPTION
     * }
     */
    public static final AddressLayout PCERT_ACCESS_DESCRIPTION = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CERT_AUTHORITY_INFO_ACCESS {
     *     DWORD cAccDescr;
     *     PCERT_ACCESS_DESCRIPTION rgAccDescr;
     * } *PCERT_AUTHORITY_INFO_ACCESS
     * }
     */
    public static final AddressLayout PCERT_AUTHORITY_INFO_ACCESS = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CERT_AUTHORITY_INFO_ACCESS {
     *     DWORD cAccDescr;
     *     PCERT_ACCESS_DESCRIPTION rgAccDescr;
     * } *PCERT_SUBJECT_INFO_ACCESS
     * }
     */
    public static final AddressLayout PCERT_SUBJECT_INFO_ACCESS = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CRL_DIST_POINT_NAME {
     *     DWORD dwDistPointNameChoice;
     *     union {
     *         CERT_ALT_NAME_INFO FullName;
     *     };
     * } *PCRL_DIST_POINT_NAME
     * }
     */
    public static final AddressLayout PCRL_DIST_POINT_NAME = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CRL_DIST_POINT {
     *     CRL_DIST_POINT_NAME DistPointName;
     *     CRYPT_BIT_BLOB ReasonFlags;
     *     CERT_ALT_NAME_INFO CRLIssuer;
     * } *PCRL_DIST_POINT
     * }
     */
    public static final AddressLayout PCRL_DIST_POINT = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CRL_DIST_POINTS_INFO {
     *     DWORD cDistPoint;
     *     PCRL_DIST_POINT rgDistPoint;
     * } *PCRL_DIST_POINTS_INFO
     * }
     */
    public static final AddressLayout PCRL_DIST_POINTS_INFO = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CROSS_CERT_DIST_POINTS_INFO {
     *     DWORD dwSyncDeltaTime;
     *     DWORD cDistPoint;
     *     PCERT_ALT_NAME_INFO rgDistPoint;
     * } *PCROSS_CERT_DIST_POINTS_INFO
     * }
     */
    public static final AddressLayout PCROSS_CERT_DIST_POINTS_INFO = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CERT_PAIR {
     *     CERT_BLOB Forward;
     *     CERT_BLOB Reverse;
     * } *PCERT_PAIR
     * }
     */
    public static final AddressLayout PCERT_PAIR = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CRL_ISSUING_DIST_POINT {
     *     CRL_DIST_POINT_NAME DistPointName;
     *     BOOL fOnlyContainsUserCerts;
     *     BOOL fOnlyContainsCACerts;
     *     CRYPT_BIT_BLOB OnlySomeReasonFlags;
     *     BOOL fIndirectCRL;
     * } *PCRL_ISSUING_DIST_POINT
     * }
     */
    public static final AddressLayout PCRL_ISSUING_DIST_POINT = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CERT_GENERAL_SUBTREE {
     *     CERT_ALT_NAME_ENTRY Base;
     *     DWORD dwMinimum;
     *     BOOL fMaximum;
     *     DWORD dwMaximum;
     * } *PCERT_GENERAL_SUBTREE
     * }
     */
    public static final AddressLayout PCERT_GENERAL_SUBTREE = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CERT_NAME_CONSTRAINTS_INFO {
     *     DWORD cPermittedSubtree;
     *     PCERT_GENERAL_SUBTREE rgPermittedSubtree;
     *     DWORD cExcludedSubtree;
     *     PCERT_GENERAL_SUBTREE rgExcludedSubtree;
     * } *PCERT_NAME_CONSTRAINTS_INFO
     * }
     */
    public static final AddressLayout PCERT_NAME_CONSTRAINTS_INFO = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CERT_DSS_PARAMETERS {
     *     CRYPT_UINT_BLOB p;
     *     CRYPT_UINT_BLOB q;
     *     CRYPT_UINT_BLOB g;
     * } *PCERT_DSS_PARAMETERS
     * }
     */
    public static final AddressLayout PCERT_DSS_PARAMETERS = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CERT_DH_PARAMETERS {
     *     CRYPT_UINT_BLOB p;
     *     CRYPT_UINT_BLOB g;
     * } *PCERT_DH_PARAMETERS
     * }
     */
    public static final AddressLayout PCERT_DH_PARAMETERS = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CERT_ECC_SIGNATURE {
     *     CRYPT_UINT_BLOB r;
     *     CRYPT_UINT_BLOB s;
     * } *PCERT_ECC_SIGNATURE
     * }
     */
    public static final AddressLayout PCERT_ECC_SIGNATURE = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CERT_X942_DH_VALIDATION_PARAMS {
     *     CRYPT_BIT_BLOB seed;
     *     DWORD pgenCounter;
     * } *PCERT_X942_DH_VALIDATION_PARAMS
     * }
     */
    public static final AddressLayout PCERT_X942_DH_VALIDATION_PARAMS = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CERT_X942_DH_PARAMETERS {
     *     CRYPT_UINT_BLOB p;
     *     CRYPT_UINT_BLOB g;
     *     CRYPT_UINT_BLOB q;
     *     CRYPT_UINT_BLOB j;
     *     PCERT_X942_DH_VALIDATION_PARAMS pValidationParams;
     * } *PCERT_X942_DH_PARAMETERS
     * }
     */
    public static final AddressLayout PCERT_X942_DH_PARAMETERS = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CRYPT_X942_OTHER_INFO {
     *     LPSTR pszContentEncryptionObjId;
     *     BYTE rgbCounter[4];
     *     BYTE rgbKeyLength[4];
     *     CRYPT_DATA_BLOB PubInfo;
     * } *PCRYPT_X942_OTHER_INFO
     * }
     */
    public static final AddressLayout PCRYPT_X942_OTHER_INFO = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CRYPT_ECC_CMS_SHARED_INFO {
     *     CRYPT_ALGORITHM_IDENTIFIER Algorithm;
     *     CRYPT_DATA_BLOB EntityUInfo;
     *     BYTE rgbSuppPubInfo[4];
     * } *PCRYPT_ECC_CMS_SHARED_INFO
     * }
     */
    public static final AddressLayout PCRYPT_ECC_CMS_SHARED_INFO = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CRYPT_RC2_CBC_PARAMETERS {
     *     DWORD dwVersion;
     *     BOOL fIV;
     *     BYTE rgbIV[8];
     * } *PCRYPT_RC2_CBC_PARAMETERS
     * }
     */
    public static final AddressLayout PCRYPT_RC2_CBC_PARAMETERS = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CRYPT_SMIME_CAPABILITY {
     *     LPSTR pszObjId;
     *     CRYPT_OBJID_BLOB Parameters;
     * } *PCRYPT_SMIME_CAPABILITY
     * }
     */
    public static final AddressLayout PCRYPT_SMIME_CAPABILITY = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CRYPT_SMIME_CAPABILITIES {
     *     DWORD cCapability;
     *     PCRYPT_SMIME_CAPABILITY rgCapability;
     * } *PCRYPT_SMIME_CAPABILITIES
     * }
     */
    public static final AddressLayout PCRYPT_SMIME_CAPABILITIES = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CERT_QC_STATEMENT {
     *     LPSTR pszStatementId;
     *     CRYPT_OBJID_BLOB StatementInfo;
     * } *PCERT_QC_STATEMENT
     * }
     */
    public static final AddressLayout PCERT_QC_STATEMENT = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CERT_QC_STATEMENTS_EXT_INFO {
     *     DWORD cStatement;
     *     PCERT_QC_STATEMENT rgStatement;
     * } *PCERT_QC_STATEMENTS_EXT_INFO
     * }
     */
    public static final AddressLayout PCERT_QC_STATEMENTS_EXT_INFO = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CRYPT_MASK_GEN_ALGORITHM {
     *     LPSTR pszObjId;
     *     CRYPT_ALGORITHM_IDENTIFIER HashAlgorithm;
     * } *PCRYPT_MASK_GEN_ALGORITHM
     * }
     */
    public static final AddressLayout PCRYPT_MASK_GEN_ALGORITHM = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CRYPT_RSA_SSA_PSS_PARAMETERS {
     *     CRYPT_ALGORITHM_IDENTIFIER HashAlgorithm;
     *     CRYPT_MASK_GEN_ALGORITHM MaskGenAlgorithm;
     *     DWORD dwSaltLength;
     *     DWORD dwTrailerField;
     * } *PCRYPT_RSA_SSA_PSS_PARAMETERS
     * }
     */
    public static final AddressLayout PCRYPT_RSA_SSA_PSS_PARAMETERS = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CRYPT_PSOURCE_ALGORITHM {
     *     LPSTR pszObjId;
     *     CRYPT_DATA_BLOB EncodingParameters;
     * } *PCRYPT_PSOURCE_ALGORITHM
     * }
     */
    public static final AddressLayout PCRYPT_PSOURCE_ALGORITHM = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CRYPT_RSAES_OAEP_PARAMETERS {
     *     CRYPT_ALGORITHM_IDENTIFIER HashAlgorithm;
     *     CRYPT_MASK_GEN_ALGORITHM MaskGenAlgorithm;
     *     CRYPT_PSOURCE_ALGORITHM PSourceAlgorithm;
     * } *PCRYPT_RSAES_OAEP_PARAMETERS
     * }
     */
    public static final AddressLayout PCRYPT_RSAES_OAEP_PARAMETERS = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CMC_TAGGED_ATTRIBUTE {
     *     DWORD dwBodyPartID;
     *     CRYPT_ATTRIBUTE Attribute;
     * } *PCMC_TAGGED_ATTRIBUTE
     * }
     */
    public static final AddressLayout PCMC_TAGGED_ATTRIBUTE = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CMC_TAGGED_CERT_REQUEST {
     *     DWORD dwBodyPartID;
     *     CRYPT_DER_BLOB SignedCertRequest;
     * } *PCMC_TAGGED_CERT_REQUEST
     * }
     */
    public static final AddressLayout PCMC_TAGGED_CERT_REQUEST = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CMC_TAGGED_REQUEST {
     *     DWORD dwTaggedRequestChoice;
     *     union {
     *         PCMC_TAGGED_CERT_REQUEST pTaggedCertRequest;
     *     };
     * } *PCMC_TAGGED_REQUEST
     * }
     */
    public static final AddressLayout PCMC_TAGGED_REQUEST = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CMC_TAGGED_CONTENT_INFO {
     *     DWORD dwBodyPartID;
     *     CRYPT_DER_BLOB EncodedContentInfo;
     * } *PCMC_TAGGED_CONTENT_INFO
     * }
     */
    public static final AddressLayout PCMC_TAGGED_CONTENT_INFO = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CMC_TAGGED_OTHER_MSG {
     *     DWORD dwBodyPartID;
     *     LPSTR pszObjId;
     *     CRYPT_OBJID_BLOB Value;
     * } *PCMC_TAGGED_OTHER_MSG
     * }
     */
    public static final AddressLayout PCMC_TAGGED_OTHER_MSG = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CMC_DATA_INFO {
     *     DWORD cTaggedAttribute;
     *     PCMC_TAGGED_ATTRIBUTE rgTaggedAttribute;
     *     DWORD cTaggedRequest;
     *     PCMC_TAGGED_REQUEST rgTaggedRequest;
     *     DWORD cTaggedContentInfo;
     *     PCMC_TAGGED_CONTENT_INFO rgTaggedContentInfo;
     *     DWORD cTaggedOtherMsg;
     *     PCMC_TAGGED_OTHER_MSG rgTaggedOtherMsg;
     * } *PCMC_DATA_INFO
     * }
     */
    public static final AddressLayout PCMC_DATA_INFO = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CMC_RESPONSE_INFO {
     *     DWORD cTaggedAttribute;
     *     PCMC_TAGGED_ATTRIBUTE rgTaggedAttribute;
     *     DWORD cTaggedContentInfo;
     *     PCMC_TAGGED_CONTENT_INFO rgTaggedContentInfo;
     *     DWORD cTaggedOtherMsg;
     *     PCMC_TAGGED_OTHER_MSG rgTaggedOtherMsg;
     * } *PCMC_RESPONSE_INFO
     * }
     */
    public static final AddressLayout PCMC_RESPONSE_INFO = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CMC_PEND_INFO {
     *     CRYPT_DATA_BLOB PendToken;
     *     FILETIME PendTime;
     * } *PCMC_PEND_INFO
     * }
     */
    public static final AddressLayout PCMC_PEND_INFO = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CMC_STATUS_INFO {
     *     DWORD dwStatus;
     *     DWORD cBodyList;
     *     DWORD *rgdwBodyList;
     *     LPWSTR pwszStatusString;
     *     DWORD dwOtherInfoChoice;
     *     union {
     *         DWORD dwFailInfo;
     *         PCMC_PEND_INFO pPendInfo;
     *     };
     * } *PCMC_STATUS_INFO
     * }
     */
    public static final AddressLayout PCMC_STATUS_INFO = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CMC_ADD_EXTENSIONS_INFO {
     *     DWORD dwCmcDataReference;
     *     DWORD cCertReference;
     *     DWORD *rgdwCertReference;
     *     DWORD cExtension;
     *     PCERT_EXTENSION rgExtension;
     * } *PCMC_ADD_EXTENSIONS_INFO
     * }
     */
    public static final AddressLayout PCMC_ADD_EXTENSIONS_INFO = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CMC_ADD_ATTRIBUTES_INFO {
     *     DWORD dwCmcDataReference;
     *     DWORD cCertReference;
     *     DWORD *rgdwCertReference;
     *     DWORD cAttribute;
     *     PCRYPT_ATTRIBUTE rgAttribute;
     * } *PCMC_ADD_ATTRIBUTES_INFO
     * }
     */
    public static final AddressLayout PCMC_ADD_ATTRIBUTES_INFO = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CERT_TEMPLATE_EXT {
     *     LPSTR pszObjId;
     *     DWORD dwMajorVersion;
     *     BOOL fMinorVersion;
     *     DWORD dwMinorVersion;
     * } *PCERT_TEMPLATE_EXT
     * }
     */
    public static final AddressLayout PCERT_TEMPLATE_EXT = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CERT_HASHED_URL {
     *     CRYPT_ALGORITHM_IDENTIFIER HashAlgorithm;
     *     CRYPT_HASH_BLOB Hash;
     *     LPWSTR pwszUrl;
     * } *PCERT_HASHED_URL
     * }
     */
    public static final AddressLayout PCERT_HASHED_URL = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CERT_LOGOTYPE_DETAILS {
     *     LPWSTR pwszMimeType;
     *     DWORD cHashedUrl;
     *     PCERT_HASHED_URL rgHashedUrl;
     * } *PCERT_LOGOTYPE_DETAILS
     * }
     */
    public static final AddressLayout PCERT_LOGOTYPE_DETAILS = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CERT_LOGOTYPE_REFERENCE {
     *     DWORD cHashedUrl;
     *     PCERT_HASHED_URL rgHashedUrl;
     * } *PCERT_LOGOTYPE_REFERENCE
     * }
     */
    public static final AddressLayout PCERT_LOGOTYPE_REFERENCE = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CERT_LOGOTYPE_IMAGE_INFO {
     *     DWORD dwLogotypeImageInfoChoice;
     *     DWORD dwFileSize;
     *     DWORD dwXSize;
     *     DWORD dwYSize;
     *     DWORD dwLogotypeImageResolutionChoice;
     *     union {
     *         DWORD dwNumBits;
     *         DWORD dwTableSize;
     *     };
     *     LPWSTR pwszLanguage;
     * } *PCERT_LOGOTYPE_IMAGE_INFO
     * }
     */
    public static final AddressLayout PCERT_LOGOTYPE_IMAGE_INFO = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CERT_LOGOTYPE_IMAGE {
     *     CERT_LOGOTYPE_DETAILS LogotypeDetails;
     *     PCERT_LOGOTYPE_IMAGE_INFO pLogotypeImageInfo;
     * } *PCERT_LOGOTYPE_IMAGE
     * }
     */
    public static final AddressLayout PCERT_LOGOTYPE_IMAGE = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CERT_LOGOTYPE_AUDIO_INFO {
     *     DWORD dwFileSize;
     *     DWORD dwPlayTime;
     *     DWORD dwChannels;
     *     DWORD dwSampleRate;
     *     LPWSTR pwszLanguage;
     * } *PCERT_LOGOTYPE_AUDIO_INFO
     * }
     */
    public static final AddressLayout PCERT_LOGOTYPE_AUDIO_INFO = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CERT_LOGOTYPE_AUDIO {
     *     CERT_LOGOTYPE_DETAILS LogotypeDetails;
     *     PCERT_LOGOTYPE_AUDIO_INFO pLogotypeAudioInfo;
     * } *PCERT_LOGOTYPE_AUDIO
     * }
     */
    public static final AddressLayout PCERT_LOGOTYPE_AUDIO = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CERT_LOGOTYPE_DATA {
     *     DWORD cLogotypeImage;
     *     PCERT_LOGOTYPE_IMAGE rgLogotypeImage;
     *     DWORD cLogotypeAudio;
     *     PCERT_LOGOTYPE_AUDIO rgLogotypeAudio;
     * } *PCERT_LOGOTYPE_DATA
     * }
     */
    public static final AddressLayout PCERT_LOGOTYPE_DATA = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CERT_LOGOTYPE_INFO {
     *     DWORD dwLogotypeInfoChoice;
     *     union {
     *         PCERT_LOGOTYPE_DATA pLogotypeDirectInfo;
     *         PCERT_LOGOTYPE_REFERENCE pLogotypeIndirectInfo;
     *     };
     * } *PCERT_LOGOTYPE_INFO
     * }
     */
    public static final AddressLayout PCERT_LOGOTYPE_INFO = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CERT_OTHER_LOGOTYPE_INFO {
     *     LPSTR pszObjId;
     *     CERT_LOGOTYPE_INFO LogotypeInfo;
     * } *PCERT_OTHER_LOGOTYPE_INFO
     * }
     */
    public static final AddressLayout PCERT_OTHER_LOGOTYPE_INFO = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CERT_LOGOTYPE_EXT_INFO {
     *     DWORD cCommunityLogo;
     *     PCERT_LOGOTYPE_INFO rgCommunityLogo;
     *     PCERT_LOGOTYPE_INFO pIssuerLogo;
     *     PCERT_LOGOTYPE_INFO pSubjectLogo;
     *     DWORD cOtherLogo;
     *     PCERT_OTHER_LOGOTYPE_INFO rgOtherLogo;
     * } *PCERT_LOGOTYPE_EXT_INFO
     * }
     */
    public static final AddressLayout PCERT_LOGOTYPE_EXT_INFO = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CERT_BIOMETRIC_DATA {
     *     DWORD dwTypeOfBiometricDataChoice;
     *     union {
     *         DWORD dwPredefined;
     *         LPSTR pszObjId;
     *     };
     *     CERT_HASHED_URL HashedUrl;
     * } *PCERT_BIOMETRIC_DATA
     * }
     */
    public static final AddressLayout PCERT_BIOMETRIC_DATA = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CERT_BIOMETRIC_EXT_INFO {
     *     DWORD cBiometricData;
     *     PCERT_BIOMETRIC_DATA rgBiometricData;
     * } *PCERT_BIOMETRIC_EXT_INFO
     * }
     */
    public static final AddressLayout PCERT_BIOMETRIC_EXT_INFO = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _OCSP_SIGNATURE_INFO {
     *     CRYPT_ALGORITHM_IDENTIFIER SignatureAlgorithm;
     *     CRYPT_BIT_BLOB Signature;
     *     DWORD cCertEncoded;
     *     PCERT_BLOB rgCertEncoded;
     * } *POCSP_SIGNATURE_INFO
     * }
     */
    public static final AddressLayout POCSP_SIGNATURE_INFO = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _OCSP_SIGNED_REQUEST_INFO {
     *     CRYPT_DER_BLOB ToBeSigned;
     *     POCSP_SIGNATURE_INFO pOptionalSignatureInfo;
     * } *POCSP_SIGNED_REQUEST_INFO
     * }
     */
    public static final AddressLayout POCSP_SIGNED_REQUEST_INFO = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _OCSP_CERT_ID {
     *     CRYPT_ALGORITHM_IDENTIFIER HashAlgorithm;
     *     CRYPT_HASH_BLOB IssuerNameHash;
     *     CRYPT_HASH_BLOB IssuerKeyHash;
     *     CRYPT_INTEGER_BLOB SerialNumber;
     * } *POCSP_CERT_ID
     * }
     */
    public static final AddressLayout POCSP_CERT_ID = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _OCSP_REQUEST_ENTRY {
     *     OCSP_CERT_ID CertId;
     *     DWORD cExtension;
     *     PCERT_EXTENSION rgExtension;
     * } *POCSP_REQUEST_ENTRY
     * }
     */
    public static final AddressLayout POCSP_REQUEST_ENTRY = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _OCSP_REQUEST_INFO {
     *     DWORD dwVersion;
     *     PCERT_ALT_NAME_ENTRY pRequestorName;
     *     DWORD cRequestEntry;
     *     POCSP_REQUEST_ENTRY rgRequestEntry;
     *     DWORD cExtension;
     *     PCERT_EXTENSION rgExtension;
     * } *POCSP_REQUEST_INFO
     * }
     */
    public static final AddressLayout POCSP_REQUEST_INFO = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _OCSP_RESPONSE_INFO {
     *     DWORD dwStatus;
     *     LPSTR pszObjId;
     *     CRYPT_OBJID_BLOB Value;
     * } *POCSP_RESPONSE_INFO
     * }
     */
    public static final AddressLayout POCSP_RESPONSE_INFO = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _OCSP_BASIC_SIGNED_RESPONSE_INFO {
     *     CRYPT_DER_BLOB ToBeSigned;
     *     OCSP_SIGNATURE_INFO SignatureInfo;
     * } *POCSP_BASIC_SIGNED_RESPONSE_INFO
     * }
     */
    public static final AddressLayout POCSP_BASIC_SIGNED_RESPONSE_INFO = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _OCSP_BASIC_REVOKED_INFO {
     *     FILETIME RevocationDate;
     *     DWORD dwCrlReasonCode;
     * } *POCSP_BASIC_REVOKED_INFO
     * }
     */
    public static final AddressLayout POCSP_BASIC_REVOKED_INFO = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _OCSP_BASIC_RESPONSE_ENTRY {
     *     OCSP_CERT_ID CertId;
     *     DWORD dwCertStatus;
     *     union {
     *         POCSP_BASIC_REVOKED_INFO pRevokedInfo;
     *     };
     *     FILETIME ThisUpdate;
     *     FILETIME NextUpdate;
     *     DWORD cExtension;
     *     PCERT_EXTENSION rgExtension;
     * } *POCSP_BASIC_RESPONSE_ENTRY
     * }
     */
    public static final AddressLayout POCSP_BASIC_RESPONSE_ENTRY = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _OCSP_BASIC_RESPONSE_INFO {
     *     DWORD dwVersion;
     *     DWORD dwResponderIdChoice;
     *     union {
     *         CERT_NAME_BLOB ByNameResponderId;
     *         CRYPT_HASH_BLOB ByKeyResponderId;
     *     };
     *     FILETIME ProducedAt;
     *     DWORD cResponseEntry;
     *     POCSP_BASIC_RESPONSE_ENTRY rgResponseEntry;
     *     DWORD cExtension;
     *     PCERT_EXTENSION rgExtension;
     * } *POCSP_BASIC_RESPONSE_INFO
     * }
     */
    public static final AddressLayout POCSP_BASIC_RESPONSE_INFO = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CERT_SUPPORTED_ALGORITHM_INFO {
     *     CRYPT_ALGORITHM_IDENTIFIER Algorithm;
     *     CRYPT_BIT_BLOB IntendedKeyUsage;
     *     CERT_POLICIES_INFO IntendedCertPolicies;
     * } *PCERT_SUPPORTED_ALGORITHM_INFO
     * }
     */
    public static final AddressLayout PCERT_SUPPORTED_ALGORITHM_INFO = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CERT_TPM_SPECIFICATION_INFO {
     *     LPWSTR pwszFamily;
     *     DWORD dwLevel;
     *     DWORD dwRevision;
     * } *PCERT_TPM_SPECIFICATION_INFO
     * }
     */
    public static final AddressLayout PCERT_TPM_SPECIFICATION_INFO = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef void *HCRYPTOIDFUNCSET
     * }
     */
    public static final AddressLayout HCRYPTOIDFUNCSET = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef void *HCRYPTOIDFUNCADDR
     * }
     */
    public static final AddressLayout HCRYPTOIDFUNCADDR = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CRYPT_OID_FUNC_ENTRY {
     *     LPCSTR pszOID;
     *     void *pvFuncAddr;
     * } *PCRYPT_OID_FUNC_ENTRY
     * }
     */
    public static final AddressLayout PCRYPT_OID_FUNC_ENTRY = C_POINTER;

    private static class CryptInstallOIDFunctionAddress {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_LONG,
            C_POINTER,
            C_LONG,
            C_POINTER,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CryptInstallOIDFunctionAddress"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CryptInstallOIDFunctionAddress(HMODULE hModule, DWORD dwEncodingType, LPCSTR pszFuncName, DWORD cFuncEntry, const CRYPT_OID_FUNC_ENTRY rgFuncEntry[], DWORD dwFlags)
     * }
     */
    public static FunctionDescriptor CryptInstallOIDFunctionAddress$descriptor() {
        return CryptInstallOIDFunctionAddress.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CryptInstallOIDFunctionAddress(HMODULE hModule, DWORD dwEncodingType, LPCSTR pszFuncName, DWORD cFuncEntry, const CRYPT_OID_FUNC_ENTRY rgFuncEntry[], DWORD dwFlags)
     * }
     */
    public static MethodHandle CryptInstallOIDFunctionAddress$handle() {
        return CryptInstallOIDFunctionAddress.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL CryptInstallOIDFunctionAddress(HMODULE hModule, DWORD dwEncodingType, LPCSTR pszFuncName, DWORD cFuncEntry, const CRYPT_OID_FUNC_ENTRY rgFuncEntry[], DWORD dwFlags)
     * }
     */
    public static int CryptInstallOIDFunctionAddress(MemorySegment hModule, int dwEncodingType, MemorySegment pszFuncName, int cFuncEntry, MemorySegment rgFuncEntry, int dwFlags) {
        var mh$ = CryptInstallOIDFunctionAddress.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CryptInstallOIDFunctionAddress", hModule, dwEncodingType, pszFuncName, cFuncEntry, rgFuncEntry, dwFlags);
            }
            return (int)mh$.invokeExact(hModule, dwEncodingType, pszFuncName, cFuncEntry, rgFuncEntry, dwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CryptInitOIDFunctionSet {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CryptInitOIDFunctionSet"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HCRYPTOIDFUNCSET CryptInitOIDFunctionSet(LPCSTR pszFuncName, DWORD dwFlags)
     * }
     */
    public static FunctionDescriptor CryptInitOIDFunctionSet$descriptor() {
        return CryptInitOIDFunctionSet.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HCRYPTOIDFUNCSET CryptInitOIDFunctionSet(LPCSTR pszFuncName, DWORD dwFlags)
     * }
     */
    public static MethodHandle CryptInitOIDFunctionSet$handle() {
        return CryptInitOIDFunctionSet.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * HCRYPTOIDFUNCSET CryptInitOIDFunctionSet(LPCSTR pszFuncName, DWORD dwFlags)
     * }
     */
    public static MemorySegment CryptInitOIDFunctionSet(MemorySegment pszFuncName, int dwFlags) {
        var mh$ = CryptInitOIDFunctionSet.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CryptInitOIDFunctionSet", pszFuncName, dwFlags);
            }
            return (MemorySegment)mh$.invokeExact(pszFuncName, dwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CryptGetOIDFunctionAddress {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_LONG,
            C_POINTER,
            C_LONG,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CryptGetOIDFunctionAddress"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CryptGetOIDFunctionAddress(HCRYPTOIDFUNCSET hFuncSet, DWORD dwEncodingType, LPCSTR pszOID, DWORD dwFlags, void **ppvFuncAddr, HCRYPTOIDFUNCADDR *phFuncAddr)
     * }
     */
    public static FunctionDescriptor CryptGetOIDFunctionAddress$descriptor() {
        return CryptGetOIDFunctionAddress.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CryptGetOIDFunctionAddress(HCRYPTOIDFUNCSET hFuncSet, DWORD dwEncodingType, LPCSTR pszOID, DWORD dwFlags, void **ppvFuncAddr, HCRYPTOIDFUNCADDR *phFuncAddr)
     * }
     */
    public static MethodHandle CryptGetOIDFunctionAddress$handle() {
        return CryptGetOIDFunctionAddress.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL CryptGetOIDFunctionAddress(HCRYPTOIDFUNCSET hFuncSet, DWORD dwEncodingType, LPCSTR pszOID, DWORD dwFlags, void **ppvFuncAddr, HCRYPTOIDFUNCADDR *phFuncAddr)
     * }
     */
    public static int CryptGetOIDFunctionAddress(MemorySegment hFuncSet, int dwEncodingType, MemorySegment pszOID, int dwFlags, MemorySegment ppvFuncAddr, MemorySegment phFuncAddr) {
        var mh$ = CryptGetOIDFunctionAddress.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CryptGetOIDFunctionAddress", hFuncSet, dwEncodingType, pszOID, dwFlags, ppvFuncAddr, phFuncAddr);
            }
            return (int)mh$.invokeExact(hFuncSet, dwEncodingType, pszOID, dwFlags, ppvFuncAddr, phFuncAddr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CryptGetDefaultOIDDllList {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_LONG,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CryptGetDefaultOIDDllList"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CryptGetDefaultOIDDllList(HCRYPTOIDFUNCSET hFuncSet, DWORD dwEncodingType, WCHAR *pwszDllList, DWORD *pcchDllList)
     * }
     */
    public static FunctionDescriptor CryptGetDefaultOIDDllList$descriptor() {
        return CryptGetDefaultOIDDllList.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CryptGetDefaultOIDDllList(HCRYPTOIDFUNCSET hFuncSet, DWORD dwEncodingType, WCHAR *pwszDllList, DWORD *pcchDllList)
     * }
     */
    public static MethodHandle CryptGetDefaultOIDDllList$handle() {
        return CryptGetDefaultOIDDllList.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL CryptGetDefaultOIDDllList(HCRYPTOIDFUNCSET hFuncSet, DWORD dwEncodingType, WCHAR *pwszDllList, DWORD *pcchDllList)
     * }
     */
    public static int CryptGetDefaultOIDDllList(MemorySegment hFuncSet, int dwEncodingType, MemorySegment pwszDllList, MemorySegment pcchDllList) {
        var mh$ = CryptGetDefaultOIDDllList.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CryptGetDefaultOIDDllList", hFuncSet, dwEncodingType, pwszDllList, pcchDllList);
            }
            return (int)mh$.invokeExact(hFuncSet, dwEncodingType, pwszDllList, pcchDllList);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CryptGetDefaultOIDFunctionAddress {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_LONG,
            C_POINTER,
            C_LONG,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CryptGetDefaultOIDFunctionAddress"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CryptGetDefaultOIDFunctionAddress(HCRYPTOIDFUNCSET hFuncSet, DWORD dwEncodingType, LPCWSTR pwszDll, DWORD dwFlags, void **ppvFuncAddr, HCRYPTOIDFUNCADDR *phFuncAddr)
     * }
     */
    public static FunctionDescriptor CryptGetDefaultOIDFunctionAddress$descriptor() {
        return CryptGetDefaultOIDFunctionAddress.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CryptGetDefaultOIDFunctionAddress(HCRYPTOIDFUNCSET hFuncSet, DWORD dwEncodingType, LPCWSTR pwszDll, DWORD dwFlags, void **ppvFuncAddr, HCRYPTOIDFUNCADDR *phFuncAddr)
     * }
     */
    public static MethodHandle CryptGetDefaultOIDFunctionAddress$handle() {
        return CryptGetDefaultOIDFunctionAddress.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL CryptGetDefaultOIDFunctionAddress(HCRYPTOIDFUNCSET hFuncSet, DWORD dwEncodingType, LPCWSTR pwszDll, DWORD dwFlags, void **ppvFuncAddr, HCRYPTOIDFUNCADDR *phFuncAddr)
     * }
     */
    public static int CryptGetDefaultOIDFunctionAddress(MemorySegment hFuncSet, int dwEncodingType, MemorySegment pwszDll, int dwFlags, MemorySegment ppvFuncAddr, MemorySegment phFuncAddr) {
        var mh$ = CryptGetDefaultOIDFunctionAddress.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CryptGetDefaultOIDFunctionAddress", hFuncSet, dwEncodingType, pwszDll, dwFlags, ppvFuncAddr, phFuncAddr);
            }
            return (int)mh$.invokeExact(hFuncSet, dwEncodingType, pwszDll, dwFlags, ppvFuncAddr, phFuncAddr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CryptFreeOIDFunctionAddress {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CryptFreeOIDFunctionAddress"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CryptFreeOIDFunctionAddress(HCRYPTOIDFUNCADDR hFuncAddr, DWORD dwFlags)
     * }
     */
    public static FunctionDescriptor CryptFreeOIDFunctionAddress$descriptor() {
        return CryptFreeOIDFunctionAddress.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CryptFreeOIDFunctionAddress(HCRYPTOIDFUNCADDR hFuncAddr, DWORD dwFlags)
     * }
     */
    public static MethodHandle CryptFreeOIDFunctionAddress$handle() {
        return CryptFreeOIDFunctionAddress.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL CryptFreeOIDFunctionAddress(HCRYPTOIDFUNCADDR hFuncAddr, DWORD dwFlags)
     * }
     */
    public static int CryptFreeOIDFunctionAddress(MemorySegment hFuncAddr, int dwFlags) {
        var mh$ = CryptFreeOIDFunctionAddress.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CryptFreeOIDFunctionAddress", hFuncAddr, dwFlags);
            }
            return (int)mh$.invokeExact(hFuncAddr, dwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CryptRegisterOIDFunction {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_LONG,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CryptRegisterOIDFunction"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CryptRegisterOIDFunction(DWORD dwEncodingType, LPCSTR pszFuncName, LPCSTR pszOID, LPCWSTR pwszDll, LPCSTR pszOverrideFuncName)
     * }
     */
    public static FunctionDescriptor CryptRegisterOIDFunction$descriptor() {
        return CryptRegisterOIDFunction.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CryptRegisterOIDFunction(DWORD dwEncodingType, LPCSTR pszFuncName, LPCSTR pszOID, LPCWSTR pwszDll, LPCSTR pszOverrideFuncName)
     * }
     */
    public static MethodHandle CryptRegisterOIDFunction$handle() {
        return CryptRegisterOIDFunction.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL CryptRegisterOIDFunction(DWORD dwEncodingType, LPCSTR pszFuncName, LPCSTR pszOID, LPCWSTR pwszDll, LPCSTR pszOverrideFuncName)
     * }
     */
    public static int CryptRegisterOIDFunction(int dwEncodingType, MemorySegment pszFuncName, MemorySegment pszOID, MemorySegment pwszDll, MemorySegment pszOverrideFuncName) {
        var mh$ = CryptRegisterOIDFunction.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CryptRegisterOIDFunction", dwEncodingType, pszFuncName, pszOID, pwszDll, pszOverrideFuncName);
            }
            return (int)mh$.invokeExact(dwEncodingType, pszFuncName, pszOID, pwszDll, pszOverrideFuncName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CryptUnregisterOIDFunction {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_LONG,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CryptUnregisterOIDFunction"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CryptUnregisterOIDFunction(DWORD dwEncodingType, LPCSTR pszFuncName, LPCSTR pszOID)
     * }
     */
    public static FunctionDescriptor CryptUnregisterOIDFunction$descriptor() {
        return CryptUnregisterOIDFunction.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CryptUnregisterOIDFunction(DWORD dwEncodingType, LPCSTR pszFuncName, LPCSTR pszOID)
     * }
     */
    public static MethodHandle CryptUnregisterOIDFunction$handle() {
        return CryptUnregisterOIDFunction.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL CryptUnregisterOIDFunction(DWORD dwEncodingType, LPCSTR pszFuncName, LPCSTR pszOID)
     * }
     */
    public static int CryptUnregisterOIDFunction(int dwEncodingType, MemorySegment pszFuncName, MemorySegment pszOID) {
        var mh$ = CryptUnregisterOIDFunction.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CryptUnregisterOIDFunction", dwEncodingType, pszFuncName, pszOID);
            }
            return (int)mh$.invokeExact(dwEncodingType, pszFuncName, pszOID);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CryptRegisterDefaultOIDFunction {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_LONG,
            C_POINTER,
            C_LONG,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CryptRegisterDefaultOIDFunction"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CryptRegisterDefaultOIDFunction(DWORD dwEncodingType, LPCSTR pszFuncName, DWORD dwIndex, LPCWSTR pwszDll)
     * }
     */
    public static FunctionDescriptor CryptRegisterDefaultOIDFunction$descriptor() {
        return CryptRegisterDefaultOIDFunction.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CryptRegisterDefaultOIDFunction(DWORD dwEncodingType, LPCSTR pszFuncName, DWORD dwIndex, LPCWSTR pwszDll)
     * }
     */
    public static MethodHandle CryptRegisterDefaultOIDFunction$handle() {
        return CryptRegisterDefaultOIDFunction.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL CryptRegisterDefaultOIDFunction(DWORD dwEncodingType, LPCSTR pszFuncName, DWORD dwIndex, LPCWSTR pwszDll)
     * }
     */
    public static int CryptRegisterDefaultOIDFunction(int dwEncodingType, MemorySegment pszFuncName, int dwIndex, MemorySegment pwszDll) {
        var mh$ = CryptRegisterDefaultOIDFunction.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CryptRegisterDefaultOIDFunction", dwEncodingType, pszFuncName, dwIndex, pwszDll);
            }
            return (int)mh$.invokeExact(dwEncodingType, pszFuncName, dwIndex, pwszDll);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CryptUnregisterDefaultOIDFunction {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_LONG,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CryptUnregisterDefaultOIDFunction"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CryptUnregisterDefaultOIDFunction(DWORD dwEncodingType, LPCSTR pszFuncName, LPCWSTR pwszDll)
     * }
     */
    public static FunctionDescriptor CryptUnregisterDefaultOIDFunction$descriptor() {
        return CryptUnregisterDefaultOIDFunction.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CryptUnregisterDefaultOIDFunction(DWORD dwEncodingType, LPCSTR pszFuncName, LPCWSTR pwszDll)
     * }
     */
    public static MethodHandle CryptUnregisterDefaultOIDFunction$handle() {
        return CryptUnregisterDefaultOIDFunction.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL CryptUnregisterDefaultOIDFunction(DWORD dwEncodingType, LPCSTR pszFuncName, LPCWSTR pwszDll)
     * }
     */
    public static int CryptUnregisterDefaultOIDFunction(int dwEncodingType, MemorySegment pszFuncName, MemorySegment pwszDll) {
        var mh$ = CryptUnregisterDefaultOIDFunction.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CryptUnregisterDefaultOIDFunction", dwEncodingType, pszFuncName, pwszDll);
            }
            return (int)mh$.invokeExact(dwEncodingType, pszFuncName, pwszDll);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CryptSetOIDFunctionValue {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_LONG,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_LONG,
            C_POINTER,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CryptSetOIDFunctionValue"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CryptSetOIDFunctionValue(DWORD dwEncodingType, LPCSTR pszFuncName, LPCSTR pszOID, LPCWSTR pwszValueName, DWORD dwValueType, const BYTE *pbValueData, DWORD cbValueData)
     * }
     */
    public static FunctionDescriptor CryptSetOIDFunctionValue$descriptor() {
        return CryptSetOIDFunctionValue.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CryptSetOIDFunctionValue(DWORD dwEncodingType, LPCSTR pszFuncName, LPCSTR pszOID, LPCWSTR pwszValueName, DWORD dwValueType, const BYTE *pbValueData, DWORD cbValueData)
     * }
     */
    public static MethodHandle CryptSetOIDFunctionValue$handle() {
        return CryptSetOIDFunctionValue.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL CryptSetOIDFunctionValue(DWORD dwEncodingType, LPCSTR pszFuncName, LPCSTR pszOID, LPCWSTR pwszValueName, DWORD dwValueType, const BYTE *pbValueData, DWORD cbValueData)
     * }
     */
    public static int CryptSetOIDFunctionValue(int dwEncodingType, MemorySegment pszFuncName, MemorySegment pszOID, MemorySegment pwszValueName, int dwValueType, MemorySegment pbValueData, int cbValueData) {
        var mh$ = CryptSetOIDFunctionValue.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CryptSetOIDFunctionValue", dwEncodingType, pszFuncName, pszOID, pwszValueName, dwValueType, pbValueData, cbValueData);
            }
            return (int)mh$.invokeExact(dwEncodingType, pszFuncName, pszOID, pwszValueName, dwValueType, pbValueData, cbValueData);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CryptGetOIDFunctionValue {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_LONG,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CryptGetOIDFunctionValue"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CryptGetOIDFunctionValue(DWORD dwEncodingType, LPCSTR pszFuncName, LPCSTR pszOID, LPCWSTR pwszValueName, DWORD *pdwValueType, BYTE *pbValueData, DWORD *pcbValueData)
     * }
     */
    public static FunctionDescriptor CryptGetOIDFunctionValue$descriptor() {
        return CryptGetOIDFunctionValue.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CryptGetOIDFunctionValue(DWORD dwEncodingType, LPCSTR pszFuncName, LPCSTR pszOID, LPCWSTR pwszValueName, DWORD *pdwValueType, BYTE *pbValueData, DWORD *pcbValueData)
     * }
     */
    public static MethodHandle CryptGetOIDFunctionValue$handle() {
        return CryptGetOIDFunctionValue.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL CryptGetOIDFunctionValue(DWORD dwEncodingType, LPCSTR pszFuncName, LPCSTR pszOID, LPCWSTR pwszValueName, DWORD *pdwValueType, BYTE *pbValueData, DWORD *pcbValueData)
     * }
     */
    public static int CryptGetOIDFunctionValue(int dwEncodingType, MemorySegment pszFuncName, MemorySegment pszOID, MemorySegment pwszValueName, MemorySegment pdwValueType, MemorySegment pbValueData, MemorySegment pcbValueData) {
        var mh$ = CryptGetOIDFunctionValue.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CryptGetOIDFunctionValue", dwEncodingType, pszFuncName, pszOID, pwszValueName, pdwValueType, pbValueData, pcbValueData);
            }
            return (int)mh$.invokeExact(dwEncodingType, pszFuncName, pszOID, pwszValueName, pdwValueType, pbValueData, pcbValueData);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CryptEnumOIDFunction {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_LONG,
            C_POINTER,
            C_POINTER,
            C_LONG,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CryptEnumOIDFunction"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CryptEnumOIDFunction(DWORD dwEncodingType, LPCSTR pszFuncName, LPCSTR pszOID, DWORD dwFlags, void *pvArg, PFN_CRYPT_ENUM_OID_FUNC pfnEnumOIDFunc)
     * }
     */
    public static FunctionDescriptor CryptEnumOIDFunction$descriptor() {
        return CryptEnumOIDFunction.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CryptEnumOIDFunction(DWORD dwEncodingType, LPCSTR pszFuncName, LPCSTR pszOID, DWORD dwFlags, void *pvArg, PFN_CRYPT_ENUM_OID_FUNC pfnEnumOIDFunc)
     * }
     */
    public static MethodHandle CryptEnumOIDFunction$handle() {
        return CryptEnumOIDFunction.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL CryptEnumOIDFunction(DWORD dwEncodingType, LPCSTR pszFuncName, LPCSTR pszOID, DWORD dwFlags, void *pvArg, PFN_CRYPT_ENUM_OID_FUNC pfnEnumOIDFunc)
     * }
     */
    public static int CryptEnumOIDFunction(int dwEncodingType, MemorySegment pszFuncName, MemorySegment pszOID, int dwFlags, MemorySegment pvArg, MemorySegment pfnEnumOIDFunc) {
        var mh$ = CryptEnumOIDFunction.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CryptEnumOIDFunction", dwEncodingType, pszFuncName, pszOID, dwFlags, pvArg, pfnEnumOIDFunc);
            }
            return (int)mh$.invokeExact(dwEncodingType, pszFuncName, pszOID, dwFlags, pvArg, pfnEnumOIDFunc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct _CRYPT_OID_INFO {
     *     DWORD cbSize;
     *     LPCSTR pszOID;
     *     LPCWSTR pwszName;
     *     DWORD dwGroupId;
     *     union {
     *         DWORD dwValue;
     *         ALG_ID Algid;
     *         DWORD dwLength;
     *     };
     *     CRYPT_DATA_BLOB ExtraInfo;
     * } *PCRYPT_OID_INFO
     * }
     */
    public static final AddressLayout PCRYPT_OID_INFO = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef const CRYPT_OID_INFO *PCCRYPT_OID_INFO
     * }
     */
    public static final AddressLayout PCCRYPT_OID_INFO = C_POINTER;

    private static class CryptFindOIDInfo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_LONG,
            C_POINTER,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CryptFindOIDInfo"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PCCRYPT_OID_INFO CryptFindOIDInfo(DWORD dwKeyType, void *pvKey, DWORD dwGroupId)
     * }
     */
    public static FunctionDescriptor CryptFindOIDInfo$descriptor() {
        return CryptFindOIDInfo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PCCRYPT_OID_INFO CryptFindOIDInfo(DWORD dwKeyType, void *pvKey, DWORD dwGroupId)
     * }
     */
    public static MethodHandle CryptFindOIDInfo$handle() {
        return CryptFindOIDInfo.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * PCCRYPT_OID_INFO CryptFindOIDInfo(DWORD dwKeyType, void *pvKey, DWORD dwGroupId)
     * }
     */
    public static MemorySegment CryptFindOIDInfo(int dwKeyType, MemorySegment pvKey, int dwGroupId) {
        var mh$ = CryptFindOIDInfo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CryptFindOIDInfo", dwKeyType, pvKey, dwGroupId);
            }
            return (MemorySegment)mh$.invokeExact(dwKeyType, pvKey, dwGroupId);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CryptRegisterOIDInfo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CryptRegisterOIDInfo"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CryptRegisterOIDInfo(PCCRYPT_OID_INFO pInfo, DWORD dwFlags)
     * }
     */
    public static FunctionDescriptor CryptRegisterOIDInfo$descriptor() {
        return CryptRegisterOIDInfo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CryptRegisterOIDInfo(PCCRYPT_OID_INFO pInfo, DWORD dwFlags)
     * }
     */
    public static MethodHandle CryptRegisterOIDInfo$handle() {
        return CryptRegisterOIDInfo.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL CryptRegisterOIDInfo(PCCRYPT_OID_INFO pInfo, DWORD dwFlags)
     * }
     */
    public static int CryptRegisterOIDInfo(MemorySegment pInfo, int dwFlags) {
        var mh$ = CryptRegisterOIDInfo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CryptRegisterOIDInfo", pInfo, dwFlags);
            }
            return (int)mh$.invokeExact(pInfo, dwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CryptUnregisterOIDInfo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CryptUnregisterOIDInfo"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CryptUnregisterOIDInfo(PCCRYPT_OID_INFO pInfo)
     * }
     */
    public static FunctionDescriptor CryptUnregisterOIDInfo$descriptor() {
        return CryptUnregisterOIDInfo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CryptUnregisterOIDInfo(PCCRYPT_OID_INFO pInfo)
     * }
     */
    public static MethodHandle CryptUnregisterOIDInfo$handle() {
        return CryptUnregisterOIDInfo.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL CryptUnregisterOIDInfo(PCCRYPT_OID_INFO pInfo)
     * }
     */
    public static int CryptUnregisterOIDInfo(MemorySegment pInfo) {
        var mh$ = CryptUnregisterOIDInfo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CryptUnregisterOIDInfo", pInfo);
            }
            return (int)mh$.invokeExact(pInfo);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CryptEnumOIDInfo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_LONG,
            C_LONG,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CryptEnumOIDInfo"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CryptEnumOIDInfo(DWORD dwGroupId, DWORD dwFlags, void *pvArg, PFN_CRYPT_ENUM_OID_INFO pfnEnumOIDInfo)
     * }
     */
    public static FunctionDescriptor CryptEnumOIDInfo$descriptor() {
        return CryptEnumOIDInfo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CryptEnumOIDInfo(DWORD dwGroupId, DWORD dwFlags, void *pvArg, PFN_CRYPT_ENUM_OID_INFO pfnEnumOIDInfo)
     * }
     */
    public static MethodHandle CryptEnumOIDInfo$handle() {
        return CryptEnumOIDInfo.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL CryptEnumOIDInfo(DWORD dwGroupId, DWORD dwFlags, void *pvArg, PFN_CRYPT_ENUM_OID_INFO pfnEnumOIDInfo)
     * }
     */
    public static int CryptEnumOIDInfo(int dwGroupId, int dwFlags, MemorySegment pvArg, MemorySegment pfnEnumOIDInfo) {
        var mh$ = CryptEnumOIDInfo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CryptEnumOIDInfo", dwGroupId, dwFlags, pvArg, pfnEnumOIDInfo);
            }
            return (int)mh$.invokeExact(dwGroupId, dwFlags, pvArg, pfnEnumOIDInfo);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CryptFindLocalizedName {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CryptFindLocalizedName"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LPCWSTR CryptFindLocalizedName(LPCWSTR pwszCryptName)
     * }
     */
    public static FunctionDescriptor CryptFindLocalizedName$descriptor() {
        return CryptFindLocalizedName.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LPCWSTR CryptFindLocalizedName(LPCWSTR pwszCryptName)
     * }
     */
    public static MethodHandle CryptFindLocalizedName$handle() {
        return CryptFindLocalizedName.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * LPCWSTR CryptFindLocalizedName(LPCWSTR pwszCryptName)
     * }
     */
    public static MemorySegment CryptFindLocalizedName(MemorySegment pwszCryptName) {
        var mh$ = CryptFindLocalizedName.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CryptFindLocalizedName", pwszCryptName);
            }
            return (MemorySegment)mh$.invokeExact(pwszCryptName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct _CERT_STRONG_SIGN_SERIALIZED_INFO {
     *     DWORD dwFlags;
     *     LPWSTR pwszCNGSignHashAlgids;
     *     LPWSTR pwszCNGPubKeyMinBitLengths;
     * } *PCERT_STRONG_SIGN_SERIALIZED_INFO
     * }
     */
    public static final AddressLayout PCERT_STRONG_SIGN_SERIALIZED_INFO = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CERT_STRONG_SIGN_PARA {
     *     DWORD cbSize;
     *     DWORD dwInfoChoice;
     *     union {
     *         void *pvInfo;
     *         PCERT_STRONG_SIGN_SERIALIZED_INFO pSerializedInfo;
     *         LPSTR pszOID;
     *     };
     * } *PCERT_STRONG_SIGN_PARA
     * }
     */
    public static final AddressLayout PCERT_STRONG_SIGN_PARA = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef const CERT_STRONG_SIGN_PARA *PCCERT_STRONG_SIGN_PARA
     * }
     */
    public static final AddressLayout PCCERT_STRONG_SIGN_PARA = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef void *HCRYPTMSG
     * }
     */
    public static final AddressLayout HCRYPTMSG = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CERT_ISSUER_SERIAL_NUMBER {
     *     CERT_NAME_BLOB Issuer;
     *     CRYPT_INTEGER_BLOB SerialNumber;
     * } *PCERT_ISSUER_SERIAL_NUMBER
     * }
     */
    public static final AddressLayout PCERT_ISSUER_SERIAL_NUMBER = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CERT_ID {
     *     DWORD dwIdChoice;
     *     union {
     *         CERT_ISSUER_SERIAL_NUMBER IssuerSerialNumber;
     *         CRYPT_HASH_BLOB KeyId;
     *         CRYPT_HASH_BLOB HashId;
     *     };
     * } *PCERT_ID
     * }
     */
    public static final AddressLayout PCERT_ID = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CMSG_SIGNER_ENCODE_INFO {
     *     DWORD cbSize;
     *     PCERT_INFO pCertInfo;
     *     union {
     *         HCRYPTPROV hCryptProv;
     *         NCRYPT_KEY_HANDLE hNCryptKey;
     *     };
     *     DWORD dwKeySpec;
     *     CRYPT_ALGORITHM_IDENTIFIER HashAlgorithm;
     *     void *pvHashAuxInfo;
     *     DWORD cAuthAttr;
     *     PCRYPT_ATTRIBUTE rgAuthAttr;
     *     DWORD cUnauthAttr;
     *     PCRYPT_ATTRIBUTE rgUnauthAttr;
     * } *PCMSG_SIGNER_ENCODE_INFO
     * }
     */
    public static final AddressLayout PCMSG_SIGNER_ENCODE_INFO = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CMSG_SIGNED_ENCODE_INFO {
     *     DWORD cbSize;
     *     DWORD cSigners;
     *     PCMSG_SIGNER_ENCODE_INFO rgSigners;
     *     DWORD cCertEncoded;
     *     PCERT_BLOB rgCertEncoded;
     *     DWORD cCrlEncoded;
     *     PCRL_BLOB rgCrlEncoded;
     * } *PCMSG_SIGNED_ENCODE_INFO
     * }
     */
    public static final AddressLayout PCMSG_SIGNED_ENCODE_INFO = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CMSG_RECIPIENT_ENCODE_INFO *PCMSG_RECIPIENT_ENCODE_INFO
     * }
     */
    public static final AddressLayout PCMSG_RECIPIENT_ENCODE_INFO = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CMSG_ENVELOPED_ENCODE_INFO {
     *     DWORD cbSize;
     *     HCRYPTPROV_LEGACY hCryptProv;
     *     CRYPT_ALGORITHM_IDENTIFIER ContentEncryptionAlgorithm;
     *     void *pvEncryptionAuxInfo;
     *     DWORD cRecipients;
     *     PCERT_INFO *rgpRecipients;
     * } *PCMSG_ENVELOPED_ENCODE_INFO
     * }
     */
    public static final AddressLayout PCMSG_ENVELOPED_ENCODE_INFO = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CMSG_KEY_TRANS_RECIPIENT_ENCODE_INFO {
     *     DWORD cbSize;
     *     CRYPT_ALGORITHM_IDENTIFIER KeyEncryptionAlgorithm;
     *     void *pvKeyEncryptionAuxInfo;
     *     HCRYPTPROV_LEGACY hCryptProv;
     *     CRYPT_BIT_BLOB RecipientPublicKey;
     *     CERT_ID RecipientId;
     * } *PCMSG_KEY_TRANS_RECIPIENT_ENCODE_INFO
     * }
     */
    public static final AddressLayout PCMSG_KEY_TRANS_RECIPIENT_ENCODE_INFO = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CMSG_RECIPIENT_ENCRYPTED_KEY_ENCODE_INFO {
     *     DWORD cbSize;
     *     CRYPT_BIT_BLOB RecipientPublicKey;
     *     CERT_ID RecipientId;
     *     FILETIME Date;
     *     PCRYPT_ATTRIBUTE_TYPE_VALUE pOtherAttr;
     * } *PCMSG_RECIPIENT_ENCRYPTED_KEY_ENCODE_INFO
     * }
     */
    public static final AddressLayout PCMSG_RECIPIENT_ENCRYPTED_KEY_ENCODE_INFO = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CMSG_KEY_AGREE_RECIPIENT_ENCODE_INFO {
     *     DWORD cbSize;
     *     CRYPT_ALGORITHM_IDENTIFIER KeyEncryptionAlgorithm;
     *     void *pvKeyEncryptionAuxInfo;
     *     CRYPT_ALGORITHM_IDENTIFIER KeyWrapAlgorithm;
     *     void *pvKeyWrapAuxInfo;
     *     HCRYPTPROV_LEGACY hCryptProv;
     *     DWORD dwKeySpec;
     *     DWORD dwKeyChoice;
     *     union {
     *         PCRYPT_ALGORITHM_IDENTIFIER pEphemeralAlgorithm;
     *         PCERT_ID pSenderId;
     *     };
     *     CRYPT_DATA_BLOB UserKeyingMaterial;
     *     DWORD cRecipientEncryptedKeys;
     *     PCMSG_RECIPIENT_ENCRYPTED_KEY_ENCODE_INFO *rgpRecipientEncryptedKeys;
     * } *PCMSG_KEY_AGREE_RECIPIENT_ENCODE_INFO
     * }
     */
    public static final AddressLayout PCMSG_KEY_AGREE_RECIPIENT_ENCODE_INFO = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CMSG_MAIL_LIST_RECIPIENT_ENCODE_INFO {
     *     DWORD cbSize;
     *     CRYPT_ALGORITHM_IDENTIFIER KeyEncryptionAlgorithm;
     *     void *pvKeyEncryptionAuxInfo;
     *     HCRYPTPROV hCryptProv;
     *     DWORD dwKeyChoice;
     *     union {
     *         HCRYPTKEY hKeyEncryptionKey;
     *         void *pvKeyEncryptionKey;
     *     };
     *     CRYPT_DATA_BLOB KeyId;
     *     FILETIME Date;
     *     PCRYPT_ATTRIBUTE_TYPE_VALUE pOtherAttr;
     * } *PCMSG_MAIL_LIST_RECIPIENT_ENCODE_INFO
     * }
     */
    public static final AddressLayout PCMSG_MAIL_LIST_RECIPIENT_ENCODE_INFO = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CMSG_RC2_AUX_INFO {
     *     DWORD cbSize;
     *     DWORD dwBitLen;
     * } *PCMSG_RC2_AUX_INFO
     * }
     */
    public static final AddressLayout PCMSG_RC2_AUX_INFO = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CMSG_SP3_COMPATIBLE_AUX_INFO {
     *     DWORD cbSize;
     *     DWORD dwFlags;
     * } *PCMSG_SP3_COMPATIBLE_AUX_INFO
     * }
     */
    public static final AddressLayout PCMSG_SP3_COMPATIBLE_AUX_INFO = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CMSG_RC4_AUX_INFO {
     *     DWORD cbSize;
     *     DWORD dwBitLen;
     * } *PCMSG_RC4_AUX_INFO
     * }
     */
    public static final AddressLayout PCMSG_RC4_AUX_INFO = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CMSG_SIGNED_AND_ENVELOPED_ENCODE_INFO {
     *     DWORD cbSize;
     *     CMSG_SIGNED_ENCODE_INFO SignedInfo;
     *     CMSG_ENVELOPED_ENCODE_INFO EnvelopedInfo;
     * } *PCMSG_SIGNED_AND_ENVELOPED_ENCODE_INFO
     * }
     */
    public static final AddressLayout PCMSG_SIGNED_AND_ENVELOPED_ENCODE_INFO = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CMSG_HASHED_ENCODE_INFO {
     *     DWORD cbSize;
     *     HCRYPTPROV_LEGACY hCryptProv;
     *     CRYPT_ALGORITHM_IDENTIFIER HashAlgorithm;
     *     void *pvHashAuxInfo;
     * } *PCMSG_HASHED_ENCODE_INFO
     * }
     */
    public static final AddressLayout PCMSG_HASHED_ENCODE_INFO = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CMSG_ENCRYPTED_ENCODE_INFO {
     *     DWORD cbSize;
     *     CRYPT_ALGORITHM_IDENTIFIER ContentEncryptionAlgorithm;
     *     void *pvEncryptionAuxInfo;
     * } *PCMSG_ENCRYPTED_ENCODE_INFO
     * }
     */
    public static final AddressLayout PCMSG_ENCRYPTED_ENCODE_INFO = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CMSG_STREAM_INFO {
     *     DWORD cbContent;
     *     PFN_CMSG_STREAM_OUTPUT pfnStreamOutput;
     *     void *pvArg;
     * } *PCMSG_STREAM_INFO
     * }
     */
    public static final AddressLayout PCMSG_STREAM_INFO = C_POINTER;

    private static class CryptMsgOpenToEncode {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_LONG,
            C_LONG,
            C_LONG,
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CryptMsgOpenToEncode"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HCRYPTMSG CryptMsgOpenToEncode(DWORD dwMsgEncodingType, DWORD dwFlags, DWORD dwMsgType, const void *pvMsgEncodeInfo, LPSTR pszInnerContentObjID, PCMSG_STREAM_INFO pStreamInfo)
     * }
     */
    public static FunctionDescriptor CryptMsgOpenToEncode$descriptor() {
        return CryptMsgOpenToEncode.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HCRYPTMSG CryptMsgOpenToEncode(DWORD dwMsgEncodingType, DWORD dwFlags, DWORD dwMsgType, const void *pvMsgEncodeInfo, LPSTR pszInnerContentObjID, PCMSG_STREAM_INFO pStreamInfo)
     * }
     */
    public static MethodHandle CryptMsgOpenToEncode$handle() {
        return CryptMsgOpenToEncode.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * HCRYPTMSG CryptMsgOpenToEncode(DWORD dwMsgEncodingType, DWORD dwFlags, DWORD dwMsgType, const void *pvMsgEncodeInfo, LPSTR pszInnerContentObjID, PCMSG_STREAM_INFO pStreamInfo)
     * }
     */
    public static MemorySegment CryptMsgOpenToEncode(int dwMsgEncodingType, int dwFlags, int dwMsgType, MemorySegment pvMsgEncodeInfo, MemorySegment pszInnerContentObjID, MemorySegment pStreamInfo) {
        var mh$ = CryptMsgOpenToEncode.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CryptMsgOpenToEncode", dwMsgEncodingType, dwFlags, dwMsgType, pvMsgEncodeInfo, pszInnerContentObjID, pStreamInfo);
            }
            return (MemorySegment)mh$.invokeExact(dwMsgEncodingType, dwFlags, dwMsgType, pvMsgEncodeInfo, pszInnerContentObjID, pStreamInfo);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CryptMsgCalculateEncodedLength {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_LONG,
            C_LONG,
            C_LONG,
            C_POINTER,
            C_POINTER,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CryptMsgCalculateEncodedLength"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD CryptMsgCalculateEncodedLength(DWORD dwMsgEncodingType, DWORD dwFlags, DWORD dwMsgType, const void *pvMsgEncodeInfo, LPSTR pszInnerContentObjID, DWORD cbData)
     * }
     */
    public static FunctionDescriptor CryptMsgCalculateEncodedLength$descriptor() {
        return CryptMsgCalculateEncodedLength.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD CryptMsgCalculateEncodedLength(DWORD dwMsgEncodingType, DWORD dwFlags, DWORD dwMsgType, const void *pvMsgEncodeInfo, LPSTR pszInnerContentObjID, DWORD cbData)
     * }
     */
    public static MethodHandle CryptMsgCalculateEncodedLength$handle() {
        return CryptMsgCalculateEncodedLength.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * DWORD CryptMsgCalculateEncodedLength(DWORD dwMsgEncodingType, DWORD dwFlags, DWORD dwMsgType, const void *pvMsgEncodeInfo, LPSTR pszInnerContentObjID, DWORD cbData)
     * }
     */
    public static int CryptMsgCalculateEncodedLength(int dwMsgEncodingType, int dwFlags, int dwMsgType, MemorySegment pvMsgEncodeInfo, MemorySegment pszInnerContentObjID, int cbData) {
        var mh$ = CryptMsgCalculateEncodedLength.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CryptMsgCalculateEncodedLength", dwMsgEncodingType, dwFlags, dwMsgType, pvMsgEncodeInfo, pszInnerContentObjID, cbData);
            }
            return (int)mh$.invokeExact(dwMsgEncodingType, dwFlags, dwMsgType, pvMsgEncodeInfo, pszInnerContentObjID, cbData);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CryptMsgOpenToDecode {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_LONG,
            C_LONG,
            C_LONG,
            C_LONG_LONG,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CryptMsgOpenToDecode"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HCRYPTMSG CryptMsgOpenToDecode(DWORD dwMsgEncodingType, DWORD dwFlags, DWORD dwMsgType, HCRYPTPROV_LEGACY hCryptProv, PCERT_INFO pRecipientInfo, PCMSG_STREAM_INFO pStreamInfo)
     * }
     */
    public static FunctionDescriptor CryptMsgOpenToDecode$descriptor() {
        return CryptMsgOpenToDecode.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HCRYPTMSG CryptMsgOpenToDecode(DWORD dwMsgEncodingType, DWORD dwFlags, DWORD dwMsgType, HCRYPTPROV_LEGACY hCryptProv, PCERT_INFO pRecipientInfo, PCMSG_STREAM_INFO pStreamInfo)
     * }
     */
    public static MethodHandle CryptMsgOpenToDecode$handle() {
        return CryptMsgOpenToDecode.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * HCRYPTMSG CryptMsgOpenToDecode(DWORD dwMsgEncodingType, DWORD dwFlags, DWORD dwMsgType, HCRYPTPROV_LEGACY hCryptProv, PCERT_INFO pRecipientInfo, PCMSG_STREAM_INFO pStreamInfo)
     * }
     */
    public static MemorySegment CryptMsgOpenToDecode(int dwMsgEncodingType, int dwFlags, int dwMsgType, long hCryptProv, MemorySegment pRecipientInfo, MemorySegment pStreamInfo) {
        var mh$ = CryptMsgOpenToDecode.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CryptMsgOpenToDecode", dwMsgEncodingType, dwFlags, dwMsgType, hCryptProv, pRecipientInfo, pStreamInfo);
            }
            return (MemorySegment)mh$.invokeExact(dwMsgEncodingType, dwFlags, dwMsgType, hCryptProv, pRecipientInfo, pStreamInfo);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CryptMsgDuplicate {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CryptMsgDuplicate"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HCRYPTMSG CryptMsgDuplicate(HCRYPTMSG hCryptMsg)
     * }
     */
    public static FunctionDescriptor CryptMsgDuplicate$descriptor() {
        return CryptMsgDuplicate.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HCRYPTMSG CryptMsgDuplicate(HCRYPTMSG hCryptMsg)
     * }
     */
    public static MethodHandle CryptMsgDuplicate$handle() {
        return CryptMsgDuplicate.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * HCRYPTMSG CryptMsgDuplicate(HCRYPTMSG hCryptMsg)
     * }
     */
    public static MemorySegment CryptMsgDuplicate(MemorySegment hCryptMsg) {
        var mh$ = CryptMsgDuplicate.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CryptMsgDuplicate", hCryptMsg);
            }
            return (MemorySegment)mh$.invokeExact(hCryptMsg);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CryptMsgClose {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CryptMsgClose"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CryptMsgClose(HCRYPTMSG hCryptMsg)
     * }
     */
    public static FunctionDescriptor CryptMsgClose$descriptor() {
        return CryptMsgClose.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CryptMsgClose(HCRYPTMSG hCryptMsg)
     * }
     */
    public static MethodHandle CryptMsgClose$handle() {
        return CryptMsgClose.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL CryptMsgClose(HCRYPTMSG hCryptMsg)
     * }
     */
    public static int CryptMsgClose(MemorySegment hCryptMsg) {
        var mh$ = CryptMsgClose.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CryptMsgClose", hCryptMsg);
            }
            return (int)mh$.invokeExact(hCryptMsg);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CryptMsgUpdate {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_LONG,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CryptMsgUpdate"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CryptMsgUpdate(HCRYPTMSG hCryptMsg, const BYTE *pbData, DWORD cbData, BOOL fFinal)
     * }
     */
    public static FunctionDescriptor CryptMsgUpdate$descriptor() {
        return CryptMsgUpdate.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CryptMsgUpdate(HCRYPTMSG hCryptMsg, const BYTE *pbData, DWORD cbData, BOOL fFinal)
     * }
     */
    public static MethodHandle CryptMsgUpdate$handle() {
        return CryptMsgUpdate.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL CryptMsgUpdate(HCRYPTMSG hCryptMsg, const BYTE *pbData, DWORD cbData, BOOL fFinal)
     * }
     */
    public static int CryptMsgUpdate(MemorySegment hCryptMsg, MemorySegment pbData, int cbData, int fFinal) {
        var mh$ = CryptMsgUpdate.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CryptMsgUpdate", hCryptMsg, pbData, cbData, fFinal);
            }
            return (int)mh$.invokeExact(hCryptMsg, pbData, cbData, fFinal);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CryptMsgGetParam {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_LONG,
            C_LONG,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CryptMsgGetParam"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CryptMsgGetParam(HCRYPTMSG hCryptMsg, DWORD dwParamType, DWORD dwIndex, void *pvData, DWORD *pcbData)
     * }
     */
    public static FunctionDescriptor CryptMsgGetParam$descriptor() {
        return CryptMsgGetParam.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CryptMsgGetParam(HCRYPTMSG hCryptMsg, DWORD dwParamType, DWORD dwIndex, void *pvData, DWORD *pcbData)
     * }
     */
    public static MethodHandle CryptMsgGetParam$handle() {
        return CryptMsgGetParam.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL CryptMsgGetParam(HCRYPTMSG hCryptMsg, DWORD dwParamType, DWORD dwIndex, void *pvData, DWORD *pcbData)
     * }
     */
    public static int CryptMsgGetParam(MemorySegment hCryptMsg, int dwParamType, int dwIndex, MemorySegment pvData, MemorySegment pcbData) {
        var mh$ = CryptMsgGetParam.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CryptMsgGetParam", hCryptMsg, dwParamType, dwIndex, pvData, pcbData);
            }
            return (int)mh$.invokeExact(hCryptMsg, dwParamType, dwIndex, pvData, pcbData);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct _CMSG_SIGNER_INFO {
     *     DWORD dwVersion;
     *     CERT_NAME_BLOB Issuer;
     *     CRYPT_INTEGER_BLOB SerialNumber;
     *     CRYPT_ALGORITHM_IDENTIFIER HashAlgorithm;
     *     CRYPT_ALGORITHM_IDENTIFIER HashEncryptionAlgorithm;
     *     CRYPT_DATA_BLOB EncryptedHash;
     *     CRYPT_ATTRIBUTES AuthAttrs;
     *     CRYPT_ATTRIBUTES UnauthAttrs;
     * } *PCMSG_SIGNER_INFO
     * }
     */
    public static final AddressLayout PCMSG_SIGNER_INFO = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CMSG_CMS_SIGNER_INFO {
     *     DWORD dwVersion;
     *     CERT_ID SignerId;
     *     CRYPT_ALGORITHM_IDENTIFIER HashAlgorithm;
     *     CRYPT_ALGORITHM_IDENTIFIER HashEncryptionAlgorithm;
     *     CRYPT_DATA_BLOB EncryptedHash;
     *     CRYPT_ATTRIBUTES AuthAttrs;
     *     CRYPT_ATTRIBUTES UnauthAttrs;
     * } *PCMSG_CMS_SIGNER_INFO
     * }
     */
    public static final AddressLayout PCMSG_CMS_SIGNER_INFO = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef CRYPT_ATTRIBUTES *PCMSG_ATTR
     * }
     */
    public static final AddressLayout PCMSG_ATTR = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CMSG_KEY_TRANS_RECIPIENT_INFO {
     *     DWORD dwVersion;
     *     CERT_ID RecipientId;
     *     CRYPT_ALGORITHM_IDENTIFIER KeyEncryptionAlgorithm;
     *     CRYPT_DATA_BLOB EncryptedKey;
     * } *PCMSG_KEY_TRANS_RECIPIENT_INFO
     * }
     */
    public static final AddressLayout PCMSG_KEY_TRANS_RECIPIENT_INFO = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CMSG_RECIPIENT_ENCRYPTED_KEY_INFO {
     *     CERT_ID RecipientId;
     *     CRYPT_DATA_BLOB EncryptedKey;
     *     FILETIME Date;
     *     PCRYPT_ATTRIBUTE_TYPE_VALUE pOtherAttr;
     * } *PCMSG_RECIPIENT_ENCRYPTED_KEY_INFO
     * }
     */
    public static final AddressLayout PCMSG_RECIPIENT_ENCRYPTED_KEY_INFO = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CMSG_KEY_AGREE_RECIPIENT_INFO {
     *     DWORD dwVersion;
     *     DWORD dwOriginatorChoice;
     *     union {
     *         CERT_ID OriginatorCertId;
     *         CERT_PUBLIC_KEY_INFO OriginatorPublicKeyInfo;
     *     };
     *     CRYPT_DATA_BLOB UserKeyingMaterial;
     *     CRYPT_ALGORITHM_IDENTIFIER KeyEncryptionAlgorithm;
     *     DWORD cRecipientEncryptedKeys;
     *     PCMSG_RECIPIENT_ENCRYPTED_KEY_INFO *rgpRecipientEncryptedKeys;
     * } *PCMSG_KEY_AGREE_RECIPIENT_INFO
     * }
     */
    public static final AddressLayout PCMSG_KEY_AGREE_RECIPIENT_INFO = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CMSG_MAIL_LIST_RECIPIENT_INFO {
     *     DWORD dwVersion;
     *     CRYPT_DATA_BLOB KeyId;
     *     CRYPT_ALGORITHM_IDENTIFIER KeyEncryptionAlgorithm;
     *     CRYPT_DATA_BLOB EncryptedKey;
     *     FILETIME Date;
     *     PCRYPT_ATTRIBUTE_TYPE_VALUE pOtherAttr;
     * } *PCMSG_MAIL_LIST_RECIPIENT_INFO
     * }
     */
    public static final AddressLayout PCMSG_MAIL_LIST_RECIPIENT_INFO = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CMSG_CMS_RECIPIENT_INFO {
     *     DWORD dwRecipientChoice;
     *     union {
     *         PCMSG_KEY_TRANS_RECIPIENT_INFO pKeyTrans;
     *         PCMSG_KEY_AGREE_RECIPIENT_INFO pKeyAgree;
     *         PCMSG_MAIL_LIST_RECIPIENT_INFO pMailList;
     *     };
     * } *PCMSG_CMS_RECIPIENT_INFO
     * }
     */
    public static final AddressLayout PCMSG_CMS_RECIPIENT_INFO = C_POINTER;

    private static class CryptMsgControl {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_LONG,
            C_LONG,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CryptMsgControl"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CryptMsgControl(HCRYPTMSG hCryptMsg, DWORD dwFlags, DWORD dwCtrlType, const void *pvCtrlPara)
     * }
     */
    public static FunctionDescriptor CryptMsgControl$descriptor() {
        return CryptMsgControl.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CryptMsgControl(HCRYPTMSG hCryptMsg, DWORD dwFlags, DWORD dwCtrlType, const void *pvCtrlPara)
     * }
     */
    public static MethodHandle CryptMsgControl$handle() {
        return CryptMsgControl.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL CryptMsgControl(HCRYPTMSG hCryptMsg, DWORD dwFlags, DWORD dwCtrlType, const void *pvCtrlPara)
     * }
     */
    public static int CryptMsgControl(MemorySegment hCryptMsg, int dwFlags, int dwCtrlType, MemorySegment pvCtrlPara) {
        var mh$ = CryptMsgControl.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CryptMsgControl", hCryptMsg, dwFlags, dwCtrlType, pvCtrlPara);
            }
            return (int)mh$.invokeExact(hCryptMsg, dwFlags, dwCtrlType, pvCtrlPara);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct _CMSG_CTRL_VERIFY_SIGNATURE_EX_PARA {
     *     DWORD cbSize;
     *     HCRYPTPROV_LEGACY hCryptProv;
     *     DWORD dwSignerIndex;
     *     DWORD dwSignerType;
     *     void *pvSigner;
     * } *PCMSG_CTRL_VERIFY_SIGNATURE_EX_PARA
     * }
     */
    public static final AddressLayout PCMSG_CTRL_VERIFY_SIGNATURE_EX_PARA = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CMSG_CTRL_DECRYPT_PARA {
     *     DWORD cbSize;
     *     union {
     *         HCRYPTPROV hCryptProv;
     *         NCRYPT_KEY_HANDLE hNCryptKey;
     *     };
     *     DWORD dwKeySpec;
     *     DWORD dwRecipientIndex;
     * } *PCMSG_CTRL_DECRYPT_PARA
     * }
     */
    public static final AddressLayout PCMSG_CTRL_DECRYPT_PARA = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CMSG_CTRL_KEY_TRANS_DECRYPT_PARA {
     *     DWORD cbSize;
     *     union {
     *         HCRYPTPROV hCryptProv;
     *         NCRYPT_KEY_HANDLE hNCryptKey;
     *     };
     *     DWORD dwKeySpec;
     *     PCMSG_KEY_TRANS_RECIPIENT_INFO pKeyTrans;
     *     DWORD dwRecipientIndex;
     * } *PCMSG_CTRL_KEY_TRANS_DECRYPT_PARA
     * }
     */
    public static final AddressLayout PCMSG_CTRL_KEY_TRANS_DECRYPT_PARA = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CMSG_CTRL_KEY_AGREE_DECRYPT_PARA {
     *     DWORD cbSize;
     *     union {
     *         HCRYPTPROV hCryptProv;
     *         NCRYPT_KEY_HANDLE hNCryptKey;
     *     };
     *     DWORD dwKeySpec;
     *     PCMSG_KEY_AGREE_RECIPIENT_INFO pKeyAgree;
     *     DWORD dwRecipientIndex;
     *     DWORD dwRecipientEncryptedKeyIndex;
     *     CRYPT_BIT_BLOB OriginatorPublicKey;
     * } *PCMSG_CTRL_KEY_AGREE_DECRYPT_PARA
     * }
     */
    public static final AddressLayout PCMSG_CTRL_KEY_AGREE_DECRYPT_PARA = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CMSG_CTRL_MAIL_LIST_DECRYPT_PARA {
     *     DWORD cbSize;
     *     HCRYPTPROV hCryptProv;
     *     PCMSG_MAIL_LIST_RECIPIENT_INFO pMailList;
     *     DWORD dwRecipientIndex;
     *     DWORD dwKeyChoice;
     *     union {
     *         HCRYPTKEY hKeyEncryptionKey;
     *         void *pvKeyEncryptionKey;
     *     };
     * } *PCMSG_CTRL_MAIL_LIST_DECRYPT_PARA
     * }
     */
    public static final AddressLayout PCMSG_CTRL_MAIL_LIST_DECRYPT_PARA = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CMSG_CTRL_ADD_SIGNER_UNAUTH_ATTR_PARA {
     *     DWORD cbSize;
     *     DWORD dwSignerIndex;
     *     CRYPT_DATA_BLOB blob;
     * } *PCMSG_CTRL_ADD_SIGNER_UNAUTH_ATTR_PARA
     * }
     */
    public static final AddressLayout PCMSG_CTRL_ADD_SIGNER_UNAUTH_ATTR_PARA = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CMSG_CTRL_DEL_SIGNER_UNAUTH_ATTR_PARA {
     *     DWORD cbSize;
     *     DWORD dwSignerIndex;
     *     DWORD dwUnauthAttrIndex;
     * } *PCMSG_CTRL_DEL_SIGNER_UNAUTH_ATTR_PARA
     * }
     */
    public static final AddressLayout PCMSG_CTRL_DEL_SIGNER_UNAUTH_ATTR_PARA = C_POINTER;

    private static class CryptMsgVerifyCountersignatureEncoded {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_LONG_LONG,
            C_LONG,
            C_POINTER,
            C_LONG,
            C_POINTER,
            C_LONG,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CryptMsgVerifyCountersignatureEncoded"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CryptMsgVerifyCountersignatureEncoded(HCRYPTPROV_LEGACY hCryptProv, DWORD dwEncodingType, PBYTE pbSignerInfo, DWORD cbSignerInfo, PBYTE pbSignerInfoCountersignature, DWORD cbSignerInfoCountersignature, PCERT_INFO pciCountersigner)
     * }
     */
    public static FunctionDescriptor CryptMsgVerifyCountersignatureEncoded$descriptor() {
        return CryptMsgVerifyCountersignatureEncoded.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CryptMsgVerifyCountersignatureEncoded(HCRYPTPROV_LEGACY hCryptProv, DWORD dwEncodingType, PBYTE pbSignerInfo, DWORD cbSignerInfo, PBYTE pbSignerInfoCountersignature, DWORD cbSignerInfoCountersignature, PCERT_INFO pciCountersigner)
     * }
     */
    public static MethodHandle CryptMsgVerifyCountersignatureEncoded$handle() {
        return CryptMsgVerifyCountersignatureEncoded.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL CryptMsgVerifyCountersignatureEncoded(HCRYPTPROV_LEGACY hCryptProv, DWORD dwEncodingType, PBYTE pbSignerInfo, DWORD cbSignerInfo, PBYTE pbSignerInfoCountersignature, DWORD cbSignerInfoCountersignature, PCERT_INFO pciCountersigner)
     * }
     */
    public static int CryptMsgVerifyCountersignatureEncoded(long hCryptProv, int dwEncodingType, MemorySegment pbSignerInfo, int cbSignerInfo, MemorySegment pbSignerInfoCountersignature, int cbSignerInfoCountersignature, MemorySegment pciCountersigner) {
        var mh$ = CryptMsgVerifyCountersignatureEncoded.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CryptMsgVerifyCountersignatureEncoded", hCryptProv, dwEncodingType, pbSignerInfo, cbSignerInfo, pbSignerInfoCountersignature, cbSignerInfoCountersignature, pciCountersigner);
            }
            return (int)mh$.invokeExact(hCryptProv, dwEncodingType, pbSignerInfo, cbSignerInfo, pbSignerInfoCountersignature, cbSignerInfoCountersignature, pciCountersigner);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CryptMsgVerifyCountersignatureEncodedEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_LONG_LONG,
            C_LONG,
            C_POINTER,
            C_LONG,
            C_POINTER,
            C_LONG,
            C_LONG,
            C_POINTER,
            C_LONG,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CryptMsgVerifyCountersignatureEncodedEx"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CryptMsgVerifyCountersignatureEncodedEx(HCRYPTPROV_LEGACY hCryptProv, DWORD dwEncodingType, PBYTE pbSignerInfo, DWORD cbSignerInfo, PBYTE pbSignerInfoCountersignature, DWORD cbSignerInfoCountersignature, DWORD dwSignerType, void *pvSigner, DWORD dwFlags, void *pvExtra)
     * }
     */
    public static FunctionDescriptor CryptMsgVerifyCountersignatureEncodedEx$descriptor() {
        return CryptMsgVerifyCountersignatureEncodedEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CryptMsgVerifyCountersignatureEncodedEx(HCRYPTPROV_LEGACY hCryptProv, DWORD dwEncodingType, PBYTE pbSignerInfo, DWORD cbSignerInfo, PBYTE pbSignerInfoCountersignature, DWORD cbSignerInfoCountersignature, DWORD dwSignerType, void *pvSigner, DWORD dwFlags, void *pvExtra)
     * }
     */
    public static MethodHandle CryptMsgVerifyCountersignatureEncodedEx$handle() {
        return CryptMsgVerifyCountersignatureEncodedEx.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL CryptMsgVerifyCountersignatureEncodedEx(HCRYPTPROV_LEGACY hCryptProv, DWORD dwEncodingType, PBYTE pbSignerInfo, DWORD cbSignerInfo, PBYTE pbSignerInfoCountersignature, DWORD cbSignerInfoCountersignature, DWORD dwSignerType, void *pvSigner, DWORD dwFlags, void *pvExtra)
     * }
     */
    public static int CryptMsgVerifyCountersignatureEncodedEx(long hCryptProv, int dwEncodingType, MemorySegment pbSignerInfo, int cbSignerInfo, MemorySegment pbSignerInfoCountersignature, int cbSignerInfoCountersignature, int dwSignerType, MemorySegment pvSigner, int dwFlags, MemorySegment pvExtra) {
        var mh$ = CryptMsgVerifyCountersignatureEncodedEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CryptMsgVerifyCountersignatureEncodedEx", hCryptProv, dwEncodingType, pbSignerInfo, cbSignerInfo, pbSignerInfoCountersignature, cbSignerInfoCountersignature, dwSignerType, pvSigner, dwFlags, pvExtra);
            }
            return (int)mh$.invokeExact(hCryptProv, dwEncodingType, pbSignerInfo, cbSignerInfo, pbSignerInfoCountersignature, cbSignerInfoCountersignature, dwSignerType, pvSigner, dwFlags, pvExtra);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CryptMsgCountersign {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_LONG,
            C_LONG,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CryptMsgCountersign"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CryptMsgCountersign(HCRYPTMSG hCryptMsg, DWORD dwIndex, DWORD cCountersigners, PCMSG_SIGNER_ENCODE_INFO rgCountersigners)
     * }
     */
    public static FunctionDescriptor CryptMsgCountersign$descriptor() {
        return CryptMsgCountersign.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CryptMsgCountersign(HCRYPTMSG hCryptMsg, DWORD dwIndex, DWORD cCountersigners, PCMSG_SIGNER_ENCODE_INFO rgCountersigners)
     * }
     */
    public static MethodHandle CryptMsgCountersign$handle() {
        return CryptMsgCountersign.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL CryptMsgCountersign(HCRYPTMSG hCryptMsg, DWORD dwIndex, DWORD cCountersigners, PCMSG_SIGNER_ENCODE_INFO rgCountersigners)
     * }
     */
    public static int CryptMsgCountersign(MemorySegment hCryptMsg, int dwIndex, int cCountersigners, MemorySegment rgCountersigners) {
        var mh$ = CryptMsgCountersign.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CryptMsgCountersign", hCryptMsg, dwIndex, cCountersigners, rgCountersigners);
            }
            return (int)mh$.invokeExact(hCryptMsg, dwIndex, cCountersigners, rgCountersigners);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CryptMsgCountersignEncoded {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_LONG,
            C_POINTER,
            C_LONG,
            C_LONG,
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CryptMsgCountersignEncoded"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CryptMsgCountersignEncoded(DWORD dwEncodingType, PBYTE pbSignerInfo, DWORD cbSignerInfo, DWORD cCountersigners, PCMSG_SIGNER_ENCODE_INFO rgCountersigners, PBYTE pbCountersignature, PDWORD pcbCountersignature)
     * }
     */
    public static FunctionDescriptor CryptMsgCountersignEncoded$descriptor() {
        return CryptMsgCountersignEncoded.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CryptMsgCountersignEncoded(DWORD dwEncodingType, PBYTE pbSignerInfo, DWORD cbSignerInfo, DWORD cCountersigners, PCMSG_SIGNER_ENCODE_INFO rgCountersigners, PBYTE pbCountersignature, PDWORD pcbCountersignature)
     * }
     */
    public static MethodHandle CryptMsgCountersignEncoded$handle() {
        return CryptMsgCountersignEncoded.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL CryptMsgCountersignEncoded(DWORD dwEncodingType, PBYTE pbSignerInfo, DWORD cbSignerInfo, DWORD cCountersigners, PCMSG_SIGNER_ENCODE_INFO rgCountersigners, PBYTE pbCountersignature, PDWORD pcbCountersignature)
     * }
     */
    public static int CryptMsgCountersignEncoded(int dwEncodingType, MemorySegment pbSignerInfo, int cbSignerInfo, int cCountersigners, MemorySegment rgCountersigners, MemorySegment pbCountersignature, MemorySegment pcbCountersignature) {
        var mh$ = CryptMsgCountersignEncoded.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CryptMsgCountersignEncoded", dwEncodingType, pbSignerInfo, cbSignerInfo, cCountersigners, rgCountersigners, pbCountersignature, pcbCountersignature);
            }
            return (int)mh$.invokeExact(dwEncodingType, pbSignerInfo, cbSignerInfo, cCountersigners, rgCountersigners, pbCountersignature, pcbCountersignature);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct _CMSG_CONTENT_ENCRYPT_INFO {
     *     DWORD cbSize;
     *     HCRYPTPROV_LEGACY hCryptProv;
     *     CRYPT_ALGORITHM_IDENTIFIER ContentEncryptionAlgorithm;
     *     void *pvEncryptionAuxInfo;
     *     DWORD cRecipients;
     *     PCMSG_RECIPIENT_ENCODE_INFO rgCmsRecipients;
     *     PFN_CMSG_ALLOC pfnAlloc;
     *     PFN_CMSG_FREE pfnFree;
     *     DWORD dwEncryptFlags;
     *     union {
     *         HCRYPTKEY hContentEncryptKey;
     *         BCRYPT_KEY_HANDLE hCNGContentEncryptKey;
     *     };
     *     DWORD dwFlags;
     *     BOOL fCNG;
     *     BYTE *pbCNGContentEncryptKeyObject;
     *     BYTE *pbContentEncryptKey;
     *     DWORD cbContentEncryptKey;
     * } *PCMSG_CONTENT_ENCRYPT_INFO
     * }
     */
    public static final AddressLayout PCMSG_CONTENT_ENCRYPT_INFO = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CMSG_KEY_TRANS_ENCRYPT_INFO {
     *     DWORD cbSize;
     *     DWORD dwRecipientIndex;
     *     CRYPT_ALGORITHM_IDENTIFIER KeyEncryptionAlgorithm;
     *     CRYPT_DATA_BLOB EncryptedKey;
     *     DWORD dwFlags;
     * } *PCMSG_KEY_TRANS_ENCRYPT_INFO
     * }
     */
    public static final AddressLayout PCMSG_KEY_TRANS_ENCRYPT_INFO = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CMSG_KEY_AGREE_KEY_ENCRYPT_INFO {
     *     DWORD cbSize;
     *     CRYPT_DATA_BLOB EncryptedKey;
     * } *PCMSG_KEY_AGREE_KEY_ENCRYPT_INFO
     * }
     */
    public static final AddressLayout PCMSG_KEY_AGREE_KEY_ENCRYPT_INFO = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CMSG_KEY_AGREE_ENCRYPT_INFO {
     *     DWORD cbSize;
     *     DWORD dwRecipientIndex;
     *     CRYPT_ALGORITHM_IDENTIFIER KeyEncryptionAlgorithm;
     *     CRYPT_DATA_BLOB UserKeyingMaterial;
     *     DWORD dwOriginatorChoice;
     *     union {
     *         CERT_ID OriginatorCertId;
     *         CERT_PUBLIC_KEY_INFO OriginatorPublicKeyInfo;
     *     };
     *     DWORD cKeyAgreeKeyEncryptInfo;
     *     PCMSG_KEY_AGREE_KEY_ENCRYPT_INFO *rgpKeyAgreeKeyEncryptInfo;
     *     DWORD dwFlags;
     * } *PCMSG_KEY_AGREE_ENCRYPT_INFO
     * }
     */
    public static final AddressLayout PCMSG_KEY_AGREE_ENCRYPT_INFO = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CMSG_MAIL_LIST_ENCRYPT_INFO {
     *     DWORD cbSize;
     *     DWORD dwRecipientIndex;
     *     CRYPT_ALGORITHM_IDENTIFIER KeyEncryptionAlgorithm;
     *     CRYPT_DATA_BLOB EncryptedKey;
     *     DWORD dwFlags;
     * } *PCMSG_MAIL_LIST_ENCRYPT_INFO
     * }
     */
    public static final AddressLayout PCMSG_MAIL_LIST_ENCRYPT_INFO = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CMSG_CNG_CONTENT_DECRYPT_INFO {
     *     DWORD cbSize;
     *     CRYPT_ALGORITHM_IDENTIFIER ContentEncryptionAlgorithm;
     *     PFN_CMSG_ALLOC pfnAlloc;
     *     PFN_CMSG_FREE pfnFree;
     *     NCRYPT_KEY_HANDLE hNCryptKey;
     *     BYTE *pbContentEncryptKey;
     *     DWORD cbContentEncryptKey;
     *     BCRYPT_KEY_HANDLE hCNGContentEncryptKey;
     *     BYTE *pbCNGContentEncryptKeyObject;
     * } *PCMSG_CNG_CONTENT_DECRYPT_INFO
     * }
     */
    public static final AddressLayout PCMSG_CNG_CONTENT_DECRYPT_INFO = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef void *HCERTSTORE
     * }
     */
    public static final AddressLayout HCERTSTORE = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CERT_CONTEXT {
     *     DWORD dwCertEncodingType;
     *     BYTE *pbCertEncoded;
     *     DWORD cbCertEncoded;
     *     PCERT_INFO pCertInfo;
     *     HCERTSTORE hCertStore;
     * } *PCERT_CONTEXT
     * }
     */
    public static final AddressLayout PCERT_CONTEXT = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef const CERT_CONTEXT *PCCERT_CONTEXT
     * }
     */
    public static final AddressLayout PCCERT_CONTEXT = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CRL_CONTEXT {
     *     DWORD dwCertEncodingType;
     *     BYTE *pbCrlEncoded;
     *     DWORD cbCrlEncoded;
     *     PCRL_INFO pCrlInfo;
     *     HCERTSTORE hCertStore;
     * } *PCRL_CONTEXT
     * }
     */
    public static final AddressLayout PCRL_CONTEXT = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef const CRL_CONTEXT *PCCRL_CONTEXT
     * }
     */
    public static final AddressLayout PCCRL_CONTEXT = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CTL_CONTEXT {
     *     DWORD dwMsgAndCertEncodingType;
     *     BYTE *pbCtlEncoded;
     *     DWORD cbCtlEncoded;
     *     PCTL_INFO pCtlInfo;
     *     HCERTSTORE hCertStore;
     *     HCRYPTMSG hCryptMsg;
     *     BYTE *pbCtlContent;
     *     DWORD cbCtlContent;
     * } *PCTL_CONTEXT
     * }
     */
    public static final AddressLayout PCTL_CONTEXT = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef const CTL_CONTEXT *PCCTL_CONTEXT
     * }
     */
    public static final AddressLayout PCCTL_CONTEXT = C_POINTER;
    private static final int KeyTypeOther = (int)0L;
    /**
     * {@snippet lang=c :
     * enum CertKeyType.KeyTypeOther = 0
     * }
     */
    public static int KeyTypeOther() {
        return KeyTypeOther;
    }
    private static final int KeyTypeVirtualSmartCard = (int)1L;
    /**
     * {@snippet lang=c :
     * enum CertKeyType.KeyTypeVirtualSmartCard = 1
     * }
     */
    public static int KeyTypeVirtualSmartCard() {
        return KeyTypeVirtualSmartCard;
    }
    private static final int KeyTypePhysicalSmartCard = (int)2L;
    /**
     * {@snippet lang=c :
     * enum CertKeyType.KeyTypePhysicalSmartCard = 2
     * }
     */
    public static int KeyTypePhysicalSmartCard() {
        return KeyTypePhysicalSmartCard;
    }
    private static final int KeyTypePassport = (int)3L;
    /**
     * {@snippet lang=c :
     * enum CertKeyType.KeyTypePassport = 3
     * }
     */
    public static int KeyTypePassport() {
        return KeyTypePassport;
    }
    private static final int KeyTypePassportRemote = (int)4L;
    /**
     * {@snippet lang=c :
     * enum CertKeyType.KeyTypePassportRemote = 4
     * }
     */
    public static int KeyTypePassportRemote() {
        return KeyTypePassportRemote;
    }
    private static final int KeyTypePassportSmartCard = (int)5L;
    /**
     * {@snippet lang=c :
     * enum CertKeyType.KeyTypePassportSmartCard = 5
     * }
     */
    public static int KeyTypePassportSmartCard() {
        return KeyTypePassportSmartCard;
    }
    private static final int KeyTypeHardware = (int)6L;
    /**
     * {@snippet lang=c :
     * enum CertKeyType.KeyTypeHardware = 6
     * }
     */
    public static int KeyTypeHardware() {
        return KeyTypeHardware;
    }
    private static final int KeyTypeSoftware = (int)7L;
    /**
     * {@snippet lang=c :
     * enum CertKeyType.KeyTypeSoftware = 7
     * }
     */
    public static int KeyTypeSoftware() {
        return KeyTypeSoftware;
    }
    private static final int KeyTypeSelfSigned = (int)8L;
    /**
     * {@snippet lang=c :
     * enum CertKeyType.KeyTypeSelfSigned = 8
     * }
     */
    public static int KeyTypeSelfSigned() {
        return KeyTypeSelfSigned;
    }
    /**
     * {@snippet lang=c :
     * typedef struct _CRYPT_KEY_PROV_PARAM {
     *     DWORD dwParam;
     *     BYTE *pbData;
     *     DWORD cbData;
     *     DWORD dwFlags;
     * } *PCRYPT_KEY_PROV_PARAM
     * }
     */
    public static final AddressLayout PCRYPT_KEY_PROV_PARAM = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CRYPT_KEY_PROV_INFO {
     *     LPWSTR pwszContainerName;
     *     LPWSTR pwszProvName;
     *     DWORD dwProvType;
     *     DWORD dwFlags;
     *     DWORD cProvParam;
     *     PCRYPT_KEY_PROV_PARAM rgProvParam;
     *     DWORD dwKeySpec;
     * } *PCRYPT_KEY_PROV_INFO
     * }
     */
    public static final AddressLayout PCRYPT_KEY_PROV_INFO = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CERT_KEY_CONTEXT {
     *     DWORD cbSize;
     *     union {
     *         HCRYPTPROV hCryptProv;
     *         NCRYPT_KEY_HANDLE hNCryptKey;
     *     };
     *     DWORD dwKeySpec;
     * } *PCERT_KEY_CONTEXT
     * }
     */
    public static final AddressLayout PCERT_KEY_CONTEXT = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _ROOT_INFO_LUID {
     *     DWORD LowPart;
     *     LONG HighPart;
     * } *PROOT_INFO_LUID
     * }
     */
    public static final AddressLayout PROOT_INFO_LUID = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CRYPT_SMART_CARD_ROOT_INFO {
     *     BYTE rgbCardID[16];
     *     ROOT_INFO_LUID luid;
     * } *PCRYPT_SMART_CARD_ROOT_INFO
     * }
     */
    public static final AddressLayout PCRYPT_SMART_CARD_ROOT_INFO = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CERT_SYSTEM_STORE_RELOCATE_PARA {
     *     union {
     *         HKEY hKeyBase;
     *         void *pvBase;
     *     };
     *     union {
     *         void *pvSystemStore;
     *         LPCSTR pszSystemStore;
     *         LPCWSTR pwszSystemStore;
     *     };
     * } *PCERT_SYSTEM_STORE_RELOCATE_PARA
     * }
     */
    public static final AddressLayout PCERT_SYSTEM_STORE_RELOCATE_PARA = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CERT_REGISTRY_STORE_CLIENT_GPT_PARA {
     *     HKEY hKeyBase;
     *     LPWSTR pwszRegPath;
     * } *PCERT_REGISTRY_STORE_CLIENT_GPT_PARA
     * }
     */
    public static final AddressLayout PCERT_REGISTRY_STORE_CLIENT_GPT_PARA = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CERT_REGISTRY_STORE_ROAMING_PARA {
     *     HKEY hKey;
     *     LPWSTR pwszStoreDirectory;
     * } *PCERT_REGISTRY_STORE_ROAMING_PARA
     * }
     */
    public static final AddressLayout PCERT_REGISTRY_STORE_ROAMING_PARA = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CERT_LDAP_STORE_OPENED_PARA {
     *     void *pvLdapSessionHandle;
     *     LPCWSTR pwszLdapUrl;
     * } *PCERT_LDAP_STORE_OPENED_PARA
     * }
     */
    public static final AddressLayout PCERT_LDAP_STORE_OPENED_PARA = C_POINTER;

    private static class CertOpenStore {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER,
            C_LONG,
            C_LONG_LONG,
            C_LONG,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CertOpenStore"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HCERTSTORE CertOpenStore(LPCSTR lpszStoreProvider, DWORD dwEncodingType, HCRYPTPROV_LEGACY hCryptProv, DWORD dwFlags, const void *pvPara)
     * }
     */
    public static FunctionDescriptor CertOpenStore$descriptor() {
        return CertOpenStore.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HCERTSTORE CertOpenStore(LPCSTR lpszStoreProvider, DWORD dwEncodingType, HCRYPTPROV_LEGACY hCryptProv, DWORD dwFlags, const void *pvPara)
     * }
     */
    public static MethodHandle CertOpenStore$handle() {
        return CertOpenStore.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * HCERTSTORE CertOpenStore(LPCSTR lpszStoreProvider, DWORD dwEncodingType, HCRYPTPROV_LEGACY hCryptProv, DWORD dwFlags, const void *pvPara)
     * }
     */
    public static MemorySegment CertOpenStore(MemorySegment lpszStoreProvider, int dwEncodingType, long hCryptProv, int dwFlags, MemorySegment pvPara) {
        var mh$ = CertOpenStore.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CertOpenStore", lpszStoreProvider, dwEncodingType, hCryptProv, dwFlags, pvPara);
            }
            return (MemorySegment)mh$.invokeExact(lpszStoreProvider, dwEncodingType, hCryptProv, dwFlags, pvPara);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef void *HCERTSTOREPROV
     * }
     */
    public static final AddressLayout HCERTSTOREPROV = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CERT_STORE_PROV_INFO {
     *     DWORD cbSize;
     *     DWORD cStoreProvFunc;
     *     void **rgpvStoreProvFunc;
     *     HCERTSTOREPROV hStoreProv;
     *     DWORD dwStoreProvFlags;
     *     HCRYPTOIDFUNCADDR hStoreProvFuncAddr2;
     * } *PCERT_STORE_PROV_INFO
     * }
     */
    public static final AddressLayout PCERT_STORE_PROV_INFO = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CERT_STORE_PROV_FIND_INFO {
     *     DWORD cbSize;
     *     DWORD dwMsgAndCertEncodingType;
     *     DWORD dwFindFlags;
     *     DWORD dwFindType;
     *     const void *pvFindPara;
     * } *PCERT_STORE_PROV_FIND_INFO
     * }
     */
    public static final AddressLayout PCERT_STORE_PROV_FIND_INFO = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef const CERT_STORE_PROV_FIND_INFO *PCCERT_STORE_PROV_FIND_INFO
     * }
     */
    public static final AddressLayout PCCERT_STORE_PROV_FIND_INFO = C_POINTER;

    private static class CertDuplicateStore {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CertDuplicateStore"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HCERTSTORE CertDuplicateStore(HCERTSTORE hCertStore)
     * }
     */
    public static FunctionDescriptor CertDuplicateStore$descriptor() {
        return CertDuplicateStore.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HCERTSTORE CertDuplicateStore(HCERTSTORE hCertStore)
     * }
     */
    public static MethodHandle CertDuplicateStore$handle() {
        return CertDuplicateStore.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * HCERTSTORE CertDuplicateStore(HCERTSTORE hCertStore)
     * }
     */
    public static MemorySegment CertDuplicateStore(MemorySegment hCertStore) {
        var mh$ = CertDuplicateStore.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CertDuplicateStore", hCertStore);
            }
            return (MemorySegment)mh$.invokeExact(hCertStore);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CertSaveStore {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_LONG,
            C_LONG,
            C_LONG,
            C_POINTER,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CertSaveStore"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CertSaveStore(HCERTSTORE hCertStore, DWORD dwEncodingType, DWORD dwSaveAs, DWORD dwSaveTo, void *pvSaveToPara, DWORD dwFlags)
     * }
     */
    public static FunctionDescriptor CertSaveStore$descriptor() {
        return CertSaveStore.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CertSaveStore(HCERTSTORE hCertStore, DWORD dwEncodingType, DWORD dwSaveAs, DWORD dwSaveTo, void *pvSaveToPara, DWORD dwFlags)
     * }
     */
    public static MethodHandle CertSaveStore$handle() {
        return CertSaveStore.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL CertSaveStore(HCERTSTORE hCertStore, DWORD dwEncodingType, DWORD dwSaveAs, DWORD dwSaveTo, void *pvSaveToPara, DWORD dwFlags)
     * }
     */
    public static int CertSaveStore(MemorySegment hCertStore, int dwEncodingType, int dwSaveAs, int dwSaveTo, MemorySegment pvSaveToPara, int dwFlags) {
        var mh$ = CertSaveStore.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CertSaveStore", hCertStore, dwEncodingType, dwSaveAs, dwSaveTo, pvSaveToPara, dwFlags);
            }
            return (int)mh$.invokeExact(hCertStore, dwEncodingType, dwSaveAs, dwSaveTo, pvSaveToPara, dwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CertCloseStore {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CertCloseStore"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CertCloseStore(HCERTSTORE hCertStore, DWORD dwFlags)
     * }
     */
    public static FunctionDescriptor CertCloseStore$descriptor() {
        return CertCloseStore.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CertCloseStore(HCERTSTORE hCertStore, DWORD dwFlags)
     * }
     */
    public static MethodHandle CertCloseStore$handle() {
        return CertCloseStore.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL CertCloseStore(HCERTSTORE hCertStore, DWORD dwFlags)
     * }
     */
    public static int CertCloseStore(MemorySegment hCertStore, int dwFlags) {
        var mh$ = CertCloseStore.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CertCloseStore", hCertStore, dwFlags);
            }
            return (int)mh$.invokeExact(hCertStore, dwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CertGetSubjectCertificateFromStore {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER,
            C_LONG,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CertGetSubjectCertificateFromStore"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PCCERT_CONTEXT CertGetSubjectCertificateFromStore(HCERTSTORE hCertStore, DWORD dwCertEncodingType, PCERT_INFO pCertId)
     * }
     */
    public static FunctionDescriptor CertGetSubjectCertificateFromStore$descriptor() {
        return CertGetSubjectCertificateFromStore.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PCCERT_CONTEXT CertGetSubjectCertificateFromStore(HCERTSTORE hCertStore, DWORD dwCertEncodingType, PCERT_INFO pCertId)
     * }
     */
    public static MethodHandle CertGetSubjectCertificateFromStore$handle() {
        return CertGetSubjectCertificateFromStore.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * PCCERT_CONTEXT CertGetSubjectCertificateFromStore(HCERTSTORE hCertStore, DWORD dwCertEncodingType, PCERT_INFO pCertId)
     * }
     */
    public static MemorySegment CertGetSubjectCertificateFromStore(MemorySegment hCertStore, int dwCertEncodingType, MemorySegment pCertId) {
        var mh$ = CertGetSubjectCertificateFromStore.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CertGetSubjectCertificateFromStore", hCertStore, dwCertEncodingType, pCertId);
            }
            return (MemorySegment)mh$.invokeExact(hCertStore, dwCertEncodingType, pCertId);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CertEnumCertificatesInStore {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CertEnumCertificatesInStore"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PCCERT_CONTEXT CertEnumCertificatesInStore(HCERTSTORE hCertStore, PCCERT_CONTEXT pPrevCertContext)
     * }
     */
    public static FunctionDescriptor CertEnumCertificatesInStore$descriptor() {
        return CertEnumCertificatesInStore.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PCCERT_CONTEXT CertEnumCertificatesInStore(HCERTSTORE hCertStore, PCCERT_CONTEXT pPrevCertContext)
     * }
     */
    public static MethodHandle CertEnumCertificatesInStore$handle() {
        return CertEnumCertificatesInStore.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * PCCERT_CONTEXT CertEnumCertificatesInStore(HCERTSTORE hCertStore, PCCERT_CONTEXT pPrevCertContext)
     * }
     */
    public static MemorySegment CertEnumCertificatesInStore(MemorySegment hCertStore, MemorySegment pPrevCertContext) {
        var mh$ = CertEnumCertificatesInStore.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CertEnumCertificatesInStore", hCertStore, pPrevCertContext);
            }
            return (MemorySegment)mh$.invokeExact(hCertStore, pPrevCertContext);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CertFindCertificateInStore {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER,
            C_LONG,
            C_LONG,
            C_LONG,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CertFindCertificateInStore"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PCCERT_CONTEXT CertFindCertificateInStore(HCERTSTORE hCertStore, DWORD dwCertEncodingType, DWORD dwFindFlags, DWORD dwFindType, const void *pvFindPara, PCCERT_CONTEXT pPrevCertContext)
     * }
     */
    public static FunctionDescriptor CertFindCertificateInStore$descriptor() {
        return CertFindCertificateInStore.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PCCERT_CONTEXT CertFindCertificateInStore(HCERTSTORE hCertStore, DWORD dwCertEncodingType, DWORD dwFindFlags, DWORD dwFindType, const void *pvFindPara, PCCERT_CONTEXT pPrevCertContext)
     * }
     */
    public static MethodHandle CertFindCertificateInStore$handle() {
        return CertFindCertificateInStore.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * PCCERT_CONTEXT CertFindCertificateInStore(HCERTSTORE hCertStore, DWORD dwCertEncodingType, DWORD dwFindFlags, DWORD dwFindType, const void *pvFindPara, PCCERT_CONTEXT pPrevCertContext)
     * }
     */
    public static MemorySegment CertFindCertificateInStore(MemorySegment hCertStore, int dwCertEncodingType, int dwFindFlags, int dwFindType, MemorySegment pvFindPara, MemorySegment pPrevCertContext) {
        var mh$ = CertFindCertificateInStore.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CertFindCertificateInStore", hCertStore, dwCertEncodingType, dwFindFlags, dwFindType, pvFindPara, pPrevCertContext);
            }
            return (MemorySegment)mh$.invokeExact(hCertStore, dwCertEncodingType, dwFindFlags, dwFindType, pvFindPara, pPrevCertContext);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CertGetIssuerCertificateFromStore {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CertGetIssuerCertificateFromStore"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PCCERT_CONTEXT CertGetIssuerCertificateFromStore(HCERTSTORE hCertStore, PCCERT_CONTEXT pSubjectContext, PCCERT_CONTEXT pPrevIssuerContext, DWORD *pdwFlags)
     * }
     */
    public static FunctionDescriptor CertGetIssuerCertificateFromStore$descriptor() {
        return CertGetIssuerCertificateFromStore.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PCCERT_CONTEXT CertGetIssuerCertificateFromStore(HCERTSTORE hCertStore, PCCERT_CONTEXT pSubjectContext, PCCERT_CONTEXT pPrevIssuerContext, DWORD *pdwFlags)
     * }
     */
    public static MethodHandle CertGetIssuerCertificateFromStore$handle() {
        return CertGetIssuerCertificateFromStore.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * PCCERT_CONTEXT CertGetIssuerCertificateFromStore(HCERTSTORE hCertStore, PCCERT_CONTEXT pSubjectContext, PCCERT_CONTEXT pPrevIssuerContext, DWORD *pdwFlags)
     * }
     */
    public static MemorySegment CertGetIssuerCertificateFromStore(MemorySegment hCertStore, MemorySegment pSubjectContext, MemorySegment pPrevIssuerContext, MemorySegment pdwFlags) {
        var mh$ = CertGetIssuerCertificateFromStore.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CertGetIssuerCertificateFromStore", hCertStore, pSubjectContext, pPrevIssuerContext, pdwFlags);
            }
            return (MemorySegment)mh$.invokeExact(hCertStore, pSubjectContext, pPrevIssuerContext, pdwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CertVerifySubjectCertificateContext {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CertVerifySubjectCertificateContext"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CertVerifySubjectCertificateContext(PCCERT_CONTEXT pSubject, PCCERT_CONTEXT pIssuer, DWORD *pdwFlags)
     * }
     */
    public static FunctionDescriptor CertVerifySubjectCertificateContext$descriptor() {
        return CertVerifySubjectCertificateContext.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CertVerifySubjectCertificateContext(PCCERT_CONTEXT pSubject, PCCERT_CONTEXT pIssuer, DWORD *pdwFlags)
     * }
     */
    public static MethodHandle CertVerifySubjectCertificateContext$handle() {
        return CertVerifySubjectCertificateContext.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL CertVerifySubjectCertificateContext(PCCERT_CONTEXT pSubject, PCCERT_CONTEXT pIssuer, DWORD *pdwFlags)
     * }
     */
    public static int CertVerifySubjectCertificateContext(MemorySegment pSubject, MemorySegment pIssuer, MemorySegment pdwFlags) {
        var mh$ = CertVerifySubjectCertificateContext.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CertVerifySubjectCertificateContext", pSubject, pIssuer, pdwFlags);
            }
            return (int)mh$.invokeExact(pSubject, pIssuer, pdwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CertDuplicateCertificateContext {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CertDuplicateCertificateContext"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PCCERT_CONTEXT CertDuplicateCertificateContext(PCCERT_CONTEXT pCertContext)
     * }
     */
    public static FunctionDescriptor CertDuplicateCertificateContext$descriptor() {
        return CertDuplicateCertificateContext.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PCCERT_CONTEXT CertDuplicateCertificateContext(PCCERT_CONTEXT pCertContext)
     * }
     */
    public static MethodHandle CertDuplicateCertificateContext$handle() {
        return CertDuplicateCertificateContext.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * PCCERT_CONTEXT CertDuplicateCertificateContext(PCCERT_CONTEXT pCertContext)
     * }
     */
    public static MemorySegment CertDuplicateCertificateContext(MemorySegment pCertContext) {
        var mh$ = CertDuplicateCertificateContext.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CertDuplicateCertificateContext", pCertContext);
            }
            return (MemorySegment)mh$.invokeExact(pCertContext);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CertCreateCertificateContext {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_LONG,
            C_POINTER,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CertCreateCertificateContext"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PCCERT_CONTEXT CertCreateCertificateContext(DWORD dwCertEncodingType, const BYTE *pbCertEncoded, DWORD cbCertEncoded)
     * }
     */
    public static FunctionDescriptor CertCreateCertificateContext$descriptor() {
        return CertCreateCertificateContext.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PCCERT_CONTEXT CertCreateCertificateContext(DWORD dwCertEncodingType, const BYTE *pbCertEncoded, DWORD cbCertEncoded)
     * }
     */
    public static MethodHandle CertCreateCertificateContext$handle() {
        return CertCreateCertificateContext.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * PCCERT_CONTEXT CertCreateCertificateContext(DWORD dwCertEncodingType, const BYTE *pbCertEncoded, DWORD cbCertEncoded)
     * }
     */
    public static MemorySegment CertCreateCertificateContext(int dwCertEncodingType, MemorySegment pbCertEncoded, int cbCertEncoded) {
        var mh$ = CertCreateCertificateContext.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CertCreateCertificateContext", dwCertEncodingType, pbCertEncoded, cbCertEncoded);
            }
            return (MemorySegment)mh$.invokeExact(dwCertEncodingType, pbCertEncoded, cbCertEncoded);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CertFreeCertificateContext {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CertFreeCertificateContext"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CertFreeCertificateContext(PCCERT_CONTEXT pCertContext)
     * }
     */
    public static FunctionDescriptor CertFreeCertificateContext$descriptor() {
        return CertFreeCertificateContext.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CertFreeCertificateContext(PCCERT_CONTEXT pCertContext)
     * }
     */
    public static MethodHandle CertFreeCertificateContext$handle() {
        return CertFreeCertificateContext.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL CertFreeCertificateContext(PCCERT_CONTEXT pCertContext)
     * }
     */
    public static int CertFreeCertificateContext(MemorySegment pCertContext) {
        var mh$ = CertFreeCertificateContext.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CertFreeCertificateContext", pCertContext);
            }
            return (int)mh$.invokeExact(pCertContext);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CertSetCertificateContextProperty {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_LONG,
            C_LONG,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CertSetCertificateContextProperty"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CertSetCertificateContextProperty(PCCERT_CONTEXT pCertContext, DWORD dwPropId, DWORD dwFlags, const void *pvData)
     * }
     */
    public static FunctionDescriptor CertSetCertificateContextProperty$descriptor() {
        return CertSetCertificateContextProperty.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CertSetCertificateContextProperty(PCCERT_CONTEXT pCertContext, DWORD dwPropId, DWORD dwFlags, const void *pvData)
     * }
     */
    public static MethodHandle CertSetCertificateContextProperty$handle() {
        return CertSetCertificateContextProperty.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL CertSetCertificateContextProperty(PCCERT_CONTEXT pCertContext, DWORD dwPropId, DWORD dwFlags, const void *pvData)
     * }
     */
    public static int CertSetCertificateContextProperty(MemorySegment pCertContext, int dwPropId, int dwFlags, MemorySegment pvData) {
        var mh$ = CertSetCertificateContextProperty.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CertSetCertificateContextProperty", pCertContext, dwPropId, dwFlags, pvData);
            }
            return (int)mh$.invokeExact(pCertContext, dwPropId, dwFlags, pvData);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CertGetCertificateContextProperty {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_LONG,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CertGetCertificateContextProperty"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CertGetCertificateContextProperty(PCCERT_CONTEXT pCertContext, DWORD dwPropId, void *pvData, DWORD *pcbData)
     * }
     */
    public static FunctionDescriptor CertGetCertificateContextProperty$descriptor() {
        return CertGetCertificateContextProperty.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CertGetCertificateContextProperty(PCCERT_CONTEXT pCertContext, DWORD dwPropId, void *pvData, DWORD *pcbData)
     * }
     */
    public static MethodHandle CertGetCertificateContextProperty$handle() {
        return CertGetCertificateContextProperty.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL CertGetCertificateContextProperty(PCCERT_CONTEXT pCertContext, DWORD dwPropId, void *pvData, DWORD *pcbData)
     * }
     */
    public static int CertGetCertificateContextProperty(MemorySegment pCertContext, int dwPropId, MemorySegment pvData, MemorySegment pcbData) {
        var mh$ = CertGetCertificateContextProperty.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CertGetCertificateContextProperty", pCertContext, dwPropId, pvData, pcbData);
            }
            return (int)mh$.invokeExact(pCertContext, dwPropId, pvData, pcbData);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CertEnumCertificateContextProperties {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_POINTER,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CertEnumCertificateContextProperties"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD CertEnumCertificateContextProperties(PCCERT_CONTEXT pCertContext, DWORD dwPropId)
     * }
     */
    public static FunctionDescriptor CertEnumCertificateContextProperties$descriptor() {
        return CertEnumCertificateContextProperties.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD CertEnumCertificateContextProperties(PCCERT_CONTEXT pCertContext, DWORD dwPropId)
     * }
     */
    public static MethodHandle CertEnumCertificateContextProperties$handle() {
        return CertEnumCertificateContextProperties.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * DWORD CertEnumCertificateContextProperties(PCCERT_CONTEXT pCertContext, DWORD dwPropId)
     * }
     */
    public static int CertEnumCertificateContextProperties(MemorySegment pCertContext, int dwPropId) {
        var mh$ = CertEnumCertificateContextProperties.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CertEnumCertificateContextProperties", pCertContext, dwPropId);
            }
            return (int)mh$.invokeExact(pCertContext, dwPropId);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CertCreateCTLEntryFromCertificateContextProperties {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_LONG,
            C_POINTER,
            C_LONG,
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CertCreateCTLEntryFromCertificateContextProperties"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CertCreateCTLEntryFromCertificateContextProperties(PCCERT_CONTEXT pCertContext, DWORD cOptAttr, PCRYPT_ATTRIBUTE rgOptAttr, DWORD dwFlags, void *pvReserved, PCTL_ENTRY pCtlEntry, DWORD *pcbCtlEntry)
     * }
     */
    public static FunctionDescriptor CertCreateCTLEntryFromCertificateContextProperties$descriptor() {
        return CertCreateCTLEntryFromCertificateContextProperties.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CertCreateCTLEntryFromCertificateContextProperties(PCCERT_CONTEXT pCertContext, DWORD cOptAttr, PCRYPT_ATTRIBUTE rgOptAttr, DWORD dwFlags, void *pvReserved, PCTL_ENTRY pCtlEntry, DWORD *pcbCtlEntry)
     * }
     */
    public static MethodHandle CertCreateCTLEntryFromCertificateContextProperties$handle() {
        return CertCreateCTLEntryFromCertificateContextProperties.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL CertCreateCTLEntryFromCertificateContextProperties(PCCERT_CONTEXT pCertContext, DWORD cOptAttr, PCRYPT_ATTRIBUTE rgOptAttr, DWORD dwFlags, void *pvReserved, PCTL_ENTRY pCtlEntry, DWORD *pcbCtlEntry)
     * }
     */
    public static int CertCreateCTLEntryFromCertificateContextProperties(MemorySegment pCertContext, int cOptAttr, MemorySegment rgOptAttr, int dwFlags, MemorySegment pvReserved, MemorySegment pCtlEntry, MemorySegment pcbCtlEntry) {
        var mh$ = CertCreateCTLEntryFromCertificateContextProperties.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CertCreateCTLEntryFromCertificateContextProperties", pCertContext, cOptAttr, rgOptAttr, dwFlags, pvReserved, pCtlEntry, pcbCtlEntry);
            }
            return (int)mh$.invokeExact(pCertContext, cOptAttr, rgOptAttr, dwFlags, pvReserved, pCtlEntry, pcbCtlEntry);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CertSetCertificateContextPropertiesFromCTLEntry {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CertSetCertificateContextPropertiesFromCTLEntry"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CertSetCertificateContextPropertiesFromCTLEntry(PCCERT_CONTEXT pCertContext, PCTL_ENTRY pCtlEntry, DWORD dwFlags)
     * }
     */
    public static FunctionDescriptor CertSetCertificateContextPropertiesFromCTLEntry$descriptor() {
        return CertSetCertificateContextPropertiesFromCTLEntry.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CertSetCertificateContextPropertiesFromCTLEntry(PCCERT_CONTEXT pCertContext, PCTL_ENTRY pCtlEntry, DWORD dwFlags)
     * }
     */
    public static MethodHandle CertSetCertificateContextPropertiesFromCTLEntry$handle() {
        return CertSetCertificateContextPropertiesFromCTLEntry.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL CertSetCertificateContextPropertiesFromCTLEntry(PCCERT_CONTEXT pCertContext, PCTL_ENTRY pCtlEntry, DWORD dwFlags)
     * }
     */
    public static int CertSetCertificateContextPropertiesFromCTLEntry(MemorySegment pCertContext, MemorySegment pCtlEntry, int dwFlags) {
        var mh$ = CertSetCertificateContextPropertiesFromCTLEntry.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CertSetCertificateContextPropertiesFromCTLEntry", pCertContext, pCtlEntry, dwFlags);
            }
            return (int)mh$.invokeExact(pCertContext, pCtlEntry, dwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CertGetCRLFromStore {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CertGetCRLFromStore"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PCCRL_CONTEXT CertGetCRLFromStore(HCERTSTORE hCertStore, PCCERT_CONTEXT pIssuerContext, PCCRL_CONTEXT pPrevCrlContext, DWORD *pdwFlags)
     * }
     */
    public static FunctionDescriptor CertGetCRLFromStore$descriptor() {
        return CertGetCRLFromStore.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PCCRL_CONTEXT CertGetCRLFromStore(HCERTSTORE hCertStore, PCCERT_CONTEXT pIssuerContext, PCCRL_CONTEXT pPrevCrlContext, DWORD *pdwFlags)
     * }
     */
    public static MethodHandle CertGetCRLFromStore$handle() {
        return CertGetCRLFromStore.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * PCCRL_CONTEXT CertGetCRLFromStore(HCERTSTORE hCertStore, PCCERT_CONTEXT pIssuerContext, PCCRL_CONTEXT pPrevCrlContext, DWORD *pdwFlags)
     * }
     */
    public static MemorySegment CertGetCRLFromStore(MemorySegment hCertStore, MemorySegment pIssuerContext, MemorySegment pPrevCrlContext, MemorySegment pdwFlags) {
        var mh$ = CertGetCRLFromStore.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CertGetCRLFromStore", hCertStore, pIssuerContext, pPrevCrlContext, pdwFlags);
            }
            return (MemorySegment)mh$.invokeExact(hCertStore, pIssuerContext, pPrevCrlContext, pdwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CertEnumCRLsInStore {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CertEnumCRLsInStore"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PCCRL_CONTEXT CertEnumCRLsInStore(HCERTSTORE hCertStore, PCCRL_CONTEXT pPrevCrlContext)
     * }
     */
    public static FunctionDescriptor CertEnumCRLsInStore$descriptor() {
        return CertEnumCRLsInStore.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PCCRL_CONTEXT CertEnumCRLsInStore(HCERTSTORE hCertStore, PCCRL_CONTEXT pPrevCrlContext)
     * }
     */
    public static MethodHandle CertEnumCRLsInStore$handle() {
        return CertEnumCRLsInStore.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * PCCRL_CONTEXT CertEnumCRLsInStore(HCERTSTORE hCertStore, PCCRL_CONTEXT pPrevCrlContext)
     * }
     */
    public static MemorySegment CertEnumCRLsInStore(MemorySegment hCertStore, MemorySegment pPrevCrlContext) {
        var mh$ = CertEnumCRLsInStore.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CertEnumCRLsInStore", hCertStore, pPrevCrlContext);
            }
            return (MemorySegment)mh$.invokeExact(hCertStore, pPrevCrlContext);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CertFindCRLInStore {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER,
            C_LONG,
            C_LONG,
            C_LONG,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CertFindCRLInStore"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PCCRL_CONTEXT CertFindCRLInStore(HCERTSTORE hCertStore, DWORD dwCertEncodingType, DWORD dwFindFlags, DWORD dwFindType, const void *pvFindPara, PCCRL_CONTEXT pPrevCrlContext)
     * }
     */
    public static FunctionDescriptor CertFindCRLInStore$descriptor() {
        return CertFindCRLInStore.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PCCRL_CONTEXT CertFindCRLInStore(HCERTSTORE hCertStore, DWORD dwCertEncodingType, DWORD dwFindFlags, DWORD dwFindType, const void *pvFindPara, PCCRL_CONTEXT pPrevCrlContext)
     * }
     */
    public static MethodHandle CertFindCRLInStore$handle() {
        return CertFindCRLInStore.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * PCCRL_CONTEXT CertFindCRLInStore(HCERTSTORE hCertStore, DWORD dwCertEncodingType, DWORD dwFindFlags, DWORD dwFindType, const void *pvFindPara, PCCRL_CONTEXT pPrevCrlContext)
     * }
     */
    public static MemorySegment CertFindCRLInStore(MemorySegment hCertStore, int dwCertEncodingType, int dwFindFlags, int dwFindType, MemorySegment pvFindPara, MemorySegment pPrevCrlContext) {
        var mh$ = CertFindCRLInStore.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CertFindCRLInStore", hCertStore, dwCertEncodingType, dwFindFlags, dwFindType, pvFindPara, pPrevCrlContext);
            }
            return (MemorySegment)mh$.invokeExact(hCertStore, dwCertEncodingType, dwFindFlags, dwFindType, pvFindPara, pPrevCrlContext);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct _CRL_FIND_ISSUED_FOR_PARA {
     *     PCCERT_CONTEXT pSubjectCert;
     *     PCCERT_CONTEXT pIssuerCert;
     * } *PCRL_FIND_ISSUED_FOR_PARA
     * }
     */
    public static final AddressLayout PCRL_FIND_ISSUED_FOR_PARA = C_POINTER;

    private static class CertDuplicateCRLContext {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CertDuplicateCRLContext"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PCCRL_CONTEXT CertDuplicateCRLContext(PCCRL_CONTEXT pCrlContext)
     * }
     */
    public static FunctionDescriptor CertDuplicateCRLContext$descriptor() {
        return CertDuplicateCRLContext.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PCCRL_CONTEXT CertDuplicateCRLContext(PCCRL_CONTEXT pCrlContext)
     * }
     */
    public static MethodHandle CertDuplicateCRLContext$handle() {
        return CertDuplicateCRLContext.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * PCCRL_CONTEXT CertDuplicateCRLContext(PCCRL_CONTEXT pCrlContext)
     * }
     */
    public static MemorySegment CertDuplicateCRLContext(MemorySegment pCrlContext) {
        var mh$ = CertDuplicateCRLContext.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CertDuplicateCRLContext", pCrlContext);
            }
            return (MemorySegment)mh$.invokeExact(pCrlContext);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CertCreateCRLContext {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_LONG,
            C_POINTER,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CertCreateCRLContext"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PCCRL_CONTEXT CertCreateCRLContext(DWORD dwCertEncodingType, const BYTE *pbCrlEncoded, DWORD cbCrlEncoded)
     * }
     */
    public static FunctionDescriptor CertCreateCRLContext$descriptor() {
        return CertCreateCRLContext.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PCCRL_CONTEXT CertCreateCRLContext(DWORD dwCertEncodingType, const BYTE *pbCrlEncoded, DWORD cbCrlEncoded)
     * }
     */
    public static MethodHandle CertCreateCRLContext$handle() {
        return CertCreateCRLContext.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * PCCRL_CONTEXT CertCreateCRLContext(DWORD dwCertEncodingType, const BYTE *pbCrlEncoded, DWORD cbCrlEncoded)
     * }
     */
    public static MemorySegment CertCreateCRLContext(int dwCertEncodingType, MemorySegment pbCrlEncoded, int cbCrlEncoded) {
        var mh$ = CertCreateCRLContext.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CertCreateCRLContext", dwCertEncodingType, pbCrlEncoded, cbCrlEncoded);
            }
            return (MemorySegment)mh$.invokeExact(dwCertEncodingType, pbCrlEncoded, cbCrlEncoded);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CertFreeCRLContext {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CertFreeCRLContext"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CertFreeCRLContext(PCCRL_CONTEXT pCrlContext)
     * }
     */
    public static FunctionDescriptor CertFreeCRLContext$descriptor() {
        return CertFreeCRLContext.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CertFreeCRLContext(PCCRL_CONTEXT pCrlContext)
     * }
     */
    public static MethodHandle CertFreeCRLContext$handle() {
        return CertFreeCRLContext.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL CertFreeCRLContext(PCCRL_CONTEXT pCrlContext)
     * }
     */
    public static int CertFreeCRLContext(MemorySegment pCrlContext) {
        var mh$ = CertFreeCRLContext.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CertFreeCRLContext", pCrlContext);
            }
            return (int)mh$.invokeExact(pCrlContext);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CertSetCRLContextProperty {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_LONG,
            C_LONG,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CertSetCRLContextProperty"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CertSetCRLContextProperty(PCCRL_CONTEXT pCrlContext, DWORD dwPropId, DWORD dwFlags, const void *pvData)
     * }
     */
    public static FunctionDescriptor CertSetCRLContextProperty$descriptor() {
        return CertSetCRLContextProperty.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CertSetCRLContextProperty(PCCRL_CONTEXT pCrlContext, DWORD dwPropId, DWORD dwFlags, const void *pvData)
     * }
     */
    public static MethodHandle CertSetCRLContextProperty$handle() {
        return CertSetCRLContextProperty.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL CertSetCRLContextProperty(PCCRL_CONTEXT pCrlContext, DWORD dwPropId, DWORD dwFlags, const void *pvData)
     * }
     */
    public static int CertSetCRLContextProperty(MemorySegment pCrlContext, int dwPropId, int dwFlags, MemorySegment pvData) {
        var mh$ = CertSetCRLContextProperty.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CertSetCRLContextProperty", pCrlContext, dwPropId, dwFlags, pvData);
            }
            return (int)mh$.invokeExact(pCrlContext, dwPropId, dwFlags, pvData);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CertGetCRLContextProperty {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_LONG,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CertGetCRLContextProperty"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CertGetCRLContextProperty(PCCRL_CONTEXT pCrlContext, DWORD dwPropId, void *pvData, DWORD *pcbData)
     * }
     */
    public static FunctionDescriptor CertGetCRLContextProperty$descriptor() {
        return CertGetCRLContextProperty.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CertGetCRLContextProperty(PCCRL_CONTEXT pCrlContext, DWORD dwPropId, void *pvData, DWORD *pcbData)
     * }
     */
    public static MethodHandle CertGetCRLContextProperty$handle() {
        return CertGetCRLContextProperty.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL CertGetCRLContextProperty(PCCRL_CONTEXT pCrlContext, DWORD dwPropId, void *pvData, DWORD *pcbData)
     * }
     */
    public static int CertGetCRLContextProperty(MemorySegment pCrlContext, int dwPropId, MemorySegment pvData, MemorySegment pcbData) {
        var mh$ = CertGetCRLContextProperty.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CertGetCRLContextProperty", pCrlContext, dwPropId, pvData, pcbData);
            }
            return (int)mh$.invokeExact(pCrlContext, dwPropId, pvData, pcbData);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CertEnumCRLContextProperties {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_POINTER,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CertEnumCRLContextProperties"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD CertEnumCRLContextProperties(PCCRL_CONTEXT pCrlContext, DWORD dwPropId)
     * }
     */
    public static FunctionDescriptor CertEnumCRLContextProperties$descriptor() {
        return CertEnumCRLContextProperties.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD CertEnumCRLContextProperties(PCCRL_CONTEXT pCrlContext, DWORD dwPropId)
     * }
     */
    public static MethodHandle CertEnumCRLContextProperties$handle() {
        return CertEnumCRLContextProperties.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * DWORD CertEnumCRLContextProperties(PCCRL_CONTEXT pCrlContext, DWORD dwPropId)
     * }
     */
    public static int CertEnumCRLContextProperties(MemorySegment pCrlContext, int dwPropId) {
        var mh$ = CertEnumCRLContextProperties.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CertEnumCRLContextProperties", pCrlContext, dwPropId);
            }
            return (int)mh$.invokeExact(pCrlContext, dwPropId);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CertFindCertificateInCRL {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_LONG,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CertFindCertificateInCRL"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CertFindCertificateInCRL(PCCERT_CONTEXT pCert, PCCRL_CONTEXT pCrlContext, DWORD dwFlags, void *pvReserved, PCRL_ENTRY *ppCrlEntry)
     * }
     */
    public static FunctionDescriptor CertFindCertificateInCRL$descriptor() {
        return CertFindCertificateInCRL.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CertFindCertificateInCRL(PCCERT_CONTEXT pCert, PCCRL_CONTEXT pCrlContext, DWORD dwFlags, void *pvReserved, PCRL_ENTRY *ppCrlEntry)
     * }
     */
    public static MethodHandle CertFindCertificateInCRL$handle() {
        return CertFindCertificateInCRL.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL CertFindCertificateInCRL(PCCERT_CONTEXT pCert, PCCRL_CONTEXT pCrlContext, DWORD dwFlags, void *pvReserved, PCRL_ENTRY *ppCrlEntry)
     * }
     */
    public static int CertFindCertificateInCRL(MemorySegment pCert, MemorySegment pCrlContext, int dwFlags, MemorySegment pvReserved, MemorySegment ppCrlEntry) {
        var mh$ = CertFindCertificateInCRL.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CertFindCertificateInCRL", pCert, pCrlContext, dwFlags, pvReserved, ppCrlEntry);
            }
            return (int)mh$.invokeExact(pCert, pCrlContext, dwFlags, pvReserved, ppCrlEntry);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CertIsValidCRLForCertificate {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_LONG,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CertIsValidCRLForCertificate"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CertIsValidCRLForCertificate(PCCERT_CONTEXT pCert, PCCRL_CONTEXT pCrl, DWORD dwFlags, void *pvReserved)
     * }
     */
    public static FunctionDescriptor CertIsValidCRLForCertificate$descriptor() {
        return CertIsValidCRLForCertificate.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CertIsValidCRLForCertificate(PCCERT_CONTEXT pCert, PCCRL_CONTEXT pCrl, DWORD dwFlags, void *pvReserved)
     * }
     */
    public static MethodHandle CertIsValidCRLForCertificate$handle() {
        return CertIsValidCRLForCertificate.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL CertIsValidCRLForCertificate(PCCERT_CONTEXT pCert, PCCRL_CONTEXT pCrl, DWORD dwFlags, void *pvReserved)
     * }
     */
    public static int CertIsValidCRLForCertificate(MemorySegment pCert, MemorySegment pCrl, int dwFlags, MemorySegment pvReserved) {
        var mh$ = CertIsValidCRLForCertificate.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CertIsValidCRLForCertificate", pCert, pCrl, dwFlags, pvReserved);
            }
            return (int)mh$.invokeExact(pCert, pCrl, dwFlags, pvReserved);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CertAddEncodedCertificateToStore {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_LONG,
            C_POINTER,
            C_LONG,
            C_LONG,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CertAddEncodedCertificateToStore"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CertAddEncodedCertificateToStore(HCERTSTORE hCertStore, DWORD dwCertEncodingType, const BYTE *pbCertEncoded, DWORD cbCertEncoded, DWORD dwAddDisposition, PCCERT_CONTEXT *ppCertContext)
     * }
     */
    public static FunctionDescriptor CertAddEncodedCertificateToStore$descriptor() {
        return CertAddEncodedCertificateToStore.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CertAddEncodedCertificateToStore(HCERTSTORE hCertStore, DWORD dwCertEncodingType, const BYTE *pbCertEncoded, DWORD cbCertEncoded, DWORD dwAddDisposition, PCCERT_CONTEXT *ppCertContext)
     * }
     */
    public static MethodHandle CertAddEncodedCertificateToStore$handle() {
        return CertAddEncodedCertificateToStore.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL CertAddEncodedCertificateToStore(HCERTSTORE hCertStore, DWORD dwCertEncodingType, const BYTE *pbCertEncoded, DWORD cbCertEncoded, DWORD dwAddDisposition, PCCERT_CONTEXT *ppCertContext)
     * }
     */
    public static int CertAddEncodedCertificateToStore(MemorySegment hCertStore, int dwCertEncodingType, MemorySegment pbCertEncoded, int cbCertEncoded, int dwAddDisposition, MemorySegment ppCertContext) {
        var mh$ = CertAddEncodedCertificateToStore.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CertAddEncodedCertificateToStore", hCertStore, dwCertEncodingType, pbCertEncoded, cbCertEncoded, dwAddDisposition, ppCertContext);
            }
            return (int)mh$.invokeExact(hCertStore, dwCertEncodingType, pbCertEncoded, cbCertEncoded, dwAddDisposition, ppCertContext);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CertAddCertificateContextToStore {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_LONG,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CertAddCertificateContextToStore"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CertAddCertificateContextToStore(HCERTSTORE hCertStore, PCCERT_CONTEXT pCertContext, DWORD dwAddDisposition, PCCERT_CONTEXT *ppStoreContext)
     * }
     */
    public static FunctionDescriptor CertAddCertificateContextToStore$descriptor() {
        return CertAddCertificateContextToStore.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CertAddCertificateContextToStore(HCERTSTORE hCertStore, PCCERT_CONTEXT pCertContext, DWORD dwAddDisposition, PCCERT_CONTEXT *ppStoreContext)
     * }
     */
    public static MethodHandle CertAddCertificateContextToStore$handle() {
        return CertAddCertificateContextToStore.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL CertAddCertificateContextToStore(HCERTSTORE hCertStore, PCCERT_CONTEXT pCertContext, DWORD dwAddDisposition, PCCERT_CONTEXT *ppStoreContext)
     * }
     */
    public static int CertAddCertificateContextToStore(MemorySegment hCertStore, MemorySegment pCertContext, int dwAddDisposition, MemorySegment ppStoreContext) {
        var mh$ = CertAddCertificateContextToStore.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CertAddCertificateContextToStore", hCertStore, pCertContext, dwAddDisposition, ppStoreContext);
            }
            return (int)mh$.invokeExact(hCertStore, pCertContext, dwAddDisposition, ppStoreContext);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CertAddSerializedElementToStore {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_LONG,
            C_LONG,
            C_LONG,
            C_LONG,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CertAddSerializedElementToStore"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CertAddSerializedElementToStore(HCERTSTORE hCertStore, const BYTE *pbElement, DWORD cbElement, DWORD dwAddDisposition, DWORD dwFlags, DWORD dwContextTypeFlags, DWORD *pdwContextType, const void **ppvContext)
     * }
     */
    public static FunctionDescriptor CertAddSerializedElementToStore$descriptor() {
        return CertAddSerializedElementToStore.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CertAddSerializedElementToStore(HCERTSTORE hCertStore, const BYTE *pbElement, DWORD cbElement, DWORD dwAddDisposition, DWORD dwFlags, DWORD dwContextTypeFlags, DWORD *pdwContextType, const void **ppvContext)
     * }
     */
    public static MethodHandle CertAddSerializedElementToStore$handle() {
        return CertAddSerializedElementToStore.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL CertAddSerializedElementToStore(HCERTSTORE hCertStore, const BYTE *pbElement, DWORD cbElement, DWORD dwAddDisposition, DWORD dwFlags, DWORD dwContextTypeFlags, DWORD *pdwContextType, const void **ppvContext)
     * }
     */
    public static int CertAddSerializedElementToStore(MemorySegment hCertStore, MemorySegment pbElement, int cbElement, int dwAddDisposition, int dwFlags, int dwContextTypeFlags, MemorySegment pdwContextType, MemorySegment ppvContext) {
        var mh$ = CertAddSerializedElementToStore.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CertAddSerializedElementToStore", hCertStore, pbElement, cbElement, dwAddDisposition, dwFlags, dwContextTypeFlags, pdwContextType, ppvContext);
            }
            return (int)mh$.invokeExact(hCertStore, pbElement, cbElement, dwAddDisposition, dwFlags, dwContextTypeFlags, pdwContextType, ppvContext);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CertDeleteCertificateFromStore {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CertDeleteCertificateFromStore"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CertDeleteCertificateFromStore(PCCERT_CONTEXT pCertContext)
     * }
     */
    public static FunctionDescriptor CertDeleteCertificateFromStore$descriptor() {
        return CertDeleteCertificateFromStore.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CertDeleteCertificateFromStore(PCCERT_CONTEXT pCertContext)
     * }
     */
    public static MethodHandle CertDeleteCertificateFromStore$handle() {
        return CertDeleteCertificateFromStore.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL CertDeleteCertificateFromStore(PCCERT_CONTEXT pCertContext)
     * }
     */
    public static int CertDeleteCertificateFromStore(MemorySegment pCertContext) {
        var mh$ = CertDeleteCertificateFromStore.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CertDeleteCertificateFromStore", pCertContext);
            }
            return (int)mh$.invokeExact(pCertContext);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CertAddEncodedCRLToStore {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_LONG,
            C_POINTER,
            C_LONG,
            C_LONG,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CertAddEncodedCRLToStore"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CertAddEncodedCRLToStore(HCERTSTORE hCertStore, DWORD dwCertEncodingType, const BYTE *pbCrlEncoded, DWORD cbCrlEncoded, DWORD dwAddDisposition, PCCRL_CONTEXT *ppCrlContext)
     * }
     */
    public static FunctionDescriptor CertAddEncodedCRLToStore$descriptor() {
        return CertAddEncodedCRLToStore.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CertAddEncodedCRLToStore(HCERTSTORE hCertStore, DWORD dwCertEncodingType, const BYTE *pbCrlEncoded, DWORD cbCrlEncoded, DWORD dwAddDisposition, PCCRL_CONTEXT *ppCrlContext)
     * }
     */
    public static MethodHandle CertAddEncodedCRLToStore$handle() {
        return CertAddEncodedCRLToStore.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL CertAddEncodedCRLToStore(HCERTSTORE hCertStore, DWORD dwCertEncodingType, const BYTE *pbCrlEncoded, DWORD cbCrlEncoded, DWORD dwAddDisposition, PCCRL_CONTEXT *ppCrlContext)
     * }
     */
    public static int CertAddEncodedCRLToStore(MemorySegment hCertStore, int dwCertEncodingType, MemorySegment pbCrlEncoded, int cbCrlEncoded, int dwAddDisposition, MemorySegment ppCrlContext) {
        var mh$ = CertAddEncodedCRLToStore.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CertAddEncodedCRLToStore", hCertStore, dwCertEncodingType, pbCrlEncoded, cbCrlEncoded, dwAddDisposition, ppCrlContext);
            }
            return (int)mh$.invokeExact(hCertStore, dwCertEncodingType, pbCrlEncoded, cbCrlEncoded, dwAddDisposition, ppCrlContext);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CertAddCRLContextToStore {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_LONG,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CertAddCRLContextToStore"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CertAddCRLContextToStore(HCERTSTORE hCertStore, PCCRL_CONTEXT pCrlContext, DWORD dwAddDisposition, PCCRL_CONTEXT *ppStoreContext)
     * }
     */
    public static FunctionDescriptor CertAddCRLContextToStore$descriptor() {
        return CertAddCRLContextToStore.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CertAddCRLContextToStore(HCERTSTORE hCertStore, PCCRL_CONTEXT pCrlContext, DWORD dwAddDisposition, PCCRL_CONTEXT *ppStoreContext)
     * }
     */
    public static MethodHandle CertAddCRLContextToStore$handle() {
        return CertAddCRLContextToStore.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL CertAddCRLContextToStore(HCERTSTORE hCertStore, PCCRL_CONTEXT pCrlContext, DWORD dwAddDisposition, PCCRL_CONTEXT *ppStoreContext)
     * }
     */
    public static int CertAddCRLContextToStore(MemorySegment hCertStore, MemorySegment pCrlContext, int dwAddDisposition, MemorySegment ppStoreContext) {
        var mh$ = CertAddCRLContextToStore.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CertAddCRLContextToStore", hCertStore, pCrlContext, dwAddDisposition, ppStoreContext);
            }
            return (int)mh$.invokeExact(hCertStore, pCrlContext, dwAddDisposition, ppStoreContext);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CertDeleteCRLFromStore {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CertDeleteCRLFromStore"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CertDeleteCRLFromStore(PCCRL_CONTEXT pCrlContext)
     * }
     */
    public static FunctionDescriptor CertDeleteCRLFromStore$descriptor() {
        return CertDeleteCRLFromStore.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CertDeleteCRLFromStore(PCCRL_CONTEXT pCrlContext)
     * }
     */
    public static MethodHandle CertDeleteCRLFromStore$handle() {
        return CertDeleteCRLFromStore.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL CertDeleteCRLFromStore(PCCRL_CONTEXT pCrlContext)
     * }
     */
    public static int CertDeleteCRLFromStore(MemorySegment pCrlContext) {
        var mh$ = CertDeleteCRLFromStore.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CertDeleteCRLFromStore", pCrlContext);
            }
            return (int)mh$.invokeExact(pCrlContext);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CertSerializeCertificateStoreElement {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_LONG,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CertSerializeCertificateStoreElement"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CertSerializeCertificateStoreElement(PCCERT_CONTEXT pCertContext, DWORD dwFlags, BYTE *pbElement, DWORD *pcbElement)
     * }
     */
    public static FunctionDescriptor CertSerializeCertificateStoreElement$descriptor() {
        return CertSerializeCertificateStoreElement.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CertSerializeCertificateStoreElement(PCCERT_CONTEXT pCertContext, DWORD dwFlags, BYTE *pbElement, DWORD *pcbElement)
     * }
     */
    public static MethodHandle CertSerializeCertificateStoreElement$handle() {
        return CertSerializeCertificateStoreElement.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL CertSerializeCertificateStoreElement(PCCERT_CONTEXT pCertContext, DWORD dwFlags, BYTE *pbElement, DWORD *pcbElement)
     * }
     */
    public static int CertSerializeCertificateStoreElement(MemorySegment pCertContext, int dwFlags, MemorySegment pbElement, MemorySegment pcbElement) {
        var mh$ = CertSerializeCertificateStoreElement.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CertSerializeCertificateStoreElement", pCertContext, dwFlags, pbElement, pcbElement);
            }
            return (int)mh$.invokeExact(pCertContext, dwFlags, pbElement, pcbElement);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CertSerializeCRLStoreElement {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_LONG,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CertSerializeCRLStoreElement"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CertSerializeCRLStoreElement(PCCRL_CONTEXT pCrlContext, DWORD dwFlags, BYTE *pbElement, DWORD *pcbElement)
     * }
     */
    public static FunctionDescriptor CertSerializeCRLStoreElement$descriptor() {
        return CertSerializeCRLStoreElement.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CertSerializeCRLStoreElement(PCCRL_CONTEXT pCrlContext, DWORD dwFlags, BYTE *pbElement, DWORD *pcbElement)
     * }
     */
    public static MethodHandle CertSerializeCRLStoreElement$handle() {
        return CertSerializeCRLStoreElement.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL CertSerializeCRLStoreElement(PCCRL_CONTEXT pCrlContext, DWORD dwFlags, BYTE *pbElement, DWORD *pcbElement)
     * }
     */
    public static int CertSerializeCRLStoreElement(MemorySegment pCrlContext, int dwFlags, MemorySegment pbElement, MemorySegment pcbElement) {
        var mh$ = CertSerializeCRLStoreElement.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CertSerializeCRLStoreElement", pCrlContext, dwFlags, pbElement, pcbElement);
            }
            return (int)mh$.invokeExact(pCrlContext, dwFlags, pbElement, pcbElement);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CertDuplicateCTLContext {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CertDuplicateCTLContext"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PCCTL_CONTEXT CertDuplicateCTLContext(PCCTL_CONTEXT pCtlContext)
     * }
     */
    public static FunctionDescriptor CertDuplicateCTLContext$descriptor() {
        return CertDuplicateCTLContext.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PCCTL_CONTEXT CertDuplicateCTLContext(PCCTL_CONTEXT pCtlContext)
     * }
     */
    public static MethodHandle CertDuplicateCTLContext$handle() {
        return CertDuplicateCTLContext.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * PCCTL_CONTEXT CertDuplicateCTLContext(PCCTL_CONTEXT pCtlContext)
     * }
     */
    public static MemorySegment CertDuplicateCTLContext(MemorySegment pCtlContext) {
        var mh$ = CertDuplicateCTLContext.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CertDuplicateCTLContext", pCtlContext);
            }
            return (MemorySegment)mh$.invokeExact(pCtlContext);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CertCreateCTLContext {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_LONG,
            C_POINTER,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CertCreateCTLContext"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PCCTL_CONTEXT CertCreateCTLContext(DWORD dwMsgAndCertEncodingType, const BYTE *pbCtlEncoded, DWORD cbCtlEncoded)
     * }
     */
    public static FunctionDescriptor CertCreateCTLContext$descriptor() {
        return CertCreateCTLContext.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PCCTL_CONTEXT CertCreateCTLContext(DWORD dwMsgAndCertEncodingType, const BYTE *pbCtlEncoded, DWORD cbCtlEncoded)
     * }
     */
    public static MethodHandle CertCreateCTLContext$handle() {
        return CertCreateCTLContext.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * PCCTL_CONTEXT CertCreateCTLContext(DWORD dwMsgAndCertEncodingType, const BYTE *pbCtlEncoded, DWORD cbCtlEncoded)
     * }
     */
    public static MemorySegment CertCreateCTLContext(int dwMsgAndCertEncodingType, MemorySegment pbCtlEncoded, int cbCtlEncoded) {
        var mh$ = CertCreateCTLContext.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CertCreateCTLContext", dwMsgAndCertEncodingType, pbCtlEncoded, cbCtlEncoded);
            }
            return (MemorySegment)mh$.invokeExact(dwMsgAndCertEncodingType, pbCtlEncoded, cbCtlEncoded);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CertFreeCTLContext {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CertFreeCTLContext"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CertFreeCTLContext(PCCTL_CONTEXT pCtlContext)
     * }
     */
    public static FunctionDescriptor CertFreeCTLContext$descriptor() {
        return CertFreeCTLContext.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CertFreeCTLContext(PCCTL_CONTEXT pCtlContext)
     * }
     */
    public static MethodHandle CertFreeCTLContext$handle() {
        return CertFreeCTLContext.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL CertFreeCTLContext(PCCTL_CONTEXT pCtlContext)
     * }
     */
    public static int CertFreeCTLContext(MemorySegment pCtlContext) {
        var mh$ = CertFreeCTLContext.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CertFreeCTLContext", pCtlContext);
            }
            return (int)mh$.invokeExact(pCtlContext);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CertSetCTLContextProperty {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_LONG,
            C_LONG,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CertSetCTLContextProperty"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CertSetCTLContextProperty(PCCTL_CONTEXT pCtlContext, DWORD dwPropId, DWORD dwFlags, const void *pvData)
     * }
     */
    public static FunctionDescriptor CertSetCTLContextProperty$descriptor() {
        return CertSetCTLContextProperty.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CertSetCTLContextProperty(PCCTL_CONTEXT pCtlContext, DWORD dwPropId, DWORD dwFlags, const void *pvData)
     * }
     */
    public static MethodHandle CertSetCTLContextProperty$handle() {
        return CertSetCTLContextProperty.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL CertSetCTLContextProperty(PCCTL_CONTEXT pCtlContext, DWORD dwPropId, DWORD dwFlags, const void *pvData)
     * }
     */
    public static int CertSetCTLContextProperty(MemorySegment pCtlContext, int dwPropId, int dwFlags, MemorySegment pvData) {
        var mh$ = CertSetCTLContextProperty.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CertSetCTLContextProperty", pCtlContext, dwPropId, dwFlags, pvData);
            }
            return (int)mh$.invokeExact(pCtlContext, dwPropId, dwFlags, pvData);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CertGetCTLContextProperty {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_LONG,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CertGetCTLContextProperty"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CertGetCTLContextProperty(PCCTL_CONTEXT pCtlContext, DWORD dwPropId, void *pvData, DWORD *pcbData)
     * }
     */
    public static FunctionDescriptor CertGetCTLContextProperty$descriptor() {
        return CertGetCTLContextProperty.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CertGetCTLContextProperty(PCCTL_CONTEXT pCtlContext, DWORD dwPropId, void *pvData, DWORD *pcbData)
     * }
     */
    public static MethodHandle CertGetCTLContextProperty$handle() {
        return CertGetCTLContextProperty.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL CertGetCTLContextProperty(PCCTL_CONTEXT pCtlContext, DWORD dwPropId, void *pvData, DWORD *pcbData)
     * }
     */
    public static int CertGetCTLContextProperty(MemorySegment pCtlContext, int dwPropId, MemorySegment pvData, MemorySegment pcbData) {
        var mh$ = CertGetCTLContextProperty.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CertGetCTLContextProperty", pCtlContext, dwPropId, pvData, pcbData);
            }
            return (int)mh$.invokeExact(pCtlContext, dwPropId, pvData, pcbData);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CertEnumCTLContextProperties {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_POINTER,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CertEnumCTLContextProperties"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD CertEnumCTLContextProperties(PCCTL_CONTEXT pCtlContext, DWORD dwPropId)
     * }
     */
    public static FunctionDescriptor CertEnumCTLContextProperties$descriptor() {
        return CertEnumCTLContextProperties.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD CertEnumCTLContextProperties(PCCTL_CONTEXT pCtlContext, DWORD dwPropId)
     * }
     */
    public static MethodHandle CertEnumCTLContextProperties$handle() {
        return CertEnumCTLContextProperties.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * DWORD CertEnumCTLContextProperties(PCCTL_CONTEXT pCtlContext, DWORD dwPropId)
     * }
     */
    public static int CertEnumCTLContextProperties(MemorySegment pCtlContext, int dwPropId) {
        var mh$ = CertEnumCTLContextProperties.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CertEnumCTLContextProperties", pCtlContext, dwPropId);
            }
            return (int)mh$.invokeExact(pCtlContext, dwPropId);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CertEnumCTLsInStore {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CertEnumCTLsInStore"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PCCTL_CONTEXT CertEnumCTLsInStore(HCERTSTORE hCertStore, PCCTL_CONTEXT pPrevCtlContext)
     * }
     */
    public static FunctionDescriptor CertEnumCTLsInStore$descriptor() {
        return CertEnumCTLsInStore.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PCCTL_CONTEXT CertEnumCTLsInStore(HCERTSTORE hCertStore, PCCTL_CONTEXT pPrevCtlContext)
     * }
     */
    public static MethodHandle CertEnumCTLsInStore$handle() {
        return CertEnumCTLsInStore.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * PCCTL_CONTEXT CertEnumCTLsInStore(HCERTSTORE hCertStore, PCCTL_CONTEXT pPrevCtlContext)
     * }
     */
    public static MemorySegment CertEnumCTLsInStore(MemorySegment hCertStore, MemorySegment pPrevCtlContext) {
        var mh$ = CertEnumCTLsInStore.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CertEnumCTLsInStore", hCertStore, pPrevCtlContext);
            }
            return (MemorySegment)mh$.invokeExact(hCertStore, pPrevCtlContext);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CertFindSubjectInCTL {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_LONG,
            C_LONG,
            C_POINTER,
            C_POINTER,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CertFindSubjectInCTL"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PCTL_ENTRY CertFindSubjectInCTL(DWORD dwEncodingType, DWORD dwSubjectType, void *pvSubject, PCCTL_CONTEXT pCtlContext, DWORD dwFlags)
     * }
     */
    public static FunctionDescriptor CertFindSubjectInCTL$descriptor() {
        return CertFindSubjectInCTL.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PCTL_ENTRY CertFindSubjectInCTL(DWORD dwEncodingType, DWORD dwSubjectType, void *pvSubject, PCCTL_CONTEXT pCtlContext, DWORD dwFlags)
     * }
     */
    public static MethodHandle CertFindSubjectInCTL$handle() {
        return CertFindSubjectInCTL.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * PCTL_ENTRY CertFindSubjectInCTL(DWORD dwEncodingType, DWORD dwSubjectType, void *pvSubject, PCCTL_CONTEXT pCtlContext, DWORD dwFlags)
     * }
     */
    public static MemorySegment CertFindSubjectInCTL(int dwEncodingType, int dwSubjectType, MemorySegment pvSubject, MemorySegment pCtlContext, int dwFlags) {
        var mh$ = CertFindSubjectInCTL.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CertFindSubjectInCTL", dwEncodingType, dwSubjectType, pvSubject, pCtlContext, dwFlags);
            }
            return (MemorySegment)mh$.invokeExact(dwEncodingType, dwSubjectType, pvSubject, pCtlContext, dwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct _CTL_ANY_SUBJECT_INFO {
     *     CRYPT_ALGORITHM_IDENTIFIER SubjectAlgorithm;
     *     CRYPT_DATA_BLOB SubjectIdentifier;
     * } *PCTL_ANY_SUBJECT_INFO
     * }
     */
    public static final AddressLayout PCTL_ANY_SUBJECT_INFO = C_POINTER;

    private static class CertFindCTLInStore {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER,
            C_LONG,
            C_LONG,
            C_LONG,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CertFindCTLInStore"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PCCTL_CONTEXT CertFindCTLInStore(HCERTSTORE hCertStore, DWORD dwMsgAndCertEncodingType, DWORD dwFindFlags, DWORD dwFindType, const void *pvFindPara, PCCTL_CONTEXT pPrevCtlContext)
     * }
     */
    public static FunctionDescriptor CertFindCTLInStore$descriptor() {
        return CertFindCTLInStore.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PCCTL_CONTEXT CertFindCTLInStore(HCERTSTORE hCertStore, DWORD dwMsgAndCertEncodingType, DWORD dwFindFlags, DWORD dwFindType, const void *pvFindPara, PCCTL_CONTEXT pPrevCtlContext)
     * }
     */
    public static MethodHandle CertFindCTLInStore$handle() {
        return CertFindCTLInStore.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * PCCTL_CONTEXT CertFindCTLInStore(HCERTSTORE hCertStore, DWORD dwMsgAndCertEncodingType, DWORD dwFindFlags, DWORD dwFindType, const void *pvFindPara, PCCTL_CONTEXT pPrevCtlContext)
     * }
     */
    public static MemorySegment CertFindCTLInStore(MemorySegment hCertStore, int dwMsgAndCertEncodingType, int dwFindFlags, int dwFindType, MemorySegment pvFindPara, MemorySegment pPrevCtlContext) {
        var mh$ = CertFindCTLInStore.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CertFindCTLInStore", hCertStore, dwMsgAndCertEncodingType, dwFindFlags, dwFindType, pvFindPara, pPrevCtlContext);
            }
            return (MemorySegment)mh$.invokeExact(hCertStore, dwMsgAndCertEncodingType, dwFindFlags, dwFindType, pvFindPara, pPrevCtlContext);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct _CTL_FIND_USAGE_PARA {
     *     DWORD cbSize;
     *     CTL_USAGE SubjectUsage;
     *     CRYPT_DATA_BLOB ListIdentifier;
     *     PCERT_INFO pSigner;
     * } *PCTL_FIND_USAGE_PARA
     * }
     */
    public static final AddressLayout PCTL_FIND_USAGE_PARA = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CTL_FIND_SUBJECT_PARA {
     *     DWORD cbSize;
     *     PCTL_FIND_USAGE_PARA pUsagePara;
     *     DWORD dwSubjectType;
     *     void *pvSubject;
     * } *PCTL_FIND_SUBJECT_PARA
     * }
     */
    public static final AddressLayout PCTL_FIND_SUBJECT_PARA = C_POINTER;

    private static class CertAddEncodedCTLToStore {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_LONG,
            C_POINTER,
            C_LONG,
            C_LONG,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CertAddEncodedCTLToStore"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CertAddEncodedCTLToStore(HCERTSTORE hCertStore, DWORD dwMsgAndCertEncodingType, const BYTE *pbCtlEncoded, DWORD cbCtlEncoded, DWORD dwAddDisposition, PCCTL_CONTEXT *ppCtlContext)
     * }
     */
    public static FunctionDescriptor CertAddEncodedCTLToStore$descriptor() {
        return CertAddEncodedCTLToStore.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CertAddEncodedCTLToStore(HCERTSTORE hCertStore, DWORD dwMsgAndCertEncodingType, const BYTE *pbCtlEncoded, DWORD cbCtlEncoded, DWORD dwAddDisposition, PCCTL_CONTEXT *ppCtlContext)
     * }
     */
    public static MethodHandle CertAddEncodedCTLToStore$handle() {
        return CertAddEncodedCTLToStore.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL CertAddEncodedCTLToStore(HCERTSTORE hCertStore, DWORD dwMsgAndCertEncodingType, const BYTE *pbCtlEncoded, DWORD cbCtlEncoded, DWORD dwAddDisposition, PCCTL_CONTEXT *ppCtlContext)
     * }
     */
    public static int CertAddEncodedCTLToStore(MemorySegment hCertStore, int dwMsgAndCertEncodingType, MemorySegment pbCtlEncoded, int cbCtlEncoded, int dwAddDisposition, MemorySegment ppCtlContext) {
        var mh$ = CertAddEncodedCTLToStore.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CertAddEncodedCTLToStore", hCertStore, dwMsgAndCertEncodingType, pbCtlEncoded, cbCtlEncoded, dwAddDisposition, ppCtlContext);
            }
            return (int)mh$.invokeExact(hCertStore, dwMsgAndCertEncodingType, pbCtlEncoded, cbCtlEncoded, dwAddDisposition, ppCtlContext);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CertAddCTLContextToStore {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_LONG,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CertAddCTLContextToStore"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CertAddCTLContextToStore(HCERTSTORE hCertStore, PCCTL_CONTEXT pCtlContext, DWORD dwAddDisposition, PCCTL_CONTEXT *ppStoreContext)
     * }
     */
    public static FunctionDescriptor CertAddCTLContextToStore$descriptor() {
        return CertAddCTLContextToStore.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CertAddCTLContextToStore(HCERTSTORE hCertStore, PCCTL_CONTEXT pCtlContext, DWORD dwAddDisposition, PCCTL_CONTEXT *ppStoreContext)
     * }
     */
    public static MethodHandle CertAddCTLContextToStore$handle() {
        return CertAddCTLContextToStore.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL CertAddCTLContextToStore(HCERTSTORE hCertStore, PCCTL_CONTEXT pCtlContext, DWORD dwAddDisposition, PCCTL_CONTEXT *ppStoreContext)
     * }
     */
    public static int CertAddCTLContextToStore(MemorySegment hCertStore, MemorySegment pCtlContext, int dwAddDisposition, MemorySegment ppStoreContext) {
        var mh$ = CertAddCTLContextToStore.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CertAddCTLContextToStore", hCertStore, pCtlContext, dwAddDisposition, ppStoreContext);
            }
            return (int)mh$.invokeExact(hCertStore, pCtlContext, dwAddDisposition, ppStoreContext);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CertSerializeCTLStoreElement {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_LONG,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CertSerializeCTLStoreElement"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CertSerializeCTLStoreElement(PCCTL_CONTEXT pCtlContext, DWORD dwFlags, BYTE *pbElement, DWORD *pcbElement)
     * }
     */
    public static FunctionDescriptor CertSerializeCTLStoreElement$descriptor() {
        return CertSerializeCTLStoreElement.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CertSerializeCTLStoreElement(PCCTL_CONTEXT pCtlContext, DWORD dwFlags, BYTE *pbElement, DWORD *pcbElement)
     * }
     */
    public static MethodHandle CertSerializeCTLStoreElement$handle() {
        return CertSerializeCTLStoreElement.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL CertSerializeCTLStoreElement(PCCTL_CONTEXT pCtlContext, DWORD dwFlags, BYTE *pbElement, DWORD *pcbElement)
     * }
     */
    public static int CertSerializeCTLStoreElement(MemorySegment pCtlContext, int dwFlags, MemorySegment pbElement, MemorySegment pcbElement) {
        var mh$ = CertSerializeCTLStoreElement.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CertSerializeCTLStoreElement", pCtlContext, dwFlags, pbElement, pcbElement);
            }
            return (int)mh$.invokeExact(pCtlContext, dwFlags, pbElement, pcbElement);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CertDeleteCTLFromStore {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CertDeleteCTLFromStore"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CertDeleteCTLFromStore(PCCTL_CONTEXT pCtlContext)
     * }
     */
    public static FunctionDescriptor CertDeleteCTLFromStore$descriptor() {
        return CertDeleteCTLFromStore.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CertDeleteCTLFromStore(PCCTL_CONTEXT pCtlContext)
     * }
     */
    public static MethodHandle CertDeleteCTLFromStore$handle() {
        return CertDeleteCTLFromStore.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL CertDeleteCTLFromStore(PCCTL_CONTEXT pCtlContext)
     * }
     */
    public static int CertDeleteCTLFromStore(MemorySegment pCtlContext) {
        var mh$ = CertDeleteCTLFromStore.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CertDeleteCTLFromStore", pCtlContext);
            }
            return (int)mh$.invokeExact(pCtlContext);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CertAddCertificateLinkToStore {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_LONG,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CertAddCertificateLinkToStore"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CertAddCertificateLinkToStore(HCERTSTORE hCertStore, PCCERT_CONTEXT pCertContext, DWORD dwAddDisposition, PCCERT_CONTEXT *ppStoreContext)
     * }
     */
    public static FunctionDescriptor CertAddCertificateLinkToStore$descriptor() {
        return CertAddCertificateLinkToStore.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CertAddCertificateLinkToStore(HCERTSTORE hCertStore, PCCERT_CONTEXT pCertContext, DWORD dwAddDisposition, PCCERT_CONTEXT *ppStoreContext)
     * }
     */
    public static MethodHandle CertAddCertificateLinkToStore$handle() {
        return CertAddCertificateLinkToStore.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL CertAddCertificateLinkToStore(HCERTSTORE hCertStore, PCCERT_CONTEXT pCertContext, DWORD dwAddDisposition, PCCERT_CONTEXT *ppStoreContext)
     * }
     */
    public static int CertAddCertificateLinkToStore(MemorySegment hCertStore, MemorySegment pCertContext, int dwAddDisposition, MemorySegment ppStoreContext) {
        var mh$ = CertAddCertificateLinkToStore.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CertAddCertificateLinkToStore", hCertStore, pCertContext, dwAddDisposition, ppStoreContext);
            }
            return (int)mh$.invokeExact(hCertStore, pCertContext, dwAddDisposition, ppStoreContext);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CertAddCRLLinkToStore {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_LONG,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CertAddCRLLinkToStore"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CertAddCRLLinkToStore(HCERTSTORE hCertStore, PCCRL_CONTEXT pCrlContext, DWORD dwAddDisposition, PCCRL_CONTEXT *ppStoreContext)
     * }
     */
    public static FunctionDescriptor CertAddCRLLinkToStore$descriptor() {
        return CertAddCRLLinkToStore.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CertAddCRLLinkToStore(HCERTSTORE hCertStore, PCCRL_CONTEXT pCrlContext, DWORD dwAddDisposition, PCCRL_CONTEXT *ppStoreContext)
     * }
     */
    public static MethodHandle CertAddCRLLinkToStore$handle() {
        return CertAddCRLLinkToStore.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL CertAddCRLLinkToStore(HCERTSTORE hCertStore, PCCRL_CONTEXT pCrlContext, DWORD dwAddDisposition, PCCRL_CONTEXT *ppStoreContext)
     * }
     */
    public static int CertAddCRLLinkToStore(MemorySegment hCertStore, MemorySegment pCrlContext, int dwAddDisposition, MemorySegment ppStoreContext) {
        var mh$ = CertAddCRLLinkToStore.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CertAddCRLLinkToStore", hCertStore, pCrlContext, dwAddDisposition, ppStoreContext);
            }
            return (int)mh$.invokeExact(hCertStore, pCrlContext, dwAddDisposition, ppStoreContext);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CertAddCTLLinkToStore {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_LONG,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CertAddCTLLinkToStore"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CertAddCTLLinkToStore(HCERTSTORE hCertStore, PCCTL_CONTEXT pCtlContext, DWORD dwAddDisposition, PCCTL_CONTEXT *ppStoreContext)
     * }
     */
    public static FunctionDescriptor CertAddCTLLinkToStore$descriptor() {
        return CertAddCTLLinkToStore.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CertAddCTLLinkToStore(HCERTSTORE hCertStore, PCCTL_CONTEXT pCtlContext, DWORD dwAddDisposition, PCCTL_CONTEXT *ppStoreContext)
     * }
     */
    public static MethodHandle CertAddCTLLinkToStore$handle() {
        return CertAddCTLLinkToStore.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL CertAddCTLLinkToStore(HCERTSTORE hCertStore, PCCTL_CONTEXT pCtlContext, DWORD dwAddDisposition, PCCTL_CONTEXT *ppStoreContext)
     * }
     */
    public static int CertAddCTLLinkToStore(MemorySegment hCertStore, MemorySegment pCtlContext, int dwAddDisposition, MemorySegment ppStoreContext) {
        var mh$ = CertAddCTLLinkToStore.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CertAddCTLLinkToStore", hCertStore, pCtlContext, dwAddDisposition, ppStoreContext);
            }
            return (int)mh$.invokeExact(hCertStore, pCtlContext, dwAddDisposition, ppStoreContext);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CertAddStoreToCollection {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_LONG,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CertAddStoreToCollection"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CertAddStoreToCollection(HCERTSTORE hCollectionStore, HCERTSTORE hSiblingStore, DWORD dwUpdateFlags, DWORD dwPriority)
     * }
     */
    public static FunctionDescriptor CertAddStoreToCollection$descriptor() {
        return CertAddStoreToCollection.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CertAddStoreToCollection(HCERTSTORE hCollectionStore, HCERTSTORE hSiblingStore, DWORD dwUpdateFlags, DWORD dwPriority)
     * }
     */
    public static MethodHandle CertAddStoreToCollection$handle() {
        return CertAddStoreToCollection.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL CertAddStoreToCollection(HCERTSTORE hCollectionStore, HCERTSTORE hSiblingStore, DWORD dwUpdateFlags, DWORD dwPriority)
     * }
     */
    public static int CertAddStoreToCollection(MemorySegment hCollectionStore, MemorySegment hSiblingStore, int dwUpdateFlags, int dwPriority) {
        var mh$ = CertAddStoreToCollection.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CertAddStoreToCollection", hCollectionStore, hSiblingStore, dwUpdateFlags, dwPriority);
            }
            return (int)mh$.invokeExact(hCollectionStore, hSiblingStore, dwUpdateFlags, dwPriority);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CertRemoveStoreFromCollection {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CertRemoveStoreFromCollection"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void CertRemoveStoreFromCollection(HCERTSTORE hCollectionStore, HCERTSTORE hSiblingStore)
     * }
     */
    public static FunctionDescriptor CertRemoveStoreFromCollection$descriptor() {
        return CertRemoveStoreFromCollection.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void CertRemoveStoreFromCollection(HCERTSTORE hCollectionStore, HCERTSTORE hSiblingStore)
     * }
     */
    public static MethodHandle CertRemoveStoreFromCollection$handle() {
        return CertRemoveStoreFromCollection.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * void CertRemoveStoreFromCollection(HCERTSTORE hCollectionStore, HCERTSTORE hSiblingStore)
     * }
     */
    public static void CertRemoveStoreFromCollection(MemorySegment hCollectionStore, MemorySegment hSiblingStore) {
        var mh$ = CertRemoveStoreFromCollection.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CertRemoveStoreFromCollection", hCollectionStore, hSiblingStore);
            }
            mh$.invokeExact(hCollectionStore, hSiblingStore);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CertControlStore {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_LONG,
            C_LONG,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CertControlStore"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CertControlStore(HCERTSTORE hCertStore, DWORD dwFlags, DWORD dwCtrlType, const void *pvCtrlPara)
     * }
     */
    public static FunctionDescriptor CertControlStore$descriptor() {
        return CertControlStore.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CertControlStore(HCERTSTORE hCertStore, DWORD dwFlags, DWORD dwCtrlType, const void *pvCtrlPara)
     * }
     */
    public static MethodHandle CertControlStore$handle() {
        return CertControlStore.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL CertControlStore(HCERTSTORE hCertStore, DWORD dwFlags, DWORD dwCtrlType, const void *pvCtrlPara)
     * }
     */
    public static int CertControlStore(MemorySegment hCertStore, int dwFlags, int dwCtrlType, MemorySegment pvCtrlPara) {
        var mh$ = CertControlStore.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CertControlStore", hCertStore, dwFlags, dwCtrlType, pvCtrlPara);
            }
            return (int)mh$.invokeExact(hCertStore, dwFlags, dwCtrlType, pvCtrlPara);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CertSetStoreProperty {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_LONG,
            C_LONG,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CertSetStoreProperty"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CertSetStoreProperty(HCERTSTORE hCertStore, DWORD dwPropId, DWORD dwFlags, const void *pvData)
     * }
     */
    public static FunctionDescriptor CertSetStoreProperty$descriptor() {
        return CertSetStoreProperty.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CertSetStoreProperty(HCERTSTORE hCertStore, DWORD dwPropId, DWORD dwFlags, const void *pvData)
     * }
     */
    public static MethodHandle CertSetStoreProperty$handle() {
        return CertSetStoreProperty.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL CertSetStoreProperty(HCERTSTORE hCertStore, DWORD dwPropId, DWORD dwFlags, const void *pvData)
     * }
     */
    public static int CertSetStoreProperty(MemorySegment hCertStore, int dwPropId, int dwFlags, MemorySegment pvData) {
        var mh$ = CertSetStoreProperty.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CertSetStoreProperty", hCertStore, dwPropId, dwFlags, pvData);
            }
            return (int)mh$.invokeExact(hCertStore, dwPropId, dwFlags, pvData);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CertGetStoreProperty {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_LONG,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CertGetStoreProperty"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CertGetStoreProperty(HCERTSTORE hCertStore, DWORD dwPropId, void *pvData, DWORD *pcbData)
     * }
     */
    public static FunctionDescriptor CertGetStoreProperty$descriptor() {
        return CertGetStoreProperty.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CertGetStoreProperty(HCERTSTORE hCertStore, DWORD dwPropId, void *pvData, DWORD *pcbData)
     * }
     */
    public static MethodHandle CertGetStoreProperty$handle() {
        return CertGetStoreProperty.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL CertGetStoreProperty(HCERTSTORE hCertStore, DWORD dwPropId, void *pvData, DWORD *pcbData)
     * }
     */
    public static int CertGetStoreProperty(MemorySegment hCertStore, int dwPropId, MemorySegment pvData, MemorySegment pcbData) {
        var mh$ = CertGetStoreProperty.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CertGetStoreProperty", hCertStore, dwPropId, pvData, pcbData);
            }
            return (int)mh$.invokeExact(hCertStore, dwPropId, pvData, pcbData);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct _CERT_CREATE_CONTEXT_PARA {
     *     DWORD cbSize;
     *     PFN_CRYPT_FREE pfnFree;
     *     void *pvFree;
     *     PFN_CERT_CREATE_CONTEXT_SORT_FUNC pfnSort;
     *     void *pvSort;
     * } *PCERT_CREATE_CONTEXT_PARA
     * }
     */
    public static final AddressLayout PCERT_CREATE_CONTEXT_PARA = C_POINTER;

    private static class CertCreateContext {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_LONG,
            C_LONG,
            C_POINTER,
            C_LONG,
            C_LONG,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CertCreateContext"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const void *CertCreateContext(DWORD dwContextType, DWORD dwEncodingType, const BYTE *pbEncoded, DWORD cbEncoded, DWORD dwFlags, PCERT_CREATE_CONTEXT_PARA pCreatePara)
     * }
     */
    public static FunctionDescriptor CertCreateContext$descriptor() {
        return CertCreateContext.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const void *CertCreateContext(DWORD dwContextType, DWORD dwEncodingType, const BYTE *pbEncoded, DWORD cbEncoded, DWORD dwFlags, PCERT_CREATE_CONTEXT_PARA pCreatePara)
     * }
     */
    public static MethodHandle CertCreateContext$handle() {
        return CertCreateContext.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * const void *CertCreateContext(DWORD dwContextType, DWORD dwEncodingType, const BYTE *pbEncoded, DWORD cbEncoded, DWORD dwFlags, PCERT_CREATE_CONTEXT_PARA pCreatePara)
     * }
     */
    public static MemorySegment CertCreateContext(int dwContextType, int dwEncodingType, MemorySegment pbEncoded, int cbEncoded, int dwFlags, MemorySegment pCreatePara) {
        var mh$ = CertCreateContext.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CertCreateContext", dwContextType, dwEncodingType, pbEncoded, cbEncoded, dwFlags, pCreatePara);
            }
            return (MemorySegment)mh$.invokeExact(dwContextType, dwEncodingType, pbEncoded, cbEncoded, dwFlags, pCreatePara);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct _CERT_SYSTEM_STORE_INFO {
     *     DWORD cbSize;
     * } *PCERT_SYSTEM_STORE_INFO
     * }
     */
    public static final AddressLayout PCERT_SYSTEM_STORE_INFO = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CERT_PHYSICAL_STORE_INFO {
     *     DWORD cbSize;
     *     LPSTR pszOpenStoreProvider;
     *     DWORD dwOpenEncodingType;
     *     DWORD dwOpenFlags;
     *     CRYPT_DATA_BLOB OpenParameters;
     *     DWORD dwFlags;
     *     DWORD dwPriority;
     * } *PCERT_PHYSICAL_STORE_INFO
     * }
     */
    public static final AddressLayout PCERT_PHYSICAL_STORE_INFO = C_POINTER;

    private static class CertRegisterSystemStore {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_LONG,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CertRegisterSystemStore"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CertRegisterSystemStore(const void *pvSystemStore, DWORD dwFlags, PCERT_SYSTEM_STORE_INFO pStoreInfo, void *pvReserved)
     * }
     */
    public static FunctionDescriptor CertRegisterSystemStore$descriptor() {
        return CertRegisterSystemStore.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CertRegisterSystemStore(const void *pvSystemStore, DWORD dwFlags, PCERT_SYSTEM_STORE_INFO pStoreInfo, void *pvReserved)
     * }
     */
    public static MethodHandle CertRegisterSystemStore$handle() {
        return CertRegisterSystemStore.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL CertRegisterSystemStore(const void *pvSystemStore, DWORD dwFlags, PCERT_SYSTEM_STORE_INFO pStoreInfo, void *pvReserved)
     * }
     */
    public static int CertRegisterSystemStore(MemorySegment pvSystemStore, int dwFlags, MemorySegment pStoreInfo, MemorySegment pvReserved) {
        var mh$ = CertRegisterSystemStore.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CertRegisterSystemStore", pvSystemStore, dwFlags, pStoreInfo, pvReserved);
            }
            return (int)mh$.invokeExact(pvSystemStore, dwFlags, pStoreInfo, pvReserved);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CertRegisterPhysicalStore {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_LONG,
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CertRegisterPhysicalStore"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CertRegisterPhysicalStore(const void *pvSystemStore, DWORD dwFlags, LPCWSTR pwszStoreName, PCERT_PHYSICAL_STORE_INFO pStoreInfo, void *pvReserved)
     * }
     */
    public static FunctionDescriptor CertRegisterPhysicalStore$descriptor() {
        return CertRegisterPhysicalStore.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CertRegisterPhysicalStore(const void *pvSystemStore, DWORD dwFlags, LPCWSTR pwszStoreName, PCERT_PHYSICAL_STORE_INFO pStoreInfo, void *pvReserved)
     * }
     */
    public static MethodHandle CertRegisterPhysicalStore$handle() {
        return CertRegisterPhysicalStore.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL CertRegisterPhysicalStore(const void *pvSystemStore, DWORD dwFlags, LPCWSTR pwszStoreName, PCERT_PHYSICAL_STORE_INFO pStoreInfo, void *pvReserved)
     * }
     */
    public static int CertRegisterPhysicalStore(MemorySegment pvSystemStore, int dwFlags, MemorySegment pwszStoreName, MemorySegment pStoreInfo, MemorySegment pvReserved) {
        var mh$ = CertRegisterPhysicalStore.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CertRegisterPhysicalStore", pvSystemStore, dwFlags, pwszStoreName, pStoreInfo, pvReserved);
            }
            return (int)mh$.invokeExact(pvSystemStore, dwFlags, pwszStoreName, pStoreInfo, pvReserved);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CertUnregisterSystemStore {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CertUnregisterSystemStore"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CertUnregisterSystemStore(const void *pvSystemStore, DWORD dwFlags)
     * }
     */
    public static FunctionDescriptor CertUnregisterSystemStore$descriptor() {
        return CertUnregisterSystemStore.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CertUnregisterSystemStore(const void *pvSystemStore, DWORD dwFlags)
     * }
     */
    public static MethodHandle CertUnregisterSystemStore$handle() {
        return CertUnregisterSystemStore.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL CertUnregisterSystemStore(const void *pvSystemStore, DWORD dwFlags)
     * }
     */
    public static int CertUnregisterSystemStore(MemorySegment pvSystemStore, int dwFlags) {
        var mh$ = CertUnregisterSystemStore.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CertUnregisterSystemStore", pvSystemStore, dwFlags);
            }
            return (int)mh$.invokeExact(pvSystemStore, dwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CertUnregisterPhysicalStore {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_LONG,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CertUnregisterPhysicalStore"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CertUnregisterPhysicalStore(const void *pvSystemStore, DWORD dwFlags, LPCWSTR pwszStoreName)
     * }
     */
    public static FunctionDescriptor CertUnregisterPhysicalStore$descriptor() {
        return CertUnregisterPhysicalStore.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CertUnregisterPhysicalStore(const void *pvSystemStore, DWORD dwFlags, LPCWSTR pwszStoreName)
     * }
     */
    public static MethodHandle CertUnregisterPhysicalStore$handle() {
        return CertUnregisterPhysicalStore.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL CertUnregisterPhysicalStore(const void *pvSystemStore, DWORD dwFlags, LPCWSTR pwszStoreName)
     * }
     */
    public static int CertUnregisterPhysicalStore(MemorySegment pvSystemStore, int dwFlags, MemorySegment pwszStoreName) {
        var mh$ = CertUnregisterPhysicalStore.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CertUnregisterPhysicalStore", pvSystemStore, dwFlags, pwszStoreName);
            }
            return (int)mh$.invokeExact(pvSystemStore, dwFlags, pwszStoreName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CertEnumSystemStoreLocation {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_LONG,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CertEnumSystemStoreLocation"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CertEnumSystemStoreLocation(DWORD dwFlags, void *pvArg, PFN_CERT_ENUM_SYSTEM_STORE_LOCATION pfnEnum)
     * }
     */
    public static FunctionDescriptor CertEnumSystemStoreLocation$descriptor() {
        return CertEnumSystemStoreLocation.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CertEnumSystemStoreLocation(DWORD dwFlags, void *pvArg, PFN_CERT_ENUM_SYSTEM_STORE_LOCATION pfnEnum)
     * }
     */
    public static MethodHandle CertEnumSystemStoreLocation$handle() {
        return CertEnumSystemStoreLocation.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL CertEnumSystemStoreLocation(DWORD dwFlags, void *pvArg, PFN_CERT_ENUM_SYSTEM_STORE_LOCATION pfnEnum)
     * }
     */
    public static int CertEnumSystemStoreLocation(int dwFlags, MemorySegment pvArg, MemorySegment pfnEnum) {
        var mh$ = CertEnumSystemStoreLocation.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CertEnumSystemStoreLocation", dwFlags, pvArg, pfnEnum);
            }
            return (int)mh$.invokeExact(dwFlags, pvArg, pfnEnum);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CertEnumSystemStore {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_LONG,
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CertEnumSystemStore"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CertEnumSystemStore(DWORD dwFlags, void *pvSystemStoreLocationPara, void *pvArg, PFN_CERT_ENUM_SYSTEM_STORE pfnEnum)
     * }
     */
    public static FunctionDescriptor CertEnumSystemStore$descriptor() {
        return CertEnumSystemStore.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CertEnumSystemStore(DWORD dwFlags, void *pvSystemStoreLocationPara, void *pvArg, PFN_CERT_ENUM_SYSTEM_STORE pfnEnum)
     * }
     */
    public static MethodHandle CertEnumSystemStore$handle() {
        return CertEnumSystemStore.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL CertEnumSystemStore(DWORD dwFlags, void *pvSystemStoreLocationPara, void *pvArg, PFN_CERT_ENUM_SYSTEM_STORE pfnEnum)
     * }
     */
    public static int CertEnumSystemStore(int dwFlags, MemorySegment pvSystemStoreLocationPara, MemorySegment pvArg, MemorySegment pfnEnum) {
        var mh$ = CertEnumSystemStore.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CertEnumSystemStore", dwFlags, pvSystemStoreLocationPara, pvArg, pfnEnum);
            }
            return (int)mh$.invokeExact(dwFlags, pvSystemStoreLocationPara, pvArg, pfnEnum);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CertEnumPhysicalStore {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_LONG,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CertEnumPhysicalStore"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CertEnumPhysicalStore(const void *pvSystemStore, DWORD dwFlags, void *pvArg, PFN_CERT_ENUM_PHYSICAL_STORE pfnEnum)
     * }
     */
    public static FunctionDescriptor CertEnumPhysicalStore$descriptor() {
        return CertEnumPhysicalStore.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CertEnumPhysicalStore(const void *pvSystemStore, DWORD dwFlags, void *pvArg, PFN_CERT_ENUM_PHYSICAL_STORE pfnEnum)
     * }
     */
    public static MethodHandle CertEnumPhysicalStore$handle() {
        return CertEnumPhysicalStore.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL CertEnumPhysicalStore(const void *pvSystemStore, DWORD dwFlags, void *pvArg, PFN_CERT_ENUM_PHYSICAL_STORE pfnEnum)
     * }
     */
    public static int CertEnumPhysicalStore(MemorySegment pvSystemStore, int dwFlags, MemorySegment pvArg, MemorySegment pfnEnum) {
        var mh$ = CertEnumPhysicalStore.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CertEnumPhysicalStore", pvSystemStore, dwFlags, pvArg, pfnEnum);
            }
            return (int)mh$.invokeExact(pvSystemStore, dwFlags, pvArg, pfnEnum);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CertGetEnhancedKeyUsage {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_LONG,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CertGetEnhancedKeyUsage"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CertGetEnhancedKeyUsage(PCCERT_CONTEXT pCertContext, DWORD dwFlags, PCERT_ENHKEY_USAGE pUsage, DWORD *pcbUsage)
     * }
     */
    public static FunctionDescriptor CertGetEnhancedKeyUsage$descriptor() {
        return CertGetEnhancedKeyUsage.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CertGetEnhancedKeyUsage(PCCERT_CONTEXT pCertContext, DWORD dwFlags, PCERT_ENHKEY_USAGE pUsage, DWORD *pcbUsage)
     * }
     */
    public static MethodHandle CertGetEnhancedKeyUsage$handle() {
        return CertGetEnhancedKeyUsage.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL CertGetEnhancedKeyUsage(PCCERT_CONTEXT pCertContext, DWORD dwFlags, PCERT_ENHKEY_USAGE pUsage, DWORD *pcbUsage)
     * }
     */
    public static int CertGetEnhancedKeyUsage(MemorySegment pCertContext, int dwFlags, MemorySegment pUsage, MemorySegment pcbUsage) {
        var mh$ = CertGetEnhancedKeyUsage.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CertGetEnhancedKeyUsage", pCertContext, dwFlags, pUsage, pcbUsage);
            }
            return (int)mh$.invokeExact(pCertContext, dwFlags, pUsage, pcbUsage);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CertSetEnhancedKeyUsage {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CertSetEnhancedKeyUsage"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CertSetEnhancedKeyUsage(PCCERT_CONTEXT pCertContext, PCERT_ENHKEY_USAGE pUsage)
     * }
     */
    public static FunctionDescriptor CertSetEnhancedKeyUsage$descriptor() {
        return CertSetEnhancedKeyUsage.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CertSetEnhancedKeyUsage(PCCERT_CONTEXT pCertContext, PCERT_ENHKEY_USAGE pUsage)
     * }
     */
    public static MethodHandle CertSetEnhancedKeyUsage$handle() {
        return CertSetEnhancedKeyUsage.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL CertSetEnhancedKeyUsage(PCCERT_CONTEXT pCertContext, PCERT_ENHKEY_USAGE pUsage)
     * }
     */
    public static int CertSetEnhancedKeyUsage(MemorySegment pCertContext, MemorySegment pUsage) {
        var mh$ = CertSetEnhancedKeyUsage.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CertSetEnhancedKeyUsage", pCertContext, pUsage);
            }
            return (int)mh$.invokeExact(pCertContext, pUsage);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CertAddEnhancedKeyUsageIdentifier {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CertAddEnhancedKeyUsageIdentifier"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CertAddEnhancedKeyUsageIdentifier(PCCERT_CONTEXT pCertContext, LPCSTR pszUsageIdentifier)
     * }
     */
    public static FunctionDescriptor CertAddEnhancedKeyUsageIdentifier$descriptor() {
        return CertAddEnhancedKeyUsageIdentifier.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CertAddEnhancedKeyUsageIdentifier(PCCERT_CONTEXT pCertContext, LPCSTR pszUsageIdentifier)
     * }
     */
    public static MethodHandle CertAddEnhancedKeyUsageIdentifier$handle() {
        return CertAddEnhancedKeyUsageIdentifier.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL CertAddEnhancedKeyUsageIdentifier(PCCERT_CONTEXT pCertContext, LPCSTR pszUsageIdentifier)
     * }
     */
    public static int CertAddEnhancedKeyUsageIdentifier(MemorySegment pCertContext, MemorySegment pszUsageIdentifier) {
        var mh$ = CertAddEnhancedKeyUsageIdentifier.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CertAddEnhancedKeyUsageIdentifier", pCertContext, pszUsageIdentifier);
            }
            return (int)mh$.invokeExact(pCertContext, pszUsageIdentifier);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CertRemoveEnhancedKeyUsageIdentifier {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CertRemoveEnhancedKeyUsageIdentifier"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CertRemoveEnhancedKeyUsageIdentifier(PCCERT_CONTEXT pCertContext, LPCSTR pszUsageIdentifier)
     * }
     */
    public static FunctionDescriptor CertRemoveEnhancedKeyUsageIdentifier$descriptor() {
        return CertRemoveEnhancedKeyUsageIdentifier.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CertRemoveEnhancedKeyUsageIdentifier(PCCERT_CONTEXT pCertContext, LPCSTR pszUsageIdentifier)
     * }
     */
    public static MethodHandle CertRemoveEnhancedKeyUsageIdentifier$handle() {
        return CertRemoveEnhancedKeyUsageIdentifier.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL CertRemoveEnhancedKeyUsageIdentifier(PCCERT_CONTEXT pCertContext, LPCSTR pszUsageIdentifier)
     * }
     */
    public static int CertRemoveEnhancedKeyUsageIdentifier(MemorySegment pCertContext, MemorySegment pszUsageIdentifier) {
        var mh$ = CertRemoveEnhancedKeyUsageIdentifier.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CertRemoveEnhancedKeyUsageIdentifier", pCertContext, pszUsageIdentifier);
            }
            return (int)mh$.invokeExact(pCertContext, pszUsageIdentifier);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CertGetValidUsages {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_LONG,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CertGetValidUsages"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CertGetValidUsages(DWORD cCerts, PCCERT_CONTEXT *rghCerts, int *cNumOIDs, LPSTR *rghOIDs, DWORD *pcbOIDs)
     * }
     */
    public static FunctionDescriptor CertGetValidUsages$descriptor() {
        return CertGetValidUsages.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CertGetValidUsages(DWORD cCerts, PCCERT_CONTEXT *rghCerts, int *cNumOIDs, LPSTR *rghOIDs, DWORD *pcbOIDs)
     * }
     */
    public static MethodHandle CertGetValidUsages$handle() {
        return CertGetValidUsages.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL CertGetValidUsages(DWORD cCerts, PCCERT_CONTEXT *rghCerts, int *cNumOIDs, LPSTR *rghOIDs, DWORD *pcbOIDs)
     * }
     */
    public static int CertGetValidUsages(int cCerts, MemorySegment rghCerts, MemorySegment cNumOIDs, MemorySegment rghOIDs, MemorySegment pcbOIDs) {
        var mh$ = CertGetValidUsages.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CertGetValidUsages", cCerts, rghCerts, cNumOIDs, rghOIDs, pcbOIDs);
            }
            return (int)mh$.invokeExact(cCerts, rghCerts, cNumOIDs, rghOIDs, pcbOIDs);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CryptMsgGetAndVerifySigner {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_LONG,
            C_POINTER,
            C_LONG,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CryptMsgGetAndVerifySigner"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CryptMsgGetAndVerifySigner(HCRYPTMSG hCryptMsg, DWORD cSignerStore, HCERTSTORE *rghSignerStore, DWORD dwFlags, PCCERT_CONTEXT *ppSigner, DWORD *pdwSignerIndex)
     * }
     */
    public static FunctionDescriptor CryptMsgGetAndVerifySigner$descriptor() {
        return CryptMsgGetAndVerifySigner.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CryptMsgGetAndVerifySigner(HCRYPTMSG hCryptMsg, DWORD cSignerStore, HCERTSTORE *rghSignerStore, DWORD dwFlags, PCCERT_CONTEXT *ppSigner, DWORD *pdwSignerIndex)
     * }
     */
    public static MethodHandle CryptMsgGetAndVerifySigner$handle() {
        return CryptMsgGetAndVerifySigner.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL CryptMsgGetAndVerifySigner(HCRYPTMSG hCryptMsg, DWORD cSignerStore, HCERTSTORE *rghSignerStore, DWORD dwFlags, PCCERT_CONTEXT *ppSigner, DWORD *pdwSignerIndex)
     * }
     */
    public static int CryptMsgGetAndVerifySigner(MemorySegment hCryptMsg, int cSignerStore, MemorySegment rghSignerStore, int dwFlags, MemorySegment ppSigner, MemorySegment pdwSignerIndex) {
        var mh$ = CryptMsgGetAndVerifySigner.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CryptMsgGetAndVerifySigner", hCryptMsg, cSignerStore, rghSignerStore, dwFlags, ppSigner, pdwSignerIndex);
            }
            return (int)mh$.invokeExact(hCryptMsg, cSignerStore, rghSignerStore, dwFlags, ppSigner, pdwSignerIndex);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CryptMsgSignCTL {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_LONG,
            C_POINTER,
            C_LONG,
            C_POINTER,
            C_LONG,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CryptMsgSignCTL"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CryptMsgSignCTL(DWORD dwMsgEncodingType, BYTE *pbCtlContent, DWORD cbCtlContent, PCMSG_SIGNED_ENCODE_INFO pSignInfo, DWORD dwFlags, BYTE *pbEncoded, DWORD *pcbEncoded)
     * }
     */
    public static FunctionDescriptor CryptMsgSignCTL$descriptor() {
        return CryptMsgSignCTL.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CryptMsgSignCTL(DWORD dwMsgEncodingType, BYTE *pbCtlContent, DWORD cbCtlContent, PCMSG_SIGNED_ENCODE_INFO pSignInfo, DWORD dwFlags, BYTE *pbEncoded, DWORD *pcbEncoded)
     * }
     */
    public static MethodHandle CryptMsgSignCTL$handle() {
        return CryptMsgSignCTL.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL CryptMsgSignCTL(DWORD dwMsgEncodingType, BYTE *pbCtlContent, DWORD cbCtlContent, PCMSG_SIGNED_ENCODE_INFO pSignInfo, DWORD dwFlags, BYTE *pbEncoded, DWORD *pcbEncoded)
     * }
     */
    public static int CryptMsgSignCTL(int dwMsgEncodingType, MemorySegment pbCtlContent, int cbCtlContent, MemorySegment pSignInfo, int dwFlags, MemorySegment pbEncoded, MemorySegment pcbEncoded) {
        var mh$ = CryptMsgSignCTL.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CryptMsgSignCTL", dwMsgEncodingType, pbCtlContent, cbCtlContent, pSignInfo, dwFlags, pbEncoded, pcbEncoded);
            }
            return (int)mh$.invokeExact(dwMsgEncodingType, pbCtlContent, cbCtlContent, pSignInfo, dwFlags, pbEncoded, pcbEncoded);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CryptMsgEncodeAndSignCTL {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_LONG,
            C_POINTER,
            C_POINTER,
            C_LONG,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CryptMsgEncodeAndSignCTL"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CryptMsgEncodeAndSignCTL(DWORD dwMsgEncodingType, PCTL_INFO pCtlInfo, PCMSG_SIGNED_ENCODE_INFO pSignInfo, DWORD dwFlags, BYTE *pbEncoded, DWORD *pcbEncoded)
     * }
     */
    public static FunctionDescriptor CryptMsgEncodeAndSignCTL$descriptor() {
        return CryptMsgEncodeAndSignCTL.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CryptMsgEncodeAndSignCTL(DWORD dwMsgEncodingType, PCTL_INFO pCtlInfo, PCMSG_SIGNED_ENCODE_INFO pSignInfo, DWORD dwFlags, BYTE *pbEncoded, DWORD *pcbEncoded)
     * }
     */
    public static MethodHandle CryptMsgEncodeAndSignCTL$handle() {
        return CryptMsgEncodeAndSignCTL.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL CryptMsgEncodeAndSignCTL(DWORD dwMsgEncodingType, PCTL_INFO pCtlInfo, PCMSG_SIGNED_ENCODE_INFO pSignInfo, DWORD dwFlags, BYTE *pbEncoded, DWORD *pcbEncoded)
     * }
     */
    public static int CryptMsgEncodeAndSignCTL(int dwMsgEncodingType, MemorySegment pCtlInfo, MemorySegment pSignInfo, int dwFlags, MemorySegment pbEncoded, MemorySegment pcbEncoded) {
        var mh$ = CryptMsgEncodeAndSignCTL.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CryptMsgEncodeAndSignCTL", dwMsgEncodingType, pCtlInfo, pSignInfo, dwFlags, pbEncoded, pcbEncoded);
            }
            return (int)mh$.invokeExact(dwMsgEncodingType, pCtlInfo, pSignInfo, dwFlags, pbEncoded, pcbEncoded);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CertFindSubjectInSortedCTL {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_LONG,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CertFindSubjectInSortedCTL"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CertFindSubjectInSortedCTL(PCRYPT_DATA_BLOB pSubjectIdentifier, PCCTL_CONTEXT pCtlContext, DWORD dwFlags, void *pvReserved, PCRYPT_DER_BLOB pEncodedAttributes)
     * }
     */
    public static FunctionDescriptor CertFindSubjectInSortedCTL$descriptor() {
        return CertFindSubjectInSortedCTL.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CertFindSubjectInSortedCTL(PCRYPT_DATA_BLOB pSubjectIdentifier, PCCTL_CONTEXT pCtlContext, DWORD dwFlags, void *pvReserved, PCRYPT_DER_BLOB pEncodedAttributes)
     * }
     */
    public static MethodHandle CertFindSubjectInSortedCTL$handle() {
        return CertFindSubjectInSortedCTL.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL CertFindSubjectInSortedCTL(PCRYPT_DATA_BLOB pSubjectIdentifier, PCCTL_CONTEXT pCtlContext, DWORD dwFlags, void *pvReserved, PCRYPT_DER_BLOB pEncodedAttributes)
     * }
     */
    public static int CertFindSubjectInSortedCTL(MemorySegment pSubjectIdentifier, MemorySegment pCtlContext, int dwFlags, MemorySegment pvReserved, MemorySegment pEncodedAttributes) {
        var mh$ = CertFindSubjectInSortedCTL.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CertFindSubjectInSortedCTL", pSubjectIdentifier, pCtlContext, dwFlags, pvReserved, pEncodedAttributes);
            }
            return (int)mh$.invokeExact(pSubjectIdentifier, pCtlContext, dwFlags, pvReserved, pEncodedAttributes);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CertEnumSubjectInSortedCTL {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CertEnumSubjectInSortedCTL"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CertEnumSubjectInSortedCTL(PCCTL_CONTEXT pCtlContext, void **ppvNextSubject, PCRYPT_DER_BLOB pSubjectIdentifier, PCRYPT_DER_BLOB pEncodedAttributes)
     * }
     */
    public static FunctionDescriptor CertEnumSubjectInSortedCTL$descriptor() {
        return CertEnumSubjectInSortedCTL.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CertEnumSubjectInSortedCTL(PCCTL_CONTEXT pCtlContext, void **ppvNextSubject, PCRYPT_DER_BLOB pSubjectIdentifier, PCRYPT_DER_BLOB pEncodedAttributes)
     * }
     */
    public static MethodHandle CertEnumSubjectInSortedCTL$handle() {
        return CertEnumSubjectInSortedCTL.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL CertEnumSubjectInSortedCTL(PCCTL_CONTEXT pCtlContext, void **ppvNextSubject, PCRYPT_DER_BLOB pSubjectIdentifier, PCRYPT_DER_BLOB pEncodedAttributes)
     * }
     */
    public static int CertEnumSubjectInSortedCTL(MemorySegment pCtlContext, MemorySegment ppvNextSubject, MemorySegment pSubjectIdentifier, MemorySegment pEncodedAttributes) {
        var mh$ = CertEnumSubjectInSortedCTL.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CertEnumSubjectInSortedCTL", pCtlContext, ppvNextSubject, pSubjectIdentifier, pEncodedAttributes);
            }
            return (int)mh$.invokeExact(pCtlContext, ppvNextSubject, pSubjectIdentifier, pEncodedAttributes);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct _CTL_VERIFY_USAGE_PARA {
     *     DWORD cbSize;
     *     CRYPT_DATA_BLOB ListIdentifier;
     *     DWORD cCtlStore;
     *     HCERTSTORE *rghCtlStore;
     *     DWORD cSignerStore;
     *     HCERTSTORE *rghSignerStore;
     * } *PCTL_VERIFY_USAGE_PARA
     * }
     */
    public static final AddressLayout PCTL_VERIFY_USAGE_PARA = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CTL_VERIFY_USAGE_STATUS {
     *     DWORD cbSize;
     *     DWORD dwError;
     *     DWORD dwFlags;
     *     PCCTL_CONTEXT *ppCtl;
     *     DWORD dwCtlEntryIndex;
     *     PCCERT_CONTEXT *ppSigner;
     *     DWORD dwSignerIndex;
     * } *PCTL_VERIFY_USAGE_STATUS
     * }
     */
    public static final AddressLayout PCTL_VERIFY_USAGE_STATUS = C_POINTER;

    private static class CertVerifyCTLUsage {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_LONG,
            C_LONG,
            C_POINTER,
            C_POINTER,
            C_LONG,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CertVerifyCTLUsage"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CertVerifyCTLUsage(DWORD dwEncodingType, DWORD dwSubjectType, void *pvSubject, PCTL_USAGE pSubjectUsage, DWORD dwFlags, PCTL_VERIFY_USAGE_PARA pVerifyUsagePara, PCTL_VERIFY_USAGE_STATUS pVerifyUsageStatus)
     * }
     */
    public static FunctionDescriptor CertVerifyCTLUsage$descriptor() {
        return CertVerifyCTLUsage.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CertVerifyCTLUsage(DWORD dwEncodingType, DWORD dwSubjectType, void *pvSubject, PCTL_USAGE pSubjectUsage, DWORD dwFlags, PCTL_VERIFY_USAGE_PARA pVerifyUsagePara, PCTL_VERIFY_USAGE_STATUS pVerifyUsageStatus)
     * }
     */
    public static MethodHandle CertVerifyCTLUsage$handle() {
        return CertVerifyCTLUsage.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL CertVerifyCTLUsage(DWORD dwEncodingType, DWORD dwSubjectType, void *pvSubject, PCTL_USAGE pSubjectUsage, DWORD dwFlags, PCTL_VERIFY_USAGE_PARA pVerifyUsagePara, PCTL_VERIFY_USAGE_STATUS pVerifyUsageStatus)
     * }
     */
    public static int CertVerifyCTLUsage(int dwEncodingType, int dwSubjectType, MemorySegment pvSubject, MemorySegment pSubjectUsage, int dwFlags, MemorySegment pVerifyUsagePara, MemorySegment pVerifyUsageStatus) {
        var mh$ = CertVerifyCTLUsage.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CertVerifyCTLUsage", dwEncodingType, dwSubjectType, pvSubject, pSubjectUsage, dwFlags, pVerifyUsagePara, pVerifyUsageStatus);
            }
            return (int)mh$.invokeExact(dwEncodingType, dwSubjectType, pvSubject, pSubjectUsage, dwFlags, pVerifyUsagePara, pVerifyUsageStatus);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct _CERT_REVOCATION_CRL_INFO {
     *     DWORD cbSize;
     *     PCCRL_CONTEXT pBaseCrlContext;
     *     PCCRL_CONTEXT pDeltaCrlContext;
     *     PCRL_ENTRY pCrlEntry;
     *     BOOL fDeltaCrlEntry;
     * } *PCERT_REVOCATION_CRL_INFO
     * }
     */
    public static final AddressLayout PCERT_REVOCATION_CRL_INFO = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CERT_REVOCATION_CHAIN_PARA *PCERT_REVOCATION_CHAIN_PARA
     * }
     */
    public static final AddressLayout PCERT_REVOCATION_CHAIN_PARA = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CERT_REVOCATION_PARA {
     *     DWORD cbSize;
     *     PCCERT_CONTEXT pIssuerCert;
     *     DWORD cCertStore;
     *     HCERTSTORE *rgCertStore;
     *     HCERTSTORE hCrlStore;
     *     LPFILETIME pftTimeToUse;
     * } *PCERT_REVOCATION_PARA
     * }
     */
    public static final AddressLayout PCERT_REVOCATION_PARA = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CERT_REVOCATION_STATUS {
     *     DWORD cbSize;
     *     DWORD dwIndex;
     *     DWORD dwError;
     *     DWORD dwReason;
     *     BOOL fHasFreshnessTime;
     *     DWORD dwFreshnessTime;
     * } *PCERT_REVOCATION_STATUS
     * }
     */
    public static final AddressLayout PCERT_REVOCATION_STATUS = C_POINTER;

    private static class CertVerifyRevocation {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_LONG,
            C_LONG,
            C_LONG,
            C_POINTER,
            C_LONG,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CertVerifyRevocation"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CertVerifyRevocation(DWORD dwEncodingType, DWORD dwRevType, DWORD cContext, PVOID rgpvContext[], DWORD dwFlags, PCERT_REVOCATION_PARA pRevPara, PCERT_REVOCATION_STATUS pRevStatus)
     * }
     */
    public static FunctionDescriptor CertVerifyRevocation$descriptor() {
        return CertVerifyRevocation.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CertVerifyRevocation(DWORD dwEncodingType, DWORD dwRevType, DWORD cContext, PVOID rgpvContext[], DWORD dwFlags, PCERT_REVOCATION_PARA pRevPara, PCERT_REVOCATION_STATUS pRevStatus)
     * }
     */
    public static MethodHandle CertVerifyRevocation$handle() {
        return CertVerifyRevocation.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL CertVerifyRevocation(DWORD dwEncodingType, DWORD dwRevType, DWORD cContext, PVOID rgpvContext[], DWORD dwFlags, PCERT_REVOCATION_PARA pRevPara, PCERT_REVOCATION_STATUS pRevStatus)
     * }
     */
    public static int CertVerifyRevocation(int dwEncodingType, int dwRevType, int cContext, MemorySegment rgpvContext, int dwFlags, MemorySegment pRevPara, MemorySegment pRevStatus) {
        var mh$ = CertVerifyRevocation.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CertVerifyRevocation", dwEncodingType, dwRevType, cContext, rgpvContext, dwFlags, pRevPara, pRevStatus);
            }
            return (int)mh$.invokeExact(dwEncodingType, dwRevType, cContext, rgpvContext, dwFlags, pRevPara, pRevStatus);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CertCompareIntegerBlob {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CertCompareIntegerBlob"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CertCompareIntegerBlob(PCRYPT_INTEGER_BLOB pInt1, PCRYPT_INTEGER_BLOB pInt2)
     * }
     */
    public static FunctionDescriptor CertCompareIntegerBlob$descriptor() {
        return CertCompareIntegerBlob.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CertCompareIntegerBlob(PCRYPT_INTEGER_BLOB pInt1, PCRYPT_INTEGER_BLOB pInt2)
     * }
     */
    public static MethodHandle CertCompareIntegerBlob$handle() {
        return CertCompareIntegerBlob.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL CertCompareIntegerBlob(PCRYPT_INTEGER_BLOB pInt1, PCRYPT_INTEGER_BLOB pInt2)
     * }
     */
    public static int CertCompareIntegerBlob(MemorySegment pInt1, MemorySegment pInt2) {
        var mh$ = CertCompareIntegerBlob.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CertCompareIntegerBlob", pInt1, pInt2);
            }
            return (int)mh$.invokeExact(pInt1, pInt2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CertCompareCertificate {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_LONG,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CertCompareCertificate"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CertCompareCertificate(DWORD dwCertEncodingType, PCERT_INFO pCertId1, PCERT_INFO pCertId2)
     * }
     */
    public static FunctionDescriptor CertCompareCertificate$descriptor() {
        return CertCompareCertificate.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CertCompareCertificate(DWORD dwCertEncodingType, PCERT_INFO pCertId1, PCERT_INFO pCertId2)
     * }
     */
    public static MethodHandle CertCompareCertificate$handle() {
        return CertCompareCertificate.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL CertCompareCertificate(DWORD dwCertEncodingType, PCERT_INFO pCertId1, PCERT_INFO pCertId2)
     * }
     */
    public static int CertCompareCertificate(int dwCertEncodingType, MemorySegment pCertId1, MemorySegment pCertId2) {
        var mh$ = CertCompareCertificate.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CertCompareCertificate", dwCertEncodingType, pCertId1, pCertId2);
            }
            return (int)mh$.invokeExact(dwCertEncodingType, pCertId1, pCertId2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CertCompareCertificateName {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_LONG,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CertCompareCertificateName"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CertCompareCertificateName(DWORD dwCertEncodingType, PCERT_NAME_BLOB pCertName1, PCERT_NAME_BLOB pCertName2)
     * }
     */
    public static FunctionDescriptor CertCompareCertificateName$descriptor() {
        return CertCompareCertificateName.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CertCompareCertificateName(DWORD dwCertEncodingType, PCERT_NAME_BLOB pCertName1, PCERT_NAME_BLOB pCertName2)
     * }
     */
    public static MethodHandle CertCompareCertificateName$handle() {
        return CertCompareCertificateName.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL CertCompareCertificateName(DWORD dwCertEncodingType, PCERT_NAME_BLOB pCertName1, PCERT_NAME_BLOB pCertName2)
     * }
     */
    public static int CertCompareCertificateName(int dwCertEncodingType, MemorySegment pCertName1, MemorySegment pCertName2) {
        var mh$ = CertCompareCertificateName.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CertCompareCertificateName", dwCertEncodingType, pCertName1, pCertName2);
            }
            return (int)mh$.invokeExact(dwCertEncodingType, pCertName1, pCertName2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CertIsRDNAttrsInCertificateName {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_LONG,
            C_LONG,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CertIsRDNAttrsInCertificateName"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CertIsRDNAttrsInCertificateName(DWORD dwCertEncodingType, DWORD dwFlags, PCERT_NAME_BLOB pCertName, PCERT_RDN pRDN)
     * }
     */
    public static FunctionDescriptor CertIsRDNAttrsInCertificateName$descriptor() {
        return CertIsRDNAttrsInCertificateName.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CertIsRDNAttrsInCertificateName(DWORD dwCertEncodingType, DWORD dwFlags, PCERT_NAME_BLOB pCertName, PCERT_RDN pRDN)
     * }
     */
    public static MethodHandle CertIsRDNAttrsInCertificateName$handle() {
        return CertIsRDNAttrsInCertificateName.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL CertIsRDNAttrsInCertificateName(DWORD dwCertEncodingType, DWORD dwFlags, PCERT_NAME_BLOB pCertName, PCERT_RDN pRDN)
     * }
     */
    public static int CertIsRDNAttrsInCertificateName(int dwCertEncodingType, int dwFlags, MemorySegment pCertName, MemorySegment pRDN) {
        var mh$ = CertIsRDNAttrsInCertificateName.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CertIsRDNAttrsInCertificateName", dwCertEncodingType, dwFlags, pCertName, pRDN);
            }
            return (int)mh$.invokeExact(dwCertEncodingType, dwFlags, pCertName, pRDN);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CertComparePublicKeyInfo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_LONG,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CertComparePublicKeyInfo"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CertComparePublicKeyInfo(DWORD dwCertEncodingType, PCERT_PUBLIC_KEY_INFO pPublicKey1, PCERT_PUBLIC_KEY_INFO pPublicKey2)
     * }
     */
    public static FunctionDescriptor CertComparePublicKeyInfo$descriptor() {
        return CertComparePublicKeyInfo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CertComparePublicKeyInfo(DWORD dwCertEncodingType, PCERT_PUBLIC_KEY_INFO pPublicKey1, PCERT_PUBLIC_KEY_INFO pPublicKey2)
     * }
     */
    public static MethodHandle CertComparePublicKeyInfo$handle() {
        return CertComparePublicKeyInfo.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL CertComparePublicKeyInfo(DWORD dwCertEncodingType, PCERT_PUBLIC_KEY_INFO pPublicKey1, PCERT_PUBLIC_KEY_INFO pPublicKey2)
     * }
     */
    public static int CertComparePublicKeyInfo(int dwCertEncodingType, MemorySegment pPublicKey1, MemorySegment pPublicKey2) {
        var mh$ = CertComparePublicKeyInfo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CertComparePublicKeyInfo", dwCertEncodingType, pPublicKey1, pPublicKey2);
            }
            return (int)mh$.invokeExact(dwCertEncodingType, pPublicKey1, pPublicKey2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CertGetPublicKeyLength {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_LONG,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CertGetPublicKeyLength"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD CertGetPublicKeyLength(DWORD dwCertEncodingType, PCERT_PUBLIC_KEY_INFO pPublicKey)
     * }
     */
    public static FunctionDescriptor CertGetPublicKeyLength$descriptor() {
        return CertGetPublicKeyLength.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD CertGetPublicKeyLength(DWORD dwCertEncodingType, PCERT_PUBLIC_KEY_INFO pPublicKey)
     * }
     */
    public static MethodHandle CertGetPublicKeyLength$handle() {
        return CertGetPublicKeyLength.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * DWORD CertGetPublicKeyLength(DWORD dwCertEncodingType, PCERT_PUBLIC_KEY_INFO pPublicKey)
     * }
     */
    public static int CertGetPublicKeyLength(int dwCertEncodingType, MemorySegment pPublicKey) {
        var mh$ = CertGetPublicKeyLength.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CertGetPublicKeyLength", dwCertEncodingType, pPublicKey);
            }
            return (int)mh$.invokeExact(dwCertEncodingType, pPublicKey);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CryptVerifyCertificateSignature {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_LONG_LONG,
            C_LONG,
            C_POINTER,
            C_LONG,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CryptVerifyCertificateSignature"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CryptVerifyCertificateSignature(HCRYPTPROV_LEGACY hCryptProv, DWORD dwCertEncodingType, const BYTE *pbEncoded, DWORD cbEncoded, PCERT_PUBLIC_KEY_INFO pPublicKey)
     * }
     */
    public static FunctionDescriptor CryptVerifyCertificateSignature$descriptor() {
        return CryptVerifyCertificateSignature.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CryptVerifyCertificateSignature(HCRYPTPROV_LEGACY hCryptProv, DWORD dwCertEncodingType, const BYTE *pbEncoded, DWORD cbEncoded, PCERT_PUBLIC_KEY_INFO pPublicKey)
     * }
     */
    public static MethodHandle CryptVerifyCertificateSignature$handle() {
        return CryptVerifyCertificateSignature.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL CryptVerifyCertificateSignature(HCRYPTPROV_LEGACY hCryptProv, DWORD dwCertEncodingType, const BYTE *pbEncoded, DWORD cbEncoded, PCERT_PUBLIC_KEY_INFO pPublicKey)
     * }
     */
    public static int CryptVerifyCertificateSignature(long hCryptProv, int dwCertEncodingType, MemorySegment pbEncoded, int cbEncoded, MemorySegment pPublicKey) {
        var mh$ = CryptVerifyCertificateSignature.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CryptVerifyCertificateSignature", hCryptProv, dwCertEncodingType, pbEncoded, cbEncoded, pPublicKey);
            }
            return (int)mh$.invokeExact(hCryptProv, dwCertEncodingType, pbEncoded, cbEncoded, pPublicKey);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CryptVerifyCertificateSignatureEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_LONG_LONG,
            C_LONG,
            C_LONG,
            C_POINTER,
            C_LONG,
            C_POINTER,
            C_LONG,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CryptVerifyCertificateSignatureEx"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CryptVerifyCertificateSignatureEx(HCRYPTPROV_LEGACY hCryptProv, DWORD dwCertEncodingType, DWORD dwSubjectType, void *pvSubject, DWORD dwIssuerType, void *pvIssuer, DWORD dwFlags, void *pvExtra)
     * }
     */
    public static FunctionDescriptor CryptVerifyCertificateSignatureEx$descriptor() {
        return CryptVerifyCertificateSignatureEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CryptVerifyCertificateSignatureEx(HCRYPTPROV_LEGACY hCryptProv, DWORD dwCertEncodingType, DWORD dwSubjectType, void *pvSubject, DWORD dwIssuerType, void *pvIssuer, DWORD dwFlags, void *pvExtra)
     * }
     */
    public static MethodHandle CryptVerifyCertificateSignatureEx$handle() {
        return CryptVerifyCertificateSignatureEx.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL CryptVerifyCertificateSignatureEx(HCRYPTPROV_LEGACY hCryptProv, DWORD dwCertEncodingType, DWORD dwSubjectType, void *pvSubject, DWORD dwIssuerType, void *pvIssuer, DWORD dwFlags, void *pvExtra)
     * }
     */
    public static int CryptVerifyCertificateSignatureEx(long hCryptProv, int dwCertEncodingType, int dwSubjectType, MemorySegment pvSubject, int dwIssuerType, MemorySegment pvIssuer, int dwFlags, MemorySegment pvExtra) {
        var mh$ = CryptVerifyCertificateSignatureEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CryptVerifyCertificateSignatureEx", hCryptProv, dwCertEncodingType, dwSubjectType, pvSubject, dwIssuerType, pvIssuer, dwFlags, pvExtra);
            }
            return (int)mh$.invokeExact(hCryptProv, dwCertEncodingType, dwSubjectType, pvSubject, dwIssuerType, pvIssuer, dwFlags, pvExtra);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct _CRYPT_VERIFY_CERT_SIGN_STRONG_PROPERTIES_INFO {
     *     CRYPT_DATA_BLOB CertSignHashCNGAlgPropData;
     *     CRYPT_DATA_BLOB CertIssuerPubKeyBitLengthPropData;
     * } *PCRYPT_VERIFY_CERT_SIGN_STRONG_PROPERTIES_INFO
     * }
     */
    public static final AddressLayout PCRYPT_VERIFY_CERT_SIGN_STRONG_PROPERTIES_INFO = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CRYPT_VERIFY_CERT_SIGN_WEAK_HASH_INFO {
     *     DWORD cCNGHashAlgid;
     *     PCWSTR *rgpwszCNGHashAlgid;
     *     DWORD dwWeakIndex;
     * } *PCRYPT_VERIFY_CERT_SIGN_WEAK_HASH_INFO
     * }
     */
    public static final AddressLayout PCRYPT_VERIFY_CERT_SIGN_WEAK_HASH_INFO = C_POINTER;

    private static class CertIsStrongHashToSign {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CertIsStrongHashToSign"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CertIsStrongHashToSign(PCCERT_STRONG_SIGN_PARA pStrongSignPara, LPCWSTR pwszCNGHashAlgid, PCCERT_CONTEXT pSigningCert)
     * }
     */
    public static FunctionDescriptor CertIsStrongHashToSign$descriptor() {
        return CertIsStrongHashToSign.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CertIsStrongHashToSign(PCCERT_STRONG_SIGN_PARA pStrongSignPara, LPCWSTR pwszCNGHashAlgid, PCCERT_CONTEXT pSigningCert)
     * }
     */
    public static MethodHandle CertIsStrongHashToSign$handle() {
        return CertIsStrongHashToSign.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL CertIsStrongHashToSign(PCCERT_STRONG_SIGN_PARA pStrongSignPara, LPCWSTR pwszCNGHashAlgid, PCCERT_CONTEXT pSigningCert)
     * }
     */
    public static int CertIsStrongHashToSign(MemorySegment pStrongSignPara, MemorySegment pwszCNGHashAlgid, MemorySegment pSigningCert) {
        var mh$ = CertIsStrongHashToSign.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CertIsStrongHashToSign", pStrongSignPara, pwszCNGHashAlgid, pSigningCert);
            }
            return (int)mh$.invokeExact(pStrongSignPara, pwszCNGHashAlgid, pSigningCert);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CryptHashToBeSigned {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_LONG_LONG,
            C_LONG,
            C_POINTER,
            C_LONG,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CryptHashToBeSigned"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CryptHashToBeSigned(HCRYPTPROV_LEGACY hCryptProv, DWORD dwCertEncodingType, const BYTE *pbEncoded, DWORD cbEncoded, BYTE *pbComputedHash, DWORD *pcbComputedHash)
     * }
     */
    public static FunctionDescriptor CryptHashToBeSigned$descriptor() {
        return CryptHashToBeSigned.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CryptHashToBeSigned(HCRYPTPROV_LEGACY hCryptProv, DWORD dwCertEncodingType, const BYTE *pbEncoded, DWORD cbEncoded, BYTE *pbComputedHash, DWORD *pcbComputedHash)
     * }
     */
    public static MethodHandle CryptHashToBeSigned$handle() {
        return CryptHashToBeSigned.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL CryptHashToBeSigned(HCRYPTPROV_LEGACY hCryptProv, DWORD dwCertEncodingType, const BYTE *pbEncoded, DWORD cbEncoded, BYTE *pbComputedHash, DWORD *pcbComputedHash)
     * }
     */
    public static int CryptHashToBeSigned(long hCryptProv, int dwCertEncodingType, MemorySegment pbEncoded, int cbEncoded, MemorySegment pbComputedHash, MemorySegment pcbComputedHash) {
        var mh$ = CryptHashToBeSigned.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CryptHashToBeSigned", hCryptProv, dwCertEncodingType, pbEncoded, cbEncoded, pbComputedHash, pcbComputedHash);
            }
            return (int)mh$.invokeExact(hCryptProv, dwCertEncodingType, pbEncoded, cbEncoded, pbComputedHash, pcbComputedHash);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CryptHashCertificate {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_LONG_LONG,
            C_INT,
            C_LONG,
            C_POINTER,
            C_LONG,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CryptHashCertificate"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CryptHashCertificate(HCRYPTPROV_LEGACY hCryptProv, ALG_ID Algid, DWORD dwFlags, const BYTE *pbEncoded, DWORD cbEncoded, BYTE *pbComputedHash, DWORD *pcbComputedHash)
     * }
     */
    public static FunctionDescriptor CryptHashCertificate$descriptor() {
        return CryptHashCertificate.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CryptHashCertificate(HCRYPTPROV_LEGACY hCryptProv, ALG_ID Algid, DWORD dwFlags, const BYTE *pbEncoded, DWORD cbEncoded, BYTE *pbComputedHash, DWORD *pcbComputedHash)
     * }
     */
    public static MethodHandle CryptHashCertificate$handle() {
        return CryptHashCertificate.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL CryptHashCertificate(HCRYPTPROV_LEGACY hCryptProv, ALG_ID Algid, DWORD dwFlags, const BYTE *pbEncoded, DWORD cbEncoded, BYTE *pbComputedHash, DWORD *pcbComputedHash)
     * }
     */
    public static int CryptHashCertificate(long hCryptProv, int Algid, int dwFlags, MemorySegment pbEncoded, int cbEncoded, MemorySegment pbComputedHash, MemorySegment pcbComputedHash) {
        var mh$ = CryptHashCertificate.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CryptHashCertificate", hCryptProv, Algid, dwFlags, pbEncoded, cbEncoded, pbComputedHash, pcbComputedHash);
            }
            return (int)mh$.invokeExact(hCryptProv, Algid, dwFlags, pbEncoded, cbEncoded, pbComputedHash, pcbComputedHash);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CryptHashCertificate2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_LONG,
            C_POINTER,
            C_POINTER,
            C_LONG,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CryptHashCertificate2"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CryptHashCertificate2(LPCWSTR pwszCNGHashAlgid, DWORD dwFlags, void *pvReserved, const BYTE *pbEncoded, DWORD cbEncoded, BYTE *pbComputedHash, DWORD *pcbComputedHash)
     * }
     */
    public static FunctionDescriptor CryptHashCertificate2$descriptor() {
        return CryptHashCertificate2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CryptHashCertificate2(LPCWSTR pwszCNGHashAlgid, DWORD dwFlags, void *pvReserved, const BYTE *pbEncoded, DWORD cbEncoded, BYTE *pbComputedHash, DWORD *pcbComputedHash)
     * }
     */
    public static MethodHandle CryptHashCertificate2$handle() {
        return CryptHashCertificate2.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL CryptHashCertificate2(LPCWSTR pwszCNGHashAlgid, DWORD dwFlags, void *pvReserved, const BYTE *pbEncoded, DWORD cbEncoded, BYTE *pbComputedHash, DWORD *pcbComputedHash)
     * }
     */
    public static int CryptHashCertificate2(MemorySegment pwszCNGHashAlgid, int dwFlags, MemorySegment pvReserved, MemorySegment pbEncoded, int cbEncoded, MemorySegment pbComputedHash, MemorySegment pcbComputedHash) {
        var mh$ = CryptHashCertificate2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CryptHashCertificate2", pwszCNGHashAlgid, dwFlags, pvReserved, pbEncoded, cbEncoded, pbComputedHash, pcbComputedHash);
            }
            return (int)mh$.invokeExact(pwszCNGHashAlgid, dwFlags, pvReserved, pbEncoded, cbEncoded, pbComputedHash, pcbComputedHash);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CryptSignCertificate {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_LONG_LONG,
            C_LONG,
            C_LONG,
            C_POINTER,
            C_LONG,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CryptSignCertificate"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CryptSignCertificate(HCRYPTPROV_OR_NCRYPT_KEY_HANDLE hCryptProvOrNCryptKey, DWORD dwKeySpec, DWORD dwCertEncodingType, const BYTE *pbEncodedToBeSigned, DWORD cbEncodedToBeSigned, PCRYPT_ALGORITHM_IDENTIFIER pSignatureAlgorithm, const void *pvHashAuxInfo, BYTE *pbSignature, DWORD *pcbSignature)
     * }
     */
    public static FunctionDescriptor CryptSignCertificate$descriptor() {
        return CryptSignCertificate.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CryptSignCertificate(HCRYPTPROV_OR_NCRYPT_KEY_HANDLE hCryptProvOrNCryptKey, DWORD dwKeySpec, DWORD dwCertEncodingType, const BYTE *pbEncodedToBeSigned, DWORD cbEncodedToBeSigned, PCRYPT_ALGORITHM_IDENTIFIER pSignatureAlgorithm, const void *pvHashAuxInfo, BYTE *pbSignature, DWORD *pcbSignature)
     * }
     */
    public static MethodHandle CryptSignCertificate$handle() {
        return CryptSignCertificate.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL CryptSignCertificate(HCRYPTPROV_OR_NCRYPT_KEY_HANDLE hCryptProvOrNCryptKey, DWORD dwKeySpec, DWORD dwCertEncodingType, const BYTE *pbEncodedToBeSigned, DWORD cbEncodedToBeSigned, PCRYPT_ALGORITHM_IDENTIFIER pSignatureAlgorithm, const void *pvHashAuxInfo, BYTE *pbSignature, DWORD *pcbSignature)
     * }
     */
    public static int CryptSignCertificate(long hCryptProvOrNCryptKey, int dwKeySpec, int dwCertEncodingType, MemorySegment pbEncodedToBeSigned, int cbEncodedToBeSigned, MemorySegment pSignatureAlgorithm, MemorySegment pvHashAuxInfo, MemorySegment pbSignature, MemorySegment pcbSignature) {
        var mh$ = CryptSignCertificate.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CryptSignCertificate", hCryptProvOrNCryptKey, dwKeySpec, dwCertEncodingType, pbEncodedToBeSigned, cbEncodedToBeSigned, pSignatureAlgorithm, pvHashAuxInfo, pbSignature, pcbSignature);
            }
            return (int)mh$.invokeExact(hCryptProvOrNCryptKey, dwKeySpec, dwCertEncodingType, pbEncodedToBeSigned, cbEncodedToBeSigned, pSignatureAlgorithm, pvHashAuxInfo, pbSignature, pcbSignature);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CryptSignAndEncodeCertificate {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_LONG_LONG,
            C_LONG,
            C_LONG,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CryptSignAndEncodeCertificate"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CryptSignAndEncodeCertificate(HCRYPTPROV_OR_NCRYPT_KEY_HANDLE hCryptProvOrNCryptKey, DWORD dwKeySpec, DWORD dwCertEncodingType, LPCSTR lpszStructType, const void *pvStructInfo, PCRYPT_ALGORITHM_IDENTIFIER pSignatureAlgorithm, const void *pvHashAuxInfo, BYTE *pbEncoded, DWORD *pcbEncoded)
     * }
     */
    public static FunctionDescriptor CryptSignAndEncodeCertificate$descriptor() {
        return CryptSignAndEncodeCertificate.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CryptSignAndEncodeCertificate(HCRYPTPROV_OR_NCRYPT_KEY_HANDLE hCryptProvOrNCryptKey, DWORD dwKeySpec, DWORD dwCertEncodingType, LPCSTR lpszStructType, const void *pvStructInfo, PCRYPT_ALGORITHM_IDENTIFIER pSignatureAlgorithm, const void *pvHashAuxInfo, BYTE *pbEncoded, DWORD *pcbEncoded)
     * }
     */
    public static MethodHandle CryptSignAndEncodeCertificate$handle() {
        return CryptSignAndEncodeCertificate.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL CryptSignAndEncodeCertificate(HCRYPTPROV_OR_NCRYPT_KEY_HANDLE hCryptProvOrNCryptKey, DWORD dwKeySpec, DWORD dwCertEncodingType, LPCSTR lpszStructType, const void *pvStructInfo, PCRYPT_ALGORITHM_IDENTIFIER pSignatureAlgorithm, const void *pvHashAuxInfo, BYTE *pbEncoded, DWORD *pcbEncoded)
     * }
     */
    public static int CryptSignAndEncodeCertificate(long hCryptProvOrNCryptKey, int dwKeySpec, int dwCertEncodingType, MemorySegment lpszStructType, MemorySegment pvStructInfo, MemorySegment pSignatureAlgorithm, MemorySegment pvHashAuxInfo, MemorySegment pbEncoded, MemorySegment pcbEncoded) {
        var mh$ = CryptSignAndEncodeCertificate.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CryptSignAndEncodeCertificate", hCryptProvOrNCryptKey, dwKeySpec, dwCertEncodingType, lpszStructType, pvStructInfo, pSignatureAlgorithm, pvHashAuxInfo, pbEncoded, pcbEncoded);
            }
            return (int)mh$.invokeExact(hCryptProvOrNCryptKey, dwKeySpec, dwCertEncodingType, lpszStructType, pvStructInfo, pSignatureAlgorithm, pvHashAuxInfo, pbEncoded, pcbEncoded);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CertVerifyTimeValidity {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CertVerifyTimeValidity"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LONG CertVerifyTimeValidity(LPFILETIME pTimeToVerify, PCERT_INFO pCertInfo)
     * }
     */
    public static FunctionDescriptor CertVerifyTimeValidity$descriptor() {
        return CertVerifyTimeValidity.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LONG CertVerifyTimeValidity(LPFILETIME pTimeToVerify, PCERT_INFO pCertInfo)
     * }
     */
    public static MethodHandle CertVerifyTimeValidity$handle() {
        return CertVerifyTimeValidity.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * LONG CertVerifyTimeValidity(LPFILETIME pTimeToVerify, PCERT_INFO pCertInfo)
     * }
     */
    public static int CertVerifyTimeValidity(MemorySegment pTimeToVerify, MemorySegment pCertInfo) {
        var mh$ = CertVerifyTimeValidity.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CertVerifyTimeValidity", pTimeToVerify, pCertInfo);
            }
            return (int)mh$.invokeExact(pTimeToVerify, pCertInfo);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CertVerifyCRLTimeValidity {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CertVerifyCRLTimeValidity"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LONG CertVerifyCRLTimeValidity(LPFILETIME pTimeToVerify, PCRL_INFO pCrlInfo)
     * }
     */
    public static FunctionDescriptor CertVerifyCRLTimeValidity$descriptor() {
        return CertVerifyCRLTimeValidity.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LONG CertVerifyCRLTimeValidity(LPFILETIME pTimeToVerify, PCRL_INFO pCrlInfo)
     * }
     */
    public static MethodHandle CertVerifyCRLTimeValidity$handle() {
        return CertVerifyCRLTimeValidity.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * LONG CertVerifyCRLTimeValidity(LPFILETIME pTimeToVerify, PCRL_INFO pCrlInfo)
     * }
     */
    public static int CertVerifyCRLTimeValidity(MemorySegment pTimeToVerify, MemorySegment pCrlInfo) {
        var mh$ = CertVerifyCRLTimeValidity.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CertVerifyCRLTimeValidity", pTimeToVerify, pCrlInfo);
            }
            return (int)mh$.invokeExact(pTimeToVerify, pCrlInfo);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CertVerifyValidityNesting {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CertVerifyValidityNesting"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CertVerifyValidityNesting(PCERT_INFO pSubjectInfo, PCERT_INFO pIssuerInfo)
     * }
     */
    public static FunctionDescriptor CertVerifyValidityNesting$descriptor() {
        return CertVerifyValidityNesting.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CertVerifyValidityNesting(PCERT_INFO pSubjectInfo, PCERT_INFO pIssuerInfo)
     * }
     */
    public static MethodHandle CertVerifyValidityNesting$handle() {
        return CertVerifyValidityNesting.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL CertVerifyValidityNesting(PCERT_INFO pSubjectInfo, PCERT_INFO pIssuerInfo)
     * }
     */
    public static int CertVerifyValidityNesting(MemorySegment pSubjectInfo, MemorySegment pIssuerInfo) {
        var mh$ = CertVerifyValidityNesting.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CertVerifyValidityNesting", pSubjectInfo, pIssuerInfo);
            }
            return (int)mh$.invokeExact(pSubjectInfo, pIssuerInfo);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CertVerifyCRLRevocation {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_LONG,
            C_POINTER,
            C_LONG,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CertVerifyCRLRevocation"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CertVerifyCRLRevocation(DWORD dwCertEncodingType, PCERT_INFO pCertId, DWORD cCrlInfo, PCRL_INFO rgpCrlInfo[])
     * }
     */
    public static FunctionDescriptor CertVerifyCRLRevocation$descriptor() {
        return CertVerifyCRLRevocation.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CertVerifyCRLRevocation(DWORD dwCertEncodingType, PCERT_INFO pCertId, DWORD cCrlInfo, PCRL_INFO rgpCrlInfo[])
     * }
     */
    public static MethodHandle CertVerifyCRLRevocation$handle() {
        return CertVerifyCRLRevocation.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL CertVerifyCRLRevocation(DWORD dwCertEncodingType, PCERT_INFO pCertId, DWORD cCrlInfo, PCRL_INFO rgpCrlInfo[])
     * }
     */
    public static int CertVerifyCRLRevocation(int dwCertEncodingType, MemorySegment pCertId, int cCrlInfo, MemorySegment rgpCrlInfo) {
        var mh$ = CertVerifyCRLRevocation.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CertVerifyCRLRevocation", dwCertEncodingType, pCertId, cCrlInfo, rgpCrlInfo);
            }
            return (int)mh$.invokeExact(dwCertEncodingType, pCertId, cCrlInfo, rgpCrlInfo);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CertAlgIdToOID {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CertAlgIdToOID"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LPCSTR CertAlgIdToOID(DWORD dwAlgId)
     * }
     */
    public static FunctionDescriptor CertAlgIdToOID$descriptor() {
        return CertAlgIdToOID.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LPCSTR CertAlgIdToOID(DWORD dwAlgId)
     * }
     */
    public static MethodHandle CertAlgIdToOID$handle() {
        return CertAlgIdToOID.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * LPCSTR CertAlgIdToOID(DWORD dwAlgId)
     * }
     */
    public static MemorySegment CertAlgIdToOID(int dwAlgId) {
        var mh$ = CertAlgIdToOID.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CertAlgIdToOID", dwAlgId);
            }
            return (MemorySegment)mh$.invokeExact(dwAlgId);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CertOIDToAlgId {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CertOIDToAlgId"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD CertOIDToAlgId(LPCSTR pszObjId)
     * }
     */
    public static FunctionDescriptor CertOIDToAlgId$descriptor() {
        return CertOIDToAlgId.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD CertOIDToAlgId(LPCSTR pszObjId)
     * }
     */
    public static MethodHandle CertOIDToAlgId$handle() {
        return CertOIDToAlgId.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * DWORD CertOIDToAlgId(LPCSTR pszObjId)
     * }
     */
    public static int CertOIDToAlgId(MemorySegment pszObjId) {
        var mh$ = CertOIDToAlgId.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CertOIDToAlgId", pszObjId);
            }
            return (int)mh$.invokeExact(pszObjId);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CertFindExtension {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER,
            C_LONG,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CertFindExtension"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PCERT_EXTENSION CertFindExtension(LPCSTR pszObjId, DWORD cExtensions, CERT_EXTENSION rgExtensions[])
     * }
     */
    public static FunctionDescriptor CertFindExtension$descriptor() {
        return CertFindExtension.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PCERT_EXTENSION CertFindExtension(LPCSTR pszObjId, DWORD cExtensions, CERT_EXTENSION rgExtensions[])
     * }
     */
    public static MethodHandle CertFindExtension$handle() {
        return CertFindExtension.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * PCERT_EXTENSION CertFindExtension(LPCSTR pszObjId, DWORD cExtensions, CERT_EXTENSION rgExtensions[])
     * }
     */
    public static MemorySegment CertFindExtension(MemorySegment pszObjId, int cExtensions, MemorySegment rgExtensions) {
        var mh$ = CertFindExtension.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CertFindExtension", pszObjId, cExtensions, rgExtensions);
            }
            return (MemorySegment)mh$.invokeExact(pszObjId, cExtensions, rgExtensions);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CertFindAttribute {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER,
            C_LONG,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CertFindAttribute"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PCRYPT_ATTRIBUTE CertFindAttribute(LPCSTR pszObjId, DWORD cAttr, CRYPT_ATTRIBUTE rgAttr[])
     * }
     */
    public static FunctionDescriptor CertFindAttribute$descriptor() {
        return CertFindAttribute.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PCRYPT_ATTRIBUTE CertFindAttribute(LPCSTR pszObjId, DWORD cAttr, CRYPT_ATTRIBUTE rgAttr[])
     * }
     */
    public static MethodHandle CertFindAttribute$handle() {
        return CertFindAttribute.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * PCRYPT_ATTRIBUTE CertFindAttribute(LPCSTR pszObjId, DWORD cAttr, CRYPT_ATTRIBUTE rgAttr[])
     * }
     */
    public static MemorySegment CertFindAttribute(MemorySegment pszObjId, int cAttr, MemorySegment rgAttr) {
        var mh$ = CertFindAttribute.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CertFindAttribute", pszObjId, cAttr, rgAttr);
            }
            return (MemorySegment)mh$.invokeExact(pszObjId, cAttr, rgAttr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CertFindRDNAttr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CertFindRDNAttr"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PCERT_RDN_ATTR CertFindRDNAttr(LPCSTR pszObjId, PCERT_NAME_INFO pName)
     * }
     */
    public static FunctionDescriptor CertFindRDNAttr$descriptor() {
        return CertFindRDNAttr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PCERT_RDN_ATTR CertFindRDNAttr(LPCSTR pszObjId, PCERT_NAME_INFO pName)
     * }
     */
    public static MethodHandle CertFindRDNAttr$handle() {
        return CertFindRDNAttr.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * PCERT_RDN_ATTR CertFindRDNAttr(LPCSTR pszObjId, PCERT_NAME_INFO pName)
     * }
     */
    public static MemorySegment CertFindRDNAttr(MemorySegment pszObjId, MemorySegment pName) {
        var mh$ = CertFindRDNAttr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CertFindRDNAttr", pszObjId, pName);
            }
            return (MemorySegment)mh$.invokeExact(pszObjId, pName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CertGetIntendedKeyUsage {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_LONG,
            C_POINTER,
            C_POINTER,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CertGetIntendedKeyUsage"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CertGetIntendedKeyUsage(DWORD dwCertEncodingType, PCERT_INFO pCertInfo, BYTE *pbKeyUsage, DWORD cbKeyUsage)
     * }
     */
    public static FunctionDescriptor CertGetIntendedKeyUsage$descriptor() {
        return CertGetIntendedKeyUsage.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CertGetIntendedKeyUsage(DWORD dwCertEncodingType, PCERT_INFO pCertInfo, BYTE *pbKeyUsage, DWORD cbKeyUsage)
     * }
     */
    public static MethodHandle CertGetIntendedKeyUsage$handle() {
        return CertGetIntendedKeyUsage.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL CertGetIntendedKeyUsage(DWORD dwCertEncodingType, PCERT_INFO pCertInfo, BYTE *pbKeyUsage, DWORD cbKeyUsage)
     * }
     */
    public static int CertGetIntendedKeyUsage(int dwCertEncodingType, MemorySegment pCertInfo, MemorySegment pbKeyUsage, int cbKeyUsage) {
        var mh$ = CertGetIntendedKeyUsage.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CertGetIntendedKeyUsage", dwCertEncodingType, pCertInfo, pbKeyUsage, cbKeyUsage);
            }
            return (int)mh$.invokeExact(dwCertEncodingType, pCertInfo, pbKeyUsage, cbKeyUsage);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef void *HCRYPTDEFAULTCONTEXT
     * }
     */
    public static final AddressLayout HCRYPTDEFAULTCONTEXT = C_POINTER;

    private static class CryptInstallDefaultContext {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_LONG_LONG,
            C_LONG,
            C_POINTER,
            C_LONG,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CryptInstallDefaultContext"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CryptInstallDefaultContext(HCRYPTPROV hCryptProv, DWORD dwDefaultType, const void *pvDefaultPara, DWORD dwFlags, void *pvReserved, HCRYPTDEFAULTCONTEXT *phDefaultContext)
     * }
     */
    public static FunctionDescriptor CryptInstallDefaultContext$descriptor() {
        return CryptInstallDefaultContext.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CryptInstallDefaultContext(HCRYPTPROV hCryptProv, DWORD dwDefaultType, const void *pvDefaultPara, DWORD dwFlags, void *pvReserved, HCRYPTDEFAULTCONTEXT *phDefaultContext)
     * }
     */
    public static MethodHandle CryptInstallDefaultContext$handle() {
        return CryptInstallDefaultContext.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL CryptInstallDefaultContext(HCRYPTPROV hCryptProv, DWORD dwDefaultType, const void *pvDefaultPara, DWORD dwFlags, void *pvReserved, HCRYPTDEFAULTCONTEXT *phDefaultContext)
     * }
     */
    public static int CryptInstallDefaultContext(long hCryptProv, int dwDefaultType, MemorySegment pvDefaultPara, int dwFlags, MemorySegment pvReserved, MemorySegment phDefaultContext) {
        var mh$ = CryptInstallDefaultContext.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CryptInstallDefaultContext", hCryptProv, dwDefaultType, pvDefaultPara, dwFlags, pvReserved, phDefaultContext);
            }
            return (int)mh$.invokeExact(hCryptProv, dwDefaultType, pvDefaultPara, dwFlags, pvReserved, phDefaultContext);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct _CRYPT_DEFAULT_CONTEXT_MULTI_OID_PARA {
     *     DWORD cOID;
     *     LPSTR *rgpszOID;
     * } *PCRYPT_DEFAULT_CONTEXT_MULTI_OID_PARA
     * }
     */
    public static final AddressLayout PCRYPT_DEFAULT_CONTEXT_MULTI_OID_PARA = C_POINTER;

    private static class CryptUninstallDefaultContext {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_LONG,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CryptUninstallDefaultContext"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CryptUninstallDefaultContext(HCRYPTDEFAULTCONTEXT hDefaultContext, DWORD dwFlags, void *pvReserved)
     * }
     */
    public static FunctionDescriptor CryptUninstallDefaultContext$descriptor() {
        return CryptUninstallDefaultContext.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CryptUninstallDefaultContext(HCRYPTDEFAULTCONTEXT hDefaultContext, DWORD dwFlags, void *pvReserved)
     * }
     */
    public static MethodHandle CryptUninstallDefaultContext$handle() {
        return CryptUninstallDefaultContext.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL CryptUninstallDefaultContext(HCRYPTDEFAULTCONTEXT hDefaultContext, DWORD dwFlags, void *pvReserved)
     * }
     */
    public static int CryptUninstallDefaultContext(MemorySegment hDefaultContext, int dwFlags, MemorySegment pvReserved) {
        var mh$ = CryptUninstallDefaultContext.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CryptUninstallDefaultContext", hDefaultContext, dwFlags, pvReserved);
            }
            return (int)mh$.invokeExact(hDefaultContext, dwFlags, pvReserved);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CryptExportPublicKeyInfo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_LONG_LONG,
            C_LONG,
            C_LONG,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CryptExportPublicKeyInfo"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CryptExportPublicKeyInfo(HCRYPTPROV_OR_NCRYPT_KEY_HANDLE hCryptProvOrNCryptKey, DWORD dwKeySpec, DWORD dwCertEncodingType, PCERT_PUBLIC_KEY_INFO pInfo, DWORD *pcbInfo)
     * }
     */
    public static FunctionDescriptor CryptExportPublicKeyInfo$descriptor() {
        return CryptExportPublicKeyInfo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CryptExportPublicKeyInfo(HCRYPTPROV_OR_NCRYPT_KEY_HANDLE hCryptProvOrNCryptKey, DWORD dwKeySpec, DWORD dwCertEncodingType, PCERT_PUBLIC_KEY_INFO pInfo, DWORD *pcbInfo)
     * }
     */
    public static MethodHandle CryptExportPublicKeyInfo$handle() {
        return CryptExportPublicKeyInfo.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL CryptExportPublicKeyInfo(HCRYPTPROV_OR_NCRYPT_KEY_HANDLE hCryptProvOrNCryptKey, DWORD dwKeySpec, DWORD dwCertEncodingType, PCERT_PUBLIC_KEY_INFO pInfo, DWORD *pcbInfo)
     * }
     */
    public static int CryptExportPublicKeyInfo(long hCryptProvOrNCryptKey, int dwKeySpec, int dwCertEncodingType, MemorySegment pInfo, MemorySegment pcbInfo) {
        var mh$ = CryptExportPublicKeyInfo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CryptExportPublicKeyInfo", hCryptProvOrNCryptKey, dwKeySpec, dwCertEncodingType, pInfo, pcbInfo);
            }
            return (int)mh$.invokeExact(hCryptProvOrNCryptKey, dwKeySpec, dwCertEncodingType, pInfo, pcbInfo);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CryptExportPublicKeyInfoEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_LONG_LONG,
            C_LONG,
            C_LONG,
            C_POINTER,
            C_LONG,
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CryptExportPublicKeyInfoEx"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CryptExportPublicKeyInfoEx(HCRYPTPROV_OR_NCRYPT_KEY_HANDLE hCryptProvOrNCryptKey, DWORD dwKeySpec, DWORD dwCertEncodingType, LPSTR pszPublicKeyObjId, DWORD dwFlags, void *pvAuxInfo, PCERT_PUBLIC_KEY_INFO pInfo, DWORD *pcbInfo)
     * }
     */
    public static FunctionDescriptor CryptExportPublicKeyInfoEx$descriptor() {
        return CryptExportPublicKeyInfoEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CryptExportPublicKeyInfoEx(HCRYPTPROV_OR_NCRYPT_KEY_HANDLE hCryptProvOrNCryptKey, DWORD dwKeySpec, DWORD dwCertEncodingType, LPSTR pszPublicKeyObjId, DWORD dwFlags, void *pvAuxInfo, PCERT_PUBLIC_KEY_INFO pInfo, DWORD *pcbInfo)
     * }
     */
    public static MethodHandle CryptExportPublicKeyInfoEx$handle() {
        return CryptExportPublicKeyInfoEx.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL CryptExportPublicKeyInfoEx(HCRYPTPROV_OR_NCRYPT_KEY_HANDLE hCryptProvOrNCryptKey, DWORD dwKeySpec, DWORD dwCertEncodingType, LPSTR pszPublicKeyObjId, DWORD dwFlags, void *pvAuxInfo, PCERT_PUBLIC_KEY_INFO pInfo, DWORD *pcbInfo)
     * }
     */
    public static int CryptExportPublicKeyInfoEx(long hCryptProvOrNCryptKey, int dwKeySpec, int dwCertEncodingType, MemorySegment pszPublicKeyObjId, int dwFlags, MemorySegment pvAuxInfo, MemorySegment pInfo, MemorySegment pcbInfo) {
        var mh$ = CryptExportPublicKeyInfoEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CryptExportPublicKeyInfoEx", hCryptProvOrNCryptKey, dwKeySpec, dwCertEncodingType, pszPublicKeyObjId, dwFlags, pvAuxInfo, pInfo, pcbInfo);
            }
            return (int)mh$.invokeExact(hCryptProvOrNCryptKey, dwKeySpec, dwCertEncodingType, pszPublicKeyObjId, dwFlags, pvAuxInfo, pInfo, pcbInfo);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CryptExportPublicKeyInfoFromBCryptKeyHandle {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_LONG,
            C_POINTER,
            C_LONG,
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CryptExportPublicKeyInfoFromBCryptKeyHandle"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CryptExportPublicKeyInfoFromBCryptKeyHandle(BCRYPT_KEY_HANDLE hBCryptKey, DWORD dwCertEncodingType, LPSTR pszPublicKeyObjId, DWORD dwFlags, void *pvAuxInfo, PCERT_PUBLIC_KEY_INFO pInfo, DWORD *pcbInfo)
     * }
     */
    public static FunctionDescriptor CryptExportPublicKeyInfoFromBCryptKeyHandle$descriptor() {
        return CryptExportPublicKeyInfoFromBCryptKeyHandle.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CryptExportPublicKeyInfoFromBCryptKeyHandle(BCRYPT_KEY_HANDLE hBCryptKey, DWORD dwCertEncodingType, LPSTR pszPublicKeyObjId, DWORD dwFlags, void *pvAuxInfo, PCERT_PUBLIC_KEY_INFO pInfo, DWORD *pcbInfo)
     * }
     */
    public static MethodHandle CryptExportPublicKeyInfoFromBCryptKeyHandle$handle() {
        return CryptExportPublicKeyInfoFromBCryptKeyHandle.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL CryptExportPublicKeyInfoFromBCryptKeyHandle(BCRYPT_KEY_HANDLE hBCryptKey, DWORD dwCertEncodingType, LPSTR pszPublicKeyObjId, DWORD dwFlags, void *pvAuxInfo, PCERT_PUBLIC_KEY_INFO pInfo, DWORD *pcbInfo)
     * }
     */
    public static int CryptExportPublicKeyInfoFromBCryptKeyHandle(MemorySegment hBCryptKey, int dwCertEncodingType, MemorySegment pszPublicKeyObjId, int dwFlags, MemorySegment pvAuxInfo, MemorySegment pInfo, MemorySegment pcbInfo) {
        var mh$ = CryptExportPublicKeyInfoFromBCryptKeyHandle.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CryptExportPublicKeyInfoFromBCryptKeyHandle", hBCryptKey, dwCertEncodingType, pszPublicKeyObjId, dwFlags, pvAuxInfo, pInfo, pcbInfo);
            }
            return (int)mh$.invokeExact(hBCryptKey, dwCertEncodingType, pszPublicKeyObjId, dwFlags, pvAuxInfo, pInfo, pcbInfo);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CryptImportPublicKeyInfo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_LONG_LONG,
            C_LONG,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CryptImportPublicKeyInfo"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CryptImportPublicKeyInfo(HCRYPTPROV hCryptProv, DWORD dwCertEncodingType, PCERT_PUBLIC_KEY_INFO pInfo, HCRYPTKEY *phKey)
     * }
     */
    public static FunctionDescriptor CryptImportPublicKeyInfo$descriptor() {
        return CryptImportPublicKeyInfo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CryptImportPublicKeyInfo(HCRYPTPROV hCryptProv, DWORD dwCertEncodingType, PCERT_PUBLIC_KEY_INFO pInfo, HCRYPTKEY *phKey)
     * }
     */
    public static MethodHandle CryptImportPublicKeyInfo$handle() {
        return CryptImportPublicKeyInfo.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL CryptImportPublicKeyInfo(HCRYPTPROV hCryptProv, DWORD dwCertEncodingType, PCERT_PUBLIC_KEY_INFO pInfo, HCRYPTKEY *phKey)
     * }
     */
    public static int CryptImportPublicKeyInfo(long hCryptProv, int dwCertEncodingType, MemorySegment pInfo, MemorySegment phKey) {
        var mh$ = CryptImportPublicKeyInfo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CryptImportPublicKeyInfo", hCryptProv, dwCertEncodingType, pInfo, phKey);
            }
            return (int)mh$.invokeExact(hCryptProv, dwCertEncodingType, pInfo, phKey);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CryptImportPublicKeyInfoEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_LONG_LONG,
            C_LONG,
            C_POINTER,
            C_INT,
            C_LONG,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CryptImportPublicKeyInfoEx"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CryptImportPublicKeyInfoEx(HCRYPTPROV hCryptProv, DWORD dwCertEncodingType, PCERT_PUBLIC_KEY_INFO pInfo, ALG_ID aiKeyAlg, DWORD dwFlags, void *pvAuxInfo, HCRYPTKEY *phKey)
     * }
     */
    public static FunctionDescriptor CryptImportPublicKeyInfoEx$descriptor() {
        return CryptImportPublicKeyInfoEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CryptImportPublicKeyInfoEx(HCRYPTPROV hCryptProv, DWORD dwCertEncodingType, PCERT_PUBLIC_KEY_INFO pInfo, ALG_ID aiKeyAlg, DWORD dwFlags, void *pvAuxInfo, HCRYPTKEY *phKey)
     * }
     */
    public static MethodHandle CryptImportPublicKeyInfoEx$handle() {
        return CryptImportPublicKeyInfoEx.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL CryptImportPublicKeyInfoEx(HCRYPTPROV hCryptProv, DWORD dwCertEncodingType, PCERT_PUBLIC_KEY_INFO pInfo, ALG_ID aiKeyAlg, DWORD dwFlags, void *pvAuxInfo, HCRYPTKEY *phKey)
     * }
     */
    public static int CryptImportPublicKeyInfoEx(long hCryptProv, int dwCertEncodingType, MemorySegment pInfo, int aiKeyAlg, int dwFlags, MemorySegment pvAuxInfo, MemorySegment phKey) {
        var mh$ = CryptImportPublicKeyInfoEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CryptImportPublicKeyInfoEx", hCryptProv, dwCertEncodingType, pInfo, aiKeyAlg, dwFlags, pvAuxInfo, phKey);
            }
            return (int)mh$.invokeExact(hCryptProv, dwCertEncodingType, pInfo, aiKeyAlg, dwFlags, pvAuxInfo, phKey);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CryptImportPublicKeyInfoEx2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_LONG,
            C_POINTER,
            C_LONG,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CryptImportPublicKeyInfoEx2"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CryptImportPublicKeyInfoEx2(DWORD dwCertEncodingType, PCERT_PUBLIC_KEY_INFO pInfo, DWORD dwFlags, void *pvAuxInfo, BCRYPT_KEY_HANDLE *phKey)
     * }
     */
    public static FunctionDescriptor CryptImportPublicKeyInfoEx2$descriptor() {
        return CryptImportPublicKeyInfoEx2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CryptImportPublicKeyInfoEx2(DWORD dwCertEncodingType, PCERT_PUBLIC_KEY_INFO pInfo, DWORD dwFlags, void *pvAuxInfo, BCRYPT_KEY_HANDLE *phKey)
     * }
     */
    public static MethodHandle CryptImportPublicKeyInfoEx2$handle() {
        return CryptImportPublicKeyInfoEx2.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL CryptImportPublicKeyInfoEx2(DWORD dwCertEncodingType, PCERT_PUBLIC_KEY_INFO pInfo, DWORD dwFlags, void *pvAuxInfo, BCRYPT_KEY_HANDLE *phKey)
     * }
     */
    public static int CryptImportPublicKeyInfoEx2(int dwCertEncodingType, MemorySegment pInfo, int dwFlags, MemorySegment pvAuxInfo, MemorySegment phKey) {
        var mh$ = CryptImportPublicKeyInfoEx2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CryptImportPublicKeyInfoEx2", dwCertEncodingType, pInfo, dwFlags, pvAuxInfo, phKey);
            }
            return (int)mh$.invokeExact(dwCertEncodingType, pInfo, dwFlags, pvAuxInfo, phKey);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CryptAcquireCertificatePrivateKey {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_LONG,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CryptAcquireCertificatePrivateKey"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CryptAcquireCertificatePrivateKey(PCCERT_CONTEXT pCert, DWORD dwFlags, void *pvParameters, HCRYPTPROV_OR_NCRYPT_KEY_HANDLE *phCryptProvOrNCryptKey, DWORD *pdwKeySpec, BOOL *pfCallerFreeProvOrNCryptKey)
     * }
     */
    public static FunctionDescriptor CryptAcquireCertificatePrivateKey$descriptor() {
        return CryptAcquireCertificatePrivateKey.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CryptAcquireCertificatePrivateKey(PCCERT_CONTEXT pCert, DWORD dwFlags, void *pvParameters, HCRYPTPROV_OR_NCRYPT_KEY_HANDLE *phCryptProvOrNCryptKey, DWORD *pdwKeySpec, BOOL *pfCallerFreeProvOrNCryptKey)
     * }
     */
    public static MethodHandle CryptAcquireCertificatePrivateKey$handle() {
        return CryptAcquireCertificatePrivateKey.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL CryptAcquireCertificatePrivateKey(PCCERT_CONTEXT pCert, DWORD dwFlags, void *pvParameters, HCRYPTPROV_OR_NCRYPT_KEY_HANDLE *phCryptProvOrNCryptKey, DWORD *pdwKeySpec, BOOL *pfCallerFreeProvOrNCryptKey)
     * }
     */
    public static int CryptAcquireCertificatePrivateKey(MemorySegment pCert, int dwFlags, MemorySegment pvParameters, MemorySegment phCryptProvOrNCryptKey, MemorySegment pdwKeySpec, MemorySegment pfCallerFreeProvOrNCryptKey) {
        var mh$ = CryptAcquireCertificatePrivateKey.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CryptAcquireCertificatePrivateKey", pCert, dwFlags, pvParameters, phCryptProvOrNCryptKey, pdwKeySpec, pfCallerFreeProvOrNCryptKey);
            }
            return (int)mh$.invokeExact(pCert, dwFlags, pvParameters, phCryptProvOrNCryptKey, pdwKeySpec, pfCallerFreeProvOrNCryptKey);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CryptFindCertificateKeyProvInfo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_LONG,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CryptFindCertificateKeyProvInfo"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CryptFindCertificateKeyProvInfo(PCCERT_CONTEXT pCert, DWORD dwFlags, void *pvReserved)
     * }
     */
    public static FunctionDescriptor CryptFindCertificateKeyProvInfo$descriptor() {
        return CryptFindCertificateKeyProvInfo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CryptFindCertificateKeyProvInfo(PCCERT_CONTEXT pCert, DWORD dwFlags, void *pvReserved)
     * }
     */
    public static MethodHandle CryptFindCertificateKeyProvInfo$handle() {
        return CryptFindCertificateKeyProvInfo.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL CryptFindCertificateKeyProvInfo(PCCERT_CONTEXT pCert, DWORD dwFlags, void *pvReserved)
     * }
     */
    public static int CryptFindCertificateKeyProvInfo(MemorySegment pCert, int dwFlags, MemorySegment pvReserved) {
        var mh$ = CryptFindCertificateKeyProvInfo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CryptFindCertificateKeyProvInfo", pCert, dwFlags, pvReserved);
            }
            return (int)mh$.invokeExact(pCert, dwFlags, pvReserved);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CryptImportPKCS8 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            _CRYPT_PKCS8_IMPORT_PARAMS.layout(),
            C_LONG,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CryptImportPKCS8"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CryptImportPKCS8(CRYPT_PKCS8_IMPORT_PARAMS sPrivateKeyAndParams, DWORD dwFlags, HCRYPTPROV *phCryptProv, void *pvAuxInfo)
     * }
     */
    public static FunctionDescriptor CryptImportPKCS8$descriptor() {
        return CryptImportPKCS8.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CryptImportPKCS8(CRYPT_PKCS8_IMPORT_PARAMS sPrivateKeyAndParams, DWORD dwFlags, HCRYPTPROV *phCryptProv, void *pvAuxInfo)
     * }
     */
    public static MethodHandle CryptImportPKCS8$handle() {
        return CryptImportPKCS8.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL CryptImportPKCS8(CRYPT_PKCS8_IMPORT_PARAMS sPrivateKeyAndParams, DWORD dwFlags, HCRYPTPROV *phCryptProv, void *pvAuxInfo)
     * }
     */
    public static int CryptImportPKCS8(MemorySegment sPrivateKeyAndParams, int dwFlags, MemorySegment phCryptProv, MemorySegment pvAuxInfo) {
        var mh$ = CryptImportPKCS8.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CryptImportPKCS8", sPrivateKeyAndParams, dwFlags, phCryptProv, pvAuxInfo);
            }
            return (int)mh$.invokeExact(sPrivateKeyAndParams, dwFlags, phCryptProv, pvAuxInfo);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CryptExportPKCS8 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_LONG_LONG,
            C_LONG,
            C_POINTER,
            C_LONG,
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CryptExportPKCS8"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CryptExportPKCS8(HCRYPTPROV hCryptProv, DWORD dwKeySpec, LPSTR pszPrivateKeyObjId, DWORD dwFlags, void *pvAuxInfo, BYTE *pbPrivateKeyBlob, DWORD *pcbPrivateKeyBlob)
     * }
     */
    public static FunctionDescriptor CryptExportPKCS8$descriptor() {
        return CryptExportPKCS8.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CryptExportPKCS8(HCRYPTPROV hCryptProv, DWORD dwKeySpec, LPSTR pszPrivateKeyObjId, DWORD dwFlags, void *pvAuxInfo, BYTE *pbPrivateKeyBlob, DWORD *pcbPrivateKeyBlob)
     * }
     */
    public static MethodHandle CryptExportPKCS8$handle() {
        return CryptExportPKCS8.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL CryptExportPKCS8(HCRYPTPROV hCryptProv, DWORD dwKeySpec, LPSTR pszPrivateKeyObjId, DWORD dwFlags, void *pvAuxInfo, BYTE *pbPrivateKeyBlob, DWORD *pcbPrivateKeyBlob)
     * }
     */
    public static int CryptExportPKCS8(long hCryptProv, int dwKeySpec, MemorySegment pszPrivateKeyObjId, int dwFlags, MemorySegment pvAuxInfo, MemorySegment pbPrivateKeyBlob, MemorySegment pcbPrivateKeyBlob) {
        var mh$ = CryptExportPKCS8.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CryptExportPKCS8", hCryptProv, dwKeySpec, pszPrivateKeyObjId, dwFlags, pvAuxInfo, pbPrivateKeyBlob, pcbPrivateKeyBlob);
            }
            return (int)mh$.invokeExact(hCryptProv, dwKeySpec, pszPrivateKeyObjId, dwFlags, pvAuxInfo, pbPrivateKeyBlob, pcbPrivateKeyBlob);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CryptExportPKCS8Ex {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_LONG,
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CryptExportPKCS8Ex"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CryptExportPKCS8Ex(CRYPT_PKCS8_EXPORT_PARAMS *psExportParams, DWORD dwFlags, void *pvAuxInfo, BYTE *pbPrivateKeyBlob, DWORD *pcbPrivateKeyBlob)
     * }
     */
    public static FunctionDescriptor CryptExportPKCS8Ex$descriptor() {
        return CryptExportPKCS8Ex.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CryptExportPKCS8Ex(CRYPT_PKCS8_EXPORT_PARAMS *psExportParams, DWORD dwFlags, void *pvAuxInfo, BYTE *pbPrivateKeyBlob, DWORD *pcbPrivateKeyBlob)
     * }
     */
    public static MethodHandle CryptExportPKCS8Ex$handle() {
        return CryptExportPKCS8Ex.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL CryptExportPKCS8Ex(CRYPT_PKCS8_EXPORT_PARAMS *psExportParams, DWORD dwFlags, void *pvAuxInfo, BYTE *pbPrivateKeyBlob, DWORD *pcbPrivateKeyBlob)
     * }
     */
    public static int CryptExportPKCS8Ex(MemorySegment psExportParams, int dwFlags, MemorySegment pvAuxInfo, MemorySegment pbPrivateKeyBlob, MemorySegment pcbPrivateKeyBlob) {
        var mh$ = CryptExportPKCS8Ex.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CryptExportPKCS8Ex", psExportParams, dwFlags, pvAuxInfo, pbPrivateKeyBlob, pcbPrivateKeyBlob);
            }
            return (int)mh$.invokeExact(psExportParams, dwFlags, pvAuxInfo, pbPrivateKeyBlob, pcbPrivateKeyBlob);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CryptHashPublicKeyInfo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_LONG_LONG,
            C_INT,
            C_LONG,
            C_LONG,
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CryptHashPublicKeyInfo"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CryptHashPublicKeyInfo(HCRYPTPROV_LEGACY hCryptProv, ALG_ID Algid, DWORD dwFlags, DWORD dwCertEncodingType, PCERT_PUBLIC_KEY_INFO pInfo, BYTE *pbComputedHash, DWORD *pcbComputedHash)
     * }
     */
    public static FunctionDescriptor CryptHashPublicKeyInfo$descriptor() {
        return CryptHashPublicKeyInfo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CryptHashPublicKeyInfo(HCRYPTPROV_LEGACY hCryptProv, ALG_ID Algid, DWORD dwFlags, DWORD dwCertEncodingType, PCERT_PUBLIC_KEY_INFO pInfo, BYTE *pbComputedHash, DWORD *pcbComputedHash)
     * }
     */
    public static MethodHandle CryptHashPublicKeyInfo$handle() {
        return CryptHashPublicKeyInfo.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL CryptHashPublicKeyInfo(HCRYPTPROV_LEGACY hCryptProv, ALG_ID Algid, DWORD dwFlags, DWORD dwCertEncodingType, PCERT_PUBLIC_KEY_INFO pInfo, BYTE *pbComputedHash, DWORD *pcbComputedHash)
     * }
     */
    public static int CryptHashPublicKeyInfo(long hCryptProv, int Algid, int dwFlags, int dwCertEncodingType, MemorySegment pInfo, MemorySegment pbComputedHash, MemorySegment pcbComputedHash) {
        var mh$ = CryptHashPublicKeyInfo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CryptHashPublicKeyInfo", hCryptProv, Algid, dwFlags, dwCertEncodingType, pInfo, pbComputedHash, pcbComputedHash);
            }
            return (int)mh$.invokeExact(hCryptProv, Algid, dwFlags, dwCertEncodingType, pInfo, pbComputedHash, pcbComputedHash);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CertRDNValueToStrA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_LONG,
            C_POINTER,
            C_POINTER,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CertRDNValueToStrA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD CertRDNValueToStrA(DWORD dwValueType, PCERT_RDN_VALUE_BLOB pValue, LPSTR psz, DWORD csz)
     * }
     */
    public static FunctionDescriptor CertRDNValueToStrA$descriptor() {
        return CertRDNValueToStrA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD CertRDNValueToStrA(DWORD dwValueType, PCERT_RDN_VALUE_BLOB pValue, LPSTR psz, DWORD csz)
     * }
     */
    public static MethodHandle CertRDNValueToStrA$handle() {
        return CertRDNValueToStrA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * DWORD CertRDNValueToStrA(DWORD dwValueType, PCERT_RDN_VALUE_BLOB pValue, LPSTR psz, DWORD csz)
     * }
     */
    public static int CertRDNValueToStrA(int dwValueType, MemorySegment pValue, MemorySegment psz, int csz) {
        var mh$ = CertRDNValueToStrA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CertRDNValueToStrA", dwValueType, pValue, psz, csz);
            }
            return (int)mh$.invokeExact(dwValueType, pValue, psz, csz);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CertRDNValueToStrW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_LONG,
            C_POINTER,
            C_POINTER,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CertRDNValueToStrW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD CertRDNValueToStrW(DWORD dwValueType, PCERT_RDN_VALUE_BLOB pValue, LPWSTR psz, DWORD csz)
     * }
     */
    public static FunctionDescriptor CertRDNValueToStrW$descriptor() {
        return CertRDNValueToStrW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD CertRDNValueToStrW(DWORD dwValueType, PCERT_RDN_VALUE_BLOB pValue, LPWSTR psz, DWORD csz)
     * }
     */
    public static MethodHandle CertRDNValueToStrW$handle() {
        return CertRDNValueToStrW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * DWORD CertRDNValueToStrW(DWORD dwValueType, PCERT_RDN_VALUE_BLOB pValue, LPWSTR psz, DWORD csz)
     * }
     */
    public static int CertRDNValueToStrW(int dwValueType, MemorySegment pValue, MemorySegment psz, int csz) {
        var mh$ = CertRDNValueToStrW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CertRDNValueToStrW", dwValueType, pValue, psz, csz);
            }
            return (int)mh$.invokeExact(dwValueType, pValue, psz, csz);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CertNameToStrA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_LONG,
            C_POINTER,
            C_LONG,
            C_POINTER,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CertNameToStrA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD CertNameToStrA(DWORD dwCertEncodingType, PCERT_NAME_BLOB pName, DWORD dwStrType, LPSTR psz, DWORD csz)
     * }
     */
    public static FunctionDescriptor CertNameToStrA$descriptor() {
        return CertNameToStrA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD CertNameToStrA(DWORD dwCertEncodingType, PCERT_NAME_BLOB pName, DWORD dwStrType, LPSTR psz, DWORD csz)
     * }
     */
    public static MethodHandle CertNameToStrA$handle() {
        return CertNameToStrA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * DWORD CertNameToStrA(DWORD dwCertEncodingType, PCERT_NAME_BLOB pName, DWORD dwStrType, LPSTR psz, DWORD csz)
     * }
     */
    public static int CertNameToStrA(int dwCertEncodingType, MemorySegment pName, int dwStrType, MemorySegment psz, int csz) {
        var mh$ = CertNameToStrA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CertNameToStrA", dwCertEncodingType, pName, dwStrType, psz, csz);
            }
            return (int)mh$.invokeExact(dwCertEncodingType, pName, dwStrType, psz, csz);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CertNameToStrW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_LONG,
            C_POINTER,
            C_LONG,
            C_POINTER,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CertNameToStrW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD CertNameToStrW(DWORD dwCertEncodingType, PCERT_NAME_BLOB pName, DWORD dwStrType, LPWSTR psz, DWORD csz)
     * }
     */
    public static FunctionDescriptor CertNameToStrW$descriptor() {
        return CertNameToStrW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD CertNameToStrW(DWORD dwCertEncodingType, PCERT_NAME_BLOB pName, DWORD dwStrType, LPWSTR psz, DWORD csz)
     * }
     */
    public static MethodHandle CertNameToStrW$handle() {
        return CertNameToStrW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * DWORD CertNameToStrW(DWORD dwCertEncodingType, PCERT_NAME_BLOB pName, DWORD dwStrType, LPWSTR psz, DWORD csz)
     * }
     */
    public static int CertNameToStrW(int dwCertEncodingType, MemorySegment pName, int dwStrType, MemorySegment psz, int csz) {
        var mh$ = CertNameToStrW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CertNameToStrW", dwCertEncodingType, pName, dwStrType, psz, csz);
            }
            return (int)mh$.invokeExact(dwCertEncodingType, pName, dwStrType, psz, csz);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CertStrToNameA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_LONG,
            C_POINTER,
            C_LONG,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CertStrToNameA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CertStrToNameA(DWORD dwCertEncodingType, LPCSTR pszX500, DWORD dwStrType, void *pvReserved, BYTE *pbEncoded, DWORD *pcbEncoded, LPCSTR *ppszError)
     * }
     */
    public static FunctionDescriptor CertStrToNameA$descriptor() {
        return CertStrToNameA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CertStrToNameA(DWORD dwCertEncodingType, LPCSTR pszX500, DWORD dwStrType, void *pvReserved, BYTE *pbEncoded, DWORD *pcbEncoded, LPCSTR *ppszError)
     * }
     */
    public static MethodHandle CertStrToNameA$handle() {
        return CertStrToNameA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL CertStrToNameA(DWORD dwCertEncodingType, LPCSTR pszX500, DWORD dwStrType, void *pvReserved, BYTE *pbEncoded, DWORD *pcbEncoded, LPCSTR *ppszError)
     * }
     */
    public static int CertStrToNameA(int dwCertEncodingType, MemorySegment pszX500, int dwStrType, MemorySegment pvReserved, MemorySegment pbEncoded, MemorySegment pcbEncoded, MemorySegment ppszError) {
        var mh$ = CertStrToNameA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CertStrToNameA", dwCertEncodingType, pszX500, dwStrType, pvReserved, pbEncoded, pcbEncoded, ppszError);
            }
            return (int)mh$.invokeExact(dwCertEncodingType, pszX500, dwStrType, pvReserved, pbEncoded, pcbEncoded, ppszError);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CertStrToNameW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_LONG,
            C_POINTER,
            C_LONG,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CertStrToNameW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CertStrToNameW(DWORD dwCertEncodingType, LPCWSTR pszX500, DWORD dwStrType, void *pvReserved, BYTE *pbEncoded, DWORD *pcbEncoded, LPCWSTR *ppszError)
     * }
     */
    public static FunctionDescriptor CertStrToNameW$descriptor() {
        return CertStrToNameW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CertStrToNameW(DWORD dwCertEncodingType, LPCWSTR pszX500, DWORD dwStrType, void *pvReserved, BYTE *pbEncoded, DWORD *pcbEncoded, LPCWSTR *ppszError)
     * }
     */
    public static MethodHandle CertStrToNameW$handle() {
        return CertStrToNameW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL CertStrToNameW(DWORD dwCertEncodingType, LPCWSTR pszX500, DWORD dwStrType, void *pvReserved, BYTE *pbEncoded, DWORD *pcbEncoded, LPCWSTR *ppszError)
     * }
     */
    public static int CertStrToNameW(int dwCertEncodingType, MemorySegment pszX500, int dwStrType, MemorySegment pvReserved, MemorySegment pbEncoded, MemorySegment pcbEncoded, MemorySegment ppszError) {
        var mh$ = CertStrToNameW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CertStrToNameW", dwCertEncodingType, pszX500, dwStrType, pvReserved, pbEncoded, pcbEncoded, ppszError);
            }
            return (int)mh$.invokeExact(dwCertEncodingType, pszX500, dwStrType, pvReserved, pbEncoded, pcbEncoded, ppszError);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CertGetNameStringA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_POINTER,
            C_LONG,
            C_LONG,
            C_POINTER,
            C_POINTER,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CertGetNameStringA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD CertGetNameStringA(PCCERT_CONTEXT pCertContext, DWORD dwType, DWORD dwFlags, void *pvTypePara, LPSTR pszNameString, DWORD cchNameString)
     * }
     */
    public static FunctionDescriptor CertGetNameStringA$descriptor() {
        return CertGetNameStringA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD CertGetNameStringA(PCCERT_CONTEXT pCertContext, DWORD dwType, DWORD dwFlags, void *pvTypePara, LPSTR pszNameString, DWORD cchNameString)
     * }
     */
    public static MethodHandle CertGetNameStringA$handle() {
        return CertGetNameStringA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * DWORD CertGetNameStringA(PCCERT_CONTEXT pCertContext, DWORD dwType, DWORD dwFlags, void *pvTypePara, LPSTR pszNameString, DWORD cchNameString)
     * }
     */
    public static int CertGetNameStringA(MemorySegment pCertContext, int dwType, int dwFlags, MemorySegment pvTypePara, MemorySegment pszNameString, int cchNameString) {
        var mh$ = CertGetNameStringA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CertGetNameStringA", pCertContext, dwType, dwFlags, pvTypePara, pszNameString, cchNameString);
            }
            return (int)mh$.invokeExact(pCertContext, dwType, dwFlags, pvTypePara, pszNameString, cchNameString);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CertGetNameStringW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_POINTER,
            C_LONG,
            C_LONG,
            C_POINTER,
            C_POINTER,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CertGetNameStringW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD CertGetNameStringW(PCCERT_CONTEXT pCertContext, DWORD dwType, DWORD dwFlags, void *pvTypePara, LPWSTR pszNameString, DWORD cchNameString)
     * }
     */
    public static FunctionDescriptor CertGetNameStringW$descriptor() {
        return CertGetNameStringW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD CertGetNameStringW(PCCERT_CONTEXT pCertContext, DWORD dwType, DWORD dwFlags, void *pvTypePara, LPWSTR pszNameString, DWORD cchNameString)
     * }
     */
    public static MethodHandle CertGetNameStringW$handle() {
        return CertGetNameStringW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * DWORD CertGetNameStringW(PCCERT_CONTEXT pCertContext, DWORD dwType, DWORD dwFlags, void *pvTypePara, LPWSTR pszNameString, DWORD cchNameString)
     * }
     */
    public static int CertGetNameStringW(MemorySegment pCertContext, int dwType, int dwFlags, MemorySegment pvTypePara, MemorySegment pszNameString, int cchNameString) {
        var mh$ = CertGetNameStringW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CertGetNameStringW", pCertContext, dwType, dwFlags, pvTypePara, pszNameString, cchNameString);
            }
            return (int)mh$.invokeExact(pCertContext, dwType, dwFlags, pvTypePara, pszNameString, cchNameString);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct _CRYPT_SIGN_MESSAGE_PARA {
     *     DWORD cbSize;
     *     DWORD dwMsgEncodingType;
     *     PCCERT_CONTEXT pSigningCert;
     *     CRYPT_ALGORITHM_IDENTIFIER HashAlgorithm;
     *     void *pvHashAuxInfo;
     *     DWORD cMsgCert;
     *     PCCERT_CONTEXT *rgpMsgCert;
     *     DWORD cMsgCrl;
     *     PCCRL_CONTEXT *rgpMsgCrl;
     *     DWORD cAuthAttr;
     *     PCRYPT_ATTRIBUTE rgAuthAttr;
     *     DWORD cUnauthAttr;
     *     PCRYPT_ATTRIBUTE rgUnauthAttr;
     *     DWORD dwFlags;
     *     DWORD dwInnerContentType;
     * } *PCRYPT_SIGN_MESSAGE_PARA
     * }
     */
    public static final AddressLayout PCRYPT_SIGN_MESSAGE_PARA = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CRYPT_VERIFY_MESSAGE_PARA {
     *     DWORD cbSize;
     *     DWORD dwMsgAndCertEncodingType;
     *     HCRYPTPROV_LEGACY hCryptProv;
     *     PFN_CRYPT_GET_SIGNER_CERTIFICATE pfnGetSignerCertificate;
     *     void *pvGetArg;
     * } *PCRYPT_VERIFY_MESSAGE_PARA
     * }
     */
    public static final AddressLayout PCRYPT_VERIFY_MESSAGE_PARA = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CRYPT_ENCRYPT_MESSAGE_PARA {
     *     DWORD cbSize;
     *     DWORD dwMsgEncodingType;
     *     HCRYPTPROV_LEGACY hCryptProv;
     *     CRYPT_ALGORITHM_IDENTIFIER ContentEncryptionAlgorithm;
     *     void *pvEncryptionAuxInfo;
     *     DWORD dwFlags;
     *     DWORD dwInnerContentType;
     * } *PCRYPT_ENCRYPT_MESSAGE_PARA
     * }
     */
    public static final AddressLayout PCRYPT_ENCRYPT_MESSAGE_PARA = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CRYPT_DECRYPT_MESSAGE_PARA {
     *     DWORD cbSize;
     *     DWORD dwMsgAndCertEncodingType;
     *     DWORD cCertStore;
     *     HCERTSTORE *rghCertStore;
     * } *PCRYPT_DECRYPT_MESSAGE_PARA
     * }
     */
    public static final AddressLayout PCRYPT_DECRYPT_MESSAGE_PARA = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CRYPT_HASH_MESSAGE_PARA {
     *     DWORD cbSize;
     *     DWORD dwMsgEncodingType;
     *     HCRYPTPROV_LEGACY hCryptProv;
     *     CRYPT_ALGORITHM_IDENTIFIER HashAlgorithm;
     *     void *pvHashAuxInfo;
     * } *PCRYPT_HASH_MESSAGE_PARA
     * }
     */
    public static final AddressLayout PCRYPT_HASH_MESSAGE_PARA = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CRYPT_KEY_SIGN_MESSAGE_PARA {
     *     DWORD cbSize;
     *     DWORD dwMsgAndCertEncodingType;
     *     union {
     *         HCRYPTPROV hCryptProv;
     *         NCRYPT_KEY_HANDLE hNCryptKey;
     *     };
     *     DWORD dwKeySpec;
     *     CRYPT_ALGORITHM_IDENTIFIER HashAlgorithm;
     *     void *pvHashAuxInfo;
     *     CRYPT_ALGORITHM_IDENTIFIER PubKeyAlgorithm;
     * } *PCRYPT_KEY_SIGN_MESSAGE_PARA
     * }
     */
    public static final AddressLayout PCRYPT_KEY_SIGN_MESSAGE_PARA = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CRYPT_KEY_VERIFY_MESSAGE_PARA {
     *     DWORD cbSize;
     *     DWORD dwMsgEncodingType;
     *     HCRYPTPROV_LEGACY hCryptProv;
     * } *PCRYPT_KEY_VERIFY_MESSAGE_PARA
     * }
     */
    public static final AddressLayout PCRYPT_KEY_VERIFY_MESSAGE_PARA = C_POINTER;

    private static class CryptSignMessage {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_INT,
            C_LONG,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CryptSignMessage"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CryptSignMessage(PCRYPT_SIGN_MESSAGE_PARA pSignPara, BOOL fDetachedSignature, DWORD cToBeSigned, const BYTE *rgpbToBeSigned[], DWORD rgcbToBeSigned[], BYTE *pbSignedBlob, DWORD *pcbSignedBlob)
     * }
     */
    public static FunctionDescriptor CryptSignMessage$descriptor() {
        return CryptSignMessage.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CryptSignMessage(PCRYPT_SIGN_MESSAGE_PARA pSignPara, BOOL fDetachedSignature, DWORD cToBeSigned, const BYTE *rgpbToBeSigned[], DWORD rgcbToBeSigned[], BYTE *pbSignedBlob, DWORD *pcbSignedBlob)
     * }
     */
    public static MethodHandle CryptSignMessage$handle() {
        return CryptSignMessage.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL CryptSignMessage(PCRYPT_SIGN_MESSAGE_PARA pSignPara, BOOL fDetachedSignature, DWORD cToBeSigned, const BYTE *rgpbToBeSigned[], DWORD rgcbToBeSigned[], BYTE *pbSignedBlob, DWORD *pcbSignedBlob)
     * }
     */
    public static int CryptSignMessage(MemorySegment pSignPara, int fDetachedSignature, int cToBeSigned, MemorySegment rgpbToBeSigned, MemorySegment rgcbToBeSigned, MemorySegment pbSignedBlob, MemorySegment pcbSignedBlob) {
        var mh$ = CryptSignMessage.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CryptSignMessage", pSignPara, fDetachedSignature, cToBeSigned, rgpbToBeSigned, rgcbToBeSigned, pbSignedBlob, pcbSignedBlob);
            }
            return (int)mh$.invokeExact(pSignPara, fDetachedSignature, cToBeSigned, rgpbToBeSigned, rgcbToBeSigned, pbSignedBlob, pcbSignedBlob);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CryptVerifyMessageSignature {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_LONG,
            C_POINTER,
            C_LONG,
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CryptVerifyMessageSignature"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CryptVerifyMessageSignature(PCRYPT_VERIFY_MESSAGE_PARA pVerifyPara, DWORD dwSignerIndex, const BYTE *pbSignedBlob, DWORD cbSignedBlob, BYTE *pbDecoded, DWORD *pcbDecoded, PCCERT_CONTEXT *ppSignerCert)
     * }
     */
    public static FunctionDescriptor CryptVerifyMessageSignature$descriptor() {
        return CryptVerifyMessageSignature.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CryptVerifyMessageSignature(PCRYPT_VERIFY_MESSAGE_PARA pVerifyPara, DWORD dwSignerIndex, const BYTE *pbSignedBlob, DWORD cbSignedBlob, BYTE *pbDecoded, DWORD *pcbDecoded, PCCERT_CONTEXT *ppSignerCert)
     * }
     */
    public static MethodHandle CryptVerifyMessageSignature$handle() {
        return CryptVerifyMessageSignature.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL CryptVerifyMessageSignature(PCRYPT_VERIFY_MESSAGE_PARA pVerifyPara, DWORD dwSignerIndex, const BYTE *pbSignedBlob, DWORD cbSignedBlob, BYTE *pbDecoded, DWORD *pcbDecoded, PCCERT_CONTEXT *ppSignerCert)
     * }
     */
    public static int CryptVerifyMessageSignature(MemorySegment pVerifyPara, int dwSignerIndex, MemorySegment pbSignedBlob, int cbSignedBlob, MemorySegment pbDecoded, MemorySegment pcbDecoded, MemorySegment ppSignerCert) {
        var mh$ = CryptVerifyMessageSignature.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CryptVerifyMessageSignature", pVerifyPara, dwSignerIndex, pbSignedBlob, cbSignedBlob, pbDecoded, pcbDecoded, ppSignerCert);
            }
            return (int)mh$.invokeExact(pVerifyPara, dwSignerIndex, pbSignedBlob, cbSignedBlob, pbDecoded, pcbDecoded, ppSignerCert);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CryptGetMessageSignerCount {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_LONG,
            C_POINTER,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CryptGetMessageSignerCount"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LONG CryptGetMessageSignerCount(DWORD dwMsgEncodingType, const BYTE *pbSignedBlob, DWORD cbSignedBlob)
     * }
     */
    public static FunctionDescriptor CryptGetMessageSignerCount$descriptor() {
        return CryptGetMessageSignerCount.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LONG CryptGetMessageSignerCount(DWORD dwMsgEncodingType, const BYTE *pbSignedBlob, DWORD cbSignedBlob)
     * }
     */
    public static MethodHandle CryptGetMessageSignerCount$handle() {
        return CryptGetMessageSignerCount.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * LONG CryptGetMessageSignerCount(DWORD dwMsgEncodingType, const BYTE *pbSignedBlob, DWORD cbSignedBlob)
     * }
     */
    public static int CryptGetMessageSignerCount(int dwMsgEncodingType, MemorySegment pbSignedBlob, int cbSignedBlob) {
        var mh$ = CryptGetMessageSignerCount.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CryptGetMessageSignerCount", dwMsgEncodingType, pbSignedBlob, cbSignedBlob);
            }
            return (int)mh$.invokeExact(dwMsgEncodingType, pbSignedBlob, cbSignedBlob);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CryptGetMessageCertificates {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_LONG,
            C_LONG_LONG,
            C_LONG,
            C_POINTER,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CryptGetMessageCertificates"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HCERTSTORE CryptGetMessageCertificates(DWORD dwMsgAndCertEncodingType, HCRYPTPROV_LEGACY hCryptProv, DWORD dwFlags, const BYTE *pbSignedBlob, DWORD cbSignedBlob)
     * }
     */
    public static FunctionDescriptor CryptGetMessageCertificates$descriptor() {
        return CryptGetMessageCertificates.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HCERTSTORE CryptGetMessageCertificates(DWORD dwMsgAndCertEncodingType, HCRYPTPROV_LEGACY hCryptProv, DWORD dwFlags, const BYTE *pbSignedBlob, DWORD cbSignedBlob)
     * }
     */
    public static MethodHandle CryptGetMessageCertificates$handle() {
        return CryptGetMessageCertificates.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * HCERTSTORE CryptGetMessageCertificates(DWORD dwMsgAndCertEncodingType, HCRYPTPROV_LEGACY hCryptProv, DWORD dwFlags, const BYTE *pbSignedBlob, DWORD cbSignedBlob)
     * }
     */
    public static MemorySegment CryptGetMessageCertificates(int dwMsgAndCertEncodingType, long hCryptProv, int dwFlags, MemorySegment pbSignedBlob, int cbSignedBlob) {
        var mh$ = CryptGetMessageCertificates.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CryptGetMessageCertificates", dwMsgAndCertEncodingType, hCryptProv, dwFlags, pbSignedBlob, cbSignedBlob);
            }
            return (MemorySegment)mh$.invokeExact(dwMsgAndCertEncodingType, hCryptProv, dwFlags, pbSignedBlob, cbSignedBlob);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CryptVerifyDetachedMessageSignature {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_LONG,
            C_POINTER,
            C_LONG,
            C_LONG,
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CryptVerifyDetachedMessageSignature"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CryptVerifyDetachedMessageSignature(PCRYPT_VERIFY_MESSAGE_PARA pVerifyPara, DWORD dwSignerIndex, const BYTE *pbDetachedSignBlob, DWORD cbDetachedSignBlob, DWORD cToBeSigned, const BYTE *rgpbToBeSigned[], DWORD rgcbToBeSigned[], PCCERT_CONTEXT *ppSignerCert)
     * }
     */
    public static FunctionDescriptor CryptVerifyDetachedMessageSignature$descriptor() {
        return CryptVerifyDetachedMessageSignature.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CryptVerifyDetachedMessageSignature(PCRYPT_VERIFY_MESSAGE_PARA pVerifyPara, DWORD dwSignerIndex, const BYTE *pbDetachedSignBlob, DWORD cbDetachedSignBlob, DWORD cToBeSigned, const BYTE *rgpbToBeSigned[], DWORD rgcbToBeSigned[], PCCERT_CONTEXT *ppSignerCert)
     * }
     */
    public static MethodHandle CryptVerifyDetachedMessageSignature$handle() {
        return CryptVerifyDetachedMessageSignature.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL CryptVerifyDetachedMessageSignature(PCRYPT_VERIFY_MESSAGE_PARA pVerifyPara, DWORD dwSignerIndex, const BYTE *pbDetachedSignBlob, DWORD cbDetachedSignBlob, DWORD cToBeSigned, const BYTE *rgpbToBeSigned[], DWORD rgcbToBeSigned[], PCCERT_CONTEXT *ppSignerCert)
     * }
     */
    public static int CryptVerifyDetachedMessageSignature(MemorySegment pVerifyPara, int dwSignerIndex, MemorySegment pbDetachedSignBlob, int cbDetachedSignBlob, int cToBeSigned, MemorySegment rgpbToBeSigned, MemorySegment rgcbToBeSigned, MemorySegment ppSignerCert) {
        var mh$ = CryptVerifyDetachedMessageSignature.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CryptVerifyDetachedMessageSignature", pVerifyPara, dwSignerIndex, pbDetachedSignBlob, cbDetachedSignBlob, cToBeSigned, rgpbToBeSigned, rgcbToBeSigned, ppSignerCert);
            }
            return (int)mh$.invokeExact(pVerifyPara, dwSignerIndex, pbDetachedSignBlob, cbDetachedSignBlob, cToBeSigned, rgpbToBeSigned, rgcbToBeSigned, ppSignerCert);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CryptEncryptMessage {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_LONG,
            C_POINTER,
            C_POINTER,
            C_LONG,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CryptEncryptMessage"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CryptEncryptMessage(PCRYPT_ENCRYPT_MESSAGE_PARA pEncryptPara, DWORD cRecipientCert, PCCERT_CONTEXT rgpRecipientCert[], const BYTE *pbToBeEncrypted, DWORD cbToBeEncrypted, BYTE *pbEncryptedBlob, DWORD *pcbEncryptedBlob)
     * }
     */
    public static FunctionDescriptor CryptEncryptMessage$descriptor() {
        return CryptEncryptMessage.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CryptEncryptMessage(PCRYPT_ENCRYPT_MESSAGE_PARA pEncryptPara, DWORD cRecipientCert, PCCERT_CONTEXT rgpRecipientCert[], const BYTE *pbToBeEncrypted, DWORD cbToBeEncrypted, BYTE *pbEncryptedBlob, DWORD *pcbEncryptedBlob)
     * }
     */
    public static MethodHandle CryptEncryptMessage$handle() {
        return CryptEncryptMessage.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL CryptEncryptMessage(PCRYPT_ENCRYPT_MESSAGE_PARA pEncryptPara, DWORD cRecipientCert, PCCERT_CONTEXT rgpRecipientCert[], const BYTE *pbToBeEncrypted, DWORD cbToBeEncrypted, BYTE *pbEncryptedBlob, DWORD *pcbEncryptedBlob)
     * }
     */
    public static int CryptEncryptMessage(MemorySegment pEncryptPara, int cRecipientCert, MemorySegment rgpRecipientCert, MemorySegment pbToBeEncrypted, int cbToBeEncrypted, MemorySegment pbEncryptedBlob, MemorySegment pcbEncryptedBlob) {
        var mh$ = CryptEncryptMessage.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CryptEncryptMessage", pEncryptPara, cRecipientCert, rgpRecipientCert, pbToBeEncrypted, cbToBeEncrypted, pbEncryptedBlob, pcbEncryptedBlob);
            }
            return (int)mh$.invokeExact(pEncryptPara, cRecipientCert, rgpRecipientCert, pbToBeEncrypted, cbToBeEncrypted, pbEncryptedBlob, pcbEncryptedBlob);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CryptDecryptMessage {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_LONG,
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CryptDecryptMessage"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CryptDecryptMessage(PCRYPT_DECRYPT_MESSAGE_PARA pDecryptPara, const BYTE *pbEncryptedBlob, DWORD cbEncryptedBlob, BYTE *pbDecrypted, DWORD *pcbDecrypted, PCCERT_CONTEXT *ppXchgCert)
     * }
     */
    public static FunctionDescriptor CryptDecryptMessage$descriptor() {
        return CryptDecryptMessage.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CryptDecryptMessage(PCRYPT_DECRYPT_MESSAGE_PARA pDecryptPara, const BYTE *pbEncryptedBlob, DWORD cbEncryptedBlob, BYTE *pbDecrypted, DWORD *pcbDecrypted, PCCERT_CONTEXT *ppXchgCert)
     * }
     */
    public static MethodHandle CryptDecryptMessage$handle() {
        return CryptDecryptMessage.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL CryptDecryptMessage(PCRYPT_DECRYPT_MESSAGE_PARA pDecryptPara, const BYTE *pbEncryptedBlob, DWORD cbEncryptedBlob, BYTE *pbDecrypted, DWORD *pcbDecrypted, PCCERT_CONTEXT *ppXchgCert)
     * }
     */
    public static int CryptDecryptMessage(MemorySegment pDecryptPara, MemorySegment pbEncryptedBlob, int cbEncryptedBlob, MemorySegment pbDecrypted, MemorySegment pcbDecrypted, MemorySegment ppXchgCert) {
        var mh$ = CryptDecryptMessage.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CryptDecryptMessage", pDecryptPara, pbEncryptedBlob, cbEncryptedBlob, pbDecrypted, pcbDecrypted, ppXchgCert);
            }
            return (int)mh$.invokeExact(pDecryptPara, pbEncryptedBlob, cbEncryptedBlob, pbDecrypted, pcbDecrypted, ppXchgCert);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CryptSignAndEncryptMessage {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_LONG,
            C_POINTER,
            C_POINTER,
            C_LONG,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CryptSignAndEncryptMessage"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CryptSignAndEncryptMessage(PCRYPT_SIGN_MESSAGE_PARA pSignPara, PCRYPT_ENCRYPT_MESSAGE_PARA pEncryptPara, DWORD cRecipientCert, PCCERT_CONTEXT rgpRecipientCert[], const BYTE *pbToBeSignedAndEncrypted, DWORD cbToBeSignedAndEncrypted, BYTE *pbSignedAndEncryptedBlob, DWORD *pcbSignedAndEncryptedBlob)
     * }
     */
    public static FunctionDescriptor CryptSignAndEncryptMessage$descriptor() {
        return CryptSignAndEncryptMessage.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CryptSignAndEncryptMessage(PCRYPT_SIGN_MESSAGE_PARA pSignPara, PCRYPT_ENCRYPT_MESSAGE_PARA pEncryptPara, DWORD cRecipientCert, PCCERT_CONTEXT rgpRecipientCert[], const BYTE *pbToBeSignedAndEncrypted, DWORD cbToBeSignedAndEncrypted, BYTE *pbSignedAndEncryptedBlob, DWORD *pcbSignedAndEncryptedBlob)
     * }
     */
    public static MethodHandle CryptSignAndEncryptMessage$handle() {
        return CryptSignAndEncryptMessage.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL CryptSignAndEncryptMessage(PCRYPT_SIGN_MESSAGE_PARA pSignPara, PCRYPT_ENCRYPT_MESSAGE_PARA pEncryptPara, DWORD cRecipientCert, PCCERT_CONTEXT rgpRecipientCert[], const BYTE *pbToBeSignedAndEncrypted, DWORD cbToBeSignedAndEncrypted, BYTE *pbSignedAndEncryptedBlob, DWORD *pcbSignedAndEncryptedBlob)
     * }
     */
    public static int CryptSignAndEncryptMessage(MemorySegment pSignPara, MemorySegment pEncryptPara, int cRecipientCert, MemorySegment rgpRecipientCert, MemorySegment pbToBeSignedAndEncrypted, int cbToBeSignedAndEncrypted, MemorySegment pbSignedAndEncryptedBlob, MemorySegment pcbSignedAndEncryptedBlob) {
        var mh$ = CryptSignAndEncryptMessage.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CryptSignAndEncryptMessage", pSignPara, pEncryptPara, cRecipientCert, rgpRecipientCert, pbToBeSignedAndEncrypted, cbToBeSignedAndEncrypted, pbSignedAndEncryptedBlob, pcbSignedAndEncryptedBlob);
            }
            return (int)mh$.invokeExact(pSignPara, pEncryptPara, cRecipientCert, rgpRecipientCert, pbToBeSignedAndEncrypted, cbToBeSignedAndEncrypted, pbSignedAndEncryptedBlob, pcbSignedAndEncryptedBlob);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CryptDecryptAndVerifyMessageSignature {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_LONG,
            C_POINTER,
            C_LONG,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CryptDecryptAndVerifyMessageSignature"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CryptDecryptAndVerifyMessageSignature(PCRYPT_DECRYPT_MESSAGE_PARA pDecryptPara, PCRYPT_VERIFY_MESSAGE_PARA pVerifyPara, DWORD dwSignerIndex, const BYTE *pbEncryptedBlob, DWORD cbEncryptedBlob, BYTE *pbDecrypted, DWORD *pcbDecrypted, PCCERT_CONTEXT *ppXchgCert, PCCERT_CONTEXT *ppSignerCert)
     * }
     */
    public static FunctionDescriptor CryptDecryptAndVerifyMessageSignature$descriptor() {
        return CryptDecryptAndVerifyMessageSignature.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CryptDecryptAndVerifyMessageSignature(PCRYPT_DECRYPT_MESSAGE_PARA pDecryptPara, PCRYPT_VERIFY_MESSAGE_PARA pVerifyPara, DWORD dwSignerIndex, const BYTE *pbEncryptedBlob, DWORD cbEncryptedBlob, BYTE *pbDecrypted, DWORD *pcbDecrypted, PCCERT_CONTEXT *ppXchgCert, PCCERT_CONTEXT *ppSignerCert)
     * }
     */
    public static MethodHandle CryptDecryptAndVerifyMessageSignature$handle() {
        return CryptDecryptAndVerifyMessageSignature.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL CryptDecryptAndVerifyMessageSignature(PCRYPT_DECRYPT_MESSAGE_PARA pDecryptPara, PCRYPT_VERIFY_MESSAGE_PARA pVerifyPara, DWORD dwSignerIndex, const BYTE *pbEncryptedBlob, DWORD cbEncryptedBlob, BYTE *pbDecrypted, DWORD *pcbDecrypted, PCCERT_CONTEXT *ppXchgCert, PCCERT_CONTEXT *ppSignerCert)
     * }
     */
    public static int CryptDecryptAndVerifyMessageSignature(MemorySegment pDecryptPara, MemorySegment pVerifyPara, int dwSignerIndex, MemorySegment pbEncryptedBlob, int cbEncryptedBlob, MemorySegment pbDecrypted, MemorySegment pcbDecrypted, MemorySegment ppXchgCert, MemorySegment ppSignerCert) {
        var mh$ = CryptDecryptAndVerifyMessageSignature.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CryptDecryptAndVerifyMessageSignature", pDecryptPara, pVerifyPara, dwSignerIndex, pbEncryptedBlob, cbEncryptedBlob, pbDecrypted, pcbDecrypted, ppXchgCert, ppSignerCert);
            }
            return (int)mh$.invokeExact(pDecryptPara, pVerifyPara, dwSignerIndex, pbEncryptedBlob, cbEncryptedBlob, pbDecrypted, pcbDecrypted, ppXchgCert, ppSignerCert);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CryptDecodeMessage {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_LONG,
            C_POINTER,
            C_POINTER,
            C_LONG,
            C_POINTER,
            C_LONG,
            C_LONG,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CryptDecodeMessage"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CryptDecodeMessage(DWORD dwMsgTypeFlags, PCRYPT_DECRYPT_MESSAGE_PARA pDecryptPara, PCRYPT_VERIFY_MESSAGE_PARA pVerifyPara, DWORD dwSignerIndex, const BYTE *pbEncodedBlob, DWORD cbEncodedBlob, DWORD dwPrevInnerContentType, DWORD *pdwMsgType, DWORD *pdwInnerContentType, BYTE *pbDecoded, DWORD *pcbDecoded, PCCERT_CONTEXT *ppXchgCert, PCCERT_CONTEXT *ppSignerCert)
     * }
     */
    public static FunctionDescriptor CryptDecodeMessage$descriptor() {
        return CryptDecodeMessage.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CryptDecodeMessage(DWORD dwMsgTypeFlags, PCRYPT_DECRYPT_MESSAGE_PARA pDecryptPara, PCRYPT_VERIFY_MESSAGE_PARA pVerifyPara, DWORD dwSignerIndex, const BYTE *pbEncodedBlob, DWORD cbEncodedBlob, DWORD dwPrevInnerContentType, DWORD *pdwMsgType, DWORD *pdwInnerContentType, BYTE *pbDecoded, DWORD *pcbDecoded, PCCERT_CONTEXT *ppXchgCert, PCCERT_CONTEXT *ppSignerCert)
     * }
     */
    public static MethodHandle CryptDecodeMessage$handle() {
        return CryptDecodeMessage.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL CryptDecodeMessage(DWORD dwMsgTypeFlags, PCRYPT_DECRYPT_MESSAGE_PARA pDecryptPara, PCRYPT_VERIFY_MESSAGE_PARA pVerifyPara, DWORD dwSignerIndex, const BYTE *pbEncodedBlob, DWORD cbEncodedBlob, DWORD dwPrevInnerContentType, DWORD *pdwMsgType, DWORD *pdwInnerContentType, BYTE *pbDecoded, DWORD *pcbDecoded, PCCERT_CONTEXT *ppXchgCert, PCCERT_CONTEXT *ppSignerCert)
     * }
     */
    public static int CryptDecodeMessage(int dwMsgTypeFlags, MemorySegment pDecryptPara, MemorySegment pVerifyPara, int dwSignerIndex, MemorySegment pbEncodedBlob, int cbEncodedBlob, int dwPrevInnerContentType, MemorySegment pdwMsgType, MemorySegment pdwInnerContentType, MemorySegment pbDecoded, MemorySegment pcbDecoded, MemorySegment ppXchgCert, MemorySegment ppSignerCert) {
        var mh$ = CryptDecodeMessage.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CryptDecodeMessage", dwMsgTypeFlags, pDecryptPara, pVerifyPara, dwSignerIndex, pbEncodedBlob, cbEncodedBlob, dwPrevInnerContentType, pdwMsgType, pdwInnerContentType, pbDecoded, pcbDecoded, ppXchgCert, ppSignerCert);
            }
            return (int)mh$.invokeExact(dwMsgTypeFlags, pDecryptPara, pVerifyPara, dwSignerIndex, pbEncodedBlob, cbEncodedBlob, dwPrevInnerContentType, pdwMsgType, pdwInnerContentType, pbDecoded, pcbDecoded, ppXchgCert, ppSignerCert);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CryptHashMessage {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_INT,
            C_LONG,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CryptHashMessage"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CryptHashMessage(PCRYPT_HASH_MESSAGE_PARA pHashPara, BOOL fDetachedHash, DWORD cToBeHashed, const BYTE *rgpbToBeHashed[], DWORD rgcbToBeHashed[], BYTE *pbHashedBlob, DWORD *pcbHashedBlob, BYTE *pbComputedHash, DWORD *pcbComputedHash)
     * }
     */
    public static FunctionDescriptor CryptHashMessage$descriptor() {
        return CryptHashMessage.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CryptHashMessage(PCRYPT_HASH_MESSAGE_PARA pHashPara, BOOL fDetachedHash, DWORD cToBeHashed, const BYTE *rgpbToBeHashed[], DWORD rgcbToBeHashed[], BYTE *pbHashedBlob, DWORD *pcbHashedBlob, BYTE *pbComputedHash, DWORD *pcbComputedHash)
     * }
     */
    public static MethodHandle CryptHashMessage$handle() {
        return CryptHashMessage.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL CryptHashMessage(PCRYPT_HASH_MESSAGE_PARA pHashPara, BOOL fDetachedHash, DWORD cToBeHashed, const BYTE *rgpbToBeHashed[], DWORD rgcbToBeHashed[], BYTE *pbHashedBlob, DWORD *pcbHashedBlob, BYTE *pbComputedHash, DWORD *pcbComputedHash)
     * }
     */
    public static int CryptHashMessage(MemorySegment pHashPara, int fDetachedHash, int cToBeHashed, MemorySegment rgpbToBeHashed, MemorySegment rgcbToBeHashed, MemorySegment pbHashedBlob, MemorySegment pcbHashedBlob, MemorySegment pbComputedHash, MemorySegment pcbComputedHash) {
        var mh$ = CryptHashMessage.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CryptHashMessage", pHashPara, fDetachedHash, cToBeHashed, rgpbToBeHashed, rgcbToBeHashed, pbHashedBlob, pcbHashedBlob, pbComputedHash, pcbComputedHash);
            }
            return (int)mh$.invokeExact(pHashPara, fDetachedHash, cToBeHashed, rgpbToBeHashed, rgcbToBeHashed, pbHashedBlob, pcbHashedBlob, pbComputedHash, pcbComputedHash);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CryptVerifyMessageHash {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_LONG,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CryptVerifyMessageHash"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CryptVerifyMessageHash(PCRYPT_HASH_MESSAGE_PARA pHashPara, BYTE *pbHashedBlob, DWORD cbHashedBlob, BYTE *pbToBeHashed, DWORD *pcbToBeHashed, BYTE *pbComputedHash, DWORD *pcbComputedHash)
     * }
     */
    public static FunctionDescriptor CryptVerifyMessageHash$descriptor() {
        return CryptVerifyMessageHash.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CryptVerifyMessageHash(PCRYPT_HASH_MESSAGE_PARA pHashPara, BYTE *pbHashedBlob, DWORD cbHashedBlob, BYTE *pbToBeHashed, DWORD *pcbToBeHashed, BYTE *pbComputedHash, DWORD *pcbComputedHash)
     * }
     */
    public static MethodHandle CryptVerifyMessageHash$handle() {
        return CryptVerifyMessageHash.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL CryptVerifyMessageHash(PCRYPT_HASH_MESSAGE_PARA pHashPara, BYTE *pbHashedBlob, DWORD cbHashedBlob, BYTE *pbToBeHashed, DWORD *pcbToBeHashed, BYTE *pbComputedHash, DWORD *pcbComputedHash)
     * }
     */
    public static int CryptVerifyMessageHash(MemorySegment pHashPara, MemorySegment pbHashedBlob, int cbHashedBlob, MemorySegment pbToBeHashed, MemorySegment pcbToBeHashed, MemorySegment pbComputedHash, MemorySegment pcbComputedHash) {
        var mh$ = CryptVerifyMessageHash.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CryptVerifyMessageHash", pHashPara, pbHashedBlob, cbHashedBlob, pbToBeHashed, pcbToBeHashed, pbComputedHash, pcbComputedHash);
            }
            return (int)mh$.invokeExact(pHashPara, pbHashedBlob, cbHashedBlob, pbToBeHashed, pcbToBeHashed, pbComputedHash, pcbComputedHash);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CryptVerifyDetachedMessageHash {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_LONG,
            C_LONG,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CryptVerifyDetachedMessageHash"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CryptVerifyDetachedMessageHash(PCRYPT_HASH_MESSAGE_PARA pHashPara, BYTE *pbDetachedHashBlob, DWORD cbDetachedHashBlob, DWORD cToBeHashed, const BYTE *rgpbToBeHashed[], DWORD rgcbToBeHashed[], BYTE *pbComputedHash, DWORD *pcbComputedHash)
     * }
     */
    public static FunctionDescriptor CryptVerifyDetachedMessageHash$descriptor() {
        return CryptVerifyDetachedMessageHash.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CryptVerifyDetachedMessageHash(PCRYPT_HASH_MESSAGE_PARA pHashPara, BYTE *pbDetachedHashBlob, DWORD cbDetachedHashBlob, DWORD cToBeHashed, const BYTE *rgpbToBeHashed[], DWORD rgcbToBeHashed[], BYTE *pbComputedHash, DWORD *pcbComputedHash)
     * }
     */
    public static MethodHandle CryptVerifyDetachedMessageHash$handle() {
        return CryptVerifyDetachedMessageHash.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL CryptVerifyDetachedMessageHash(PCRYPT_HASH_MESSAGE_PARA pHashPara, BYTE *pbDetachedHashBlob, DWORD cbDetachedHashBlob, DWORD cToBeHashed, const BYTE *rgpbToBeHashed[], DWORD rgcbToBeHashed[], BYTE *pbComputedHash, DWORD *pcbComputedHash)
     * }
     */
    public static int CryptVerifyDetachedMessageHash(MemorySegment pHashPara, MemorySegment pbDetachedHashBlob, int cbDetachedHashBlob, int cToBeHashed, MemorySegment rgpbToBeHashed, MemorySegment rgcbToBeHashed, MemorySegment pbComputedHash, MemorySegment pcbComputedHash) {
        var mh$ = CryptVerifyDetachedMessageHash.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CryptVerifyDetachedMessageHash", pHashPara, pbDetachedHashBlob, cbDetachedHashBlob, cToBeHashed, rgpbToBeHashed, rgcbToBeHashed, pbComputedHash, pcbComputedHash);
            }
            return (int)mh$.invokeExact(pHashPara, pbDetachedHashBlob, cbDetachedHashBlob, cToBeHashed, rgpbToBeHashed, rgcbToBeHashed, pbComputedHash, pcbComputedHash);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CryptSignMessageWithKey {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_LONG,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CryptSignMessageWithKey"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CryptSignMessageWithKey(PCRYPT_KEY_SIGN_MESSAGE_PARA pSignPara, const BYTE *pbToBeSigned, DWORD cbToBeSigned, BYTE *pbSignedBlob, DWORD *pcbSignedBlob)
     * }
     */
    public static FunctionDescriptor CryptSignMessageWithKey$descriptor() {
        return CryptSignMessageWithKey.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CryptSignMessageWithKey(PCRYPT_KEY_SIGN_MESSAGE_PARA pSignPara, const BYTE *pbToBeSigned, DWORD cbToBeSigned, BYTE *pbSignedBlob, DWORD *pcbSignedBlob)
     * }
     */
    public static MethodHandle CryptSignMessageWithKey$handle() {
        return CryptSignMessageWithKey.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL CryptSignMessageWithKey(PCRYPT_KEY_SIGN_MESSAGE_PARA pSignPara, const BYTE *pbToBeSigned, DWORD cbToBeSigned, BYTE *pbSignedBlob, DWORD *pcbSignedBlob)
     * }
     */
    public static int CryptSignMessageWithKey(MemorySegment pSignPara, MemorySegment pbToBeSigned, int cbToBeSigned, MemorySegment pbSignedBlob, MemorySegment pcbSignedBlob) {
        var mh$ = CryptSignMessageWithKey.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CryptSignMessageWithKey", pSignPara, pbToBeSigned, cbToBeSigned, pbSignedBlob, pcbSignedBlob);
            }
            return (int)mh$.invokeExact(pSignPara, pbToBeSigned, cbToBeSigned, pbSignedBlob, pcbSignedBlob);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CryptVerifyMessageSignatureWithKey {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_LONG,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CryptVerifyMessageSignatureWithKey"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CryptVerifyMessageSignatureWithKey(PCRYPT_KEY_VERIFY_MESSAGE_PARA pVerifyPara, PCERT_PUBLIC_KEY_INFO pPublicKeyInfo, const BYTE *pbSignedBlob, DWORD cbSignedBlob, BYTE *pbDecoded, DWORD *pcbDecoded)
     * }
     */
    public static FunctionDescriptor CryptVerifyMessageSignatureWithKey$descriptor() {
        return CryptVerifyMessageSignatureWithKey.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CryptVerifyMessageSignatureWithKey(PCRYPT_KEY_VERIFY_MESSAGE_PARA pVerifyPara, PCERT_PUBLIC_KEY_INFO pPublicKeyInfo, const BYTE *pbSignedBlob, DWORD cbSignedBlob, BYTE *pbDecoded, DWORD *pcbDecoded)
     * }
     */
    public static MethodHandle CryptVerifyMessageSignatureWithKey$handle() {
        return CryptVerifyMessageSignatureWithKey.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL CryptVerifyMessageSignatureWithKey(PCRYPT_KEY_VERIFY_MESSAGE_PARA pVerifyPara, PCERT_PUBLIC_KEY_INFO pPublicKeyInfo, const BYTE *pbSignedBlob, DWORD cbSignedBlob, BYTE *pbDecoded, DWORD *pcbDecoded)
     * }
     */
    public static int CryptVerifyMessageSignatureWithKey(MemorySegment pVerifyPara, MemorySegment pPublicKeyInfo, MemorySegment pbSignedBlob, int cbSignedBlob, MemorySegment pbDecoded, MemorySegment pcbDecoded) {
        var mh$ = CryptVerifyMessageSignatureWithKey.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CryptVerifyMessageSignatureWithKey", pVerifyPara, pPublicKeyInfo, pbSignedBlob, cbSignedBlob, pbDecoded, pcbDecoded);
            }
            return (int)mh$.invokeExact(pVerifyPara, pPublicKeyInfo, pbSignedBlob, cbSignedBlob, pbDecoded, pcbDecoded);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CertOpenSystemStoreA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_LONG_LONG,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CertOpenSystemStoreA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HCERTSTORE CertOpenSystemStoreA(HCRYPTPROV_LEGACY hProv, LPCSTR szSubsystemProtocol)
     * }
     */
    public static FunctionDescriptor CertOpenSystemStoreA$descriptor() {
        return CertOpenSystemStoreA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HCERTSTORE CertOpenSystemStoreA(HCRYPTPROV_LEGACY hProv, LPCSTR szSubsystemProtocol)
     * }
     */
    public static MethodHandle CertOpenSystemStoreA$handle() {
        return CertOpenSystemStoreA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * HCERTSTORE CertOpenSystemStoreA(HCRYPTPROV_LEGACY hProv, LPCSTR szSubsystemProtocol)
     * }
     */
    public static MemorySegment CertOpenSystemStoreA(long hProv, MemorySegment szSubsystemProtocol) {
        var mh$ = CertOpenSystemStoreA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CertOpenSystemStoreA", hProv, szSubsystemProtocol);
            }
            return (MemorySegment)mh$.invokeExact(hProv, szSubsystemProtocol);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CertOpenSystemStoreW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_LONG_LONG,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CertOpenSystemStoreW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HCERTSTORE CertOpenSystemStoreW(HCRYPTPROV_LEGACY hProv, LPCWSTR szSubsystemProtocol)
     * }
     */
    public static FunctionDescriptor CertOpenSystemStoreW$descriptor() {
        return CertOpenSystemStoreW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HCERTSTORE CertOpenSystemStoreW(HCRYPTPROV_LEGACY hProv, LPCWSTR szSubsystemProtocol)
     * }
     */
    public static MethodHandle CertOpenSystemStoreW$handle() {
        return CertOpenSystemStoreW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * HCERTSTORE CertOpenSystemStoreW(HCRYPTPROV_LEGACY hProv, LPCWSTR szSubsystemProtocol)
     * }
     */
    public static MemorySegment CertOpenSystemStoreW(long hProv, MemorySegment szSubsystemProtocol) {
        var mh$ = CertOpenSystemStoreW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CertOpenSystemStoreW", hProv, szSubsystemProtocol);
            }
            return (MemorySegment)mh$.invokeExact(hProv, szSubsystemProtocol);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CertAddEncodedCertificateToSystemStoreA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CertAddEncodedCertificateToSystemStoreA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CertAddEncodedCertificateToSystemStoreA(LPCSTR szCertStoreName, const BYTE *pbCertEncoded, DWORD cbCertEncoded)
     * }
     */
    public static FunctionDescriptor CertAddEncodedCertificateToSystemStoreA$descriptor() {
        return CertAddEncodedCertificateToSystemStoreA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CertAddEncodedCertificateToSystemStoreA(LPCSTR szCertStoreName, const BYTE *pbCertEncoded, DWORD cbCertEncoded)
     * }
     */
    public static MethodHandle CertAddEncodedCertificateToSystemStoreA$handle() {
        return CertAddEncodedCertificateToSystemStoreA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL CertAddEncodedCertificateToSystemStoreA(LPCSTR szCertStoreName, const BYTE *pbCertEncoded, DWORD cbCertEncoded)
     * }
     */
    public static int CertAddEncodedCertificateToSystemStoreA(MemorySegment szCertStoreName, MemorySegment pbCertEncoded, int cbCertEncoded) {
        var mh$ = CertAddEncodedCertificateToSystemStoreA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CertAddEncodedCertificateToSystemStoreA", szCertStoreName, pbCertEncoded, cbCertEncoded);
            }
            return (int)mh$.invokeExact(szCertStoreName, pbCertEncoded, cbCertEncoded);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CertAddEncodedCertificateToSystemStoreW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CertAddEncodedCertificateToSystemStoreW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CertAddEncodedCertificateToSystemStoreW(LPCWSTR szCertStoreName, const BYTE *pbCertEncoded, DWORD cbCertEncoded)
     * }
     */
    public static FunctionDescriptor CertAddEncodedCertificateToSystemStoreW$descriptor() {
        return CertAddEncodedCertificateToSystemStoreW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CertAddEncodedCertificateToSystemStoreW(LPCWSTR szCertStoreName, const BYTE *pbCertEncoded, DWORD cbCertEncoded)
     * }
     */
    public static MethodHandle CertAddEncodedCertificateToSystemStoreW$handle() {
        return CertAddEncodedCertificateToSystemStoreW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL CertAddEncodedCertificateToSystemStoreW(LPCWSTR szCertStoreName, const BYTE *pbCertEncoded, DWORD cbCertEncoded)
     * }
     */
    public static int CertAddEncodedCertificateToSystemStoreW(MemorySegment szCertStoreName, MemorySegment pbCertEncoded, int cbCertEncoded) {
        var mh$ = CertAddEncodedCertificateToSystemStoreW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CertAddEncodedCertificateToSystemStoreW", szCertStoreName, pbCertEncoded, cbCertEncoded);
            }
            return (int)mh$.invokeExact(szCertStoreName, pbCertEncoded, cbCertEncoded);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct _CERT_CHAIN {
     *     DWORD cCerts;
     *     PCERT_BLOB certs;
     *     CRYPT_KEY_PROV_INFO keyLocatorInfo;
     * } *PCERT_CHAIN
     * }
     */
    public static final AddressLayout PCERT_CHAIN = C_POINTER;

    private static class FindCertsByIssuer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_LONG,
            C_POINTER,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("FindCertsByIssuer"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HRESULT FindCertsByIssuer(PCERT_CHAIN pCertChains, DWORD *pcbCertChains, DWORD *pcCertChains, BYTE *pbEncodedIssuerName, DWORD cbEncodedIssuerName, LPCWSTR pwszPurpose, DWORD dwKeySpec)
     * }
     */
    public static FunctionDescriptor FindCertsByIssuer$descriptor() {
        return FindCertsByIssuer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HRESULT FindCertsByIssuer(PCERT_CHAIN pCertChains, DWORD *pcbCertChains, DWORD *pcCertChains, BYTE *pbEncodedIssuerName, DWORD cbEncodedIssuerName, LPCWSTR pwszPurpose, DWORD dwKeySpec)
     * }
     */
    public static MethodHandle FindCertsByIssuer$handle() {
        return FindCertsByIssuer.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * HRESULT FindCertsByIssuer(PCERT_CHAIN pCertChains, DWORD *pcbCertChains, DWORD *pcCertChains, BYTE *pbEncodedIssuerName, DWORD cbEncodedIssuerName, LPCWSTR pwszPurpose, DWORD dwKeySpec)
     * }
     */
    public static int FindCertsByIssuer(MemorySegment pCertChains, MemorySegment pcbCertChains, MemorySegment pcCertChains, MemorySegment pbEncodedIssuerName, int cbEncodedIssuerName, MemorySegment pwszPurpose, int dwKeySpec) {
        var mh$ = FindCertsByIssuer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FindCertsByIssuer", pCertChains, pcbCertChains, pcCertChains, pbEncodedIssuerName, cbEncodedIssuerName, pwszPurpose, dwKeySpec);
            }
            return (int)mh$.invokeExact(pCertChains, pcbCertChains, pcCertChains, pbEncodedIssuerName, cbEncodedIssuerName, pwszPurpose, dwKeySpec);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CryptQueryObject {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_LONG,
            C_POINTER,
            C_LONG,
            C_LONG,
            C_LONG,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CryptQueryObject"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CryptQueryObject(DWORD dwObjectType, const void *pvObject, DWORD dwExpectedContentTypeFlags, DWORD dwExpectedFormatTypeFlags, DWORD dwFlags, DWORD *pdwMsgAndCertEncodingType, DWORD *pdwContentType, DWORD *pdwFormatType, HCERTSTORE *phCertStore, HCRYPTMSG *phMsg, const void **ppvContext)
     * }
     */
    public static FunctionDescriptor CryptQueryObject$descriptor() {
        return CryptQueryObject.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CryptQueryObject(DWORD dwObjectType, const void *pvObject, DWORD dwExpectedContentTypeFlags, DWORD dwExpectedFormatTypeFlags, DWORD dwFlags, DWORD *pdwMsgAndCertEncodingType, DWORD *pdwContentType, DWORD *pdwFormatType, HCERTSTORE *phCertStore, HCRYPTMSG *phMsg, const void **ppvContext)
     * }
     */
    public static MethodHandle CryptQueryObject$handle() {
        return CryptQueryObject.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL CryptQueryObject(DWORD dwObjectType, const void *pvObject, DWORD dwExpectedContentTypeFlags, DWORD dwExpectedFormatTypeFlags, DWORD dwFlags, DWORD *pdwMsgAndCertEncodingType, DWORD *pdwContentType, DWORD *pdwFormatType, HCERTSTORE *phCertStore, HCRYPTMSG *phMsg, const void **ppvContext)
     * }
     */
    public static int CryptQueryObject(int dwObjectType, MemorySegment pvObject, int dwExpectedContentTypeFlags, int dwExpectedFormatTypeFlags, int dwFlags, MemorySegment pdwMsgAndCertEncodingType, MemorySegment pdwContentType, MemorySegment pdwFormatType, MemorySegment phCertStore, MemorySegment phMsg, MemorySegment ppvContext) {
        var mh$ = CryptQueryObject.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CryptQueryObject", dwObjectType, pvObject, dwExpectedContentTypeFlags, dwExpectedFormatTypeFlags, dwFlags, pdwMsgAndCertEncodingType, pdwContentType, pdwFormatType, phCertStore, phMsg, ppvContext);
            }
            return (int)mh$.invokeExact(dwObjectType, pvObject, dwExpectedContentTypeFlags, dwExpectedFormatTypeFlags, dwFlags, pdwMsgAndCertEncodingType, pdwContentType, pdwFormatType, phCertStore, phMsg, ppvContext);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CryptMemAlloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CryptMemAlloc"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LPVOID CryptMemAlloc(ULONG cbSize)
     * }
     */
    public static FunctionDescriptor CryptMemAlloc$descriptor() {
        return CryptMemAlloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LPVOID CryptMemAlloc(ULONG cbSize)
     * }
     */
    public static MethodHandle CryptMemAlloc$handle() {
        return CryptMemAlloc.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * LPVOID CryptMemAlloc(ULONG cbSize)
     * }
     */
    public static MemorySegment CryptMemAlloc(int cbSize) {
        var mh$ = CryptMemAlloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CryptMemAlloc", cbSize);
            }
            return (MemorySegment)mh$.invokeExact(cbSize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CryptMemRealloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CryptMemRealloc"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LPVOID CryptMemRealloc(LPVOID pv, ULONG cbSize)
     * }
     */
    public static FunctionDescriptor CryptMemRealloc$descriptor() {
        return CryptMemRealloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LPVOID CryptMemRealloc(LPVOID pv, ULONG cbSize)
     * }
     */
    public static MethodHandle CryptMemRealloc$handle() {
        return CryptMemRealloc.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * LPVOID CryptMemRealloc(LPVOID pv, ULONG cbSize)
     * }
     */
    public static MemorySegment CryptMemRealloc(MemorySegment pv, int cbSize) {
        var mh$ = CryptMemRealloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CryptMemRealloc", pv, cbSize);
            }
            return (MemorySegment)mh$.invokeExact(pv, cbSize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CryptMemFree {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CryptMemFree"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void CryptMemFree(LPVOID pv)
     * }
     */
    public static FunctionDescriptor CryptMemFree$descriptor() {
        return CryptMemFree.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void CryptMemFree(LPVOID pv)
     * }
     */
    public static MethodHandle CryptMemFree$handle() {
        return CryptMemFree.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * void CryptMemFree(LPVOID pv)
     * }
     */
    public static void CryptMemFree(MemorySegment pv) {
        var mh$ = CryptMemFree.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CryptMemFree", pv);
            }
            mh$.invokeExact(pv);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef HANDLE HCRYPTASYNC
     * }
     */
    public static final AddressLayout HCRYPTASYNC = C_POINTER;
}

