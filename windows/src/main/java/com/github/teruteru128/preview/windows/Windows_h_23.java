// Generated by jextract

package com.github.teruteru128.preview.windows;

import java.lang.invoke.*;
import java.lang.foreign.*;
import java.nio.ByteOrder;
import java.util.*;
import java.util.function.*;
import java.util.stream.*;

import static java.lang.foreign.ValueLayout.*;
import static java.lang.foreign.MemoryLayout.PathElement.*;

public class Windows_h_23 extends Windows_h_24 {

    Windows_h_23() {
        // Should not be called directly
    }
    private static final int DISPLAYCONFIG_COLOR_ENCODING_INTENSITY = (int)4L;
    /**
     * {@snippet lang=c :
     * enum _DISPLAYCONFIG_COLOR_ENCODING.DISPLAYCONFIG_COLOR_ENCODING_INTENSITY = 4
     * }
     */
    public static int DISPLAYCONFIG_COLOR_ENCODING_INTENSITY() {
        return DISPLAYCONFIG_COLOR_ENCODING_INTENSITY;
    }
    private static final int DISPLAYCONFIG_COLOR_ENCODING_FORCE_UINT32 = (int)-1L;
    /**
     * {@snippet lang=c :
     * enum _DISPLAYCONFIG_COLOR_ENCODING.DISPLAYCONFIG_COLOR_ENCODING_FORCE_UINT32 = -1
     * }
     */
    public static int DISPLAYCONFIG_COLOR_ENCODING_FORCE_UINT32() {
        return DISPLAYCONFIG_COLOR_ENCODING_FORCE_UINT32;
    }
    /**
     * {@snippet lang=c :
     * typedef struct _RGNDATAHEADER {
     *     DWORD dwSize;
     *     DWORD iType;
     *     DWORD nCount;
     *     DWORD nRgnSize;
     *     RECT rcBound;
     * } *PRGNDATAHEADER
     * }
     */
    public static final AddressLayout PRGNDATAHEADER = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _RGNDATA {
     *     RGNDATAHEADER rdh;
     *     char Buffer[1];
     * } *PRGNDATA
     * }
     */
    public static final AddressLayout PRGNDATA = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _RGNDATA {
     *     RGNDATAHEADER rdh;
     *     char Buffer[1];
     * } *NPRGNDATA
     * }
     */
    public static final AddressLayout NPRGNDATA = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _RGNDATA {
     *     RGNDATAHEADER rdh;
     *     char Buffer[1];
     * } *LPRGNDATA
     * }
     */
    public static final AddressLayout LPRGNDATA = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _ABC {
     *     int abcA;
     *     UINT abcB;
     *     int abcC;
     * } *PABC
     * }
     */
    public static final AddressLayout PABC = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _ABC {
     *     int abcA;
     *     UINT abcB;
     *     int abcC;
     * } *NPABC
     * }
     */
    public static final AddressLayout NPABC = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _ABC {
     *     int abcA;
     *     UINT abcB;
     *     int abcC;
     * } *LPABC
     * }
     */
    public static final AddressLayout LPABC = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _ABCFLOAT {
     *     FLOAT abcfA;
     *     FLOAT abcfB;
     *     FLOAT abcfC;
     * } *PABCFLOAT
     * }
     */
    public static final AddressLayout PABCFLOAT = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _ABCFLOAT {
     *     FLOAT abcfA;
     *     FLOAT abcfB;
     *     FLOAT abcfC;
     * } *NPABCFLOAT
     * }
     */
    public static final AddressLayout NPABCFLOAT = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _ABCFLOAT {
     *     FLOAT abcfA;
     *     FLOAT abcfB;
     *     FLOAT abcfC;
     * } *LPABCFLOAT
     * }
     */
    public static final AddressLayout LPABCFLOAT = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _OUTLINETEXTMETRICA {
     *     UINT otmSize;
     *     TEXTMETRICA otmTextMetrics;
     *     BYTE otmFiller;
     *     PANOSE otmPanoseNumber;
     *     UINT otmfsSelection;
     *     UINT otmfsType;
     *     int otmsCharSlopeRise;
     *     int otmsCharSlopeRun;
     *     int otmItalicAngle;
     *     UINT otmEMSquare;
     *     int otmAscent;
     *     int otmDescent;
     *     UINT otmLineGap;
     *     UINT otmsCapEmHeight;
     *     UINT otmsXHeight;
     *     RECT otmrcFontBox;
     *     int otmMacAscent;
     *     int otmMacDescent;
     *     UINT otmMacLineGap;
     *     UINT otmusMinimumPPEM;
     *     POINT otmptSubscriptSize;
     *     POINT otmptSubscriptOffset;
     *     POINT otmptSuperscriptSize;
     *     POINT otmptSuperscriptOffset;
     *     UINT otmsStrikeoutSize;
     *     int otmsStrikeoutPosition;
     *     int otmsUnderscoreSize;
     *     int otmsUnderscorePosition;
     *     PSTR otmpFamilyName;
     *     PSTR otmpFaceName;
     *     PSTR otmpStyleName;
     *     PSTR otmpFullName;
     * } *POUTLINETEXTMETRICA
     * }
     */
    public static final AddressLayout POUTLINETEXTMETRICA = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _OUTLINETEXTMETRICA {
     *     UINT otmSize;
     *     TEXTMETRICA otmTextMetrics;
     *     BYTE otmFiller;
     *     PANOSE otmPanoseNumber;
     *     UINT otmfsSelection;
     *     UINT otmfsType;
     *     int otmsCharSlopeRise;
     *     int otmsCharSlopeRun;
     *     int otmItalicAngle;
     *     UINT otmEMSquare;
     *     int otmAscent;
     *     int otmDescent;
     *     UINT otmLineGap;
     *     UINT otmsCapEmHeight;
     *     UINT otmsXHeight;
     *     RECT otmrcFontBox;
     *     int otmMacAscent;
     *     int otmMacDescent;
     *     UINT otmMacLineGap;
     *     UINT otmusMinimumPPEM;
     *     POINT otmptSubscriptSize;
     *     POINT otmptSubscriptOffset;
     *     POINT otmptSuperscriptSize;
     *     POINT otmptSuperscriptOffset;
     *     UINT otmsStrikeoutSize;
     *     int otmsStrikeoutPosition;
     *     int otmsUnderscoreSize;
     *     int otmsUnderscorePosition;
     *     PSTR otmpFamilyName;
     *     PSTR otmpFaceName;
     *     PSTR otmpStyleName;
     *     PSTR otmpFullName;
     * } *NPOUTLINETEXTMETRICA
     * }
     */
    public static final AddressLayout NPOUTLINETEXTMETRICA = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _OUTLINETEXTMETRICA {
     *     UINT otmSize;
     *     TEXTMETRICA otmTextMetrics;
     *     BYTE otmFiller;
     *     PANOSE otmPanoseNumber;
     *     UINT otmfsSelection;
     *     UINT otmfsType;
     *     int otmsCharSlopeRise;
     *     int otmsCharSlopeRun;
     *     int otmItalicAngle;
     *     UINT otmEMSquare;
     *     int otmAscent;
     *     int otmDescent;
     *     UINT otmLineGap;
     *     UINT otmsCapEmHeight;
     *     UINT otmsXHeight;
     *     RECT otmrcFontBox;
     *     int otmMacAscent;
     *     int otmMacDescent;
     *     UINT otmMacLineGap;
     *     UINT otmusMinimumPPEM;
     *     POINT otmptSubscriptSize;
     *     POINT otmptSubscriptOffset;
     *     POINT otmptSuperscriptSize;
     *     POINT otmptSuperscriptOffset;
     *     UINT otmsStrikeoutSize;
     *     int otmsStrikeoutPosition;
     *     int otmsUnderscoreSize;
     *     int otmsUnderscorePosition;
     *     PSTR otmpFamilyName;
     *     PSTR otmpFaceName;
     *     PSTR otmpStyleName;
     *     PSTR otmpFullName;
     * } *LPOUTLINETEXTMETRICA
     * }
     */
    public static final AddressLayout LPOUTLINETEXTMETRICA = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _OUTLINETEXTMETRICW {
     *     UINT otmSize;
     *     TEXTMETRICW otmTextMetrics;
     *     BYTE otmFiller;
     *     PANOSE otmPanoseNumber;
     *     UINT otmfsSelection;
     *     UINT otmfsType;
     *     int otmsCharSlopeRise;
     *     int otmsCharSlopeRun;
     *     int otmItalicAngle;
     *     UINT otmEMSquare;
     *     int otmAscent;
     *     int otmDescent;
     *     UINT otmLineGap;
     *     UINT otmsCapEmHeight;
     *     UINT otmsXHeight;
     *     RECT otmrcFontBox;
     *     int otmMacAscent;
     *     int otmMacDescent;
     *     UINT otmMacLineGap;
     *     UINT otmusMinimumPPEM;
     *     POINT otmptSubscriptSize;
     *     POINT otmptSubscriptOffset;
     *     POINT otmptSuperscriptSize;
     *     POINT otmptSuperscriptOffset;
     *     UINT otmsStrikeoutSize;
     *     int otmsStrikeoutPosition;
     *     int otmsUnderscoreSize;
     *     int otmsUnderscorePosition;
     *     PSTR otmpFamilyName;
     *     PSTR otmpFaceName;
     *     PSTR otmpStyleName;
     *     PSTR otmpFullName;
     * } *POUTLINETEXTMETRICW
     * }
     */
    public static final AddressLayout POUTLINETEXTMETRICW = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _OUTLINETEXTMETRICW {
     *     UINT otmSize;
     *     TEXTMETRICW otmTextMetrics;
     *     BYTE otmFiller;
     *     PANOSE otmPanoseNumber;
     *     UINT otmfsSelection;
     *     UINT otmfsType;
     *     int otmsCharSlopeRise;
     *     int otmsCharSlopeRun;
     *     int otmItalicAngle;
     *     UINT otmEMSquare;
     *     int otmAscent;
     *     int otmDescent;
     *     UINT otmLineGap;
     *     UINT otmsCapEmHeight;
     *     UINT otmsXHeight;
     *     RECT otmrcFontBox;
     *     int otmMacAscent;
     *     int otmMacDescent;
     *     UINT otmMacLineGap;
     *     UINT otmusMinimumPPEM;
     *     POINT otmptSubscriptSize;
     *     POINT otmptSubscriptOffset;
     *     POINT otmptSuperscriptSize;
     *     POINT otmptSuperscriptOffset;
     *     UINT otmsStrikeoutSize;
     *     int otmsStrikeoutPosition;
     *     int otmsUnderscoreSize;
     *     int otmsUnderscorePosition;
     *     PSTR otmpFamilyName;
     *     PSTR otmpFaceName;
     *     PSTR otmpStyleName;
     *     PSTR otmpFullName;
     * } *NPOUTLINETEXTMETRICW
     * }
     */
    public static final AddressLayout NPOUTLINETEXTMETRICW = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _OUTLINETEXTMETRICW {
     *     UINT otmSize;
     *     TEXTMETRICW otmTextMetrics;
     *     BYTE otmFiller;
     *     PANOSE otmPanoseNumber;
     *     UINT otmfsSelection;
     *     UINT otmfsType;
     *     int otmsCharSlopeRise;
     *     int otmsCharSlopeRun;
     *     int otmItalicAngle;
     *     UINT otmEMSquare;
     *     int otmAscent;
     *     int otmDescent;
     *     UINT otmLineGap;
     *     UINT otmsCapEmHeight;
     *     UINT otmsXHeight;
     *     RECT otmrcFontBox;
     *     int otmMacAscent;
     *     int otmMacDescent;
     *     UINT otmMacLineGap;
     *     UINT otmusMinimumPPEM;
     *     POINT otmptSubscriptSize;
     *     POINT otmptSubscriptOffset;
     *     POINT otmptSuperscriptSize;
     *     POINT otmptSuperscriptOffset;
     *     UINT otmsStrikeoutSize;
     *     int otmsStrikeoutPosition;
     *     int otmsUnderscoreSize;
     *     int otmsUnderscorePosition;
     *     PSTR otmpFamilyName;
     *     PSTR otmpFaceName;
     *     PSTR otmpStyleName;
     *     PSTR otmpFullName;
     * } *LPOUTLINETEXTMETRICW
     * }
     */
    public static final AddressLayout LPOUTLINETEXTMETRICW = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef POUTLINETEXTMETRICA POUTLINETEXTMETRIC
     * }
     */
    public static final AddressLayout POUTLINETEXTMETRIC = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef NPOUTLINETEXTMETRICA NPOUTLINETEXTMETRIC
     * }
     */
    public static final AddressLayout NPOUTLINETEXTMETRIC = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef LPOUTLINETEXTMETRICA LPOUTLINETEXTMETRIC
     * }
     */
    public static final AddressLayout LPOUTLINETEXTMETRIC = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagPOLYTEXTA {
     *     int x;
     *     int y;
     *     UINT n;
     *     LPCSTR lpstr;
     *     UINT uiFlags;
     *     RECT rcl;
     *     int *pdx;
     * } *PPOLYTEXTA
     * }
     */
    public static final AddressLayout PPOLYTEXTA = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagPOLYTEXTA {
     *     int x;
     *     int y;
     *     UINT n;
     *     LPCSTR lpstr;
     *     UINT uiFlags;
     *     RECT rcl;
     *     int *pdx;
     * } *NPPOLYTEXTA
     * }
     */
    public static final AddressLayout NPPOLYTEXTA = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagPOLYTEXTA {
     *     int x;
     *     int y;
     *     UINT n;
     *     LPCSTR lpstr;
     *     UINT uiFlags;
     *     RECT rcl;
     *     int *pdx;
     * } *LPPOLYTEXTA
     * }
     */
    public static final AddressLayout LPPOLYTEXTA = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagPOLYTEXTW {
     *     int x;
     *     int y;
     *     UINT n;
     *     LPCWSTR lpstr;
     *     UINT uiFlags;
     *     RECT rcl;
     *     int *pdx;
     * } *PPOLYTEXTW
     * }
     */
    public static final AddressLayout PPOLYTEXTW = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagPOLYTEXTW {
     *     int x;
     *     int y;
     *     UINT n;
     *     LPCWSTR lpstr;
     *     UINT uiFlags;
     *     RECT rcl;
     *     int *pdx;
     * } *NPPOLYTEXTW
     * }
     */
    public static final AddressLayout NPPOLYTEXTW = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagPOLYTEXTW {
     *     int x;
     *     int y;
     *     UINT n;
     *     LPCWSTR lpstr;
     *     UINT uiFlags;
     *     RECT rcl;
     *     int *pdx;
     * } *LPPOLYTEXTW
     * }
     */
    public static final AddressLayout LPPOLYTEXTW = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef PPOLYTEXTA PPOLYTEXT
     * }
     */
    public static final AddressLayout PPOLYTEXT = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef NPPOLYTEXTA NPPOLYTEXT
     * }
     */
    public static final AddressLayout NPPOLYTEXT = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef LPPOLYTEXTA LPPOLYTEXT
     * }
     */
    public static final AddressLayout LPPOLYTEXT = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _MAT2 {
     *     FIXED eM11;
     *     FIXED eM12;
     *     FIXED eM21;
     *     FIXED eM22;
     * } *LPMAT2
     * }
     */
    public static final AddressLayout LPMAT2 = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _GLYPHMETRICS {
     *     UINT gmBlackBoxX;
     *     UINT gmBlackBoxY;
     *     POINT gmptGlyphOrigin;
     *     short gmCellIncX;
     *     short gmCellIncY;
     * } *LPGLYPHMETRICS
     * }
     */
    public static final AddressLayout LPGLYPHMETRICS = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagPOINTFX {
     *     FIXED x;
     *     FIXED y;
     * } *LPPOINTFX
     * }
     */
    public static final AddressLayout LPPOINTFX = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagTTPOLYCURVE {
     *     WORD wType;
     *     WORD cpfx;
     *     POINTFX apfx[1];
     * } *LPTTPOLYCURVE
     * }
     */
    public static final AddressLayout LPTTPOLYCURVE = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagTTPOLYGONHEADER {
     *     DWORD cb;
     *     DWORD dwType;
     *     POINTFX pfxStart;
     * } *LPTTPOLYGONHEADER
     * }
     */
    public static final AddressLayout LPTTPOLYGONHEADER = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagGCP_RESULTSA {
     *     DWORD lStructSize;
     *     LPSTR lpOutString;
     *     UINT *lpOrder;
     *     int *lpDx;
     *     int *lpCaretPos;
     *     LPSTR lpClass;
     *     LPWSTR lpGlyphs;
     *     UINT nGlyphs;
     *     int nMaxFit;
     * } *LPGCP_RESULTSA
     * }
     */
    public static final AddressLayout LPGCP_RESULTSA = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagGCP_RESULTSW {
     *     DWORD lStructSize;
     *     LPWSTR lpOutString;
     *     UINT *lpOrder;
     *     int *lpDx;
     *     int *lpCaretPos;
     *     LPSTR lpClass;
     *     LPWSTR lpGlyphs;
     *     UINT nGlyphs;
     *     int nMaxFit;
     * } *LPGCP_RESULTSW
     * }
     */
    public static final AddressLayout LPGCP_RESULTSW = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef LPGCP_RESULTSA LPGCP_RESULTS
     * }
     */
    public static final AddressLayout LPGCP_RESULTS = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _RASTERIZER_STATUS {
     *     short nSize;
     *     short wFlags;
     *     short nLanguageID;
     * } *LPRASTERIZER_STATUS
     * }
     */
    public static final AddressLayout LPRASTERIZER_STATUS = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagPIXELFORMATDESCRIPTOR {
     *     WORD nSize;
     *     WORD nVersion;
     *     DWORD dwFlags;
     *     BYTE iPixelType;
     *     BYTE cColorBits;
     *     BYTE cRedBits;
     *     BYTE cRedShift;
     *     BYTE cGreenBits;
     *     BYTE cGreenShift;
     *     BYTE cBlueBits;
     *     BYTE cBlueShift;
     *     BYTE cAlphaBits;
     *     BYTE cAlphaShift;
     *     BYTE cAccumBits;
     *     BYTE cAccumRedBits;
     *     BYTE cAccumGreenBits;
     *     BYTE cAccumBlueBits;
     *     BYTE cAccumAlphaBits;
     *     BYTE cDepthBits;
     *     BYTE cStencilBits;
     *     BYTE cAuxBuffers;
     *     BYTE iLayerType;
     *     BYTE bReserved;
     *     DWORD dwLayerMask;
     *     DWORD dwVisibleMask;
     *     DWORD dwDamageMask;
     * } *PPIXELFORMATDESCRIPTOR
     * }
     */
    public static final AddressLayout PPIXELFORMATDESCRIPTOR = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagPIXELFORMATDESCRIPTOR {
     *     WORD nSize;
     *     WORD nVersion;
     *     DWORD dwFlags;
     *     BYTE iPixelType;
     *     BYTE cColorBits;
     *     BYTE cRedBits;
     *     BYTE cRedShift;
     *     BYTE cGreenBits;
     *     BYTE cGreenShift;
     *     BYTE cBlueBits;
     *     BYTE cBlueShift;
     *     BYTE cAlphaBits;
     *     BYTE cAlphaShift;
     *     BYTE cAccumBits;
     *     BYTE cAccumRedBits;
     *     BYTE cAccumGreenBits;
     *     BYTE cAccumBlueBits;
     *     BYTE cAccumAlphaBits;
     *     BYTE cDepthBits;
     *     BYTE cStencilBits;
     *     BYTE cAuxBuffers;
     *     BYTE iLayerType;
     *     BYTE bReserved;
     *     DWORD dwLayerMask;
     *     DWORD dwVisibleMask;
     *     DWORD dwDamageMask;
     * } *LPPIXELFORMATDESCRIPTOR
     * }
     */
    public static final AddressLayout LPPIXELFORMATDESCRIPTOR = C_POINTER;

    private static class AddFontResourceA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("AddFontResourceA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int AddFontResourceA(LPCSTR)
     * }
     */
    public static FunctionDescriptor AddFontResourceA$descriptor() {
        return AddFontResourceA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int AddFontResourceA(LPCSTR)
     * }
     */
    public static MethodHandle AddFontResourceA$handle() {
        return AddFontResourceA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int AddFontResourceA(LPCSTR)
     * }
     */
    public static int AddFontResourceA(MemorySegment x0) {
        var mh$ = AddFontResourceA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("AddFontResourceA", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class AddFontResourceW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("AddFontResourceW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int AddFontResourceW(LPCWSTR)
     * }
     */
    public static FunctionDescriptor AddFontResourceW$descriptor() {
        return AddFontResourceW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int AddFontResourceW(LPCWSTR)
     * }
     */
    public static MethodHandle AddFontResourceW$handle() {
        return AddFontResourceW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int AddFontResourceW(LPCWSTR)
     * }
     */
    public static int AddFontResourceW(MemorySegment x0) {
        var mh$ = AddFontResourceW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("AddFontResourceW", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class AnimatePalette {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_INT,
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("AnimatePalette"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL AnimatePalette(HPALETTE hPal, UINT iStartIndex, UINT cEntries, const PALETTEENTRY *ppe)
     * }
     */
    public static FunctionDescriptor AnimatePalette$descriptor() {
        return AnimatePalette.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL AnimatePalette(HPALETTE hPal, UINT iStartIndex, UINT cEntries, const PALETTEENTRY *ppe)
     * }
     */
    public static MethodHandle AnimatePalette$handle() {
        return AnimatePalette.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL AnimatePalette(HPALETTE hPal, UINT iStartIndex, UINT cEntries, const PALETTEENTRY *ppe)
     * }
     */
    public static int AnimatePalette(MemorySegment hPal, int iStartIndex, int cEntries, MemorySegment ppe) {
        var mh$ = AnimatePalette.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("AnimatePalette", hPal, iStartIndex, cEntries, ppe);
            }
            return (int)mh$.invokeExact(hPal, iStartIndex, cEntries, ppe);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Arc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_INT,
            C_INT,
            C_INT,
            C_INT,
            C_INT,
            C_INT,
            C_INT,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("Arc"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL Arc(HDC hdc, int x1, int y1, int x2, int y2, int x3, int y3, int x4, int y4)
     * }
     */
    public static FunctionDescriptor Arc$descriptor() {
        return Arc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL Arc(HDC hdc, int x1, int y1, int x2, int y2, int x3, int y3, int x4, int y4)
     * }
     */
    public static MethodHandle Arc$handle() {
        return Arc.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL Arc(HDC hdc, int x1, int y1, int x2, int y2, int x3, int y3, int x4, int y4)
     * }
     */
    public static int Arc(MemorySegment hdc, int x1, int y1, int x2, int y2, int x3, int y3, int x4, int y4) {
        var mh$ = Arc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Arc", hdc, x1, y1, x2, y2, x3, y3, x4, y4);
            }
            return (int)mh$.invokeExact(hdc, x1, y1, x2, y2, x3, y3, x4, y4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class BitBlt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_INT,
            C_INT,
            C_INT,
            C_INT,
            C_POINTER,
            C_INT,
            C_INT,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("BitBlt"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL BitBlt(HDC hdc, int x, int y, int cx, int cy, HDC hdcSrc, int x1, int y1, DWORD rop)
     * }
     */
    public static FunctionDescriptor BitBlt$descriptor() {
        return BitBlt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL BitBlt(HDC hdc, int x, int y, int cx, int cy, HDC hdcSrc, int x1, int y1, DWORD rop)
     * }
     */
    public static MethodHandle BitBlt$handle() {
        return BitBlt.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL BitBlt(HDC hdc, int x, int y, int cx, int cy, HDC hdcSrc, int x1, int y1, DWORD rop)
     * }
     */
    public static int BitBlt(MemorySegment hdc, int x, int y, int cx, int cy, MemorySegment hdcSrc, int x1, int y1, int rop) {
        var mh$ = BitBlt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("BitBlt", hdc, x, y, cx, cy, hdcSrc, x1, y1, rop);
            }
            return (int)mh$.invokeExact(hdc, x, y, cx, cy, hdcSrc, x1, y1, rop);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CancelDC {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CancelDC"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CancelDC(HDC hdc)
     * }
     */
    public static FunctionDescriptor CancelDC$descriptor() {
        return CancelDC.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CancelDC(HDC hdc)
     * }
     */
    public static MethodHandle CancelDC$handle() {
        return CancelDC.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL CancelDC(HDC hdc)
     * }
     */
    public static int CancelDC(MemorySegment hdc) {
        var mh$ = CancelDC.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CancelDC", hdc);
            }
            return (int)mh$.invokeExact(hdc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Chord {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_INT,
            C_INT,
            C_INT,
            C_INT,
            C_INT,
            C_INT,
            C_INT,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("Chord"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL Chord(HDC hdc, int x1, int y1, int x2, int y2, int x3, int y3, int x4, int y4)
     * }
     */
    public static FunctionDescriptor Chord$descriptor() {
        return Chord.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL Chord(HDC hdc, int x1, int y1, int x2, int y2, int x3, int y3, int x4, int y4)
     * }
     */
    public static MethodHandle Chord$handle() {
        return Chord.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL Chord(HDC hdc, int x1, int y1, int x2, int y2, int x3, int y3, int x4, int y4)
     * }
     */
    public static int Chord(MemorySegment hdc, int x1, int y1, int x2, int y2, int x3, int y3, int x4, int y4) {
        var mh$ = Chord.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Chord", hdc, x1, y1, x2, y2, x3, y3, x4, y4);
            }
            return (int)mh$.invokeExact(hdc, x1, y1, x2, y2, x3, y3, x4, y4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ChoosePixelFormat {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("ChoosePixelFormat"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int ChoosePixelFormat(HDC hdc, const PIXELFORMATDESCRIPTOR *ppfd)
     * }
     */
    public static FunctionDescriptor ChoosePixelFormat$descriptor() {
        return ChoosePixelFormat.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int ChoosePixelFormat(HDC hdc, const PIXELFORMATDESCRIPTOR *ppfd)
     * }
     */
    public static MethodHandle ChoosePixelFormat$handle() {
        return ChoosePixelFormat.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int ChoosePixelFormat(HDC hdc, const PIXELFORMATDESCRIPTOR *ppfd)
     * }
     */
    public static int ChoosePixelFormat(MemorySegment hdc, MemorySegment ppfd) {
        var mh$ = ChoosePixelFormat.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ChoosePixelFormat", hdc, ppfd);
            }
            return (int)mh$.invokeExact(hdc, ppfd);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CloseMetaFile {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CloseMetaFile"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HMETAFILE CloseMetaFile(HDC hdc)
     * }
     */
    public static FunctionDescriptor CloseMetaFile$descriptor() {
        return CloseMetaFile.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HMETAFILE CloseMetaFile(HDC hdc)
     * }
     */
    public static MethodHandle CloseMetaFile$handle() {
        return CloseMetaFile.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * HMETAFILE CloseMetaFile(HDC hdc)
     * }
     */
    public static MemorySegment CloseMetaFile(MemorySegment hdc) {
        var mh$ = CloseMetaFile.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CloseMetaFile", hdc);
            }
            return (MemorySegment)mh$.invokeExact(hdc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CombineRgn {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CombineRgn"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int CombineRgn(HRGN hrgnDst, HRGN hrgnSrc1, HRGN hrgnSrc2, int iMode)
     * }
     */
    public static FunctionDescriptor CombineRgn$descriptor() {
        return CombineRgn.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int CombineRgn(HRGN hrgnDst, HRGN hrgnSrc1, HRGN hrgnSrc2, int iMode)
     * }
     */
    public static MethodHandle CombineRgn$handle() {
        return CombineRgn.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int CombineRgn(HRGN hrgnDst, HRGN hrgnSrc1, HRGN hrgnSrc2, int iMode)
     * }
     */
    public static int CombineRgn(MemorySegment hrgnDst, MemorySegment hrgnSrc1, MemorySegment hrgnSrc2, int iMode) {
        var mh$ = CombineRgn.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CombineRgn", hrgnDst, hrgnSrc1, hrgnSrc2, iMode);
            }
            return (int)mh$.invokeExact(hrgnDst, hrgnSrc1, hrgnSrc2, iMode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CopyMetaFileA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CopyMetaFileA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HMETAFILE CopyMetaFileA(HMETAFILE, LPCSTR)
     * }
     */
    public static FunctionDescriptor CopyMetaFileA$descriptor() {
        return CopyMetaFileA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HMETAFILE CopyMetaFileA(HMETAFILE, LPCSTR)
     * }
     */
    public static MethodHandle CopyMetaFileA$handle() {
        return CopyMetaFileA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * HMETAFILE CopyMetaFileA(HMETAFILE, LPCSTR)
     * }
     */
    public static MemorySegment CopyMetaFileA(MemorySegment x0, MemorySegment x1) {
        var mh$ = CopyMetaFileA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CopyMetaFileA", x0, x1);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CopyMetaFileW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CopyMetaFileW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HMETAFILE CopyMetaFileW(HMETAFILE, LPCWSTR)
     * }
     */
    public static FunctionDescriptor CopyMetaFileW$descriptor() {
        return CopyMetaFileW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HMETAFILE CopyMetaFileW(HMETAFILE, LPCWSTR)
     * }
     */
    public static MethodHandle CopyMetaFileW$handle() {
        return CopyMetaFileW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * HMETAFILE CopyMetaFileW(HMETAFILE, LPCWSTR)
     * }
     */
    public static MemorySegment CopyMetaFileW(MemorySegment x0, MemorySegment x1) {
        var mh$ = CopyMetaFileW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CopyMetaFileW", x0, x1);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateBitmap {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_INT,
            C_INT,
            C_INT,
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CreateBitmap"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HBITMAP CreateBitmap(int nWidth, int nHeight, UINT nPlanes, UINT nBitCount, const void *lpBits)
     * }
     */
    public static FunctionDescriptor CreateBitmap$descriptor() {
        return CreateBitmap.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HBITMAP CreateBitmap(int nWidth, int nHeight, UINT nPlanes, UINT nBitCount, const void *lpBits)
     * }
     */
    public static MethodHandle CreateBitmap$handle() {
        return CreateBitmap.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * HBITMAP CreateBitmap(int nWidth, int nHeight, UINT nPlanes, UINT nBitCount, const void *lpBits)
     * }
     */
    public static MemorySegment CreateBitmap(int nWidth, int nHeight, int nPlanes, int nBitCount, MemorySegment lpBits) {
        var mh$ = CreateBitmap.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateBitmap", nWidth, nHeight, nPlanes, nBitCount, lpBits);
            }
            return (MemorySegment)mh$.invokeExact(nWidth, nHeight, nPlanes, nBitCount, lpBits);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateBitmapIndirect {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CreateBitmapIndirect"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HBITMAP CreateBitmapIndirect(const BITMAP *pbm)
     * }
     */
    public static FunctionDescriptor CreateBitmapIndirect$descriptor() {
        return CreateBitmapIndirect.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HBITMAP CreateBitmapIndirect(const BITMAP *pbm)
     * }
     */
    public static MethodHandle CreateBitmapIndirect$handle() {
        return CreateBitmapIndirect.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * HBITMAP CreateBitmapIndirect(const BITMAP *pbm)
     * }
     */
    public static MemorySegment CreateBitmapIndirect(MemorySegment pbm) {
        var mh$ = CreateBitmapIndirect.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateBitmapIndirect", pbm);
            }
            return (MemorySegment)mh$.invokeExact(pbm);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateBrushIndirect {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CreateBrushIndirect"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HBRUSH CreateBrushIndirect(const LOGBRUSH *plbrush)
     * }
     */
    public static FunctionDescriptor CreateBrushIndirect$descriptor() {
        return CreateBrushIndirect.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HBRUSH CreateBrushIndirect(const LOGBRUSH *plbrush)
     * }
     */
    public static MethodHandle CreateBrushIndirect$handle() {
        return CreateBrushIndirect.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * HBRUSH CreateBrushIndirect(const LOGBRUSH *plbrush)
     * }
     */
    public static MemorySegment CreateBrushIndirect(MemorySegment plbrush) {
        var mh$ = CreateBrushIndirect.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateBrushIndirect", plbrush);
            }
            return (MemorySegment)mh$.invokeExact(plbrush);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateCompatibleBitmap {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER,
            C_INT,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CreateCompatibleBitmap"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HBITMAP CreateCompatibleBitmap(HDC hdc, int cx, int cy)
     * }
     */
    public static FunctionDescriptor CreateCompatibleBitmap$descriptor() {
        return CreateCompatibleBitmap.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HBITMAP CreateCompatibleBitmap(HDC hdc, int cx, int cy)
     * }
     */
    public static MethodHandle CreateCompatibleBitmap$handle() {
        return CreateCompatibleBitmap.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * HBITMAP CreateCompatibleBitmap(HDC hdc, int cx, int cy)
     * }
     */
    public static MemorySegment CreateCompatibleBitmap(MemorySegment hdc, int cx, int cy) {
        var mh$ = CreateCompatibleBitmap.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateCompatibleBitmap", hdc, cx, cy);
            }
            return (MemorySegment)mh$.invokeExact(hdc, cx, cy);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateDiscardableBitmap {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER,
            C_INT,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CreateDiscardableBitmap"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HBITMAP CreateDiscardableBitmap(HDC hdc, int cx, int cy)
     * }
     */
    public static FunctionDescriptor CreateDiscardableBitmap$descriptor() {
        return CreateDiscardableBitmap.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HBITMAP CreateDiscardableBitmap(HDC hdc, int cx, int cy)
     * }
     */
    public static MethodHandle CreateDiscardableBitmap$handle() {
        return CreateDiscardableBitmap.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * HBITMAP CreateDiscardableBitmap(HDC hdc, int cx, int cy)
     * }
     */
    public static MemorySegment CreateDiscardableBitmap(MemorySegment hdc, int cx, int cy) {
        var mh$ = CreateDiscardableBitmap.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateDiscardableBitmap", hdc, cx, cy);
            }
            return (MemorySegment)mh$.invokeExact(hdc, cx, cy);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateCompatibleDC {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CreateCompatibleDC"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HDC CreateCompatibleDC(HDC hdc)
     * }
     */
    public static FunctionDescriptor CreateCompatibleDC$descriptor() {
        return CreateCompatibleDC.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HDC CreateCompatibleDC(HDC hdc)
     * }
     */
    public static MethodHandle CreateCompatibleDC$handle() {
        return CreateCompatibleDC.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * HDC CreateCompatibleDC(HDC hdc)
     * }
     */
    public static MemorySegment CreateCompatibleDC(MemorySegment hdc) {
        var mh$ = CreateCompatibleDC.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateCompatibleDC", hdc);
            }
            return (MemorySegment)mh$.invokeExact(hdc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateDCA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CreateDCA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HDC CreateDCA(LPCSTR pwszDriver, LPCSTR pwszDevice, LPCSTR pszPort, const DEVMODEA *pdm)
     * }
     */
    public static FunctionDescriptor CreateDCA$descriptor() {
        return CreateDCA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HDC CreateDCA(LPCSTR pwszDriver, LPCSTR pwszDevice, LPCSTR pszPort, const DEVMODEA *pdm)
     * }
     */
    public static MethodHandle CreateDCA$handle() {
        return CreateDCA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * HDC CreateDCA(LPCSTR pwszDriver, LPCSTR pwszDevice, LPCSTR pszPort, const DEVMODEA *pdm)
     * }
     */
    public static MemorySegment CreateDCA(MemorySegment pwszDriver, MemorySegment pwszDevice, MemorySegment pszPort, MemorySegment pdm) {
        var mh$ = CreateDCA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateDCA", pwszDriver, pwszDevice, pszPort, pdm);
            }
            return (MemorySegment)mh$.invokeExact(pwszDriver, pwszDevice, pszPort, pdm);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateDCW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CreateDCW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HDC CreateDCW(LPCWSTR pwszDriver, LPCWSTR pwszDevice, LPCWSTR pszPort, const DEVMODEW *pdm)
     * }
     */
    public static FunctionDescriptor CreateDCW$descriptor() {
        return CreateDCW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HDC CreateDCW(LPCWSTR pwszDriver, LPCWSTR pwszDevice, LPCWSTR pszPort, const DEVMODEW *pdm)
     * }
     */
    public static MethodHandle CreateDCW$handle() {
        return CreateDCW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * HDC CreateDCW(LPCWSTR pwszDriver, LPCWSTR pwszDevice, LPCWSTR pszPort, const DEVMODEW *pdm)
     * }
     */
    public static MemorySegment CreateDCW(MemorySegment pwszDriver, MemorySegment pwszDevice, MemorySegment pszPort, MemorySegment pdm) {
        var mh$ = CreateDCW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateDCW", pwszDriver, pwszDevice, pszPort, pdm);
            }
            return (MemorySegment)mh$.invokeExact(pwszDriver, pwszDevice, pszPort, pdm);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateDIBitmap {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_LONG,
            C_POINTER,
            C_POINTER,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CreateDIBitmap"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HBITMAP CreateDIBitmap(HDC hdc, const BITMAPINFOHEADER *pbmih, DWORD flInit, const void *pjBits, const BITMAPINFO *pbmi, UINT iUsage)
     * }
     */
    public static FunctionDescriptor CreateDIBitmap$descriptor() {
        return CreateDIBitmap.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HBITMAP CreateDIBitmap(HDC hdc, const BITMAPINFOHEADER *pbmih, DWORD flInit, const void *pjBits, const BITMAPINFO *pbmi, UINT iUsage)
     * }
     */
    public static MethodHandle CreateDIBitmap$handle() {
        return CreateDIBitmap.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * HBITMAP CreateDIBitmap(HDC hdc, const BITMAPINFOHEADER *pbmih, DWORD flInit, const void *pjBits, const BITMAPINFO *pbmi, UINT iUsage)
     * }
     */
    public static MemorySegment CreateDIBitmap(MemorySegment hdc, MemorySegment pbmih, int flInit, MemorySegment pjBits, MemorySegment pbmi, int iUsage) {
        var mh$ = CreateDIBitmap.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateDIBitmap", hdc, pbmih, flInit, pjBits, pbmi, iUsage);
            }
            return (MemorySegment)mh$.invokeExact(hdc, pbmih, flInit, pjBits, pbmi, iUsage);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateDIBPatternBrush {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CreateDIBPatternBrush"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HBRUSH CreateDIBPatternBrush(HGLOBAL h, UINT iUsage)
     * }
     */
    public static FunctionDescriptor CreateDIBPatternBrush$descriptor() {
        return CreateDIBPatternBrush.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HBRUSH CreateDIBPatternBrush(HGLOBAL h, UINT iUsage)
     * }
     */
    public static MethodHandle CreateDIBPatternBrush$handle() {
        return CreateDIBPatternBrush.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * HBRUSH CreateDIBPatternBrush(HGLOBAL h, UINT iUsage)
     * }
     */
    public static MemorySegment CreateDIBPatternBrush(MemorySegment h, int iUsage) {
        var mh$ = CreateDIBPatternBrush.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateDIBPatternBrush", h, iUsage);
            }
            return (MemorySegment)mh$.invokeExact(h, iUsage);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateDIBPatternBrushPt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CreateDIBPatternBrushPt"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HBRUSH CreateDIBPatternBrushPt(const void *lpPackedDIB, UINT iUsage)
     * }
     */
    public static FunctionDescriptor CreateDIBPatternBrushPt$descriptor() {
        return CreateDIBPatternBrushPt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HBRUSH CreateDIBPatternBrushPt(const void *lpPackedDIB, UINT iUsage)
     * }
     */
    public static MethodHandle CreateDIBPatternBrushPt$handle() {
        return CreateDIBPatternBrushPt.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * HBRUSH CreateDIBPatternBrushPt(const void *lpPackedDIB, UINT iUsage)
     * }
     */
    public static MemorySegment CreateDIBPatternBrushPt(MemorySegment lpPackedDIB, int iUsage) {
        var mh$ = CreateDIBPatternBrushPt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateDIBPatternBrushPt", lpPackedDIB, iUsage);
            }
            return (MemorySegment)mh$.invokeExact(lpPackedDIB, iUsage);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateEllipticRgn {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_INT,
            C_INT,
            C_INT,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CreateEllipticRgn"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HRGN CreateEllipticRgn(int x1, int y1, int x2, int y2)
     * }
     */
    public static FunctionDescriptor CreateEllipticRgn$descriptor() {
        return CreateEllipticRgn.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HRGN CreateEllipticRgn(int x1, int y1, int x2, int y2)
     * }
     */
    public static MethodHandle CreateEllipticRgn$handle() {
        return CreateEllipticRgn.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * HRGN CreateEllipticRgn(int x1, int y1, int x2, int y2)
     * }
     */
    public static MemorySegment CreateEllipticRgn(int x1, int y1, int x2, int y2) {
        var mh$ = CreateEllipticRgn.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateEllipticRgn", x1, y1, x2, y2);
            }
            return (MemorySegment)mh$.invokeExact(x1, y1, x2, y2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateEllipticRgnIndirect {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CreateEllipticRgnIndirect"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HRGN CreateEllipticRgnIndirect(const RECT *lprect)
     * }
     */
    public static FunctionDescriptor CreateEllipticRgnIndirect$descriptor() {
        return CreateEllipticRgnIndirect.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HRGN CreateEllipticRgnIndirect(const RECT *lprect)
     * }
     */
    public static MethodHandle CreateEllipticRgnIndirect$handle() {
        return CreateEllipticRgnIndirect.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * HRGN CreateEllipticRgnIndirect(const RECT *lprect)
     * }
     */
    public static MemorySegment CreateEllipticRgnIndirect(MemorySegment lprect) {
        var mh$ = CreateEllipticRgnIndirect.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateEllipticRgnIndirect", lprect);
            }
            return (MemorySegment)mh$.invokeExact(lprect);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateFontIndirectA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CreateFontIndirectA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HFONT CreateFontIndirectA(const LOGFONTA *lplf)
     * }
     */
    public static FunctionDescriptor CreateFontIndirectA$descriptor() {
        return CreateFontIndirectA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HFONT CreateFontIndirectA(const LOGFONTA *lplf)
     * }
     */
    public static MethodHandle CreateFontIndirectA$handle() {
        return CreateFontIndirectA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * HFONT CreateFontIndirectA(const LOGFONTA *lplf)
     * }
     */
    public static MemorySegment CreateFontIndirectA(MemorySegment lplf) {
        var mh$ = CreateFontIndirectA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateFontIndirectA", lplf);
            }
            return (MemorySegment)mh$.invokeExact(lplf);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateFontIndirectW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CreateFontIndirectW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HFONT CreateFontIndirectW(const LOGFONTW *lplf)
     * }
     */
    public static FunctionDescriptor CreateFontIndirectW$descriptor() {
        return CreateFontIndirectW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HFONT CreateFontIndirectW(const LOGFONTW *lplf)
     * }
     */
    public static MethodHandle CreateFontIndirectW$handle() {
        return CreateFontIndirectW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * HFONT CreateFontIndirectW(const LOGFONTW *lplf)
     * }
     */
    public static MemorySegment CreateFontIndirectW(MemorySegment lplf) {
        var mh$ = CreateFontIndirectW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateFontIndirectW", lplf);
            }
            return (MemorySegment)mh$.invokeExact(lplf);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateFontA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_INT,
            C_INT,
            C_INT,
            C_INT,
            C_INT,
            C_LONG,
            C_LONG,
            C_LONG,
            C_LONG,
            C_LONG,
            C_LONG,
            C_LONG,
            C_LONG,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CreateFontA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HFONT CreateFontA(int cHeight, int cWidth, int cEscapement, int cOrientation, int cWeight, DWORD bItalic, DWORD bUnderline, DWORD bStrikeOut, DWORD iCharSet, DWORD iOutPrecision, DWORD iClipPrecision, DWORD iQuality, DWORD iPitchAndFamily, LPCSTR pszFaceName)
     * }
     */
    public static FunctionDescriptor CreateFontA$descriptor() {
        return CreateFontA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HFONT CreateFontA(int cHeight, int cWidth, int cEscapement, int cOrientation, int cWeight, DWORD bItalic, DWORD bUnderline, DWORD bStrikeOut, DWORD iCharSet, DWORD iOutPrecision, DWORD iClipPrecision, DWORD iQuality, DWORD iPitchAndFamily, LPCSTR pszFaceName)
     * }
     */
    public static MethodHandle CreateFontA$handle() {
        return CreateFontA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * HFONT CreateFontA(int cHeight, int cWidth, int cEscapement, int cOrientation, int cWeight, DWORD bItalic, DWORD bUnderline, DWORD bStrikeOut, DWORD iCharSet, DWORD iOutPrecision, DWORD iClipPrecision, DWORD iQuality, DWORD iPitchAndFamily, LPCSTR pszFaceName)
     * }
     */
    public static MemorySegment CreateFontA(int cHeight, int cWidth, int cEscapement, int cOrientation, int cWeight, int bItalic, int bUnderline, int bStrikeOut, int iCharSet, int iOutPrecision, int iClipPrecision, int iQuality, int iPitchAndFamily, MemorySegment pszFaceName) {
        var mh$ = CreateFontA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateFontA", cHeight, cWidth, cEscapement, cOrientation, cWeight, bItalic, bUnderline, bStrikeOut, iCharSet, iOutPrecision, iClipPrecision, iQuality, iPitchAndFamily, pszFaceName);
            }
            return (MemorySegment)mh$.invokeExact(cHeight, cWidth, cEscapement, cOrientation, cWeight, bItalic, bUnderline, bStrikeOut, iCharSet, iOutPrecision, iClipPrecision, iQuality, iPitchAndFamily, pszFaceName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateFontW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_INT,
            C_INT,
            C_INT,
            C_INT,
            C_INT,
            C_LONG,
            C_LONG,
            C_LONG,
            C_LONG,
            C_LONG,
            C_LONG,
            C_LONG,
            C_LONG,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CreateFontW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HFONT CreateFontW(int cHeight, int cWidth, int cEscapement, int cOrientation, int cWeight, DWORD bItalic, DWORD bUnderline, DWORD bStrikeOut, DWORD iCharSet, DWORD iOutPrecision, DWORD iClipPrecision, DWORD iQuality, DWORD iPitchAndFamily, LPCWSTR pszFaceName)
     * }
     */
    public static FunctionDescriptor CreateFontW$descriptor() {
        return CreateFontW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HFONT CreateFontW(int cHeight, int cWidth, int cEscapement, int cOrientation, int cWeight, DWORD bItalic, DWORD bUnderline, DWORD bStrikeOut, DWORD iCharSet, DWORD iOutPrecision, DWORD iClipPrecision, DWORD iQuality, DWORD iPitchAndFamily, LPCWSTR pszFaceName)
     * }
     */
    public static MethodHandle CreateFontW$handle() {
        return CreateFontW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * HFONT CreateFontW(int cHeight, int cWidth, int cEscapement, int cOrientation, int cWeight, DWORD bItalic, DWORD bUnderline, DWORD bStrikeOut, DWORD iCharSet, DWORD iOutPrecision, DWORD iClipPrecision, DWORD iQuality, DWORD iPitchAndFamily, LPCWSTR pszFaceName)
     * }
     */
    public static MemorySegment CreateFontW(int cHeight, int cWidth, int cEscapement, int cOrientation, int cWeight, int bItalic, int bUnderline, int bStrikeOut, int iCharSet, int iOutPrecision, int iClipPrecision, int iQuality, int iPitchAndFamily, MemorySegment pszFaceName) {
        var mh$ = CreateFontW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateFontW", cHeight, cWidth, cEscapement, cOrientation, cWeight, bItalic, bUnderline, bStrikeOut, iCharSet, iOutPrecision, iClipPrecision, iQuality, iPitchAndFamily, pszFaceName);
            }
            return (MemorySegment)mh$.invokeExact(cHeight, cWidth, cEscapement, cOrientation, cWeight, bItalic, bUnderline, bStrikeOut, iCharSet, iOutPrecision, iClipPrecision, iQuality, iPitchAndFamily, pszFaceName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateHatchBrush {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_INT,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CreateHatchBrush"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HBRUSH CreateHatchBrush(int iHatch, COLORREF color)
     * }
     */
    public static FunctionDescriptor CreateHatchBrush$descriptor() {
        return CreateHatchBrush.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HBRUSH CreateHatchBrush(int iHatch, COLORREF color)
     * }
     */
    public static MethodHandle CreateHatchBrush$handle() {
        return CreateHatchBrush.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * HBRUSH CreateHatchBrush(int iHatch, COLORREF color)
     * }
     */
    public static MemorySegment CreateHatchBrush(int iHatch, int color) {
        var mh$ = CreateHatchBrush.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateHatchBrush", iHatch, color);
            }
            return (MemorySegment)mh$.invokeExact(iHatch, color);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateICA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CreateICA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HDC CreateICA(LPCSTR pszDriver, LPCSTR pszDevice, LPCSTR pszPort, const DEVMODEA *pdm)
     * }
     */
    public static FunctionDescriptor CreateICA$descriptor() {
        return CreateICA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HDC CreateICA(LPCSTR pszDriver, LPCSTR pszDevice, LPCSTR pszPort, const DEVMODEA *pdm)
     * }
     */
    public static MethodHandle CreateICA$handle() {
        return CreateICA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * HDC CreateICA(LPCSTR pszDriver, LPCSTR pszDevice, LPCSTR pszPort, const DEVMODEA *pdm)
     * }
     */
    public static MemorySegment CreateICA(MemorySegment pszDriver, MemorySegment pszDevice, MemorySegment pszPort, MemorySegment pdm) {
        var mh$ = CreateICA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateICA", pszDriver, pszDevice, pszPort, pdm);
            }
            return (MemorySegment)mh$.invokeExact(pszDriver, pszDevice, pszPort, pdm);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateICW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CreateICW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HDC CreateICW(LPCWSTR pszDriver, LPCWSTR pszDevice, LPCWSTR pszPort, const DEVMODEW *pdm)
     * }
     */
    public static FunctionDescriptor CreateICW$descriptor() {
        return CreateICW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HDC CreateICW(LPCWSTR pszDriver, LPCWSTR pszDevice, LPCWSTR pszPort, const DEVMODEW *pdm)
     * }
     */
    public static MethodHandle CreateICW$handle() {
        return CreateICW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * HDC CreateICW(LPCWSTR pszDriver, LPCWSTR pszDevice, LPCWSTR pszPort, const DEVMODEW *pdm)
     * }
     */
    public static MemorySegment CreateICW(MemorySegment pszDriver, MemorySegment pszDevice, MemorySegment pszPort, MemorySegment pdm) {
        var mh$ = CreateICW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateICW", pszDriver, pszDevice, pszPort, pdm);
            }
            return (MemorySegment)mh$.invokeExact(pszDriver, pszDevice, pszPort, pdm);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateMetaFileA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CreateMetaFileA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HDC CreateMetaFileA(LPCSTR pszFile)
     * }
     */
    public static FunctionDescriptor CreateMetaFileA$descriptor() {
        return CreateMetaFileA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HDC CreateMetaFileA(LPCSTR pszFile)
     * }
     */
    public static MethodHandle CreateMetaFileA$handle() {
        return CreateMetaFileA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * HDC CreateMetaFileA(LPCSTR pszFile)
     * }
     */
    public static MemorySegment CreateMetaFileA(MemorySegment pszFile) {
        var mh$ = CreateMetaFileA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateMetaFileA", pszFile);
            }
            return (MemorySegment)mh$.invokeExact(pszFile);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateMetaFileW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CreateMetaFileW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HDC CreateMetaFileW(LPCWSTR pszFile)
     * }
     */
    public static FunctionDescriptor CreateMetaFileW$descriptor() {
        return CreateMetaFileW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HDC CreateMetaFileW(LPCWSTR pszFile)
     * }
     */
    public static MethodHandle CreateMetaFileW$handle() {
        return CreateMetaFileW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * HDC CreateMetaFileW(LPCWSTR pszFile)
     * }
     */
    public static MemorySegment CreateMetaFileW(MemorySegment pszFile) {
        var mh$ = CreateMetaFileW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateMetaFileW", pszFile);
            }
            return (MemorySegment)mh$.invokeExact(pszFile);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreatePalette {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CreatePalette"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HPALETTE CreatePalette(const LOGPALETTE *plpal)
     * }
     */
    public static FunctionDescriptor CreatePalette$descriptor() {
        return CreatePalette.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HPALETTE CreatePalette(const LOGPALETTE *plpal)
     * }
     */
    public static MethodHandle CreatePalette$handle() {
        return CreatePalette.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * HPALETTE CreatePalette(const LOGPALETTE *plpal)
     * }
     */
    public static MemorySegment CreatePalette(MemorySegment plpal) {
        var mh$ = CreatePalette.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreatePalette", plpal);
            }
            return (MemorySegment)mh$.invokeExact(plpal);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreatePen {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_INT,
            C_INT,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CreatePen"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HPEN CreatePen(int iStyle, int cWidth, COLORREF color)
     * }
     */
    public static FunctionDescriptor CreatePen$descriptor() {
        return CreatePen.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HPEN CreatePen(int iStyle, int cWidth, COLORREF color)
     * }
     */
    public static MethodHandle CreatePen$handle() {
        return CreatePen.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * HPEN CreatePen(int iStyle, int cWidth, COLORREF color)
     * }
     */
    public static MemorySegment CreatePen(int iStyle, int cWidth, int color) {
        var mh$ = CreatePen.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreatePen", iStyle, cWidth, color);
            }
            return (MemorySegment)mh$.invokeExact(iStyle, cWidth, color);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreatePenIndirect {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CreatePenIndirect"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HPEN CreatePenIndirect(const LOGPEN *plpen)
     * }
     */
    public static FunctionDescriptor CreatePenIndirect$descriptor() {
        return CreatePenIndirect.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HPEN CreatePenIndirect(const LOGPEN *plpen)
     * }
     */
    public static MethodHandle CreatePenIndirect$handle() {
        return CreatePenIndirect.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * HPEN CreatePenIndirect(const LOGPEN *plpen)
     * }
     */
    public static MemorySegment CreatePenIndirect(MemorySegment plpen) {
        var mh$ = CreatePenIndirect.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreatePenIndirect", plpen);
            }
            return (MemorySegment)mh$.invokeExact(plpen);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreatePolyPolygonRgn {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_INT,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CreatePolyPolygonRgn"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HRGN CreatePolyPolygonRgn(const POINT *pptl, const INT *pc, int cPoly, int iMode)
     * }
     */
    public static FunctionDescriptor CreatePolyPolygonRgn$descriptor() {
        return CreatePolyPolygonRgn.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HRGN CreatePolyPolygonRgn(const POINT *pptl, const INT *pc, int cPoly, int iMode)
     * }
     */
    public static MethodHandle CreatePolyPolygonRgn$handle() {
        return CreatePolyPolygonRgn.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * HRGN CreatePolyPolygonRgn(const POINT *pptl, const INT *pc, int cPoly, int iMode)
     * }
     */
    public static MemorySegment CreatePolyPolygonRgn(MemorySegment pptl, MemorySegment pc, int cPoly, int iMode) {
        var mh$ = CreatePolyPolygonRgn.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreatePolyPolygonRgn", pptl, pc, cPoly, iMode);
            }
            return (MemorySegment)mh$.invokeExact(pptl, pc, cPoly, iMode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreatePatternBrush {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CreatePatternBrush"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HBRUSH CreatePatternBrush(HBITMAP hbm)
     * }
     */
    public static FunctionDescriptor CreatePatternBrush$descriptor() {
        return CreatePatternBrush.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HBRUSH CreatePatternBrush(HBITMAP hbm)
     * }
     */
    public static MethodHandle CreatePatternBrush$handle() {
        return CreatePatternBrush.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * HBRUSH CreatePatternBrush(HBITMAP hbm)
     * }
     */
    public static MemorySegment CreatePatternBrush(MemorySegment hbm) {
        var mh$ = CreatePatternBrush.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreatePatternBrush", hbm);
            }
            return (MemorySegment)mh$.invokeExact(hbm);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateRectRgn {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_INT,
            C_INT,
            C_INT,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CreateRectRgn"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HRGN CreateRectRgn(int x1, int y1, int x2, int y2)
     * }
     */
    public static FunctionDescriptor CreateRectRgn$descriptor() {
        return CreateRectRgn.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HRGN CreateRectRgn(int x1, int y1, int x2, int y2)
     * }
     */
    public static MethodHandle CreateRectRgn$handle() {
        return CreateRectRgn.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * HRGN CreateRectRgn(int x1, int y1, int x2, int y2)
     * }
     */
    public static MemorySegment CreateRectRgn(int x1, int y1, int x2, int y2) {
        var mh$ = CreateRectRgn.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateRectRgn", x1, y1, x2, y2);
            }
            return (MemorySegment)mh$.invokeExact(x1, y1, x2, y2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateRectRgnIndirect {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CreateRectRgnIndirect"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HRGN CreateRectRgnIndirect(const RECT *lprect)
     * }
     */
    public static FunctionDescriptor CreateRectRgnIndirect$descriptor() {
        return CreateRectRgnIndirect.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HRGN CreateRectRgnIndirect(const RECT *lprect)
     * }
     */
    public static MethodHandle CreateRectRgnIndirect$handle() {
        return CreateRectRgnIndirect.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * HRGN CreateRectRgnIndirect(const RECT *lprect)
     * }
     */
    public static MemorySegment CreateRectRgnIndirect(MemorySegment lprect) {
        var mh$ = CreateRectRgnIndirect.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateRectRgnIndirect", lprect);
            }
            return (MemorySegment)mh$.invokeExact(lprect);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateRoundRectRgn {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_INT,
            C_INT,
            C_INT,
            C_INT,
            C_INT,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CreateRoundRectRgn"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HRGN CreateRoundRectRgn(int x1, int y1, int x2, int y2, int w, int h)
     * }
     */
    public static FunctionDescriptor CreateRoundRectRgn$descriptor() {
        return CreateRoundRectRgn.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HRGN CreateRoundRectRgn(int x1, int y1, int x2, int y2, int w, int h)
     * }
     */
    public static MethodHandle CreateRoundRectRgn$handle() {
        return CreateRoundRectRgn.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * HRGN CreateRoundRectRgn(int x1, int y1, int x2, int y2, int w, int h)
     * }
     */
    public static MemorySegment CreateRoundRectRgn(int x1, int y1, int x2, int y2, int w, int h) {
        var mh$ = CreateRoundRectRgn.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateRoundRectRgn", x1, y1, x2, y2, w, h);
            }
            return (MemorySegment)mh$.invokeExact(x1, y1, x2, y2, w, h);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateScalableFontResourceA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_LONG,
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CreateScalableFontResourceA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CreateScalableFontResourceA(DWORD fdwHidden, LPCSTR lpszFont, LPCSTR lpszFile, LPCSTR lpszPath)
     * }
     */
    public static FunctionDescriptor CreateScalableFontResourceA$descriptor() {
        return CreateScalableFontResourceA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CreateScalableFontResourceA(DWORD fdwHidden, LPCSTR lpszFont, LPCSTR lpszFile, LPCSTR lpszPath)
     * }
     */
    public static MethodHandle CreateScalableFontResourceA$handle() {
        return CreateScalableFontResourceA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL CreateScalableFontResourceA(DWORD fdwHidden, LPCSTR lpszFont, LPCSTR lpszFile, LPCSTR lpszPath)
     * }
     */
    public static int CreateScalableFontResourceA(int fdwHidden, MemorySegment lpszFont, MemorySegment lpszFile, MemorySegment lpszPath) {
        var mh$ = CreateScalableFontResourceA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateScalableFontResourceA", fdwHidden, lpszFont, lpszFile, lpszPath);
            }
            return (int)mh$.invokeExact(fdwHidden, lpszFont, lpszFile, lpszPath);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateScalableFontResourceW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_LONG,
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CreateScalableFontResourceW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CreateScalableFontResourceW(DWORD fdwHidden, LPCWSTR lpszFont, LPCWSTR lpszFile, LPCWSTR lpszPath)
     * }
     */
    public static FunctionDescriptor CreateScalableFontResourceW$descriptor() {
        return CreateScalableFontResourceW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CreateScalableFontResourceW(DWORD fdwHidden, LPCWSTR lpszFont, LPCWSTR lpszFile, LPCWSTR lpszPath)
     * }
     */
    public static MethodHandle CreateScalableFontResourceW$handle() {
        return CreateScalableFontResourceW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL CreateScalableFontResourceW(DWORD fdwHidden, LPCWSTR lpszFont, LPCWSTR lpszFile, LPCWSTR lpszPath)
     * }
     */
    public static int CreateScalableFontResourceW(int fdwHidden, MemorySegment lpszFont, MemorySegment lpszFile, MemorySegment lpszPath) {
        var mh$ = CreateScalableFontResourceW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateScalableFontResourceW", fdwHidden, lpszFont, lpszFile, lpszPath);
            }
            return (int)mh$.invokeExact(fdwHidden, lpszFont, lpszFile, lpszPath);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateSolidBrush {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CreateSolidBrush"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HBRUSH CreateSolidBrush(COLORREF color)
     * }
     */
    public static FunctionDescriptor CreateSolidBrush$descriptor() {
        return CreateSolidBrush.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HBRUSH CreateSolidBrush(COLORREF color)
     * }
     */
    public static MethodHandle CreateSolidBrush$handle() {
        return CreateSolidBrush.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * HBRUSH CreateSolidBrush(COLORREF color)
     * }
     */
    public static MemorySegment CreateSolidBrush(int color) {
        var mh$ = CreateSolidBrush.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateSolidBrush", color);
            }
            return (MemorySegment)mh$.invokeExact(color);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DeleteDC {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("DeleteDC"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL DeleteDC(HDC hdc)
     * }
     */
    public static FunctionDescriptor DeleteDC$descriptor() {
        return DeleteDC.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL DeleteDC(HDC hdc)
     * }
     */
    public static MethodHandle DeleteDC$handle() {
        return DeleteDC.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL DeleteDC(HDC hdc)
     * }
     */
    public static int DeleteDC(MemorySegment hdc) {
        var mh$ = DeleteDC.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DeleteDC", hdc);
            }
            return (int)mh$.invokeExact(hdc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DeleteMetaFile {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("DeleteMetaFile"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL DeleteMetaFile(HMETAFILE hmf)
     * }
     */
    public static FunctionDescriptor DeleteMetaFile$descriptor() {
        return DeleteMetaFile.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL DeleteMetaFile(HMETAFILE hmf)
     * }
     */
    public static MethodHandle DeleteMetaFile$handle() {
        return DeleteMetaFile.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL DeleteMetaFile(HMETAFILE hmf)
     * }
     */
    public static int DeleteMetaFile(MemorySegment hmf) {
        var mh$ = DeleteMetaFile.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DeleteMetaFile", hmf);
            }
            return (int)mh$.invokeExact(hmf);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DeleteObject {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("DeleteObject"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL DeleteObject(HGDIOBJ ho)
     * }
     */
    public static FunctionDescriptor DeleteObject$descriptor() {
        return DeleteObject.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL DeleteObject(HGDIOBJ ho)
     * }
     */
    public static MethodHandle DeleteObject$handle() {
        return DeleteObject.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL DeleteObject(HGDIOBJ ho)
     * }
     */
    public static int DeleteObject(MemorySegment ho) {
        var mh$ = DeleteObject.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DeleteObject", ho);
            }
            return (int)mh$.invokeExact(ho);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DescribePixelFormat {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_INT,
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("DescribePixelFormat"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int DescribePixelFormat(HDC hdc, int iPixelFormat, UINT nBytes, LPPIXELFORMATDESCRIPTOR ppfd)
     * }
     */
    public static FunctionDescriptor DescribePixelFormat$descriptor() {
        return DescribePixelFormat.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int DescribePixelFormat(HDC hdc, int iPixelFormat, UINT nBytes, LPPIXELFORMATDESCRIPTOR ppfd)
     * }
     */
    public static MethodHandle DescribePixelFormat$handle() {
        return DescribePixelFormat.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int DescribePixelFormat(HDC hdc, int iPixelFormat, UINT nBytes, LPPIXELFORMATDESCRIPTOR ppfd)
     * }
     */
    public static int DescribePixelFormat(MemorySegment hdc, int iPixelFormat, int nBytes, MemorySegment ppfd) {
        var mh$ = DescribePixelFormat.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DescribePixelFormat", hdc, iPixelFormat, nBytes, ppfd);
            }
            return (int)mh$.invokeExact(hdc, iPixelFormat, nBytes, ppfd);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DeviceCapabilitiesA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_SHORT,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("DeviceCapabilitiesA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int DeviceCapabilitiesA(LPCSTR pDevice, LPCSTR pPort, WORD fwCapability, LPSTR pOutput, const DEVMODEA *pDevMode)
     * }
     */
    public static FunctionDescriptor DeviceCapabilitiesA$descriptor() {
        return DeviceCapabilitiesA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int DeviceCapabilitiesA(LPCSTR pDevice, LPCSTR pPort, WORD fwCapability, LPSTR pOutput, const DEVMODEA *pDevMode)
     * }
     */
    public static MethodHandle DeviceCapabilitiesA$handle() {
        return DeviceCapabilitiesA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int DeviceCapabilitiesA(LPCSTR pDevice, LPCSTR pPort, WORD fwCapability, LPSTR pOutput, const DEVMODEA *pDevMode)
     * }
     */
    public static int DeviceCapabilitiesA(MemorySegment pDevice, MemorySegment pPort, short fwCapability, MemorySegment pOutput, MemorySegment pDevMode) {
        var mh$ = DeviceCapabilitiesA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DeviceCapabilitiesA", pDevice, pPort, fwCapability, pOutput, pDevMode);
            }
            return (int)mh$.invokeExact(pDevice, pPort, fwCapability, pOutput, pDevMode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DeviceCapabilitiesW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_SHORT,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("DeviceCapabilitiesW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int DeviceCapabilitiesW(LPCWSTR pDevice, LPCWSTR pPort, WORD fwCapability, LPWSTR pOutput, const DEVMODEW *pDevMode)
     * }
     */
    public static FunctionDescriptor DeviceCapabilitiesW$descriptor() {
        return DeviceCapabilitiesW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int DeviceCapabilitiesW(LPCWSTR pDevice, LPCWSTR pPort, WORD fwCapability, LPWSTR pOutput, const DEVMODEW *pDevMode)
     * }
     */
    public static MethodHandle DeviceCapabilitiesW$handle() {
        return DeviceCapabilitiesW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int DeviceCapabilitiesW(LPCWSTR pDevice, LPCWSTR pPort, WORD fwCapability, LPWSTR pOutput, const DEVMODEW *pDevMode)
     * }
     */
    public static int DeviceCapabilitiesW(MemorySegment pDevice, MemorySegment pPort, short fwCapability, MemorySegment pOutput, MemorySegment pDevMode) {
        var mh$ = DeviceCapabilitiesW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DeviceCapabilitiesW", pDevice, pPort, fwCapability, pOutput, pDevMode);
            }
            return (int)mh$.invokeExact(pDevice, pPort, fwCapability, pOutput, pDevMode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DrawEscape {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_INT,
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("DrawEscape"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int DrawEscape(HDC hdc, int iEscape, int cjIn, LPCSTR lpIn)
     * }
     */
    public static FunctionDescriptor DrawEscape$descriptor() {
        return DrawEscape.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int DrawEscape(HDC hdc, int iEscape, int cjIn, LPCSTR lpIn)
     * }
     */
    public static MethodHandle DrawEscape$handle() {
        return DrawEscape.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int DrawEscape(HDC hdc, int iEscape, int cjIn, LPCSTR lpIn)
     * }
     */
    public static int DrawEscape(MemorySegment hdc, int iEscape, int cjIn, MemorySegment lpIn) {
        var mh$ = DrawEscape.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DrawEscape", hdc, iEscape, cjIn, lpIn);
            }
            return (int)mh$.invokeExact(hdc, iEscape, cjIn, lpIn);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Ellipse {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_INT,
            C_INT,
            C_INT,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("Ellipse"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL Ellipse(HDC hdc, int left, int top, int right, int bottom)
     * }
     */
    public static FunctionDescriptor Ellipse$descriptor() {
        return Ellipse.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL Ellipse(HDC hdc, int left, int top, int right, int bottom)
     * }
     */
    public static MethodHandle Ellipse$handle() {
        return Ellipse.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL Ellipse(HDC hdc, int left, int top, int right, int bottom)
     * }
     */
    public static int Ellipse(MemorySegment hdc, int left, int top, int right, int bottom) {
        var mh$ = Ellipse.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Ellipse", hdc, left, top, right, bottom);
            }
            return (int)mh$.invokeExact(hdc, left, top, right, bottom);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class EnumFontFamiliesExA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_LONG_LONG,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("EnumFontFamiliesExA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int EnumFontFamiliesExA(HDC hdc, LPLOGFONTA lpLogfont, FONTENUMPROCA lpProc, LPARAM lParam, DWORD dwFlags)
     * }
     */
    public static FunctionDescriptor EnumFontFamiliesExA$descriptor() {
        return EnumFontFamiliesExA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int EnumFontFamiliesExA(HDC hdc, LPLOGFONTA lpLogfont, FONTENUMPROCA lpProc, LPARAM lParam, DWORD dwFlags)
     * }
     */
    public static MethodHandle EnumFontFamiliesExA$handle() {
        return EnumFontFamiliesExA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int EnumFontFamiliesExA(HDC hdc, LPLOGFONTA lpLogfont, FONTENUMPROCA lpProc, LPARAM lParam, DWORD dwFlags)
     * }
     */
    public static int EnumFontFamiliesExA(MemorySegment hdc, MemorySegment lpLogfont, MemorySegment lpProc, long lParam, int dwFlags) {
        var mh$ = EnumFontFamiliesExA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("EnumFontFamiliesExA", hdc, lpLogfont, lpProc, lParam, dwFlags);
            }
            return (int)mh$.invokeExact(hdc, lpLogfont, lpProc, lParam, dwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class EnumFontFamiliesExW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_LONG_LONG,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("EnumFontFamiliesExW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int EnumFontFamiliesExW(HDC hdc, LPLOGFONTW lpLogfont, FONTENUMPROCW lpProc, LPARAM lParam, DWORD dwFlags)
     * }
     */
    public static FunctionDescriptor EnumFontFamiliesExW$descriptor() {
        return EnumFontFamiliesExW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int EnumFontFamiliesExW(HDC hdc, LPLOGFONTW lpLogfont, FONTENUMPROCW lpProc, LPARAM lParam, DWORD dwFlags)
     * }
     */
    public static MethodHandle EnumFontFamiliesExW$handle() {
        return EnumFontFamiliesExW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int EnumFontFamiliesExW(HDC hdc, LPLOGFONTW lpLogfont, FONTENUMPROCW lpProc, LPARAM lParam, DWORD dwFlags)
     * }
     */
    public static int EnumFontFamiliesExW(MemorySegment hdc, MemorySegment lpLogfont, MemorySegment lpProc, long lParam, int dwFlags) {
        var mh$ = EnumFontFamiliesExW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("EnumFontFamiliesExW", hdc, lpLogfont, lpProc, lParam, dwFlags);
            }
            return (int)mh$.invokeExact(hdc, lpLogfont, lpProc, lParam, dwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class EnumFontFamiliesA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_LONG_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("EnumFontFamiliesA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int EnumFontFamiliesA(HDC hdc, LPCSTR lpLogfont, FONTENUMPROCA lpProc, LPARAM lParam)
     * }
     */
    public static FunctionDescriptor EnumFontFamiliesA$descriptor() {
        return EnumFontFamiliesA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int EnumFontFamiliesA(HDC hdc, LPCSTR lpLogfont, FONTENUMPROCA lpProc, LPARAM lParam)
     * }
     */
    public static MethodHandle EnumFontFamiliesA$handle() {
        return EnumFontFamiliesA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int EnumFontFamiliesA(HDC hdc, LPCSTR lpLogfont, FONTENUMPROCA lpProc, LPARAM lParam)
     * }
     */
    public static int EnumFontFamiliesA(MemorySegment hdc, MemorySegment lpLogfont, MemorySegment lpProc, long lParam) {
        var mh$ = EnumFontFamiliesA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("EnumFontFamiliesA", hdc, lpLogfont, lpProc, lParam);
            }
            return (int)mh$.invokeExact(hdc, lpLogfont, lpProc, lParam);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class EnumFontFamiliesW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_LONG_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("EnumFontFamiliesW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int EnumFontFamiliesW(HDC hdc, LPCWSTR lpLogfont, FONTENUMPROCW lpProc, LPARAM lParam)
     * }
     */
    public static FunctionDescriptor EnumFontFamiliesW$descriptor() {
        return EnumFontFamiliesW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int EnumFontFamiliesW(HDC hdc, LPCWSTR lpLogfont, FONTENUMPROCW lpProc, LPARAM lParam)
     * }
     */
    public static MethodHandle EnumFontFamiliesW$handle() {
        return EnumFontFamiliesW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int EnumFontFamiliesW(HDC hdc, LPCWSTR lpLogfont, FONTENUMPROCW lpProc, LPARAM lParam)
     * }
     */
    public static int EnumFontFamiliesW(MemorySegment hdc, MemorySegment lpLogfont, MemorySegment lpProc, long lParam) {
        var mh$ = EnumFontFamiliesW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("EnumFontFamiliesW", hdc, lpLogfont, lpProc, lParam);
            }
            return (int)mh$.invokeExact(hdc, lpLogfont, lpProc, lParam);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class EnumFontsA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_LONG_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("EnumFontsA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int EnumFontsA(HDC hdc, LPCSTR lpLogfont, FONTENUMPROCA lpProc, LPARAM lParam)
     * }
     */
    public static FunctionDescriptor EnumFontsA$descriptor() {
        return EnumFontsA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int EnumFontsA(HDC hdc, LPCSTR lpLogfont, FONTENUMPROCA lpProc, LPARAM lParam)
     * }
     */
    public static MethodHandle EnumFontsA$handle() {
        return EnumFontsA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int EnumFontsA(HDC hdc, LPCSTR lpLogfont, FONTENUMPROCA lpProc, LPARAM lParam)
     * }
     */
    public static int EnumFontsA(MemorySegment hdc, MemorySegment lpLogfont, MemorySegment lpProc, long lParam) {
        var mh$ = EnumFontsA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("EnumFontsA", hdc, lpLogfont, lpProc, lParam);
            }
            return (int)mh$.invokeExact(hdc, lpLogfont, lpProc, lParam);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class EnumFontsW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_LONG_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("EnumFontsW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int EnumFontsW(HDC hdc, LPCWSTR lpLogfont, FONTENUMPROCW lpProc, LPARAM lParam)
     * }
     */
    public static FunctionDescriptor EnumFontsW$descriptor() {
        return EnumFontsW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int EnumFontsW(HDC hdc, LPCWSTR lpLogfont, FONTENUMPROCW lpProc, LPARAM lParam)
     * }
     */
    public static MethodHandle EnumFontsW$handle() {
        return EnumFontsW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int EnumFontsW(HDC hdc, LPCWSTR lpLogfont, FONTENUMPROCW lpProc, LPARAM lParam)
     * }
     */
    public static int EnumFontsW(MemorySegment hdc, MemorySegment lpLogfont, MemorySegment lpProc, long lParam) {
        var mh$ = EnumFontsW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("EnumFontsW", hdc, lpLogfont, lpProc, lParam);
            }
            return (int)mh$.invokeExact(hdc, lpLogfont, lpProc, lParam);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class EnumObjects {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_INT,
            C_POINTER,
            C_LONG_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("EnumObjects"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int EnumObjects(HDC hdc, int nType, GOBJENUMPROC lpFunc, LPARAM lParam)
     * }
     */
    public static FunctionDescriptor EnumObjects$descriptor() {
        return EnumObjects.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int EnumObjects(HDC hdc, int nType, GOBJENUMPROC lpFunc, LPARAM lParam)
     * }
     */
    public static MethodHandle EnumObjects$handle() {
        return EnumObjects.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int EnumObjects(HDC hdc, int nType, GOBJENUMPROC lpFunc, LPARAM lParam)
     * }
     */
    public static int EnumObjects(MemorySegment hdc, int nType, MemorySegment lpFunc, long lParam) {
        var mh$ = EnumObjects.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("EnumObjects", hdc, nType, lpFunc, lParam);
            }
            return (int)mh$.invokeExact(hdc, nType, lpFunc, lParam);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class EqualRgn {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("EqualRgn"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL EqualRgn(HRGN hrgn1, HRGN hrgn2)
     * }
     */
    public static FunctionDescriptor EqualRgn$descriptor() {
        return EqualRgn.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL EqualRgn(HRGN hrgn1, HRGN hrgn2)
     * }
     */
    public static MethodHandle EqualRgn$handle() {
        return EqualRgn.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL EqualRgn(HRGN hrgn1, HRGN hrgn2)
     * }
     */
    public static int EqualRgn(MemorySegment hrgn1, MemorySegment hrgn2) {
        var mh$ = EqualRgn.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("EqualRgn", hrgn1, hrgn2);
            }
            return (int)mh$.invokeExact(hrgn1, hrgn2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Escape {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_INT,
            C_INT,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("Escape"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int Escape(HDC hdc, int iEscape, int cjIn, LPCSTR pvIn, LPVOID pvOut)
     * }
     */
    public static FunctionDescriptor Escape$descriptor() {
        return Escape.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int Escape(HDC hdc, int iEscape, int cjIn, LPCSTR pvIn, LPVOID pvOut)
     * }
     */
    public static MethodHandle Escape$handle() {
        return Escape.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int Escape(HDC hdc, int iEscape, int cjIn, LPCSTR pvIn, LPVOID pvOut)
     * }
     */
    public static int Escape(MemorySegment hdc, int iEscape, int cjIn, MemorySegment pvIn, MemorySegment pvOut) {
        var mh$ = Escape.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Escape", hdc, iEscape, cjIn, pvIn, pvOut);
            }
            return (int)mh$.invokeExact(hdc, iEscape, cjIn, pvIn, pvOut);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ExtEscape {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_INT,
            C_INT,
            C_POINTER,
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("ExtEscape"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int ExtEscape(HDC hdc, int iEscape, int cjInput, LPCSTR lpInData, int cjOutput, LPSTR lpOutData)
     * }
     */
    public static FunctionDescriptor ExtEscape$descriptor() {
        return ExtEscape.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int ExtEscape(HDC hdc, int iEscape, int cjInput, LPCSTR lpInData, int cjOutput, LPSTR lpOutData)
     * }
     */
    public static MethodHandle ExtEscape$handle() {
        return ExtEscape.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int ExtEscape(HDC hdc, int iEscape, int cjInput, LPCSTR lpInData, int cjOutput, LPSTR lpOutData)
     * }
     */
    public static int ExtEscape(MemorySegment hdc, int iEscape, int cjInput, MemorySegment lpInData, int cjOutput, MemorySegment lpOutData) {
        var mh$ = ExtEscape.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ExtEscape", hdc, iEscape, cjInput, lpInData, cjOutput, lpOutData);
            }
            return (int)mh$.invokeExact(hdc, iEscape, cjInput, lpInData, cjOutput, lpOutData);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ExcludeClipRect {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_INT,
            C_INT,
            C_INT,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("ExcludeClipRect"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int ExcludeClipRect(HDC hdc, int left, int top, int right, int bottom)
     * }
     */
    public static FunctionDescriptor ExcludeClipRect$descriptor() {
        return ExcludeClipRect.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int ExcludeClipRect(HDC hdc, int left, int top, int right, int bottom)
     * }
     */
    public static MethodHandle ExcludeClipRect$handle() {
        return ExcludeClipRect.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int ExcludeClipRect(HDC hdc, int left, int top, int right, int bottom)
     * }
     */
    public static int ExcludeClipRect(MemorySegment hdc, int left, int top, int right, int bottom) {
        var mh$ = ExcludeClipRect.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ExcludeClipRect", hdc, left, top, right, bottom);
            }
            return (int)mh$.invokeExact(hdc, left, top, right, bottom);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ExtCreateRegion {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER,
            C_LONG,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("ExtCreateRegion"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HRGN ExtCreateRegion(const XFORM *lpx, DWORD nCount, const RGNDATA *lpData)
     * }
     */
    public static FunctionDescriptor ExtCreateRegion$descriptor() {
        return ExtCreateRegion.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HRGN ExtCreateRegion(const XFORM *lpx, DWORD nCount, const RGNDATA *lpData)
     * }
     */
    public static MethodHandle ExtCreateRegion$handle() {
        return ExtCreateRegion.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * HRGN ExtCreateRegion(const XFORM *lpx, DWORD nCount, const RGNDATA *lpData)
     * }
     */
    public static MemorySegment ExtCreateRegion(MemorySegment lpx, int nCount, MemorySegment lpData) {
        var mh$ = ExtCreateRegion.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ExtCreateRegion", lpx, nCount, lpData);
            }
            return (MemorySegment)mh$.invokeExact(lpx, nCount, lpData);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ExtFloodFill {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_INT,
            C_INT,
            C_LONG,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("ExtFloodFill"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL ExtFloodFill(HDC hdc, int x, int y, COLORREF color, UINT type)
     * }
     */
    public static FunctionDescriptor ExtFloodFill$descriptor() {
        return ExtFloodFill.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL ExtFloodFill(HDC hdc, int x, int y, COLORREF color, UINT type)
     * }
     */
    public static MethodHandle ExtFloodFill$handle() {
        return ExtFloodFill.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL ExtFloodFill(HDC hdc, int x, int y, COLORREF color, UINT type)
     * }
     */
    public static int ExtFloodFill(MemorySegment hdc, int x, int y, int color, int type) {
        var mh$ = ExtFloodFill.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ExtFloodFill", hdc, x, y, color, type);
            }
            return (int)mh$.invokeExact(hdc, x, y, color, type);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FillRgn {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("FillRgn"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL FillRgn(HDC hdc, HRGN hrgn, HBRUSH hbr)
     * }
     */
    public static FunctionDescriptor FillRgn$descriptor() {
        return FillRgn.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL FillRgn(HDC hdc, HRGN hrgn, HBRUSH hbr)
     * }
     */
    public static MethodHandle FillRgn$handle() {
        return FillRgn.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL FillRgn(HDC hdc, HRGN hrgn, HBRUSH hbr)
     * }
     */
    public static int FillRgn(MemorySegment hdc, MemorySegment hrgn, MemorySegment hbr) {
        var mh$ = FillRgn.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FillRgn", hdc, hrgn, hbr);
            }
            return (int)mh$.invokeExact(hdc, hrgn, hbr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FloodFill {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_INT,
            C_INT,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("FloodFill"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL FloodFill(HDC hdc, int x, int y, COLORREF color)
     * }
     */
    public static FunctionDescriptor FloodFill$descriptor() {
        return FloodFill.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL FloodFill(HDC hdc, int x, int y, COLORREF color)
     * }
     */
    public static MethodHandle FloodFill$handle() {
        return FloodFill.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL FloodFill(HDC hdc, int x, int y, COLORREF color)
     * }
     */
    public static int FloodFill(MemorySegment hdc, int x, int y, int color) {
        var mh$ = FloodFill.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FloodFill", hdc, x, y, color);
            }
            return (int)mh$.invokeExact(hdc, x, y, color);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FrameRgn {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_INT,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("FrameRgn"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL FrameRgn(HDC hdc, HRGN hrgn, HBRUSH hbr, int w, int h)
     * }
     */
    public static FunctionDescriptor FrameRgn$descriptor() {
        return FrameRgn.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL FrameRgn(HDC hdc, HRGN hrgn, HBRUSH hbr, int w, int h)
     * }
     */
    public static MethodHandle FrameRgn$handle() {
        return FrameRgn.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL FrameRgn(HDC hdc, HRGN hrgn, HBRUSH hbr, int w, int h)
     * }
     */
    public static int FrameRgn(MemorySegment hdc, MemorySegment hrgn, MemorySegment hbr, int w, int h) {
        var mh$ = FrameRgn.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FrameRgn", hdc, hrgn, hbr, w, h);
            }
            return (int)mh$.invokeExact(hdc, hrgn, hbr, w, h);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetROP2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetROP2"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int GetROP2(HDC hdc)
     * }
     */
    public static FunctionDescriptor GetROP2$descriptor() {
        return GetROP2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int GetROP2(HDC hdc)
     * }
     */
    public static MethodHandle GetROP2$handle() {
        return GetROP2.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int GetROP2(HDC hdc)
     * }
     */
    public static int GetROP2(MemorySegment hdc) {
        var mh$ = GetROP2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetROP2", hdc);
            }
            return (int)mh$.invokeExact(hdc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetAspectRatioFilterEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetAspectRatioFilterEx"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetAspectRatioFilterEx(HDC hdc, LPSIZE lpsize)
     * }
     */
    public static FunctionDescriptor GetAspectRatioFilterEx$descriptor() {
        return GetAspectRatioFilterEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetAspectRatioFilterEx(HDC hdc, LPSIZE lpsize)
     * }
     */
    public static MethodHandle GetAspectRatioFilterEx$handle() {
        return GetAspectRatioFilterEx.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL GetAspectRatioFilterEx(HDC hdc, LPSIZE lpsize)
     * }
     */
    public static int GetAspectRatioFilterEx(MemorySegment hdc, MemorySegment lpsize) {
        var mh$ = GetAspectRatioFilterEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetAspectRatioFilterEx", hdc, lpsize);
            }
            return (int)mh$.invokeExact(hdc, lpsize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetBkColor {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetBkColor"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * COLORREF GetBkColor(HDC hdc)
     * }
     */
    public static FunctionDescriptor GetBkColor$descriptor() {
        return GetBkColor.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * COLORREF GetBkColor(HDC hdc)
     * }
     */
    public static MethodHandle GetBkColor$handle() {
        return GetBkColor.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * COLORREF GetBkColor(HDC hdc)
     * }
     */
    public static int GetBkColor(MemorySegment hdc) {
        var mh$ = GetBkColor.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetBkColor", hdc);
            }
            return (int)mh$.invokeExact(hdc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetDCBrushColor {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetDCBrushColor"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * COLORREF GetDCBrushColor(HDC hdc)
     * }
     */
    public static FunctionDescriptor GetDCBrushColor$descriptor() {
        return GetDCBrushColor.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * COLORREF GetDCBrushColor(HDC hdc)
     * }
     */
    public static MethodHandle GetDCBrushColor$handle() {
        return GetDCBrushColor.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * COLORREF GetDCBrushColor(HDC hdc)
     * }
     */
    public static int GetDCBrushColor(MemorySegment hdc) {
        var mh$ = GetDCBrushColor.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetDCBrushColor", hdc);
            }
            return (int)mh$.invokeExact(hdc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetDCPenColor {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetDCPenColor"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * COLORREF GetDCPenColor(HDC hdc)
     * }
     */
    public static FunctionDescriptor GetDCPenColor$descriptor() {
        return GetDCPenColor.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * COLORREF GetDCPenColor(HDC hdc)
     * }
     */
    public static MethodHandle GetDCPenColor$handle() {
        return GetDCPenColor.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * COLORREF GetDCPenColor(HDC hdc)
     * }
     */
    public static int GetDCPenColor(MemorySegment hdc) {
        var mh$ = GetDCPenColor.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetDCPenColor", hdc);
            }
            return (int)mh$.invokeExact(hdc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetBkMode {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetBkMode"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int GetBkMode(HDC hdc)
     * }
     */
    public static FunctionDescriptor GetBkMode$descriptor() {
        return GetBkMode.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int GetBkMode(HDC hdc)
     * }
     */
    public static MethodHandle GetBkMode$handle() {
        return GetBkMode.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int GetBkMode(HDC hdc)
     * }
     */
    public static int GetBkMode(MemorySegment hdc) {
        var mh$ = GetBkMode.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetBkMode", hdc);
            }
            return (int)mh$.invokeExact(hdc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetBitmapBits {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_POINTER,
            C_LONG,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetBitmapBits"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LONG GetBitmapBits(HBITMAP hbit, LONG cb, LPVOID lpvBits)
     * }
     */
    public static FunctionDescriptor GetBitmapBits$descriptor() {
        return GetBitmapBits.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LONG GetBitmapBits(HBITMAP hbit, LONG cb, LPVOID lpvBits)
     * }
     */
    public static MethodHandle GetBitmapBits$handle() {
        return GetBitmapBits.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * LONG GetBitmapBits(HBITMAP hbit, LONG cb, LPVOID lpvBits)
     * }
     */
    public static int GetBitmapBits(MemorySegment hbit, int cb, MemorySegment lpvBits) {
        var mh$ = GetBitmapBits.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetBitmapBits", hbit, cb, lpvBits);
            }
            return (int)mh$.invokeExact(hbit, cb, lpvBits);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetBitmapDimensionEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetBitmapDimensionEx"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetBitmapDimensionEx(HBITMAP hbit, LPSIZE lpsize)
     * }
     */
    public static FunctionDescriptor GetBitmapDimensionEx$descriptor() {
        return GetBitmapDimensionEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetBitmapDimensionEx(HBITMAP hbit, LPSIZE lpsize)
     * }
     */
    public static MethodHandle GetBitmapDimensionEx$handle() {
        return GetBitmapDimensionEx.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL GetBitmapDimensionEx(HBITMAP hbit, LPSIZE lpsize)
     * }
     */
    public static int GetBitmapDimensionEx(MemorySegment hbit, MemorySegment lpsize) {
        var mh$ = GetBitmapDimensionEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetBitmapDimensionEx", hbit, lpsize);
            }
            return (int)mh$.invokeExact(hbit, lpsize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetBoundsRect {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetBoundsRect"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * UINT GetBoundsRect(HDC hdc, LPRECT lprect, UINT flags)
     * }
     */
    public static FunctionDescriptor GetBoundsRect$descriptor() {
        return GetBoundsRect.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * UINT GetBoundsRect(HDC hdc, LPRECT lprect, UINT flags)
     * }
     */
    public static MethodHandle GetBoundsRect$handle() {
        return GetBoundsRect.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * UINT GetBoundsRect(HDC hdc, LPRECT lprect, UINT flags)
     * }
     */
    public static int GetBoundsRect(MemorySegment hdc, MemorySegment lprect, int flags) {
        var mh$ = GetBoundsRect.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetBoundsRect", hdc, lprect, flags);
            }
            return (int)mh$.invokeExact(hdc, lprect, flags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetBrushOrgEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetBrushOrgEx"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetBrushOrgEx(HDC hdc, LPPOINT lppt)
     * }
     */
    public static FunctionDescriptor GetBrushOrgEx$descriptor() {
        return GetBrushOrgEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetBrushOrgEx(HDC hdc, LPPOINT lppt)
     * }
     */
    public static MethodHandle GetBrushOrgEx$handle() {
        return GetBrushOrgEx.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL GetBrushOrgEx(HDC hdc, LPPOINT lppt)
     * }
     */
    public static int GetBrushOrgEx(MemorySegment hdc, MemorySegment lppt) {
        var mh$ = GetBrushOrgEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetBrushOrgEx", hdc, lppt);
            }
            return (int)mh$.invokeExact(hdc, lppt);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetCharWidthA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_INT,
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetCharWidthA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetCharWidthA(HDC hdc, UINT iFirst, UINT iLast, LPINT lpBuffer)
     * }
     */
    public static FunctionDescriptor GetCharWidthA$descriptor() {
        return GetCharWidthA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetCharWidthA(HDC hdc, UINT iFirst, UINT iLast, LPINT lpBuffer)
     * }
     */
    public static MethodHandle GetCharWidthA$handle() {
        return GetCharWidthA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL GetCharWidthA(HDC hdc, UINT iFirst, UINT iLast, LPINT lpBuffer)
     * }
     */
    public static int GetCharWidthA(MemorySegment hdc, int iFirst, int iLast, MemorySegment lpBuffer) {
        var mh$ = GetCharWidthA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetCharWidthA", hdc, iFirst, iLast, lpBuffer);
            }
            return (int)mh$.invokeExact(hdc, iFirst, iLast, lpBuffer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetCharWidthW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_INT,
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetCharWidthW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetCharWidthW(HDC hdc, UINT iFirst, UINT iLast, LPINT lpBuffer)
     * }
     */
    public static FunctionDescriptor GetCharWidthW$descriptor() {
        return GetCharWidthW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetCharWidthW(HDC hdc, UINT iFirst, UINT iLast, LPINT lpBuffer)
     * }
     */
    public static MethodHandle GetCharWidthW$handle() {
        return GetCharWidthW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL GetCharWidthW(HDC hdc, UINT iFirst, UINT iLast, LPINT lpBuffer)
     * }
     */
    public static int GetCharWidthW(MemorySegment hdc, int iFirst, int iLast, MemorySegment lpBuffer) {
        var mh$ = GetCharWidthW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetCharWidthW", hdc, iFirst, iLast, lpBuffer);
            }
            return (int)mh$.invokeExact(hdc, iFirst, iLast, lpBuffer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetCharWidth32A {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_INT,
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetCharWidth32A"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetCharWidth32A(HDC hdc, UINT iFirst, UINT iLast, LPINT lpBuffer)
     * }
     */
    public static FunctionDescriptor GetCharWidth32A$descriptor() {
        return GetCharWidth32A.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetCharWidth32A(HDC hdc, UINT iFirst, UINT iLast, LPINT lpBuffer)
     * }
     */
    public static MethodHandle GetCharWidth32A$handle() {
        return GetCharWidth32A.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL GetCharWidth32A(HDC hdc, UINT iFirst, UINT iLast, LPINT lpBuffer)
     * }
     */
    public static int GetCharWidth32A(MemorySegment hdc, int iFirst, int iLast, MemorySegment lpBuffer) {
        var mh$ = GetCharWidth32A.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetCharWidth32A", hdc, iFirst, iLast, lpBuffer);
            }
            return (int)mh$.invokeExact(hdc, iFirst, iLast, lpBuffer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetCharWidth32W {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_INT,
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetCharWidth32W"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetCharWidth32W(HDC hdc, UINT iFirst, UINT iLast, LPINT lpBuffer)
     * }
     */
    public static FunctionDescriptor GetCharWidth32W$descriptor() {
        return GetCharWidth32W.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetCharWidth32W(HDC hdc, UINT iFirst, UINT iLast, LPINT lpBuffer)
     * }
     */
    public static MethodHandle GetCharWidth32W$handle() {
        return GetCharWidth32W.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL GetCharWidth32W(HDC hdc, UINT iFirst, UINT iLast, LPINT lpBuffer)
     * }
     */
    public static int GetCharWidth32W(MemorySegment hdc, int iFirst, int iLast, MemorySegment lpBuffer) {
        var mh$ = GetCharWidth32W.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetCharWidth32W", hdc, iFirst, iLast, lpBuffer);
            }
            return (int)mh$.invokeExact(hdc, iFirst, iLast, lpBuffer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetCharWidthFloatA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_INT,
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetCharWidthFloatA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetCharWidthFloatA(HDC hdc, UINT iFirst, UINT iLast, PFLOAT lpBuffer)
     * }
     */
    public static FunctionDescriptor GetCharWidthFloatA$descriptor() {
        return GetCharWidthFloatA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetCharWidthFloatA(HDC hdc, UINT iFirst, UINT iLast, PFLOAT lpBuffer)
     * }
     */
    public static MethodHandle GetCharWidthFloatA$handle() {
        return GetCharWidthFloatA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL GetCharWidthFloatA(HDC hdc, UINT iFirst, UINT iLast, PFLOAT lpBuffer)
     * }
     */
    public static int GetCharWidthFloatA(MemorySegment hdc, int iFirst, int iLast, MemorySegment lpBuffer) {
        var mh$ = GetCharWidthFloatA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetCharWidthFloatA", hdc, iFirst, iLast, lpBuffer);
            }
            return (int)mh$.invokeExact(hdc, iFirst, iLast, lpBuffer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetCharWidthFloatW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_INT,
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetCharWidthFloatW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetCharWidthFloatW(HDC hdc, UINT iFirst, UINT iLast, PFLOAT lpBuffer)
     * }
     */
    public static FunctionDescriptor GetCharWidthFloatW$descriptor() {
        return GetCharWidthFloatW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetCharWidthFloatW(HDC hdc, UINT iFirst, UINT iLast, PFLOAT lpBuffer)
     * }
     */
    public static MethodHandle GetCharWidthFloatW$handle() {
        return GetCharWidthFloatW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL GetCharWidthFloatW(HDC hdc, UINT iFirst, UINT iLast, PFLOAT lpBuffer)
     * }
     */
    public static int GetCharWidthFloatW(MemorySegment hdc, int iFirst, int iLast, MemorySegment lpBuffer) {
        var mh$ = GetCharWidthFloatW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetCharWidthFloatW", hdc, iFirst, iLast, lpBuffer);
            }
            return (int)mh$.invokeExact(hdc, iFirst, iLast, lpBuffer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetCharABCWidthsA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_INT,
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetCharABCWidthsA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetCharABCWidthsA(HDC hdc, UINT wFirst, UINT wLast, LPABC lpABC)
     * }
     */
    public static FunctionDescriptor GetCharABCWidthsA$descriptor() {
        return GetCharABCWidthsA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetCharABCWidthsA(HDC hdc, UINT wFirst, UINT wLast, LPABC lpABC)
     * }
     */
    public static MethodHandle GetCharABCWidthsA$handle() {
        return GetCharABCWidthsA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL GetCharABCWidthsA(HDC hdc, UINT wFirst, UINT wLast, LPABC lpABC)
     * }
     */
    public static int GetCharABCWidthsA(MemorySegment hdc, int wFirst, int wLast, MemorySegment lpABC) {
        var mh$ = GetCharABCWidthsA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetCharABCWidthsA", hdc, wFirst, wLast, lpABC);
            }
            return (int)mh$.invokeExact(hdc, wFirst, wLast, lpABC);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetCharABCWidthsW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_INT,
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetCharABCWidthsW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetCharABCWidthsW(HDC hdc, UINT wFirst, UINT wLast, LPABC lpABC)
     * }
     */
    public static FunctionDescriptor GetCharABCWidthsW$descriptor() {
        return GetCharABCWidthsW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetCharABCWidthsW(HDC hdc, UINT wFirst, UINT wLast, LPABC lpABC)
     * }
     */
    public static MethodHandle GetCharABCWidthsW$handle() {
        return GetCharABCWidthsW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL GetCharABCWidthsW(HDC hdc, UINT wFirst, UINT wLast, LPABC lpABC)
     * }
     */
    public static int GetCharABCWidthsW(MemorySegment hdc, int wFirst, int wLast, MemorySegment lpABC) {
        var mh$ = GetCharABCWidthsW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetCharABCWidthsW", hdc, wFirst, wLast, lpABC);
            }
            return (int)mh$.invokeExact(hdc, wFirst, wLast, lpABC);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetCharABCWidthsFloatA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_INT,
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetCharABCWidthsFloatA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetCharABCWidthsFloatA(HDC hdc, UINT iFirst, UINT iLast, LPABCFLOAT lpABC)
     * }
     */
    public static FunctionDescriptor GetCharABCWidthsFloatA$descriptor() {
        return GetCharABCWidthsFloatA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetCharABCWidthsFloatA(HDC hdc, UINT iFirst, UINT iLast, LPABCFLOAT lpABC)
     * }
     */
    public static MethodHandle GetCharABCWidthsFloatA$handle() {
        return GetCharABCWidthsFloatA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL GetCharABCWidthsFloatA(HDC hdc, UINT iFirst, UINT iLast, LPABCFLOAT lpABC)
     * }
     */
    public static int GetCharABCWidthsFloatA(MemorySegment hdc, int iFirst, int iLast, MemorySegment lpABC) {
        var mh$ = GetCharABCWidthsFloatA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetCharABCWidthsFloatA", hdc, iFirst, iLast, lpABC);
            }
            return (int)mh$.invokeExact(hdc, iFirst, iLast, lpABC);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetCharABCWidthsFloatW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_INT,
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetCharABCWidthsFloatW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetCharABCWidthsFloatW(HDC hdc, UINT iFirst, UINT iLast, LPABCFLOAT lpABC)
     * }
     */
    public static FunctionDescriptor GetCharABCWidthsFloatW$descriptor() {
        return GetCharABCWidthsFloatW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetCharABCWidthsFloatW(HDC hdc, UINT iFirst, UINT iLast, LPABCFLOAT lpABC)
     * }
     */
    public static MethodHandle GetCharABCWidthsFloatW$handle() {
        return GetCharABCWidthsFloatW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL GetCharABCWidthsFloatW(HDC hdc, UINT iFirst, UINT iLast, LPABCFLOAT lpABC)
     * }
     */
    public static int GetCharABCWidthsFloatW(MemorySegment hdc, int iFirst, int iLast, MemorySegment lpABC) {
        var mh$ = GetCharABCWidthsFloatW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetCharABCWidthsFloatW", hdc, iFirst, iLast, lpABC);
            }
            return (int)mh$.invokeExact(hdc, iFirst, iLast, lpABC);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetClipBox {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetClipBox"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int GetClipBox(HDC hdc, LPRECT lprect)
     * }
     */
    public static FunctionDescriptor GetClipBox$descriptor() {
        return GetClipBox.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int GetClipBox(HDC hdc, LPRECT lprect)
     * }
     */
    public static MethodHandle GetClipBox$handle() {
        return GetClipBox.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int GetClipBox(HDC hdc, LPRECT lprect)
     * }
     */
    public static int GetClipBox(MemorySegment hdc, MemorySegment lprect) {
        var mh$ = GetClipBox.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetClipBox", hdc, lprect);
            }
            return (int)mh$.invokeExact(hdc, lprect);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetClipRgn {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetClipRgn"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int GetClipRgn(HDC hdc, HRGN hrgn)
     * }
     */
    public static FunctionDescriptor GetClipRgn$descriptor() {
        return GetClipRgn.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int GetClipRgn(HDC hdc, HRGN hrgn)
     * }
     */
    public static MethodHandle GetClipRgn$handle() {
        return GetClipRgn.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int GetClipRgn(HDC hdc, HRGN hrgn)
     * }
     */
    public static int GetClipRgn(MemorySegment hdc, MemorySegment hrgn) {
        var mh$ = GetClipRgn.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetClipRgn", hdc, hrgn);
            }
            return (int)mh$.invokeExact(hdc, hrgn);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetMetaRgn {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetMetaRgn"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int GetMetaRgn(HDC hdc, HRGN hrgn)
     * }
     */
    public static FunctionDescriptor GetMetaRgn$descriptor() {
        return GetMetaRgn.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int GetMetaRgn(HDC hdc, HRGN hrgn)
     * }
     */
    public static MethodHandle GetMetaRgn$handle() {
        return GetMetaRgn.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int GetMetaRgn(HDC hdc, HRGN hrgn)
     * }
     */
    public static int GetMetaRgn(MemorySegment hdc, MemorySegment hrgn) {
        var mh$ = GetMetaRgn.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetMetaRgn", hdc, hrgn);
            }
            return (int)mh$.invokeExact(hdc, hrgn);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetCurrentObject {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetCurrentObject"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HGDIOBJ GetCurrentObject(HDC hdc, UINT type)
     * }
     */
    public static FunctionDescriptor GetCurrentObject$descriptor() {
        return GetCurrentObject.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HGDIOBJ GetCurrentObject(HDC hdc, UINT type)
     * }
     */
    public static MethodHandle GetCurrentObject$handle() {
        return GetCurrentObject.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * HGDIOBJ GetCurrentObject(HDC hdc, UINT type)
     * }
     */
    public static MemorySegment GetCurrentObject(MemorySegment hdc, int type) {
        var mh$ = GetCurrentObject.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetCurrentObject", hdc, type);
            }
            return (MemorySegment)mh$.invokeExact(hdc, type);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetCurrentPositionEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetCurrentPositionEx"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetCurrentPositionEx(HDC hdc, LPPOINT lppt)
     * }
     */
    public static FunctionDescriptor GetCurrentPositionEx$descriptor() {
        return GetCurrentPositionEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetCurrentPositionEx(HDC hdc, LPPOINT lppt)
     * }
     */
    public static MethodHandle GetCurrentPositionEx$handle() {
        return GetCurrentPositionEx.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL GetCurrentPositionEx(HDC hdc, LPPOINT lppt)
     * }
     */
    public static int GetCurrentPositionEx(MemorySegment hdc, MemorySegment lppt) {
        var mh$ = GetCurrentPositionEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetCurrentPositionEx", hdc, lppt);
            }
            return (int)mh$.invokeExact(hdc, lppt);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetDeviceCaps {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetDeviceCaps"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int GetDeviceCaps(HDC hdc, int index)
     * }
     */
    public static FunctionDescriptor GetDeviceCaps$descriptor() {
        return GetDeviceCaps.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int GetDeviceCaps(HDC hdc, int index)
     * }
     */
    public static MethodHandle GetDeviceCaps$handle() {
        return GetDeviceCaps.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int GetDeviceCaps(HDC hdc, int index)
     * }
     */
    public static int GetDeviceCaps(MemorySegment hdc, int index) {
        var mh$ = GetDeviceCaps.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetDeviceCaps", hdc, index);
            }
            return (int)mh$.invokeExact(hdc, index);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetDIBits {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_INT,
            C_INT,
            C_POINTER,
            C_POINTER,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetDIBits"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int GetDIBits(HDC hdc, HBITMAP hbm, UINT start, UINT cLines, LPVOID lpvBits, LPBITMAPINFO lpbmi, UINT usage)
     * }
     */
    public static FunctionDescriptor GetDIBits$descriptor() {
        return GetDIBits.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int GetDIBits(HDC hdc, HBITMAP hbm, UINT start, UINT cLines, LPVOID lpvBits, LPBITMAPINFO lpbmi, UINT usage)
     * }
     */
    public static MethodHandle GetDIBits$handle() {
        return GetDIBits.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int GetDIBits(HDC hdc, HBITMAP hbm, UINT start, UINT cLines, LPVOID lpvBits, LPBITMAPINFO lpbmi, UINT usage)
     * }
     */
    public static int GetDIBits(MemorySegment hdc, MemorySegment hbm, int start, int cLines, MemorySegment lpvBits, MemorySegment lpbmi, int usage) {
        var mh$ = GetDIBits.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetDIBits", hdc, hbm, start, cLines, lpvBits, lpbmi, usage);
            }
            return (int)mh$.invokeExact(hdc, hbm, start, cLines, lpvBits, lpbmi, usage);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetFontData {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_POINTER,
            C_LONG,
            C_LONG,
            C_POINTER,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetFontData"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetFontData(HDC hdc, DWORD dwTable, DWORD dwOffset, PVOID pvBuffer, DWORD cjBuffer)
     * }
     */
    public static FunctionDescriptor GetFontData$descriptor() {
        return GetFontData.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetFontData(HDC hdc, DWORD dwTable, DWORD dwOffset, PVOID pvBuffer, DWORD cjBuffer)
     * }
     */
    public static MethodHandle GetFontData$handle() {
        return GetFontData.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * DWORD GetFontData(HDC hdc, DWORD dwTable, DWORD dwOffset, PVOID pvBuffer, DWORD cjBuffer)
     * }
     */
    public static int GetFontData(MemorySegment hdc, int dwTable, int dwOffset, MemorySegment pvBuffer, int cjBuffer) {
        var mh$ = GetFontData.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetFontData", hdc, dwTable, dwOffset, pvBuffer, cjBuffer);
            }
            return (int)mh$.invokeExact(hdc, dwTable, dwOffset, pvBuffer, cjBuffer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetGlyphOutlineA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_POINTER,
            C_INT,
            C_INT,
            C_POINTER,
            C_LONG,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetGlyphOutlineA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetGlyphOutlineA(HDC hdc, UINT uChar, UINT fuFormat, LPGLYPHMETRICS lpgm, DWORD cjBuffer, LPVOID pvBuffer, const MAT2 *lpmat2)
     * }
     */
    public static FunctionDescriptor GetGlyphOutlineA$descriptor() {
        return GetGlyphOutlineA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetGlyphOutlineA(HDC hdc, UINT uChar, UINT fuFormat, LPGLYPHMETRICS lpgm, DWORD cjBuffer, LPVOID pvBuffer, const MAT2 *lpmat2)
     * }
     */
    public static MethodHandle GetGlyphOutlineA$handle() {
        return GetGlyphOutlineA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * DWORD GetGlyphOutlineA(HDC hdc, UINT uChar, UINT fuFormat, LPGLYPHMETRICS lpgm, DWORD cjBuffer, LPVOID pvBuffer, const MAT2 *lpmat2)
     * }
     */
    public static int GetGlyphOutlineA(MemorySegment hdc, int uChar, int fuFormat, MemorySegment lpgm, int cjBuffer, MemorySegment pvBuffer, MemorySegment lpmat2) {
        var mh$ = GetGlyphOutlineA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetGlyphOutlineA", hdc, uChar, fuFormat, lpgm, cjBuffer, pvBuffer, lpmat2);
            }
            return (int)mh$.invokeExact(hdc, uChar, fuFormat, lpgm, cjBuffer, pvBuffer, lpmat2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetGlyphOutlineW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_POINTER,
            C_INT,
            C_INT,
            C_POINTER,
            C_LONG,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetGlyphOutlineW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetGlyphOutlineW(HDC hdc, UINT uChar, UINT fuFormat, LPGLYPHMETRICS lpgm, DWORD cjBuffer, LPVOID pvBuffer, const MAT2 *lpmat2)
     * }
     */
    public static FunctionDescriptor GetGlyphOutlineW$descriptor() {
        return GetGlyphOutlineW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetGlyphOutlineW(HDC hdc, UINT uChar, UINT fuFormat, LPGLYPHMETRICS lpgm, DWORD cjBuffer, LPVOID pvBuffer, const MAT2 *lpmat2)
     * }
     */
    public static MethodHandle GetGlyphOutlineW$handle() {
        return GetGlyphOutlineW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * DWORD GetGlyphOutlineW(HDC hdc, UINT uChar, UINT fuFormat, LPGLYPHMETRICS lpgm, DWORD cjBuffer, LPVOID pvBuffer, const MAT2 *lpmat2)
     * }
     */
    public static int GetGlyphOutlineW(MemorySegment hdc, int uChar, int fuFormat, MemorySegment lpgm, int cjBuffer, MemorySegment pvBuffer, MemorySegment lpmat2) {
        var mh$ = GetGlyphOutlineW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetGlyphOutlineW", hdc, uChar, fuFormat, lpgm, cjBuffer, pvBuffer, lpmat2);
            }
            return (int)mh$.invokeExact(hdc, uChar, fuFormat, lpgm, cjBuffer, pvBuffer, lpmat2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetGraphicsMode {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetGraphicsMode"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int GetGraphicsMode(HDC hdc)
     * }
     */
    public static FunctionDescriptor GetGraphicsMode$descriptor() {
        return GetGraphicsMode.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int GetGraphicsMode(HDC hdc)
     * }
     */
    public static MethodHandle GetGraphicsMode$handle() {
        return GetGraphicsMode.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int GetGraphicsMode(HDC hdc)
     * }
     */
    public static int GetGraphicsMode(MemorySegment hdc) {
        var mh$ = GetGraphicsMode.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetGraphicsMode", hdc);
            }
            return (int)mh$.invokeExact(hdc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetMapMode {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetMapMode"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int GetMapMode(HDC hdc)
     * }
     */
    public static FunctionDescriptor GetMapMode$descriptor() {
        return GetMapMode.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int GetMapMode(HDC hdc)
     * }
     */
    public static MethodHandle GetMapMode$handle() {
        return GetMapMode.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int GetMapMode(HDC hdc)
     * }
     */
    public static int GetMapMode(MemorySegment hdc) {
        var mh$ = GetMapMode.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetMapMode", hdc);
            }
            return (int)mh$.invokeExact(hdc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetMetaFileBitsEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetMetaFileBitsEx"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * UINT GetMetaFileBitsEx(HMETAFILE hMF, UINT cbBuffer, LPVOID lpData)
     * }
     */
    public static FunctionDescriptor GetMetaFileBitsEx$descriptor() {
        return GetMetaFileBitsEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * UINT GetMetaFileBitsEx(HMETAFILE hMF, UINT cbBuffer, LPVOID lpData)
     * }
     */
    public static MethodHandle GetMetaFileBitsEx$handle() {
        return GetMetaFileBitsEx.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * UINT GetMetaFileBitsEx(HMETAFILE hMF, UINT cbBuffer, LPVOID lpData)
     * }
     */
    public static int GetMetaFileBitsEx(MemorySegment hMF, int cbBuffer, MemorySegment lpData) {
        var mh$ = GetMetaFileBitsEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetMetaFileBitsEx", hMF, cbBuffer, lpData);
            }
            return (int)mh$.invokeExact(hMF, cbBuffer, lpData);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetMetaFileA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetMetaFileA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HMETAFILE GetMetaFileA(LPCSTR lpName)
     * }
     */
    public static FunctionDescriptor GetMetaFileA$descriptor() {
        return GetMetaFileA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HMETAFILE GetMetaFileA(LPCSTR lpName)
     * }
     */
    public static MethodHandle GetMetaFileA$handle() {
        return GetMetaFileA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * HMETAFILE GetMetaFileA(LPCSTR lpName)
     * }
     */
    public static MemorySegment GetMetaFileA(MemorySegment lpName) {
        var mh$ = GetMetaFileA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetMetaFileA", lpName);
            }
            return (MemorySegment)mh$.invokeExact(lpName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetMetaFileW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetMetaFileW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HMETAFILE GetMetaFileW(LPCWSTR lpName)
     * }
     */
    public static FunctionDescriptor GetMetaFileW$descriptor() {
        return GetMetaFileW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HMETAFILE GetMetaFileW(LPCWSTR lpName)
     * }
     */
    public static MethodHandle GetMetaFileW$handle() {
        return GetMetaFileW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * HMETAFILE GetMetaFileW(LPCWSTR lpName)
     * }
     */
    public static MemorySegment GetMetaFileW(MemorySegment lpName) {
        var mh$ = GetMetaFileW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetMetaFileW", lpName);
            }
            return (MemorySegment)mh$.invokeExact(lpName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetNearestColor {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_POINTER,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetNearestColor"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * COLORREF GetNearestColor(HDC hdc, COLORREF color)
     * }
     */
    public static FunctionDescriptor GetNearestColor$descriptor() {
        return GetNearestColor.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * COLORREF GetNearestColor(HDC hdc, COLORREF color)
     * }
     */
    public static MethodHandle GetNearestColor$handle() {
        return GetNearestColor.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * COLORREF GetNearestColor(HDC hdc, COLORREF color)
     * }
     */
    public static int GetNearestColor(MemorySegment hdc, int color) {
        var mh$ = GetNearestColor.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetNearestColor", hdc, color);
            }
            return (int)mh$.invokeExact(hdc, color);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetNearestPaletteIndex {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetNearestPaletteIndex"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * UINT GetNearestPaletteIndex(HPALETTE h, COLORREF color)
     * }
     */
    public static FunctionDescriptor GetNearestPaletteIndex$descriptor() {
        return GetNearestPaletteIndex.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * UINT GetNearestPaletteIndex(HPALETTE h, COLORREF color)
     * }
     */
    public static MethodHandle GetNearestPaletteIndex$handle() {
        return GetNearestPaletteIndex.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * UINT GetNearestPaletteIndex(HPALETTE h, COLORREF color)
     * }
     */
    public static int GetNearestPaletteIndex(MemorySegment h, int color) {
        var mh$ = GetNearestPaletteIndex.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetNearestPaletteIndex", h, color);
            }
            return (int)mh$.invokeExact(h, color);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetObjectType {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetObjectType"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetObjectType(HGDIOBJ h)
     * }
     */
    public static FunctionDescriptor GetObjectType$descriptor() {
        return GetObjectType.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetObjectType(HGDIOBJ h)
     * }
     */
    public static MethodHandle GetObjectType$handle() {
        return GetObjectType.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * DWORD GetObjectType(HGDIOBJ h)
     * }
     */
    public static int GetObjectType(MemorySegment h) {
        var mh$ = GetObjectType.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetObjectType", h);
            }
            return (int)mh$.invokeExact(h);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetOutlineTextMetricsA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetOutlineTextMetricsA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * UINT GetOutlineTextMetricsA(HDC hdc, UINT cjCopy, LPOUTLINETEXTMETRICA potm)
     * }
     */
    public static FunctionDescriptor GetOutlineTextMetricsA$descriptor() {
        return GetOutlineTextMetricsA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * UINT GetOutlineTextMetricsA(HDC hdc, UINT cjCopy, LPOUTLINETEXTMETRICA potm)
     * }
     */
    public static MethodHandle GetOutlineTextMetricsA$handle() {
        return GetOutlineTextMetricsA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * UINT GetOutlineTextMetricsA(HDC hdc, UINT cjCopy, LPOUTLINETEXTMETRICA potm)
     * }
     */
    public static int GetOutlineTextMetricsA(MemorySegment hdc, int cjCopy, MemorySegment potm) {
        var mh$ = GetOutlineTextMetricsA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetOutlineTextMetricsA", hdc, cjCopy, potm);
            }
            return (int)mh$.invokeExact(hdc, cjCopy, potm);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetOutlineTextMetricsW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetOutlineTextMetricsW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * UINT GetOutlineTextMetricsW(HDC hdc, UINT cjCopy, LPOUTLINETEXTMETRICW potm)
     * }
     */
    public static FunctionDescriptor GetOutlineTextMetricsW$descriptor() {
        return GetOutlineTextMetricsW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * UINT GetOutlineTextMetricsW(HDC hdc, UINT cjCopy, LPOUTLINETEXTMETRICW potm)
     * }
     */
    public static MethodHandle GetOutlineTextMetricsW$handle() {
        return GetOutlineTextMetricsW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * UINT GetOutlineTextMetricsW(HDC hdc, UINT cjCopy, LPOUTLINETEXTMETRICW potm)
     * }
     */
    public static int GetOutlineTextMetricsW(MemorySegment hdc, int cjCopy, MemorySegment potm) {
        var mh$ = GetOutlineTextMetricsW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetOutlineTextMetricsW", hdc, cjCopy, potm);
            }
            return (int)mh$.invokeExact(hdc, cjCopy, potm);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetPaletteEntries {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_INT,
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetPaletteEntries"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * UINT GetPaletteEntries(HPALETTE hpal, UINT iStart, UINT cEntries, LPPALETTEENTRY pPalEntries)
     * }
     */
    public static FunctionDescriptor GetPaletteEntries$descriptor() {
        return GetPaletteEntries.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * UINT GetPaletteEntries(HPALETTE hpal, UINT iStart, UINT cEntries, LPPALETTEENTRY pPalEntries)
     * }
     */
    public static MethodHandle GetPaletteEntries$handle() {
        return GetPaletteEntries.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * UINT GetPaletteEntries(HPALETTE hpal, UINT iStart, UINT cEntries, LPPALETTEENTRY pPalEntries)
     * }
     */
    public static int GetPaletteEntries(MemorySegment hpal, int iStart, int cEntries, MemorySegment pPalEntries) {
        var mh$ = GetPaletteEntries.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetPaletteEntries", hpal, iStart, cEntries, pPalEntries);
            }
            return (int)mh$.invokeExact(hpal, iStart, cEntries, pPalEntries);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetPixel {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_POINTER,
            C_INT,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetPixel"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * COLORREF GetPixel(HDC hdc, int x, int y)
     * }
     */
    public static FunctionDescriptor GetPixel$descriptor() {
        return GetPixel.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * COLORREF GetPixel(HDC hdc, int x, int y)
     * }
     */
    public static MethodHandle GetPixel$handle() {
        return GetPixel.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * COLORREF GetPixel(HDC hdc, int x, int y)
     * }
     */
    public static int GetPixel(MemorySegment hdc, int x, int y) {
        var mh$ = GetPixel.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetPixel", hdc, x, y);
            }
            return (int)mh$.invokeExact(hdc, x, y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetPixelFormat {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetPixelFormat"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int GetPixelFormat(HDC hdc)
     * }
     */
    public static FunctionDescriptor GetPixelFormat$descriptor() {
        return GetPixelFormat.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int GetPixelFormat(HDC hdc)
     * }
     */
    public static MethodHandle GetPixelFormat$handle() {
        return GetPixelFormat.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int GetPixelFormat(HDC hdc)
     * }
     */
    public static int GetPixelFormat(MemorySegment hdc) {
        var mh$ = GetPixelFormat.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetPixelFormat", hdc);
            }
            return (int)mh$.invokeExact(hdc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetPolyFillMode {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetPolyFillMode"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int GetPolyFillMode(HDC hdc)
     * }
     */
    public static FunctionDescriptor GetPolyFillMode$descriptor() {
        return GetPolyFillMode.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int GetPolyFillMode(HDC hdc)
     * }
     */
    public static MethodHandle GetPolyFillMode$handle() {
        return GetPolyFillMode.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int GetPolyFillMode(HDC hdc)
     * }
     */
    public static int GetPolyFillMode(MemorySegment hdc) {
        var mh$ = GetPolyFillMode.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetPolyFillMode", hdc);
            }
            return (int)mh$.invokeExact(hdc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetRasterizerCaps {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetRasterizerCaps"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetRasterizerCaps(LPRASTERIZER_STATUS lpraststat, UINT cjBytes)
     * }
     */
    public static FunctionDescriptor GetRasterizerCaps$descriptor() {
        return GetRasterizerCaps.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetRasterizerCaps(LPRASTERIZER_STATUS lpraststat, UINT cjBytes)
     * }
     */
    public static MethodHandle GetRasterizerCaps$handle() {
        return GetRasterizerCaps.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL GetRasterizerCaps(LPRASTERIZER_STATUS lpraststat, UINT cjBytes)
     * }
     */
    public static int GetRasterizerCaps(MemorySegment lpraststat, int cjBytes) {
        var mh$ = GetRasterizerCaps.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetRasterizerCaps", lpraststat, cjBytes);
            }
            return (int)mh$.invokeExact(lpraststat, cjBytes);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetRandomRgn {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetRandomRgn"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int GetRandomRgn(HDC hdc, HRGN hrgn, INT i)
     * }
     */
    public static FunctionDescriptor GetRandomRgn$descriptor() {
        return GetRandomRgn.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int GetRandomRgn(HDC hdc, HRGN hrgn, INT i)
     * }
     */
    public static MethodHandle GetRandomRgn$handle() {
        return GetRandomRgn.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int GetRandomRgn(HDC hdc, HRGN hrgn, INT i)
     * }
     */
    public static int GetRandomRgn(MemorySegment hdc, MemorySegment hrgn, int i) {
        var mh$ = GetRandomRgn.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetRandomRgn", hdc, hrgn, i);
            }
            return (int)mh$.invokeExact(hdc, hrgn, i);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetRegionData {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_POINTER,
            C_LONG,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetRegionData"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetRegionData(HRGN hrgn, DWORD nCount, LPRGNDATA lpRgnData)
     * }
     */
    public static FunctionDescriptor GetRegionData$descriptor() {
        return GetRegionData.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetRegionData(HRGN hrgn, DWORD nCount, LPRGNDATA lpRgnData)
     * }
     */
    public static MethodHandle GetRegionData$handle() {
        return GetRegionData.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * DWORD GetRegionData(HRGN hrgn, DWORD nCount, LPRGNDATA lpRgnData)
     * }
     */
    public static int GetRegionData(MemorySegment hrgn, int nCount, MemorySegment lpRgnData) {
        var mh$ = GetRegionData.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetRegionData", hrgn, nCount, lpRgnData);
            }
            return (int)mh$.invokeExact(hrgn, nCount, lpRgnData);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetRgnBox {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetRgnBox"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int GetRgnBox(HRGN hrgn, LPRECT lprc)
     * }
     */
    public static FunctionDescriptor GetRgnBox$descriptor() {
        return GetRgnBox.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int GetRgnBox(HRGN hrgn, LPRECT lprc)
     * }
     */
    public static MethodHandle GetRgnBox$handle() {
        return GetRgnBox.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int GetRgnBox(HRGN hrgn, LPRECT lprc)
     * }
     */
    public static int GetRgnBox(MemorySegment hrgn, MemorySegment lprc) {
        var mh$ = GetRgnBox.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetRgnBox", hrgn, lprc);
            }
            return (int)mh$.invokeExact(hrgn, lprc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetStockObject {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetStockObject"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HGDIOBJ GetStockObject(int i)
     * }
     */
    public static FunctionDescriptor GetStockObject$descriptor() {
        return GetStockObject.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HGDIOBJ GetStockObject(int i)
     * }
     */
    public static MethodHandle GetStockObject$handle() {
        return GetStockObject.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * HGDIOBJ GetStockObject(int i)
     * }
     */
    public static MemorySegment GetStockObject(int i) {
        var mh$ = GetStockObject.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetStockObject", i);
            }
            return (MemorySegment)mh$.invokeExact(i);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetStretchBltMode {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetStretchBltMode"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int GetStretchBltMode(HDC hdc)
     * }
     */
    public static FunctionDescriptor GetStretchBltMode$descriptor() {
        return GetStretchBltMode.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int GetStretchBltMode(HDC hdc)
     * }
     */
    public static MethodHandle GetStretchBltMode$handle() {
        return GetStretchBltMode.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int GetStretchBltMode(HDC hdc)
     * }
     */
    public static int GetStretchBltMode(MemorySegment hdc) {
        var mh$ = GetStretchBltMode.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetStretchBltMode", hdc);
            }
            return (int)mh$.invokeExact(hdc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetSystemPaletteEntries {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_INT,
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetSystemPaletteEntries"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * UINT GetSystemPaletteEntries(HDC hdc, UINT iStart, UINT cEntries, LPPALETTEENTRY pPalEntries)
     * }
     */
    public static FunctionDescriptor GetSystemPaletteEntries$descriptor() {
        return GetSystemPaletteEntries.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * UINT GetSystemPaletteEntries(HDC hdc, UINT iStart, UINT cEntries, LPPALETTEENTRY pPalEntries)
     * }
     */
    public static MethodHandle GetSystemPaletteEntries$handle() {
        return GetSystemPaletteEntries.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * UINT GetSystemPaletteEntries(HDC hdc, UINT iStart, UINT cEntries, LPPALETTEENTRY pPalEntries)
     * }
     */
    public static int GetSystemPaletteEntries(MemorySegment hdc, int iStart, int cEntries, MemorySegment pPalEntries) {
        var mh$ = GetSystemPaletteEntries.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetSystemPaletteEntries", hdc, iStart, cEntries, pPalEntries);
            }
            return (int)mh$.invokeExact(hdc, iStart, cEntries, pPalEntries);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetSystemPaletteUse {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetSystemPaletteUse"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * UINT GetSystemPaletteUse(HDC hdc)
     * }
     */
    public static FunctionDescriptor GetSystemPaletteUse$descriptor() {
        return GetSystemPaletteUse.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * UINT GetSystemPaletteUse(HDC hdc)
     * }
     */
    public static MethodHandle GetSystemPaletteUse$handle() {
        return GetSystemPaletteUse.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * UINT GetSystemPaletteUse(HDC hdc)
     * }
     */
    public static int GetSystemPaletteUse(MemorySegment hdc) {
        var mh$ = GetSystemPaletteUse.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetSystemPaletteUse", hdc);
            }
            return (int)mh$.invokeExact(hdc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetTextCharacterExtra {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetTextCharacterExtra"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int GetTextCharacterExtra(HDC hdc)
     * }
     */
    public static FunctionDescriptor GetTextCharacterExtra$descriptor() {
        return GetTextCharacterExtra.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int GetTextCharacterExtra(HDC hdc)
     * }
     */
    public static MethodHandle GetTextCharacterExtra$handle() {
        return GetTextCharacterExtra.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int GetTextCharacterExtra(HDC hdc)
     * }
     */
    public static int GetTextCharacterExtra(MemorySegment hdc) {
        var mh$ = GetTextCharacterExtra.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetTextCharacterExtra", hdc);
            }
            return (int)mh$.invokeExact(hdc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetTextAlign {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetTextAlign"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * UINT GetTextAlign(HDC hdc)
     * }
     */
    public static FunctionDescriptor GetTextAlign$descriptor() {
        return GetTextAlign.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * UINT GetTextAlign(HDC hdc)
     * }
     */
    public static MethodHandle GetTextAlign$handle() {
        return GetTextAlign.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * UINT GetTextAlign(HDC hdc)
     * }
     */
    public static int GetTextAlign(MemorySegment hdc) {
        var mh$ = GetTextAlign.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetTextAlign", hdc);
            }
            return (int)mh$.invokeExact(hdc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetTextColor {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetTextColor"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * COLORREF GetTextColor(HDC hdc)
     * }
     */
    public static FunctionDescriptor GetTextColor$descriptor() {
        return GetTextColor.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * COLORREF GetTextColor(HDC hdc)
     * }
     */
    public static MethodHandle GetTextColor$handle() {
        return GetTextColor.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * COLORREF GetTextColor(HDC hdc)
     * }
     */
    public static int GetTextColor(MemorySegment hdc) {
        var mh$ = GetTextColor.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetTextColor", hdc);
            }
            return (int)mh$.invokeExact(hdc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetTextExtentPointA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetTextExtentPointA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetTextExtentPointA(HDC hdc, LPCSTR lpString, int c, LPSIZE lpsz)
     * }
     */
    public static FunctionDescriptor GetTextExtentPointA$descriptor() {
        return GetTextExtentPointA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetTextExtentPointA(HDC hdc, LPCSTR lpString, int c, LPSIZE lpsz)
     * }
     */
    public static MethodHandle GetTextExtentPointA$handle() {
        return GetTextExtentPointA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL GetTextExtentPointA(HDC hdc, LPCSTR lpString, int c, LPSIZE lpsz)
     * }
     */
    public static int GetTextExtentPointA(MemorySegment hdc, MemorySegment lpString, int c, MemorySegment lpsz) {
        var mh$ = GetTextExtentPointA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetTextExtentPointA", hdc, lpString, c, lpsz);
            }
            return (int)mh$.invokeExact(hdc, lpString, c, lpsz);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetTextExtentPointW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetTextExtentPointW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetTextExtentPointW(HDC hdc, LPCWSTR lpString, int c, LPSIZE lpsz)
     * }
     */
    public static FunctionDescriptor GetTextExtentPointW$descriptor() {
        return GetTextExtentPointW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetTextExtentPointW(HDC hdc, LPCWSTR lpString, int c, LPSIZE lpsz)
     * }
     */
    public static MethodHandle GetTextExtentPointW$handle() {
        return GetTextExtentPointW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL GetTextExtentPointW(HDC hdc, LPCWSTR lpString, int c, LPSIZE lpsz)
     * }
     */
    public static int GetTextExtentPointW(MemorySegment hdc, MemorySegment lpString, int c, MemorySegment lpsz) {
        var mh$ = GetTextExtentPointW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetTextExtentPointW", hdc, lpString, c, lpsz);
            }
            return (int)mh$.invokeExact(hdc, lpString, c, lpsz);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetTextExtentPoint32A {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetTextExtentPoint32A"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetTextExtentPoint32A(HDC hdc, LPCSTR lpString, int c, LPSIZE psizl)
     * }
     */
    public static FunctionDescriptor GetTextExtentPoint32A$descriptor() {
        return GetTextExtentPoint32A.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetTextExtentPoint32A(HDC hdc, LPCSTR lpString, int c, LPSIZE psizl)
     * }
     */
    public static MethodHandle GetTextExtentPoint32A$handle() {
        return GetTextExtentPoint32A.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL GetTextExtentPoint32A(HDC hdc, LPCSTR lpString, int c, LPSIZE psizl)
     * }
     */
    public static int GetTextExtentPoint32A(MemorySegment hdc, MemorySegment lpString, int c, MemorySegment psizl) {
        var mh$ = GetTextExtentPoint32A.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetTextExtentPoint32A", hdc, lpString, c, psizl);
            }
            return (int)mh$.invokeExact(hdc, lpString, c, psizl);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetTextExtentPoint32W {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetTextExtentPoint32W"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetTextExtentPoint32W(HDC hdc, LPCWSTR lpString, int c, LPSIZE psizl)
     * }
     */
    public static FunctionDescriptor GetTextExtentPoint32W$descriptor() {
        return GetTextExtentPoint32W.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetTextExtentPoint32W(HDC hdc, LPCWSTR lpString, int c, LPSIZE psizl)
     * }
     */
    public static MethodHandle GetTextExtentPoint32W$handle() {
        return GetTextExtentPoint32W.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL GetTextExtentPoint32W(HDC hdc, LPCWSTR lpString, int c, LPSIZE psizl)
     * }
     */
    public static int GetTextExtentPoint32W(MemorySegment hdc, MemorySegment lpString, int c, MemorySegment psizl) {
        var mh$ = GetTextExtentPoint32W.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetTextExtentPoint32W", hdc, lpString, c, psizl);
            }
            return (int)mh$.invokeExact(hdc, lpString, c, psizl);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetTextExtentExPointA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_INT,
            C_INT,
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetTextExtentExPointA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetTextExtentExPointA(HDC hdc, LPCSTR lpszString, int cchString, int nMaxExtent, LPINT lpnFit, LPINT lpnDx, LPSIZE lpSize)
     * }
     */
    public static FunctionDescriptor GetTextExtentExPointA$descriptor() {
        return GetTextExtentExPointA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetTextExtentExPointA(HDC hdc, LPCSTR lpszString, int cchString, int nMaxExtent, LPINT lpnFit, LPINT lpnDx, LPSIZE lpSize)
     * }
     */
    public static MethodHandle GetTextExtentExPointA$handle() {
        return GetTextExtentExPointA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL GetTextExtentExPointA(HDC hdc, LPCSTR lpszString, int cchString, int nMaxExtent, LPINT lpnFit, LPINT lpnDx, LPSIZE lpSize)
     * }
     */
    public static int GetTextExtentExPointA(MemorySegment hdc, MemorySegment lpszString, int cchString, int nMaxExtent, MemorySegment lpnFit, MemorySegment lpnDx, MemorySegment lpSize) {
        var mh$ = GetTextExtentExPointA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetTextExtentExPointA", hdc, lpszString, cchString, nMaxExtent, lpnFit, lpnDx, lpSize);
            }
            return (int)mh$.invokeExact(hdc, lpszString, cchString, nMaxExtent, lpnFit, lpnDx, lpSize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetTextExtentExPointW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_INT,
            C_INT,
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetTextExtentExPointW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetTextExtentExPointW(HDC hdc, LPCWSTR lpszString, int cchString, int nMaxExtent, LPINT lpnFit, LPINT lpnDx, LPSIZE lpSize)
     * }
     */
    public static FunctionDescriptor GetTextExtentExPointW$descriptor() {
        return GetTextExtentExPointW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetTextExtentExPointW(HDC hdc, LPCWSTR lpszString, int cchString, int nMaxExtent, LPINT lpnFit, LPINT lpnDx, LPSIZE lpSize)
     * }
     */
    public static MethodHandle GetTextExtentExPointW$handle() {
        return GetTextExtentExPointW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL GetTextExtentExPointW(HDC hdc, LPCWSTR lpszString, int cchString, int nMaxExtent, LPINT lpnFit, LPINT lpnDx, LPSIZE lpSize)
     * }
     */
    public static int GetTextExtentExPointW(MemorySegment hdc, MemorySegment lpszString, int cchString, int nMaxExtent, MemorySegment lpnFit, MemorySegment lpnDx, MemorySegment lpSize) {
        var mh$ = GetTextExtentExPointW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetTextExtentExPointW", hdc, lpszString, cchString, nMaxExtent, lpnFit, lpnDx, lpSize);
            }
            return (int)mh$.invokeExact(hdc, lpszString, cchString, nMaxExtent, lpnFit, lpnDx, lpSize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetTextCharset {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetTextCharset"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int GetTextCharset(HDC hdc)
     * }
     */
    public static FunctionDescriptor GetTextCharset$descriptor() {
        return GetTextCharset.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int GetTextCharset(HDC hdc)
     * }
     */
    public static MethodHandle GetTextCharset$handle() {
        return GetTextCharset.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int GetTextCharset(HDC hdc)
     * }
     */
    public static int GetTextCharset(MemorySegment hdc) {
        var mh$ = GetTextCharset.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetTextCharset", hdc);
            }
            return (int)mh$.invokeExact(hdc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetTextCharsetInfo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetTextCharsetInfo"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int GetTextCharsetInfo(HDC hdc, LPFONTSIGNATURE lpSig, DWORD dwFlags)
     * }
     */
    public static FunctionDescriptor GetTextCharsetInfo$descriptor() {
        return GetTextCharsetInfo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int GetTextCharsetInfo(HDC hdc, LPFONTSIGNATURE lpSig, DWORD dwFlags)
     * }
     */
    public static MethodHandle GetTextCharsetInfo$handle() {
        return GetTextCharsetInfo.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int GetTextCharsetInfo(HDC hdc, LPFONTSIGNATURE lpSig, DWORD dwFlags)
     * }
     */
    public static int GetTextCharsetInfo(MemorySegment hdc, MemorySegment lpSig, int dwFlags) {
        var mh$ = GetTextCharsetInfo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetTextCharsetInfo", hdc, lpSig, dwFlags);
            }
            return (int)mh$.invokeExact(hdc, lpSig, dwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TranslateCharsetInfo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("TranslateCharsetInfo"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL TranslateCharsetInfo(DWORD *lpSrc, LPCHARSETINFO lpCs, DWORD dwFlags)
     * }
     */
    public static FunctionDescriptor TranslateCharsetInfo$descriptor() {
        return TranslateCharsetInfo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL TranslateCharsetInfo(DWORD *lpSrc, LPCHARSETINFO lpCs, DWORD dwFlags)
     * }
     */
    public static MethodHandle TranslateCharsetInfo$handle() {
        return TranslateCharsetInfo.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL TranslateCharsetInfo(DWORD *lpSrc, LPCHARSETINFO lpCs, DWORD dwFlags)
     * }
     */
    public static int TranslateCharsetInfo(MemorySegment lpSrc, MemorySegment lpCs, int dwFlags) {
        var mh$ = TranslateCharsetInfo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TranslateCharsetInfo", lpSrc, lpCs, dwFlags);
            }
            return (int)mh$.invokeExact(lpSrc, lpCs, dwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetFontLanguageInfo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetFontLanguageInfo"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetFontLanguageInfo(HDC hdc)
     * }
     */
    public static FunctionDescriptor GetFontLanguageInfo$descriptor() {
        return GetFontLanguageInfo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetFontLanguageInfo(HDC hdc)
     * }
     */
    public static MethodHandle GetFontLanguageInfo$handle() {
        return GetFontLanguageInfo.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * DWORD GetFontLanguageInfo(HDC hdc)
     * }
     */
    public static int GetFontLanguageInfo(MemorySegment hdc) {
        var mh$ = GetFontLanguageInfo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetFontLanguageInfo", hdc);
            }
            return (int)mh$.invokeExact(hdc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetCharacterPlacementA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_POINTER,
            C_POINTER,
            C_INT,
            C_INT,
            C_POINTER,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetCharacterPlacementA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetCharacterPlacementA(HDC hdc, LPCSTR lpString, int nCount, int nMexExtent, LPGCP_RESULTSA lpResults, DWORD dwFlags)
     * }
     */
    public static FunctionDescriptor GetCharacterPlacementA$descriptor() {
        return GetCharacterPlacementA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetCharacterPlacementA(HDC hdc, LPCSTR lpString, int nCount, int nMexExtent, LPGCP_RESULTSA lpResults, DWORD dwFlags)
     * }
     */
    public static MethodHandle GetCharacterPlacementA$handle() {
        return GetCharacterPlacementA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * DWORD GetCharacterPlacementA(HDC hdc, LPCSTR lpString, int nCount, int nMexExtent, LPGCP_RESULTSA lpResults, DWORD dwFlags)
     * }
     */
    public static int GetCharacterPlacementA(MemorySegment hdc, MemorySegment lpString, int nCount, int nMexExtent, MemorySegment lpResults, int dwFlags) {
        var mh$ = GetCharacterPlacementA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetCharacterPlacementA", hdc, lpString, nCount, nMexExtent, lpResults, dwFlags);
            }
            return (int)mh$.invokeExact(hdc, lpString, nCount, nMexExtent, lpResults, dwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetCharacterPlacementW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_POINTER,
            C_POINTER,
            C_INT,
            C_INT,
            C_POINTER,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetCharacterPlacementW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetCharacterPlacementW(HDC hdc, LPCWSTR lpString, int nCount, int nMexExtent, LPGCP_RESULTSW lpResults, DWORD dwFlags)
     * }
     */
    public static FunctionDescriptor GetCharacterPlacementW$descriptor() {
        return GetCharacterPlacementW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetCharacterPlacementW(HDC hdc, LPCWSTR lpString, int nCount, int nMexExtent, LPGCP_RESULTSW lpResults, DWORD dwFlags)
     * }
     */
    public static MethodHandle GetCharacterPlacementW$handle() {
        return GetCharacterPlacementW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * DWORD GetCharacterPlacementW(HDC hdc, LPCWSTR lpString, int nCount, int nMexExtent, LPGCP_RESULTSW lpResults, DWORD dwFlags)
     * }
     */
    public static int GetCharacterPlacementW(MemorySegment hdc, MemorySegment lpString, int nCount, int nMexExtent, MemorySegment lpResults, int dwFlags) {
        var mh$ = GetCharacterPlacementW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetCharacterPlacementW", hdc, lpString, nCount, nMexExtent, lpResults, dwFlags);
            }
            return (int)mh$.invokeExact(hdc, lpString, nCount, nMexExtent, lpResults, dwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct tagWCRANGE {
     *     WCHAR wcLow;
     *     USHORT cGlyphs;
     * } *PWCRANGE
     * }
     */
    public static final AddressLayout PWCRANGE = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagWCRANGE {
     *     WCHAR wcLow;
     *     USHORT cGlyphs;
     * } *LPWCRANGE
     * }
     */
    public static final AddressLayout LPWCRANGE = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagGLYPHSET {
     *     DWORD cbThis;
     *     DWORD flAccel;
     *     DWORD cGlyphsSupported;
     *     DWORD cRanges;
     *     WCRANGE ranges[1];
     * } *PGLYPHSET
     * }
     */
    public static final AddressLayout PGLYPHSET = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagGLYPHSET {
     *     DWORD cbThis;
     *     DWORD flAccel;
     *     DWORD cGlyphsSupported;
     *     DWORD cRanges;
     *     WCRANGE ranges[1];
     * } *LPGLYPHSET
     * }
     */
    public static final AddressLayout LPGLYPHSET = C_POINTER;

    private static class GetFontUnicodeRanges {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetFontUnicodeRanges"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetFontUnicodeRanges(HDC hdc, LPGLYPHSET lpgs)
     * }
     */
    public static FunctionDescriptor GetFontUnicodeRanges$descriptor() {
        return GetFontUnicodeRanges.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetFontUnicodeRanges(HDC hdc, LPGLYPHSET lpgs)
     * }
     */
    public static MethodHandle GetFontUnicodeRanges$handle() {
        return GetFontUnicodeRanges.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * DWORD GetFontUnicodeRanges(HDC hdc, LPGLYPHSET lpgs)
     * }
     */
    public static int GetFontUnicodeRanges(MemorySegment hdc, MemorySegment lpgs) {
        var mh$ = GetFontUnicodeRanges.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetFontUnicodeRanges", hdc, lpgs);
            }
            return (int)mh$.invokeExact(hdc, lpgs);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetGlyphIndicesA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_POINTER,
            C_POINTER,
            C_INT,
            C_POINTER,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetGlyphIndicesA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetGlyphIndicesA(HDC hdc, LPCSTR lpstr, int c, LPWORD pgi, DWORD fl)
     * }
     */
    public static FunctionDescriptor GetGlyphIndicesA$descriptor() {
        return GetGlyphIndicesA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetGlyphIndicesA(HDC hdc, LPCSTR lpstr, int c, LPWORD pgi, DWORD fl)
     * }
     */
    public static MethodHandle GetGlyphIndicesA$handle() {
        return GetGlyphIndicesA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * DWORD GetGlyphIndicesA(HDC hdc, LPCSTR lpstr, int c, LPWORD pgi, DWORD fl)
     * }
     */
    public static int GetGlyphIndicesA(MemorySegment hdc, MemorySegment lpstr, int c, MemorySegment pgi, int fl) {
        var mh$ = GetGlyphIndicesA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetGlyphIndicesA", hdc, lpstr, c, pgi, fl);
            }
            return (int)mh$.invokeExact(hdc, lpstr, c, pgi, fl);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetGlyphIndicesW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_POINTER,
            C_POINTER,
            C_INT,
            C_POINTER,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetGlyphIndicesW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetGlyphIndicesW(HDC hdc, LPCWSTR lpstr, int c, LPWORD pgi, DWORD fl)
     * }
     */
    public static FunctionDescriptor GetGlyphIndicesW$descriptor() {
        return GetGlyphIndicesW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetGlyphIndicesW(HDC hdc, LPCWSTR lpstr, int c, LPWORD pgi, DWORD fl)
     * }
     */
    public static MethodHandle GetGlyphIndicesW$handle() {
        return GetGlyphIndicesW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * DWORD GetGlyphIndicesW(HDC hdc, LPCWSTR lpstr, int c, LPWORD pgi, DWORD fl)
     * }
     */
    public static int GetGlyphIndicesW(MemorySegment hdc, MemorySegment lpstr, int c, MemorySegment pgi, int fl) {
        var mh$ = GetGlyphIndicesW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetGlyphIndicesW", hdc, lpstr, c, pgi, fl);
            }
            return (int)mh$.invokeExact(hdc, lpstr, c, pgi, fl);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetTextExtentPointI {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetTextExtentPointI"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetTextExtentPointI(HDC hdc, LPWORD pgiIn, int cgi, LPSIZE psize)
     * }
     */
    public static FunctionDescriptor GetTextExtentPointI$descriptor() {
        return GetTextExtentPointI.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetTextExtentPointI(HDC hdc, LPWORD pgiIn, int cgi, LPSIZE psize)
     * }
     */
    public static MethodHandle GetTextExtentPointI$handle() {
        return GetTextExtentPointI.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL GetTextExtentPointI(HDC hdc, LPWORD pgiIn, int cgi, LPSIZE psize)
     * }
     */
    public static int GetTextExtentPointI(MemorySegment hdc, MemorySegment pgiIn, int cgi, MemorySegment psize) {
        var mh$ = GetTextExtentPointI.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetTextExtentPointI", hdc, pgiIn, cgi, psize);
            }
            return (int)mh$.invokeExact(hdc, pgiIn, cgi, psize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetTextExtentExPointI {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_INT,
            C_INT,
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetTextExtentExPointI"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetTextExtentExPointI(HDC hdc, LPWORD lpwszString, int cwchString, int nMaxExtent, LPINT lpnFit, LPINT lpnDx, LPSIZE lpSize)
     * }
     */
    public static FunctionDescriptor GetTextExtentExPointI$descriptor() {
        return GetTextExtentExPointI.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetTextExtentExPointI(HDC hdc, LPWORD lpwszString, int cwchString, int nMaxExtent, LPINT lpnFit, LPINT lpnDx, LPSIZE lpSize)
     * }
     */
    public static MethodHandle GetTextExtentExPointI$handle() {
        return GetTextExtentExPointI.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL GetTextExtentExPointI(HDC hdc, LPWORD lpwszString, int cwchString, int nMaxExtent, LPINT lpnFit, LPINT lpnDx, LPSIZE lpSize)
     * }
     */
    public static int GetTextExtentExPointI(MemorySegment hdc, MemorySegment lpwszString, int cwchString, int nMaxExtent, MemorySegment lpnFit, MemorySegment lpnDx, MemorySegment lpSize) {
        var mh$ = GetTextExtentExPointI.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetTextExtentExPointI", hdc, lpwszString, cwchString, nMaxExtent, lpnFit, lpnDx, lpSize);
            }
            return (int)mh$.invokeExact(hdc, lpwszString, cwchString, nMaxExtent, lpnFit, lpnDx, lpSize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetCharWidthI {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_INT,
            C_INT,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetCharWidthI"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetCharWidthI(HDC hdc, UINT giFirst, UINT cgi, LPWORD pgi, LPINT piWidths)
     * }
     */
    public static FunctionDescriptor GetCharWidthI$descriptor() {
        return GetCharWidthI.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetCharWidthI(HDC hdc, UINT giFirst, UINT cgi, LPWORD pgi, LPINT piWidths)
     * }
     */
    public static MethodHandle GetCharWidthI$handle() {
        return GetCharWidthI.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL GetCharWidthI(HDC hdc, UINT giFirst, UINT cgi, LPWORD pgi, LPINT piWidths)
     * }
     */
    public static int GetCharWidthI(MemorySegment hdc, int giFirst, int cgi, MemorySegment pgi, MemorySegment piWidths) {
        var mh$ = GetCharWidthI.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetCharWidthI", hdc, giFirst, cgi, pgi, piWidths);
            }
            return (int)mh$.invokeExact(hdc, giFirst, cgi, pgi, piWidths);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetCharABCWidthsI {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_INT,
            C_INT,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetCharABCWidthsI"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetCharABCWidthsI(HDC hdc, UINT giFirst, UINT cgi, LPWORD pgi, LPABC pabc)
     * }
     */
    public static FunctionDescriptor GetCharABCWidthsI$descriptor() {
        return GetCharABCWidthsI.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetCharABCWidthsI(HDC hdc, UINT giFirst, UINT cgi, LPWORD pgi, LPABC pabc)
     * }
     */
    public static MethodHandle GetCharABCWidthsI$handle() {
        return GetCharABCWidthsI.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL GetCharABCWidthsI(HDC hdc, UINT giFirst, UINT cgi, LPWORD pgi, LPABC pabc)
     * }
     */
    public static int GetCharABCWidthsI(MemorySegment hdc, int giFirst, int cgi, MemorySegment pgi, MemorySegment pabc) {
        var mh$ = GetCharABCWidthsI.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetCharABCWidthsI", hdc, giFirst, cgi, pgi, pabc);
            }
            return (int)mh$.invokeExact(hdc, giFirst, cgi, pgi, pabc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct tagDESIGNVECTOR {
     *     DWORD dvReserved;
     *     DWORD dvNumAxes;
     *     LONG dvValues[16];
     * } *PDESIGNVECTOR
     * }
     */
    public static final AddressLayout PDESIGNVECTOR = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagDESIGNVECTOR {
     *     DWORD dvReserved;
     *     DWORD dvNumAxes;
     *     LONG dvValues[16];
     * } *LPDESIGNVECTOR
     * }
     */
    public static final AddressLayout LPDESIGNVECTOR = C_POINTER;

    private static class AddFontResourceExA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_LONG,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("AddFontResourceExA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int AddFontResourceExA(LPCSTR name, DWORD fl, PVOID res)
     * }
     */
    public static FunctionDescriptor AddFontResourceExA$descriptor() {
        return AddFontResourceExA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int AddFontResourceExA(LPCSTR name, DWORD fl, PVOID res)
     * }
     */
    public static MethodHandle AddFontResourceExA$handle() {
        return AddFontResourceExA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int AddFontResourceExA(LPCSTR name, DWORD fl, PVOID res)
     * }
     */
    public static int AddFontResourceExA(MemorySegment name, int fl, MemorySegment res) {
        var mh$ = AddFontResourceExA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("AddFontResourceExA", name, fl, res);
            }
            return (int)mh$.invokeExact(name, fl, res);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class AddFontResourceExW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_LONG,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("AddFontResourceExW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int AddFontResourceExW(LPCWSTR name, DWORD fl, PVOID res)
     * }
     */
    public static FunctionDescriptor AddFontResourceExW$descriptor() {
        return AddFontResourceExW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int AddFontResourceExW(LPCWSTR name, DWORD fl, PVOID res)
     * }
     */
    public static MethodHandle AddFontResourceExW$handle() {
        return AddFontResourceExW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int AddFontResourceExW(LPCWSTR name, DWORD fl, PVOID res)
     * }
     */
    public static int AddFontResourceExW(MemorySegment name, int fl, MemorySegment res) {
        var mh$ = AddFontResourceExW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("AddFontResourceExW", name, fl, res);
            }
            return (int)mh$.invokeExact(name, fl, res);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RemoveFontResourceExA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_LONG,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("RemoveFontResourceExA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL RemoveFontResourceExA(LPCSTR name, DWORD fl, PVOID pdv)
     * }
     */
    public static FunctionDescriptor RemoveFontResourceExA$descriptor() {
        return RemoveFontResourceExA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL RemoveFontResourceExA(LPCSTR name, DWORD fl, PVOID pdv)
     * }
     */
    public static MethodHandle RemoveFontResourceExA$handle() {
        return RemoveFontResourceExA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL RemoveFontResourceExA(LPCSTR name, DWORD fl, PVOID pdv)
     * }
     */
    public static int RemoveFontResourceExA(MemorySegment name, int fl, MemorySegment pdv) {
        var mh$ = RemoveFontResourceExA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RemoveFontResourceExA", name, fl, pdv);
            }
            return (int)mh$.invokeExact(name, fl, pdv);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RemoveFontResourceExW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_LONG,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("RemoveFontResourceExW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL RemoveFontResourceExW(LPCWSTR name, DWORD fl, PVOID pdv)
     * }
     */
    public static FunctionDescriptor RemoveFontResourceExW$descriptor() {
        return RemoveFontResourceExW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL RemoveFontResourceExW(LPCWSTR name, DWORD fl, PVOID pdv)
     * }
     */
    public static MethodHandle RemoveFontResourceExW$handle() {
        return RemoveFontResourceExW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL RemoveFontResourceExW(LPCWSTR name, DWORD fl, PVOID pdv)
     * }
     */
    public static int RemoveFontResourceExW(MemorySegment name, int fl, MemorySegment pdv) {
        var mh$ = RemoveFontResourceExW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RemoveFontResourceExW", name, fl, pdv);
            }
            return (int)mh$.invokeExact(name, fl, pdv);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class AddFontMemResourceEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER,
            C_LONG,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("AddFontMemResourceEx"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HANDLE AddFontMemResourceEx(PVOID pFileView, DWORD cjSize, PVOID pvResrved, DWORD *pNumFonts)
     * }
     */
    public static FunctionDescriptor AddFontMemResourceEx$descriptor() {
        return AddFontMemResourceEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HANDLE AddFontMemResourceEx(PVOID pFileView, DWORD cjSize, PVOID pvResrved, DWORD *pNumFonts)
     * }
     */
    public static MethodHandle AddFontMemResourceEx$handle() {
        return AddFontMemResourceEx.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * HANDLE AddFontMemResourceEx(PVOID pFileView, DWORD cjSize, PVOID pvResrved, DWORD *pNumFonts)
     * }
     */
    public static MemorySegment AddFontMemResourceEx(MemorySegment pFileView, int cjSize, MemorySegment pvResrved, MemorySegment pNumFonts) {
        var mh$ = AddFontMemResourceEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("AddFontMemResourceEx", pFileView, cjSize, pvResrved, pNumFonts);
            }
            return (MemorySegment)mh$.invokeExact(pFileView, cjSize, pvResrved, pNumFonts);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RemoveFontMemResourceEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("RemoveFontMemResourceEx"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL RemoveFontMemResourceEx(HANDLE h)
     * }
     */
    public static FunctionDescriptor RemoveFontMemResourceEx$descriptor() {
        return RemoveFontMemResourceEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL RemoveFontMemResourceEx(HANDLE h)
     * }
     */
    public static MethodHandle RemoveFontMemResourceEx$handle() {
        return RemoveFontMemResourceEx.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL RemoveFontMemResourceEx(HANDLE h)
     * }
     */
    public static int RemoveFontMemResourceEx(MemorySegment h) {
        var mh$ = RemoveFontMemResourceEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RemoveFontMemResourceEx", h);
            }
            return (int)mh$.invokeExact(h);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct tagAXISINFOA {
     *     LONG axMinValue;
     *     LONG axMaxValue;
     *     BYTE axAxisName[16];
     * } *PAXISINFOA
     * }
     */
    public static final AddressLayout PAXISINFOA = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagAXISINFOA {
     *     LONG axMinValue;
     *     LONG axMaxValue;
     *     BYTE axAxisName[16];
     * } *LPAXISINFOA
     * }
     */
    public static final AddressLayout LPAXISINFOA = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagAXISINFOW {
     *     LONG axMinValue;
     *     LONG axMaxValue;
     *     WCHAR axAxisName[16];
     * } *PAXISINFOW
     * }
     */
    public static final AddressLayout PAXISINFOW = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagAXISINFOW {
     *     LONG axMinValue;
     *     LONG axMaxValue;
     *     WCHAR axAxisName[16];
     * } *LPAXISINFOW
     * }
     */
    public static final AddressLayout LPAXISINFOW = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef PAXISINFOA PAXISINFO
     * }
     */
    public static final AddressLayout PAXISINFO = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef LPAXISINFOA LPAXISINFO
     * }
     */
    public static final AddressLayout LPAXISINFO = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagAXESLISTA {
     *     DWORD axlReserved;
     *     DWORD axlNumAxes;
     *     AXISINFOA axlAxisInfo[16];
     * } *PAXESLISTA
     * }
     */
    public static final AddressLayout PAXESLISTA = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagAXESLISTA {
     *     DWORD axlReserved;
     *     DWORD axlNumAxes;
     *     AXISINFOA axlAxisInfo[16];
     * } *LPAXESLISTA
     * }
     */
    public static final AddressLayout LPAXESLISTA = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagAXESLISTW {
     *     DWORD axlReserved;
     *     DWORD axlNumAxes;
     *     AXISINFOW axlAxisInfo[16];
     * } *PAXESLISTW
     * }
     */
    public static final AddressLayout PAXESLISTW = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagAXESLISTW {
     *     DWORD axlReserved;
     *     DWORD axlNumAxes;
     *     AXISINFOW axlAxisInfo[16];
     * } *LPAXESLISTW
     * }
     */
    public static final AddressLayout LPAXESLISTW = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef PAXESLISTA PAXESLIST
     * }
     */
    public static final AddressLayout PAXESLIST = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef LPAXESLISTA LPAXESLIST
     * }
     */
    public static final AddressLayout LPAXESLIST = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagENUMLOGFONTEXDVA {
     *     ENUMLOGFONTEXA elfEnumLogfontEx;
     *     DESIGNVECTOR elfDesignVector;
     * } *PENUMLOGFONTEXDVA
     * }
     */
    public static final AddressLayout PENUMLOGFONTEXDVA = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagENUMLOGFONTEXDVA {
     *     ENUMLOGFONTEXA elfEnumLogfontEx;
     *     DESIGNVECTOR elfDesignVector;
     * } *LPENUMLOGFONTEXDVA
     * }
     */
    public static final AddressLayout LPENUMLOGFONTEXDVA = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagENUMLOGFONTEXDVW {
     *     ENUMLOGFONTEXW elfEnumLogfontEx;
     *     DESIGNVECTOR elfDesignVector;
     * } *PENUMLOGFONTEXDVW
     * }
     */
    public static final AddressLayout PENUMLOGFONTEXDVW = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagENUMLOGFONTEXDVW {
     *     ENUMLOGFONTEXW elfEnumLogfontEx;
     *     DESIGNVECTOR elfDesignVector;
     * } *LPENUMLOGFONTEXDVW
     * }
     */
    public static final AddressLayout LPENUMLOGFONTEXDVW = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef PENUMLOGFONTEXDVA PENUMLOGFONTEXDV
     * }
     */
    public static final AddressLayout PENUMLOGFONTEXDV = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef LPENUMLOGFONTEXDVA LPENUMLOGFONTEXDV
     * }
     */
    public static final AddressLayout LPENUMLOGFONTEXDV = C_POINTER;

    private static class CreateFontIndirectExA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CreateFontIndirectExA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HFONT CreateFontIndirectExA(const ENUMLOGFONTEXDVA *)
     * }
     */
    public static FunctionDescriptor CreateFontIndirectExA$descriptor() {
        return CreateFontIndirectExA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HFONT CreateFontIndirectExA(const ENUMLOGFONTEXDVA *)
     * }
     */
    public static MethodHandle CreateFontIndirectExA$handle() {
        return CreateFontIndirectExA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * HFONT CreateFontIndirectExA(const ENUMLOGFONTEXDVA *)
     * }
     */
    public static MemorySegment CreateFontIndirectExA(MemorySegment x0) {
        var mh$ = CreateFontIndirectExA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateFontIndirectExA", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateFontIndirectExW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CreateFontIndirectExW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HFONT CreateFontIndirectExW(const ENUMLOGFONTEXDVW *)
     * }
     */
    public static FunctionDescriptor CreateFontIndirectExW$descriptor() {
        return CreateFontIndirectExW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HFONT CreateFontIndirectExW(const ENUMLOGFONTEXDVW *)
     * }
     */
    public static MethodHandle CreateFontIndirectExW$handle() {
        return CreateFontIndirectExW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * HFONT CreateFontIndirectExW(const ENUMLOGFONTEXDVW *)
     * }
     */
    public static MemorySegment CreateFontIndirectExW(MemorySegment x0) {
        var mh$ = CreateFontIndirectExW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateFontIndirectExW", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct tagENUMTEXTMETRICA {
     *     NEWTEXTMETRICEXA etmNewTextMetricEx;
     *     AXESLISTA etmAxesList;
     * } *PENUMTEXTMETRICA
     * }
     */
    public static final AddressLayout PENUMTEXTMETRICA = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagENUMTEXTMETRICA {
     *     NEWTEXTMETRICEXA etmNewTextMetricEx;
     *     AXESLISTA etmAxesList;
     * } *LPENUMTEXTMETRICA
     * }
     */
    public static final AddressLayout LPENUMTEXTMETRICA = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagENUMTEXTMETRICW {
     *     NEWTEXTMETRICEXW etmNewTextMetricEx;
     *     AXESLISTW etmAxesList;
     * } *PENUMTEXTMETRICW
     * }
     */
    public static final AddressLayout PENUMTEXTMETRICW = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagENUMTEXTMETRICW {
     *     NEWTEXTMETRICEXW etmNewTextMetricEx;
     *     AXESLISTW etmAxesList;
     * } *LPENUMTEXTMETRICW
     * }
     */
    public static final AddressLayout LPENUMTEXTMETRICW = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef PENUMTEXTMETRICA PENUMTEXTMETRIC
     * }
     */
    public static final AddressLayout PENUMTEXTMETRIC = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef LPENUMTEXTMETRICA LPENUMTEXTMETRIC
     * }
     */
    public static final AddressLayout LPENUMTEXTMETRIC = C_POINTER;

    private static class GetViewportExtEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetViewportExtEx"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetViewportExtEx(HDC hdc, LPSIZE lpsize)
     * }
     */
    public static FunctionDescriptor GetViewportExtEx$descriptor() {
        return GetViewportExtEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetViewportExtEx(HDC hdc, LPSIZE lpsize)
     * }
     */
    public static MethodHandle GetViewportExtEx$handle() {
        return GetViewportExtEx.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL GetViewportExtEx(HDC hdc, LPSIZE lpsize)
     * }
     */
    public static int GetViewportExtEx(MemorySegment hdc, MemorySegment lpsize) {
        var mh$ = GetViewportExtEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetViewportExtEx", hdc, lpsize);
            }
            return (int)mh$.invokeExact(hdc, lpsize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetViewportOrgEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetViewportOrgEx"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetViewportOrgEx(HDC hdc, LPPOINT lppoint)
     * }
     */
    public static FunctionDescriptor GetViewportOrgEx$descriptor() {
        return GetViewportOrgEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetViewportOrgEx(HDC hdc, LPPOINT lppoint)
     * }
     */
    public static MethodHandle GetViewportOrgEx$handle() {
        return GetViewportOrgEx.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL GetViewportOrgEx(HDC hdc, LPPOINT lppoint)
     * }
     */
    public static int GetViewportOrgEx(MemorySegment hdc, MemorySegment lppoint) {
        var mh$ = GetViewportOrgEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetViewportOrgEx", hdc, lppoint);
            }
            return (int)mh$.invokeExact(hdc, lppoint);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetWindowExtEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetWindowExtEx"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetWindowExtEx(HDC hdc, LPSIZE lpsize)
     * }
     */
    public static FunctionDescriptor GetWindowExtEx$descriptor() {
        return GetWindowExtEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetWindowExtEx(HDC hdc, LPSIZE lpsize)
     * }
     */
    public static MethodHandle GetWindowExtEx$handle() {
        return GetWindowExtEx.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL GetWindowExtEx(HDC hdc, LPSIZE lpsize)
     * }
     */
    public static int GetWindowExtEx(MemorySegment hdc, MemorySegment lpsize) {
        var mh$ = GetWindowExtEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetWindowExtEx", hdc, lpsize);
            }
            return (int)mh$.invokeExact(hdc, lpsize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetWindowOrgEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetWindowOrgEx"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetWindowOrgEx(HDC hdc, LPPOINT lppoint)
     * }
     */
    public static FunctionDescriptor GetWindowOrgEx$descriptor() {
        return GetWindowOrgEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetWindowOrgEx(HDC hdc, LPPOINT lppoint)
     * }
     */
    public static MethodHandle GetWindowOrgEx$handle() {
        return GetWindowOrgEx.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL GetWindowOrgEx(HDC hdc, LPPOINT lppoint)
     * }
     */
    public static int GetWindowOrgEx(MemorySegment hdc, MemorySegment lppoint) {
        var mh$ = GetWindowOrgEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetWindowOrgEx", hdc, lppoint);
            }
            return (int)mh$.invokeExact(hdc, lppoint);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class IntersectClipRect {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_INT,
            C_INT,
            C_INT,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("IntersectClipRect"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int IntersectClipRect(HDC hdc, int left, int top, int right, int bottom)
     * }
     */
    public static FunctionDescriptor IntersectClipRect$descriptor() {
        return IntersectClipRect.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int IntersectClipRect(HDC hdc, int left, int top, int right, int bottom)
     * }
     */
    public static MethodHandle IntersectClipRect$handle() {
        return IntersectClipRect.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int IntersectClipRect(HDC hdc, int left, int top, int right, int bottom)
     * }
     */
    public static int IntersectClipRect(MemorySegment hdc, int left, int top, int right, int bottom) {
        var mh$ = IntersectClipRect.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("IntersectClipRect", hdc, left, top, right, bottom);
            }
            return (int)mh$.invokeExact(hdc, left, top, right, bottom);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class InvertRgn {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("InvertRgn"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL InvertRgn(HDC hdc, HRGN hrgn)
     * }
     */
    public static FunctionDescriptor InvertRgn$descriptor() {
        return InvertRgn.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL InvertRgn(HDC hdc, HRGN hrgn)
     * }
     */
    public static MethodHandle InvertRgn$handle() {
        return InvertRgn.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL InvertRgn(HDC hdc, HRGN hrgn)
     * }
     */
    public static int InvertRgn(MemorySegment hdc, MemorySegment hrgn) {
        var mh$ = InvertRgn.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("InvertRgn", hdc, hrgn);
            }
            return (int)mh$.invokeExact(hdc, hrgn);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LineDDA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_INT,
            C_INT,
            C_INT,
            C_INT,
            C_POINTER,
            C_LONG_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("LineDDA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL LineDDA(int xStart, int yStart, int xEnd, int yEnd, LINEDDAPROC lpProc, LPARAM data)
     * }
     */
    public static FunctionDescriptor LineDDA$descriptor() {
        return LineDDA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL LineDDA(int xStart, int yStart, int xEnd, int yEnd, LINEDDAPROC lpProc, LPARAM data)
     * }
     */
    public static MethodHandle LineDDA$handle() {
        return LineDDA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL LineDDA(int xStart, int yStart, int xEnd, int yEnd, LINEDDAPROC lpProc, LPARAM data)
     * }
     */
    public static int LineDDA(int xStart, int yStart, int xEnd, int yEnd, MemorySegment lpProc, long data) {
        var mh$ = LineDDA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LineDDA", xStart, yStart, xEnd, yEnd, lpProc, data);
            }
            return (int)mh$.invokeExact(xStart, yStart, xEnd, yEnd, lpProc, data);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LineTo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_INT,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("LineTo"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL LineTo(HDC hdc, int x, int y)
     * }
     */
    public static FunctionDescriptor LineTo$descriptor() {
        return LineTo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL LineTo(HDC hdc, int x, int y)
     * }
     */
    public static MethodHandle LineTo$handle() {
        return LineTo.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL LineTo(HDC hdc, int x, int y)
     * }
     */
    public static int LineTo(MemorySegment hdc, int x, int y) {
        var mh$ = LineTo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LineTo", hdc, x, y);
            }
            return (int)mh$.invokeExact(hdc, x, y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MaskBlt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_INT,
            C_INT,
            C_INT,
            C_INT,
            C_POINTER,
            C_INT,
            C_INT,
            C_POINTER,
            C_INT,
            C_INT,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("MaskBlt"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL MaskBlt(HDC hdcDest, int xDest, int yDest, int width, int height, HDC hdcSrc, int xSrc, int ySrc, HBITMAP hbmMask, int xMask, int yMask, DWORD rop)
     * }
     */
    public static FunctionDescriptor MaskBlt$descriptor() {
        return MaskBlt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL MaskBlt(HDC hdcDest, int xDest, int yDest, int width, int height, HDC hdcSrc, int xSrc, int ySrc, HBITMAP hbmMask, int xMask, int yMask, DWORD rop)
     * }
     */
    public static MethodHandle MaskBlt$handle() {
        return MaskBlt.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL MaskBlt(HDC hdcDest, int xDest, int yDest, int width, int height, HDC hdcSrc, int xSrc, int ySrc, HBITMAP hbmMask, int xMask, int yMask, DWORD rop)
     * }
     */
    public static int MaskBlt(MemorySegment hdcDest, int xDest, int yDest, int width, int height, MemorySegment hdcSrc, int xSrc, int ySrc, MemorySegment hbmMask, int xMask, int yMask, int rop) {
        var mh$ = MaskBlt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MaskBlt", hdcDest, xDest, yDest, width, height, hdcSrc, xSrc, ySrc, hbmMask, xMask, yMask, rop);
            }
            return (int)mh$.invokeExact(hdcDest, xDest, yDest, width, height, hdcSrc, xSrc, ySrc, hbmMask, xMask, yMask, rop);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PlgBlt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_INT,
            C_INT,
            C_INT,
            C_INT,
            C_POINTER,
            C_INT,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("PlgBlt"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL PlgBlt(HDC hdcDest, const POINT *lpPoint, HDC hdcSrc, int xSrc, int ySrc, int width, int height, HBITMAP hbmMask, int xMask, int yMask)
     * }
     */
    public static FunctionDescriptor PlgBlt$descriptor() {
        return PlgBlt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL PlgBlt(HDC hdcDest, const POINT *lpPoint, HDC hdcSrc, int xSrc, int ySrc, int width, int height, HBITMAP hbmMask, int xMask, int yMask)
     * }
     */
    public static MethodHandle PlgBlt$handle() {
        return PlgBlt.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL PlgBlt(HDC hdcDest, const POINT *lpPoint, HDC hdcSrc, int xSrc, int ySrc, int width, int height, HBITMAP hbmMask, int xMask, int yMask)
     * }
     */
    public static int PlgBlt(MemorySegment hdcDest, MemorySegment lpPoint, MemorySegment hdcSrc, int xSrc, int ySrc, int width, int height, MemorySegment hbmMask, int xMask, int yMask) {
        var mh$ = PlgBlt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PlgBlt", hdcDest, lpPoint, hdcSrc, xSrc, ySrc, width, height, hbmMask, xMask, yMask);
            }
            return (int)mh$.invokeExact(hdcDest, lpPoint, hdcSrc, xSrc, ySrc, width, height, hbmMask, xMask, yMask);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class OffsetClipRgn {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_INT,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("OffsetClipRgn"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int OffsetClipRgn(HDC hdc, int x, int y)
     * }
     */
    public static FunctionDescriptor OffsetClipRgn$descriptor() {
        return OffsetClipRgn.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int OffsetClipRgn(HDC hdc, int x, int y)
     * }
     */
    public static MethodHandle OffsetClipRgn$handle() {
        return OffsetClipRgn.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int OffsetClipRgn(HDC hdc, int x, int y)
     * }
     */
    public static int OffsetClipRgn(MemorySegment hdc, int x, int y) {
        var mh$ = OffsetClipRgn.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("OffsetClipRgn", hdc, x, y);
            }
            return (int)mh$.invokeExact(hdc, x, y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class OffsetRgn {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_INT,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("OffsetRgn"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int OffsetRgn(HRGN hrgn, int x, int y)
     * }
     */
    public static FunctionDescriptor OffsetRgn$descriptor() {
        return OffsetRgn.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int OffsetRgn(HRGN hrgn, int x, int y)
     * }
     */
    public static MethodHandle OffsetRgn$handle() {
        return OffsetRgn.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int OffsetRgn(HRGN hrgn, int x, int y)
     * }
     */
    public static int OffsetRgn(MemorySegment hrgn, int x, int y) {
        var mh$ = OffsetRgn.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("OffsetRgn", hrgn, x, y);
            }
            return (int)mh$.invokeExact(hrgn, x, y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PatBlt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_INT,
            C_INT,
            C_INT,
            C_INT,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("PatBlt"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL PatBlt(HDC hdc, int x, int y, int w, int h, DWORD rop)
     * }
     */
    public static FunctionDescriptor PatBlt$descriptor() {
        return PatBlt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL PatBlt(HDC hdc, int x, int y, int w, int h, DWORD rop)
     * }
     */
    public static MethodHandle PatBlt$handle() {
        return PatBlt.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL PatBlt(HDC hdc, int x, int y, int w, int h, DWORD rop)
     * }
     */
    public static int PatBlt(MemorySegment hdc, int x, int y, int w, int h, int rop) {
        var mh$ = PatBlt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PatBlt", hdc, x, y, w, h, rop);
            }
            return (int)mh$.invokeExact(hdc, x, y, w, h, rop);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Pie {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_INT,
            C_INT,
            C_INT,
            C_INT,
            C_INT,
            C_INT,
            C_INT,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("Pie"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL Pie(HDC hdc, int left, int top, int right, int bottom, int xr1, int yr1, int xr2, int yr2)
     * }
     */
    public static FunctionDescriptor Pie$descriptor() {
        return Pie.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL Pie(HDC hdc, int left, int top, int right, int bottom, int xr1, int yr1, int xr2, int yr2)
     * }
     */
    public static MethodHandle Pie$handle() {
        return Pie.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL Pie(HDC hdc, int left, int top, int right, int bottom, int xr1, int yr1, int xr2, int yr2)
     * }
     */
    public static int Pie(MemorySegment hdc, int left, int top, int right, int bottom, int xr1, int yr1, int xr2, int yr2) {
        var mh$ = Pie.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Pie", hdc, left, top, right, bottom, xr1, yr1, xr2, yr2);
            }
            return (int)mh$.invokeExact(hdc, left, top, right, bottom, xr1, yr1, xr2, yr2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PlayMetaFile {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("PlayMetaFile"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL PlayMetaFile(HDC hdc, HMETAFILE hmf)
     * }
     */
    public static FunctionDescriptor PlayMetaFile$descriptor() {
        return PlayMetaFile.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL PlayMetaFile(HDC hdc, HMETAFILE hmf)
     * }
     */
    public static MethodHandle PlayMetaFile$handle() {
        return PlayMetaFile.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL PlayMetaFile(HDC hdc, HMETAFILE hmf)
     * }
     */
    public static int PlayMetaFile(MemorySegment hdc, MemorySegment hmf) {
        var mh$ = PlayMetaFile.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PlayMetaFile", hdc, hmf);
            }
            return (int)mh$.invokeExact(hdc, hmf);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PaintRgn {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("PaintRgn"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL PaintRgn(HDC hdc, HRGN hrgn)
     * }
     */
    public static FunctionDescriptor PaintRgn$descriptor() {
        return PaintRgn.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL PaintRgn(HDC hdc, HRGN hrgn)
     * }
     */
    public static MethodHandle PaintRgn$handle() {
        return PaintRgn.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL PaintRgn(HDC hdc, HRGN hrgn)
     * }
     */
    public static int PaintRgn(MemorySegment hdc, MemorySegment hrgn) {
        var mh$ = PaintRgn.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PaintRgn", hdc, hrgn);
            }
            return (int)mh$.invokeExact(hdc, hrgn);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PolyPolygon {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("PolyPolygon"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL PolyPolygon(HDC hdc, const POINT *apt, const INT *asz, int csz)
     * }
     */
    public static FunctionDescriptor PolyPolygon$descriptor() {
        return PolyPolygon.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL PolyPolygon(HDC hdc, const POINT *apt, const INT *asz, int csz)
     * }
     */
    public static MethodHandle PolyPolygon$handle() {
        return PolyPolygon.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL PolyPolygon(HDC hdc, const POINT *apt, const INT *asz, int csz)
     * }
     */
    public static int PolyPolygon(MemorySegment hdc, MemorySegment apt, MemorySegment asz, int csz) {
        var mh$ = PolyPolygon.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PolyPolygon", hdc, apt, asz, csz);
            }
            return (int)mh$.invokeExact(hdc, apt, asz, csz);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PtInRegion {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_INT,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("PtInRegion"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL PtInRegion(HRGN hrgn, int x, int y)
     * }
     */
    public static FunctionDescriptor PtInRegion$descriptor() {
        return PtInRegion.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL PtInRegion(HRGN hrgn, int x, int y)
     * }
     */
    public static MethodHandle PtInRegion$handle() {
        return PtInRegion.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL PtInRegion(HRGN hrgn, int x, int y)
     * }
     */
    public static int PtInRegion(MemorySegment hrgn, int x, int y) {
        var mh$ = PtInRegion.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PtInRegion", hrgn, x, y);
            }
            return (int)mh$.invokeExact(hrgn, x, y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PtVisible {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_INT,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("PtVisible"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL PtVisible(HDC hdc, int x, int y)
     * }
     */
    public static FunctionDescriptor PtVisible$descriptor() {
        return PtVisible.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL PtVisible(HDC hdc, int x, int y)
     * }
     */
    public static MethodHandle PtVisible$handle() {
        return PtVisible.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL PtVisible(HDC hdc, int x, int y)
     * }
     */
    public static int PtVisible(MemorySegment hdc, int x, int y) {
        var mh$ = PtVisible.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PtVisible", hdc, x, y);
            }
            return (int)mh$.invokeExact(hdc, x, y);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RectInRegion {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("RectInRegion"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL RectInRegion(HRGN hrgn, const RECT *lprect)
     * }
     */
    public static FunctionDescriptor RectInRegion$descriptor() {
        return RectInRegion.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL RectInRegion(HRGN hrgn, const RECT *lprect)
     * }
     */
    public static MethodHandle RectInRegion$handle() {
        return RectInRegion.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL RectInRegion(HRGN hrgn, const RECT *lprect)
     * }
     */
    public static int RectInRegion(MemorySegment hrgn, MemorySegment lprect) {
        var mh$ = RectInRegion.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RectInRegion", hrgn, lprect);
            }
            return (int)mh$.invokeExact(hrgn, lprect);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RectVisible {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("RectVisible"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL RectVisible(HDC hdc, const RECT *lprect)
     * }
     */
    public static FunctionDescriptor RectVisible$descriptor() {
        return RectVisible.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL RectVisible(HDC hdc, const RECT *lprect)
     * }
     */
    public static MethodHandle RectVisible$handle() {
        return RectVisible.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL RectVisible(HDC hdc, const RECT *lprect)
     * }
     */
    public static int RectVisible(MemorySegment hdc, MemorySegment lprect) {
        var mh$ = RectVisible.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RectVisible", hdc, lprect);
            }
            return (int)mh$.invokeExact(hdc, lprect);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Rectangle {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_INT,
            C_INT,
            C_INT,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("Rectangle"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL Rectangle(HDC hdc, int left, int top, int right, int bottom)
     * }
     */
    public static FunctionDescriptor Rectangle$descriptor() {
        return Rectangle.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL Rectangle(HDC hdc, int left, int top, int right, int bottom)
     * }
     */
    public static MethodHandle Rectangle$handle() {
        return Rectangle.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL Rectangle(HDC hdc, int left, int top, int right, int bottom)
     * }
     */
    public static int Rectangle(MemorySegment hdc, int left, int top, int right, int bottom) {
        var mh$ = Rectangle.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Rectangle", hdc, left, top, right, bottom);
            }
            return (int)mh$.invokeExact(hdc, left, top, right, bottom);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RestoreDC {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("RestoreDC"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL RestoreDC(HDC hdc, int nSavedDC)
     * }
     */
    public static FunctionDescriptor RestoreDC$descriptor() {
        return RestoreDC.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL RestoreDC(HDC hdc, int nSavedDC)
     * }
     */
    public static MethodHandle RestoreDC$handle() {
        return RestoreDC.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL RestoreDC(HDC hdc, int nSavedDC)
     * }
     */
    public static int RestoreDC(MemorySegment hdc, int nSavedDC) {
        var mh$ = RestoreDC.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RestoreDC", hdc, nSavedDC);
            }
            return (int)mh$.invokeExact(hdc, nSavedDC);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ResetDCA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("ResetDCA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HDC ResetDCA(HDC hdc, const DEVMODEA *lpdm)
     * }
     */
    public static FunctionDescriptor ResetDCA$descriptor() {
        return ResetDCA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HDC ResetDCA(HDC hdc, const DEVMODEA *lpdm)
     * }
     */
    public static MethodHandle ResetDCA$handle() {
        return ResetDCA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * HDC ResetDCA(HDC hdc, const DEVMODEA *lpdm)
     * }
     */
    public static MemorySegment ResetDCA(MemorySegment hdc, MemorySegment lpdm) {
        var mh$ = ResetDCA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ResetDCA", hdc, lpdm);
            }
            return (MemorySegment)mh$.invokeExact(hdc, lpdm);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ResetDCW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("ResetDCW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HDC ResetDCW(HDC hdc, const DEVMODEW *lpdm)
     * }
     */
    public static FunctionDescriptor ResetDCW$descriptor() {
        return ResetDCW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HDC ResetDCW(HDC hdc, const DEVMODEW *lpdm)
     * }
     */
    public static MethodHandle ResetDCW$handle() {
        return ResetDCW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * HDC ResetDCW(HDC hdc, const DEVMODEW *lpdm)
     * }
     */
    public static MemorySegment ResetDCW(MemorySegment hdc, MemorySegment lpdm) {
        var mh$ = ResetDCW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ResetDCW", hdc, lpdm);
            }
            return (MemorySegment)mh$.invokeExact(hdc, lpdm);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RealizePalette {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("RealizePalette"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * UINT RealizePalette(HDC hdc)
     * }
     */
    public static FunctionDescriptor RealizePalette$descriptor() {
        return RealizePalette.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * UINT RealizePalette(HDC hdc)
     * }
     */
    public static MethodHandle RealizePalette$handle() {
        return RealizePalette.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * UINT RealizePalette(HDC hdc)
     * }
     */
    public static int RealizePalette(MemorySegment hdc) {
        var mh$ = RealizePalette.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RealizePalette", hdc);
            }
            return (int)mh$.invokeExact(hdc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RemoveFontResourceA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("RemoveFontResourceA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL RemoveFontResourceA(LPCSTR lpFileName)
     * }
     */
    public static FunctionDescriptor RemoveFontResourceA$descriptor() {
        return RemoveFontResourceA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL RemoveFontResourceA(LPCSTR lpFileName)
     * }
     */
    public static MethodHandle RemoveFontResourceA$handle() {
        return RemoveFontResourceA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL RemoveFontResourceA(LPCSTR lpFileName)
     * }
     */
    public static int RemoveFontResourceA(MemorySegment lpFileName) {
        var mh$ = RemoveFontResourceA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RemoveFontResourceA", lpFileName);
            }
            return (int)mh$.invokeExact(lpFileName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RemoveFontResourceW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("RemoveFontResourceW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL RemoveFontResourceW(LPCWSTR lpFileName)
     * }
     */
    public static FunctionDescriptor RemoveFontResourceW$descriptor() {
        return RemoveFontResourceW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL RemoveFontResourceW(LPCWSTR lpFileName)
     * }
     */
    public static MethodHandle RemoveFontResourceW$handle() {
        return RemoveFontResourceW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL RemoveFontResourceW(LPCWSTR lpFileName)
     * }
     */
    public static int RemoveFontResourceW(MemorySegment lpFileName) {
        var mh$ = RemoveFontResourceW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RemoveFontResourceW", lpFileName);
            }
            return (int)mh$.invokeExact(lpFileName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RoundRect {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_INT,
            C_INT,
            C_INT,
            C_INT,
            C_INT,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("RoundRect"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL RoundRect(HDC hdc, int left, int top, int right, int bottom, int width, int height)
     * }
     */
    public static FunctionDescriptor RoundRect$descriptor() {
        return RoundRect.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL RoundRect(HDC hdc, int left, int top, int right, int bottom, int width, int height)
     * }
     */
    public static MethodHandle RoundRect$handle() {
        return RoundRect.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL RoundRect(HDC hdc, int left, int top, int right, int bottom, int width, int height)
     * }
     */
    public static int RoundRect(MemorySegment hdc, int left, int top, int right, int bottom, int width, int height) {
        var mh$ = RoundRect.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RoundRect", hdc, left, top, right, bottom, width, height);
            }
            return (int)mh$.invokeExact(hdc, left, top, right, bottom, width, height);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ResizePalette {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("ResizePalette"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL ResizePalette(HPALETTE hpal, UINT n)
     * }
     */
    public static FunctionDescriptor ResizePalette$descriptor() {
        return ResizePalette.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL ResizePalette(HPALETTE hpal, UINT n)
     * }
     */
    public static MethodHandle ResizePalette$handle() {
        return ResizePalette.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL ResizePalette(HPALETTE hpal, UINT n)
     * }
     */
    public static int ResizePalette(MemorySegment hpal, int n) {
        var mh$ = ResizePalette.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ResizePalette", hpal, n);
            }
            return (int)mh$.invokeExact(hpal, n);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SaveDC {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("SaveDC"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SaveDC(HDC hdc)
     * }
     */
    public static FunctionDescriptor SaveDC$descriptor() {
        return SaveDC.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SaveDC(HDC hdc)
     * }
     */
    public static MethodHandle SaveDC$handle() {
        return SaveDC.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int SaveDC(HDC hdc)
     * }
     */
    public static int SaveDC(MemorySegment hdc) {
        var mh$ = SaveDC.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SaveDC", hdc);
            }
            return (int)mh$.invokeExact(hdc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SelectClipRgn {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("SelectClipRgn"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SelectClipRgn(HDC hdc, HRGN hrgn)
     * }
     */
    public static FunctionDescriptor SelectClipRgn$descriptor() {
        return SelectClipRgn.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SelectClipRgn(HDC hdc, HRGN hrgn)
     * }
     */
    public static MethodHandle SelectClipRgn$handle() {
        return SelectClipRgn.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int SelectClipRgn(HDC hdc, HRGN hrgn)
     * }
     */
    public static int SelectClipRgn(MemorySegment hdc, MemorySegment hrgn) {
        var mh$ = SelectClipRgn.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SelectClipRgn", hdc, hrgn);
            }
            return (int)mh$.invokeExact(hdc, hrgn);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ExtSelectClipRgn {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("ExtSelectClipRgn"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int ExtSelectClipRgn(HDC hdc, HRGN hrgn, int mode)
     * }
     */
    public static FunctionDescriptor ExtSelectClipRgn$descriptor() {
        return ExtSelectClipRgn.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int ExtSelectClipRgn(HDC hdc, HRGN hrgn, int mode)
     * }
     */
    public static MethodHandle ExtSelectClipRgn$handle() {
        return ExtSelectClipRgn.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int ExtSelectClipRgn(HDC hdc, HRGN hrgn, int mode)
     * }
     */
    public static int ExtSelectClipRgn(MemorySegment hdc, MemorySegment hrgn, int mode) {
        var mh$ = ExtSelectClipRgn.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ExtSelectClipRgn", hdc, hrgn, mode);
            }
            return (int)mh$.invokeExact(hdc, hrgn, mode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetMetaRgn {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("SetMetaRgn"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SetMetaRgn(HDC hdc)
     * }
     */
    public static FunctionDescriptor SetMetaRgn$descriptor() {
        return SetMetaRgn.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SetMetaRgn(HDC hdc)
     * }
     */
    public static MethodHandle SetMetaRgn$handle() {
        return SetMetaRgn.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int SetMetaRgn(HDC hdc)
     * }
     */
    public static int SetMetaRgn(MemorySegment hdc) {
        var mh$ = SetMetaRgn.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetMetaRgn", hdc);
            }
            return (int)mh$.invokeExact(hdc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SelectObject {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("SelectObject"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HGDIOBJ SelectObject(HDC hdc, HGDIOBJ h)
     * }
     */
    public static FunctionDescriptor SelectObject$descriptor() {
        return SelectObject.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HGDIOBJ SelectObject(HDC hdc, HGDIOBJ h)
     * }
     */
    public static MethodHandle SelectObject$handle() {
        return SelectObject.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * HGDIOBJ SelectObject(HDC hdc, HGDIOBJ h)
     * }
     */
    public static MemorySegment SelectObject(MemorySegment hdc, MemorySegment h) {
        var mh$ = SelectObject.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SelectObject", hdc, h);
            }
            return (MemorySegment)mh$.invokeExact(hdc, h);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SelectPalette {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("SelectPalette"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HPALETTE SelectPalette(HDC hdc, HPALETTE hPal, BOOL bForceBkgd)
     * }
     */
    public static FunctionDescriptor SelectPalette$descriptor() {
        return SelectPalette.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HPALETTE SelectPalette(HDC hdc, HPALETTE hPal, BOOL bForceBkgd)
     * }
     */
    public static MethodHandle SelectPalette$handle() {
        return SelectPalette.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * HPALETTE SelectPalette(HDC hdc, HPALETTE hPal, BOOL bForceBkgd)
     * }
     */
    public static MemorySegment SelectPalette(MemorySegment hdc, MemorySegment hPal, int bForceBkgd) {
        var mh$ = SelectPalette.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SelectPalette", hdc, hPal, bForceBkgd);
            }
            return (MemorySegment)mh$.invokeExact(hdc, hPal, bForceBkgd);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetBkColor {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_POINTER,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("SetBkColor"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * COLORREF SetBkColor(HDC hdc, COLORREF color)
     * }
     */
    public static FunctionDescriptor SetBkColor$descriptor() {
        return SetBkColor.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * COLORREF SetBkColor(HDC hdc, COLORREF color)
     * }
     */
    public static MethodHandle SetBkColor$handle() {
        return SetBkColor.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * COLORREF SetBkColor(HDC hdc, COLORREF color)
     * }
     */
    public static int SetBkColor(MemorySegment hdc, int color) {
        var mh$ = SetBkColor.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetBkColor", hdc, color);
            }
            return (int)mh$.invokeExact(hdc, color);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetDCBrushColor {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_POINTER,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("SetDCBrushColor"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * COLORREF SetDCBrushColor(HDC hdc, COLORREF color)
     * }
     */
    public static FunctionDescriptor SetDCBrushColor$descriptor() {
        return SetDCBrushColor.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * COLORREF SetDCBrushColor(HDC hdc, COLORREF color)
     * }
     */
    public static MethodHandle SetDCBrushColor$handle() {
        return SetDCBrushColor.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * COLORREF SetDCBrushColor(HDC hdc, COLORREF color)
     * }
     */
    public static int SetDCBrushColor(MemorySegment hdc, int color) {
        var mh$ = SetDCBrushColor.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetDCBrushColor", hdc, color);
            }
            return (int)mh$.invokeExact(hdc, color);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetDCPenColor {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_POINTER,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("SetDCPenColor"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * COLORREF SetDCPenColor(HDC hdc, COLORREF color)
     * }
     */
    public static FunctionDescriptor SetDCPenColor$descriptor() {
        return SetDCPenColor.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * COLORREF SetDCPenColor(HDC hdc, COLORREF color)
     * }
     */
    public static MethodHandle SetDCPenColor$handle() {
        return SetDCPenColor.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * COLORREF SetDCPenColor(HDC hdc, COLORREF color)
     * }
     */
    public static int SetDCPenColor(MemorySegment hdc, int color) {
        var mh$ = SetDCPenColor.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetDCPenColor", hdc, color);
            }
            return (int)mh$.invokeExact(hdc, color);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetBkMode {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("SetBkMode"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SetBkMode(HDC hdc, int mode)
     * }
     */
    public static FunctionDescriptor SetBkMode$descriptor() {
        return SetBkMode.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SetBkMode(HDC hdc, int mode)
     * }
     */
    public static MethodHandle SetBkMode$handle() {
        return SetBkMode.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int SetBkMode(HDC hdc, int mode)
     * }
     */
    public static int SetBkMode(MemorySegment hdc, int mode) {
        var mh$ = SetBkMode.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetBkMode", hdc, mode);
            }
            return (int)mh$.invokeExact(hdc, mode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetBitmapBits {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_POINTER,
            C_LONG,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("SetBitmapBits"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LONG SetBitmapBits(HBITMAP hbm, DWORD cb, const void *pvBits)
     * }
     */
    public static FunctionDescriptor SetBitmapBits$descriptor() {
        return SetBitmapBits.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LONG SetBitmapBits(HBITMAP hbm, DWORD cb, const void *pvBits)
     * }
     */
    public static MethodHandle SetBitmapBits$handle() {
        return SetBitmapBits.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * LONG SetBitmapBits(HBITMAP hbm, DWORD cb, const void *pvBits)
     * }
     */
    public static int SetBitmapBits(MemorySegment hbm, int cb, MemorySegment pvBits) {
        var mh$ = SetBitmapBits.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetBitmapBits", hbm, cb, pvBits);
            }
            return (int)mh$.invokeExact(hbm, cb, pvBits);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetBoundsRect {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("SetBoundsRect"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * UINT SetBoundsRect(HDC hdc, const RECT *lprect, UINT flags)
     * }
     */
    public static FunctionDescriptor SetBoundsRect$descriptor() {
        return SetBoundsRect.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * UINT SetBoundsRect(HDC hdc, const RECT *lprect, UINT flags)
     * }
     */
    public static MethodHandle SetBoundsRect$handle() {
        return SetBoundsRect.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * UINT SetBoundsRect(HDC hdc, const RECT *lprect, UINT flags)
     * }
     */
    public static int SetBoundsRect(MemorySegment hdc, MemorySegment lprect, int flags) {
        var mh$ = SetBoundsRect.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetBoundsRect", hdc, lprect, flags);
            }
            return (int)mh$.invokeExact(hdc, lprect, flags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetDIBits {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_INT,
            C_INT,
            C_POINTER,
            C_POINTER,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("SetDIBits"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SetDIBits(HDC hdc, HBITMAP hbm, UINT start, UINT cLines, const void *lpBits, const BITMAPINFO *lpbmi, UINT ColorUse)
     * }
     */
    public static FunctionDescriptor SetDIBits$descriptor() {
        return SetDIBits.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SetDIBits(HDC hdc, HBITMAP hbm, UINT start, UINT cLines, const void *lpBits, const BITMAPINFO *lpbmi, UINT ColorUse)
     * }
     */
    public static MethodHandle SetDIBits$handle() {
        return SetDIBits.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int SetDIBits(HDC hdc, HBITMAP hbm, UINT start, UINT cLines, const void *lpBits, const BITMAPINFO *lpbmi, UINT ColorUse)
     * }
     */
    public static int SetDIBits(MemorySegment hdc, MemorySegment hbm, int start, int cLines, MemorySegment lpBits, MemorySegment lpbmi, int ColorUse) {
        var mh$ = SetDIBits.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetDIBits", hdc, hbm, start, cLines, lpBits, lpbmi, ColorUse);
            }
            return (int)mh$.invokeExact(hdc, hbm, start, cLines, lpBits, lpbmi, ColorUse);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetDIBitsToDevice {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_INT,
            C_INT,
            C_LONG,
            C_LONG,
            C_INT,
            C_INT,
            C_INT,
            C_INT,
            C_POINTER,
            C_POINTER,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("SetDIBitsToDevice"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SetDIBitsToDevice(HDC hdc, int xDest, int yDest, DWORD w, DWORD h, int xSrc, int ySrc, UINT StartScan, UINT cLines, const void *lpvBits, const BITMAPINFO *lpbmi, UINT ColorUse)
     * }
     */
    public static FunctionDescriptor SetDIBitsToDevice$descriptor() {
        return SetDIBitsToDevice.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SetDIBitsToDevice(HDC hdc, int xDest, int yDest, DWORD w, DWORD h, int xSrc, int ySrc, UINT StartScan, UINT cLines, const void *lpvBits, const BITMAPINFO *lpbmi, UINT ColorUse)
     * }
     */
    public static MethodHandle SetDIBitsToDevice$handle() {
        return SetDIBitsToDevice.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int SetDIBitsToDevice(HDC hdc, int xDest, int yDest, DWORD w, DWORD h, int xSrc, int ySrc, UINT StartScan, UINT cLines, const void *lpvBits, const BITMAPINFO *lpbmi, UINT ColorUse)
     * }
     */
    public static int SetDIBitsToDevice(MemorySegment hdc, int xDest, int yDest, int w, int h, int xSrc, int ySrc, int StartScan, int cLines, MemorySegment lpvBits, MemorySegment lpbmi, int ColorUse) {
        var mh$ = SetDIBitsToDevice.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetDIBitsToDevice", hdc, xDest, yDest, w, h, xSrc, ySrc, StartScan, cLines, lpvBits, lpbmi, ColorUse);
            }
            return (int)mh$.invokeExact(hdc, xDest, yDest, w, h, xSrc, ySrc, StartScan, cLines, lpvBits, lpbmi, ColorUse);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetMapperFlags {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_POINTER,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("SetMapperFlags"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD SetMapperFlags(HDC hdc, DWORD flags)
     * }
     */
    public static FunctionDescriptor SetMapperFlags$descriptor() {
        return SetMapperFlags.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD SetMapperFlags(HDC hdc, DWORD flags)
     * }
     */
    public static MethodHandle SetMapperFlags$handle() {
        return SetMapperFlags.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * DWORD SetMapperFlags(HDC hdc, DWORD flags)
     * }
     */
    public static int SetMapperFlags(MemorySegment hdc, int flags) {
        var mh$ = SetMapperFlags.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetMapperFlags", hdc, flags);
            }
            return (int)mh$.invokeExact(hdc, flags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetGraphicsMode {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("SetGraphicsMode"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SetGraphicsMode(HDC hdc, int iMode)
     * }
     */
    public static FunctionDescriptor SetGraphicsMode$descriptor() {
        return SetGraphicsMode.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SetGraphicsMode(HDC hdc, int iMode)
     * }
     */
    public static MethodHandle SetGraphicsMode$handle() {
        return SetGraphicsMode.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int SetGraphicsMode(HDC hdc, int iMode)
     * }
     */
    public static int SetGraphicsMode(MemorySegment hdc, int iMode) {
        var mh$ = SetGraphicsMode.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetGraphicsMode", hdc, iMode);
            }
            return (int)mh$.invokeExact(hdc, iMode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetMapMode {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("SetMapMode"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SetMapMode(HDC hdc, int iMode)
     * }
     */
    public static FunctionDescriptor SetMapMode$descriptor() {
        return SetMapMode.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SetMapMode(HDC hdc, int iMode)
     * }
     */
    public static MethodHandle SetMapMode$handle() {
        return SetMapMode.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int SetMapMode(HDC hdc, int iMode)
     * }
     */
    public static int SetMapMode(MemorySegment hdc, int iMode) {
        var mh$ = SetMapMode.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetMapMode", hdc, iMode);
            }
            return (int)mh$.invokeExact(hdc, iMode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetLayout {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_POINTER,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("SetLayout"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD SetLayout(HDC hdc, DWORD l)
     * }
     */
    public static FunctionDescriptor SetLayout$descriptor() {
        return SetLayout.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD SetLayout(HDC hdc, DWORD l)
     * }
     */
    public static MethodHandle SetLayout$handle() {
        return SetLayout.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * DWORD SetLayout(HDC hdc, DWORD l)
     * }
     */
    public static int SetLayout(MemorySegment hdc, int l) {
        var mh$ = SetLayout.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetLayout", hdc, l);
            }
            return (int)mh$.invokeExact(hdc, l);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetLayout {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetLayout"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetLayout(HDC hdc)
     * }
     */
    public static FunctionDescriptor GetLayout$descriptor() {
        return GetLayout.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetLayout(HDC hdc)
     * }
     */
    public static MethodHandle GetLayout$handle() {
        return GetLayout.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * DWORD GetLayout(HDC hdc)
     * }
     */
    public static int GetLayout(MemorySegment hdc) {
        var mh$ = GetLayout.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetLayout", hdc);
            }
            return (int)mh$.invokeExact(hdc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetMetaFileBitsEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("SetMetaFileBitsEx"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HMETAFILE SetMetaFileBitsEx(UINT cbBuffer, const BYTE *lpData)
     * }
     */
    public static FunctionDescriptor SetMetaFileBitsEx$descriptor() {
        return SetMetaFileBitsEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HMETAFILE SetMetaFileBitsEx(UINT cbBuffer, const BYTE *lpData)
     * }
     */
    public static MethodHandle SetMetaFileBitsEx$handle() {
        return SetMetaFileBitsEx.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * HMETAFILE SetMetaFileBitsEx(UINT cbBuffer, const BYTE *lpData)
     * }
     */
    public static MemorySegment SetMetaFileBitsEx(int cbBuffer, MemorySegment lpData) {
        var mh$ = SetMetaFileBitsEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetMetaFileBitsEx", cbBuffer, lpData);
            }
            return (MemorySegment)mh$.invokeExact(cbBuffer, lpData);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetPaletteEntries {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_INT,
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("SetPaletteEntries"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * UINT SetPaletteEntries(HPALETTE hpal, UINT iStart, UINT cEntries, const PALETTEENTRY *pPalEntries)
     * }
     */
    public static FunctionDescriptor SetPaletteEntries$descriptor() {
        return SetPaletteEntries.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * UINT SetPaletteEntries(HPALETTE hpal, UINT iStart, UINT cEntries, const PALETTEENTRY *pPalEntries)
     * }
     */
    public static MethodHandle SetPaletteEntries$handle() {
        return SetPaletteEntries.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * UINT SetPaletteEntries(HPALETTE hpal, UINT iStart, UINT cEntries, const PALETTEENTRY *pPalEntries)
     * }
     */
    public static int SetPaletteEntries(MemorySegment hpal, int iStart, int cEntries, MemorySegment pPalEntries) {
        var mh$ = SetPaletteEntries.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetPaletteEntries", hpal, iStart, cEntries, pPalEntries);
            }
            return (int)mh$.invokeExact(hpal, iStart, cEntries, pPalEntries);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetPixel {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_POINTER,
            C_INT,
            C_INT,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("SetPixel"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * COLORREF SetPixel(HDC hdc, int x, int y, COLORREF color)
     * }
     */
    public static FunctionDescriptor SetPixel$descriptor() {
        return SetPixel.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * COLORREF SetPixel(HDC hdc, int x, int y, COLORREF color)
     * }
     */
    public static MethodHandle SetPixel$handle() {
        return SetPixel.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * COLORREF SetPixel(HDC hdc, int x, int y, COLORREF color)
     * }
     */
    public static int SetPixel(MemorySegment hdc, int x, int y, int color) {
        var mh$ = SetPixel.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetPixel", hdc, x, y, color);
            }
            return (int)mh$.invokeExact(hdc, x, y, color);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetPixelV {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_INT,
            C_INT,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("SetPixelV"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetPixelV(HDC hdc, int x, int y, COLORREF color)
     * }
     */
    public static FunctionDescriptor SetPixelV$descriptor() {
        return SetPixelV.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetPixelV(HDC hdc, int x, int y, COLORREF color)
     * }
     */
    public static MethodHandle SetPixelV$handle() {
        return SetPixelV.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL SetPixelV(HDC hdc, int x, int y, COLORREF color)
     * }
     */
    public static int SetPixelV(MemorySegment hdc, int x, int y, int color) {
        var mh$ = SetPixelV.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetPixelV", hdc, x, y, color);
            }
            return (int)mh$.invokeExact(hdc, x, y, color);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetPixelFormat {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("SetPixelFormat"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetPixelFormat(HDC hdc, int format, const PIXELFORMATDESCRIPTOR *ppfd)
     * }
     */
    public static FunctionDescriptor SetPixelFormat$descriptor() {
        return SetPixelFormat.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetPixelFormat(HDC hdc, int format, const PIXELFORMATDESCRIPTOR *ppfd)
     * }
     */
    public static MethodHandle SetPixelFormat$handle() {
        return SetPixelFormat.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL SetPixelFormat(HDC hdc, int format, const PIXELFORMATDESCRIPTOR *ppfd)
     * }
     */
    public static int SetPixelFormat(MemorySegment hdc, int format, MemorySegment ppfd) {
        var mh$ = SetPixelFormat.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetPixelFormat", hdc, format, ppfd);
            }
            return (int)mh$.invokeExact(hdc, format, ppfd);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetPolyFillMode {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("SetPolyFillMode"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SetPolyFillMode(HDC hdc, int mode)
     * }
     */
    public static FunctionDescriptor SetPolyFillMode$descriptor() {
        return SetPolyFillMode.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SetPolyFillMode(HDC hdc, int mode)
     * }
     */
    public static MethodHandle SetPolyFillMode$handle() {
        return SetPolyFillMode.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int SetPolyFillMode(HDC hdc, int mode)
     * }
     */
    public static int SetPolyFillMode(MemorySegment hdc, int mode) {
        var mh$ = SetPolyFillMode.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetPolyFillMode", hdc, mode);
            }
            return (int)mh$.invokeExact(hdc, mode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class StretchBlt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_INT,
            C_INT,
            C_INT,
            C_INT,
            C_POINTER,
            C_INT,
            C_INT,
            C_INT,
            C_INT,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("StretchBlt"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL StretchBlt(HDC hdcDest, int xDest, int yDest, int wDest, int hDest, HDC hdcSrc, int xSrc, int ySrc, int wSrc, int hSrc, DWORD rop)
     * }
     */
    public static FunctionDescriptor StretchBlt$descriptor() {
        return StretchBlt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL StretchBlt(HDC hdcDest, int xDest, int yDest, int wDest, int hDest, HDC hdcSrc, int xSrc, int ySrc, int wSrc, int hSrc, DWORD rop)
     * }
     */
    public static MethodHandle StretchBlt$handle() {
        return StretchBlt.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL StretchBlt(HDC hdcDest, int xDest, int yDest, int wDest, int hDest, HDC hdcSrc, int xSrc, int ySrc, int wSrc, int hSrc, DWORD rop)
     * }
     */
    public static int StretchBlt(MemorySegment hdcDest, int xDest, int yDest, int wDest, int hDest, MemorySegment hdcSrc, int xSrc, int ySrc, int wSrc, int hSrc, int rop) {
        var mh$ = StretchBlt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("StretchBlt", hdcDest, xDest, yDest, wDest, hDest, hdcSrc, xSrc, ySrc, wSrc, hSrc, rop);
            }
            return (int)mh$.invokeExact(hdcDest, xDest, yDest, wDest, hDest, hdcSrc, xSrc, ySrc, wSrc, hSrc, rop);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetRectRgn {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_INT,
            C_INT,
            C_INT,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("SetRectRgn"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetRectRgn(HRGN hrgn, int left, int top, int right, int bottom)
     * }
     */
    public static FunctionDescriptor SetRectRgn$descriptor() {
        return SetRectRgn.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetRectRgn(HRGN hrgn, int left, int top, int right, int bottom)
     * }
     */
    public static MethodHandle SetRectRgn$handle() {
        return SetRectRgn.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL SetRectRgn(HRGN hrgn, int left, int top, int right, int bottom)
     * }
     */
    public static int SetRectRgn(MemorySegment hrgn, int left, int top, int right, int bottom) {
        var mh$ = SetRectRgn.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetRectRgn", hrgn, left, top, right, bottom);
            }
            return (int)mh$.invokeExact(hrgn, left, top, right, bottom);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class StretchDIBits {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_INT,
            C_INT,
            C_INT,
            C_INT,
            C_INT,
            C_INT,
            C_INT,
            C_INT,
            C_POINTER,
            C_POINTER,
            C_INT,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("StretchDIBits"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int StretchDIBits(HDC hdc, int xDest, int yDest, int DestWidth, int DestHeight, int xSrc, int ySrc, int SrcWidth, int SrcHeight, const void *lpBits, const BITMAPINFO *lpbmi, UINT iUsage, DWORD rop)
     * }
     */
    public static FunctionDescriptor StretchDIBits$descriptor() {
        return StretchDIBits.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int StretchDIBits(HDC hdc, int xDest, int yDest, int DestWidth, int DestHeight, int xSrc, int ySrc, int SrcWidth, int SrcHeight, const void *lpBits, const BITMAPINFO *lpbmi, UINT iUsage, DWORD rop)
     * }
     */
    public static MethodHandle StretchDIBits$handle() {
        return StretchDIBits.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int StretchDIBits(HDC hdc, int xDest, int yDest, int DestWidth, int DestHeight, int xSrc, int ySrc, int SrcWidth, int SrcHeight, const void *lpBits, const BITMAPINFO *lpbmi, UINT iUsage, DWORD rop)
     * }
     */
    public static int StretchDIBits(MemorySegment hdc, int xDest, int yDest, int DestWidth, int DestHeight, int xSrc, int ySrc, int SrcWidth, int SrcHeight, MemorySegment lpBits, MemorySegment lpbmi, int iUsage, int rop) {
        var mh$ = StretchDIBits.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("StretchDIBits", hdc, xDest, yDest, DestWidth, DestHeight, xSrc, ySrc, SrcWidth, SrcHeight, lpBits, lpbmi, iUsage, rop);
            }
            return (int)mh$.invokeExact(hdc, xDest, yDest, DestWidth, DestHeight, xSrc, ySrc, SrcWidth, SrcHeight, lpBits, lpbmi, iUsage, rop);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetROP2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("SetROP2"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SetROP2(HDC hdc, int rop2)
     * }
     */
    public static FunctionDescriptor SetROP2$descriptor() {
        return SetROP2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SetROP2(HDC hdc, int rop2)
     * }
     */
    public static MethodHandle SetROP2$handle() {
        return SetROP2.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int SetROP2(HDC hdc, int rop2)
     * }
     */
    public static int SetROP2(MemorySegment hdc, int rop2) {
        var mh$ = SetROP2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetROP2", hdc, rop2);
            }
            return (int)mh$.invokeExact(hdc, rop2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetStretchBltMode {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("SetStretchBltMode"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SetStretchBltMode(HDC hdc, int mode)
     * }
     */
    public static FunctionDescriptor SetStretchBltMode$descriptor() {
        return SetStretchBltMode.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SetStretchBltMode(HDC hdc, int mode)
     * }
     */
    public static MethodHandle SetStretchBltMode$handle() {
        return SetStretchBltMode.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int SetStretchBltMode(HDC hdc, int mode)
     * }
     */
    public static int SetStretchBltMode(MemorySegment hdc, int mode) {
        var mh$ = SetStretchBltMode.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetStretchBltMode", hdc, mode);
            }
            return (int)mh$.invokeExact(hdc, mode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetSystemPaletteUse {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("SetSystemPaletteUse"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * UINT SetSystemPaletteUse(HDC hdc, UINT use)
     * }
     */
    public static FunctionDescriptor SetSystemPaletteUse$descriptor() {
        return SetSystemPaletteUse.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * UINT SetSystemPaletteUse(HDC hdc, UINT use)
     * }
     */
    public static MethodHandle SetSystemPaletteUse$handle() {
        return SetSystemPaletteUse.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * UINT SetSystemPaletteUse(HDC hdc, UINT use)
     * }
     */
    public static int SetSystemPaletteUse(MemorySegment hdc, int use) {
        var mh$ = SetSystemPaletteUse.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetSystemPaletteUse", hdc, use);
            }
            return (int)mh$.invokeExact(hdc, use);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetTextCharacterExtra {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("SetTextCharacterExtra"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SetTextCharacterExtra(HDC hdc, int extra)
     * }
     */
    public static FunctionDescriptor SetTextCharacterExtra$descriptor() {
        return SetTextCharacterExtra.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SetTextCharacterExtra(HDC hdc, int extra)
     * }
     */
    public static MethodHandle SetTextCharacterExtra$handle() {
        return SetTextCharacterExtra.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int SetTextCharacterExtra(HDC hdc, int extra)
     * }
     */
    public static int SetTextCharacterExtra(MemorySegment hdc, int extra) {
        var mh$ = SetTextCharacterExtra.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetTextCharacterExtra", hdc, extra);
            }
            return (int)mh$.invokeExact(hdc, extra);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetTextColor {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_POINTER,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("SetTextColor"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * COLORREF SetTextColor(HDC hdc, COLORREF color)
     * }
     */
    public static FunctionDescriptor SetTextColor$descriptor() {
        return SetTextColor.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * COLORREF SetTextColor(HDC hdc, COLORREF color)
     * }
     */
    public static MethodHandle SetTextColor$handle() {
        return SetTextColor.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * COLORREF SetTextColor(HDC hdc, COLORREF color)
     * }
     */
    public static int SetTextColor(MemorySegment hdc, int color) {
        var mh$ = SetTextColor.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetTextColor", hdc, color);
            }
            return (int)mh$.invokeExact(hdc, color);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetTextAlign {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("SetTextAlign"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * UINT SetTextAlign(HDC hdc, UINT align)
     * }
     */
    public static FunctionDescriptor SetTextAlign$descriptor() {
        return SetTextAlign.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * UINT SetTextAlign(HDC hdc, UINT align)
     * }
     */
    public static MethodHandle SetTextAlign$handle() {
        return SetTextAlign.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * UINT SetTextAlign(HDC hdc, UINT align)
     * }
     */
    public static int SetTextAlign(MemorySegment hdc, int align) {
        var mh$ = SetTextAlign.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetTextAlign", hdc, align);
            }
            return (int)mh$.invokeExact(hdc, align);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetTextJustification {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_INT,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("SetTextJustification"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetTextJustification(HDC hdc, int extra, int count)
     * }
     */
    public static FunctionDescriptor SetTextJustification$descriptor() {
        return SetTextJustification.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetTextJustification(HDC hdc, int extra, int count)
     * }
     */
    public static MethodHandle SetTextJustification$handle() {
        return SetTextJustification.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL SetTextJustification(HDC hdc, int extra, int count)
     * }
     */
    public static int SetTextJustification(MemorySegment hdc, int extra, int count) {
        var mh$ = SetTextJustification.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetTextJustification", hdc, extra, count);
            }
            return (int)mh$.invokeExact(hdc, extra, count);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class UpdateColors {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("UpdateColors"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL UpdateColors(HDC hdc)
     * }
     */
    public static FunctionDescriptor UpdateColors$descriptor() {
        return UpdateColors.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL UpdateColors(HDC hdc)
     * }
     */
    public static MethodHandle UpdateColors$handle() {
        return UpdateColors.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL UpdateColors(HDC hdc)
     * }
     */
    public static int UpdateColors(MemorySegment hdc) {
        var mh$ = UpdateColors.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("UpdateColors", hdc);
            }
            return (int)mh$.invokeExact(hdc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef USHORT COLOR16
     * }
     */
    public static final OfShort COLOR16 = C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef struct _TRIVERTEX {
     *     LONG x;
     *     LONG y;
     *     COLOR16 Red;
     *     COLOR16 Green;
     *     COLOR16 Blue;
     *     COLOR16 Alpha;
     * } *PTRIVERTEX
     * }
     */
    public static final AddressLayout PTRIVERTEX = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _TRIVERTEX {
     *     LONG x;
     *     LONG y;
     *     COLOR16 Red;
     *     COLOR16 Green;
     *     COLOR16 Blue;
     *     COLOR16 Alpha;
     * } *LPTRIVERTEX
     * }
     */
    public static final AddressLayout LPTRIVERTEX = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _GRADIENT_TRIANGLE {
     *     ULONG Vertex1;
     *     ULONG Vertex2;
     *     ULONG Vertex3;
     * } *PGRADIENT_TRIANGLE
     * }
     */
    public static final AddressLayout PGRADIENT_TRIANGLE = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _GRADIENT_TRIANGLE {
     *     ULONG Vertex1;
     *     ULONG Vertex2;
     *     ULONG Vertex3;
     * } *LPGRADIENT_TRIANGLE
     * }
     */
    public static final AddressLayout LPGRADIENT_TRIANGLE = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _GRADIENT_RECT {
     *     ULONG UpperLeft;
     *     ULONG LowerRight;
     * } *PGRADIENT_RECT
     * }
     */
    public static final AddressLayout PGRADIENT_RECT = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _GRADIENT_RECT {
     *     ULONG UpperLeft;
     *     ULONG LowerRight;
     * } *LPGRADIENT_RECT
     * }
     */
    public static final AddressLayout LPGRADIENT_RECT = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _BLENDFUNCTION {
     *     BYTE BlendOp;
     *     BYTE BlendFlags;
     *     BYTE SourceConstantAlpha;
     *     BYTE AlphaFormat;
     * } *PBLENDFUNCTION
     * }
     */
    public static final AddressLayout PBLENDFUNCTION = C_POINTER;

    private static class AlphaBlend {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_INT,
            C_INT,
            C_INT,
            C_INT,
            C_POINTER,
            C_INT,
            C_INT,
            C_INT,
            C_INT,
            _BLENDFUNCTION.layout()
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("AlphaBlend"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL AlphaBlend(HDC hdcDest, int xoriginDest, int yoriginDest, int wDest, int hDest, HDC hdcSrc, int xoriginSrc, int yoriginSrc, int wSrc, int hSrc, BLENDFUNCTION ftn)
     * }
     */
    public static FunctionDescriptor AlphaBlend$descriptor() {
        return AlphaBlend.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL AlphaBlend(HDC hdcDest, int xoriginDest, int yoriginDest, int wDest, int hDest, HDC hdcSrc, int xoriginSrc, int yoriginSrc, int wSrc, int hSrc, BLENDFUNCTION ftn)
     * }
     */
    public static MethodHandle AlphaBlend$handle() {
        return AlphaBlend.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL AlphaBlend(HDC hdcDest, int xoriginDest, int yoriginDest, int wDest, int hDest, HDC hdcSrc, int xoriginSrc, int yoriginSrc, int wSrc, int hSrc, BLENDFUNCTION ftn)
     * }
     */
    public static int AlphaBlend(MemorySegment hdcDest, int xoriginDest, int yoriginDest, int wDest, int hDest, MemorySegment hdcSrc, int xoriginSrc, int yoriginSrc, int wSrc, int hSrc, MemorySegment ftn) {
        var mh$ = AlphaBlend.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("AlphaBlend", hdcDest, xoriginDest, yoriginDest, wDest, hDest, hdcSrc, xoriginSrc, yoriginSrc, wSrc, hSrc, ftn);
            }
            return (int)mh$.invokeExact(hdcDest, xoriginDest, yoriginDest, wDest, hDest, hdcSrc, xoriginSrc, yoriginSrc, wSrc, hSrc, ftn);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TransparentBlt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_INT,
            C_INT,
            C_INT,
            C_INT,
            C_POINTER,
            C_INT,
            C_INT,
            C_INT,
            C_INT,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("TransparentBlt"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL TransparentBlt(HDC hdcDest, int xoriginDest, int yoriginDest, int wDest, int hDest, HDC hdcSrc, int xoriginSrc, int yoriginSrc, int wSrc, int hSrc, UINT crTransparent)
     * }
     */
    public static FunctionDescriptor TransparentBlt$descriptor() {
        return TransparentBlt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL TransparentBlt(HDC hdcDest, int xoriginDest, int yoriginDest, int wDest, int hDest, HDC hdcSrc, int xoriginSrc, int yoriginSrc, int wSrc, int hSrc, UINT crTransparent)
     * }
     */
    public static MethodHandle TransparentBlt$handle() {
        return TransparentBlt.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL TransparentBlt(HDC hdcDest, int xoriginDest, int yoriginDest, int wDest, int hDest, HDC hdcSrc, int xoriginSrc, int yoriginSrc, int wSrc, int hSrc, UINT crTransparent)
     * }
     */
    public static int TransparentBlt(MemorySegment hdcDest, int xoriginDest, int yoriginDest, int wDest, int hDest, MemorySegment hdcSrc, int xoriginSrc, int yoriginSrc, int wSrc, int hSrc, int crTransparent) {
        var mh$ = TransparentBlt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TransparentBlt", hdcDest, xoriginDest, yoriginDest, wDest, hDest, hdcSrc, xoriginSrc, yoriginSrc, wSrc, hSrc, crTransparent);
            }
            return (int)mh$.invokeExact(hdcDest, xoriginDest, yoriginDest, wDest, hDest, hdcSrc, xoriginSrc, yoriginSrc, wSrc, hSrc, crTransparent);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GradientFill {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_LONG,
            C_POINTER,
            C_LONG,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GradientFill"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GradientFill(HDC hdc, PTRIVERTEX pVertex, ULONG nVertex, PVOID pMesh, ULONG nMesh, ULONG ulMode)
     * }
     */
    public static FunctionDescriptor GradientFill$descriptor() {
        return GradientFill.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GradientFill(HDC hdc, PTRIVERTEX pVertex, ULONG nVertex, PVOID pMesh, ULONG nMesh, ULONG ulMode)
     * }
     */
    public static MethodHandle GradientFill$handle() {
        return GradientFill.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL GradientFill(HDC hdc, PTRIVERTEX pVertex, ULONG nVertex, PVOID pMesh, ULONG nMesh, ULONG ulMode)
     * }
     */
    public static int GradientFill(MemorySegment hdc, MemorySegment pVertex, int nVertex, MemorySegment pMesh, int nMesh, int ulMode) {
        var mh$ = GradientFill.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GradientFill", hdc, pVertex, nVertex, pMesh, nMesh, ulMode);
            }
            return (int)mh$.invokeExact(hdc, pVertex, nVertex, pMesh, nMesh, ulMode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GdiAlphaBlend {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_INT,
            C_INT,
            C_INT,
            C_INT,
            C_POINTER,
            C_INT,
            C_INT,
            C_INT,
            C_INT,
            _BLENDFUNCTION.layout()
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GdiAlphaBlend"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GdiAlphaBlend(HDC hdcDest, int xoriginDest, int yoriginDest, int wDest, int hDest, HDC hdcSrc, int xoriginSrc, int yoriginSrc, int wSrc, int hSrc, BLENDFUNCTION ftn)
     * }
     */
    public static FunctionDescriptor GdiAlphaBlend$descriptor() {
        return GdiAlphaBlend.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GdiAlphaBlend(HDC hdcDest, int xoriginDest, int yoriginDest, int wDest, int hDest, HDC hdcSrc, int xoriginSrc, int yoriginSrc, int wSrc, int hSrc, BLENDFUNCTION ftn)
     * }
     */
    public static MethodHandle GdiAlphaBlend$handle() {
        return GdiAlphaBlend.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL GdiAlphaBlend(HDC hdcDest, int xoriginDest, int yoriginDest, int wDest, int hDest, HDC hdcSrc, int xoriginSrc, int yoriginSrc, int wSrc, int hSrc, BLENDFUNCTION ftn)
     * }
     */
    public static int GdiAlphaBlend(MemorySegment hdcDest, int xoriginDest, int yoriginDest, int wDest, int hDest, MemorySegment hdcSrc, int xoriginSrc, int yoriginSrc, int wSrc, int hSrc, MemorySegment ftn) {
        var mh$ = GdiAlphaBlend.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GdiAlphaBlend", hdcDest, xoriginDest, yoriginDest, wDest, hDest, hdcSrc, xoriginSrc, yoriginSrc, wSrc, hSrc, ftn);
            }
            return (int)mh$.invokeExact(hdcDest, xoriginDest, yoriginDest, wDest, hDest, hdcSrc, xoriginSrc, yoriginSrc, wSrc, hSrc, ftn);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GdiTransparentBlt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_INT,
            C_INT,
            C_INT,
            C_INT,
            C_POINTER,
            C_INT,
            C_INT,
            C_INT,
            C_INT,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GdiTransparentBlt"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GdiTransparentBlt(HDC hdcDest, int xoriginDest, int yoriginDest, int wDest, int hDest, HDC hdcSrc, int xoriginSrc, int yoriginSrc, int wSrc, int hSrc, UINT crTransparent)
     * }
     */
    public static FunctionDescriptor GdiTransparentBlt$descriptor() {
        return GdiTransparentBlt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GdiTransparentBlt(HDC hdcDest, int xoriginDest, int yoriginDest, int wDest, int hDest, HDC hdcSrc, int xoriginSrc, int yoriginSrc, int wSrc, int hSrc, UINT crTransparent)
     * }
     */
    public static MethodHandle GdiTransparentBlt$handle() {
        return GdiTransparentBlt.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL GdiTransparentBlt(HDC hdcDest, int xoriginDest, int yoriginDest, int wDest, int hDest, HDC hdcSrc, int xoriginSrc, int yoriginSrc, int wSrc, int hSrc, UINT crTransparent)
     * }
     */
    public static int GdiTransparentBlt(MemorySegment hdcDest, int xoriginDest, int yoriginDest, int wDest, int hDest, MemorySegment hdcSrc, int xoriginSrc, int yoriginSrc, int wSrc, int hSrc, int crTransparent) {
        var mh$ = GdiTransparentBlt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GdiTransparentBlt", hdcDest, xoriginDest, yoriginDest, wDest, hDest, hdcSrc, xoriginSrc, yoriginSrc, wSrc, hSrc, crTransparent);
            }
            return (int)mh$.invokeExact(hdcDest, xoriginDest, yoriginDest, wDest, hDest, hdcSrc, xoriginSrc, yoriginSrc, wSrc, hSrc, crTransparent);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GdiGradientFill {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_LONG,
            C_POINTER,
            C_LONG,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GdiGradientFill"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GdiGradientFill(HDC hdc, PTRIVERTEX pVertex, ULONG nVertex, PVOID pMesh, ULONG nCount, ULONG ulMode)
     * }
     */
    public static FunctionDescriptor GdiGradientFill$descriptor() {
        return GdiGradientFill.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GdiGradientFill(HDC hdc, PTRIVERTEX pVertex, ULONG nVertex, PVOID pMesh, ULONG nCount, ULONG ulMode)
     * }
     */
    public static MethodHandle GdiGradientFill$handle() {
        return GdiGradientFill.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL GdiGradientFill(HDC hdc, PTRIVERTEX pVertex, ULONG nVertex, PVOID pMesh, ULONG nCount, ULONG ulMode)
     * }
     */
    public static int GdiGradientFill(MemorySegment hdc, MemorySegment pVertex, int nVertex, MemorySegment pMesh, int nCount, int ulMode) {
        var mh$ = GdiGradientFill.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GdiGradientFill", hdc, pVertex, nVertex, pMesh, nCount, ulMode);
            }
            return (int)mh$.invokeExact(hdc, pVertex, nVertex, pMesh, nCount, ulMode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PlayMetaFileRecord {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("PlayMetaFileRecord"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL PlayMetaFileRecord(HDC hdc, LPHANDLETABLE lpHandleTable, LPMETARECORD lpMR, UINT noObjs)
     * }
     */
    public static FunctionDescriptor PlayMetaFileRecord$descriptor() {
        return PlayMetaFileRecord.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL PlayMetaFileRecord(HDC hdc, LPHANDLETABLE lpHandleTable, LPMETARECORD lpMR, UINT noObjs)
     * }
     */
    public static MethodHandle PlayMetaFileRecord$handle() {
        return PlayMetaFileRecord.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL PlayMetaFileRecord(HDC hdc, LPHANDLETABLE lpHandleTable, LPMETARECORD lpMR, UINT noObjs)
     * }
     */
    public static int PlayMetaFileRecord(MemorySegment hdc, MemorySegment lpHandleTable, MemorySegment lpMR, int noObjs) {
        var mh$ = PlayMetaFileRecord.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PlayMetaFileRecord", hdc, lpHandleTable, lpMR, noObjs);
            }
            return (int)mh$.invokeExact(hdc, lpHandleTable, lpMR, noObjs);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class EnumMetaFile {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_LONG_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("EnumMetaFile"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL EnumMetaFile(HDC hdc, HMETAFILE hmf, MFENUMPROC proc, LPARAM param)
     * }
     */
    public static FunctionDescriptor EnumMetaFile$descriptor() {
        return EnumMetaFile.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL EnumMetaFile(HDC hdc, HMETAFILE hmf, MFENUMPROC proc, LPARAM param)
     * }
     */
    public static MethodHandle EnumMetaFile$handle() {
        return EnumMetaFile.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL EnumMetaFile(HDC hdc, HMETAFILE hmf, MFENUMPROC proc, LPARAM param)
     * }
     */
    public static int EnumMetaFile(MemorySegment hdc, MemorySegment hmf, MemorySegment proc, long param) {
        var mh$ = EnumMetaFile.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("EnumMetaFile", hdc, hmf, proc, param);
            }
            return (int)mh$.invokeExact(hdc, hmf, proc, param);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CloseEnhMetaFile {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CloseEnhMetaFile"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HENHMETAFILE CloseEnhMetaFile(HDC hdc)
     * }
     */
    public static FunctionDescriptor CloseEnhMetaFile$descriptor() {
        return CloseEnhMetaFile.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HENHMETAFILE CloseEnhMetaFile(HDC hdc)
     * }
     */
    public static MethodHandle CloseEnhMetaFile$handle() {
        return CloseEnhMetaFile.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * HENHMETAFILE CloseEnhMetaFile(HDC hdc)
     * }
     */
    public static MemorySegment CloseEnhMetaFile(MemorySegment hdc) {
        var mh$ = CloseEnhMetaFile.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CloseEnhMetaFile", hdc);
            }
            return (MemorySegment)mh$.invokeExact(hdc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CopyEnhMetaFileA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CopyEnhMetaFileA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HENHMETAFILE CopyEnhMetaFileA(HENHMETAFILE hEnh, LPCSTR lpFileName)
     * }
     */
    public static FunctionDescriptor CopyEnhMetaFileA$descriptor() {
        return CopyEnhMetaFileA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HENHMETAFILE CopyEnhMetaFileA(HENHMETAFILE hEnh, LPCSTR lpFileName)
     * }
     */
    public static MethodHandle CopyEnhMetaFileA$handle() {
        return CopyEnhMetaFileA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * HENHMETAFILE CopyEnhMetaFileA(HENHMETAFILE hEnh, LPCSTR lpFileName)
     * }
     */
    public static MemorySegment CopyEnhMetaFileA(MemorySegment hEnh, MemorySegment lpFileName) {
        var mh$ = CopyEnhMetaFileA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CopyEnhMetaFileA", hEnh, lpFileName);
            }
            return (MemorySegment)mh$.invokeExact(hEnh, lpFileName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CopyEnhMetaFileW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CopyEnhMetaFileW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HENHMETAFILE CopyEnhMetaFileW(HENHMETAFILE hEnh, LPCWSTR lpFileName)
     * }
     */
    public static FunctionDescriptor CopyEnhMetaFileW$descriptor() {
        return CopyEnhMetaFileW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HENHMETAFILE CopyEnhMetaFileW(HENHMETAFILE hEnh, LPCWSTR lpFileName)
     * }
     */
    public static MethodHandle CopyEnhMetaFileW$handle() {
        return CopyEnhMetaFileW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * HENHMETAFILE CopyEnhMetaFileW(HENHMETAFILE hEnh, LPCWSTR lpFileName)
     * }
     */
    public static MemorySegment CopyEnhMetaFileW(MemorySegment hEnh, MemorySegment lpFileName) {
        var mh$ = CopyEnhMetaFileW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CopyEnhMetaFileW", hEnh, lpFileName);
            }
            return (MemorySegment)mh$.invokeExact(hEnh, lpFileName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateEnhMetaFileA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CreateEnhMetaFileA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HDC CreateEnhMetaFileA(HDC hdc, LPCSTR lpFilename, const RECT *lprc, LPCSTR lpDesc)
     * }
     */
    public static FunctionDescriptor CreateEnhMetaFileA$descriptor() {
        return CreateEnhMetaFileA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HDC CreateEnhMetaFileA(HDC hdc, LPCSTR lpFilename, const RECT *lprc, LPCSTR lpDesc)
     * }
     */
    public static MethodHandle CreateEnhMetaFileA$handle() {
        return CreateEnhMetaFileA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * HDC CreateEnhMetaFileA(HDC hdc, LPCSTR lpFilename, const RECT *lprc, LPCSTR lpDesc)
     * }
     */
    public static MemorySegment CreateEnhMetaFileA(MemorySegment hdc, MemorySegment lpFilename, MemorySegment lprc, MemorySegment lpDesc) {
        var mh$ = CreateEnhMetaFileA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateEnhMetaFileA", hdc, lpFilename, lprc, lpDesc);
            }
            return (MemorySegment)mh$.invokeExact(hdc, lpFilename, lprc, lpDesc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateEnhMetaFileW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CreateEnhMetaFileW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HDC CreateEnhMetaFileW(HDC hdc, LPCWSTR lpFilename, const RECT *lprc, LPCWSTR lpDesc)
     * }
     */
    public static FunctionDescriptor CreateEnhMetaFileW$descriptor() {
        return CreateEnhMetaFileW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HDC CreateEnhMetaFileW(HDC hdc, LPCWSTR lpFilename, const RECT *lprc, LPCWSTR lpDesc)
     * }
     */
    public static MethodHandle CreateEnhMetaFileW$handle() {
        return CreateEnhMetaFileW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * HDC CreateEnhMetaFileW(HDC hdc, LPCWSTR lpFilename, const RECT *lprc, LPCWSTR lpDesc)
     * }
     */
    public static MemorySegment CreateEnhMetaFileW(MemorySegment hdc, MemorySegment lpFilename, MemorySegment lprc, MemorySegment lpDesc) {
        var mh$ = CreateEnhMetaFileW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateEnhMetaFileW", hdc, lpFilename, lprc, lpDesc);
            }
            return (MemorySegment)mh$.invokeExact(hdc, lpFilename, lprc, lpDesc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DeleteEnhMetaFile {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("DeleteEnhMetaFile"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL DeleteEnhMetaFile(HENHMETAFILE hmf)
     * }
     */
    public static FunctionDescriptor DeleteEnhMetaFile$descriptor() {
        return DeleteEnhMetaFile.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL DeleteEnhMetaFile(HENHMETAFILE hmf)
     * }
     */
    public static MethodHandle DeleteEnhMetaFile$handle() {
        return DeleteEnhMetaFile.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL DeleteEnhMetaFile(HENHMETAFILE hmf)
     * }
     */
    public static int DeleteEnhMetaFile(MemorySegment hmf) {
        var mh$ = DeleteEnhMetaFile.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DeleteEnhMetaFile", hmf);
            }
            return (int)mh$.invokeExact(hmf);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class EnumEnhMetaFile {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("EnumEnhMetaFile"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL EnumEnhMetaFile(HDC hdc, HENHMETAFILE hmf, ENHMFENUMPROC proc, LPVOID param, const RECT *lpRect)
     * }
     */
    public static FunctionDescriptor EnumEnhMetaFile$descriptor() {
        return EnumEnhMetaFile.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL EnumEnhMetaFile(HDC hdc, HENHMETAFILE hmf, ENHMFENUMPROC proc, LPVOID param, const RECT *lpRect)
     * }
     */
    public static MethodHandle EnumEnhMetaFile$handle() {
        return EnumEnhMetaFile.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL EnumEnhMetaFile(HDC hdc, HENHMETAFILE hmf, ENHMFENUMPROC proc, LPVOID param, const RECT *lpRect)
     * }
     */
    public static int EnumEnhMetaFile(MemorySegment hdc, MemorySegment hmf, MemorySegment proc, MemorySegment param, MemorySegment lpRect) {
        var mh$ = EnumEnhMetaFile.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("EnumEnhMetaFile", hdc, hmf, proc, param, lpRect);
            }
            return (int)mh$.invokeExact(hdc, hmf, proc, param, lpRect);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetEnhMetaFileA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetEnhMetaFileA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HENHMETAFILE GetEnhMetaFileA(LPCSTR lpName)
     * }
     */
    public static FunctionDescriptor GetEnhMetaFileA$descriptor() {
        return GetEnhMetaFileA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HENHMETAFILE GetEnhMetaFileA(LPCSTR lpName)
     * }
     */
    public static MethodHandle GetEnhMetaFileA$handle() {
        return GetEnhMetaFileA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * HENHMETAFILE GetEnhMetaFileA(LPCSTR lpName)
     * }
     */
    public static MemorySegment GetEnhMetaFileA(MemorySegment lpName) {
        var mh$ = GetEnhMetaFileA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetEnhMetaFileA", lpName);
            }
            return (MemorySegment)mh$.invokeExact(lpName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetEnhMetaFileW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetEnhMetaFileW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HENHMETAFILE GetEnhMetaFileW(LPCWSTR lpName)
     * }
     */
    public static FunctionDescriptor GetEnhMetaFileW$descriptor() {
        return GetEnhMetaFileW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HENHMETAFILE GetEnhMetaFileW(LPCWSTR lpName)
     * }
     */
    public static MethodHandle GetEnhMetaFileW$handle() {
        return GetEnhMetaFileW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * HENHMETAFILE GetEnhMetaFileW(LPCWSTR lpName)
     * }
     */
    public static MemorySegment GetEnhMetaFileW(MemorySegment lpName) {
        var mh$ = GetEnhMetaFileW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetEnhMetaFileW", lpName);
            }
            return (MemorySegment)mh$.invokeExact(lpName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetEnhMetaFileBits {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetEnhMetaFileBits"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * UINT GetEnhMetaFileBits(HENHMETAFILE hEMF, UINT nSize, LPBYTE lpData)
     * }
     */
    public static FunctionDescriptor GetEnhMetaFileBits$descriptor() {
        return GetEnhMetaFileBits.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * UINT GetEnhMetaFileBits(HENHMETAFILE hEMF, UINT nSize, LPBYTE lpData)
     * }
     */
    public static MethodHandle GetEnhMetaFileBits$handle() {
        return GetEnhMetaFileBits.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * UINT GetEnhMetaFileBits(HENHMETAFILE hEMF, UINT nSize, LPBYTE lpData)
     * }
     */
    public static int GetEnhMetaFileBits(MemorySegment hEMF, int nSize, MemorySegment lpData) {
        var mh$ = GetEnhMetaFileBits.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetEnhMetaFileBits", hEMF, nSize, lpData);
            }
            return (int)mh$.invokeExact(hEMF, nSize, lpData);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetEnhMetaFileDescriptionA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetEnhMetaFileDescriptionA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * UINT GetEnhMetaFileDescriptionA(HENHMETAFILE hemf, UINT cchBuffer, LPSTR lpDescription)
     * }
     */
    public static FunctionDescriptor GetEnhMetaFileDescriptionA$descriptor() {
        return GetEnhMetaFileDescriptionA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * UINT GetEnhMetaFileDescriptionA(HENHMETAFILE hemf, UINT cchBuffer, LPSTR lpDescription)
     * }
     */
    public static MethodHandle GetEnhMetaFileDescriptionA$handle() {
        return GetEnhMetaFileDescriptionA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * UINT GetEnhMetaFileDescriptionA(HENHMETAFILE hemf, UINT cchBuffer, LPSTR lpDescription)
     * }
     */
    public static int GetEnhMetaFileDescriptionA(MemorySegment hemf, int cchBuffer, MemorySegment lpDescription) {
        var mh$ = GetEnhMetaFileDescriptionA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetEnhMetaFileDescriptionA", hemf, cchBuffer, lpDescription);
            }
            return (int)mh$.invokeExact(hemf, cchBuffer, lpDescription);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetEnhMetaFileDescriptionW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetEnhMetaFileDescriptionW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * UINT GetEnhMetaFileDescriptionW(HENHMETAFILE hemf, UINT cchBuffer, LPWSTR lpDescription)
     * }
     */
    public static FunctionDescriptor GetEnhMetaFileDescriptionW$descriptor() {
        return GetEnhMetaFileDescriptionW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * UINT GetEnhMetaFileDescriptionW(HENHMETAFILE hemf, UINT cchBuffer, LPWSTR lpDescription)
     * }
     */
    public static MethodHandle GetEnhMetaFileDescriptionW$handle() {
        return GetEnhMetaFileDescriptionW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * UINT GetEnhMetaFileDescriptionW(HENHMETAFILE hemf, UINT cchBuffer, LPWSTR lpDescription)
     * }
     */
    public static int GetEnhMetaFileDescriptionW(MemorySegment hemf, int cchBuffer, MemorySegment lpDescription) {
        var mh$ = GetEnhMetaFileDescriptionW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetEnhMetaFileDescriptionW", hemf, cchBuffer, lpDescription);
            }
            return (int)mh$.invokeExact(hemf, cchBuffer, lpDescription);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetEnhMetaFileHeader {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetEnhMetaFileHeader"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * UINT GetEnhMetaFileHeader(HENHMETAFILE hemf, UINT nSize, LPENHMETAHEADER lpEnhMetaHeader)
     * }
     */
    public static FunctionDescriptor GetEnhMetaFileHeader$descriptor() {
        return GetEnhMetaFileHeader.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * UINT GetEnhMetaFileHeader(HENHMETAFILE hemf, UINT nSize, LPENHMETAHEADER lpEnhMetaHeader)
     * }
     */
    public static MethodHandle GetEnhMetaFileHeader$handle() {
        return GetEnhMetaFileHeader.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * UINT GetEnhMetaFileHeader(HENHMETAFILE hemf, UINT nSize, LPENHMETAHEADER lpEnhMetaHeader)
     * }
     */
    public static int GetEnhMetaFileHeader(MemorySegment hemf, int nSize, MemorySegment lpEnhMetaHeader) {
        var mh$ = GetEnhMetaFileHeader.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetEnhMetaFileHeader", hemf, nSize, lpEnhMetaHeader);
            }
            return (int)mh$.invokeExact(hemf, nSize, lpEnhMetaHeader);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetEnhMetaFilePaletteEntries {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetEnhMetaFilePaletteEntries"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * UINT GetEnhMetaFilePaletteEntries(HENHMETAFILE hemf, UINT nNumEntries, LPPALETTEENTRY lpPaletteEntries)
     * }
     */
    public static FunctionDescriptor GetEnhMetaFilePaletteEntries$descriptor() {
        return GetEnhMetaFilePaletteEntries.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * UINT GetEnhMetaFilePaletteEntries(HENHMETAFILE hemf, UINT nNumEntries, LPPALETTEENTRY lpPaletteEntries)
     * }
     */
    public static MethodHandle GetEnhMetaFilePaletteEntries$handle() {
        return GetEnhMetaFilePaletteEntries.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * UINT GetEnhMetaFilePaletteEntries(HENHMETAFILE hemf, UINT nNumEntries, LPPALETTEENTRY lpPaletteEntries)
     * }
     */
    public static int GetEnhMetaFilePaletteEntries(MemorySegment hemf, int nNumEntries, MemorySegment lpPaletteEntries) {
        var mh$ = GetEnhMetaFilePaletteEntries.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetEnhMetaFilePaletteEntries", hemf, nNumEntries, lpPaletteEntries);
            }
            return (int)mh$.invokeExact(hemf, nNumEntries, lpPaletteEntries);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetEnhMetaFilePixelFormat {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetEnhMetaFilePixelFormat"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * UINT GetEnhMetaFilePixelFormat(HENHMETAFILE hemf, UINT cbBuffer, PIXELFORMATDESCRIPTOR *ppfd)
     * }
     */
    public static FunctionDescriptor GetEnhMetaFilePixelFormat$descriptor() {
        return GetEnhMetaFilePixelFormat.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * UINT GetEnhMetaFilePixelFormat(HENHMETAFILE hemf, UINT cbBuffer, PIXELFORMATDESCRIPTOR *ppfd)
     * }
     */
    public static MethodHandle GetEnhMetaFilePixelFormat$handle() {
        return GetEnhMetaFilePixelFormat.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * UINT GetEnhMetaFilePixelFormat(HENHMETAFILE hemf, UINT cbBuffer, PIXELFORMATDESCRIPTOR *ppfd)
     * }
     */
    public static int GetEnhMetaFilePixelFormat(MemorySegment hemf, int cbBuffer, MemorySegment ppfd) {
        var mh$ = GetEnhMetaFilePixelFormat.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetEnhMetaFilePixelFormat", hemf, cbBuffer, ppfd);
            }
            return (int)mh$.invokeExact(hemf, cbBuffer, ppfd);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetWinMetaFileBits {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_INT,
            C_POINTER,
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetWinMetaFileBits"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * UINT GetWinMetaFileBits(HENHMETAFILE hemf, UINT cbData16, LPBYTE pData16, INT iMapMode, HDC hdcRef)
     * }
     */
    public static FunctionDescriptor GetWinMetaFileBits$descriptor() {
        return GetWinMetaFileBits.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * UINT GetWinMetaFileBits(HENHMETAFILE hemf, UINT cbData16, LPBYTE pData16, INT iMapMode, HDC hdcRef)
     * }
     */
    public static MethodHandle GetWinMetaFileBits$handle() {
        return GetWinMetaFileBits.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * UINT GetWinMetaFileBits(HENHMETAFILE hemf, UINT cbData16, LPBYTE pData16, INT iMapMode, HDC hdcRef)
     * }
     */
    public static int GetWinMetaFileBits(MemorySegment hemf, int cbData16, MemorySegment pData16, int iMapMode, MemorySegment hdcRef) {
        var mh$ = GetWinMetaFileBits.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetWinMetaFileBits", hemf, cbData16, pData16, iMapMode, hdcRef);
            }
            return (int)mh$.invokeExact(hemf, cbData16, pData16, iMapMode, hdcRef);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PlayEnhMetaFile {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("PlayEnhMetaFile"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL PlayEnhMetaFile(HDC hdc, HENHMETAFILE hmf, const RECT *lprect)
     * }
     */
    public static FunctionDescriptor PlayEnhMetaFile$descriptor() {
        return PlayEnhMetaFile.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL PlayEnhMetaFile(HDC hdc, HENHMETAFILE hmf, const RECT *lprect)
     * }
     */
    public static MethodHandle PlayEnhMetaFile$handle() {
        return PlayEnhMetaFile.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL PlayEnhMetaFile(HDC hdc, HENHMETAFILE hmf, const RECT *lprect)
     * }
     */
    public static int PlayEnhMetaFile(MemorySegment hdc, MemorySegment hmf, MemorySegment lprect) {
        var mh$ = PlayEnhMetaFile.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PlayEnhMetaFile", hdc, hmf, lprect);
            }
            return (int)mh$.invokeExact(hdc, hmf, lprect);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PlayEnhMetaFileRecord {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("PlayEnhMetaFileRecord"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL PlayEnhMetaFileRecord(HDC hdc, LPHANDLETABLE pht, const ENHMETARECORD *pmr, UINT cht)
     * }
     */
    public static FunctionDescriptor PlayEnhMetaFileRecord$descriptor() {
        return PlayEnhMetaFileRecord.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL PlayEnhMetaFileRecord(HDC hdc, LPHANDLETABLE pht, const ENHMETARECORD *pmr, UINT cht)
     * }
     */
    public static MethodHandle PlayEnhMetaFileRecord$handle() {
        return PlayEnhMetaFileRecord.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL PlayEnhMetaFileRecord(HDC hdc, LPHANDLETABLE pht, const ENHMETARECORD *pmr, UINT cht)
     * }
     */
    public static int PlayEnhMetaFileRecord(MemorySegment hdc, MemorySegment pht, MemorySegment pmr, int cht) {
        var mh$ = PlayEnhMetaFileRecord.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PlayEnhMetaFileRecord", hdc, pht, pmr, cht);
            }
            return (int)mh$.invokeExact(hdc, pht, pmr, cht);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetEnhMetaFileBits {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("SetEnhMetaFileBits"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HENHMETAFILE SetEnhMetaFileBits(UINT nSize, const BYTE *pb)
     * }
     */
    public static FunctionDescriptor SetEnhMetaFileBits$descriptor() {
        return SetEnhMetaFileBits.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HENHMETAFILE SetEnhMetaFileBits(UINT nSize, const BYTE *pb)
     * }
     */
    public static MethodHandle SetEnhMetaFileBits$handle() {
        return SetEnhMetaFileBits.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * HENHMETAFILE SetEnhMetaFileBits(UINT nSize, const BYTE *pb)
     * }
     */
    public static MemorySegment SetEnhMetaFileBits(int nSize, MemorySegment pb) {
        var mh$ = SetEnhMetaFileBits.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetEnhMetaFileBits", nSize, pb);
            }
            return (MemorySegment)mh$.invokeExact(nSize, pb);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetWinMetaFileBits {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_INT,
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("SetWinMetaFileBits"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HENHMETAFILE SetWinMetaFileBits(UINT nSize, const BYTE *lpMeta16Data, HDC hdcRef, const METAFILEPICT *lpMFP)
     * }
     */
    public static FunctionDescriptor SetWinMetaFileBits$descriptor() {
        return SetWinMetaFileBits.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HENHMETAFILE SetWinMetaFileBits(UINT nSize, const BYTE *lpMeta16Data, HDC hdcRef, const METAFILEPICT *lpMFP)
     * }
     */
    public static MethodHandle SetWinMetaFileBits$handle() {
        return SetWinMetaFileBits.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * HENHMETAFILE SetWinMetaFileBits(UINT nSize, const BYTE *lpMeta16Data, HDC hdcRef, const METAFILEPICT *lpMFP)
     * }
     */
    public static MemorySegment SetWinMetaFileBits(int nSize, MemorySegment lpMeta16Data, MemorySegment hdcRef, MemorySegment lpMFP) {
        var mh$ = SetWinMetaFileBits.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetWinMetaFileBits", nSize, lpMeta16Data, hdcRef, lpMFP);
            }
            return (MemorySegment)mh$.invokeExact(nSize, lpMeta16Data, hdcRef, lpMFP);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GdiComment {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GdiComment"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GdiComment(HDC hdc, UINT nSize, const BYTE *lpData)
     * }
     */
    public static FunctionDescriptor GdiComment$descriptor() {
        return GdiComment.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GdiComment(HDC hdc, UINT nSize, const BYTE *lpData)
     * }
     */
    public static MethodHandle GdiComment$handle() {
        return GdiComment.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL GdiComment(HDC hdc, UINT nSize, const BYTE *lpData)
     * }
     */
    public static int GdiComment(MemorySegment hdc, int nSize, MemorySegment lpData) {
        var mh$ = GdiComment.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GdiComment", hdc, nSize, lpData);
            }
            return (int)mh$.invokeExact(hdc, nSize, lpData);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetTextMetricsA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetTextMetricsA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetTextMetricsA(HDC hdc, LPTEXTMETRICA lptm)
     * }
     */
    public static FunctionDescriptor GetTextMetricsA$descriptor() {
        return GetTextMetricsA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetTextMetricsA(HDC hdc, LPTEXTMETRICA lptm)
     * }
     */
    public static MethodHandle GetTextMetricsA$handle() {
        return GetTextMetricsA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL GetTextMetricsA(HDC hdc, LPTEXTMETRICA lptm)
     * }
     */
    public static int GetTextMetricsA(MemorySegment hdc, MemorySegment lptm) {
        var mh$ = GetTextMetricsA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetTextMetricsA", hdc, lptm);
            }
            return (int)mh$.invokeExact(hdc, lptm);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetTextMetricsW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetTextMetricsW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetTextMetricsW(HDC hdc, LPTEXTMETRICW lptm)
     * }
     */
    public static FunctionDescriptor GetTextMetricsW$descriptor() {
        return GetTextMetricsW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetTextMetricsW(HDC hdc, LPTEXTMETRICW lptm)
     * }
     */
    public static MethodHandle GetTextMetricsW$handle() {
        return GetTextMetricsW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL GetTextMetricsW(HDC hdc, LPTEXTMETRICW lptm)
     * }
     */
    public static int GetTextMetricsW(MemorySegment hdc, MemorySegment lptm) {
        var mh$ = GetTextMetricsW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetTextMetricsW", hdc, lptm);
            }
            return (int)mh$.invokeExact(hdc, lptm);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct tagDIBSECTION {
     *     BITMAP dsBm;
     *     BITMAPINFOHEADER dsBmih;
     *     DWORD dsBitfields[3];
     *     HANDLE dshSection;
     *     DWORD dsOffset;
     * } *LPDIBSECTION
     * }
     */
    public static final AddressLayout LPDIBSECTION = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagDIBSECTION {
     *     BITMAP dsBm;
     *     BITMAPINFOHEADER dsBmih;
     *     DWORD dsBitfields[3];
     *     HANDLE dshSection;
     *     DWORD dsOffset;
     * } *PDIBSECTION
     * }
     */
    public static final AddressLayout PDIBSECTION = C_POINTER;

    private static class AngleArc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_INT,
            C_INT,
            C_LONG,
            C_FLOAT,
            C_FLOAT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("AngleArc"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL AngleArc(HDC hdc, int x, int y, DWORD r, FLOAT StartAngle, FLOAT SweepAngle)
     * }
     */
    public static FunctionDescriptor AngleArc$descriptor() {
        return AngleArc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL AngleArc(HDC hdc, int x, int y, DWORD r, FLOAT StartAngle, FLOAT SweepAngle)
     * }
     */
    public static MethodHandle AngleArc$handle() {
        return AngleArc.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL AngleArc(HDC hdc, int x, int y, DWORD r, FLOAT StartAngle, FLOAT SweepAngle)
     * }
     */
    public static int AngleArc(MemorySegment hdc, int x, int y, int r, float StartAngle, float SweepAngle) {
        var mh$ = AngleArc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("AngleArc", hdc, x, y, r, StartAngle, SweepAngle);
            }
            return (int)mh$.invokeExact(hdc, x, y, r, StartAngle, SweepAngle);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PolyPolyline {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("PolyPolyline"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL PolyPolyline(HDC hdc, const POINT *apt, const DWORD *asz, DWORD csz)
     * }
     */
    public static FunctionDescriptor PolyPolyline$descriptor() {
        return PolyPolyline.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL PolyPolyline(HDC hdc, const POINT *apt, const DWORD *asz, DWORD csz)
     * }
     */
    public static MethodHandle PolyPolyline$handle() {
        return PolyPolyline.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL PolyPolyline(HDC hdc, const POINT *apt, const DWORD *asz, DWORD csz)
     * }
     */
    public static int PolyPolyline(MemorySegment hdc, MemorySegment apt, MemorySegment asz, int csz) {
        var mh$ = PolyPolyline.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PolyPolyline", hdc, apt, asz, csz);
            }
            return (int)mh$.invokeExact(hdc, apt, asz, csz);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetWorldTransform {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetWorldTransform"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetWorldTransform(HDC hdc, LPXFORM lpxf)
     * }
     */
    public static FunctionDescriptor GetWorldTransform$descriptor() {
        return GetWorldTransform.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetWorldTransform(HDC hdc, LPXFORM lpxf)
     * }
     */
    public static MethodHandle GetWorldTransform$handle() {
        return GetWorldTransform.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL GetWorldTransform(HDC hdc, LPXFORM lpxf)
     * }
     */
    public static int GetWorldTransform(MemorySegment hdc, MemorySegment lpxf) {
        var mh$ = GetWorldTransform.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetWorldTransform", hdc, lpxf);
            }
            return (int)mh$.invokeExact(hdc, lpxf);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetWorldTransform {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("SetWorldTransform"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetWorldTransform(HDC hdc, const XFORM *lpxf)
     * }
     */
    public static FunctionDescriptor SetWorldTransform$descriptor() {
        return SetWorldTransform.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetWorldTransform(HDC hdc, const XFORM *lpxf)
     * }
     */
    public static MethodHandle SetWorldTransform$handle() {
        return SetWorldTransform.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL SetWorldTransform(HDC hdc, const XFORM *lpxf)
     * }
     */
    public static int SetWorldTransform(MemorySegment hdc, MemorySegment lpxf) {
        var mh$ = SetWorldTransform.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetWorldTransform", hdc, lpxf);
            }
            return (int)mh$.invokeExact(hdc, lpxf);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ModifyWorldTransform {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("ModifyWorldTransform"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL ModifyWorldTransform(HDC hdc, const XFORM *lpxf, DWORD mode)
     * }
     */
    public static FunctionDescriptor ModifyWorldTransform$descriptor() {
        return ModifyWorldTransform.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL ModifyWorldTransform(HDC hdc, const XFORM *lpxf, DWORD mode)
     * }
     */
    public static MethodHandle ModifyWorldTransform$handle() {
        return ModifyWorldTransform.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL ModifyWorldTransform(HDC hdc, const XFORM *lpxf, DWORD mode)
     * }
     */
    public static int ModifyWorldTransform(MemorySegment hdc, MemorySegment lpxf, int mode) {
        var mh$ = ModifyWorldTransform.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ModifyWorldTransform", hdc, lpxf, mode);
            }
            return (int)mh$.invokeExact(hdc, lpxf, mode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CombineTransform {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CombineTransform"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CombineTransform(LPXFORM lpxfOut, const XFORM *lpxf1, const XFORM *lpxf2)
     * }
     */
    public static FunctionDescriptor CombineTransform$descriptor() {
        return CombineTransform.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CombineTransform(LPXFORM lpxfOut, const XFORM *lpxf1, const XFORM *lpxf2)
     * }
     */
    public static MethodHandle CombineTransform$handle() {
        return CombineTransform.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL CombineTransform(LPXFORM lpxfOut, const XFORM *lpxf1, const XFORM *lpxf2)
     * }
     */
    public static int CombineTransform(MemorySegment lpxfOut, MemorySegment lpxf1, MemorySegment lpxf2) {
        var mh$ = CombineTransform.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CombineTransform", lpxfOut, lpxf1, lpxf2);
            }
            return (int)mh$.invokeExact(lpxfOut, lpxf1, lpxf2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateDIBSection {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_INT,
            C_POINTER,
            C_POINTER,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CreateDIBSection"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HBITMAP CreateDIBSection(HDC hdc, const BITMAPINFO *pbmi, UINT usage, void **ppvBits, HANDLE hSection, DWORD offset)
     * }
     */
    public static FunctionDescriptor CreateDIBSection$descriptor() {
        return CreateDIBSection.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HBITMAP CreateDIBSection(HDC hdc, const BITMAPINFO *pbmi, UINT usage, void **ppvBits, HANDLE hSection, DWORD offset)
     * }
     */
    public static MethodHandle CreateDIBSection$handle() {
        return CreateDIBSection.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * HBITMAP CreateDIBSection(HDC hdc, const BITMAPINFO *pbmi, UINT usage, void **ppvBits, HANDLE hSection, DWORD offset)
     * }
     */
    public static MemorySegment CreateDIBSection(MemorySegment hdc, MemorySegment pbmi, int usage, MemorySegment ppvBits, MemorySegment hSection, int offset) {
        var mh$ = CreateDIBSection.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateDIBSection", hdc, pbmi, usage, ppvBits, hSection, offset);
            }
            return (MemorySegment)mh$.invokeExact(hdc, pbmi, usage, ppvBits, hSection, offset);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetDIBColorTable {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_INT,
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetDIBColorTable"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * UINT GetDIBColorTable(HDC hdc, UINT iStart, UINT cEntries, RGBQUAD *prgbq)
     * }
     */
    public static FunctionDescriptor GetDIBColorTable$descriptor() {
        return GetDIBColorTable.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * UINT GetDIBColorTable(HDC hdc, UINT iStart, UINT cEntries, RGBQUAD *prgbq)
     * }
     */
    public static MethodHandle GetDIBColorTable$handle() {
        return GetDIBColorTable.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * UINT GetDIBColorTable(HDC hdc, UINT iStart, UINT cEntries, RGBQUAD *prgbq)
     * }
     */
    public static int GetDIBColorTable(MemorySegment hdc, int iStart, int cEntries, MemorySegment prgbq) {
        var mh$ = GetDIBColorTable.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetDIBColorTable", hdc, iStart, cEntries, prgbq);
            }
            return (int)mh$.invokeExact(hdc, iStart, cEntries, prgbq);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetDIBColorTable {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_INT,
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("SetDIBColorTable"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * UINT SetDIBColorTable(HDC hdc, UINT iStart, UINT cEntries, const RGBQUAD *prgbq)
     * }
     */
    public static FunctionDescriptor SetDIBColorTable$descriptor() {
        return SetDIBColorTable.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * UINT SetDIBColorTable(HDC hdc, UINT iStart, UINT cEntries, const RGBQUAD *prgbq)
     * }
     */
    public static MethodHandle SetDIBColorTable$handle() {
        return SetDIBColorTable.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * UINT SetDIBColorTable(HDC hdc, UINT iStart, UINT cEntries, const RGBQUAD *prgbq)
     * }
     */
    public static int SetDIBColorTable(MemorySegment hdc, int iStart, int cEntries, MemorySegment prgbq) {
        var mh$ = SetDIBColorTable.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetDIBColorTable", hdc, iStart, cEntries, prgbq);
            }
            return (int)mh$.invokeExact(hdc, iStart, cEntries, prgbq);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct tagCOLORADJUSTMENT {
     *     WORD caSize;
     *     WORD caFlags;
     *     WORD caIlluminantIndex;
     *     WORD caRedGamma;
     *     WORD caGreenGamma;
     *     WORD caBlueGamma;
     *     WORD caReferenceBlack;
     *     WORD caReferenceWhite;
     *     SHORT caContrast;
     *     SHORT caBrightness;
     *     SHORT caColorfulness;
     *     SHORT caRedGreenTint;
     * } *PCOLORADJUSTMENT
     * }
     */
    public static final AddressLayout PCOLORADJUSTMENT = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagCOLORADJUSTMENT {
     *     WORD caSize;
     *     WORD caFlags;
     *     WORD caIlluminantIndex;
     *     WORD caRedGamma;
     *     WORD caGreenGamma;
     *     WORD caBlueGamma;
     *     WORD caReferenceBlack;
     *     WORD caReferenceWhite;
     *     SHORT caContrast;
     *     SHORT caBrightness;
     *     SHORT caColorfulness;
     *     SHORT caRedGreenTint;
     * } *LPCOLORADJUSTMENT
     * }
     */
    public static final AddressLayout LPCOLORADJUSTMENT = C_POINTER;

    private static class SetColorAdjustment {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("SetColorAdjustment"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetColorAdjustment(HDC hdc, const COLORADJUSTMENT *lpca)
     * }
     */
    public static FunctionDescriptor SetColorAdjustment$descriptor() {
        return SetColorAdjustment.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetColorAdjustment(HDC hdc, const COLORADJUSTMENT *lpca)
     * }
     */
    public static MethodHandle SetColorAdjustment$handle() {
        return SetColorAdjustment.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL SetColorAdjustment(HDC hdc, const COLORADJUSTMENT *lpca)
     * }
     */
    public static int SetColorAdjustment(MemorySegment hdc, MemorySegment lpca) {
        var mh$ = SetColorAdjustment.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetColorAdjustment", hdc, lpca);
            }
            return (int)mh$.invokeExact(hdc, lpca);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetColorAdjustment {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetColorAdjustment"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetColorAdjustment(HDC hdc, LPCOLORADJUSTMENT lpca)
     * }
     */
    public static FunctionDescriptor GetColorAdjustment$descriptor() {
        return GetColorAdjustment.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetColorAdjustment(HDC hdc, LPCOLORADJUSTMENT lpca)
     * }
     */
    public static MethodHandle GetColorAdjustment$handle() {
        return GetColorAdjustment.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL GetColorAdjustment(HDC hdc, LPCOLORADJUSTMENT lpca)
     * }
     */
    public static int GetColorAdjustment(MemorySegment hdc, MemorySegment lpca) {
        var mh$ = GetColorAdjustment.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetColorAdjustment", hdc, lpca);
            }
            return (int)mh$.invokeExact(hdc, lpca);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateHalftonePalette {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CreateHalftonePalette"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HPALETTE CreateHalftonePalette(HDC hdc)
     * }
     */
    public static FunctionDescriptor CreateHalftonePalette$descriptor() {
        return CreateHalftonePalette.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HPALETTE CreateHalftonePalette(HDC hdc)
     * }
     */
    public static MethodHandle CreateHalftonePalette$handle() {
        return CreateHalftonePalette.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * HPALETTE CreateHalftonePalette(HDC hdc)
     * }
     */
    public static MemorySegment CreateHalftonePalette(MemorySegment hdc) {
        var mh$ = CreateHalftonePalette.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateHalftonePalette", hdc);
            }
            return (MemorySegment)mh$.invokeExact(hdc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct _DOCINFOA {
     *     int cbSize;
     *     LPCSTR lpszDocName;
     *     LPCSTR lpszOutput;
     *     LPCSTR lpszDatatype;
     *     DWORD fwType;
     * } *LPDOCINFOA
     * }
     */
    public static final AddressLayout LPDOCINFOA = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _DOCINFOW {
     *     int cbSize;
     *     LPCWSTR lpszDocName;
     *     LPCWSTR lpszOutput;
     *     LPCWSTR lpszDatatype;
     *     DWORD fwType;
     * } *LPDOCINFOW
     * }
     */
    public static final AddressLayout LPDOCINFOW = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef LPDOCINFOA LPDOCINFO
     * }
     */
    public static final AddressLayout LPDOCINFO = C_POINTER;

    private static class StartDocA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("StartDocA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int StartDocA(HDC hdc, const DOCINFOA *lpdi)
     * }
     */
    public static FunctionDescriptor StartDocA$descriptor() {
        return StartDocA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int StartDocA(HDC hdc, const DOCINFOA *lpdi)
     * }
     */
    public static MethodHandle StartDocA$handle() {
        return StartDocA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int StartDocA(HDC hdc, const DOCINFOA *lpdi)
     * }
     */
    public static int StartDocA(MemorySegment hdc, MemorySegment lpdi) {
        var mh$ = StartDocA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("StartDocA", hdc, lpdi);
            }
            return (int)mh$.invokeExact(hdc, lpdi);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class StartDocW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("StartDocW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int StartDocW(HDC hdc, const DOCINFOW *lpdi)
     * }
     */
    public static FunctionDescriptor StartDocW$descriptor() {
        return StartDocW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int StartDocW(HDC hdc, const DOCINFOW *lpdi)
     * }
     */
    public static MethodHandle StartDocW$handle() {
        return StartDocW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int StartDocW(HDC hdc, const DOCINFOW *lpdi)
     * }
     */
    public static int StartDocW(MemorySegment hdc, MemorySegment lpdi) {
        var mh$ = StartDocW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("StartDocW", hdc, lpdi);
            }
            return (int)mh$.invokeExact(hdc, lpdi);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class EndDoc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("EndDoc"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int EndDoc(HDC hdc)
     * }
     */
    public static FunctionDescriptor EndDoc$descriptor() {
        return EndDoc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int EndDoc(HDC hdc)
     * }
     */
    public static MethodHandle EndDoc$handle() {
        return EndDoc.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int EndDoc(HDC hdc)
     * }
     */
    public static int EndDoc(MemorySegment hdc) {
        var mh$ = EndDoc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("EndDoc", hdc);
            }
            return (int)mh$.invokeExact(hdc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class StartPage {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("StartPage"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int StartPage(HDC hdc)
     * }
     */
    public static FunctionDescriptor StartPage$descriptor() {
        return StartPage.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int StartPage(HDC hdc)
     * }
     */
    public static MethodHandle StartPage$handle() {
        return StartPage.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int StartPage(HDC hdc)
     * }
     */
    public static int StartPage(MemorySegment hdc) {
        var mh$ = StartPage.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("StartPage", hdc);
            }
            return (int)mh$.invokeExact(hdc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class EndPage {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("EndPage"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int EndPage(HDC hdc)
     * }
     */
    public static FunctionDescriptor EndPage$descriptor() {
        return EndPage.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int EndPage(HDC hdc)
     * }
     */
    public static MethodHandle EndPage$handle() {
        return EndPage.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int EndPage(HDC hdc)
     * }
     */
    public static int EndPage(MemorySegment hdc) {
        var mh$ = EndPage.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("EndPage", hdc);
            }
            return (int)mh$.invokeExact(hdc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class AbortDoc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("AbortDoc"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int AbortDoc(HDC hdc)
     * }
     */
    public static FunctionDescriptor AbortDoc$descriptor() {
        return AbortDoc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int AbortDoc(HDC hdc)
     * }
     */
    public static MethodHandle AbortDoc$handle() {
        return AbortDoc.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int AbortDoc(HDC hdc)
     * }
     */
    public static int AbortDoc(MemorySegment hdc) {
        var mh$ = AbortDoc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("AbortDoc", hdc);
            }
            return (int)mh$.invokeExact(hdc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetAbortProc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("SetAbortProc"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SetAbortProc(HDC hdc, ABORTPROC proc)
     * }
     */
    public static FunctionDescriptor SetAbortProc$descriptor() {
        return SetAbortProc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SetAbortProc(HDC hdc, ABORTPROC proc)
     * }
     */
    public static MethodHandle SetAbortProc$handle() {
        return SetAbortProc.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int SetAbortProc(HDC hdc, ABORTPROC proc)
     * }
     */
    public static int SetAbortProc(MemorySegment hdc, MemorySegment proc) {
        var mh$ = SetAbortProc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetAbortProc", hdc, proc);
            }
            return (int)mh$.invokeExact(hdc, proc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class AbortPath {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("AbortPath"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL AbortPath(HDC hdc)
     * }
     */
    public static FunctionDescriptor AbortPath$descriptor() {
        return AbortPath.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL AbortPath(HDC hdc)
     * }
     */
    public static MethodHandle AbortPath$handle() {
        return AbortPath.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL AbortPath(HDC hdc)
     * }
     */
    public static int AbortPath(MemorySegment hdc) {
        var mh$ = AbortPath.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("AbortPath", hdc);
            }
            return (int)mh$.invokeExact(hdc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ArcTo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_INT,
            C_INT,
            C_INT,
            C_INT,
            C_INT,
            C_INT,
            C_INT,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("ArcTo"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL ArcTo(HDC hdc, int left, int top, int right, int bottom, int xr1, int yr1, int xr2, int yr2)
     * }
     */
    public static FunctionDescriptor ArcTo$descriptor() {
        return ArcTo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL ArcTo(HDC hdc, int left, int top, int right, int bottom, int xr1, int yr1, int xr2, int yr2)
     * }
     */
    public static MethodHandle ArcTo$handle() {
        return ArcTo.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL ArcTo(HDC hdc, int left, int top, int right, int bottom, int xr1, int yr1, int xr2, int yr2)
     * }
     */
    public static int ArcTo(MemorySegment hdc, int left, int top, int right, int bottom, int xr1, int yr1, int xr2, int yr2) {
        var mh$ = ArcTo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ArcTo", hdc, left, top, right, bottom, xr1, yr1, xr2, yr2);
            }
            return (int)mh$.invokeExact(hdc, left, top, right, bottom, xr1, yr1, xr2, yr2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class BeginPath {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("BeginPath"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL BeginPath(HDC hdc)
     * }
     */
    public static FunctionDescriptor BeginPath$descriptor() {
        return BeginPath.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL BeginPath(HDC hdc)
     * }
     */
    public static MethodHandle BeginPath$handle() {
        return BeginPath.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL BeginPath(HDC hdc)
     * }
     */
    public static int BeginPath(MemorySegment hdc) {
        var mh$ = BeginPath.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("BeginPath", hdc);
            }
            return (int)mh$.invokeExact(hdc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CloseFigure {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CloseFigure"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CloseFigure(HDC hdc)
     * }
     */
    public static FunctionDescriptor CloseFigure$descriptor() {
        return CloseFigure.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CloseFigure(HDC hdc)
     * }
     */
    public static MethodHandle CloseFigure$handle() {
        return CloseFigure.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL CloseFigure(HDC hdc)
     * }
     */
    public static int CloseFigure(MemorySegment hdc) {
        var mh$ = CloseFigure.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CloseFigure", hdc);
            }
            return (int)mh$.invokeExact(hdc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class EndPath {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("EndPath"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL EndPath(HDC hdc)
     * }
     */
    public static FunctionDescriptor EndPath$descriptor() {
        return EndPath.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL EndPath(HDC hdc)
     * }
     */
    public static MethodHandle EndPath$handle() {
        return EndPath.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL EndPath(HDC hdc)
     * }
     */
    public static int EndPath(MemorySegment hdc) {
        var mh$ = EndPath.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("EndPath", hdc);
            }
            return (int)mh$.invokeExact(hdc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FillPath {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("FillPath"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL FillPath(HDC hdc)
     * }
     */
    public static FunctionDescriptor FillPath$descriptor() {
        return FillPath.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL FillPath(HDC hdc)
     * }
     */
    public static MethodHandle FillPath$handle() {
        return FillPath.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL FillPath(HDC hdc)
     * }
     */
    public static int FillPath(MemorySegment hdc) {
        var mh$ = FillPath.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FillPath", hdc);
            }
            return (int)mh$.invokeExact(hdc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FlattenPath {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("FlattenPath"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL FlattenPath(HDC hdc)
     * }
     */
    public static FunctionDescriptor FlattenPath$descriptor() {
        return FlattenPath.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL FlattenPath(HDC hdc)
     * }
     */
    public static MethodHandle FlattenPath$handle() {
        return FlattenPath.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL FlattenPath(HDC hdc)
     * }
     */
    public static int FlattenPath(MemorySegment hdc) {
        var mh$ = FlattenPath.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FlattenPath", hdc);
            }
            return (int)mh$.invokeExact(hdc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetPath {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetPath"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int GetPath(HDC hdc, LPPOINT apt, LPBYTE aj, int cpt)
     * }
     */
    public static FunctionDescriptor GetPath$descriptor() {
        return GetPath.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int GetPath(HDC hdc, LPPOINT apt, LPBYTE aj, int cpt)
     * }
     */
    public static MethodHandle GetPath$handle() {
        return GetPath.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int GetPath(HDC hdc, LPPOINT apt, LPBYTE aj, int cpt)
     * }
     */
    public static int GetPath(MemorySegment hdc, MemorySegment apt, MemorySegment aj, int cpt) {
        var mh$ = GetPath.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetPath", hdc, apt, aj, cpt);
            }
            return (int)mh$.invokeExact(hdc, apt, aj, cpt);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PathToRegion {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("PathToRegion"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HRGN PathToRegion(HDC hdc)
     * }
     */
    public static FunctionDescriptor PathToRegion$descriptor() {
        return PathToRegion.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HRGN PathToRegion(HDC hdc)
     * }
     */
    public static MethodHandle PathToRegion$handle() {
        return PathToRegion.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * HRGN PathToRegion(HDC hdc)
     * }
     */
    public static MemorySegment PathToRegion(MemorySegment hdc) {
        var mh$ = PathToRegion.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PathToRegion", hdc);
            }
            return (MemorySegment)mh$.invokeExact(hdc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PolyDraw {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("PolyDraw"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL PolyDraw(HDC hdc, const POINT *apt, const BYTE *aj, int cpt)
     * }
     */
    public static FunctionDescriptor PolyDraw$descriptor() {
        return PolyDraw.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL PolyDraw(HDC hdc, const POINT *apt, const BYTE *aj, int cpt)
     * }
     */
    public static MethodHandle PolyDraw$handle() {
        return PolyDraw.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL PolyDraw(HDC hdc, const POINT *apt, const BYTE *aj, int cpt)
     * }
     */
    public static int PolyDraw(MemorySegment hdc, MemorySegment apt, MemorySegment aj, int cpt) {
        var mh$ = PolyDraw.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PolyDraw", hdc, apt, aj, cpt);
            }
            return (int)mh$.invokeExact(hdc, apt, aj, cpt);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SelectClipPath {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("SelectClipPath"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SelectClipPath(HDC hdc, int mode)
     * }
     */
    public static FunctionDescriptor SelectClipPath$descriptor() {
        return SelectClipPath.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SelectClipPath(HDC hdc, int mode)
     * }
     */
    public static MethodHandle SelectClipPath$handle() {
        return SelectClipPath.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL SelectClipPath(HDC hdc, int mode)
     * }
     */
    public static int SelectClipPath(MemorySegment hdc, int mode) {
        var mh$ = SelectClipPath.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SelectClipPath", hdc, mode);
            }
            return (int)mh$.invokeExact(hdc, mode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetArcDirection {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("SetArcDirection"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SetArcDirection(HDC hdc, int dir)
     * }
     */
    public static FunctionDescriptor SetArcDirection$descriptor() {
        return SetArcDirection.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SetArcDirection(HDC hdc, int dir)
     * }
     */
    public static MethodHandle SetArcDirection$handle() {
        return SetArcDirection.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int SetArcDirection(HDC hdc, int dir)
     * }
     */
    public static int SetArcDirection(MemorySegment hdc, int dir) {
        var mh$ = SetArcDirection.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetArcDirection", hdc, dir);
            }
            return (int)mh$.invokeExact(hdc, dir);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetMiterLimit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_FLOAT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("SetMiterLimit"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetMiterLimit(HDC hdc, FLOAT limit, PFLOAT old)
     * }
     */
    public static FunctionDescriptor SetMiterLimit$descriptor() {
        return SetMiterLimit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetMiterLimit(HDC hdc, FLOAT limit, PFLOAT old)
     * }
     */
    public static MethodHandle SetMiterLimit$handle() {
        return SetMiterLimit.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL SetMiterLimit(HDC hdc, FLOAT limit, PFLOAT old)
     * }
     */
    public static int SetMiterLimit(MemorySegment hdc, float limit, MemorySegment old) {
        var mh$ = SetMiterLimit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetMiterLimit", hdc, limit, old);
            }
            return (int)mh$.invokeExact(hdc, limit, old);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class StrokeAndFillPath {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("StrokeAndFillPath"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL StrokeAndFillPath(HDC hdc)
     * }
     */
    public static FunctionDescriptor StrokeAndFillPath$descriptor() {
        return StrokeAndFillPath.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL StrokeAndFillPath(HDC hdc)
     * }
     */
    public static MethodHandle StrokeAndFillPath$handle() {
        return StrokeAndFillPath.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL StrokeAndFillPath(HDC hdc)
     * }
     */
    public static int StrokeAndFillPath(MemorySegment hdc) {
        var mh$ = StrokeAndFillPath.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("StrokeAndFillPath", hdc);
            }
            return (int)mh$.invokeExact(hdc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class StrokePath {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("StrokePath"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL StrokePath(HDC hdc)
     * }
     */
    public static FunctionDescriptor StrokePath$descriptor() {
        return StrokePath.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL StrokePath(HDC hdc)
     * }
     */
    public static MethodHandle StrokePath$handle() {
        return StrokePath.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL StrokePath(HDC hdc)
     * }
     */
    public static int StrokePath(MemorySegment hdc) {
        var mh$ = StrokePath.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("StrokePath", hdc);
            }
            return (int)mh$.invokeExact(hdc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class WidenPath {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("WidenPath"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL WidenPath(HDC hdc)
     * }
     */
    public static FunctionDescriptor WidenPath$descriptor() {
        return WidenPath.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL WidenPath(HDC hdc)
     * }
     */
    public static MethodHandle WidenPath$handle() {
        return WidenPath.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL WidenPath(HDC hdc)
     * }
     */
    public static int WidenPath(MemorySegment hdc) {
        var mh$ = WidenPath.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WidenPath", hdc);
            }
            return (int)mh$.invokeExact(hdc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ExtCreatePen {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_LONG,
            C_LONG,
            C_POINTER,
            C_LONG,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("ExtCreatePen"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HPEN ExtCreatePen(DWORD iPenStyle, DWORD cWidth, const LOGBRUSH *plbrush, DWORD cStyle, const DWORD *pstyle)
     * }
     */
    public static FunctionDescriptor ExtCreatePen$descriptor() {
        return ExtCreatePen.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HPEN ExtCreatePen(DWORD iPenStyle, DWORD cWidth, const LOGBRUSH *plbrush, DWORD cStyle, const DWORD *pstyle)
     * }
     */
    public static MethodHandle ExtCreatePen$handle() {
        return ExtCreatePen.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * HPEN ExtCreatePen(DWORD iPenStyle, DWORD cWidth, const LOGBRUSH *plbrush, DWORD cStyle, const DWORD *pstyle)
     * }
     */
    public static MemorySegment ExtCreatePen(int iPenStyle, int cWidth, MemorySegment plbrush, int cStyle, MemorySegment pstyle) {
        var mh$ = ExtCreatePen.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ExtCreatePen", iPenStyle, cWidth, plbrush, cStyle, pstyle);
            }
            return (MemorySegment)mh$.invokeExact(iPenStyle, cWidth, plbrush, cStyle, pstyle);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetMiterLimit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetMiterLimit"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetMiterLimit(HDC hdc, PFLOAT plimit)
     * }
     */
    public static FunctionDescriptor GetMiterLimit$descriptor() {
        return GetMiterLimit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetMiterLimit(HDC hdc, PFLOAT plimit)
     * }
     */
    public static MethodHandle GetMiterLimit$handle() {
        return GetMiterLimit.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL GetMiterLimit(HDC hdc, PFLOAT plimit)
     * }
     */
    public static int GetMiterLimit(MemorySegment hdc, MemorySegment plimit) {
        var mh$ = GetMiterLimit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetMiterLimit", hdc, plimit);
            }
            return (int)mh$.invokeExact(hdc, plimit);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetArcDirection {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetArcDirection"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int GetArcDirection(HDC hdc)
     * }
     */
    public static FunctionDescriptor GetArcDirection$descriptor() {
        return GetArcDirection.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int GetArcDirection(HDC hdc)
     * }
     */
    public static MethodHandle GetArcDirection$handle() {
        return GetArcDirection.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int GetArcDirection(HDC hdc)
     * }
     */
    public static int GetArcDirection(MemorySegment hdc) {
        var mh$ = GetArcDirection.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetArcDirection", hdc);
            }
            return (int)mh$.invokeExact(hdc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetObjectA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetObjectA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int GetObjectA(HANDLE h, int c, LPVOID pv)
     * }
     */
    public static FunctionDescriptor GetObjectA$descriptor() {
        return GetObjectA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int GetObjectA(HANDLE h, int c, LPVOID pv)
     * }
     */
    public static MethodHandle GetObjectA$handle() {
        return GetObjectA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int GetObjectA(HANDLE h, int c, LPVOID pv)
     * }
     */
    public static int GetObjectA(MemorySegment h, int c, MemorySegment pv) {
        var mh$ = GetObjectA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetObjectA", h, c, pv);
            }
            return (int)mh$.invokeExact(h, c, pv);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetObjectW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetObjectW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int GetObjectW(HANDLE h, int c, LPVOID pv)
     * }
     */
    public static FunctionDescriptor GetObjectW$descriptor() {
        return GetObjectW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int GetObjectW(HANDLE h, int c, LPVOID pv)
     * }
     */
    public static MethodHandle GetObjectW$handle() {
        return GetObjectW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int GetObjectW(HANDLE h, int c, LPVOID pv)
     * }
     */
    public static int GetObjectW(MemorySegment h, int c, MemorySegment pv) {
        var mh$ = GetObjectW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetObjectW", h, c, pv);
            }
            return (int)mh$.invokeExact(h, c, pv);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MoveToEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_INT,
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("MoveToEx"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL MoveToEx(HDC hdc, int x, int y, LPPOINT lppt)
     * }
     */
    public static FunctionDescriptor MoveToEx$descriptor() {
        return MoveToEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL MoveToEx(HDC hdc, int x, int y, LPPOINT lppt)
     * }
     */
    public static MethodHandle MoveToEx$handle() {
        return MoveToEx.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL MoveToEx(HDC hdc, int x, int y, LPPOINT lppt)
     * }
     */
    public static int MoveToEx(MemorySegment hdc, int x, int y, MemorySegment lppt) {
        var mh$ = MoveToEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MoveToEx", hdc, x, y, lppt);
            }
            return (int)mh$.invokeExact(hdc, x, y, lppt);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TextOutA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_INT,
            C_INT,
            C_POINTER,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("TextOutA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL TextOutA(HDC hdc, int x, int y, LPCSTR lpString, int c)
     * }
     */
    public static FunctionDescriptor TextOutA$descriptor() {
        return TextOutA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL TextOutA(HDC hdc, int x, int y, LPCSTR lpString, int c)
     * }
     */
    public static MethodHandle TextOutA$handle() {
        return TextOutA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL TextOutA(HDC hdc, int x, int y, LPCSTR lpString, int c)
     * }
     */
    public static int TextOutA(MemorySegment hdc, int x, int y, MemorySegment lpString, int c) {
        var mh$ = TextOutA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TextOutA", hdc, x, y, lpString, c);
            }
            return (int)mh$.invokeExact(hdc, x, y, lpString, c);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TextOutW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_INT,
            C_INT,
            C_POINTER,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("TextOutW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL TextOutW(HDC hdc, int x, int y, LPCWSTR lpString, int c)
     * }
     */
    public static FunctionDescriptor TextOutW$descriptor() {
        return TextOutW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL TextOutW(HDC hdc, int x, int y, LPCWSTR lpString, int c)
     * }
     */
    public static MethodHandle TextOutW$handle() {
        return TextOutW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL TextOutW(HDC hdc, int x, int y, LPCWSTR lpString, int c)
     * }
     */
    public static int TextOutW(MemorySegment hdc, int x, int y, MemorySegment lpString, int c) {
        var mh$ = TextOutW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TextOutW", hdc, x, y, lpString, c);
            }
            return (int)mh$.invokeExact(hdc, x, y, lpString, c);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ExtTextOutA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_INT,
            C_INT,
            C_INT,
            C_POINTER,
            C_POINTER,
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("ExtTextOutA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL ExtTextOutA(HDC hdc, int x, int y, UINT options, const RECT *lprect, LPCSTR lpString, UINT c, const INT *lpDx)
     * }
     */
    public static FunctionDescriptor ExtTextOutA$descriptor() {
        return ExtTextOutA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL ExtTextOutA(HDC hdc, int x, int y, UINT options, const RECT *lprect, LPCSTR lpString, UINT c, const INT *lpDx)
     * }
     */
    public static MethodHandle ExtTextOutA$handle() {
        return ExtTextOutA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL ExtTextOutA(HDC hdc, int x, int y, UINT options, const RECT *lprect, LPCSTR lpString, UINT c, const INT *lpDx)
     * }
     */
    public static int ExtTextOutA(MemorySegment hdc, int x, int y, int options, MemorySegment lprect, MemorySegment lpString, int c, MemorySegment lpDx) {
        var mh$ = ExtTextOutA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ExtTextOutA", hdc, x, y, options, lprect, lpString, c, lpDx);
            }
            return (int)mh$.invokeExact(hdc, x, y, options, lprect, lpString, c, lpDx);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ExtTextOutW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_INT,
            C_INT,
            C_INT,
            C_POINTER,
            C_POINTER,
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("ExtTextOutW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL ExtTextOutW(HDC hdc, int x, int y, UINT options, const RECT *lprect, LPCWSTR lpString, UINT c, const INT *lpDx)
     * }
     */
    public static FunctionDescriptor ExtTextOutW$descriptor() {
        return ExtTextOutW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL ExtTextOutW(HDC hdc, int x, int y, UINT options, const RECT *lprect, LPCWSTR lpString, UINT c, const INT *lpDx)
     * }
     */
    public static MethodHandle ExtTextOutW$handle() {
        return ExtTextOutW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL ExtTextOutW(HDC hdc, int x, int y, UINT options, const RECT *lprect, LPCWSTR lpString, UINT c, const INT *lpDx)
     * }
     */
    public static int ExtTextOutW(MemorySegment hdc, int x, int y, int options, MemorySegment lprect, MemorySegment lpString, int c, MemorySegment lpDx) {
        var mh$ = ExtTextOutW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ExtTextOutW", hdc, x, y, options, lprect, lpString, c, lpDx);
            }
            return (int)mh$.invokeExact(hdc, x, y, options, lprect, lpString, c, lpDx);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PolyTextOutA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("PolyTextOutA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL PolyTextOutA(HDC hdc, const POLYTEXTA *ppt, int nstrings)
     * }
     */
    public static FunctionDescriptor PolyTextOutA$descriptor() {
        return PolyTextOutA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL PolyTextOutA(HDC hdc, const POLYTEXTA *ppt, int nstrings)
     * }
     */
    public static MethodHandle PolyTextOutA$handle() {
        return PolyTextOutA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL PolyTextOutA(HDC hdc, const POLYTEXTA *ppt, int nstrings)
     * }
     */
    public static int PolyTextOutA(MemorySegment hdc, MemorySegment ppt, int nstrings) {
        var mh$ = PolyTextOutA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PolyTextOutA", hdc, ppt, nstrings);
            }
            return (int)mh$.invokeExact(hdc, ppt, nstrings);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PolyTextOutW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("PolyTextOutW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL PolyTextOutW(HDC hdc, const POLYTEXTW *ppt, int nstrings)
     * }
     */
    public static FunctionDescriptor PolyTextOutW$descriptor() {
        return PolyTextOutW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL PolyTextOutW(HDC hdc, const POLYTEXTW *ppt, int nstrings)
     * }
     */
    public static MethodHandle PolyTextOutW$handle() {
        return PolyTextOutW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL PolyTextOutW(HDC hdc, const POLYTEXTW *ppt, int nstrings)
     * }
     */
    public static int PolyTextOutW(MemorySegment hdc, MemorySegment ppt, int nstrings) {
        var mh$ = PolyTextOutW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PolyTextOutW", hdc, ppt, nstrings);
            }
            return (int)mh$.invokeExact(hdc, ppt, nstrings);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreatePolygonRgn {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER,
            C_INT,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CreatePolygonRgn"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HRGN CreatePolygonRgn(const POINT *pptl, int cPoint, int iMode)
     * }
     */
    public static FunctionDescriptor CreatePolygonRgn$descriptor() {
        return CreatePolygonRgn.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HRGN CreatePolygonRgn(const POINT *pptl, int cPoint, int iMode)
     * }
     */
    public static MethodHandle CreatePolygonRgn$handle() {
        return CreatePolygonRgn.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * HRGN CreatePolygonRgn(const POINT *pptl, int cPoint, int iMode)
     * }
     */
    public static MemorySegment CreatePolygonRgn(MemorySegment pptl, int cPoint, int iMode) {
        var mh$ = CreatePolygonRgn.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreatePolygonRgn", pptl, cPoint, iMode);
            }
            return (MemorySegment)mh$.invokeExact(pptl, cPoint, iMode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DPtoLP {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("DPtoLP"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL DPtoLP(HDC hdc, LPPOINT lppt, int c)
     * }
     */
    public static FunctionDescriptor DPtoLP$descriptor() {
        return DPtoLP.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL DPtoLP(HDC hdc, LPPOINT lppt, int c)
     * }
     */
    public static MethodHandle DPtoLP$handle() {
        return DPtoLP.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL DPtoLP(HDC hdc, LPPOINT lppt, int c)
     * }
     */
    public static int DPtoLP(MemorySegment hdc, MemorySegment lppt, int c) {
        var mh$ = DPtoLP.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DPtoLP", hdc, lppt, c);
            }
            return (int)mh$.invokeExact(hdc, lppt, c);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LPtoDP {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("LPtoDP"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL LPtoDP(HDC hdc, LPPOINT lppt, int c)
     * }
     */
    public static FunctionDescriptor LPtoDP$descriptor() {
        return LPtoDP.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL LPtoDP(HDC hdc, LPPOINT lppt, int c)
     * }
     */
    public static MethodHandle LPtoDP$handle() {
        return LPtoDP.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL LPtoDP(HDC hdc, LPPOINT lppt, int c)
     * }
     */
    public static int LPtoDP(MemorySegment hdc, MemorySegment lppt, int c) {
        var mh$ = LPtoDP.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LPtoDP", hdc, lppt, c);
            }
            return (int)mh$.invokeExact(hdc, lppt, c);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Polygon {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("Polygon"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL Polygon(HDC hdc, const POINT *apt, int cpt)
     * }
     */
    public static FunctionDescriptor Polygon$descriptor() {
        return Polygon.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL Polygon(HDC hdc, const POINT *apt, int cpt)
     * }
     */
    public static MethodHandle Polygon$handle() {
        return Polygon.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL Polygon(HDC hdc, const POINT *apt, int cpt)
     * }
     */
    public static int Polygon(MemorySegment hdc, MemorySegment apt, int cpt) {
        var mh$ = Polygon.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Polygon", hdc, apt, cpt);
            }
            return (int)mh$.invokeExact(hdc, apt, cpt);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Polyline {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("Polyline"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL Polyline(HDC hdc, const POINT *apt, int cpt)
     * }
     */
    public static FunctionDescriptor Polyline$descriptor() {
        return Polyline.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL Polyline(HDC hdc, const POINT *apt, int cpt)
     * }
     */
    public static MethodHandle Polyline$handle() {
        return Polyline.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL Polyline(HDC hdc, const POINT *apt, int cpt)
     * }
     */
    public static int Polyline(MemorySegment hdc, MemorySegment apt, int cpt) {
        var mh$ = Polyline.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Polyline", hdc, apt, cpt);
            }
            return (int)mh$.invokeExact(hdc, apt, cpt);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PolyBezier {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("PolyBezier"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL PolyBezier(HDC hdc, const POINT *apt, DWORD cpt)
     * }
     */
    public static FunctionDescriptor PolyBezier$descriptor() {
        return PolyBezier.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL PolyBezier(HDC hdc, const POINT *apt, DWORD cpt)
     * }
     */
    public static MethodHandle PolyBezier$handle() {
        return PolyBezier.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL PolyBezier(HDC hdc, const POINT *apt, DWORD cpt)
     * }
     */
    public static int PolyBezier(MemorySegment hdc, MemorySegment apt, int cpt) {
        var mh$ = PolyBezier.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PolyBezier", hdc, apt, cpt);
            }
            return (int)mh$.invokeExact(hdc, apt, cpt);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PolyBezierTo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("PolyBezierTo"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL PolyBezierTo(HDC hdc, const POINT *apt, DWORD cpt)
     * }
     */
    public static FunctionDescriptor PolyBezierTo$descriptor() {
        return PolyBezierTo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL PolyBezierTo(HDC hdc, const POINT *apt, DWORD cpt)
     * }
     */
    public static MethodHandle PolyBezierTo$handle() {
        return PolyBezierTo.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL PolyBezierTo(HDC hdc, const POINT *apt, DWORD cpt)
     * }
     */
    public static int PolyBezierTo(MemorySegment hdc, MemorySegment apt, int cpt) {
        var mh$ = PolyBezierTo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PolyBezierTo", hdc, apt, cpt);
            }
            return (int)mh$.invokeExact(hdc, apt, cpt);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PolylineTo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("PolylineTo"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL PolylineTo(HDC hdc, const POINT *apt, DWORD cpt)
     * }
     */
    public static FunctionDescriptor PolylineTo$descriptor() {
        return PolylineTo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL PolylineTo(HDC hdc, const POINT *apt, DWORD cpt)
     * }
     */
    public static MethodHandle PolylineTo$handle() {
        return PolylineTo.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL PolylineTo(HDC hdc, const POINT *apt, DWORD cpt)
     * }
     */
    public static int PolylineTo(MemorySegment hdc, MemorySegment apt, int cpt) {
        var mh$ = PolylineTo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PolylineTo", hdc, apt, cpt);
            }
            return (int)mh$.invokeExact(hdc, apt, cpt);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetViewportExtEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_INT,
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("SetViewportExtEx"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetViewportExtEx(HDC hdc, int x, int y, LPSIZE lpsz)
     * }
     */
    public static FunctionDescriptor SetViewportExtEx$descriptor() {
        return SetViewportExtEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetViewportExtEx(HDC hdc, int x, int y, LPSIZE lpsz)
     * }
     */
    public static MethodHandle SetViewportExtEx$handle() {
        return SetViewportExtEx.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL SetViewportExtEx(HDC hdc, int x, int y, LPSIZE lpsz)
     * }
     */
    public static int SetViewportExtEx(MemorySegment hdc, int x, int y, MemorySegment lpsz) {
        var mh$ = SetViewportExtEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetViewportExtEx", hdc, x, y, lpsz);
            }
            return (int)mh$.invokeExact(hdc, x, y, lpsz);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetViewportOrgEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_INT,
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("SetViewportOrgEx"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetViewportOrgEx(HDC hdc, int x, int y, LPPOINT lppt)
     * }
     */
    public static FunctionDescriptor SetViewportOrgEx$descriptor() {
        return SetViewportOrgEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetViewportOrgEx(HDC hdc, int x, int y, LPPOINT lppt)
     * }
     */
    public static MethodHandle SetViewportOrgEx$handle() {
        return SetViewportOrgEx.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL SetViewportOrgEx(HDC hdc, int x, int y, LPPOINT lppt)
     * }
     */
    public static int SetViewportOrgEx(MemorySegment hdc, int x, int y, MemorySegment lppt) {
        var mh$ = SetViewportOrgEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetViewportOrgEx", hdc, x, y, lppt);
            }
            return (int)mh$.invokeExact(hdc, x, y, lppt);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetWindowExtEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_INT,
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("SetWindowExtEx"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetWindowExtEx(HDC hdc, int x, int y, LPSIZE lpsz)
     * }
     */
    public static FunctionDescriptor SetWindowExtEx$descriptor() {
        return SetWindowExtEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetWindowExtEx(HDC hdc, int x, int y, LPSIZE lpsz)
     * }
     */
    public static MethodHandle SetWindowExtEx$handle() {
        return SetWindowExtEx.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL SetWindowExtEx(HDC hdc, int x, int y, LPSIZE lpsz)
     * }
     */
    public static int SetWindowExtEx(MemorySegment hdc, int x, int y, MemorySegment lpsz) {
        var mh$ = SetWindowExtEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetWindowExtEx", hdc, x, y, lpsz);
            }
            return (int)mh$.invokeExact(hdc, x, y, lpsz);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetWindowOrgEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_INT,
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("SetWindowOrgEx"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetWindowOrgEx(HDC hdc, int x, int y, LPPOINT lppt)
     * }
     */
    public static FunctionDescriptor SetWindowOrgEx$descriptor() {
        return SetWindowOrgEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetWindowOrgEx(HDC hdc, int x, int y, LPPOINT lppt)
     * }
     */
    public static MethodHandle SetWindowOrgEx$handle() {
        return SetWindowOrgEx.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL SetWindowOrgEx(HDC hdc, int x, int y, LPPOINT lppt)
     * }
     */
    public static int SetWindowOrgEx(MemorySegment hdc, int x, int y, MemorySegment lppt) {
        var mh$ = SetWindowOrgEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetWindowOrgEx", hdc, x, y, lppt);
            }
            return (int)mh$.invokeExact(hdc, x, y, lppt);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class OffsetViewportOrgEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_INT,
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("OffsetViewportOrgEx"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL OffsetViewportOrgEx(HDC hdc, int x, int y, LPPOINT lppt)
     * }
     */
    public static FunctionDescriptor OffsetViewportOrgEx$descriptor() {
        return OffsetViewportOrgEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL OffsetViewportOrgEx(HDC hdc, int x, int y, LPPOINT lppt)
     * }
     */
    public static MethodHandle OffsetViewportOrgEx$handle() {
        return OffsetViewportOrgEx.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL OffsetViewportOrgEx(HDC hdc, int x, int y, LPPOINT lppt)
     * }
     */
    public static int OffsetViewportOrgEx(MemorySegment hdc, int x, int y, MemorySegment lppt) {
        var mh$ = OffsetViewportOrgEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("OffsetViewportOrgEx", hdc, x, y, lppt);
            }
            return (int)mh$.invokeExact(hdc, x, y, lppt);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class OffsetWindowOrgEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_INT,
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("OffsetWindowOrgEx"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL OffsetWindowOrgEx(HDC hdc, int x, int y, LPPOINT lppt)
     * }
     */
    public static FunctionDescriptor OffsetWindowOrgEx$descriptor() {
        return OffsetWindowOrgEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL OffsetWindowOrgEx(HDC hdc, int x, int y, LPPOINT lppt)
     * }
     */
    public static MethodHandle OffsetWindowOrgEx$handle() {
        return OffsetWindowOrgEx.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL OffsetWindowOrgEx(HDC hdc, int x, int y, LPPOINT lppt)
     * }
     */
    public static int OffsetWindowOrgEx(MemorySegment hdc, int x, int y, MemorySegment lppt) {
        var mh$ = OffsetWindowOrgEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("OffsetWindowOrgEx", hdc, x, y, lppt);
            }
            return (int)mh$.invokeExact(hdc, x, y, lppt);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ScaleViewportExtEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_INT,
            C_INT,
            C_INT,
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("ScaleViewportExtEx"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL ScaleViewportExtEx(HDC hdc, int xn, int dx, int yn, int yd, LPSIZE lpsz)
     * }
     */
    public static FunctionDescriptor ScaleViewportExtEx$descriptor() {
        return ScaleViewportExtEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL ScaleViewportExtEx(HDC hdc, int xn, int dx, int yn, int yd, LPSIZE lpsz)
     * }
     */
    public static MethodHandle ScaleViewportExtEx$handle() {
        return ScaleViewportExtEx.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL ScaleViewportExtEx(HDC hdc, int xn, int dx, int yn, int yd, LPSIZE lpsz)
     * }
     */
    public static int ScaleViewportExtEx(MemorySegment hdc, int xn, int dx, int yn, int yd, MemorySegment lpsz) {
        var mh$ = ScaleViewportExtEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ScaleViewportExtEx", hdc, xn, dx, yn, yd, lpsz);
            }
            return (int)mh$.invokeExact(hdc, xn, dx, yn, yd, lpsz);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ScaleWindowExtEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_INT,
            C_INT,
            C_INT,
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("ScaleWindowExtEx"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL ScaleWindowExtEx(HDC hdc, int xn, int xd, int yn, int yd, LPSIZE lpsz)
     * }
     */
    public static FunctionDescriptor ScaleWindowExtEx$descriptor() {
        return ScaleWindowExtEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL ScaleWindowExtEx(HDC hdc, int xn, int xd, int yn, int yd, LPSIZE lpsz)
     * }
     */
    public static MethodHandle ScaleWindowExtEx$handle() {
        return ScaleWindowExtEx.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL ScaleWindowExtEx(HDC hdc, int xn, int xd, int yn, int yd, LPSIZE lpsz)
     * }
     */
    public static int ScaleWindowExtEx(MemorySegment hdc, int xn, int xd, int yn, int yd, MemorySegment lpsz) {
        var mh$ = ScaleWindowExtEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ScaleWindowExtEx", hdc, xn, xd, yn, yd, lpsz);
            }
            return (int)mh$.invokeExact(hdc, xn, xd, yn, yd, lpsz);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetBitmapDimensionEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_INT,
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("SetBitmapDimensionEx"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetBitmapDimensionEx(HBITMAP hbm, int w, int h, LPSIZE lpsz)
     * }
     */
    public static FunctionDescriptor SetBitmapDimensionEx$descriptor() {
        return SetBitmapDimensionEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetBitmapDimensionEx(HBITMAP hbm, int w, int h, LPSIZE lpsz)
     * }
     */
    public static MethodHandle SetBitmapDimensionEx$handle() {
        return SetBitmapDimensionEx.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL SetBitmapDimensionEx(HBITMAP hbm, int w, int h, LPSIZE lpsz)
     * }
     */
    public static int SetBitmapDimensionEx(MemorySegment hbm, int w, int h, MemorySegment lpsz) {
        var mh$ = SetBitmapDimensionEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetBitmapDimensionEx", hbm, w, h, lpsz);
            }
            return (int)mh$.invokeExact(hbm, w, h, lpsz);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetBrushOrgEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_INT,
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("SetBrushOrgEx"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetBrushOrgEx(HDC hdc, int x, int y, LPPOINT lppt)
     * }
     */
    public static FunctionDescriptor SetBrushOrgEx$descriptor() {
        return SetBrushOrgEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetBrushOrgEx(HDC hdc, int x, int y, LPPOINT lppt)
     * }
     */
    public static MethodHandle SetBrushOrgEx$handle() {
        return SetBrushOrgEx.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL SetBrushOrgEx(HDC hdc, int x, int y, LPPOINT lppt)
     * }
     */
    public static int SetBrushOrgEx(MemorySegment hdc, int x, int y, MemorySegment lppt) {
        var mh$ = SetBrushOrgEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetBrushOrgEx", hdc, x, y, lppt);
            }
            return (int)mh$.invokeExact(hdc, x, y, lppt);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetTextFaceA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetTextFaceA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int GetTextFaceA(HDC hdc, int c, LPSTR lpName)
     * }
     */
    public static FunctionDescriptor GetTextFaceA$descriptor() {
        return GetTextFaceA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int GetTextFaceA(HDC hdc, int c, LPSTR lpName)
     * }
     */
    public static MethodHandle GetTextFaceA$handle() {
        return GetTextFaceA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int GetTextFaceA(HDC hdc, int c, LPSTR lpName)
     * }
     */
    public static int GetTextFaceA(MemorySegment hdc, int c, MemorySegment lpName) {
        var mh$ = GetTextFaceA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetTextFaceA", hdc, c, lpName);
            }
            return (int)mh$.invokeExact(hdc, c, lpName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetTextFaceW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetTextFaceW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int GetTextFaceW(HDC hdc, int c, LPWSTR lpName)
     * }
     */
    public static FunctionDescriptor GetTextFaceW$descriptor() {
        return GetTextFaceW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int GetTextFaceW(HDC hdc, int c, LPWSTR lpName)
     * }
     */
    public static MethodHandle GetTextFaceW$handle() {
        return GetTextFaceW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int GetTextFaceW(HDC hdc, int c, LPWSTR lpName)
     * }
     */
    public static int GetTextFaceW(MemorySegment hdc, int c, MemorySegment lpName) {
        var mh$ = GetTextFaceW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetTextFaceW", hdc, c, lpName);
            }
            return (int)mh$.invokeExact(hdc, c, lpName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct tagKERNINGPAIR {
     *     WORD wFirst;
     *     WORD wSecond;
     *     int iKernAmount;
     * } *LPKERNINGPAIR
     * }
     */
    public static final AddressLayout LPKERNINGPAIR = C_POINTER;

    private static class GetKerningPairsA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_POINTER,
            C_LONG,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetKerningPairsA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetKerningPairsA(HDC hdc, DWORD nPairs, LPKERNINGPAIR lpKernPair)
     * }
     */
    public static FunctionDescriptor GetKerningPairsA$descriptor() {
        return GetKerningPairsA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetKerningPairsA(HDC hdc, DWORD nPairs, LPKERNINGPAIR lpKernPair)
     * }
     */
    public static MethodHandle GetKerningPairsA$handle() {
        return GetKerningPairsA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * DWORD GetKerningPairsA(HDC hdc, DWORD nPairs, LPKERNINGPAIR lpKernPair)
     * }
     */
    public static int GetKerningPairsA(MemorySegment hdc, int nPairs, MemorySegment lpKernPair) {
        var mh$ = GetKerningPairsA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetKerningPairsA", hdc, nPairs, lpKernPair);
            }
            return (int)mh$.invokeExact(hdc, nPairs, lpKernPair);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetKerningPairsW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_POINTER,
            C_LONG,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetKerningPairsW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetKerningPairsW(HDC hdc, DWORD nPairs, LPKERNINGPAIR lpKernPair)
     * }
     */
    public static FunctionDescriptor GetKerningPairsW$descriptor() {
        return GetKerningPairsW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetKerningPairsW(HDC hdc, DWORD nPairs, LPKERNINGPAIR lpKernPair)
     * }
     */
    public static MethodHandle GetKerningPairsW$handle() {
        return GetKerningPairsW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * DWORD GetKerningPairsW(HDC hdc, DWORD nPairs, LPKERNINGPAIR lpKernPair)
     * }
     */
    public static int GetKerningPairsW(MemorySegment hdc, int nPairs, MemorySegment lpKernPair) {
        var mh$ = GetKerningPairsW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetKerningPairsW", hdc, nPairs, lpKernPair);
            }
            return (int)mh$.invokeExact(hdc, nPairs, lpKernPair);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetDCOrgEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetDCOrgEx"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetDCOrgEx(HDC hdc, LPPOINT lppt)
     * }
     */
    public static FunctionDescriptor GetDCOrgEx$descriptor() {
        return GetDCOrgEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetDCOrgEx(HDC hdc, LPPOINT lppt)
     * }
     */
    public static MethodHandle GetDCOrgEx$handle() {
        return GetDCOrgEx.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL GetDCOrgEx(HDC hdc, LPPOINT lppt)
     * }
     */
    public static int GetDCOrgEx(MemorySegment hdc, MemorySegment lppt) {
        var mh$ = GetDCOrgEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetDCOrgEx", hdc, lppt);
            }
            return (int)mh$.invokeExact(hdc, lppt);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FixBrushOrgEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_INT,
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("FixBrushOrgEx"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL FixBrushOrgEx(HDC hdc, int x, int y, LPPOINT ptl)
     * }
     */
    public static FunctionDescriptor FixBrushOrgEx$descriptor() {
        return FixBrushOrgEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL FixBrushOrgEx(HDC hdc, int x, int y, LPPOINT ptl)
     * }
     */
    public static MethodHandle FixBrushOrgEx$handle() {
        return FixBrushOrgEx.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL FixBrushOrgEx(HDC hdc, int x, int y, LPPOINT ptl)
     * }
     */
    public static int FixBrushOrgEx(MemorySegment hdc, int x, int y, MemorySegment ptl) {
        var mh$ = FixBrushOrgEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FixBrushOrgEx", hdc, x, y, ptl);
            }
            return (int)mh$.invokeExact(hdc, x, y, ptl);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class UnrealizeObject {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("UnrealizeObject"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL UnrealizeObject(HGDIOBJ h)
     * }
     */
    public static FunctionDescriptor UnrealizeObject$descriptor() {
        return UnrealizeObject.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL UnrealizeObject(HGDIOBJ h)
     * }
     */
    public static MethodHandle UnrealizeObject$handle() {
        return UnrealizeObject.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL UnrealizeObject(HGDIOBJ h)
     * }
     */
    public static int UnrealizeObject(MemorySegment h) {
        var mh$ = UnrealizeObject.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("UnrealizeObject", h);
            }
            return (int)mh$.invokeExact(h);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GdiFlush {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT    );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GdiFlush"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GdiFlush()
     * }
     */
    public static FunctionDescriptor GdiFlush$descriptor() {
        return GdiFlush.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GdiFlush()
     * }
     */
    public static MethodHandle GdiFlush$handle() {
        return GdiFlush.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL GdiFlush()
     * }
     */
    public static int GdiFlush() {
        var mh$ = GdiFlush.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GdiFlush");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GdiSetBatchLimit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GdiSetBatchLimit"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GdiSetBatchLimit(DWORD dw)
     * }
     */
    public static FunctionDescriptor GdiSetBatchLimit$descriptor() {
        return GdiSetBatchLimit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GdiSetBatchLimit(DWORD dw)
     * }
     */
    public static MethodHandle GdiSetBatchLimit$handle() {
        return GdiSetBatchLimit.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * DWORD GdiSetBatchLimit(DWORD dw)
     * }
     */
    public static int GdiSetBatchLimit(int dw) {
        var mh$ = GdiSetBatchLimit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GdiSetBatchLimit", dw);
            }
            return (int)mh$.invokeExact(dw);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GdiGetBatchLimit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG    );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GdiGetBatchLimit"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GdiGetBatchLimit()
     * }
     */
    public static FunctionDescriptor GdiGetBatchLimit$descriptor() {
        return GdiGetBatchLimit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GdiGetBatchLimit()
     * }
     */
    public static MethodHandle GdiGetBatchLimit$handle() {
        return GdiGetBatchLimit.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * DWORD GdiGetBatchLimit()
     * }
     */
    public static int GdiGetBatchLimit() {
        var mh$ = GdiGetBatchLimit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GdiGetBatchLimit");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetICMMode {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("SetICMMode"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SetICMMode(HDC hdc, int mode)
     * }
     */
    public static FunctionDescriptor SetICMMode$descriptor() {
        return SetICMMode.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SetICMMode(HDC hdc, int mode)
     * }
     */
    public static MethodHandle SetICMMode$handle() {
        return SetICMMode.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int SetICMMode(HDC hdc, int mode)
     * }
     */
    public static int SetICMMode(MemorySegment hdc, int mode) {
        var mh$ = SetICMMode.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetICMMode", hdc, mode);
            }
            return (int)mh$.invokeExact(hdc, mode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CheckColorsInGamut {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CheckColorsInGamut"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CheckColorsInGamut(HDC hdc, LPRGBTRIPLE lpRGBTriple, LPVOID dlpBuffer, DWORD nCount)
     * }
     */
    public static FunctionDescriptor CheckColorsInGamut$descriptor() {
        return CheckColorsInGamut.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CheckColorsInGamut(HDC hdc, LPRGBTRIPLE lpRGBTriple, LPVOID dlpBuffer, DWORD nCount)
     * }
     */
    public static MethodHandle CheckColorsInGamut$handle() {
        return CheckColorsInGamut.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL CheckColorsInGamut(HDC hdc, LPRGBTRIPLE lpRGBTriple, LPVOID dlpBuffer, DWORD nCount)
     * }
     */
    public static int CheckColorsInGamut(MemorySegment hdc, MemorySegment lpRGBTriple, MemorySegment dlpBuffer, int nCount) {
        var mh$ = CheckColorsInGamut.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CheckColorsInGamut", hdc, lpRGBTriple, dlpBuffer, nCount);
            }
            return (int)mh$.invokeExact(hdc, lpRGBTriple, dlpBuffer, nCount);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetColorSpace {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetColorSpace"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HCOLORSPACE GetColorSpace(HDC hdc)
     * }
     */
    public static FunctionDescriptor GetColorSpace$descriptor() {
        return GetColorSpace.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HCOLORSPACE GetColorSpace(HDC hdc)
     * }
     */
    public static MethodHandle GetColorSpace$handle() {
        return GetColorSpace.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * HCOLORSPACE GetColorSpace(HDC hdc)
     * }
     */
    public static MemorySegment GetColorSpace(MemorySegment hdc) {
        var mh$ = GetColorSpace.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetColorSpace", hdc);
            }
            return (MemorySegment)mh$.invokeExact(hdc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetLogColorSpaceA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetLogColorSpaceA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetLogColorSpaceA(HCOLORSPACE hColorSpace, LPLOGCOLORSPACEA lpBuffer, DWORD nSize)
     * }
     */
    public static FunctionDescriptor GetLogColorSpaceA$descriptor() {
        return GetLogColorSpaceA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetLogColorSpaceA(HCOLORSPACE hColorSpace, LPLOGCOLORSPACEA lpBuffer, DWORD nSize)
     * }
     */
    public static MethodHandle GetLogColorSpaceA$handle() {
        return GetLogColorSpaceA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL GetLogColorSpaceA(HCOLORSPACE hColorSpace, LPLOGCOLORSPACEA lpBuffer, DWORD nSize)
     * }
     */
    public static int GetLogColorSpaceA(MemorySegment hColorSpace, MemorySegment lpBuffer, int nSize) {
        var mh$ = GetLogColorSpaceA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetLogColorSpaceA", hColorSpace, lpBuffer, nSize);
            }
            return (int)mh$.invokeExact(hColorSpace, lpBuffer, nSize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetLogColorSpaceW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetLogColorSpaceW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetLogColorSpaceW(HCOLORSPACE hColorSpace, LPLOGCOLORSPACEW lpBuffer, DWORD nSize)
     * }
     */
    public static FunctionDescriptor GetLogColorSpaceW$descriptor() {
        return GetLogColorSpaceW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetLogColorSpaceW(HCOLORSPACE hColorSpace, LPLOGCOLORSPACEW lpBuffer, DWORD nSize)
     * }
     */
    public static MethodHandle GetLogColorSpaceW$handle() {
        return GetLogColorSpaceW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL GetLogColorSpaceW(HCOLORSPACE hColorSpace, LPLOGCOLORSPACEW lpBuffer, DWORD nSize)
     * }
     */
    public static int GetLogColorSpaceW(MemorySegment hColorSpace, MemorySegment lpBuffer, int nSize) {
        var mh$ = GetLogColorSpaceW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetLogColorSpaceW", hColorSpace, lpBuffer, nSize);
            }
            return (int)mh$.invokeExact(hColorSpace, lpBuffer, nSize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateColorSpaceA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CreateColorSpaceA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HCOLORSPACE CreateColorSpaceA(LPLOGCOLORSPACEA lplcs)
     * }
     */
    public static FunctionDescriptor CreateColorSpaceA$descriptor() {
        return CreateColorSpaceA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HCOLORSPACE CreateColorSpaceA(LPLOGCOLORSPACEA lplcs)
     * }
     */
    public static MethodHandle CreateColorSpaceA$handle() {
        return CreateColorSpaceA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * HCOLORSPACE CreateColorSpaceA(LPLOGCOLORSPACEA lplcs)
     * }
     */
    public static MemorySegment CreateColorSpaceA(MemorySegment lplcs) {
        var mh$ = CreateColorSpaceA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateColorSpaceA", lplcs);
            }
            return (MemorySegment)mh$.invokeExact(lplcs);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateColorSpaceW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CreateColorSpaceW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HCOLORSPACE CreateColorSpaceW(LPLOGCOLORSPACEW lplcs)
     * }
     */
    public static FunctionDescriptor CreateColorSpaceW$descriptor() {
        return CreateColorSpaceW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HCOLORSPACE CreateColorSpaceW(LPLOGCOLORSPACEW lplcs)
     * }
     */
    public static MethodHandle CreateColorSpaceW$handle() {
        return CreateColorSpaceW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * HCOLORSPACE CreateColorSpaceW(LPLOGCOLORSPACEW lplcs)
     * }
     */
    public static MemorySegment CreateColorSpaceW(MemorySegment lplcs) {
        var mh$ = CreateColorSpaceW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateColorSpaceW", lplcs);
            }
            return (MemorySegment)mh$.invokeExact(lplcs);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetColorSpace {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("SetColorSpace"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HCOLORSPACE SetColorSpace(HDC hdc, HCOLORSPACE hcs)
     * }
     */
    public static FunctionDescriptor SetColorSpace$descriptor() {
        return SetColorSpace.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HCOLORSPACE SetColorSpace(HDC hdc, HCOLORSPACE hcs)
     * }
     */
    public static MethodHandle SetColorSpace$handle() {
        return SetColorSpace.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * HCOLORSPACE SetColorSpace(HDC hdc, HCOLORSPACE hcs)
     * }
     */
    public static MemorySegment SetColorSpace(MemorySegment hdc, MemorySegment hcs) {
        var mh$ = SetColorSpace.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetColorSpace", hdc, hcs);
            }
            return (MemorySegment)mh$.invokeExact(hdc, hcs);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DeleteColorSpace {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("DeleteColorSpace"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL DeleteColorSpace(HCOLORSPACE hcs)
     * }
     */
    public static FunctionDescriptor DeleteColorSpace$descriptor() {
        return DeleteColorSpace.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL DeleteColorSpace(HCOLORSPACE hcs)
     * }
     */
    public static MethodHandle DeleteColorSpace$handle() {
        return DeleteColorSpace.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL DeleteColorSpace(HCOLORSPACE hcs)
     * }
     */
    public static int DeleteColorSpace(MemorySegment hcs) {
        var mh$ = DeleteColorSpace.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DeleteColorSpace", hcs);
            }
            return (int)mh$.invokeExact(hcs);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetICMProfileA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetICMProfileA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetICMProfileA(HDC hdc, LPDWORD pBufSize, LPSTR pszFilename)
     * }
     */
    public static FunctionDescriptor GetICMProfileA$descriptor() {
        return GetICMProfileA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetICMProfileA(HDC hdc, LPDWORD pBufSize, LPSTR pszFilename)
     * }
     */
    public static MethodHandle GetICMProfileA$handle() {
        return GetICMProfileA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL GetICMProfileA(HDC hdc, LPDWORD pBufSize, LPSTR pszFilename)
     * }
     */
    public static int GetICMProfileA(MemorySegment hdc, MemorySegment pBufSize, MemorySegment pszFilename) {
        var mh$ = GetICMProfileA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetICMProfileA", hdc, pBufSize, pszFilename);
            }
            return (int)mh$.invokeExact(hdc, pBufSize, pszFilename);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetICMProfileW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetICMProfileW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetICMProfileW(HDC hdc, LPDWORD pBufSize, LPWSTR pszFilename)
     * }
     */
    public static FunctionDescriptor GetICMProfileW$descriptor() {
        return GetICMProfileW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetICMProfileW(HDC hdc, LPDWORD pBufSize, LPWSTR pszFilename)
     * }
     */
    public static MethodHandle GetICMProfileW$handle() {
        return GetICMProfileW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL GetICMProfileW(HDC hdc, LPDWORD pBufSize, LPWSTR pszFilename)
     * }
     */
    public static int GetICMProfileW(MemorySegment hdc, MemorySegment pBufSize, MemorySegment pszFilename) {
        var mh$ = GetICMProfileW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetICMProfileW", hdc, pBufSize, pszFilename);
            }
            return (int)mh$.invokeExact(hdc, pBufSize, pszFilename);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetICMProfileA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("SetICMProfileA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetICMProfileA(HDC hdc, LPSTR lpFileName)
     * }
     */
    public static FunctionDescriptor SetICMProfileA$descriptor() {
        return SetICMProfileA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetICMProfileA(HDC hdc, LPSTR lpFileName)
     * }
     */
    public static MethodHandle SetICMProfileA$handle() {
        return SetICMProfileA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL SetICMProfileA(HDC hdc, LPSTR lpFileName)
     * }
     */
    public static int SetICMProfileA(MemorySegment hdc, MemorySegment lpFileName) {
        var mh$ = SetICMProfileA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetICMProfileA", hdc, lpFileName);
            }
            return (int)mh$.invokeExact(hdc, lpFileName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetICMProfileW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("SetICMProfileW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetICMProfileW(HDC hdc, LPWSTR lpFileName)
     * }
     */
    public static FunctionDescriptor SetICMProfileW$descriptor() {
        return SetICMProfileW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetICMProfileW(HDC hdc, LPWSTR lpFileName)
     * }
     */
    public static MethodHandle SetICMProfileW$handle() {
        return SetICMProfileW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL SetICMProfileW(HDC hdc, LPWSTR lpFileName)
     * }
     */
    public static int SetICMProfileW(MemorySegment hdc, MemorySegment lpFileName) {
        var mh$ = SetICMProfileW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetICMProfileW", hdc, lpFileName);
            }
            return (int)mh$.invokeExact(hdc, lpFileName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetDeviceGammaRamp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetDeviceGammaRamp"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetDeviceGammaRamp(HDC hdc, LPVOID lpRamp)
     * }
     */
    public static FunctionDescriptor GetDeviceGammaRamp$descriptor() {
        return GetDeviceGammaRamp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetDeviceGammaRamp(HDC hdc, LPVOID lpRamp)
     * }
     */
    public static MethodHandle GetDeviceGammaRamp$handle() {
        return GetDeviceGammaRamp.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL GetDeviceGammaRamp(HDC hdc, LPVOID lpRamp)
     * }
     */
    public static int GetDeviceGammaRamp(MemorySegment hdc, MemorySegment lpRamp) {
        var mh$ = GetDeviceGammaRamp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetDeviceGammaRamp", hdc, lpRamp);
            }
            return (int)mh$.invokeExact(hdc, lpRamp);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetDeviceGammaRamp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("SetDeviceGammaRamp"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetDeviceGammaRamp(HDC hdc, LPVOID lpRamp)
     * }
     */
    public static FunctionDescriptor SetDeviceGammaRamp$descriptor() {
        return SetDeviceGammaRamp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetDeviceGammaRamp(HDC hdc, LPVOID lpRamp)
     * }
     */
    public static MethodHandle SetDeviceGammaRamp$handle() {
        return SetDeviceGammaRamp.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL SetDeviceGammaRamp(HDC hdc, LPVOID lpRamp)
     * }
     */
    public static int SetDeviceGammaRamp(MemorySegment hdc, MemorySegment lpRamp) {
        var mh$ = SetDeviceGammaRamp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetDeviceGammaRamp", hdc, lpRamp);
            }
            return (int)mh$.invokeExact(hdc, lpRamp);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ColorMatchToTarget {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("ColorMatchToTarget"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL ColorMatchToTarget(HDC hdc, HDC hdcTarget, DWORD action)
     * }
     */
    public static FunctionDescriptor ColorMatchToTarget$descriptor() {
        return ColorMatchToTarget.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL ColorMatchToTarget(HDC hdc, HDC hdcTarget, DWORD action)
     * }
     */
    public static MethodHandle ColorMatchToTarget$handle() {
        return ColorMatchToTarget.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL ColorMatchToTarget(HDC hdc, HDC hdcTarget, DWORD action)
     * }
     */
    public static int ColorMatchToTarget(MemorySegment hdc, MemorySegment hdcTarget, int action) {
        var mh$ = ColorMatchToTarget.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ColorMatchToTarget", hdc, hdcTarget, action);
            }
            return (int)mh$.invokeExact(hdc, hdcTarget, action);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class EnumICMProfilesA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_LONG_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("EnumICMProfilesA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int EnumICMProfilesA(HDC hdc, ICMENUMPROCA proc, LPARAM param)
     * }
     */
    public static FunctionDescriptor EnumICMProfilesA$descriptor() {
        return EnumICMProfilesA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int EnumICMProfilesA(HDC hdc, ICMENUMPROCA proc, LPARAM param)
     * }
     */
    public static MethodHandle EnumICMProfilesA$handle() {
        return EnumICMProfilesA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int EnumICMProfilesA(HDC hdc, ICMENUMPROCA proc, LPARAM param)
     * }
     */
    public static int EnumICMProfilesA(MemorySegment hdc, MemorySegment proc, long param) {
        var mh$ = EnumICMProfilesA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("EnumICMProfilesA", hdc, proc, param);
            }
            return (int)mh$.invokeExact(hdc, proc, param);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class EnumICMProfilesW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_LONG_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("EnumICMProfilesW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int EnumICMProfilesW(HDC hdc, ICMENUMPROCW proc, LPARAM param)
     * }
     */
    public static FunctionDescriptor EnumICMProfilesW$descriptor() {
        return EnumICMProfilesW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int EnumICMProfilesW(HDC hdc, ICMENUMPROCW proc, LPARAM param)
     * }
     */
    public static MethodHandle EnumICMProfilesW$handle() {
        return EnumICMProfilesW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int EnumICMProfilesW(HDC hdc, ICMENUMPROCW proc, LPARAM param)
     * }
     */
    public static int EnumICMProfilesW(MemorySegment hdc, MemorySegment proc, long param) {
        var mh$ = EnumICMProfilesW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("EnumICMProfilesW", hdc, proc, param);
            }
            return (int)mh$.invokeExact(hdc, proc, param);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class UpdateICMRegKeyA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_LONG,
            C_POINTER,
            C_POINTER,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("UpdateICMRegKeyA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL UpdateICMRegKeyA(DWORD reserved, LPSTR lpszCMID, LPSTR lpszFileName, UINT command)
     * }
     */
    public static FunctionDescriptor UpdateICMRegKeyA$descriptor() {
        return UpdateICMRegKeyA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL UpdateICMRegKeyA(DWORD reserved, LPSTR lpszCMID, LPSTR lpszFileName, UINT command)
     * }
     */
    public static MethodHandle UpdateICMRegKeyA$handle() {
        return UpdateICMRegKeyA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL UpdateICMRegKeyA(DWORD reserved, LPSTR lpszCMID, LPSTR lpszFileName, UINT command)
     * }
     */
    public static int UpdateICMRegKeyA(int reserved, MemorySegment lpszCMID, MemorySegment lpszFileName, int command) {
        var mh$ = UpdateICMRegKeyA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("UpdateICMRegKeyA", reserved, lpszCMID, lpszFileName, command);
            }
            return (int)mh$.invokeExact(reserved, lpszCMID, lpszFileName, command);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class UpdateICMRegKeyW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_LONG,
            C_POINTER,
            C_POINTER,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("UpdateICMRegKeyW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL UpdateICMRegKeyW(DWORD reserved, LPWSTR lpszCMID, LPWSTR lpszFileName, UINT command)
     * }
     */
    public static FunctionDescriptor UpdateICMRegKeyW$descriptor() {
        return UpdateICMRegKeyW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL UpdateICMRegKeyW(DWORD reserved, LPWSTR lpszCMID, LPWSTR lpszFileName, UINT command)
     * }
     */
    public static MethodHandle UpdateICMRegKeyW$handle() {
        return UpdateICMRegKeyW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL UpdateICMRegKeyW(DWORD reserved, LPWSTR lpszCMID, LPWSTR lpszFileName, UINT command)
     * }
     */
    public static int UpdateICMRegKeyW(int reserved, MemorySegment lpszCMID, MemorySegment lpszFileName, int command) {
        var mh$ = UpdateICMRegKeyW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("UpdateICMRegKeyW", reserved, lpszCMID, lpszFileName, command);
            }
            return (int)mh$.invokeExact(reserved, lpszCMID, lpszFileName, command);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ColorCorrectPalette {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_LONG,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("ColorCorrectPalette"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL ColorCorrectPalette(HDC hdc, HPALETTE hPal, DWORD deFirst, DWORD num)
     * }
     */
    public static FunctionDescriptor ColorCorrectPalette$descriptor() {
        return ColorCorrectPalette.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL ColorCorrectPalette(HDC hdc, HPALETTE hPal, DWORD deFirst, DWORD num)
     * }
     */
    public static MethodHandle ColorCorrectPalette$handle() {
        return ColorCorrectPalette.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL ColorCorrectPalette(HDC hdc, HPALETTE hPal, DWORD deFirst, DWORD num)
     * }
     */
    public static int ColorCorrectPalette(MemorySegment hdc, MemorySegment hPal, int deFirst, int num) {
        var mh$ = ColorCorrectPalette.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ColorCorrectPalette", hdc, hPal, deFirst, num);
            }
            return (int)mh$.invokeExact(hdc, hPal, deFirst, num);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct tagEMR {
     *     DWORD iType;
     *     DWORD nSize;
     * } *PEMR
     * }
     */
    public static final AddressLayout PEMR = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMRTEXT {
     *     POINTL ptlReference;
     *     DWORD nChars;
     *     DWORD offString;
     *     DWORD fOptions;
     *     RECTL rcl;
     *     DWORD offDx;
     * } *PEMRTEXT
     * }
     */
    public static final AddressLayout PEMRTEXT = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagABORTPATH {
     *     EMR emr;
     * } *PEMRABORTPATH
     * }
     */
    public static final AddressLayout PEMRABORTPATH = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagABORTPATH {
     *     EMR emr;
     * } *PEMRBEGINPATH
     * }
     */
    public static final AddressLayout PEMRBEGINPATH = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagABORTPATH {
     *     EMR emr;
     * } *PEMRENDPATH
     * }
     */
    public static final AddressLayout PEMRENDPATH = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagABORTPATH {
     *     EMR emr;
     * } *PEMRCLOSEFIGURE
     * }
     */
    public static final AddressLayout PEMRCLOSEFIGURE = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagABORTPATH {
     *     EMR emr;
     * } *PEMRFLATTENPATH
     * }
     */
    public static final AddressLayout PEMRFLATTENPATH = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagABORTPATH {
     *     EMR emr;
     * } *PEMRWIDENPATH
     * }
     */
    public static final AddressLayout PEMRWIDENPATH = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagABORTPATH {
     *     EMR emr;
     * } *PEMRSETMETARGN
     * }
     */
    public static final AddressLayout PEMRSETMETARGN = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagABORTPATH {
     *     EMR emr;
     * } *PEMRSAVEDC
     * }
     */
    public static final AddressLayout PEMRSAVEDC = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagABORTPATH {
     *     EMR emr;
     * } *PEMRREALIZEPALETTE
     * }
     */
    public static final AddressLayout PEMRREALIZEPALETTE = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMRSELECTCLIPPATH {
     *     EMR emr;
     *     DWORD iMode;
     * } *PEMRSELECTCLIPPATH
     * }
     */
    public static final AddressLayout PEMRSELECTCLIPPATH = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMRSELECTCLIPPATH {
     *     EMR emr;
     *     DWORD iMode;
     * } *PEMRSETBKMODE
     * }
     */
    public static final AddressLayout PEMRSETBKMODE = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMRSELECTCLIPPATH {
     *     EMR emr;
     *     DWORD iMode;
     * } *PEMRSETMAPMODE
     * }
     */
    public static final AddressLayout PEMRSETMAPMODE = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMRSELECTCLIPPATH {
     *     EMR emr;
     *     DWORD iMode;
     * } *PEMRSETLAYOUT
     * }
     */
    public static final AddressLayout PEMRSETLAYOUT = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMRSELECTCLIPPATH {
     *     EMR emr;
     *     DWORD iMode;
     * } *PEMRSETPOLYFILLMODE
     * }
     */
    public static final AddressLayout PEMRSETPOLYFILLMODE = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMRSELECTCLIPPATH {
     *     EMR emr;
     *     DWORD iMode;
     * } *PEMRSETROP2
     * }
     */
    public static final AddressLayout PEMRSETROP2 = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMRSELECTCLIPPATH {
     *     EMR emr;
     *     DWORD iMode;
     * } *PEMRSETSTRETCHBLTMODE
     * }
     */
    public static final AddressLayout PEMRSETSTRETCHBLTMODE = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMRSELECTCLIPPATH {
     *     EMR emr;
     *     DWORD iMode;
     * } *PEMRSETICMMODE
     * }
     */
    public static final AddressLayout PEMRSETICMMODE = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMRSELECTCLIPPATH {
     *     EMR emr;
     *     DWORD iMode;
     * } *PEMRSETTEXTALIGN
     * }
     */
    public static final AddressLayout PEMRSETTEXTALIGN = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMRSETMITERLIMIT {
     *     EMR emr;
     *     FLOAT eMiterLimit;
     * } *PEMRSETMITERLIMIT
     * }
     */
    public static final AddressLayout PEMRSETMITERLIMIT = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMRRESTOREDC {
     *     EMR emr;
     *     LONG iRelative;
     * } *PEMRRESTOREDC
     * }
     */
    public static final AddressLayout PEMRRESTOREDC = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMRSETARCDIRECTION {
     *     EMR emr;
     *     DWORD iArcDirection;
     * } *PEMRSETARCDIRECTION
     * }
     */
    public static final AddressLayout PEMRSETARCDIRECTION = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMRSETMAPPERFLAGS {
     *     EMR emr;
     *     DWORD dwFlags;
     * } *PEMRSETMAPPERFLAGS
     * }
     */
    public static final AddressLayout PEMRSETMAPPERFLAGS = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMRSETTEXTCOLOR {
     *     EMR emr;
     *     COLORREF crColor;
     * } *PEMRSETBKCOLOR
     * }
     */
    public static final AddressLayout PEMRSETBKCOLOR = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMRSETTEXTCOLOR {
     *     EMR emr;
     *     COLORREF crColor;
     * } *PEMRSETTEXTCOLOR
     * }
     */
    public static final AddressLayout PEMRSETTEXTCOLOR = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMRSELECTOBJECT {
     *     EMR emr;
     *     DWORD ihObject;
     * } *PEMRSELECTOBJECT
     * }
     */
    public static final AddressLayout PEMRSELECTOBJECT = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMRSELECTOBJECT {
     *     EMR emr;
     *     DWORD ihObject;
     * } *PEMRDELETEOBJECT
     * }
     */
    public static final AddressLayout PEMRDELETEOBJECT = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMRSELECTPALETTE {
     *     EMR emr;
     *     DWORD ihPal;
     * } *PEMRSELECTPALETTE
     * }
     */
    public static final AddressLayout PEMRSELECTPALETTE = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMRRESIZEPALETTE {
     *     EMR emr;
     *     DWORD ihPal;
     *     DWORD cEntries;
     * } *PEMRRESIZEPALETTE
     * }
     */
    public static final AddressLayout PEMRRESIZEPALETTE = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMRSETPALETTEENTRIES {
     *     EMR emr;
     *     DWORD ihPal;
     *     DWORD iStart;
     *     DWORD cEntries;
     *     PALETTEENTRY aPalEntries[1];
     * } *PEMRSETPALETTEENTRIES
     * }
     */
    public static final AddressLayout PEMRSETPALETTEENTRIES = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMRSETCOLORADJUSTMENT {
     *     EMR emr;
     *     COLORADJUSTMENT ColorAdjustment;
     * } *PEMRSETCOLORADJUSTMENT
     * }
     */
    public static final AddressLayout PEMRSETCOLORADJUSTMENT = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMRGDICOMMENT {
     *     EMR emr;
     *     DWORD cbData;
     *     BYTE Data[1];
     * } *PEMRGDICOMMENT
     * }
     */
    public static final AddressLayout PEMRGDICOMMENT = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMREOF {
     *     EMR emr;
     *     DWORD nPalEntries;
     *     DWORD offPalEntries;
     *     DWORD nSizeLast;
     * } *PEMREOF
     * }
     */
    public static final AddressLayout PEMREOF = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMRLINETO {
     *     EMR emr;
     *     POINTL ptl;
     * } *PEMRLINETO
     * }
     */
    public static final AddressLayout PEMRLINETO = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMRLINETO {
     *     EMR emr;
     *     POINTL ptl;
     * } *PEMRMOVETOEX
     * }
     */
    public static final AddressLayout PEMRMOVETOEX = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMROFFSETCLIPRGN {
     *     EMR emr;
     *     POINTL ptlOffset;
     * } *PEMROFFSETCLIPRGN
     * }
     */
    public static final AddressLayout PEMROFFSETCLIPRGN = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMRFILLPATH {
     *     EMR emr;
     *     RECTL rclBounds;
     * } *PEMRFILLPATH
     * }
     */
    public static final AddressLayout PEMRFILLPATH = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMRFILLPATH {
     *     EMR emr;
     *     RECTL rclBounds;
     * } *PEMRSTROKEANDFILLPATH
     * }
     */
    public static final AddressLayout PEMRSTROKEANDFILLPATH = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMRFILLPATH {
     *     EMR emr;
     *     RECTL rclBounds;
     * } *PEMRSTROKEPATH
     * }
     */
    public static final AddressLayout PEMRSTROKEPATH = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMREXCLUDECLIPRECT {
     *     EMR emr;
     *     RECTL rclClip;
     * } *PEMREXCLUDECLIPRECT
     * }
     */
    public static final AddressLayout PEMREXCLUDECLIPRECT = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMREXCLUDECLIPRECT {
     *     EMR emr;
     *     RECTL rclClip;
     * } *PEMRINTERSECTCLIPRECT
     * }
     */
    public static final AddressLayout PEMRINTERSECTCLIPRECT = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMRSETVIEWPORTORGEX {
     *     EMR emr;
     *     POINTL ptlOrigin;
     * } *PEMRSETVIEWPORTORGEX
     * }
     */
    public static final AddressLayout PEMRSETVIEWPORTORGEX = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMRSETVIEWPORTORGEX {
     *     EMR emr;
     *     POINTL ptlOrigin;
     * } *PEMRSETWINDOWORGEX
     * }
     */
    public static final AddressLayout PEMRSETWINDOWORGEX = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMRSETVIEWPORTORGEX {
     *     EMR emr;
     *     POINTL ptlOrigin;
     * } *PEMRSETBRUSHORGEX
     * }
     */
    public static final AddressLayout PEMRSETBRUSHORGEX = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMRSETVIEWPORTEXTEX {
     *     EMR emr;
     *     SIZEL szlExtent;
     * } *PEMRSETVIEWPORTEXTEX
     * }
     */
    public static final AddressLayout PEMRSETVIEWPORTEXTEX = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMRSETVIEWPORTEXTEX {
     *     EMR emr;
     *     SIZEL szlExtent;
     * } *PEMRSETWINDOWEXTEX
     * }
     */
    public static final AddressLayout PEMRSETWINDOWEXTEX = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMRSCALEVIEWPORTEXTEX {
     *     EMR emr;
     *     LONG xNum;
     *     LONG xDenom;
     *     LONG yNum;
     *     LONG yDenom;
     * } *PEMRSCALEVIEWPORTEXTEX
     * }
     */
    public static final AddressLayout PEMRSCALEVIEWPORTEXTEX = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMRSCALEVIEWPORTEXTEX {
     *     EMR emr;
     *     LONG xNum;
     *     LONG xDenom;
     *     LONG yNum;
     *     LONG yDenom;
     * } *PEMRSCALEWINDOWEXTEX
     * }
     */
    public static final AddressLayout PEMRSCALEWINDOWEXTEX = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMRSETWORLDTRANSFORM {
     *     EMR emr;
     *     XFORM xform;
     * } *PEMRSETWORLDTRANSFORM
     * }
     */
    public static final AddressLayout PEMRSETWORLDTRANSFORM = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMRMODIFYWORLDTRANSFORM {
     *     EMR emr;
     *     XFORM xform;
     *     DWORD iMode;
     * } *PEMRMODIFYWORLDTRANSFORM
     * }
     */
    public static final AddressLayout PEMRMODIFYWORLDTRANSFORM = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMRSETPIXELV {
     *     EMR emr;
     *     POINTL ptlPixel;
     *     COLORREF crColor;
     * } *PEMRSETPIXELV
     * }
     */
    public static final AddressLayout PEMRSETPIXELV = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMREXTFLOODFILL {
     *     EMR emr;
     *     POINTL ptlStart;
     *     COLORREF crColor;
     *     DWORD iMode;
     * } *PEMREXTFLOODFILL
     * }
     */
    public static final AddressLayout PEMREXTFLOODFILL = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMRELLIPSE {
     *     EMR emr;
     *     RECTL rclBox;
     * } *PEMRELLIPSE
     * }
     */
    public static final AddressLayout PEMRELLIPSE = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMRELLIPSE {
     *     EMR emr;
     *     RECTL rclBox;
     * } *PEMRRECTANGLE
     * }
     */
    public static final AddressLayout PEMRRECTANGLE = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMRROUNDRECT {
     *     EMR emr;
     *     RECTL rclBox;
     *     SIZEL szlCorner;
     * } *PEMRROUNDRECT
     * }
     */
    public static final AddressLayout PEMRROUNDRECT = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMRARC {
     *     EMR emr;
     *     RECTL rclBox;
     *     POINTL ptlStart;
     *     POINTL ptlEnd;
     * } *PEMRARC
     * }
     */
    public static final AddressLayout PEMRARC = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMRARC {
     *     EMR emr;
     *     RECTL rclBox;
     *     POINTL ptlStart;
     *     POINTL ptlEnd;
     * } *PEMRARCTO
     * }
     */
    public static final AddressLayout PEMRARCTO = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMRARC {
     *     EMR emr;
     *     RECTL rclBox;
     *     POINTL ptlStart;
     *     POINTL ptlEnd;
     * } *PEMRCHORD
     * }
     */
    public static final AddressLayout PEMRCHORD = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMRARC {
     *     EMR emr;
     *     RECTL rclBox;
     *     POINTL ptlStart;
     *     POINTL ptlEnd;
     * } *PEMRPIE
     * }
     */
    public static final AddressLayout PEMRPIE = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMRANGLEARC {
     *     EMR emr;
     *     POINTL ptlCenter;
     *     DWORD nRadius;
     *     FLOAT eStartAngle;
     *     FLOAT eSweepAngle;
     * } *PEMRANGLEARC
     * }
     */
    public static final AddressLayout PEMRANGLEARC = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMRPOLYLINE {
     *     EMR emr;
     *     RECTL rclBounds;
     *     DWORD cptl;
     *     POINTL aptl[1];
     * } *PEMRPOLYLINE
     * }
     */
    public static final AddressLayout PEMRPOLYLINE = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMRPOLYLINE {
     *     EMR emr;
     *     RECTL rclBounds;
     *     DWORD cptl;
     *     POINTL aptl[1];
     * } *PEMRPOLYBEZIER
     * }
     */
    public static final AddressLayout PEMRPOLYBEZIER = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMRPOLYLINE {
     *     EMR emr;
     *     RECTL rclBounds;
     *     DWORD cptl;
     *     POINTL aptl[1];
     * } *PEMRPOLYGON
     * }
     */
    public static final AddressLayout PEMRPOLYGON = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMRPOLYLINE {
     *     EMR emr;
     *     RECTL rclBounds;
     *     DWORD cptl;
     *     POINTL aptl[1];
     * } *PEMRPOLYBEZIERTO
     * }
     */
    public static final AddressLayout PEMRPOLYBEZIERTO = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMRPOLYLINE {
     *     EMR emr;
     *     RECTL rclBounds;
     *     DWORD cptl;
     *     POINTL aptl[1];
     * } *PEMRPOLYLINETO
     * }
     */
    public static final AddressLayout PEMRPOLYLINETO = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMRPOLYLINE16 {
     *     EMR emr;
     *     RECTL rclBounds;
     *     DWORD cpts;
     *     POINTS apts[1];
     * } *PEMRPOLYLINE16
     * }
     */
    public static final AddressLayout PEMRPOLYLINE16 = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMRPOLYLINE16 {
     *     EMR emr;
     *     RECTL rclBounds;
     *     DWORD cpts;
     *     POINTS apts[1];
     * } *PEMRPOLYBEZIER16
     * }
     */
    public static final AddressLayout PEMRPOLYBEZIER16 = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMRPOLYLINE16 {
     *     EMR emr;
     *     RECTL rclBounds;
     *     DWORD cpts;
     *     POINTS apts[1];
     * } *PEMRPOLYGON16
     * }
     */
    public static final AddressLayout PEMRPOLYGON16 = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMRPOLYLINE16 {
     *     EMR emr;
     *     RECTL rclBounds;
     *     DWORD cpts;
     *     POINTS apts[1];
     * } *PEMRPOLYBEZIERTO16
     * }
     */
    public static final AddressLayout PEMRPOLYBEZIERTO16 = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMRPOLYLINE16 {
     *     EMR emr;
     *     RECTL rclBounds;
     *     DWORD cpts;
     *     POINTS apts[1];
     * } *PEMRPOLYLINETO16
     * }
     */
    public static final AddressLayout PEMRPOLYLINETO16 = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMRPOLYDRAW {
     *     EMR emr;
     *     RECTL rclBounds;
     *     DWORD cptl;
     *     POINTL aptl[1];
     *     BYTE abTypes[1];
     * } *PEMRPOLYDRAW
     * }
     */
    public static final AddressLayout PEMRPOLYDRAW = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMRPOLYDRAW16 {
     *     EMR emr;
     *     RECTL rclBounds;
     *     DWORD cpts;
     *     POINTS apts[1];
     *     BYTE abTypes[1];
     * } *PEMRPOLYDRAW16
     * }
     */
    public static final AddressLayout PEMRPOLYDRAW16 = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMRPOLYPOLYLINE {
     *     EMR emr;
     *     RECTL rclBounds;
     *     DWORD nPolys;
     *     DWORD cptl;
     *     DWORD aPolyCounts[1];
     *     POINTL aptl[1];
     * } *PEMRPOLYPOLYLINE
     * }
     */
    public static final AddressLayout PEMRPOLYPOLYLINE = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMRPOLYPOLYLINE {
     *     EMR emr;
     *     RECTL rclBounds;
     *     DWORD nPolys;
     *     DWORD cptl;
     *     DWORD aPolyCounts[1];
     *     POINTL aptl[1];
     * } *PEMRPOLYPOLYGON
     * }
     */
    public static final AddressLayout PEMRPOLYPOLYGON = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMRPOLYPOLYLINE16 {
     *     EMR emr;
     *     RECTL rclBounds;
     *     DWORD nPolys;
     *     DWORD cpts;
     *     DWORD aPolyCounts[1];
     *     POINTS apts[1];
     * } *PEMRPOLYPOLYLINE16
     * }
     */
    public static final AddressLayout PEMRPOLYPOLYLINE16 = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMRPOLYPOLYLINE16 {
     *     EMR emr;
     *     RECTL rclBounds;
     *     DWORD nPolys;
     *     DWORD cpts;
     *     DWORD aPolyCounts[1];
     *     POINTS apts[1];
     * } *PEMRPOLYPOLYGON16
     * }
     */
    public static final AddressLayout PEMRPOLYPOLYGON16 = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMRINVERTRGN {
     *     EMR emr;
     *     RECTL rclBounds;
     *     DWORD cbRgnData;
     *     BYTE RgnData[1];
     * } *PEMRINVERTRGN
     * }
     */
    public static final AddressLayout PEMRINVERTRGN = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMRINVERTRGN {
     *     EMR emr;
     *     RECTL rclBounds;
     *     DWORD cbRgnData;
     *     BYTE RgnData[1];
     * } *PEMRPAINTRGN
     * }
     */
    public static final AddressLayout PEMRPAINTRGN = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMRFILLRGN {
     *     EMR emr;
     *     RECTL rclBounds;
     *     DWORD cbRgnData;
     *     DWORD ihBrush;
     *     BYTE RgnData[1];
     * } *PEMRFILLRGN
     * }
     */
    public static final AddressLayout PEMRFILLRGN = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMRFRAMERGN {
     *     EMR emr;
     *     RECTL rclBounds;
     *     DWORD cbRgnData;
     *     DWORD ihBrush;
     *     SIZEL szlStroke;
     *     BYTE RgnData[1];
     * } *PEMRFRAMERGN
     * }
     */
    public static final AddressLayout PEMRFRAMERGN = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMREXTSELECTCLIPRGN {
     *     EMR emr;
     *     DWORD cbRgnData;
     *     DWORD iMode;
     *     BYTE RgnData[1];
     * } *PEMREXTSELECTCLIPRGN
     * }
     */
    public static final AddressLayout PEMREXTSELECTCLIPRGN = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMREXTTEXTOUTA {
     *     EMR emr;
     *     RECTL rclBounds;
     *     DWORD iGraphicsMode;
     *     FLOAT exScale;
     *     FLOAT eyScale;
     *     EMRTEXT emrtext;
     * } *PEMREXTTEXTOUTA
     * }
     */
    public static final AddressLayout PEMREXTTEXTOUTA = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMREXTTEXTOUTA {
     *     EMR emr;
     *     RECTL rclBounds;
     *     DWORD iGraphicsMode;
     *     FLOAT exScale;
     *     FLOAT eyScale;
     *     EMRTEXT emrtext;
     * } *PEMREXTTEXTOUTW
     * }
     */
    public static final AddressLayout PEMREXTTEXTOUTW = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMRPOLYTEXTOUTA {
     *     EMR emr;
     *     RECTL rclBounds;
     *     DWORD iGraphicsMode;
     *     FLOAT exScale;
     *     FLOAT eyScale;
     *     LONG cStrings;
     *     EMRTEXT aemrtext[1];
     * } *PEMRPOLYTEXTOUTA
     * }
     */
    public static final AddressLayout PEMRPOLYTEXTOUTA = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMRPOLYTEXTOUTA {
     *     EMR emr;
     *     RECTL rclBounds;
     *     DWORD iGraphicsMode;
     *     FLOAT exScale;
     *     FLOAT eyScale;
     *     LONG cStrings;
     *     EMRTEXT aemrtext[1];
     * } *PEMRPOLYTEXTOUTW
     * }
     */
    public static final AddressLayout PEMRPOLYTEXTOUTW = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMRBITBLT {
     *     EMR emr;
     *     RECTL rclBounds;
     *     LONG xDest;
     *     LONG yDest;
     *     LONG cxDest;
     *     LONG cyDest;
     *     DWORD dwRop;
     *     LONG xSrc;
     *     LONG ySrc;
     *     XFORM xformSrc;
     *     COLORREF crBkColorSrc;
     *     DWORD iUsageSrc;
     *     DWORD offBmiSrc;
     *     DWORD cbBmiSrc;
     *     DWORD offBitsSrc;
     *     DWORD cbBitsSrc;
     * } *PEMRBITBLT
     * }
     */
    public static final AddressLayout PEMRBITBLT = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMRSTRETCHBLT {
     *     EMR emr;
     *     RECTL rclBounds;
     *     LONG xDest;
     *     LONG yDest;
     *     LONG cxDest;
     *     LONG cyDest;
     *     DWORD dwRop;
     *     LONG xSrc;
     *     LONG ySrc;
     *     XFORM xformSrc;
     *     COLORREF crBkColorSrc;
     *     DWORD iUsageSrc;
     *     DWORD offBmiSrc;
     *     DWORD cbBmiSrc;
     *     DWORD offBitsSrc;
     *     DWORD cbBitsSrc;
     *     LONG cxSrc;
     *     LONG cySrc;
     * } *PEMRSTRETCHBLT
     * }
     */
    public static final AddressLayout PEMRSTRETCHBLT = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMRMASKBLT {
     *     EMR emr;
     *     RECTL rclBounds;
     *     LONG xDest;
     *     LONG yDest;
     *     LONG cxDest;
     *     LONG cyDest;
     *     DWORD dwRop;
     *     LONG xSrc;
     *     LONG ySrc;
     *     XFORM xformSrc;
     *     COLORREF crBkColorSrc;
     *     DWORD iUsageSrc;
     *     DWORD offBmiSrc;
     *     DWORD cbBmiSrc;
     *     DWORD offBitsSrc;
     *     DWORD cbBitsSrc;
     *     LONG xMask;
     *     LONG yMask;
     *     DWORD iUsageMask;
     *     DWORD offBmiMask;
     *     DWORD cbBmiMask;
     *     DWORD offBitsMask;
     *     DWORD cbBitsMask;
     * } *PEMRMASKBLT
     * }
     */
    public static final AddressLayout PEMRMASKBLT = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMRPLGBLT {
     *     EMR emr;
     *     RECTL rclBounds;
     *     POINTL aptlDest[3];
     *     LONG xSrc;
     *     LONG ySrc;
     *     LONG cxSrc;
     *     LONG cySrc;
     *     XFORM xformSrc;
     *     COLORREF crBkColorSrc;
     *     DWORD iUsageSrc;
     *     DWORD offBmiSrc;
     *     DWORD cbBmiSrc;
     *     DWORD offBitsSrc;
     *     DWORD cbBitsSrc;
     *     LONG xMask;
     *     LONG yMask;
     *     DWORD iUsageMask;
     *     DWORD offBmiMask;
     *     DWORD cbBmiMask;
     *     DWORD offBitsMask;
     *     DWORD cbBitsMask;
     * } *PEMRPLGBLT
     * }
     */
    public static final AddressLayout PEMRPLGBLT = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMRSETDIBITSTODEVICE {
     *     EMR emr;
     *     RECTL rclBounds;
     *     LONG xDest;
     *     LONG yDest;
     *     LONG xSrc;
     *     LONG ySrc;
     *     LONG cxSrc;
     *     LONG cySrc;
     *     DWORD offBmiSrc;
     *     DWORD cbBmiSrc;
     *     DWORD offBitsSrc;
     *     DWORD cbBitsSrc;
     *     DWORD iUsageSrc;
     *     DWORD iStartScan;
     *     DWORD cScans;
     * } *PEMRSETDIBITSTODEVICE
     * }
     */
    public static final AddressLayout PEMRSETDIBITSTODEVICE = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMRSTRETCHDIBITS {
     *     EMR emr;
     *     RECTL rclBounds;
     *     LONG xDest;
     *     LONG yDest;
     *     LONG xSrc;
     *     LONG ySrc;
     *     LONG cxSrc;
     *     LONG cySrc;
     *     DWORD offBmiSrc;
     *     DWORD cbBmiSrc;
     *     DWORD offBitsSrc;
     *     DWORD cbBitsSrc;
     *     DWORD iUsageSrc;
     *     DWORD dwRop;
     *     LONG cxDest;
     *     LONG cyDest;
     * } *PEMRSTRETCHDIBITS
     * }
     */
    public static final AddressLayout PEMRSTRETCHDIBITS = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMREXTCREATEFONTINDIRECTW {
     *     EMR emr;
     *     DWORD ihFont;
     *     EXTLOGFONTW elfw;
     * } *PEMREXTCREATEFONTINDIRECTW
     * }
     */
    public static final AddressLayout PEMREXTCREATEFONTINDIRECTW = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMRCREATEPALETTE {
     *     EMR emr;
     *     DWORD ihPal;
     *     LOGPALETTE lgpl;
     * } *PEMRCREATEPALETTE
     * }
     */
    public static final AddressLayout PEMRCREATEPALETTE = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMRCREATEPEN {
     *     EMR emr;
     *     DWORD ihPen;
     *     LOGPEN lopn;
     * } *PEMRCREATEPEN
     * }
     */
    public static final AddressLayout PEMRCREATEPEN = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMREXTCREATEPEN {
     *     EMR emr;
     *     DWORD ihPen;
     *     DWORD offBmi;
     *     DWORD cbBmi;
     *     DWORD offBits;
     *     DWORD cbBits;
     *     EXTLOGPEN32 elp;
     * } *PEMREXTCREATEPEN
     * }
     */
    public static final AddressLayout PEMREXTCREATEPEN = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMRCREATEBRUSHINDIRECT {
     *     EMR emr;
     *     DWORD ihBrush;
     *     LOGBRUSH32 lb;
     * } *PEMRCREATEBRUSHINDIRECT
     * }
     */
    public static final AddressLayout PEMRCREATEBRUSHINDIRECT = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMRCREATEMONOBRUSH {
     *     EMR emr;
     *     DWORD ihBrush;
     *     DWORD iUsage;
     *     DWORD offBmi;
     *     DWORD cbBmi;
     *     DWORD offBits;
     *     DWORD cbBits;
     * } *PEMRCREATEMONOBRUSH
     * }
     */
    public static final AddressLayout PEMRCREATEMONOBRUSH = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMRCREATEDIBPATTERNBRUSHPT {
     *     EMR emr;
     *     DWORD ihBrush;
     *     DWORD iUsage;
     *     DWORD offBmi;
     *     DWORD cbBmi;
     *     DWORD offBits;
     *     DWORD cbBits;
     * } *PEMRCREATEDIBPATTERNBRUSHPT
     * }
     */
    public static final AddressLayout PEMRCREATEDIBPATTERNBRUSHPT = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMRFORMAT {
     *     DWORD dSignature;
     *     DWORD nVersion;
     *     DWORD cbData;
     *     DWORD offData;
     * } *PEMRFORMAT
     * }
     */
    public static final AddressLayout PEMRFORMAT = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMRGLSRECORD {
     *     EMR emr;
     *     DWORD cbData;
     *     BYTE Data[1];
     * } *PEMRGLSRECORD
     * }
     */
    public static final AddressLayout PEMRGLSRECORD = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMRGLSBOUNDEDRECORD {
     *     EMR emr;
     *     RECTL rclBounds;
     *     DWORD cbData;
     *     BYTE Data[1];
     * } *PEMRGLSBOUNDEDRECORD
     * }
     */
    public static final AddressLayout PEMRGLSBOUNDEDRECORD = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMRPIXELFORMAT {
     *     EMR emr;
     *     PIXELFORMATDESCRIPTOR pfd;
     * } *PEMRPIXELFORMAT
     * }
     */
    public static final AddressLayout PEMRPIXELFORMAT = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMRCREATECOLORSPACE {
     *     EMR emr;
     *     DWORD ihCS;
     *     LOGCOLORSPACEA lcs;
     * } *PEMRCREATECOLORSPACE
     * }
     */
    public static final AddressLayout PEMRCREATECOLORSPACE = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMRSETCOLORSPACE {
     *     EMR emr;
     *     DWORD ihCS;
     * } *PEMRSETCOLORSPACE
     * }
     */
    public static final AddressLayout PEMRSETCOLORSPACE = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMRSETCOLORSPACE {
     *     EMR emr;
     *     DWORD ihCS;
     * } *PEMRSELECTCOLORSPACE
     * }
     */
    public static final AddressLayout PEMRSELECTCOLORSPACE = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMRSETCOLORSPACE {
     *     EMR emr;
     *     DWORD ihCS;
     * } *PEMRDELETECOLORSPACE
     * }
     */
    public static final AddressLayout PEMRDELETECOLORSPACE = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMREXTESCAPE {
     *     EMR emr;
     *     INT iEscape;
     *     INT cbEscData;
     *     BYTE EscData[1];
     * } *PEMREXTESCAPE
     * }
     */
    public static final AddressLayout PEMREXTESCAPE = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMREXTESCAPE {
     *     EMR emr;
     *     INT iEscape;
     *     INT cbEscData;
     *     BYTE EscData[1];
     * } *PEMRDRAWESCAPE
     * }
     */
    public static final AddressLayout PEMRDRAWESCAPE = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMRNAMEDESCAPE {
     *     EMR emr;
     *     INT iEscape;
     *     INT cbDriver;
     *     INT cbEscData;
     *     BYTE EscData[1];
     * } *PEMRNAMEDESCAPE
     * }
     */
    public static final AddressLayout PEMRNAMEDESCAPE = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMRSETICMPROFILE {
     *     EMR emr;
     *     DWORD dwFlags;
     *     DWORD cbName;
     *     DWORD cbData;
     *     BYTE Data[1];
     * } *PEMRSETICMPROFILE
     * }
     */
    public static final AddressLayout PEMRSETICMPROFILE = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMRSETICMPROFILE {
     *     EMR emr;
     *     DWORD dwFlags;
     *     DWORD cbName;
     *     DWORD cbData;
     *     BYTE Data[1];
     * } *PEMRSETICMPROFILEA
     * }
     */
    public static final AddressLayout PEMRSETICMPROFILEA = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMRSETICMPROFILE {
     *     EMR emr;
     *     DWORD dwFlags;
     *     DWORD cbName;
     *     DWORD cbData;
     *     BYTE Data[1];
     * } *PEMRSETICMPROFILEW
     * }
     */
    public static final AddressLayout PEMRSETICMPROFILEW = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMRCREATECOLORSPACEW {
     *     EMR emr;
     *     DWORD ihCS;
     *     LOGCOLORSPACEW lcs;
     *     DWORD dwFlags;
     *     DWORD cbData;
     *     BYTE Data[1];
     * } *PEMRCREATECOLORSPACEW
     * }
     */
    public static final AddressLayout PEMRCREATECOLORSPACEW = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagCOLORMATCHTOTARGET {
     *     EMR emr;
     *     DWORD dwAction;
     *     DWORD dwFlags;
     *     DWORD cbName;
     *     DWORD cbData;
     *     BYTE Data[1];
     * } *PEMRCOLORMATCHTOTARGET
     * }
     */
    public static final AddressLayout PEMRCOLORMATCHTOTARGET = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagCOLORCORRECTPALETTE {
     *     EMR emr;
     *     DWORD ihPalette;
     *     DWORD nFirstEntry;
     *     DWORD nPalEntries;
     *     DWORD nReserved;
     * } *PEMRCOLORCORRECTPALETTE
     * }
     */
    public static final AddressLayout PEMRCOLORCORRECTPALETTE = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMRALPHABLEND {
     *     EMR emr;
     *     RECTL rclBounds;
     *     LONG xDest;
     *     LONG yDest;
     *     LONG cxDest;
     *     LONG cyDest;
     *     DWORD dwRop;
     *     LONG xSrc;
     *     LONG ySrc;
     *     XFORM xformSrc;
     *     COLORREF crBkColorSrc;
     *     DWORD iUsageSrc;
     *     DWORD offBmiSrc;
     *     DWORD cbBmiSrc;
     *     DWORD offBitsSrc;
     *     DWORD cbBitsSrc;
     *     LONG cxSrc;
     *     LONG cySrc;
     * } *PEMRALPHABLEND
     * }
     */
    public static final AddressLayout PEMRALPHABLEND = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMRGRADIENTFILL {
     *     EMR emr;
     *     RECTL rclBounds;
     *     DWORD nVer;
     *     DWORD nTri;
     *     ULONG ulMode;
     *     TRIVERTEX Ver[1];
     * } *PEMRGRADIENTFILL
     * }
     */
    public static final AddressLayout PEMRGRADIENTFILL = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEMRTRANSPARENTBLT {
     *     EMR emr;
     *     RECTL rclBounds;
     *     LONG xDest;
     *     LONG yDest;
     *     LONG cxDest;
     *     LONG cyDest;
     *     DWORD dwRop;
     *     LONG xSrc;
     *     LONG ySrc;
     *     XFORM xformSrc;
     *     COLORREF crBkColorSrc;
     *     DWORD iUsageSrc;
     *     DWORD offBmiSrc;
     *     DWORD cbBmiSrc;
     *     DWORD offBitsSrc;
     *     DWORD cbBitsSrc;
     *     LONG cxSrc;
     *     LONG cySrc;
     * } *PEMRTRANSPARENTBLT
     * }
     */
    public static final AddressLayout PEMRTRANSPARENTBLT = C_POINTER;

    private static class wglCopyContext {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("wglCopyContext"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL wglCopyContext(HGLRC, HGLRC, UINT)
     * }
     */
    public static FunctionDescriptor wglCopyContext$descriptor() {
        return wglCopyContext.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL wglCopyContext(HGLRC, HGLRC, UINT)
     * }
     */
    public static MethodHandle wglCopyContext$handle() {
        return wglCopyContext.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL wglCopyContext(HGLRC, HGLRC, UINT)
     * }
     */
    public static int wglCopyContext(MemorySegment x0, MemorySegment x1, int x2) {
        var mh$ = wglCopyContext.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wglCopyContext", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wglCreateContext {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("wglCreateContext"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HGLRC wglCreateContext(HDC)
     * }
     */
    public static FunctionDescriptor wglCreateContext$descriptor() {
        return wglCreateContext.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HGLRC wglCreateContext(HDC)
     * }
     */
    public static MethodHandle wglCreateContext$handle() {
        return wglCreateContext.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * HGLRC wglCreateContext(HDC)
     * }
     */
    public static MemorySegment wglCreateContext(MemorySegment x0) {
        var mh$ = wglCreateContext.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wglCreateContext", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wglCreateLayerContext {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("wglCreateLayerContext"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HGLRC wglCreateLayerContext(HDC, int)
     * }
     */
    public static FunctionDescriptor wglCreateLayerContext$descriptor() {
        return wglCreateLayerContext.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HGLRC wglCreateLayerContext(HDC, int)
     * }
     */
    public static MethodHandle wglCreateLayerContext$handle() {
        return wglCreateLayerContext.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * HGLRC wglCreateLayerContext(HDC, int)
     * }
     */
    public static MemorySegment wglCreateLayerContext(MemorySegment x0, int x1) {
        var mh$ = wglCreateLayerContext.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wglCreateLayerContext", x0, x1);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wglDeleteContext {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("wglDeleteContext"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL wglDeleteContext(HGLRC)
     * }
     */
    public static FunctionDescriptor wglDeleteContext$descriptor() {
        return wglDeleteContext.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL wglDeleteContext(HGLRC)
     * }
     */
    public static MethodHandle wglDeleteContext$handle() {
        return wglDeleteContext.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL wglDeleteContext(HGLRC)
     * }
     */
    public static int wglDeleteContext(MemorySegment x0) {
        var mh$ = wglDeleteContext.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wglDeleteContext", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wglGetCurrentContext {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER    );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("wglGetCurrentContext"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HGLRC wglGetCurrentContext()
     * }
     */
    public static FunctionDescriptor wglGetCurrentContext$descriptor() {
        return wglGetCurrentContext.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HGLRC wglGetCurrentContext()
     * }
     */
    public static MethodHandle wglGetCurrentContext$handle() {
        return wglGetCurrentContext.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * HGLRC wglGetCurrentContext()
     * }
     */
    public static MemorySegment wglGetCurrentContext() {
        var mh$ = wglGetCurrentContext.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wglGetCurrentContext");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wglGetCurrentDC {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER    );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("wglGetCurrentDC"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HDC wglGetCurrentDC()
     * }
     */
    public static FunctionDescriptor wglGetCurrentDC$descriptor() {
        return wglGetCurrentDC.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HDC wglGetCurrentDC()
     * }
     */
    public static MethodHandle wglGetCurrentDC$handle() {
        return wglGetCurrentDC.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * HDC wglGetCurrentDC()
     * }
     */
    public static MemorySegment wglGetCurrentDC() {
        var mh$ = wglGetCurrentDC.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wglGetCurrentDC");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wglGetProcAddress {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("wglGetProcAddress"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PROC wglGetProcAddress(LPCSTR)
     * }
     */
    public static FunctionDescriptor wglGetProcAddress$descriptor() {
        return wglGetProcAddress.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PROC wglGetProcAddress(LPCSTR)
     * }
     */
    public static MethodHandle wglGetProcAddress$handle() {
        return wglGetProcAddress.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * PROC wglGetProcAddress(LPCSTR)
     * }
     */
    public static MemorySegment wglGetProcAddress(MemorySegment x0) {
        var mh$ = wglGetProcAddress.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wglGetProcAddress", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wglMakeCurrent {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("wglMakeCurrent"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL wglMakeCurrent(HDC, HGLRC)
     * }
     */
    public static FunctionDescriptor wglMakeCurrent$descriptor() {
        return wglMakeCurrent.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL wglMakeCurrent(HDC, HGLRC)
     * }
     */
    public static MethodHandle wglMakeCurrent$handle() {
        return wglMakeCurrent.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL wglMakeCurrent(HDC, HGLRC)
     * }
     */
    public static int wglMakeCurrent(MemorySegment x0, MemorySegment x1) {
        var mh$ = wglMakeCurrent.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wglMakeCurrent", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wglShareLists {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("wglShareLists"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL wglShareLists(HGLRC, HGLRC)
     * }
     */
    public static FunctionDescriptor wglShareLists$descriptor() {
        return wglShareLists.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL wglShareLists(HGLRC, HGLRC)
     * }
     */
    public static MethodHandle wglShareLists$handle() {
        return wglShareLists.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL wglShareLists(HGLRC, HGLRC)
     * }
     */
    public static int wglShareLists(MemorySegment x0, MemorySegment x1) {
        var mh$ = wglShareLists.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wglShareLists", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wglUseFontBitmapsA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_LONG,
            C_LONG,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("wglUseFontBitmapsA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL wglUseFontBitmapsA(HDC, DWORD, DWORD, DWORD)
     * }
     */
    public static FunctionDescriptor wglUseFontBitmapsA$descriptor() {
        return wglUseFontBitmapsA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL wglUseFontBitmapsA(HDC, DWORD, DWORD, DWORD)
     * }
     */
    public static MethodHandle wglUseFontBitmapsA$handle() {
        return wglUseFontBitmapsA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL wglUseFontBitmapsA(HDC, DWORD, DWORD, DWORD)
     * }
     */
    public static int wglUseFontBitmapsA(MemorySegment x0, int x1, int x2, int x3) {
        var mh$ = wglUseFontBitmapsA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wglUseFontBitmapsA", x0, x1, x2, x3);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wglUseFontBitmapsW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_LONG,
            C_LONG,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("wglUseFontBitmapsW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL wglUseFontBitmapsW(HDC, DWORD, DWORD, DWORD)
     * }
     */
    public static FunctionDescriptor wglUseFontBitmapsW$descriptor() {
        return wglUseFontBitmapsW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL wglUseFontBitmapsW(HDC, DWORD, DWORD, DWORD)
     * }
     */
    public static MethodHandle wglUseFontBitmapsW$handle() {
        return wglUseFontBitmapsW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL wglUseFontBitmapsW(HDC, DWORD, DWORD, DWORD)
     * }
     */
    public static int wglUseFontBitmapsW(MemorySegment x0, int x1, int x2, int x3) {
        var mh$ = wglUseFontBitmapsW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wglUseFontBitmapsW", x0, x1, x2, x3);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SwapBuffers {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("SwapBuffers"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SwapBuffers(HDC)
     * }
     */
    public static FunctionDescriptor SwapBuffers$descriptor() {
        return SwapBuffers.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SwapBuffers(HDC)
     * }
     */
    public static MethodHandle SwapBuffers$handle() {
        return SwapBuffers.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL SwapBuffers(HDC)
     * }
     */
    public static int SwapBuffers(MemorySegment x0) {
        var mh$ = SwapBuffers.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SwapBuffers", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct _POINTFLOAT {
     *     FLOAT x;
     *     FLOAT y;
     * } *PPOINTFLOAT
     * }
     */
    public static final AddressLayout PPOINTFLOAT = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _GLYPHMETRICSFLOAT {
     *     FLOAT gmfBlackBoxX;
     *     FLOAT gmfBlackBoxY;
     *     POINTFLOAT gmfptGlyphOrigin;
     *     FLOAT gmfCellIncX;
     *     FLOAT gmfCellIncY;
     * } *PGLYPHMETRICSFLOAT
     * }
     */
    public static final AddressLayout PGLYPHMETRICSFLOAT = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _GLYPHMETRICSFLOAT {
     *     FLOAT gmfBlackBoxX;
     *     FLOAT gmfBlackBoxY;
     *     POINTFLOAT gmfptGlyphOrigin;
     *     FLOAT gmfCellIncX;
     *     FLOAT gmfCellIncY;
     * } *LPGLYPHMETRICSFLOAT
     * }
     */
    public static final AddressLayout LPGLYPHMETRICSFLOAT = C_POINTER;

    private static class wglUseFontOutlinesA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_LONG,
            C_LONG,
            C_LONG,
            C_FLOAT,
            C_FLOAT,
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("wglUseFontOutlinesA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL wglUseFontOutlinesA(HDC, DWORD, DWORD, DWORD, FLOAT, FLOAT, int, LPGLYPHMETRICSFLOAT)
     * }
     */
    public static FunctionDescriptor wglUseFontOutlinesA$descriptor() {
        return wglUseFontOutlinesA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL wglUseFontOutlinesA(HDC, DWORD, DWORD, DWORD, FLOAT, FLOAT, int, LPGLYPHMETRICSFLOAT)
     * }
     */
    public static MethodHandle wglUseFontOutlinesA$handle() {
        return wglUseFontOutlinesA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL wglUseFontOutlinesA(HDC, DWORD, DWORD, DWORD, FLOAT, FLOAT, int, LPGLYPHMETRICSFLOAT)
     * }
     */
    public static int wglUseFontOutlinesA(MemorySegment x0, int x1, int x2, int x3, float x4, float x5, int x6, MemorySegment x7) {
        var mh$ = wglUseFontOutlinesA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wglUseFontOutlinesA", x0, x1, x2, x3, x4, x5, x6, x7);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4, x5, x6, x7);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wglUseFontOutlinesW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_LONG,
            C_LONG,
            C_LONG,
            C_FLOAT,
            C_FLOAT,
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("wglUseFontOutlinesW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL wglUseFontOutlinesW(HDC, DWORD, DWORD, DWORD, FLOAT, FLOAT, int, LPGLYPHMETRICSFLOAT)
     * }
     */
    public static FunctionDescriptor wglUseFontOutlinesW$descriptor() {
        return wglUseFontOutlinesW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL wglUseFontOutlinesW(HDC, DWORD, DWORD, DWORD, FLOAT, FLOAT, int, LPGLYPHMETRICSFLOAT)
     * }
     */
    public static MethodHandle wglUseFontOutlinesW$handle() {
        return wglUseFontOutlinesW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL wglUseFontOutlinesW(HDC, DWORD, DWORD, DWORD, FLOAT, FLOAT, int, LPGLYPHMETRICSFLOAT)
     * }
     */
    public static int wglUseFontOutlinesW(MemorySegment x0, int x1, int x2, int x3, float x4, float x5, int x6, MemorySegment x7) {
        var mh$ = wglUseFontOutlinesW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wglUseFontOutlinesW", x0, x1, x2, x3, x4, x5, x6, x7);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4, x5, x6, x7);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct tagLAYERPLANEDESCRIPTOR {
     *     WORD nSize;
     *     WORD nVersion;
     *     DWORD dwFlags;
     *     BYTE iPixelType;
     *     BYTE cColorBits;
     *     BYTE cRedBits;
     *     BYTE cRedShift;
     *     BYTE cGreenBits;
     *     BYTE cGreenShift;
     *     BYTE cBlueBits;
     *     BYTE cBlueShift;
     *     BYTE cAlphaBits;
     *     BYTE cAlphaShift;
     *     BYTE cAccumBits;
     *     BYTE cAccumRedBits;
     *     BYTE cAccumGreenBits;
     *     BYTE cAccumBlueBits;
     *     BYTE cAccumAlphaBits;
     *     BYTE cDepthBits;
     *     BYTE cStencilBits;
     *     BYTE cAuxBuffers;
     *     BYTE iLayerPlane;
     *     BYTE bReserved;
     *     COLORREF crTransparent;
     * } *PLAYERPLANEDESCRIPTOR
     * }
     */
    public static final AddressLayout PLAYERPLANEDESCRIPTOR = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagLAYERPLANEDESCRIPTOR {
     *     WORD nSize;
     *     WORD nVersion;
     *     DWORD dwFlags;
     *     BYTE iPixelType;
     *     BYTE cColorBits;
     *     BYTE cRedBits;
     *     BYTE cRedShift;
     *     BYTE cGreenBits;
     *     BYTE cGreenShift;
     *     BYTE cBlueBits;
     *     BYTE cBlueShift;
     *     BYTE cAlphaBits;
     *     BYTE cAlphaShift;
     *     BYTE cAccumBits;
     *     BYTE cAccumRedBits;
     *     BYTE cAccumGreenBits;
     *     BYTE cAccumBlueBits;
     *     BYTE cAccumAlphaBits;
     *     BYTE cDepthBits;
     *     BYTE cStencilBits;
     *     BYTE cAuxBuffers;
     *     BYTE iLayerPlane;
     *     BYTE bReserved;
     *     COLORREF crTransparent;
     * } *LPLAYERPLANEDESCRIPTOR
     * }
     */
    public static final AddressLayout LPLAYERPLANEDESCRIPTOR = C_POINTER;

    private static class wglDescribeLayerPlane {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_INT,
            C_INT,
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("wglDescribeLayerPlane"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL wglDescribeLayerPlane(HDC, int, int, UINT, LPLAYERPLANEDESCRIPTOR)
     * }
     */
    public static FunctionDescriptor wglDescribeLayerPlane$descriptor() {
        return wglDescribeLayerPlane.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL wglDescribeLayerPlane(HDC, int, int, UINT, LPLAYERPLANEDESCRIPTOR)
     * }
     */
    public static MethodHandle wglDescribeLayerPlane$handle() {
        return wglDescribeLayerPlane.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL wglDescribeLayerPlane(HDC, int, int, UINT, LPLAYERPLANEDESCRIPTOR)
     * }
     */
    public static int wglDescribeLayerPlane(MemorySegment x0, int x1, int x2, int x3, MemorySegment x4) {
        var mh$ = wglDescribeLayerPlane.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wglDescribeLayerPlane", x0, x1, x2, x3, x4);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wglSetLayerPaletteEntries {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_INT,
            C_INT,
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("wglSetLayerPaletteEntries"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int wglSetLayerPaletteEntries(HDC, int, int, int, const COLORREF *)
     * }
     */
    public static FunctionDescriptor wglSetLayerPaletteEntries$descriptor() {
        return wglSetLayerPaletteEntries.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int wglSetLayerPaletteEntries(HDC, int, int, int, const COLORREF *)
     * }
     */
    public static MethodHandle wglSetLayerPaletteEntries$handle() {
        return wglSetLayerPaletteEntries.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int wglSetLayerPaletteEntries(HDC, int, int, int, const COLORREF *)
     * }
     */
    public static int wglSetLayerPaletteEntries(MemorySegment x0, int x1, int x2, int x3, MemorySegment x4) {
        var mh$ = wglSetLayerPaletteEntries.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wglSetLayerPaletteEntries", x0, x1, x2, x3, x4);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wglGetLayerPaletteEntries {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_INT,
            C_INT,
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("wglGetLayerPaletteEntries"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int wglGetLayerPaletteEntries(HDC, int, int, int, COLORREF *)
     * }
     */
    public static FunctionDescriptor wglGetLayerPaletteEntries$descriptor() {
        return wglGetLayerPaletteEntries.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int wglGetLayerPaletteEntries(HDC, int, int, int, COLORREF *)
     * }
     */
    public static MethodHandle wglGetLayerPaletteEntries$handle() {
        return wglGetLayerPaletteEntries.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int wglGetLayerPaletteEntries(HDC, int, int, int, COLORREF *)
     * }
     */
    public static int wglGetLayerPaletteEntries(MemorySegment x0, int x1, int x2, int x3, MemorySegment x4) {
        var mh$ = wglGetLayerPaletteEntries.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wglGetLayerPaletteEntries", x0, x1, x2, x3, x4);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wglRealizeLayerPalette {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_INT,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("wglRealizeLayerPalette"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL wglRealizeLayerPalette(HDC, int, BOOL)
     * }
     */
    public static FunctionDescriptor wglRealizeLayerPalette$descriptor() {
        return wglRealizeLayerPalette.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL wglRealizeLayerPalette(HDC, int, BOOL)
     * }
     */
    public static MethodHandle wglRealizeLayerPalette$handle() {
        return wglRealizeLayerPalette.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL wglRealizeLayerPalette(HDC, int, BOOL)
     * }
     */
    public static int wglRealizeLayerPalette(MemorySegment x0, int x1, int x2) {
        var mh$ = wglRealizeLayerPalette.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wglRealizeLayerPalette", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wglSwapLayerBuffers {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("wglSwapLayerBuffers"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL wglSwapLayerBuffers(HDC, UINT)
     * }
     */
    public static FunctionDescriptor wglSwapLayerBuffers$descriptor() {
        return wglSwapLayerBuffers.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL wglSwapLayerBuffers(HDC, UINT)
     * }
     */
    public static MethodHandle wglSwapLayerBuffers$handle() {
        return wglSwapLayerBuffers.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL wglSwapLayerBuffers(HDC, UINT)
     * }
     */
    public static int wglSwapLayerBuffers(MemorySegment x0, int x1) {
        var mh$ = wglSwapLayerBuffers.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wglSwapLayerBuffers", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct _WGLSWAP {
     *     HDC hdc;
     *     UINT uiFlags;
     * } *PWGLSWAP
     * }
     */
    public static final AddressLayout PWGLSWAP = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _WGLSWAP {
     *     HDC hdc;
     *     UINT uiFlags;
     * } *LPWGLSWAP
     * }
     */
    public static final AddressLayout LPWGLSWAP = C_POINTER;

    private static class wglSwapMultipleBuffers {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("wglSwapMultipleBuffers"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD wglSwapMultipleBuffers(UINT, const WGLSWAP *)
     * }
     */
    public static FunctionDescriptor wglSwapMultipleBuffers$descriptor() {
        return wglSwapMultipleBuffers.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD wglSwapMultipleBuffers(UINT, const WGLSWAP *)
     * }
     */
    public static MethodHandle wglSwapMultipleBuffers$handle() {
        return wglSwapMultipleBuffers.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * DWORD wglSwapMultipleBuffers(UINT, const WGLSWAP *)
     * }
     */
    public static int wglSwapMultipleBuffers(int x0, MemorySegment x1) {
        var mh$ = wglSwapMultipleBuffers.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wglSwapMultipleBuffers", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef HANDLE HDWP
     * }
     */
    public static final AddressLayout HDWP = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef PVOID LPMENUTEMPLATEA
     * }
     */
    public static final AddressLayout LPMENUTEMPLATEA = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef PVOID LPMENUTEMPLATEW
     * }
     */
    public static final AddressLayout LPMENUTEMPLATEW = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef LPMENUTEMPLATEA LPMENUTEMPLATE
     * }
     */
    public static final AddressLayout LPMENUTEMPLATE = C_POINTER;

    private static class wvsprintfA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("wvsprintfA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int wvsprintfA(LPSTR, LPCSTR, va_list arglist)
     * }
     */
    public static FunctionDescriptor wvsprintfA$descriptor() {
        return wvsprintfA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int wvsprintfA(LPSTR, LPCSTR, va_list arglist)
     * }
     */
    public static MethodHandle wvsprintfA$handle() {
        return wvsprintfA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int wvsprintfA(LPSTR, LPCSTR, va_list arglist)
     * }
     */
    public static int wvsprintfA(MemorySegment x0, MemorySegment x1, MemorySegment arglist) {
        var mh$ = wvsprintfA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wvsprintfA", x0, x1, arglist);
            }
            return (int)mh$.invokeExact(x0, x1, arglist);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wvsprintfW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("wvsprintfW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int wvsprintfW(LPWSTR, LPCWSTR, va_list arglist)
     * }
     */
    public static FunctionDescriptor wvsprintfW$descriptor() {
        return wvsprintfW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int wvsprintfW(LPWSTR, LPCWSTR, va_list arglist)
     * }
     */
    public static MethodHandle wvsprintfW$handle() {
        return wvsprintfW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int wvsprintfW(LPWSTR, LPCWSTR, va_list arglist)
     * }
     */
    public static int wvsprintfW(MemorySegment x0, MemorySegment x1, MemorySegment arglist) {
        var mh$ = wvsprintfW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wvsprintfW", x0, x1, arglist);
            }
            return (int)mh$.invokeExact(x0, x1, arglist);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * int wsprintfA(LPSTR, LPCSTR, ...)
     * }
     */
    public static class wsprintfA {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                C_INT,
                C_POINTER,
                C_POINTER
            );
        private static final MemorySegment ADDR = findOrThrow("wsprintfA");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private wsprintfA(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * int wsprintfA(LPSTR, LPCSTR, ...)
         * }
         */
        public static wsprintfA makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new wsprintfA(mh$, desc$, spreader$);
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public int apply(MemorySegment x0, MemorySegment x1, Object... x2) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("wsprintfA", x0, x1, x2);
                }
                return (int)spreader.invokeExact(x0, x1, x2);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * int wsprintfW(LPWSTR, LPCWSTR, ...)
     * }
     */
    public static class wsprintfW {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                C_INT,
                C_POINTER,
                C_POINTER
            );
        private static final MemorySegment ADDR = findOrThrow("wsprintfW");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private wsprintfW(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * int wsprintfW(LPWSTR, LPCWSTR, ...)
         * }
         */
        public static wsprintfW makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new wsprintfW(mh$, desc$, spreader$);
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public int apply(MemorySegment x0, MemorySegment x1, Object... x2) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("wsprintfW", x0, x1, x2);
                }
                return (int)spreader.invokeExact(x0, x1, x2);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct tagCBT_CREATEWNDA {
     *     struct tagCREATESTRUCTA *lpcs;
     *     HWND hwndInsertAfter;
     * } *LPCBT_CREATEWNDA
     * }
     */
    public static final AddressLayout LPCBT_CREATEWNDA = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagCBT_CREATEWNDW {
     *     struct tagCREATESTRUCTW *lpcs;
     *     HWND hwndInsertAfter;
     * } *LPCBT_CREATEWNDW
     * }
     */
    public static final AddressLayout LPCBT_CREATEWNDW = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef LPCBT_CREATEWNDA LPCBT_CREATEWND
     * }
     */
    public static final AddressLayout LPCBT_CREATEWND = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagCBTACTIVATESTRUCT {
     *     BOOL fMouse;
     *     HWND hWndActive;
     * } *LPCBTACTIVATESTRUCT
     * }
     */
    public static final AddressLayout LPCBTACTIVATESTRUCT = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagWTSSESSION_NOTIFICATION {
     *     DWORD cbSize;
     *     DWORD dwSessionId;
     * } *PWTSSESSION_NOTIFICATION
     * }
     */
    public static final AddressLayout PWTSSESSION_NOTIFICATION = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct {
     *     HWND hwnd;
     *     RECT rc;
     * } *LPSHELLHOOKINFO
     * }
     */
    public static final AddressLayout LPSHELLHOOKINFO = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEVENTMSG {
     *     UINT message;
     *     UINT paramL;
     *     UINT paramH;
     *     DWORD time;
     *     HWND hwnd;
     * } *PEVENTMSGMSG
     * }
     */
    public static final AddressLayout PEVENTMSGMSG = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEVENTMSG {
     *     UINT message;
     *     UINT paramL;
     *     UINT paramH;
     *     DWORD time;
     *     HWND hwnd;
     * } *NPEVENTMSGMSG
     * }
     */
    public static final AddressLayout NPEVENTMSGMSG = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEVENTMSG {
     *     UINT message;
     *     UINT paramL;
     *     UINT paramH;
     *     DWORD time;
     *     HWND hwnd;
     * } *LPEVENTMSGMSG
     * }
     */
    public static final AddressLayout LPEVENTMSGMSG = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEVENTMSG {
     *     UINT message;
     *     UINT paramL;
     *     UINT paramH;
     *     DWORD time;
     *     HWND hwnd;
     * } *PEVENTMSG
     * }
     */
    public static final AddressLayout PEVENTMSG = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEVENTMSG {
     *     UINT message;
     *     UINT paramL;
     *     UINT paramH;
     *     DWORD time;
     *     HWND hwnd;
     * } *NPEVENTMSG
     * }
     */
    public static final AddressLayout NPEVENTMSG = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagEVENTMSG {
     *     UINT message;
     *     UINT paramL;
     *     UINT paramH;
     *     DWORD time;
     *     HWND hwnd;
     * } *LPEVENTMSG
     * }
     */
    public static final AddressLayout LPEVENTMSG = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagCWPSTRUCT {
     *     LPARAM lParam;
     *     WPARAM wParam;
     *     UINT message;
     *     HWND hwnd;
     * } *PCWPSTRUCT
     * }
     */
    public static final AddressLayout PCWPSTRUCT = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagCWPSTRUCT {
     *     LPARAM lParam;
     *     WPARAM wParam;
     *     UINT message;
     *     HWND hwnd;
     * } *NPCWPSTRUCT
     * }
     */
    public static final AddressLayout NPCWPSTRUCT = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagCWPSTRUCT {
     *     LPARAM lParam;
     *     WPARAM wParam;
     *     UINT message;
     *     HWND hwnd;
     * } *LPCWPSTRUCT
     * }
     */
    public static final AddressLayout LPCWPSTRUCT = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagCWPRETSTRUCT {
     *     LRESULT lResult;
     *     LPARAM lParam;
     *     WPARAM wParam;
     *     UINT message;
     *     HWND hwnd;
     * } *PCWPRETSTRUCT
     * }
     */
    public static final AddressLayout PCWPRETSTRUCT = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagCWPRETSTRUCT {
     *     LRESULT lResult;
     *     LPARAM lParam;
     *     WPARAM wParam;
     *     UINT message;
     *     HWND hwnd;
     * } *NPCWPRETSTRUCT
     * }
     */
    public static final AddressLayout NPCWPRETSTRUCT = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagCWPRETSTRUCT {
     *     LRESULT lResult;
     *     LPARAM lParam;
     *     WPARAM wParam;
     *     UINT message;
     *     HWND hwnd;
     * } *LPCWPRETSTRUCT
     * }
     */
    public static final AddressLayout LPCWPRETSTRUCT = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagKBDLLHOOKSTRUCT {
     *     DWORD vkCode;
     *     DWORD scanCode;
     *     DWORD flags;
     *     DWORD time;
     *     ULONG_PTR dwExtraInfo;
     * } *LPKBDLLHOOKSTRUCT
     * }
     */
    public static final AddressLayout LPKBDLLHOOKSTRUCT = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagKBDLLHOOKSTRUCT {
     *     DWORD vkCode;
     *     DWORD scanCode;
     *     DWORD flags;
     *     DWORD time;
     *     ULONG_PTR dwExtraInfo;
     * } *PKBDLLHOOKSTRUCT
     * }
     */
    public static final AddressLayout PKBDLLHOOKSTRUCT = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagMSLLHOOKSTRUCT {
     *     POINT pt;
     *     DWORD mouseData;
     *     DWORD flags;
     *     DWORD time;
     *     ULONG_PTR dwExtraInfo;
     * } *LPMSLLHOOKSTRUCT
     * }
     */
    public static final AddressLayout LPMSLLHOOKSTRUCT = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagMSLLHOOKSTRUCT {
     *     POINT pt;
     *     DWORD mouseData;
     *     DWORD flags;
     *     DWORD time;
     *     ULONG_PTR dwExtraInfo;
     * } *PMSLLHOOKSTRUCT
     * }
     */
    public static final AddressLayout PMSLLHOOKSTRUCT = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagDEBUGHOOKINFO {
     *     DWORD idThread;
     *     DWORD idThreadInstaller;
     *     LPARAM lParam;
     *     WPARAM wParam;
     *     int code;
     * } *PDEBUGHOOKINFO
     * }
     */
    public static final AddressLayout PDEBUGHOOKINFO = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagDEBUGHOOKINFO {
     *     DWORD idThread;
     *     DWORD idThreadInstaller;
     *     LPARAM lParam;
     *     WPARAM wParam;
     *     int code;
     * } *NPDEBUGHOOKINFO
     * }
     */
    public static final AddressLayout NPDEBUGHOOKINFO = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagDEBUGHOOKINFO {
     *     DWORD idThread;
     *     DWORD idThreadInstaller;
     *     LPARAM lParam;
     *     WPARAM wParam;
     *     int code;
     * } *LPDEBUGHOOKINFO
     * }
     */
    public static final AddressLayout LPDEBUGHOOKINFO = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagMOUSEHOOKSTRUCT {
     *     POINT pt;
     *     HWND hwnd;
     *     UINT wHitTestCode;
     *     ULONG_PTR dwExtraInfo;
     * } *LPMOUSEHOOKSTRUCT
     * }
     */
    public static final AddressLayout LPMOUSEHOOKSTRUCT = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagMOUSEHOOKSTRUCT {
     *     POINT pt;
     *     HWND hwnd;
     *     UINT wHitTestCode;
     *     ULONG_PTR dwExtraInfo;
     * } *PMOUSEHOOKSTRUCT
     * }
     */
    public static final AddressLayout PMOUSEHOOKSTRUCT = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagMOUSEHOOKSTRUCTEX {
     *     DWORD mouseData;
     * } *LPMOUSEHOOKSTRUCTEX
     * }
     */
    public static final AddressLayout LPMOUSEHOOKSTRUCTEX = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagMOUSEHOOKSTRUCTEX {
     *     DWORD mouseData;
     * } *PMOUSEHOOKSTRUCTEX
     * }
     */
    public static final AddressLayout PMOUSEHOOKSTRUCTEX = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagHARDWAREHOOKSTRUCT {
     *     HWND hwnd;
     *     UINT message;
     *     WPARAM wParam;
     *     LPARAM lParam;
     * } *LPHARDWAREHOOKSTRUCT
     * }
     */
    public static final AddressLayout LPHARDWAREHOOKSTRUCT = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagHARDWAREHOOKSTRUCT {
     *     HWND hwnd;
     *     UINT message;
     *     WPARAM wParam;
     *     LPARAM lParam;
     * } *PHARDWAREHOOKSTRUCT
     * }
     */
    public static final AddressLayout PHARDWAREHOOKSTRUCT = C_POINTER;

    private static class LoadKeyboardLayoutA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("LoadKeyboardLayoutA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HKL LoadKeyboardLayoutA(LPCSTR pwszKLID, UINT Flags)
     * }
     */
    public static FunctionDescriptor LoadKeyboardLayoutA$descriptor() {
        return LoadKeyboardLayoutA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HKL LoadKeyboardLayoutA(LPCSTR pwszKLID, UINT Flags)
     * }
     */
    public static MethodHandle LoadKeyboardLayoutA$handle() {
        return LoadKeyboardLayoutA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * HKL LoadKeyboardLayoutA(LPCSTR pwszKLID, UINT Flags)
     * }
     */
    public static MemorySegment LoadKeyboardLayoutA(MemorySegment pwszKLID, int Flags) {
        var mh$ = LoadKeyboardLayoutA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LoadKeyboardLayoutA", pwszKLID, Flags);
            }
            return (MemorySegment)mh$.invokeExact(pwszKLID, Flags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LoadKeyboardLayoutW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("LoadKeyboardLayoutW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HKL LoadKeyboardLayoutW(LPCWSTR pwszKLID, UINT Flags)
     * }
     */
    public static FunctionDescriptor LoadKeyboardLayoutW$descriptor() {
        return LoadKeyboardLayoutW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HKL LoadKeyboardLayoutW(LPCWSTR pwszKLID, UINT Flags)
     * }
     */
    public static MethodHandle LoadKeyboardLayoutW$handle() {
        return LoadKeyboardLayoutW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * HKL LoadKeyboardLayoutW(LPCWSTR pwszKLID, UINT Flags)
     * }
     */
    public static MemorySegment LoadKeyboardLayoutW(MemorySegment pwszKLID, int Flags) {
        var mh$ = LoadKeyboardLayoutW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LoadKeyboardLayoutW", pwszKLID, Flags);
            }
            return (MemorySegment)mh$.invokeExact(pwszKLID, Flags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ActivateKeyboardLayout {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("ActivateKeyboardLayout"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HKL ActivateKeyboardLayout(HKL hkl, UINT Flags)
     * }
     */
    public static FunctionDescriptor ActivateKeyboardLayout$descriptor() {
        return ActivateKeyboardLayout.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HKL ActivateKeyboardLayout(HKL hkl, UINT Flags)
     * }
     */
    public static MethodHandle ActivateKeyboardLayout$handle() {
        return ActivateKeyboardLayout.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * HKL ActivateKeyboardLayout(HKL hkl, UINT Flags)
     * }
     */
    public static MemorySegment ActivateKeyboardLayout(MemorySegment hkl, int Flags) {
        var mh$ = ActivateKeyboardLayout.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ActivateKeyboardLayout", hkl, Flags);
            }
            return (MemorySegment)mh$.invokeExact(hkl, Flags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ToUnicodeEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_INT,
            C_INT,
            C_POINTER,
            C_POINTER,
            C_INT,
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("ToUnicodeEx"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int ToUnicodeEx(UINT wVirtKey, UINT wScanCode, const BYTE *lpKeyState, LPWSTR pwszBuff, int cchBuff, UINT wFlags, HKL dwhkl)
     * }
     */
    public static FunctionDescriptor ToUnicodeEx$descriptor() {
        return ToUnicodeEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int ToUnicodeEx(UINT wVirtKey, UINT wScanCode, const BYTE *lpKeyState, LPWSTR pwszBuff, int cchBuff, UINT wFlags, HKL dwhkl)
     * }
     */
    public static MethodHandle ToUnicodeEx$handle() {
        return ToUnicodeEx.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int ToUnicodeEx(UINT wVirtKey, UINT wScanCode, const BYTE *lpKeyState, LPWSTR pwszBuff, int cchBuff, UINT wFlags, HKL dwhkl)
     * }
     */
    public static int ToUnicodeEx(int wVirtKey, int wScanCode, MemorySegment lpKeyState, MemorySegment pwszBuff, int cchBuff, int wFlags, MemorySegment dwhkl) {
        var mh$ = ToUnicodeEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ToUnicodeEx", wVirtKey, wScanCode, lpKeyState, pwszBuff, cchBuff, wFlags, dwhkl);
            }
            return (int)mh$.invokeExact(wVirtKey, wScanCode, lpKeyState, pwszBuff, cchBuff, wFlags, dwhkl);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class UnloadKeyboardLayout {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("UnloadKeyboardLayout"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL UnloadKeyboardLayout(HKL hkl)
     * }
     */
    public static FunctionDescriptor UnloadKeyboardLayout$descriptor() {
        return UnloadKeyboardLayout.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL UnloadKeyboardLayout(HKL hkl)
     * }
     */
    public static MethodHandle UnloadKeyboardLayout$handle() {
        return UnloadKeyboardLayout.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL UnloadKeyboardLayout(HKL hkl)
     * }
     */
    public static int UnloadKeyboardLayout(MemorySegment hkl) {
        var mh$ = UnloadKeyboardLayout.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("UnloadKeyboardLayout", hkl);
            }
            return (int)mh$.invokeExact(hkl);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetKeyboardLayoutNameA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetKeyboardLayoutNameA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetKeyboardLayoutNameA(LPSTR pwszKLID)
     * }
     */
    public static FunctionDescriptor GetKeyboardLayoutNameA$descriptor() {
        return GetKeyboardLayoutNameA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetKeyboardLayoutNameA(LPSTR pwszKLID)
     * }
     */
    public static MethodHandle GetKeyboardLayoutNameA$handle() {
        return GetKeyboardLayoutNameA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL GetKeyboardLayoutNameA(LPSTR pwszKLID)
     * }
     */
    public static int GetKeyboardLayoutNameA(MemorySegment pwszKLID) {
        var mh$ = GetKeyboardLayoutNameA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetKeyboardLayoutNameA", pwszKLID);
            }
            return (int)mh$.invokeExact(pwszKLID);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetKeyboardLayoutNameW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetKeyboardLayoutNameW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetKeyboardLayoutNameW(LPWSTR pwszKLID)
     * }
     */
    public static FunctionDescriptor GetKeyboardLayoutNameW$descriptor() {
        return GetKeyboardLayoutNameW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetKeyboardLayoutNameW(LPWSTR pwszKLID)
     * }
     */
    public static MethodHandle GetKeyboardLayoutNameW$handle() {
        return GetKeyboardLayoutNameW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL GetKeyboardLayoutNameW(LPWSTR pwszKLID)
     * }
     */
    public static int GetKeyboardLayoutNameW(MemorySegment pwszKLID) {
        var mh$ = GetKeyboardLayoutNameW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetKeyboardLayoutNameW", pwszKLID);
            }
            return (int)mh$.invokeExact(pwszKLID);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetKeyboardLayoutList {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetKeyboardLayoutList"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int GetKeyboardLayoutList(int nBuff, HKL *lpList)
     * }
     */
    public static FunctionDescriptor GetKeyboardLayoutList$descriptor() {
        return GetKeyboardLayoutList.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int GetKeyboardLayoutList(int nBuff, HKL *lpList)
     * }
     */
    public static MethodHandle GetKeyboardLayoutList$handle() {
        return GetKeyboardLayoutList.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int GetKeyboardLayoutList(int nBuff, HKL *lpList)
     * }
     */
    public static int GetKeyboardLayoutList(int nBuff, MemorySegment lpList) {
        var mh$ = GetKeyboardLayoutList.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetKeyboardLayoutList", nBuff, lpList);
            }
            return (int)mh$.invokeExact(nBuff, lpList);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetKeyboardLayout {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetKeyboardLayout"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HKL GetKeyboardLayout(DWORD idThread)
     * }
     */
    public static FunctionDescriptor GetKeyboardLayout$descriptor() {
        return GetKeyboardLayout.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HKL GetKeyboardLayout(DWORD idThread)
     * }
     */
    public static MethodHandle GetKeyboardLayout$handle() {
        return GetKeyboardLayout.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * HKL GetKeyboardLayout(DWORD idThread)
     * }
     */
    public static MemorySegment GetKeyboardLayout(int idThread) {
        var mh$ = GetKeyboardLayout.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetKeyboardLayout", idThread);
            }
            return (MemorySegment)mh$.invokeExact(idThread);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct tagMOUSEMOVEPOINT {
     *     int x;
     *     int y;
     *     DWORD time;
     *     ULONG_PTR dwExtraInfo;
     * } *PMOUSEMOVEPOINT
     * }
     */
    public static final AddressLayout PMOUSEMOVEPOINT = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagMOUSEMOVEPOINT {
     *     int x;
     *     int y;
     *     DWORD time;
     *     ULONG_PTR dwExtraInfo;
     * } *LPMOUSEMOVEPOINT
     * }
     */
    public static final AddressLayout LPMOUSEMOVEPOINT = C_POINTER;

    private static class GetMouseMovePointsEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_INT,
            C_POINTER,
            C_POINTER,
            C_INT,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetMouseMovePointsEx"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int GetMouseMovePointsEx(UINT cbSize, LPMOUSEMOVEPOINT lppt, LPMOUSEMOVEPOINT lpptBuf, int nBufPoints, DWORD resolution)
     * }
     */
    public static FunctionDescriptor GetMouseMovePointsEx$descriptor() {
        return GetMouseMovePointsEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int GetMouseMovePointsEx(UINT cbSize, LPMOUSEMOVEPOINT lppt, LPMOUSEMOVEPOINT lpptBuf, int nBufPoints, DWORD resolution)
     * }
     */
    public static MethodHandle GetMouseMovePointsEx$handle() {
        return GetMouseMovePointsEx.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int GetMouseMovePointsEx(UINT cbSize, LPMOUSEMOVEPOINT lppt, LPMOUSEMOVEPOINT lpptBuf, int nBufPoints, DWORD resolution)
     * }
     */
    public static int GetMouseMovePointsEx(int cbSize, MemorySegment lppt, MemorySegment lpptBuf, int nBufPoints, int resolution) {
        var mh$ = GetMouseMovePointsEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetMouseMovePointsEx", cbSize, lppt, lpptBuf, nBufPoints, resolution);
            }
            return (int)mh$.invokeExact(cbSize, lppt, lpptBuf, nBufPoints, resolution);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateDesktopA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_LONG,
            C_LONG,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CreateDesktopA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HDESK CreateDesktopA(LPCSTR lpszDesktop, LPCSTR lpszDevice, DEVMODEA *pDevmode, DWORD dwFlags, ACCESS_MASK dwDesiredAccess, LPSECURITY_ATTRIBUTES lpsa)
     * }
     */
    public static FunctionDescriptor CreateDesktopA$descriptor() {
        return CreateDesktopA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HDESK CreateDesktopA(LPCSTR lpszDesktop, LPCSTR lpszDevice, DEVMODEA *pDevmode, DWORD dwFlags, ACCESS_MASK dwDesiredAccess, LPSECURITY_ATTRIBUTES lpsa)
     * }
     */
    public static MethodHandle CreateDesktopA$handle() {
        return CreateDesktopA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * HDESK CreateDesktopA(LPCSTR lpszDesktop, LPCSTR lpszDevice, DEVMODEA *pDevmode, DWORD dwFlags, ACCESS_MASK dwDesiredAccess, LPSECURITY_ATTRIBUTES lpsa)
     * }
     */
    public static MemorySegment CreateDesktopA(MemorySegment lpszDesktop, MemorySegment lpszDevice, MemorySegment pDevmode, int dwFlags, int dwDesiredAccess, MemorySegment lpsa) {
        var mh$ = CreateDesktopA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateDesktopA", lpszDesktop, lpszDevice, pDevmode, dwFlags, dwDesiredAccess, lpsa);
            }
            return (MemorySegment)mh$.invokeExact(lpszDesktop, lpszDevice, pDevmode, dwFlags, dwDesiredAccess, lpsa);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateDesktopW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_LONG,
            C_LONG,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CreateDesktopW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HDESK CreateDesktopW(LPCWSTR lpszDesktop, LPCWSTR lpszDevice, DEVMODEW *pDevmode, DWORD dwFlags, ACCESS_MASK dwDesiredAccess, LPSECURITY_ATTRIBUTES lpsa)
     * }
     */
    public static FunctionDescriptor CreateDesktopW$descriptor() {
        return CreateDesktopW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HDESK CreateDesktopW(LPCWSTR lpszDesktop, LPCWSTR lpszDevice, DEVMODEW *pDevmode, DWORD dwFlags, ACCESS_MASK dwDesiredAccess, LPSECURITY_ATTRIBUTES lpsa)
     * }
     */
    public static MethodHandle CreateDesktopW$handle() {
        return CreateDesktopW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * HDESK CreateDesktopW(LPCWSTR lpszDesktop, LPCWSTR lpszDevice, DEVMODEW *pDevmode, DWORD dwFlags, ACCESS_MASK dwDesiredAccess, LPSECURITY_ATTRIBUTES lpsa)
     * }
     */
    public static MemorySegment CreateDesktopW(MemorySegment lpszDesktop, MemorySegment lpszDevice, MemorySegment pDevmode, int dwFlags, int dwDesiredAccess, MemorySegment lpsa) {
        var mh$ = CreateDesktopW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateDesktopW", lpszDesktop, lpszDevice, pDevmode, dwFlags, dwDesiredAccess, lpsa);
            }
            return (MemorySegment)mh$.invokeExact(lpszDesktop, lpszDevice, pDevmode, dwFlags, dwDesiredAccess, lpsa);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateDesktopExA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_LONG,
            C_LONG,
            C_POINTER,
            C_LONG,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CreateDesktopExA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HDESK CreateDesktopExA(LPCSTR lpszDesktop, LPCSTR lpszDevice, DEVMODEA *pDevmode, DWORD dwFlags, ACCESS_MASK dwDesiredAccess, LPSECURITY_ATTRIBUTES lpsa, ULONG ulHeapSize, PVOID pvoid)
     * }
     */
    public static FunctionDescriptor CreateDesktopExA$descriptor() {
        return CreateDesktopExA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HDESK CreateDesktopExA(LPCSTR lpszDesktop, LPCSTR lpszDevice, DEVMODEA *pDevmode, DWORD dwFlags, ACCESS_MASK dwDesiredAccess, LPSECURITY_ATTRIBUTES lpsa, ULONG ulHeapSize, PVOID pvoid)
     * }
     */
    public static MethodHandle CreateDesktopExA$handle() {
        return CreateDesktopExA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * HDESK CreateDesktopExA(LPCSTR lpszDesktop, LPCSTR lpszDevice, DEVMODEA *pDevmode, DWORD dwFlags, ACCESS_MASK dwDesiredAccess, LPSECURITY_ATTRIBUTES lpsa, ULONG ulHeapSize, PVOID pvoid)
     * }
     */
    public static MemorySegment CreateDesktopExA(MemorySegment lpszDesktop, MemorySegment lpszDevice, MemorySegment pDevmode, int dwFlags, int dwDesiredAccess, MemorySegment lpsa, int ulHeapSize, MemorySegment pvoid) {
        var mh$ = CreateDesktopExA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateDesktopExA", lpszDesktop, lpszDevice, pDevmode, dwFlags, dwDesiredAccess, lpsa, ulHeapSize, pvoid);
            }
            return (MemorySegment)mh$.invokeExact(lpszDesktop, lpszDevice, pDevmode, dwFlags, dwDesiredAccess, lpsa, ulHeapSize, pvoid);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateDesktopExW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_LONG,
            C_LONG,
            C_POINTER,
            C_LONG,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CreateDesktopExW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HDESK CreateDesktopExW(LPCWSTR lpszDesktop, LPCWSTR lpszDevice, DEVMODEW *pDevmode, DWORD dwFlags, ACCESS_MASK dwDesiredAccess, LPSECURITY_ATTRIBUTES lpsa, ULONG ulHeapSize, PVOID pvoid)
     * }
     */
    public static FunctionDescriptor CreateDesktopExW$descriptor() {
        return CreateDesktopExW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HDESK CreateDesktopExW(LPCWSTR lpszDesktop, LPCWSTR lpszDevice, DEVMODEW *pDevmode, DWORD dwFlags, ACCESS_MASK dwDesiredAccess, LPSECURITY_ATTRIBUTES lpsa, ULONG ulHeapSize, PVOID pvoid)
     * }
     */
    public static MethodHandle CreateDesktopExW$handle() {
        return CreateDesktopExW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * HDESK CreateDesktopExW(LPCWSTR lpszDesktop, LPCWSTR lpszDevice, DEVMODEW *pDevmode, DWORD dwFlags, ACCESS_MASK dwDesiredAccess, LPSECURITY_ATTRIBUTES lpsa, ULONG ulHeapSize, PVOID pvoid)
     * }
     */
    public static MemorySegment CreateDesktopExW(MemorySegment lpszDesktop, MemorySegment lpszDevice, MemorySegment pDevmode, int dwFlags, int dwDesiredAccess, MemorySegment lpsa, int ulHeapSize, MemorySegment pvoid) {
        var mh$ = CreateDesktopExW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateDesktopExW", lpszDesktop, lpszDevice, pDevmode, dwFlags, dwDesiredAccess, lpsa, ulHeapSize, pvoid);
            }
            return (MemorySegment)mh$.invokeExact(lpszDesktop, lpszDevice, pDevmode, dwFlags, dwDesiredAccess, lpsa, ulHeapSize, pvoid);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class OpenDesktopA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER,
            C_LONG,
            C_INT,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("OpenDesktopA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HDESK OpenDesktopA(LPCSTR lpszDesktop, DWORD dwFlags, BOOL fInherit, ACCESS_MASK dwDesiredAccess)
     * }
     */
    public static FunctionDescriptor OpenDesktopA$descriptor() {
        return OpenDesktopA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HDESK OpenDesktopA(LPCSTR lpszDesktop, DWORD dwFlags, BOOL fInherit, ACCESS_MASK dwDesiredAccess)
     * }
     */
    public static MethodHandle OpenDesktopA$handle() {
        return OpenDesktopA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * HDESK OpenDesktopA(LPCSTR lpszDesktop, DWORD dwFlags, BOOL fInherit, ACCESS_MASK dwDesiredAccess)
     * }
     */
    public static MemorySegment OpenDesktopA(MemorySegment lpszDesktop, int dwFlags, int fInherit, int dwDesiredAccess) {
        var mh$ = OpenDesktopA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("OpenDesktopA", lpszDesktop, dwFlags, fInherit, dwDesiredAccess);
            }
            return (MemorySegment)mh$.invokeExact(lpszDesktop, dwFlags, fInherit, dwDesiredAccess);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class OpenDesktopW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER,
            C_LONG,
            C_INT,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("OpenDesktopW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HDESK OpenDesktopW(LPCWSTR lpszDesktop, DWORD dwFlags, BOOL fInherit, ACCESS_MASK dwDesiredAccess)
     * }
     */
    public static FunctionDescriptor OpenDesktopW$descriptor() {
        return OpenDesktopW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HDESK OpenDesktopW(LPCWSTR lpszDesktop, DWORD dwFlags, BOOL fInherit, ACCESS_MASK dwDesiredAccess)
     * }
     */
    public static MethodHandle OpenDesktopW$handle() {
        return OpenDesktopW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * HDESK OpenDesktopW(LPCWSTR lpszDesktop, DWORD dwFlags, BOOL fInherit, ACCESS_MASK dwDesiredAccess)
     * }
     */
    public static MemorySegment OpenDesktopW(MemorySegment lpszDesktop, int dwFlags, int fInherit, int dwDesiredAccess) {
        var mh$ = OpenDesktopW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("OpenDesktopW", lpszDesktop, dwFlags, fInherit, dwDesiredAccess);
            }
            return (MemorySegment)mh$.invokeExact(lpszDesktop, dwFlags, fInherit, dwDesiredAccess);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class OpenInputDesktop {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_LONG,
            C_INT,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("OpenInputDesktop"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HDESK OpenInputDesktop(DWORD dwFlags, BOOL fInherit, ACCESS_MASK dwDesiredAccess)
     * }
     */
    public static FunctionDescriptor OpenInputDesktop$descriptor() {
        return OpenInputDesktop.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HDESK OpenInputDesktop(DWORD dwFlags, BOOL fInherit, ACCESS_MASK dwDesiredAccess)
     * }
     */
    public static MethodHandle OpenInputDesktop$handle() {
        return OpenInputDesktop.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * HDESK OpenInputDesktop(DWORD dwFlags, BOOL fInherit, ACCESS_MASK dwDesiredAccess)
     * }
     */
    public static MemorySegment OpenInputDesktop(int dwFlags, int fInherit, int dwDesiredAccess) {
        var mh$ = OpenInputDesktop.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("OpenInputDesktop", dwFlags, fInherit, dwDesiredAccess);
            }
            return (MemorySegment)mh$.invokeExact(dwFlags, fInherit, dwDesiredAccess);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class EnumDesktopsA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_LONG_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("EnumDesktopsA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL EnumDesktopsA(HWINSTA hwinsta, DESKTOPENUMPROCA lpEnumFunc, LPARAM lParam)
     * }
     */
    public static FunctionDescriptor EnumDesktopsA$descriptor() {
        return EnumDesktopsA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL EnumDesktopsA(HWINSTA hwinsta, DESKTOPENUMPROCA lpEnumFunc, LPARAM lParam)
     * }
     */
    public static MethodHandle EnumDesktopsA$handle() {
        return EnumDesktopsA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL EnumDesktopsA(HWINSTA hwinsta, DESKTOPENUMPROCA lpEnumFunc, LPARAM lParam)
     * }
     */
    public static int EnumDesktopsA(MemorySegment hwinsta, MemorySegment lpEnumFunc, long lParam) {
        var mh$ = EnumDesktopsA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("EnumDesktopsA", hwinsta, lpEnumFunc, lParam);
            }
            return (int)mh$.invokeExact(hwinsta, lpEnumFunc, lParam);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class EnumDesktopsW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_LONG_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("EnumDesktopsW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL EnumDesktopsW(HWINSTA hwinsta, DESKTOPENUMPROCW lpEnumFunc, LPARAM lParam)
     * }
     */
    public static FunctionDescriptor EnumDesktopsW$descriptor() {
        return EnumDesktopsW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL EnumDesktopsW(HWINSTA hwinsta, DESKTOPENUMPROCW lpEnumFunc, LPARAM lParam)
     * }
     */
    public static MethodHandle EnumDesktopsW$handle() {
        return EnumDesktopsW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL EnumDesktopsW(HWINSTA hwinsta, DESKTOPENUMPROCW lpEnumFunc, LPARAM lParam)
     * }
     */
    public static int EnumDesktopsW(MemorySegment hwinsta, MemorySegment lpEnumFunc, long lParam) {
        var mh$ = EnumDesktopsW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("EnumDesktopsW", hwinsta, lpEnumFunc, lParam);
            }
            return (int)mh$.invokeExact(hwinsta, lpEnumFunc, lParam);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class EnumDesktopWindows {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_LONG_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("EnumDesktopWindows"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL EnumDesktopWindows(HDESK hDesktop, WNDENUMPROC lpfn, LPARAM lParam)
     * }
     */
    public static FunctionDescriptor EnumDesktopWindows$descriptor() {
        return EnumDesktopWindows.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL EnumDesktopWindows(HDESK hDesktop, WNDENUMPROC lpfn, LPARAM lParam)
     * }
     */
    public static MethodHandle EnumDesktopWindows$handle() {
        return EnumDesktopWindows.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL EnumDesktopWindows(HDESK hDesktop, WNDENUMPROC lpfn, LPARAM lParam)
     * }
     */
    public static int EnumDesktopWindows(MemorySegment hDesktop, MemorySegment lpfn, long lParam) {
        var mh$ = EnumDesktopWindows.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("EnumDesktopWindows", hDesktop, lpfn, lParam);
            }
            return (int)mh$.invokeExact(hDesktop, lpfn, lParam);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SwitchDesktop {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("SwitchDesktop"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SwitchDesktop(HDESK hDesktop)
     * }
     */
    public static FunctionDescriptor SwitchDesktop$descriptor() {
        return SwitchDesktop.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SwitchDesktop(HDESK hDesktop)
     * }
     */
    public static MethodHandle SwitchDesktop$handle() {
        return SwitchDesktop.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL SwitchDesktop(HDESK hDesktop)
     * }
     */
    public static int SwitchDesktop(MemorySegment hDesktop) {
        var mh$ = SwitchDesktop.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SwitchDesktop", hDesktop);
            }
            return (int)mh$.invokeExact(hDesktop);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetThreadDesktop {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("SetThreadDesktop"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetThreadDesktop(HDESK hDesktop)
     * }
     */
    public static FunctionDescriptor SetThreadDesktop$descriptor() {
        return SetThreadDesktop.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetThreadDesktop(HDESK hDesktop)
     * }
     */
    public static MethodHandle SetThreadDesktop$handle() {
        return SetThreadDesktop.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL SetThreadDesktop(HDESK hDesktop)
     * }
     */
    public static int SetThreadDesktop(MemorySegment hDesktop) {
        var mh$ = SetThreadDesktop.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetThreadDesktop", hDesktop);
            }
            return (int)mh$.invokeExact(hDesktop);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CloseDesktop {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CloseDesktop"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CloseDesktop(HDESK hDesktop)
     * }
     */
    public static FunctionDescriptor CloseDesktop$descriptor() {
        return CloseDesktop.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CloseDesktop(HDESK hDesktop)
     * }
     */
    public static MethodHandle CloseDesktop$handle() {
        return CloseDesktop.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL CloseDesktop(HDESK hDesktop)
     * }
     */
    public static int CloseDesktop(MemorySegment hDesktop) {
        var mh$ = CloseDesktop.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CloseDesktop", hDesktop);
            }
            return (int)mh$.invokeExact(hDesktop);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetThreadDesktop {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetThreadDesktop"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HDESK GetThreadDesktop(DWORD dwThreadId)
     * }
     */
    public static FunctionDescriptor GetThreadDesktop$descriptor() {
        return GetThreadDesktop.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HDESK GetThreadDesktop(DWORD dwThreadId)
     * }
     */
    public static MethodHandle GetThreadDesktop$handle() {
        return GetThreadDesktop.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * HDESK GetThreadDesktop(DWORD dwThreadId)
     * }
     */
    public static MemorySegment GetThreadDesktop(int dwThreadId) {
        var mh$ = GetThreadDesktop.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetThreadDesktop", dwThreadId);
            }
            return (MemorySegment)mh$.invokeExact(dwThreadId);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateWindowStationA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER,
            C_LONG,
            C_LONG,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CreateWindowStationA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HWINSTA CreateWindowStationA(LPCSTR lpwinsta, DWORD dwFlags, ACCESS_MASK dwDesiredAccess, LPSECURITY_ATTRIBUTES lpsa)
     * }
     */
    public static FunctionDescriptor CreateWindowStationA$descriptor() {
        return CreateWindowStationA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HWINSTA CreateWindowStationA(LPCSTR lpwinsta, DWORD dwFlags, ACCESS_MASK dwDesiredAccess, LPSECURITY_ATTRIBUTES lpsa)
     * }
     */
    public static MethodHandle CreateWindowStationA$handle() {
        return CreateWindowStationA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * HWINSTA CreateWindowStationA(LPCSTR lpwinsta, DWORD dwFlags, ACCESS_MASK dwDesiredAccess, LPSECURITY_ATTRIBUTES lpsa)
     * }
     */
    public static MemorySegment CreateWindowStationA(MemorySegment lpwinsta, int dwFlags, int dwDesiredAccess, MemorySegment lpsa) {
        var mh$ = CreateWindowStationA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateWindowStationA", lpwinsta, dwFlags, dwDesiredAccess, lpsa);
            }
            return (MemorySegment)mh$.invokeExact(lpwinsta, dwFlags, dwDesiredAccess, lpsa);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateWindowStationW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER,
            C_LONG,
            C_LONG,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CreateWindowStationW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HWINSTA CreateWindowStationW(LPCWSTR lpwinsta, DWORD dwFlags, ACCESS_MASK dwDesiredAccess, LPSECURITY_ATTRIBUTES lpsa)
     * }
     */
    public static FunctionDescriptor CreateWindowStationW$descriptor() {
        return CreateWindowStationW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HWINSTA CreateWindowStationW(LPCWSTR lpwinsta, DWORD dwFlags, ACCESS_MASK dwDesiredAccess, LPSECURITY_ATTRIBUTES lpsa)
     * }
     */
    public static MethodHandle CreateWindowStationW$handle() {
        return CreateWindowStationW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * HWINSTA CreateWindowStationW(LPCWSTR lpwinsta, DWORD dwFlags, ACCESS_MASK dwDesiredAccess, LPSECURITY_ATTRIBUTES lpsa)
     * }
     */
    public static MemorySegment CreateWindowStationW(MemorySegment lpwinsta, int dwFlags, int dwDesiredAccess, MemorySegment lpsa) {
        var mh$ = CreateWindowStationW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateWindowStationW", lpwinsta, dwFlags, dwDesiredAccess, lpsa);
            }
            return (MemorySegment)mh$.invokeExact(lpwinsta, dwFlags, dwDesiredAccess, lpsa);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class OpenWindowStationA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER,
            C_INT,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("OpenWindowStationA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HWINSTA OpenWindowStationA(LPCSTR lpszWinSta, BOOL fInherit, ACCESS_MASK dwDesiredAccess)
     * }
     */
    public static FunctionDescriptor OpenWindowStationA$descriptor() {
        return OpenWindowStationA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HWINSTA OpenWindowStationA(LPCSTR lpszWinSta, BOOL fInherit, ACCESS_MASK dwDesiredAccess)
     * }
     */
    public static MethodHandle OpenWindowStationA$handle() {
        return OpenWindowStationA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * HWINSTA OpenWindowStationA(LPCSTR lpszWinSta, BOOL fInherit, ACCESS_MASK dwDesiredAccess)
     * }
     */
    public static MemorySegment OpenWindowStationA(MemorySegment lpszWinSta, int fInherit, int dwDesiredAccess) {
        var mh$ = OpenWindowStationA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("OpenWindowStationA", lpszWinSta, fInherit, dwDesiredAccess);
            }
            return (MemorySegment)mh$.invokeExact(lpszWinSta, fInherit, dwDesiredAccess);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class OpenWindowStationW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER,
            C_INT,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("OpenWindowStationW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HWINSTA OpenWindowStationW(LPCWSTR lpszWinSta, BOOL fInherit, ACCESS_MASK dwDesiredAccess)
     * }
     */
    public static FunctionDescriptor OpenWindowStationW$descriptor() {
        return OpenWindowStationW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HWINSTA OpenWindowStationW(LPCWSTR lpszWinSta, BOOL fInherit, ACCESS_MASK dwDesiredAccess)
     * }
     */
    public static MethodHandle OpenWindowStationW$handle() {
        return OpenWindowStationW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * HWINSTA OpenWindowStationW(LPCWSTR lpszWinSta, BOOL fInherit, ACCESS_MASK dwDesiredAccess)
     * }
     */
    public static MemorySegment OpenWindowStationW(MemorySegment lpszWinSta, int fInherit, int dwDesiredAccess) {
        var mh$ = OpenWindowStationW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("OpenWindowStationW", lpszWinSta, fInherit, dwDesiredAccess);
            }
            return (MemorySegment)mh$.invokeExact(lpszWinSta, fInherit, dwDesiredAccess);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class EnumWindowStationsA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_LONG_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("EnumWindowStationsA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL EnumWindowStationsA(WINSTAENUMPROCA lpEnumFunc, LPARAM lParam)
     * }
     */
    public static FunctionDescriptor EnumWindowStationsA$descriptor() {
        return EnumWindowStationsA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL EnumWindowStationsA(WINSTAENUMPROCA lpEnumFunc, LPARAM lParam)
     * }
     */
    public static MethodHandle EnumWindowStationsA$handle() {
        return EnumWindowStationsA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL EnumWindowStationsA(WINSTAENUMPROCA lpEnumFunc, LPARAM lParam)
     * }
     */
    public static int EnumWindowStationsA(MemorySegment lpEnumFunc, long lParam) {
        var mh$ = EnumWindowStationsA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("EnumWindowStationsA", lpEnumFunc, lParam);
            }
            return (int)mh$.invokeExact(lpEnumFunc, lParam);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class EnumWindowStationsW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_LONG_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("EnumWindowStationsW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL EnumWindowStationsW(WINSTAENUMPROCW lpEnumFunc, LPARAM lParam)
     * }
     */
    public static FunctionDescriptor EnumWindowStationsW$descriptor() {
        return EnumWindowStationsW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL EnumWindowStationsW(WINSTAENUMPROCW lpEnumFunc, LPARAM lParam)
     * }
     */
    public static MethodHandle EnumWindowStationsW$handle() {
        return EnumWindowStationsW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL EnumWindowStationsW(WINSTAENUMPROCW lpEnumFunc, LPARAM lParam)
     * }
     */
    public static int EnumWindowStationsW(MemorySegment lpEnumFunc, long lParam) {
        var mh$ = EnumWindowStationsW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("EnumWindowStationsW", lpEnumFunc, lParam);
            }
            return (int)mh$.invokeExact(lpEnumFunc, lParam);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CloseWindowStation {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CloseWindowStation"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CloseWindowStation(HWINSTA hWinSta)
     * }
     */
    public static FunctionDescriptor CloseWindowStation$descriptor() {
        return CloseWindowStation.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CloseWindowStation(HWINSTA hWinSta)
     * }
     */
    public static MethodHandle CloseWindowStation$handle() {
        return CloseWindowStation.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL CloseWindowStation(HWINSTA hWinSta)
     * }
     */
    public static int CloseWindowStation(MemorySegment hWinSta) {
        var mh$ = CloseWindowStation.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CloseWindowStation", hWinSta);
            }
            return (int)mh$.invokeExact(hWinSta);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetProcessWindowStation {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("SetProcessWindowStation"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetProcessWindowStation(HWINSTA hWinSta)
     * }
     */
    public static FunctionDescriptor SetProcessWindowStation$descriptor() {
        return SetProcessWindowStation.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetProcessWindowStation(HWINSTA hWinSta)
     * }
     */
    public static MethodHandle SetProcessWindowStation$handle() {
        return SetProcessWindowStation.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL SetProcessWindowStation(HWINSTA hWinSta)
     * }
     */
    public static int SetProcessWindowStation(MemorySegment hWinSta) {
        var mh$ = SetProcessWindowStation.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetProcessWindowStation", hWinSta);
            }
            return (int)mh$.invokeExact(hWinSta);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetProcessWindowStation {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER    );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetProcessWindowStation"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HWINSTA GetProcessWindowStation()
     * }
     */
    public static FunctionDescriptor GetProcessWindowStation$descriptor() {
        return GetProcessWindowStation.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HWINSTA GetProcessWindowStation()
     * }
     */
    public static MethodHandle GetProcessWindowStation$handle() {
        return GetProcessWindowStation.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * HWINSTA GetProcessWindowStation()
     * }
     */
    public static MemorySegment GetProcessWindowStation() {
        var mh$ = GetProcessWindowStation.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetProcessWindowStation");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetUserObjectSecurity {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("SetUserObjectSecurity"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetUserObjectSecurity(HANDLE hObj, PSECURITY_INFORMATION pSIRequested, PSECURITY_DESCRIPTOR pSID)
     * }
     */
    public static FunctionDescriptor SetUserObjectSecurity$descriptor() {
        return SetUserObjectSecurity.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetUserObjectSecurity(HANDLE hObj, PSECURITY_INFORMATION pSIRequested, PSECURITY_DESCRIPTOR pSID)
     * }
     */
    public static MethodHandle SetUserObjectSecurity$handle() {
        return SetUserObjectSecurity.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL SetUserObjectSecurity(HANDLE hObj, PSECURITY_INFORMATION pSIRequested, PSECURITY_DESCRIPTOR pSID)
     * }
     */
    public static int SetUserObjectSecurity(MemorySegment hObj, MemorySegment pSIRequested, MemorySegment pSID) {
        var mh$ = SetUserObjectSecurity.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetUserObjectSecurity", hObj, pSIRequested, pSID);
            }
            return (int)mh$.invokeExact(hObj, pSIRequested, pSID);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetUserObjectSecurity {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_LONG,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetUserObjectSecurity"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetUserObjectSecurity(HANDLE hObj, PSECURITY_INFORMATION pSIRequested, PSECURITY_DESCRIPTOR pSID, DWORD nLength, LPDWORD lpnLengthNeeded)
     * }
     */
    public static FunctionDescriptor GetUserObjectSecurity$descriptor() {
        return GetUserObjectSecurity.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetUserObjectSecurity(HANDLE hObj, PSECURITY_INFORMATION pSIRequested, PSECURITY_DESCRIPTOR pSID, DWORD nLength, LPDWORD lpnLengthNeeded)
     * }
     */
    public static MethodHandle GetUserObjectSecurity$handle() {
        return GetUserObjectSecurity.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL GetUserObjectSecurity(HANDLE hObj, PSECURITY_INFORMATION pSIRequested, PSECURITY_DESCRIPTOR pSID, DWORD nLength, LPDWORD lpnLengthNeeded)
     * }
     */
    public static int GetUserObjectSecurity(MemorySegment hObj, MemorySegment pSIRequested, MemorySegment pSID, int nLength, MemorySegment lpnLengthNeeded) {
        var mh$ = GetUserObjectSecurity.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetUserObjectSecurity", hObj, pSIRequested, pSID, nLength, lpnLengthNeeded);
            }
            return (int)mh$.invokeExact(hObj, pSIRequested, pSID, nLength, lpnLengthNeeded);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct tagUSEROBJECTFLAGS {
     *     BOOL fInherit;
     *     BOOL fReserved;
     *     DWORD dwFlags;
     * } *PUSEROBJECTFLAGS
     * }
     */
    public static final AddressLayout PUSEROBJECTFLAGS = C_POINTER;

    private static class GetUserObjectInformationA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_INT,
            C_POINTER,
            C_LONG,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetUserObjectInformationA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetUserObjectInformationA(HANDLE hObj, int nIndex, PVOID pvInfo, DWORD nLength, LPDWORD lpnLengthNeeded)
     * }
     */
    public static FunctionDescriptor GetUserObjectInformationA$descriptor() {
        return GetUserObjectInformationA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetUserObjectInformationA(HANDLE hObj, int nIndex, PVOID pvInfo, DWORD nLength, LPDWORD lpnLengthNeeded)
     * }
     */
    public static MethodHandle GetUserObjectInformationA$handle() {
        return GetUserObjectInformationA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL GetUserObjectInformationA(HANDLE hObj, int nIndex, PVOID pvInfo, DWORD nLength, LPDWORD lpnLengthNeeded)
     * }
     */
    public static int GetUserObjectInformationA(MemorySegment hObj, int nIndex, MemorySegment pvInfo, int nLength, MemorySegment lpnLengthNeeded) {
        var mh$ = GetUserObjectInformationA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetUserObjectInformationA", hObj, nIndex, pvInfo, nLength, lpnLengthNeeded);
            }
            return (int)mh$.invokeExact(hObj, nIndex, pvInfo, nLength, lpnLengthNeeded);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetUserObjectInformationW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_INT,
            C_POINTER,
            C_LONG,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetUserObjectInformationW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetUserObjectInformationW(HANDLE hObj, int nIndex, PVOID pvInfo, DWORD nLength, LPDWORD lpnLengthNeeded)
     * }
     */
    public static FunctionDescriptor GetUserObjectInformationW$descriptor() {
        return GetUserObjectInformationW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetUserObjectInformationW(HANDLE hObj, int nIndex, PVOID pvInfo, DWORD nLength, LPDWORD lpnLengthNeeded)
     * }
     */
    public static MethodHandle GetUserObjectInformationW$handle() {
        return GetUserObjectInformationW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL GetUserObjectInformationW(HANDLE hObj, int nIndex, PVOID pvInfo, DWORD nLength, LPDWORD lpnLengthNeeded)
     * }
     */
    public static int GetUserObjectInformationW(MemorySegment hObj, int nIndex, MemorySegment pvInfo, int nLength, MemorySegment lpnLengthNeeded) {
        var mh$ = GetUserObjectInformationW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetUserObjectInformationW", hObj, nIndex, pvInfo, nLength, lpnLengthNeeded);
            }
            return (int)mh$.invokeExact(hObj, nIndex, pvInfo, nLength, lpnLengthNeeded);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetUserObjectInformationA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_INT,
            C_POINTER,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("SetUserObjectInformationA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetUserObjectInformationA(HANDLE hObj, int nIndex, PVOID pvInfo, DWORD nLength)
     * }
     */
    public static FunctionDescriptor SetUserObjectInformationA$descriptor() {
        return SetUserObjectInformationA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetUserObjectInformationA(HANDLE hObj, int nIndex, PVOID pvInfo, DWORD nLength)
     * }
     */
    public static MethodHandle SetUserObjectInformationA$handle() {
        return SetUserObjectInformationA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL SetUserObjectInformationA(HANDLE hObj, int nIndex, PVOID pvInfo, DWORD nLength)
     * }
     */
    public static int SetUserObjectInformationA(MemorySegment hObj, int nIndex, MemorySegment pvInfo, int nLength) {
        var mh$ = SetUserObjectInformationA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetUserObjectInformationA", hObj, nIndex, pvInfo, nLength);
            }
            return (int)mh$.invokeExact(hObj, nIndex, pvInfo, nLength);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetUserObjectInformationW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_INT,
            C_POINTER,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("SetUserObjectInformationW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetUserObjectInformationW(HANDLE hObj, int nIndex, PVOID pvInfo, DWORD nLength)
     * }
     */
    public static FunctionDescriptor SetUserObjectInformationW$descriptor() {
        return SetUserObjectInformationW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetUserObjectInformationW(HANDLE hObj, int nIndex, PVOID pvInfo, DWORD nLength)
     * }
     */
    public static MethodHandle SetUserObjectInformationW$handle() {
        return SetUserObjectInformationW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL SetUserObjectInformationW(HANDLE hObj, int nIndex, PVOID pvInfo, DWORD nLength)
     * }
     */
    public static int SetUserObjectInformationW(MemorySegment hObj, int nIndex, MemorySegment pvInfo, int nLength) {
        var mh$ = SetUserObjectInformationW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetUserObjectInformationW", hObj, nIndex, pvInfo, nLength);
            }
            return (int)mh$.invokeExact(hObj, nIndex, pvInfo, nLength);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct tagWNDCLASSEXA {
     *     UINT cbSize;
     *     UINT style;
     *     WNDPROC lpfnWndProc;
     *     int cbClsExtra;
     *     int cbWndExtra;
     *     HINSTANCE hInstance;
     *     HICON hIcon;
     *     HCURSOR hCursor;
     *     HBRUSH hbrBackground;
     *     LPCSTR lpszMenuName;
     *     LPCSTR lpszClassName;
     *     HICON hIconSm;
     * } *PWNDCLASSEXA
     * }
     */
    public static final AddressLayout PWNDCLASSEXA = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagWNDCLASSEXA {
     *     UINT cbSize;
     *     UINT style;
     *     WNDPROC lpfnWndProc;
     *     int cbClsExtra;
     *     int cbWndExtra;
     *     HINSTANCE hInstance;
     *     HICON hIcon;
     *     HCURSOR hCursor;
     *     HBRUSH hbrBackground;
     *     LPCSTR lpszMenuName;
     *     LPCSTR lpszClassName;
     *     HICON hIconSm;
     * } *NPWNDCLASSEXA
     * }
     */
    public static final AddressLayout NPWNDCLASSEXA = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagWNDCLASSEXA {
     *     UINT cbSize;
     *     UINT style;
     *     WNDPROC lpfnWndProc;
     *     int cbClsExtra;
     *     int cbWndExtra;
     *     HINSTANCE hInstance;
     *     HICON hIcon;
     *     HCURSOR hCursor;
     *     HBRUSH hbrBackground;
     *     LPCSTR lpszMenuName;
     *     LPCSTR lpszClassName;
     *     HICON hIconSm;
     * } *LPWNDCLASSEXA
     * }
     */
    public static final AddressLayout LPWNDCLASSEXA = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagWNDCLASSEXW {
     *     UINT cbSize;
     *     UINT style;
     *     WNDPROC lpfnWndProc;
     *     int cbClsExtra;
     *     int cbWndExtra;
     *     HINSTANCE hInstance;
     *     HICON hIcon;
     *     HCURSOR hCursor;
     *     HBRUSH hbrBackground;
     *     LPCWSTR lpszMenuName;
     *     LPCWSTR lpszClassName;
     *     HICON hIconSm;
     * } *PWNDCLASSEXW
     * }
     */
    public static final AddressLayout PWNDCLASSEXW = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagWNDCLASSEXW {
     *     UINT cbSize;
     *     UINT style;
     *     WNDPROC lpfnWndProc;
     *     int cbClsExtra;
     *     int cbWndExtra;
     *     HINSTANCE hInstance;
     *     HICON hIcon;
     *     HCURSOR hCursor;
     *     HBRUSH hbrBackground;
     *     LPCWSTR lpszMenuName;
     *     LPCWSTR lpszClassName;
     *     HICON hIconSm;
     * } *NPWNDCLASSEXW
     * }
     */
    public static final AddressLayout NPWNDCLASSEXW = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagWNDCLASSEXW {
     *     UINT cbSize;
     *     UINT style;
     *     WNDPROC lpfnWndProc;
     *     int cbClsExtra;
     *     int cbWndExtra;
     *     HINSTANCE hInstance;
     *     HICON hIcon;
     *     HCURSOR hCursor;
     *     HBRUSH hbrBackground;
     *     LPCWSTR lpszMenuName;
     *     LPCWSTR lpszClassName;
     *     HICON hIconSm;
     * } *LPWNDCLASSEXW
     * }
     */
    public static final AddressLayout LPWNDCLASSEXW = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef PWNDCLASSEXA PWNDCLASSEX
     * }
     */
    public static final AddressLayout PWNDCLASSEX = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef NPWNDCLASSEXA NPWNDCLASSEX
     * }
     */
    public static final AddressLayout NPWNDCLASSEX = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef LPWNDCLASSEXA LPWNDCLASSEX
     * }
     */
    public static final AddressLayout LPWNDCLASSEX = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagWNDCLASSA {
     *     UINT style;
     *     WNDPROC lpfnWndProc;
     *     int cbClsExtra;
     *     int cbWndExtra;
     *     HINSTANCE hInstance;
     *     HICON hIcon;
     *     HCURSOR hCursor;
     *     HBRUSH hbrBackground;
     *     LPCSTR lpszMenuName;
     *     LPCSTR lpszClassName;
     * } *PWNDCLASSA
     * }
     */
    public static final AddressLayout PWNDCLASSA = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagWNDCLASSA {
     *     UINT style;
     *     WNDPROC lpfnWndProc;
     *     int cbClsExtra;
     *     int cbWndExtra;
     *     HINSTANCE hInstance;
     *     HICON hIcon;
     *     HCURSOR hCursor;
     *     HBRUSH hbrBackground;
     *     LPCSTR lpszMenuName;
     *     LPCSTR lpszClassName;
     * } *NPWNDCLASSA
     * }
     */
    public static final AddressLayout NPWNDCLASSA = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagWNDCLASSA {
     *     UINT style;
     *     WNDPROC lpfnWndProc;
     *     int cbClsExtra;
     *     int cbWndExtra;
     *     HINSTANCE hInstance;
     *     HICON hIcon;
     *     HCURSOR hCursor;
     *     HBRUSH hbrBackground;
     *     LPCSTR lpszMenuName;
     *     LPCSTR lpszClassName;
     * } *LPWNDCLASSA
     * }
     */
    public static final AddressLayout LPWNDCLASSA = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagWNDCLASSW {
     *     UINT style;
     *     WNDPROC lpfnWndProc;
     *     int cbClsExtra;
     *     int cbWndExtra;
     *     HINSTANCE hInstance;
     *     HICON hIcon;
     *     HCURSOR hCursor;
     *     HBRUSH hbrBackground;
     *     LPCWSTR lpszMenuName;
     *     LPCWSTR lpszClassName;
     * } *PWNDCLASSW
     * }
     */
    public static final AddressLayout PWNDCLASSW = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagWNDCLASSW {
     *     UINT style;
     *     WNDPROC lpfnWndProc;
     *     int cbClsExtra;
     *     int cbWndExtra;
     *     HINSTANCE hInstance;
     *     HICON hIcon;
     *     HCURSOR hCursor;
     *     HBRUSH hbrBackground;
     *     LPCWSTR lpszMenuName;
     *     LPCWSTR lpszClassName;
     * } *NPWNDCLASSW
     * }
     */
    public static final AddressLayout NPWNDCLASSW = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagWNDCLASSW {
     *     UINT style;
     *     WNDPROC lpfnWndProc;
     *     int cbClsExtra;
     *     int cbWndExtra;
     *     HINSTANCE hInstance;
     *     HICON hIcon;
     *     HCURSOR hCursor;
     *     HBRUSH hbrBackground;
     *     LPCWSTR lpszMenuName;
     *     LPCWSTR lpszClassName;
     * } *LPWNDCLASSW
     * }
     */
    public static final AddressLayout LPWNDCLASSW = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef PWNDCLASSA PWNDCLASS
     * }
     */
    public static final AddressLayout PWNDCLASS = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef NPWNDCLASSA NPWNDCLASS
     * }
     */
    public static final AddressLayout NPWNDCLASS = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef LPWNDCLASSA LPWNDCLASS
     * }
     */
    public static final AddressLayout LPWNDCLASS = C_POINTER;

    private static class IsHungAppWindow {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("IsHungAppWindow"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL IsHungAppWindow(HWND hwnd)
     * }
     */
    public static FunctionDescriptor IsHungAppWindow$descriptor() {
        return IsHungAppWindow.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL IsHungAppWindow(HWND hwnd)
     * }
     */
    public static MethodHandle IsHungAppWindow$handle() {
        return IsHungAppWindow.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL IsHungAppWindow(HWND hwnd)
     * }
     */
    public static int IsHungAppWindow(MemorySegment hwnd) {
        var mh$ = IsHungAppWindow.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("IsHungAppWindow", hwnd);
            }
            return (int)mh$.invokeExact(hwnd);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DisableProcessWindowsGhosting {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("DisableProcessWindowsGhosting"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void DisableProcessWindowsGhosting()
     * }
     */
    public static FunctionDescriptor DisableProcessWindowsGhosting$descriptor() {
        return DisableProcessWindowsGhosting.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void DisableProcessWindowsGhosting()
     * }
     */
    public static MethodHandle DisableProcessWindowsGhosting$handle() {
        return DisableProcessWindowsGhosting.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * void DisableProcessWindowsGhosting()
     * }
     */
    public static void DisableProcessWindowsGhosting() {
        var mh$ = DisableProcessWindowsGhosting.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DisableProcessWindowsGhosting");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct tagMSG {
     *     HWND hwnd;
     *     UINT message;
     *     WPARAM wParam;
     *     LPARAM lParam;
     *     DWORD time;
     *     POINT pt;
     * } *PMSG
     * }
     */
    public static final AddressLayout PMSG = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagMSG {
     *     HWND hwnd;
     *     UINT message;
     *     WPARAM wParam;
     *     LPARAM lParam;
     *     DWORD time;
     *     POINT pt;
     * } *NPMSG
     * }
     */
    public static final AddressLayout NPMSG = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagMSG {
     *     HWND hwnd;
     *     UINT message;
     *     WPARAM wParam;
     *     LPARAM lParam;
     *     DWORD time;
     *     POINT pt;
     * } *LPMSG
     * }
     */
    public static final AddressLayout LPMSG = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagMINMAXINFO {
     *     POINT ptReserved;
     *     POINT ptMaxSize;
     *     POINT ptMaxPosition;
     *     POINT ptMinTrackSize;
     *     POINT ptMaxTrackSize;
     * } *PMINMAXINFO
     * }
     */
    public static final AddressLayout PMINMAXINFO = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagMINMAXINFO {
     *     POINT ptReserved;
     *     POINT ptMaxSize;
     *     POINT ptMaxPosition;
     *     POINT ptMinTrackSize;
     *     POINT ptMaxTrackSize;
     * } *LPMINMAXINFO
     * }
     */
    public static final AddressLayout LPMINMAXINFO = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagCOPYDATASTRUCT {
     *     ULONG_PTR dwData;
     *     DWORD cbData;
     *     PVOID lpData;
     * } *PCOPYDATASTRUCT
     * }
     */
    public static final AddressLayout PCOPYDATASTRUCT = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagMDINEXTMENU {
     *     HMENU hmenuIn;
     *     HMENU hmenuNext;
     *     HWND hwndNext;
     * } *PMDINEXTMENU
     * }
     */
    public static final AddressLayout PMDINEXTMENU = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagMDINEXTMENU {
     *     HMENU hmenuIn;
     *     HMENU hmenuNext;
     *     HWND hwndNext;
     * } *LPMDINEXTMENU
     * }
     */
    public static final AddressLayout LPMDINEXTMENU = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct {
     *     GUID PowerSetting;
     *     DWORD DataLength;
     *     UCHAR Data[1];
     * } *PPOWERBROADCAST_SETTING
     * }
     */
    public static final AddressLayout PPOWERBROADCAST_SETTING = C_POINTER;

    private static class RegisterWindowMessageA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("RegisterWindowMessageA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * UINT RegisterWindowMessageA(LPCSTR lpString)
     * }
     */
    public static FunctionDescriptor RegisterWindowMessageA$descriptor() {
        return RegisterWindowMessageA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * UINT RegisterWindowMessageA(LPCSTR lpString)
     * }
     */
    public static MethodHandle RegisterWindowMessageA$handle() {
        return RegisterWindowMessageA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * UINT RegisterWindowMessageA(LPCSTR lpString)
     * }
     */
    public static int RegisterWindowMessageA(MemorySegment lpString) {
        var mh$ = RegisterWindowMessageA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RegisterWindowMessageA", lpString);
            }
            return (int)mh$.invokeExact(lpString);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RegisterWindowMessageW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("RegisterWindowMessageW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * UINT RegisterWindowMessageW(LPCWSTR lpString)
     * }
     */
    public static FunctionDescriptor RegisterWindowMessageW$descriptor() {
        return RegisterWindowMessageW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * UINT RegisterWindowMessageW(LPCWSTR lpString)
     * }
     */
    public static MethodHandle RegisterWindowMessageW$handle() {
        return RegisterWindowMessageW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * UINT RegisterWindowMessageW(LPCWSTR lpString)
     * }
     */
    public static int RegisterWindowMessageW(MemorySegment lpString) {
        var mh$ = RegisterWindowMessageW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RegisterWindowMessageW", lpString);
            }
            return (int)mh$.invokeExact(lpString);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct tagWINDOWPOS {
     *     HWND hwnd;
     *     HWND hwndInsertAfter;
     *     int x;
     *     int y;
     *     int cx;
     *     int cy;
     *     UINT flags;
     * } *LPWINDOWPOS
     * }
     */
    public static final AddressLayout LPWINDOWPOS = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagWINDOWPOS {
     *     HWND hwnd;
     *     HWND hwndInsertAfter;
     *     int x;
     *     int y;
     *     int cx;
     *     int cy;
     *     UINT flags;
     * } *PWINDOWPOS
     * }
     */
    public static final AddressLayout PWINDOWPOS = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagNCCALCSIZE_PARAMS {
     *     RECT rgrc[3];
     *     PWINDOWPOS lppos;
     * } *LPNCCALCSIZE_PARAMS
     * }
     */
    public static final AddressLayout LPNCCALCSIZE_PARAMS = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagTRACKMOUSEEVENT {
     *     DWORD cbSize;
     *     DWORD dwFlags;
     *     HWND hwndTrack;
     *     DWORD dwHoverTime;
     * } *LPTRACKMOUSEEVENT
     * }
     */
    public static final AddressLayout LPTRACKMOUSEEVENT = C_POINTER;

    private static class TrackMouseEvent {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("TrackMouseEvent"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL TrackMouseEvent(LPTRACKMOUSEEVENT lpEventTrack)
     * }
     */
    public static FunctionDescriptor TrackMouseEvent$descriptor() {
        return TrackMouseEvent.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL TrackMouseEvent(LPTRACKMOUSEEVENT lpEventTrack)
     * }
     */
    public static MethodHandle TrackMouseEvent$handle() {
        return TrackMouseEvent.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL TrackMouseEvent(LPTRACKMOUSEEVENT lpEventTrack)
     * }
     */
    public static int TrackMouseEvent(MemorySegment lpEventTrack) {
        var mh$ = TrackMouseEvent.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TrackMouseEvent", lpEventTrack);
            }
            return (int)mh$.invokeExact(lpEventTrack);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DrawEdge {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_INT,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("DrawEdge"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL DrawEdge(HDC hdc, LPRECT qrc, UINT edge, UINT grfFlags)
     * }
     */
    public static FunctionDescriptor DrawEdge$descriptor() {
        return DrawEdge.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL DrawEdge(HDC hdc, LPRECT qrc, UINT edge, UINT grfFlags)
     * }
     */
    public static MethodHandle DrawEdge$handle() {
        return DrawEdge.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL DrawEdge(HDC hdc, LPRECT qrc, UINT edge, UINT grfFlags)
     * }
     */
    public static int DrawEdge(MemorySegment hdc, MemorySegment qrc, int edge, int grfFlags) {
        var mh$ = DrawEdge.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DrawEdge", hdc, qrc, edge, grfFlags);
            }
            return (int)mh$.invokeExact(hdc, qrc, edge, grfFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DrawFrameControl {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_INT,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("DrawFrameControl"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL DrawFrameControl(HDC, LPRECT, UINT, UINT)
     * }
     */
    public static FunctionDescriptor DrawFrameControl$descriptor() {
        return DrawFrameControl.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL DrawFrameControl(HDC, LPRECT, UINT, UINT)
     * }
     */
    public static MethodHandle DrawFrameControl$handle() {
        return DrawFrameControl.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL DrawFrameControl(HDC, LPRECT, UINT, UINT)
     * }
     */
    public static int DrawFrameControl(MemorySegment x0, MemorySegment x1, int x2, int x3) {
        var mh$ = DrawFrameControl.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DrawFrameControl", x0, x1, x2, x3);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DrawCaption {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("DrawCaption"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL DrawCaption(HWND hwnd, HDC hdc, const RECT *lprect, UINT flags)
     * }
     */
    public static FunctionDescriptor DrawCaption$descriptor() {
        return DrawCaption.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL DrawCaption(HWND hwnd, HDC hdc, const RECT *lprect, UINT flags)
     * }
     */
    public static MethodHandle DrawCaption$handle() {
        return DrawCaption.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL DrawCaption(HWND hwnd, HDC hdc, const RECT *lprect, UINT flags)
     * }
     */
    public static int DrawCaption(MemorySegment hwnd, MemorySegment hdc, MemorySegment lprect, int flags) {
        var mh$ = DrawCaption.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DrawCaption", hwnd, hdc, lprect, flags);
            }
            return (int)mh$.invokeExact(hwnd, hdc, lprect, flags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DrawAnimatedRects {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_INT,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("DrawAnimatedRects"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL DrawAnimatedRects(HWND hwnd, int idAni, const RECT *lprcFrom, const RECT *lprcTo)
     * }
     */
    public static FunctionDescriptor DrawAnimatedRects$descriptor() {
        return DrawAnimatedRects.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL DrawAnimatedRects(HWND hwnd, int idAni, const RECT *lprcFrom, const RECT *lprcTo)
     * }
     */
    public static MethodHandle DrawAnimatedRects$handle() {
        return DrawAnimatedRects.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL DrawAnimatedRects(HWND hwnd, int idAni, const RECT *lprcFrom, const RECT *lprcTo)
     * }
     */
    public static int DrawAnimatedRects(MemorySegment hwnd, int idAni, MemorySegment lprcFrom, MemorySegment lprcTo) {
        var mh$ = DrawAnimatedRects.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DrawAnimatedRects", hwnd, idAni, lprcFrom, lprcTo);
            }
            return (int)mh$.invokeExact(hwnd, idAni, lprcFrom, lprcTo);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct tagACCEL {
     *     BYTE fVirt;
     *     WORD key;
     *     WORD cmd;
     * } *LPACCEL
     * }
     */
    public static final AddressLayout LPACCEL = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagPAINTSTRUCT {
     *     HDC hdc;
     *     BOOL fErase;
     *     RECT rcPaint;
     *     BOOL fRestore;
     *     BOOL fIncUpdate;
     *     BYTE rgbReserved[32];
     * } *PPAINTSTRUCT
     * }
     */
    public static final AddressLayout PPAINTSTRUCT = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagPAINTSTRUCT {
     *     HDC hdc;
     *     BOOL fErase;
     *     RECT rcPaint;
     *     BOOL fRestore;
     *     BOOL fIncUpdate;
     *     BYTE rgbReserved[32];
     * } *NPPAINTSTRUCT
     * }
     */
    public static final AddressLayout NPPAINTSTRUCT = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagPAINTSTRUCT {
     *     HDC hdc;
     *     BOOL fErase;
     *     RECT rcPaint;
     *     BOOL fRestore;
     *     BOOL fIncUpdate;
     *     BYTE rgbReserved[32];
     * } *LPPAINTSTRUCT
     * }
     */
    public static final AddressLayout LPPAINTSTRUCT = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagCREATESTRUCTA {
     *     LPVOID lpCreateParams;
     *     HINSTANCE hInstance;
     *     HMENU hMenu;
     *     HWND hwndParent;
     *     int cy;
     *     int cx;
     *     int y;
     *     int x;
     *     LONG style;
     *     LPCSTR lpszName;
     *     LPCSTR lpszClass;
     *     DWORD dwExStyle;
     * } *LPCREATESTRUCTA
     * }
     */
    public static final AddressLayout LPCREATESTRUCTA = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagCREATESTRUCTW {
     *     LPVOID lpCreateParams;
     *     HINSTANCE hInstance;
     *     HMENU hMenu;
     *     HWND hwndParent;
     *     int cy;
     *     int cx;
     *     int y;
     *     int x;
     *     LONG style;
     *     LPCWSTR lpszName;
     *     LPCWSTR lpszClass;
     *     DWORD dwExStyle;
     * } *LPCREATESTRUCTW
     * }
     */
    public static final AddressLayout LPCREATESTRUCTW = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef LPCREATESTRUCTA LPCREATESTRUCT
     * }
     */
    public static final AddressLayout LPCREATESTRUCT = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef WINDOWPLACEMENT *PWINDOWPLACEMENT
     * }
     */
    public static final AddressLayout PWINDOWPLACEMENT = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef WINDOWPLACEMENT *LPWINDOWPLACEMENT
     * }
     */
    public static final AddressLayout LPWINDOWPLACEMENT = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef NMHDR *LPNMHDR
     * }
     */
    public static final AddressLayout LPNMHDR = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagSTYLESTRUCT {
     *     DWORD styleOld;
     *     DWORD styleNew;
     * } *LPSTYLESTRUCT
     * }
     */
    public static final AddressLayout LPSTYLESTRUCT = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagMEASUREITEMSTRUCT {
     *     UINT CtlType;
     *     UINT CtlID;
     *     UINT itemID;
     *     UINT itemWidth;
     *     UINT itemHeight;
     *     ULONG_PTR itemData;
     * } *PMEASUREITEMSTRUCT
     * }
     */
    public static final AddressLayout PMEASUREITEMSTRUCT = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagMEASUREITEMSTRUCT {
     *     UINT CtlType;
     *     UINT CtlID;
     *     UINT itemID;
     *     UINT itemWidth;
     *     UINT itemHeight;
     *     ULONG_PTR itemData;
     * } *LPMEASUREITEMSTRUCT
     * }
     */
    public static final AddressLayout LPMEASUREITEMSTRUCT = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagDRAWITEMSTRUCT {
     *     UINT CtlType;
     *     UINT CtlID;
     *     UINT itemID;
     *     UINT itemAction;
     *     UINT itemState;
     *     HWND hwndItem;
     *     HDC hDC;
     *     RECT rcItem;
     *     ULONG_PTR itemData;
     * } *PDRAWITEMSTRUCT
     * }
     */
    public static final AddressLayout PDRAWITEMSTRUCT = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagDRAWITEMSTRUCT {
     *     UINT CtlType;
     *     UINT CtlID;
     *     UINT itemID;
     *     UINT itemAction;
     *     UINT itemState;
     *     HWND hwndItem;
     *     HDC hDC;
     *     RECT rcItem;
     *     ULONG_PTR itemData;
     * } *LPDRAWITEMSTRUCT
     * }
     */
    public static final AddressLayout LPDRAWITEMSTRUCT = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagDELETEITEMSTRUCT {
     *     UINT CtlType;
     *     UINT CtlID;
     *     UINT itemID;
     *     HWND hwndItem;
     *     ULONG_PTR itemData;
     * } *PDELETEITEMSTRUCT
     * }
     */
    public static final AddressLayout PDELETEITEMSTRUCT = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagDELETEITEMSTRUCT {
     *     UINT CtlType;
     *     UINT CtlID;
     *     UINT itemID;
     *     HWND hwndItem;
     *     ULONG_PTR itemData;
     * } *LPDELETEITEMSTRUCT
     * }
     */
    public static final AddressLayout LPDELETEITEMSTRUCT = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagCOMPAREITEMSTRUCT {
     *     UINT CtlType;
     *     UINT CtlID;
     *     HWND hwndItem;
     *     UINT itemID1;
     *     ULONG_PTR itemData1;
     *     UINT itemID2;
     *     ULONG_PTR itemData2;
     *     DWORD dwLocaleId;
     * } *PCOMPAREITEMSTRUCT
     * }
     */
    public static final AddressLayout PCOMPAREITEMSTRUCT = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagCOMPAREITEMSTRUCT {
     *     UINT CtlType;
     *     UINT CtlID;
     *     HWND hwndItem;
     *     UINT itemID1;
     *     ULONG_PTR itemData1;
     *     UINT itemID2;
     *     ULONG_PTR itemData2;
     *     DWORD dwLocaleId;
     * } *LPCOMPAREITEMSTRUCT
     * }
     */
    public static final AddressLayout LPCOMPAREITEMSTRUCT = C_POINTER;

    private static class GetMessageA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_INT,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetMessageA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetMessageA(LPMSG lpMsg, HWND hWnd, UINT wMsgFilterMin, UINT wMsgFilterMax)
     * }
     */
    public static FunctionDescriptor GetMessageA$descriptor() {
        return GetMessageA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetMessageA(LPMSG lpMsg, HWND hWnd, UINT wMsgFilterMin, UINT wMsgFilterMax)
     * }
     */
    public static MethodHandle GetMessageA$handle() {
        return GetMessageA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL GetMessageA(LPMSG lpMsg, HWND hWnd, UINT wMsgFilterMin, UINT wMsgFilterMax)
     * }
     */
    public static int GetMessageA(MemorySegment lpMsg, MemorySegment hWnd, int wMsgFilterMin, int wMsgFilterMax) {
        var mh$ = GetMessageA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetMessageA", lpMsg, hWnd, wMsgFilterMin, wMsgFilterMax);
            }
            return (int)mh$.invokeExact(lpMsg, hWnd, wMsgFilterMin, wMsgFilterMax);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetMessageW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_INT,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetMessageW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetMessageW(LPMSG lpMsg, HWND hWnd, UINT wMsgFilterMin, UINT wMsgFilterMax)
     * }
     */
    public static FunctionDescriptor GetMessageW$descriptor() {
        return GetMessageW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetMessageW(LPMSG lpMsg, HWND hWnd, UINT wMsgFilterMin, UINT wMsgFilterMax)
     * }
     */
    public static MethodHandle GetMessageW$handle() {
        return GetMessageW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL GetMessageW(LPMSG lpMsg, HWND hWnd, UINT wMsgFilterMin, UINT wMsgFilterMax)
     * }
     */
    public static int GetMessageW(MemorySegment lpMsg, MemorySegment hWnd, int wMsgFilterMin, int wMsgFilterMax) {
        var mh$ = GetMessageW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetMessageW", lpMsg, hWnd, wMsgFilterMin, wMsgFilterMax);
            }
            return (int)mh$.invokeExact(lpMsg, hWnd, wMsgFilterMin, wMsgFilterMax);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TranslateMessage {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("TranslateMessage"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL TranslateMessage(const MSG *lpMsg)
     * }
     */
    public static FunctionDescriptor TranslateMessage$descriptor() {
        return TranslateMessage.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL TranslateMessage(const MSG *lpMsg)
     * }
     */
    public static MethodHandle TranslateMessage$handle() {
        return TranslateMessage.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL TranslateMessage(const MSG *lpMsg)
     * }
     */
    public static int TranslateMessage(MemorySegment lpMsg) {
        var mh$ = TranslateMessage.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TranslateMessage", lpMsg);
            }
            return (int)mh$.invokeExact(lpMsg);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DispatchMessageA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG_LONG,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("DispatchMessageA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LRESULT DispatchMessageA(const MSG *lpMsg)
     * }
     */
    public static FunctionDescriptor DispatchMessageA$descriptor() {
        return DispatchMessageA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LRESULT DispatchMessageA(const MSG *lpMsg)
     * }
     */
    public static MethodHandle DispatchMessageA$handle() {
        return DispatchMessageA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * LRESULT DispatchMessageA(const MSG *lpMsg)
     * }
     */
    public static long DispatchMessageA(MemorySegment lpMsg) {
        var mh$ = DispatchMessageA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DispatchMessageA", lpMsg);
            }
            return (long)mh$.invokeExact(lpMsg);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DispatchMessageW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG_LONG,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("DispatchMessageW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LRESULT DispatchMessageW(const MSG *lpMsg)
     * }
     */
    public static FunctionDescriptor DispatchMessageW$descriptor() {
        return DispatchMessageW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LRESULT DispatchMessageW(const MSG *lpMsg)
     * }
     */
    public static MethodHandle DispatchMessageW$handle() {
        return DispatchMessageW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * LRESULT DispatchMessageW(const MSG *lpMsg)
     * }
     */
    public static long DispatchMessageW(MemorySegment lpMsg) {
        var mh$ = DispatchMessageW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DispatchMessageW", lpMsg);
            }
            return (long)mh$.invokeExact(lpMsg);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetMessageQueue {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("SetMessageQueue"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetMessageQueue(int cMessagesMax)
     * }
     */
    public static FunctionDescriptor SetMessageQueue$descriptor() {
        return SetMessageQueue.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetMessageQueue(int cMessagesMax)
     * }
     */
    public static MethodHandle SetMessageQueue$handle() {
        return SetMessageQueue.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL SetMessageQueue(int cMessagesMax)
     * }
     */
    public static int SetMessageQueue(int cMessagesMax) {
        var mh$ = SetMessageQueue.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetMessageQueue", cMessagesMax);
            }
            return (int)mh$.invokeExact(cMessagesMax);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PeekMessageA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_INT,
            C_INT,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("PeekMessageA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL PeekMessageA(LPMSG lpMsg, HWND hWnd, UINT wMsgFilterMin, UINT wMsgFilterMax, UINT wRemoveMsg)
     * }
     */
    public static FunctionDescriptor PeekMessageA$descriptor() {
        return PeekMessageA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL PeekMessageA(LPMSG lpMsg, HWND hWnd, UINT wMsgFilterMin, UINT wMsgFilterMax, UINT wRemoveMsg)
     * }
     */
    public static MethodHandle PeekMessageA$handle() {
        return PeekMessageA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL PeekMessageA(LPMSG lpMsg, HWND hWnd, UINT wMsgFilterMin, UINT wMsgFilterMax, UINT wRemoveMsg)
     * }
     */
    public static int PeekMessageA(MemorySegment lpMsg, MemorySegment hWnd, int wMsgFilterMin, int wMsgFilterMax, int wRemoveMsg) {
        var mh$ = PeekMessageA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PeekMessageA", lpMsg, hWnd, wMsgFilterMin, wMsgFilterMax, wRemoveMsg);
            }
            return (int)mh$.invokeExact(lpMsg, hWnd, wMsgFilterMin, wMsgFilterMax, wRemoveMsg);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PeekMessageW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_INT,
            C_INT,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("PeekMessageW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL PeekMessageW(LPMSG lpMsg, HWND hWnd, UINT wMsgFilterMin, UINT wMsgFilterMax, UINT wRemoveMsg)
     * }
     */
    public static FunctionDescriptor PeekMessageW$descriptor() {
        return PeekMessageW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL PeekMessageW(LPMSG lpMsg, HWND hWnd, UINT wMsgFilterMin, UINT wMsgFilterMax, UINT wRemoveMsg)
     * }
     */
    public static MethodHandle PeekMessageW$handle() {
        return PeekMessageW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL PeekMessageW(LPMSG lpMsg, HWND hWnd, UINT wMsgFilterMin, UINT wMsgFilterMax, UINT wRemoveMsg)
     * }
     */
    public static int PeekMessageW(MemorySegment lpMsg, MemorySegment hWnd, int wMsgFilterMin, int wMsgFilterMax, int wRemoveMsg) {
        var mh$ = PeekMessageW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PeekMessageW", lpMsg, hWnd, wMsgFilterMin, wMsgFilterMax, wRemoveMsg);
            }
            return (int)mh$.invokeExact(lpMsg, hWnd, wMsgFilterMin, wMsgFilterMax, wRemoveMsg);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RegisterHotKey {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_INT,
            C_INT,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("RegisterHotKey"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL RegisterHotKey(HWND hWnd, int id, UINT fsModifiers, UINT vk)
     * }
     */
    public static FunctionDescriptor RegisterHotKey$descriptor() {
        return RegisterHotKey.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL RegisterHotKey(HWND hWnd, int id, UINT fsModifiers, UINT vk)
     * }
     */
    public static MethodHandle RegisterHotKey$handle() {
        return RegisterHotKey.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL RegisterHotKey(HWND hWnd, int id, UINT fsModifiers, UINT vk)
     * }
     */
    public static int RegisterHotKey(MemorySegment hWnd, int id, int fsModifiers, int vk) {
        var mh$ = RegisterHotKey.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RegisterHotKey", hWnd, id, fsModifiers, vk);
            }
            return (int)mh$.invokeExact(hWnd, id, fsModifiers, vk);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class UnregisterHotKey {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("UnregisterHotKey"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL UnregisterHotKey(HWND hWnd, int id)
     * }
     */
    public static FunctionDescriptor UnregisterHotKey$descriptor() {
        return UnregisterHotKey.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL UnregisterHotKey(HWND hWnd, int id)
     * }
     */
    public static MethodHandle UnregisterHotKey$handle() {
        return UnregisterHotKey.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL UnregisterHotKey(HWND hWnd, int id)
     * }
     */
    public static int UnregisterHotKey(MemorySegment hWnd, int id) {
        var mh$ = UnregisterHotKey.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("UnregisterHotKey", hWnd, id);
            }
            return (int)mh$.invokeExact(hWnd, id);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ExitWindowsEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_INT,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("ExitWindowsEx"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL ExitWindowsEx(UINT uFlags, DWORD dwReason)
     * }
     */
    public static FunctionDescriptor ExitWindowsEx$descriptor() {
        return ExitWindowsEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL ExitWindowsEx(UINT uFlags, DWORD dwReason)
     * }
     */
    public static MethodHandle ExitWindowsEx$handle() {
        return ExitWindowsEx.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL ExitWindowsEx(UINT uFlags, DWORD dwReason)
     * }
     */
    public static int ExitWindowsEx(int uFlags, int dwReason) {
        var mh$ = ExitWindowsEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ExitWindowsEx", uFlags, dwReason);
            }
            return (int)mh$.invokeExact(uFlags, dwReason);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SwapMouseButton {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("SwapMouseButton"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SwapMouseButton(BOOL fSwap)
     * }
     */
    public static FunctionDescriptor SwapMouseButton$descriptor() {
        return SwapMouseButton.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SwapMouseButton(BOOL fSwap)
     * }
     */
    public static MethodHandle SwapMouseButton$handle() {
        return SwapMouseButton.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL SwapMouseButton(BOOL fSwap)
     * }
     */
    public static int SwapMouseButton(int fSwap) {
        var mh$ = SwapMouseButton.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SwapMouseButton", fSwap);
            }
            return (int)mh$.invokeExact(fSwap);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetMessagePos {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG    );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetMessagePos"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetMessagePos()
     * }
     */
    public static FunctionDescriptor GetMessagePos$descriptor() {
        return GetMessagePos.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetMessagePos()
     * }
     */
    public static MethodHandle GetMessagePos$handle() {
        return GetMessagePos.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * DWORD GetMessagePos()
     * }
     */
    public static int GetMessagePos() {
        var mh$ = GetMessagePos.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetMessagePos");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetMessageTime {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG    );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetMessageTime"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LONG GetMessageTime()
     * }
     */
    public static FunctionDescriptor GetMessageTime$descriptor() {
        return GetMessageTime.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LONG GetMessageTime()
     * }
     */
    public static MethodHandle GetMessageTime$handle() {
        return GetMessageTime.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * LONG GetMessageTime()
     * }
     */
    public static int GetMessageTime() {
        var mh$ = GetMessageTime.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetMessageTime");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetMessageExtraInfo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG_LONG    );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetMessageExtraInfo"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LPARAM GetMessageExtraInfo()
     * }
     */
    public static FunctionDescriptor GetMessageExtraInfo$descriptor() {
        return GetMessageExtraInfo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LPARAM GetMessageExtraInfo()
     * }
     */
    public static MethodHandle GetMessageExtraInfo$handle() {
        return GetMessageExtraInfo.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * LPARAM GetMessageExtraInfo()
     * }
     */
    public static long GetMessageExtraInfo() {
        var mh$ = GetMessageExtraInfo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetMessageExtraInfo");
            }
            return (long)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetUnpredictedMessagePos {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG    );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetUnpredictedMessagePos"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetUnpredictedMessagePos()
     * }
     */
    public static FunctionDescriptor GetUnpredictedMessagePos$descriptor() {
        return GetUnpredictedMessagePos.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetUnpredictedMessagePos()
     * }
     */
    public static MethodHandle GetUnpredictedMessagePos$handle() {
        return GetUnpredictedMessagePos.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * DWORD GetUnpredictedMessagePos()
     * }
     */
    public static int GetUnpredictedMessagePos() {
        var mh$ = GetUnpredictedMessagePos.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetUnpredictedMessagePos");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class IsWow64Message {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT    );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("IsWow64Message"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL IsWow64Message()
     * }
     */
    public static FunctionDescriptor IsWow64Message$descriptor() {
        return IsWow64Message.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL IsWow64Message()
     * }
     */
    public static MethodHandle IsWow64Message$handle() {
        return IsWow64Message.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL IsWow64Message()
     * }
     */
    public static int IsWow64Message() {
        var mh$ = IsWow64Message.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("IsWow64Message");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetMessageExtraInfo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG_LONG,
            C_LONG_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("SetMessageExtraInfo"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LPARAM SetMessageExtraInfo(LPARAM lParam)
     * }
     */
    public static FunctionDescriptor SetMessageExtraInfo$descriptor() {
        return SetMessageExtraInfo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LPARAM SetMessageExtraInfo(LPARAM lParam)
     * }
     */
    public static MethodHandle SetMessageExtraInfo$handle() {
        return SetMessageExtraInfo.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * LPARAM SetMessageExtraInfo(LPARAM lParam)
     * }
     */
    public static long SetMessageExtraInfo(long lParam) {
        var mh$ = SetMessageExtraInfo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetMessageExtraInfo", lParam);
            }
            return (long)mh$.invokeExact(lParam);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SendMessageA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG_LONG,
            C_POINTER,
            C_INT,
            C_LONG_LONG,
            C_LONG_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("SendMessageA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LRESULT SendMessageA(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam)
     * }
     */
    public static FunctionDescriptor SendMessageA$descriptor() {
        return SendMessageA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LRESULT SendMessageA(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam)
     * }
     */
    public static MethodHandle SendMessageA$handle() {
        return SendMessageA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * LRESULT SendMessageA(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam)
     * }
     */
    public static long SendMessageA(MemorySegment hWnd, int Msg, long wParam, long lParam) {
        var mh$ = SendMessageA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SendMessageA", hWnd, Msg, wParam, lParam);
            }
            return (long)mh$.invokeExact(hWnd, Msg, wParam, lParam);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SendMessageW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG_LONG,
            C_POINTER,
            C_INT,
            C_LONG_LONG,
            C_LONG_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("SendMessageW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LRESULT SendMessageW(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam)
     * }
     */
    public static FunctionDescriptor SendMessageW$descriptor() {
        return SendMessageW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LRESULT SendMessageW(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam)
     * }
     */
    public static MethodHandle SendMessageW$handle() {
        return SendMessageW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * LRESULT SendMessageW(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam)
     * }
     */
    public static long SendMessageW(MemorySegment hWnd, int Msg, long wParam, long lParam) {
        var mh$ = SendMessageW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SendMessageW", hWnd, Msg, wParam, lParam);
            }
            return (long)mh$.invokeExact(hWnd, Msg, wParam, lParam);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SendMessageTimeoutA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG_LONG,
            C_POINTER,
            C_INT,
            C_LONG_LONG,
            C_LONG_LONG,
            C_INT,
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("SendMessageTimeoutA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LRESULT SendMessageTimeoutA(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam, UINT fuFlags, UINT uTimeout, PDWORD_PTR lpdwResult)
     * }
     */
    public static FunctionDescriptor SendMessageTimeoutA$descriptor() {
        return SendMessageTimeoutA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LRESULT SendMessageTimeoutA(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam, UINT fuFlags, UINT uTimeout, PDWORD_PTR lpdwResult)
     * }
     */
    public static MethodHandle SendMessageTimeoutA$handle() {
        return SendMessageTimeoutA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * LRESULT SendMessageTimeoutA(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam, UINT fuFlags, UINT uTimeout, PDWORD_PTR lpdwResult)
     * }
     */
    public static long SendMessageTimeoutA(MemorySegment hWnd, int Msg, long wParam, long lParam, int fuFlags, int uTimeout, MemorySegment lpdwResult) {
        var mh$ = SendMessageTimeoutA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SendMessageTimeoutA", hWnd, Msg, wParam, lParam, fuFlags, uTimeout, lpdwResult);
            }
            return (long)mh$.invokeExact(hWnd, Msg, wParam, lParam, fuFlags, uTimeout, lpdwResult);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SendMessageTimeoutW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG_LONG,
            C_POINTER,
            C_INT,
            C_LONG_LONG,
            C_LONG_LONG,
            C_INT,
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("SendMessageTimeoutW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LRESULT SendMessageTimeoutW(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam, UINT fuFlags, UINT uTimeout, PDWORD_PTR lpdwResult)
     * }
     */
    public static FunctionDescriptor SendMessageTimeoutW$descriptor() {
        return SendMessageTimeoutW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LRESULT SendMessageTimeoutW(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam, UINT fuFlags, UINT uTimeout, PDWORD_PTR lpdwResult)
     * }
     */
    public static MethodHandle SendMessageTimeoutW$handle() {
        return SendMessageTimeoutW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * LRESULT SendMessageTimeoutW(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam, UINT fuFlags, UINT uTimeout, PDWORD_PTR lpdwResult)
     * }
     */
    public static long SendMessageTimeoutW(MemorySegment hWnd, int Msg, long wParam, long lParam, int fuFlags, int uTimeout, MemorySegment lpdwResult) {
        var mh$ = SendMessageTimeoutW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SendMessageTimeoutW", hWnd, Msg, wParam, lParam, fuFlags, uTimeout, lpdwResult);
            }
            return (long)mh$.invokeExact(hWnd, Msg, wParam, lParam, fuFlags, uTimeout, lpdwResult);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SendNotifyMessageA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_INT,
            C_LONG_LONG,
            C_LONG_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("SendNotifyMessageA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SendNotifyMessageA(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam)
     * }
     */
    public static FunctionDescriptor SendNotifyMessageA$descriptor() {
        return SendNotifyMessageA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SendNotifyMessageA(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam)
     * }
     */
    public static MethodHandle SendNotifyMessageA$handle() {
        return SendNotifyMessageA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL SendNotifyMessageA(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam)
     * }
     */
    public static int SendNotifyMessageA(MemorySegment hWnd, int Msg, long wParam, long lParam) {
        var mh$ = SendNotifyMessageA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SendNotifyMessageA", hWnd, Msg, wParam, lParam);
            }
            return (int)mh$.invokeExact(hWnd, Msg, wParam, lParam);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SendNotifyMessageW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_INT,
            C_LONG_LONG,
            C_LONG_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("SendNotifyMessageW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SendNotifyMessageW(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam)
     * }
     */
    public static FunctionDescriptor SendNotifyMessageW$descriptor() {
        return SendNotifyMessageW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SendNotifyMessageW(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam)
     * }
     */
    public static MethodHandle SendNotifyMessageW$handle() {
        return SendNotifyMessageW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL SendNotifyMessageW(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam)
     * }
     */
    public static int SendNotifyMessageW(MemorySegment hWnd, int Msg, long wParam, long lParam) {
        var mh$ = SendNotifyMessageW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SendNotifyMessageW", hWnd, Msg, wParam, lParam);
            }
            return (int)mh$.invokeExact(hWnd, Msg, wParam, lParam);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SendMessageCallbackA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_INT,
            C_LONG_LONG,
            C_LONG_LONG,
            C_POINTER,
            C_LONG_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("SendMessageCallbackA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SendMessageCallbackA(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam, SENDASYNCPROC lpResultCallBack, ULONG_PTR dwData)
     * }
     */
    public static FunctionDescriptor SendMessageCallbackA$descriptor() {
        return SendMessageCallbackA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SendMessageCallbackA(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam, SENDASYNCPROC lpResultCallBack, ULONG_PTR dwData)
     * }
     */
    public static MethodHandle SendMessageCallbackA$handle() {
        return SendMessageCallbackA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL SendMessageCallbackA(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam, SENDASYNCPROC lpResultCallBack, ULONG_PTR dwData)
     * }
     */
    public static int SendMessageCallbackA(MemorySegment hWnd, int Msg, long wParam, long lParam, MemorySegment lpResultCallBack, long dwData) {
        var mh$ = SendMessageCallbackA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SendMessageCallbackA", hWnd, Msg, wParam, lParam, lpResultCallBack, dwData);
            }
            return (int)mh$.invokeExact(hWnd, Msg, wParam, lParam, lpResultCallBack, dwData);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SendMessageCallbackW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_INT,
            C_LONG_LONG,
            C_LONG_LONG,
            C_POINTER,
            C_LONG_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("SendMessageCallbackW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SendMessageCallbackW(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam, SENDASYNCPROC lpResultCallBack, ULONG_PTR dwData)
     * }
     */
    public static FunctionDescriptor SendMessageCallbackW$descriptor() {
        return SendMessageCallbackW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SendMessageCallbackW(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam, SENDASYNCPROC lpResultCallBack, ULONG_PTR dwData)
     * }
     */
    public static MethodHandle SendMessageCallbackW$handle() {
        return SendMessageCallbackW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL SendMessageCallbackW(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam, SENDASYNCPROC lpResultCallBack, ULONG_PTR dwData)
     * }
     */
    public static int SendMessageCallbackW(MemorySegment hWnd, int Msg, long wParam, long lParam, MemorySegment lpResultCallBack, long dwData) {
        var mh$ = SendMessageCallbackW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SendMessageCallbackW", hWnd, Msg, wParam, lParam, lpResultCallBack, dwData);
            }
            return (int)mh$.invokeExact(hWnd, Msg, wParam, lParam, lpResultCallBack, dwData);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct {
     *     UINT cbSize;
     *     HDESK hdesk;
     *     HWND hwnd;
     *     LUID luid;
     * } *PBSMINFO
     * }
     */
    public static final AddressLayout PBSMINFO = C_POINTER;

    private static class BroadcastSystemMessageExA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_LONG,
            C_POINTER,
            C_INT,
            C_LONG_LONG,
            C_LONG_LONG,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("BroadcastSystemMessageExA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long BroadcastSystemMessageExA(DWORD flags, LPDWORD lpInfo, UINT Msg, WPARAM wParam, LPARAM lParam, PBSMINFO pbsmInfo)
     * }
     */
    public static FunctionDescriptor BroadcastSystemMessageExA$descriptor() {
        return BroadcastSystemMessageExA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long BroadcastSystemMessageExA(DWORD flags, LPDWORD lpInfo, UINT Msg, WPARAM wParam, LPARAM lParam, PBSMINFO pbsmInfo)
     * }
     */
    public static MethodHandle BroadcastSystemMessageExA$handle() {
        return BroadcastSystemMessageExA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * long BroadcastSystemMessageExA(DWORD flags, LPDWORD lpInfo, UINT Msg, WPARAM wParam, LPARAM lParam, PBSMINFO pbsmInfo)
     * }
     */
    public static int BroadcastSystemMessageExA(int flags, MemorySegment lpInfo, int Msg, long wParam, long lParam, MemorySegment pbsmInfo) {
        var mh$ = BroadcastSystemMessageExA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("BroadcastSystemMessageExA", flags, lpInfo, Msg, wParam, lParam, pbsmInfo);
            }
            return (int)mh$.invokeExact(flags, lpInfo, Msg, wParam, lParam, pbsmInfo);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class BroadcastSystemMessageExW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_LONG,
            C_POINTER,
            C_INT,
            C_LONG_LONG,
            C_LONG_LONG,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("BroadcastSystemMessageExW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long BroadcastSystemMessageExW(DWORD flags, LPDWORD lpInfo, UINT Msg, WPARAM wParam, LPARAM lParam, PBSMINFO pbsmInfo)
     * }
     */
    public static FunctionDescriptor BroadcastSystemMessageExW$descriptor() {
        return BroadcastSystemMessageExW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long BroadcastSystemMessageExW(DWORD flags, LPDWORD lpInfo, UINT Msg, WPARAM wParam, LPARAM lParam, PBSMINFO pbsmInfo)
     * }
     */
    public static MethodHandle BroadcastSystemMessageExW$handle() {
        return BroadcastSystemMessageExW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * long BroadcastSystemMessageExW(DWORD flags, LPDWORD lpInfo, UINT Msg, WPARAM wParam, LPARAM lParam, PBSMINFO pbsmInfo)
     * }
     */
    public static int BroadcastSystemMessageExW(int flags, MemorySegment lpInfo, int Msg, long wParam, long lParam, MemorySegment pbsmInfo) {
        var mh$ = BroadcastSystemMessageExW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("BroadcastSystemMessageExW", flags, lpInfo, Msg, wParam, lParam, pbsmInfo);
            }
            return (int)mh$.invokeExact(flags, lpInfo, Msg, wParam, lParam, pbsmInfo);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class BroadcastSystemMessageA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_LONG,
            C_POINTER,
            C_INT,
            C_LONG_LONG,
            C_LONG_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("BroadcastSystemMessageA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long BroadcastSystemMessageA(DWORD flags, LPDWORD lpInfo, UINT Msg, WPARAM wParam, LPARAM lParam)
     * }
     */
    public static FunctionDescriptor BroadcastSystemMessageA$descriptor() {
        return BroadcastSystemMessageA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long BroadcastSystemMessageA(DWORD flags, LPDWORD lpInfo, UINT Msg, WPARAM wParam, LPARAM lParam)
     * }
     */
    public static MethodHandle BroadcastSystemMessageA$handle() {
        return BroadcastSystemMessageA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * long BroadcastSystemMessageA(DWORD flags, LPDWORD lpInfo, UINT Msg, WPARAM wParam, LPARAM lParam)
     * }
     */
    public static int BroadcastSystemMessageA(int flags, MemorySegment lpInfo, int Msg, long wParam, long lParam) {
        var mh$ = BroadcastSystemMessageA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("BroadcastSystemMessageA", flags, lpInfo, Msg, wParam, lParam);
            }
            return (int)mh$.invokeExact(flags, lpInfo, Msg, wParam, lParam);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class BroadcastSystemMessageW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_LONG,
            C_POINTER,
            C_INT,
            C_LONG_LONG,
            C_LONG_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("BroadcastSystemMessageW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long BroadcastSystemMessageW(DWORD flags, LPDWORD lpInfo, UINT Msg, WPARAM wParam, LPARAM lParam)
     * }
     */
    public static FunctionDescriptor BroadcastSystemMessageW$descriptor() {
        return BroadcastSystemMessageW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long BroadcastSystemMessageW(DWORD flags, LPDWORD lpInfo, UINT Msg, WPARAM wParam, LPARAM lParam)
     * }
     */
    public static MethodHandle BroadcastSystemMessageW$handle() {
        return BroadcastSystemMessageW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * long BroadcastSystemMessageW(DWORD flags, LPDWORD lpInfo, UINT Msg, WPARAM wParam, LPARAM lParam)
     * }
     */
    public static int BroadcastSystemMessageW(int flags, MemorySegment lpInfo, int Msg, long wParam, long lParam) {
        var mh$ = BroadcastSystemMessageW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("BroadcastSystemMessageW", flags, lpInfo, Msg, wParam, lParam);
            }
            return (int)mh$.invokeExact(flags, lpInfo, Msg, wParam, lParam);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef PVOID HDEVNOTIFY
     * }
     */
    public static final AddressLayout HDEVNOTIFY = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef HDEVNOTIFY *PHDEVNOTIFY
     * }
     */
    public static final AddressLayout PHDEVNOTIFY = C_POINTER;

    private static class RegisterDeviceNotificationA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("RegisterDeviceNotificationA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HDEVNOTIFY RegisterDeviceNotificationA(HANDLE hRecipient, LPVOID NotificationFilter, DWORD Flags)
     * }
     */
    public static FunctionDescriptor RegisterDeviceNotificationA$descriptor() {
        return RegisterDeviceNotificationA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HDEVNOTIFY RegisterDeviceNotificationA(HANDLE hRecipient, LPVOID NotificationFilter, DWORD Flags)
     * }
     */
    public static MethodHandle RegisterDeviceNotificationA$handle() {
        return RegisterDeviceNotificationA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * HDEVNOTIFY RegisterDeviceNotificationA(HANDLE hRecipient, LPVOID NotificationFilter, DWORD Flags)
     * }
     */
    public static MemorySegment RegisterDeviceNotificationA(MemorySegment hRecipient, MemorySegment NotificationFilter, int Flags) {
        var mh$ = RegisterDeviceNotificationA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RegisterDeviceNotificationA", hRecipient, NotificationFilter, Flags);
            }
            return (MemorySegment)mh$.invokeExact(hRecipient, NotificationFilter, Flags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RegisterDeviceNotificationW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("RegisterDeviceNotificationW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HDEVNOTIFY RegisterDeviceNotificationW(HANDLE hRecipient, LPVOID NotificationFilter, DWORD Flags)
     * }
     */
    public static FunctionDescriptor RegisterDeviceNotificationW$descriptor() {
        return RegisterDeviceNotificationW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HDEVNOTIFY RegisterDeviceNotificationW(HANDLE hRecipient, LPVOID NotificationFilter, DWORD Flags)
     * }
     */
    public static MethodHandle RegisterDeviceNotificationW$handle() {
        return RegisterDeviceNotificationW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * HDEVNOTIFY RegisterDeviceNotificationW(HANDLE hRecipient, LPVOID NotificationFilter, DWORD Flags)
     * }
     */
    public static MemorySegment RegisterDeviceNotificationW(MemorySegment hRecipient, MemorySegment NotificationFilter, int Flags) {
        var mh$ = RegisterDeviceNotificationW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RegisterDeviceNotificationW", hRecipient, NotificationFilter, Flags);
            }
            return (MemorySegment)mh$.invokeExact(hRecipient, NotificationFilter, Flags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class UnregisterDeviceNotification {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("UnregisterDeviceNotification"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL UnregisterDeviceNotification(HDEVNOTIFY Handle)
     * }
     */
    public static FunctionDescriptor UnregisterDeviceNotification$descriptor() {
        return UnregisterDeviceNotification.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL UnregisterDeviceNotification(HDEVNOTIFY Handle)
     * }
     */
    public static MethodHandle UnregisterDeviceNotification$handle() {
        return UnregisterDeviceNotification.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL UnregisterDeviceNotification(HDEVNOTIFY Handle)
     * }
     */
    public static int UnregisterDeviceNotification(MemorySegment Handle) {
        var mh$ = UnregisterDeviceNotification.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("UnregisterDeviceNotification", Handle);
            }
            return (int)mh$.invokeExact(Handle);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef PVOID HPOWERNOTIFY
     * }
     */
    public static final AddressLayout HPOWERNOTIFY = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef HPOWERNOTIFY *PHPOWERNOTIFY
     * }
     */
    public static final AddressLayout PHPOWERNOTIFY = C_POINTER;

    private static class RegisterPowerSettingNotification {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("RegisterPowerSettingNotification"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HPOWERNOTIFY RegisterPowerSettingNotification(HANDLE hRecipient, LPCGUID PowerSettingGuid, DWORD Flags)
     * }
     */
    public static FunctionDescriptor RegisterPowerSettingNotification$descriptor() {
        return RegisterPowerSettingNotification.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HPOWERNOTIFY RegisterPowerSettingNotification(HANDLE hRecipient, LPCGUID PowerSettingGuid, DWORD Flags)
     * }
     */
    public static MethodHandle RegisterPowerSettingNotification$handle() {
        return RegisterPowerSettingNotification.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * HPOWERNOTIFY RegisterPowerSettingNotification(HANDLE hRecipient, LPCGUID PowerSettingGuid, DWORD Flags)
     * }
     */
    public static MemorySegment RegisterPowerSettingNotification(MemorySegment hRecipient, MemorySegment PowerSettingGuid, int Flags) {
        var mh$ = RegisterPowerSettingNotification.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RegisterPowerSettingNotification", hRecipient, PowerSettingGuid, Flags);
            }
            return (MemorySegment)mh$.invokeExact(hRecipient, PowerSettingGuid, Flags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class UnregisterPowerSettingNotification {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("UnregisterPowerSettingNotification"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL UnregisterPowerSettingNotification(HPOWERNOTIFY Handle)
     * }
     */
    public static FunctionDescriptor UnregisterPowerSettingNotification$descriptor() {
        return UnregisterPowerSettingNotification.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL UnregisterPowerSettingNotification(HPOWERNOTIFY Handle)
     * }
     */
    public static MethodHandle UnregisterPowerSettingNotification$handle() {
        return UnregisterPowerSettingNotification.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL UnregisterPowerSettingNotification(HPOWERNOTIFY Handle)
     * }
     */
    public static int UnregisterPowerSettingNotification(MemorySegment Handle) {
        var mh$ = UnregisterPowerSettingNotification.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("UnregisterPowerSettingNotification", Handle);
            }
            return (int)mh$.invokeExact(Handle);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RegisterSuspendResumeNotification {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("RegisterSuspendResumeNotification"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HPOWERNOTIFY RegisterSuspendResumeNotification(HANDLE hRecipient, DWORD Flags)
     * }
     */
    public static FunctionDescriptor RegisterSuspendResumeNotification$descriptor() {
        return RegisterSuspendResumeNotification.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HPOWERNOTIFY RegisterSuspendResumeNotification(HANDLE hRecipient, DWORD Flags)
     * }
     */
    public static MethodHandle RegisterSuspendResumeNotification$handle() {
        return RegisterSuspendResumeNotification.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * HPOWERNOTIFY RegisterSuspendResumeNotification(HANDLE hRecipient, DWORD Flags)
     * }
     */
    public static MemorySegment RegisterSuspendResumeNotification(MemorySegment hRecipient, int Flags) {
        var mh$ = RegisterSuspendResumeNotification.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RegisterSuspendResumeNotification", hRecipient, Flags);
            }
            return (MemorySegment)mh$.invokeExact(hRecipient, Flags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class UnregisterSuspendResumeNotification {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("UnregisterSuspendResumeNotification"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL UnregisterSuspendResumeNotification(HPOWERNOTIFY Handle)
     * }
     */
    public static FunctionDescriptor UnregisterSuspendResumeNotification$descriptor() {
        return UnregisterSuspendResumeNotification.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL UnregisterSuspendResumeNotification(HPOWERNOTIFY Handle)
     * }
     */
    public static MethodHandle UnregisterSuspendResumeNotification$handle() {
        return UnregisterSuspendResumeNotification.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL UnregisterSuspendResumeNotification(HPOWERNOTIFY Handle)
     * }
     */
    public static int UnregisterSuspendResumeNotification(MemorySegment Handle) {
        var mh$ = UnregisterSuspendResumeNotification.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("UnregisterSuspendResumeNotification", Handle);
            }
            return (int)mh$.invokeExact(Handle);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PostMessageA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_INT,
            C_LONG_LONG,
            C_LONG_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("PostMessageA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL PostMessageA(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam)
     * }
     */
    public static FunctionDescriptor PostMessageA$descriptor() {
        return PostMessageA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL PostMessageA(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam)
     * }
     */
    public static MethodHandle PostMessageA$handle() {
        return PostMessageA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL PostMessageA(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam)
     * }
     */
    public static int PostMessageA(MemorySegment hWnd, int Msg, long wParam, long lParam) {
        var mh$ = PostMessageA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PostMessageA", hWnd, Msg, wParam, lParam);
            }
            return (int)mh$.invokeExact(hWnd, Msg, wParam, lParam);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PostMessageW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_INT,
            C_LONG_LONG,
            C_LONG_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("PostMessageW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL PostMessageW(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam)
     * }
     */
    public static FunctionDescriptor PostMessageW$descriptor() {
        return PostMessageW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL PostMessageW(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam)
     * }
     */
    public static MethodHandle PostMessageW$handle() {
        return PostMessageW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL PostMessageW(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam)
     * }
     */
    public static int PostMessageW(MemorySegment hWnd, int Msg, long wParam, long lParam) {
        var mh$ = PostMessageW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PostMessageW", hWnd, Msg, wParam, lParam);
            }
            return (int)mh$.invokeExact(hWnd, Msg, wParam, lParam);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PostThreadMessageA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_LONG,
            C_INT,
            C_LONG_LONG,
            C_LONG_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("PostThreadMessageA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL PostThreadMessageA(DWORD idThread, UINT Msg, WPARAM wParam, LPARAM lParam)
     * }
     */
    public static FunctionDescriptor PostThreadMessageA$descriptor() {
        return PostThreadMessageA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL PostThreadMessageA(DWORD idThread, UINT Msg, WPARAM wParam, LPARAM lParam)
     * }
     */
    public static MethodHandle PostThreadMessageA$handle() {
        return PostThreadMessageA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL PostThreadMessageA(DWORD idThread, UINT Msg, WPARAM wParam, LPARAM lParam)
     * }
     */
    public static int PostThreadMessageA(int idThread, int Msg, long wParam, long lParam) {
        var mh$ = PostThreadMessageA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PostThreadMessageA", idThread, Msg, wParam, lParam);
            }
            return (int)mh$.invokeExact(idThread, Msg, wParam, lParam);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PostThreadMessageW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_LONG,
            C_INT,
            C_LONG_LONG,
            C_LONG_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("PostThreadMessageW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL PostThreadMessageW(DWORD idThread, UINT Msg, WPARAM wParam, LPARAM lParam)
     * }
     */
    public static FunctionDescriptor PostThreadMessageW$descriptor() {
        return PostThreadMessageW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL PostThreadMessageW(DWORD idThread, UINT Msg, WPARAM wParam, LPARAM lParam)
     * }
     */
    public static MethodHandle PostThreadMessageW$handle() {
        return PostThreadMessageW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL PostThreadMessageW(DWORD idThread, UINT Msg, WPARAM wParam, LPARAM lParam)
     * }
     */
    public static int PostThreadMessageW(int idThread, int Msg, long wParam, long lParam) {
        var mh$ = PostThreadMessageW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PostThreadMessageW", idThread, Msg, wParam, lParam);
            }
            return (int)mh$.invokeExact(idThread, Msg, wParam, lParam);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class AttachThreadInput {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_LONG,
            C_LONG,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("AttachThreadInput"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL AttachThreadInput(DWORD idAttach, DWORD idAttachTo, BOOL fAttach)
     * }
     */
    public static FunctionDescriptor AttachThreadInput$descriptor() {
        return AttachThreadInput.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL AttachThreadInput(DWORD idAttach, DWORD idAttachTo, BOOL fAttach)
     * }
     */
    public static MethodHandle AttachThreadInput$handle() {
        return AttachThreadInput.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL AttachThreadInput(DWORD idAttach, DWORD idAttachTo, BOOL fAttach)
     * }
     */
    public static int AttachThreadInput(int idAttach, int idAttachTo, int fAttach) {
        var mh$ = AttachThreadInput.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("AttachThreadInput", idAttach, idAttachTo, fAttach);
            }
            return (int)mh$.invokeExact(idAttach, idAttachTo, fAttach);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ReplyMessage {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_LONG_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("ReplyMessage"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL ReplyMessage(LRESULT lResult)
     * }
     */
    public static FunctionDescriptor ReplyMessage$descriptor() {
        return ReplyMessage.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL ReplyMessage(LRESULT lResult)
     * }
     */
    public static MethodHandle ReplyMessage$handle() {
        return ReplyMessage.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL ReplyMessage(LRESULT lResult)
     * }
     */
    public static int ReplyMessage(long lResult) {
        var mh$ = ReplyMessage.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ReplyMessage", lResult);
            }
            return (int)mh$.invokeExact(lResult);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class WaitMessage {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT    );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("WaitMessage"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL WaitMessage()
     * }
     */
    public static FunctionDescriptor WaitMessage$descriptor() {
        return WaitMessage.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL WaitMessage()
     * }
     */
    public static MethodHandle WaitMessage$handle() {
        return WaitMessage.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL WaitMessage()
     * }
     */
    public static int WaitMessage() {
        var mh$ = WaitMessage.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WaitMessage");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class WaitForInputIdle {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_POINTER,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("WaitForInputIdle"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD WaitForInputIdle(HANDLE hProcess, DWORD dwMilliseconds)
     * }
     */
    public static FunctionDescriptor WaitForInputIdle$descriptor() {
        return WaitForInputIdle.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD WaitForInputIdle(HANDLE hProcess, DWORD dwMilliseconds)
     * }
     */
    public static MethodHandle WaitForInputIdle$handle() {
        return WaitForInputIdle.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * DWORD WaitForInputIdle(HANDLE hProcess, DWORD dwMilliseconds)
     * }
     */
    public static int WaitForInputIdle(MemorySegment hProcess, int dwMilliseconds) {
        var mh$ = WaitForInputIdle.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WaitForInputIdle", hProcess, dwMilliseconds);
            }
            return (int)mh$.invokeExact(hProcess, dwMilliseconds);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DefWindowProcA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG_LONG,
            C_POINTER,
            C_INT,
            C_LONG_LONG,
            C_LONG_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("DefWindowProcA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LRESULT DefWindowProcA(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam)
     * }
     */
    public static FunctionDescriptor DefWindowProcA$descriptor() {
        return DefWindowProcA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LRESULT DefWindowProcA(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam)
     * }
     */
    public static MethodHandle DefWindowProcA$handle() {
        return DefWindowProcA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * LRESULT DefWindowProcA(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam)
     * }
     */
    public static long DefWindowProcA(MemorySegment hWnd, int Msg, long wParam, long lParam) {
        var mh$ = DefWindowProcA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DefWindowProcA", hWnd, Msg, wParam, lParam);
            }
            return (long)mh$.invokeExact(hWnd, Msg, wParam, lParam);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DefWindowProcW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG_LONG,
            C_POINTER,
            C_INT,
            C_LONG_LONG,
            C_LONG_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("DefWindowProcW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LRESULT DefWindowProcW(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam)
     * }
     */
    public static FunctionDescriptor DefWindowProcW$descriptor() {
        return DefWindowProcW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LRESULT DefWindowProcW(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam)
     * }
     */
    public static MethodHandle DefWindowProcW$handle() {
        return DefWindowProcW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * LRESULT DefWindowProcW(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam)
     * }
     */
    public static long DefWindowProcW(MemorySegment hWnd, int Msg, long wParam, long lParam) {
        var mh$ = DefWindowProcW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DefWindowProcW", hWnd, Msg, wParam, lParam);
            }
            return (long)mh$.invokeExact(hWnd, Msg, wParam, lParam);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PostQuitMessage {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("PostQuitMessage"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void PostQuitMessage(int nExitCode)
     * }
     */
    public static FunctionDescriptor PostQuitMessage$descriptor() {
        return PostQuitMessage.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void PostQuitMessage(int nExitCode)
     * }
     */
    public static MethodHandle PostQuitMessage$handle() {
        return PostQuitMessage.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * void PostQuitMessage(int nExitCode)
     * }
     */
    public static void PostQuitMessage(int nExitCode) {
        var mh$ = PostQuitMessage.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PostQuitMessage", nExitCode);
            }
            mh$.invokeExact(nExitCode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CallWindowProcA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG_LONG,
            C_POINTER,
            C_POINTER,
            C_INT,
            C_LONG_LONG,
            C_LONG_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CallWindowProcA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LRESULT CallWindowProcA(WNDPROC lpPrevWndFunc, HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam)
     * }
     */
    public static FunctionDescriptor CallWindowProcA$descriptor() {
        return CallWindowProcA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LRESULT CallWindowProcA(WNDPROC lpPrevWndFunc, HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam)
     * }
     */
    public static MethodHandle CallWindowProcA$handle() {
        return CallWindowProcA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * LRESULT CallWindowProcA(WNDPROC lpPrevWndFunc, HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam)
     * }
     */
    public static long CallWindowProcA(MemorySegment lpPrevWndFunc, MemorySegment hWnd, int Msg, long wParam, long lParam) {
        var mh$ = CallWindowProcA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CallWindowProcA", lpPrevWndFunc, hWnd, Msg, wParam, lParam);
            }
            return (long)mh$.invokeExact(lpPrevWndFunc, hWnd, Msg, wParam, lParam);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CallWindowProcW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG_LONG,
            C_POINTER,
            C_POINTER,
            C_INT,
            C_LONG_LONG,
            C_LONG_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CallWindowProcW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LRESULT CallWindowProcW(WNDPROC lpPrevWndFunc, HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam)
     * }
     */
    public static FunctionDescriptor CallWindowProcW$descriptor() {
        return CallWindowProcW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LRESULT CallWindowProcW(WNDPROC lpPrevWndFunc, HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam)
     * }
     */
    public static MethodHandle CallWindowProcW$handle() {
        return CallWindowProcW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * LRESULT CallWindowProcW(WNDPROC lpPrevWndFunc, HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam)
     * }
     */
    public static long CallWindowProcW(MemorySegment lpPrevWndFunc, MemorySegment hWnd, int Msg, long wParam, long lParam) {
        var mh$ = CallWindowProcW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CallWindowProcW", lpPrevWndFunc, hWnd, Msg, wParam, lParam);
            }
            return (long)mh$.invokeExact(lpPrevWndFunc, hWnd, Msg, wParam, lParam);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class InSendMessage {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT    );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("InSendMessage"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL InSendMessage()
     * }
     */
    public static FunctionDescriptor InSendMessage$descriptor() {
        return InSendMessage.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL InSendMessage()
     * }
     */
    public static MethodHandle InSendMessage$handle() {
        return InSendMessage.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL InSendMessage()
     * }
     */
    public static int InSendMessage() {
        var mh$ = InSendMessage.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("InSendMessage");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class InSendMessageEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("InSendMessageEx"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD InSendMessageEx(LPVOID lpReserved)
     * }
     */
    public static FunctionDescriptor InSendMessageEx$descriptor() {
        return InSendMessageEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD InSendMessageEx(LPVOID lpReserved)
     * }
     */
    public static MethodHandle InSendMessageEx$handle() {
        return InSendMessageEx.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * DWORD InSendMessageEx(LPVOID lpReserved)
     * }
     */
    public static int InSendMessageEx(MemorySegment lpReserved) {
        var mh$ = InSendMessageEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("InSendMessageEx", lpReserved);
            }
            return (int)mh$.invokeExact(lpReserved);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetDoubleClickTime {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT    );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetDoubleClickTime"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * UINT GetDoubleClickTime()
     * }
     */
    public static FunctionDescriptor GetDoubleClickTime$descriptor() {
        return GetDoubleClickTime.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * UINT GetDoubleClickTime()
     * }
     */
    public static MethodHandle GetDoubleClickTime$handle() {
        return GetDoubleClickTime.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * UINT GetDoubleClickTime()
     * }
     */
    public static int GetDoubleClickTime() {
        var mh$ = GetDoubleClickTime.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetDoubleClickTime");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetDoubleClickTime {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("SetDoubleClickTime"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetDoubleClickTime(UINT)
     * }
     */
    public static FunctionDescriptor SetDoubleClickTime$descriptor() {
        return SetDoubleClickTime.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetDoubleClickTime(UINT)
     * }
     */
    public static MethodHandle SetDoubleClickTime$handle() {
        return SetDoubleClickTime.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL SetDoubleClickTime(UINT)
     * }
     */
    public static int SetDoubleClickTime(int x0) {
        var mh$ = SetDoubleClickTime.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetDoubleClickTime", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RegisterClassA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_SHORT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("RegisterClassA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ATOM RegisterClassA(const WNDCLASSA *lpWndClass)
     * }
     */
    public static FunctionDescriptor RegisterClassA$descriptor() {
        return RegisterClassA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ATOM RegisterClassA(const WNDCLASSA *lpWndClass)
     * }
     */
    public static MethodHandle RegisterClassA$handle() {
        return RegisterClassA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * ATOM RegisterClassA(const WNDCLASSA *lpWndClass)
     * }
     */
    public static short RegisterClassA(MemorySegment lpWndClass) {
        var mh$ = RegisterClassA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RegisterClassA", lpWndClass);
            }
            return (short)mh$.invokeExact(lpWndClass);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RegisterClassW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_SHORT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("RegisterClassW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ATOM RegisterClassW(const WNDCLASSW *lpWndClass)
     * }
     */
    public static FunctionDescriptor RegisterClassW$descriptor() {
        return RegisterClassW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ATOM RegisterClassW(const WNDCLASSW *lpWndClass)
     * }
     */
    public static MethodHandle RegisterClassW$handle() {
        return RegisterClassW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * ATOM RegisterClassW(const WNDCLASSW *lpWndClass)
     * }
     */
    public static short RegisterClassW(MemorySegment lpWndClass) {
        var mh$ = RegisterClassW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RegisterClassW", lpWndClass);
            }
            return (short)mh$.invokeExact(lpWndClass);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class UnregisterClassA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("UnregisterClassA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL UnregisterClassA(LPCSTR lpClassName, HINSTANCE hInstance)
     * }
     */
    public static FunctionDescriptor UnregisterClassA$descriptor() {
        return UnregisterClassA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL UnregisterClassA(LPCSTR lpClassName, HINSTANCE hInstance)
     * }
     */
    public static MethodHandle UnregisterClassA$handle() {
        return UnregisterClassA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL UnregisterClassA(LPCSTR lpClassName, HINSTANCE hInstance)
     * }
     */
    public static int UnregisterClassA(MemorySegment lpClassName, MemorySegment hInstance) {
        var mh$ = UnregisterClassA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("UnregisterClassA", lpClassName, hInstance);
            }
            return (int)mh$.invokeExact(lpClassName, hInstance);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class UnregisterClassW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("UnregisterClassW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL UnregisterClassW(LPCWSTR lpClassName, HINSTANCE hInstance)
     * }
     */
    public static FunctionDescriptor UnregisterClassW$descriptor() {
        return UnregisterClassW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL UnregisterClassW(LPCWSTR lpClassName, HINSTANCE hInstance)
     * }
     */
    public static MethodHandle UnregisterClassW$handle() {
        return UnregisterClassW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL UnregisterClassW(LPCWSTR lpClassName, HINSTANCE hInstance)
     * }
     */
    public static int UnregisterClassW(MemorySegment lpClassName, MemorySegment hInstance) {
        var mh$ = UnregisterClassW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("UnregisterClassW", lpClassName, hInstance);
            }
            return (int)mh$.invokeExact(lpClassName, hInstance);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetClassInfoA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetClassInfoA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetClassInfoA(HINSTANCE hInstance, LPCSTR lpClassName, LPWNDCLASSA lpWndClass)
     * }
     */
    public static FunctionDescriptor GetClassInfoA$descriptor() {
        return GetClassInfoA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetClassInfoA(HINSTANCE hInstance, LPCSTR lpClassName, LPWNDCLASSA lpWndClass)
     * }
     */
    public static MethodHandle GetClassInfoA$handle() {
        return GetClassInfoA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL GetClassInfoA(HINSTANCE hInstance, LPCSTR lpClassName, LPWNDCLASSA lpWndClass)
     * }
     */
    public static int GetClassInfoA(MemorySegment hInstance, MemorySegment lpClassName, MemorySegment lpWndClass) {
        var mh$ = GetClassInfoA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetClassInfoA", hInstance, lpClassName, lpWndClass);
            }
            return (int)mh$.invokeExact(hInstance, lpClassName, lpWndClass);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetClassInfoW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetClassInfoW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetClassInfoW(HINSTANCE hInstance, LPCWSTR lpClassName, LPWNDCLASSW lpWndClass)
     * }
     */
    public static FunctionDescriptor GetClassInfoW$descriptor() {
        return GetClassInfoW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetClassInfoW(HINSTANCE hInstance, LPCWSTR lpClassName, LPWNDCLASSW lpWndClass)
     * }
     */
    public static MethodHandle GetClassInfoW$handle() {
        return GetClassInfoW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL GetClassInfoW(HINSTANCE hInstance, LPCWSTR lpClassName, LPWNDCLASSW lpWndClass)
     * }
     */
    public static int GetClassInfoW(MemorySegment hInstance, MemorySegment lpClassName, MemorySegment lpWndClass) {
        var mh$ = GetClassInfoW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetClassInfoW", hInstance, lpClassName, lpWndClass);
            }
            return (int)mh$.invokeExact(hInstance, lpClassName, lpWndClass);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RegisterClassExA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_SHORT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("RegisterClassExA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ATOM RegisterClassExA(const WNDCLASSEXA *)
     * }
     */
    public static FunctionDescriptor RegisterClassExA$descriptor() {
        return RegisterClassExA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ATOM RegisterClassExA(const WNDCLASSEXA *)
     * }
     */
    public static MethodHandle RegisterClassExA$handle() {
        return RegisterClassExA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * ATOM RegisterClassExA(const WNDCLASSEXA *)
     * }
     */
    public static short RegisterClassExA(MemorySegment x0) {
        var mh$ = RegisterClassExA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RegisterClassExA", x0);
            }
            return (short)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RegisterClassExW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_SHORT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("RegisterClassExW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ATOM RegisterClassExW(const WNDCLASSEXW *)
     * }
     */
    public static FunctionDescriptor RegisterClassExW$descriptor() {
        return RegisterClassExW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ATOM RegisterClassExW(const WNDCLASSEXW *)
     * }
     */
    public static MethodHandle RegisterClassExW$handle() {
        return RegisterClassExW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * ATOM RegisterClassExW(const WNDCLASSEXW *)
     * }
     */
    public static short RegisterClassExW(MemorySegment x0) {
        var mh$ = RegisterClassExW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RegisterClassExW", x0);
            }
            return (short)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetClassInfoExA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetClassInfoExA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetClassInfoExA(HINSTANCE hInstance, LPCSTR lpszClass, LPWNDCLASSEXA lpwcx)
     * }
     */
    public static FunctionDescriptor GetClassInfoExA$descriptor() {
        return GetClassInfoExA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetClassInfoExA(HINSTANCE hInstance, LPCSTR lpszClass, LPWNDCLASSEXA lpwcx)
     * }
     */
    public static MethodHandle GetClassInfoExA$handle() {
        return GetClassInfoExA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL GetClassInfoExA(HINSTANCE hInstance, LPCSTR lpszClass, LPWNDCLASSEXA lpwcx)
     * }
     */
    public static int GetClassInfoExA(MemorySegment hInstance, MemorySegment lpszClass, MemorySegment lpwcx) {
        var mh$ = GetClassInfoExA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetClassInfoExA", hInstance, lpszClass, lpwcx);
            }
            return (int)mh$.invokeExact(hInstance, lpszClass, lpwcx);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetClassInfoExW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetClassInfoExW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetClassInfoExW(HINSTANCE hInstance, LPCWSTR lpszClass, LPWNDCLASSEXW lpwcx)
     * }
     */
    public static FunctionDescriptor GetClassInfoExW$descriptor() {
        return GetClassInfoExW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetClassInfoExW(HINSTANCE hInstance, LPCWSTR lpszClass, LPWNDCLASSEXW lpwcx)
     * }
     */
    public static MethodHandle GetClassInfoExW$handle() {
        return GetClassInfoExW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL GetClassInfoExW(HINSTANCE hInstance, LPCWSTR lpszClass, LPWNDCLASSEXW lpwcx)
     * }
     */
    public static int GetClassInfoExW(MemorySegment hInstance, MemorySegment lpszClass, MemorySegment lpwcx) {
        var mh$ = GetClassInfoExW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetClassInfoExW", hInstance, lpszClass, lpwcx);
            }
            return (int)mh$.invokeExact(hInstance, lpszClass, lpwcx);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateWindowExA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_LONG,
            C_POINTER,
            C_POINTER,
            C_LONG,
            C_INT,
            C_INT,
            C_INT,
            C_INT,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CreateWindowExA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HWND CreateWindowExA(DWORD dwExStyle, LPCSTR lpClassName, LPCSTR lpWindowName, DWORD dwStyle, int X, int Y, int nWidth, int nHeight, HWND hWndParent, HMENU hMenu, HINSTANCE hInstance, LPVOID lpParam)
     * }
     */
    public static FunctionDescriptor CreateWindowExA$descriptor() {
        return CreateWindowExA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HWND CreateWindowExA(DWORD dwExStyle, LPCSTR lpClassName, LPCSTR lpWindowName, DWORD dwStyle, int X, int Y, int nWidth, int nHeight, HWND hWndParent, HMENU hMenu, HINSTANCE hInstance, LPVOID lpParam)
     * }
     */
    public static MethodHandle CreateWindowExA$handle() {
        return CreateWindowExA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * HWND CreateWindowExA(DWORD dwExStyle, LPCSTR lpClassName, LPCSTR lpWindowName, DWORD dwStyle, int X, int Y, int nWidth, int nHeight, HWND hWndParent, HMENU hMenu, HINSTANCE hInstance, LPVOID lpParam)
     * }
     */
    public static MemorySegment CreateWindowExA(int dwExStyle, MemorySegment lpClassName, MemorySegment lpWindowName, int dwStyle, int X, int Y, int nWidth, int nHeight, MemorySegment hWndParent, MemorySegment hMenu, MemorySegment hInstance, MemorySegment lpParam) {
        var mh$ = CreateWindowExA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateWindowExA", dwExStyle, lpClassName, lpWindowName, dwStyle, X, Y, nWidth, nHeight, hWndParent, hMenu, hInstance, lpParam);
            }
            return (MemorySegment)mh$.invokeExact(dwExStyle, lpClassName, lpWindowName, dwStyle, X, Y, nWidth, nHeight, hWndParent, hMenu, hInstance, lpParam);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateWindowExW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_LONG,
            C_POINTER,
            C_POINTER,
            C_LONG,
            C_INT,
            C_INT,
            C_INT,
            C_INT,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CreateWindowExW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HWND CreateWindowExW(DWORD dwExStyle, LPCWSTR lpClassName, LPCWSTR lpWindowName, DWORD dwStyle, int X, int Y, int nWidth, int nHeight, HWND hWndParent, HMENU hMenu, HINSTANCE hInstance, LPVOID lpParam)
     * }
     */
    public static FunctionDescriptor CreateWindowExW$descriptor() {
        return CreateWindowExW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HWND CreateWindowExW(DWORD dwExStyle, LPCWSTR lpClassName, LPCWSTR lpWindowName, DWORD dwStyle, int X, int Y, int nWidth, int nHeight, HWND hWndParent, HMENU hMenu, HINSTANCE hInstance, LPVOID lpParam)
     * }
     */
    public static MethodHandle CreateWindowExW$handle() {
        return CreateWindowExW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * HWND CreateWindowExW(DWORD dwExStyle, LPCWSTR lpClassName, LPCWSTR lpWindowName, DWORD dwStyle, int X, int Y, int nWidth, int nHeight, HWND hWndParent, HMENU hMenu, HINSTANCE hInstance, LPVOID lpParam)
     * }
     */
    public static MemorySegment CreateWindowExW(int dwExStyle, MemorySegment lpClassName, MemorySegment lpWindowName, int dwStyle, int X, int Y, int nWidth, int nHeight, MemorySegment hWndParent, MemorySegment hMenu, MemorySegment hInstance, MemorySegment lpParam) {
        var mh$ = CreateWindowExW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateWindowExW", dwExStyle, lpClassName, lpWindowName, dwStyle, X, Y, nWidth, nHeight, hWndParent, hMenu, hInstance, lpParam);
            }
            return (MemorySegment)mh$.invokeExact(dwExStyle, lpClassName, lpWindowName, dwStyle, X, Y, nWidth, nHeight, hWndParent, hMenu, hInstance, lpParam);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class IsWindow {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("IsWindow"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL IsWindow(HWND hWnd)
     * }
     */
    public static FunctionDescriptor IsWindow$descriptor() {
        return IsWindow.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL IsWindow(HWND hWnd)
     * }
     */
    public static MethodHandle IsWindow$handle() {
        return IsWindow.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL IsWindow(HWND hWnd)
     * }
     */
    public static int IsWindow(MemorySegment hWnd) {
        var mh$ = IsWindow.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("IsWindow", hWnd);
            }
            return (int)mh$.invokeExact(hWnd);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class IsMenu {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("IsMenu"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL IsMenu(HMENU hMenu)
     * }
     */
    public static FunctionDescriptor IsMenu$descriptor() {
        return IsMenu.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL IsMenu(HMENU hMenu)
     * }
     */
    public static MethodHandle IsMenu$handle() {
        return IsMenu.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL IsMenu(HMENU hMenu)
     * }
     */
    public static int IsMenu(MemorySegment hMenu) {
        var mh$ = IsMenu.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("IsMenu", hMenu);
            }
            return (int)mh$.invokeExact(hMenu);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class IsChild {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("IsChild"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL IsChild(HWND hWndParent, HWND hWnd)
     * }
     */
    public static FunctionDescriptor IsChild$descriptor() {
        return IsChild.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL IsChild(HWND hWndParent, HWND hWnd)
     * }
     */
    public static MethodHandle IsChild$handle() {
        return IsChild.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL IsChild(HWND hWndParent, HWND hWnd)
     * }
     */
    public static int IsChild(MemorySegment hWndParent, MemorySegment hWnd) {
        var mh$ = IsChild.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("IsChild", hWndParent, hWnd);
            }
            return (int)mh$.invokeExact(hWndParent, hWnd);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DestroyWindow {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("DestroyWindow"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL DestroyWindow(HWND hWnd)
     * }
     */
    public static FunctionDescriptor DestroyWindow$descriptor() {
        return DestroyWindow.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL DestroyWindow(HWND hWnd)
     * }
     */
    public static MethodHandle DestroyWindow$handle() {
        return DestroyWindow.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL DestroyWindow(HWND hWnd)
     * }
     */
    public static int DestroyWindow(MemorySegment hWnd) {
        var mh$ = DestroyWindow.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DestroyWindow", hWnd);
            }
            return (int)mh$.invokeExact(hWnd);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ShowWindow {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("ShowWindow"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL ShowWindow(HWND hWnd, int nCmdShow)
     * }
     */
    public static FunctionDescriptor ShowWindow$descriptor() {
        return ShowWindow.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL ShowWindow(HWND hWnd, int nCmdShow)
     * }
     */
    public static MethodHandle ShowWindow$handle() {
        return ShowWindow.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL ShowWindow(HWND hWnd, int nCmdShow)
     * }
     */
    public static int ShowWindow(MemorySegment hWnd, int nCmdShow) {
        var mh$ = ShowWindow.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ShowWindow", hWnd, nCmdShow);
            }
            return (int)mh$.invokeExact(hWnd, nCmdShow);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class AnimateWindow {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_LONG,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("AnimateWindow"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL AnimateWindow(HWND hWnd, DWORD dwTime, DWORD dwFlags)
     * }
     */
    public static FunctionDescriptor AnimateWindow$descriptor() {
        return AnimateWindow.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL AnimateWindow(HWND hWnd, DWORD dwTime, DWORD dwFlags)
     * }
     */
    public static MethodHandle AnimateWindow$handle() {
        return AnimateWindow.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL AnimateWindow(HWND hWnd, DWORD dwTime, DWORD dwFlags)
     * }
     */
    public static int AnimateWindow(MemorySegment hWnd, int dwTime, int dwFlags) {
        var mh$ = AnimateWindow.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("AnimateWindow", hWnd, dwTime, dwFlags);
            }
            return (int)mh$.invokeExact(hWnd, dwTime, dwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class UpdateLayeredWindow {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_LONG,
            C_POINTER,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("UpdateLayeredWindow"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL UpdateLayeredWindow(HWND hWnd, HDC hdcDst, POINT *pptDst, SIZE *psize, HDC hdcSrc, POINT *pptSrc, COLORREF crKey, BLENDFUNCTION *pblend, DWORD dwFlags)
     * }
     */
    public static FunctionDescriptor UpdateLayeredWindow$descriptor() {
        return UpdateLayeredWindow.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL UpdateLayeredWindow(HWND hWnd, HDC hdcDst, POINT *pptDst, SIZE *psize, HDC hdcSrc, POINT *pptSrc, COLORREF crKey, BLENDFUNCTION *pblend, DWORD dwFlags)
     * }
     */
    public static MethodHandle UpdateLayeredWindow$handle() {
        return UpdateLayeredWindow.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL UpdateLayeredWindow(HWND hWnd, HDC hdcDst, POINT *pptDst, SIZE *psize, HDC hdcSrc, POINT *pptSrc, COLORREF crKey, BLENDFUNCTION *pblend, DWORD dwFlags)
     * }
     */
    public static int UpdateLayeredWindow(MemorySegment hWnd, MemorySegment hdcDst, MemorySegment pptDst, MemorySegment psize, MemorySegment hdcSrc, MemorySegment pptSrc, int crKey, MemorySegment pblend, int dwFlags) {
        var mh$ = UpdateLayeredWindow.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("UpdateLayeredWindow", hWnd, hdcDst, pptDst, psize, hdcSrc, pptSrc, crKey, pblend, dwFlags);
            }
            return (int)mh$.invokeExact(hWnd, hdcDst, pptDst, psize, hdcSrc, pptSrc, crKey, pblend, dwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct tagUPDATELAYEREDWINDOWINFO {
     *     DWORD cbSize;
     *     HDC hdcDst;
     *     const POINT *pptDst;
     *     const SIZE *psize;
     *     HDC hdcSrc;
     *     const POINT *pptSrc;
     *     COLORREF crKey;
     *     const BLENDFUNCTION *pblend;
     *     DWORD dwFlags;
     *     const RECT *prcDirty;
     * } *PUPDATELAYEREDWINDOWINFO
     * }
     */
    public static final AddressLayout PUPDATELAYEREDWINDOWINFO = C_POINTER;

    private static class UpdateLayeredWindowIndirect {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("UpdateLayeredWindowIndirect"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL UpdateLayeredWindowIndirect(HWND hWnd, const UPDATELAYEREDWINDOWINFO *pULWInfo)
     * }
     */
    public static FunctionDescriptor UpdateLayeredWindowIndirect$descriptor() {
        return UpdateLayeredWindowIndirect.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL UpdateLayeredWindowIndirect(HWND hWnd, const UPDATELAYEREDWINDOWINFO *pULWInfo)
     * }
     */
    public static MethodHandle UpdateLayeredWindowIndirect$handle() {
        return UpdateLayeredWindowIndirect.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL UpdateLayeredWindowIndirect(HWND hWnd, const UPDATELAYEREDWINDOWINFO *pULWInfo)
     * }
     */
    public static int UpdateLayeredWindowIndirect(MemorySegment hWnd, MemorySegment pULWInfo) {
        var mh$ = UpdateLayeredWindowIndirect.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("UpdateLayeredWindowIndirect", hWnd, pULWInfo);
            }
            return (int)mh$.invokeExact(hWnd, pULWInfo);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetLayeredWindowAttributes {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetLayeredWindowAttributes"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetLayeredWindowAttributes(HWND hwnd, COLORREF *pcrKey, BYTE *pbAlpha, DWORD *pdwFlags)
     * }
     */
    public static FunctionDescriptor GetLayeredWindowAttributes$descriptor() {
        return GetLayeredWindowAttributes.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetLayeredWindowAttributes(HWND hwnd, COLORREF *pcrKey, BYTE *pbAlpha, DWORD *pdwFlags)
     * }
     */
    public static MethodHandle GetLayeredWindowAttributes$handle() {
        return GetLayeredWindowAttributes.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL GetLayeredWindowAttributes(HWND hwnd, COLORREF *pcrKey, BYTE *pbAlpha, DWORD *pdwFlags)
     * }
     */
    public static int GetLayeredWindowAttributes(MemorySegment hwnd, MemorySegment pcrKey, MemorySegment pbAlpha, MemorySegment pdwFlags) {
        var mh$ = GetLayeredWindowAttributes.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetLayeredWindowAttributes", hwnd, pcrKey, pbAlpha, pdwFlags);
            }
            return (int)mh$.invokeExact(hwnd, pcrKey, pbAlpha, pdwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PrintWindow {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("PrintWindow"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL PrintWindow(HWND hwnd, HDC hdcBlt, UINT nFlags)
     * }
     */
    public static FunctionDescriptor PrintWindow$descriptor() {
        return PrintWindow.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL PrintWindow(HWND hwnd, HDC hdcBlt, UINT nFlags)
     * }
     */
    public static MethodHandle PrintWindow$handle() {
        return PrintWindow.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL PrintWindow(HWND hwnd, HDC hdcBlt, UINT nFlags)
     * }
     */
    public static int PrintWindow(MemorySegment hwnd, MemorySegment hdcBlt, int nFlags) {
        var mh$ = PrintWindow.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PrintWindow", hwnd, hdcBlt, nFlags);
            }
            return (int)mh$.invokeExact(hwnd, hdcBlt, nFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetLayeredWindowAttributes {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_LONG,
            C_CHAR,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("SetLayeredWindowAttributes"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetLayeredWindowAttributes(HWND hwnd, COLORREF crKey, BYTE bAlpha, DWORD dwFlags)
     * }
     */
    public static FunctionDescriptor SetLayeredWindowAttributes$descriptor() {
        return SetLayeredWindowAttributes.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetLayeredWindowAttributes(HWND hwnd, COLORREF crKey, BYTE bAlpha, DWORD dwFlags)
     * }
     */
    public static MethodHandle SetLayeredWindowAttributes$handle() {
        return SetLayeredWindowAttributes.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL SetLayeredWindowAttributes(HWND hwnd, COLORREF crKey, BYTE bAlpha, DWORD dwFlags)
     * }
     */
    public static int SetLayeredWindowAttributes(MemorySegment hwnd, int crKey, byte bAlpha, int dwFlags) {
        var mh$ = SetLayeredWindowAttributes.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetLayeredWindowAttributes", hwnd, crKey, bAlpha, dwFlags);
            }
            return (int)mh$.invokeExact(hwnd, crKey, bAlpha, dwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ShowWindowAsync {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("ShowWindowAsync"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL ShowWindowAsync(HWND hWnd, int nCmdShow)
     * }
     */
    public static FunctionDescriptor ShowWindowAsync$descriptor() {
        return ShowWindowAsync.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL ShowWindowAsync(HWND hWnd, int nCmdShow)
     * }
     */
    public static MethodHandle ShowWindowAsync$handle() {
        return ShowWindowAsync.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL ShowWindowAsync(HWND hWnd, int nCmdShow)
     * }
     */
    public static int ShowWindowAsync(MemorySegment hWnd, int nCmdShow) {
        var mh$ = ShowWindowAsync.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ShowWindowAsync", hWnd, nCmdShow);
            }
            return (int)mh$.invokeExact(hWnd, nCmdShow);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FlashWindow {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("FlashWindow"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL FlashWindow(HWND hWnd, BOOL bInvert)
     * }
     */
    public static FunctionDescriptor FlashWindow$descriptor() {
        return FlashWindow.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL FlashWindow(HWND hWnd, BOOL bInvert)
     * }
     */
    public static MethodHandle FlashWindow$handle() {
        return FlashWindow.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL FlashWindow(HWND hWnd, BOOL bInvert)
     * }
     */
    public static int FlashWindow(MemorySegment hWnd, int bInvert) {
        var mh$ = FlashWindow.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FlashWindow", hWnd, bInvert);
            }
            return (int)mh$.invokeExact(hWnd, bInvert);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct {
     *     UINT cbSize;
     *     HWND hwnd;
     *     DWORD dwFlags;
     *     UINT uCount;
     *     DWORD dwTimeout;
     * } *PFLASHWINFO
     * }
     */
    public static final AddressLayout PFLASHWINFO = C_POINTER;

    private static class FlashWindowEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("FlashWindowEx"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL FlashWindowEx(PFLASHWINFO pfwi)
     * }
     */
    public static FunctionDescriptor FlashWindowEx$descriptor() {
        return FlashWindowEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL FlashWindowEx(PFLASHWINFO pfwi)
     * }
     */
    public static MethodHandle FlashWindowEx$handle() {
        return FlashWindowEx.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL FlashWindowEx(PFLASHWINFO pfwi)
     * }
     */
    public static int FlashWindowEx(MemorySegment pfwi) {
        var mh$ = FlashWindowEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FlashWindowEx", pfwi);
            }
            return (int)mh$.invokeExact(pfwi);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ShowOwnedPopups {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("ShowOwnedPopups"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL ShowOwnedPopups(HWND hWnd, BOOL fShow)
     * }
     */
    public static FunctionDescriptor ShowOwnedPopups$descriptor() {
        return ShowOwnedPopups.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL ShowOwnedPopups(HWND hWnd, BOOL fShow)
     * }
     */
    public static MethodHandle ShowOwnedPopups$handle() {
        return ShowOwnedPopups.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL ShowOwnedPopups(HWND hWnd, BOOL fShow)
     * }
     */
    public static int ShowOwnedPopups(MemorySegment hWnd, int fShow) {
        var mh$ = ShowOwnedPopups.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ShowOwnedPopups", hWnd, fShow);
            }
            return (int)mh$.invokeExact(hWnd, fShow);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class OpenIcon {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("OpenIcon"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL OpenIcon(HWND hWnd)
     * }
     */
    public static FunctionDescriptor OpenIcon$descriptor() {
        return OpenIcon.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL OpenIcon(HWND hWnd)
     * }
     */
    public static MethodHandle OpenIcon$handle() {
        return OpenIcon.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL OpenIcon(HWND hWnd)
     * }
     */
    public static int OpenIcon(MemorySegment hWnd) {
        var mh$ = OpenIcon.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("OpenIcon", hWnd);
            }
            return (int)mh$.invokeExact(hWnd);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CloseWindow {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CloseWindow"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CloseWindow(HWND hWnd)
     * }
     */
    public static FunctionDescriptor CloseWindow$descriptor() {
        return CloseWindow.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CloseWindow(HWND hWnd)
     * }
     */
    public static MethodHandle CloseWindow$handle() {
        return CloseWindow.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL CloseWindow(HWND hWnd)
     * }
     */
    public static int CloseWindow(MemorySegment hWnd) {
        var mh$ = CloseWindow.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CloseWindow", hWnd);
            }
            return (int)mh$.invokeExact(hWnd);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MoveWindow {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_INT,
            C_INT,
            C_INT,
            C_INT,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("MoveWindow"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL MoveWindow(HWND hWnd, int X, int Y, int nWidth, int nHeight, BOOL bRepaint)
     * }
     */
    public static FunctionDescriptor MoveWindow$descriptor() {
        return MoveWindow.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL MoveWindow(HWND hWnd, int X, int Y, int nWidth, int nHeight, BOOL bRepaint)
     * }
     */
    public static MethodHandle MoveWindow$handle() {
        return MoveWindow.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL MoveWindow(HWND hWnd, int X, int Y, int nWidth, int nHeight, BOOL bRepaint)
     * }
     */
    public static int MoveWindow(MemorySegment hWnd, int X, int Y, int nWidth, int nHeight, int bRepaint) {
        var mh$ = MoveWindow.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MoveWindow", hWnd, X, Y, nWidth, nHeight, bRepaint);
            }
            return (int)mh$.invokeExact(hWnd, X, Y, nWidth, nHeight, bRepaint);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetWindowPos {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_INT,
            C_INT,
            C_INT,
            C_INT,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("SetWindowPos"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetWindowPos(HWND hWnd, HWND hWndInsertAfter, int X, int Y, int cx, int cy, UINT uFlags)
     * }
     */
    public static FunctionDescriptor SetWindowPos$descriptor() {
        return SetWindowPos.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetWindowPos(HWND hWnd, HWND hWndInsertAfter, int X, int Y, int cx, int cy, UINT uFlags)
     * }
     */
    public static MethodHandle SetWindowPos$handle() {
        return SetWindowPos.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL SetWindowPos(HWND hWnd, HWND hWndInsertAfter, int X, int Y, int cx, int cy, UINT uFlags)
     * }
     */
    public static int SetWindowPos(MemorySegment hWnd, MemorySegment hWndInsertAfter, int X, int Y, int cx, int cy, int uFlags) {
        var mh$ = SetWindowPos.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetWindowPos", hWnd, hWndInsertAfter, X, Y, cx, cy, uFlags);
            }
            return (int)mh$.invokeExact(hWnd, hWndInsertAfter, X, Y, cx, cy, uFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetWindowPlacement {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetWindowPlacement"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetWindowPlacement(HWND hWnd, WINDOWPLACEMENT *lpwndpl)
     * }
     */
    public static FunctionDescriptor GetWindowPlacement$descriptor() {
        return GetWindowPlacement.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetWindowPlacement(HWND hWnd, WINDOWPLACEMENT *lpwndpl)
     * }
     */
    public static MethodHandle GetWindowPlacement$handle() {
        return GetWindowPlacement.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL GetWindowPlacement(HWND hWnd, WINDOWPLACEMENT *lpwndpl)
     * }
     */
    public static int GetWindowPlacement(MemorySegment hWnd, MemorySegment lpwndpl) {
        var mh$ = GetWindowPlacement.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetWindowPlacement", hWnd, lpwndpl);
            }
            return (int)mh$.invokeExact(hWnd, lpwndpl);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetWindowPlacement {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("SetWindowPlacement"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetWindowPlacement(HWND hWnd, const WINDOWPLACEMENT *lpwndpl)
     * }
     */
    public static FunctionDescriptor SetWindowPlacement$descriptor() {
        return SetWindowPlacement.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetWindowPlacement(HWND hWnd, const WINDOWPLACEMENT *lpwndpl)
     * }
     */
    public static MethodHandle SetWindowPlacement$handle() {
        return SetWindowPlacement.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL SetWindowPlacement(HWND hWnd, const WINDOWPLACEMENT *lpwndpl)
     * }
     */
    public static int SetWindowPlacement(MemorySegment hWnd, MemorySegment lpwndpl) {
        var mh$ = SetWindowPlacement.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetWindowPlacement", hWnd, lpwndpl);
            }
            return (int)mh$.invokeExact(hWnd, lpwndpl);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetWindowDisplayAffinity {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetWindowDisplayAffinity"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetWindowDisplayAffinity(HWND hWnd, DWORD *pdwAffinity)
     * }
     */
    public static FunctionDescriptor GetWindowDisplayAffinity$descriptor() {
        return GetWindowDisplayAffinity.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetWindowDisplayAffinity(HWND hWnd, DWORD *pdwAffinity)
     * }
     */
    public static MethodHandle GetWindowDisplayAffinity$handle() {
        return GetWindowDisplayAffinity.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL GetWindowDisplayAffinity(HWND hWnd, DWORD *pdwAffinity)
     * }
     */
    public static int GetWindowDisplayAffinity(MemorySegment hWnd, MemorySegment pdwAffinity) {
        var mh$ = GetWindowDisplayAffinity.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetWindowDisplayAffinity", hWnd, pdwAffinity);
            }
            return (int)mh$.invokeExact(hWnd, pdwAffinity);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetWindowDisplayAffinity {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("SetWindowDisplayAffinity"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetWindowDisplayAffinity(HWND hWnd, DWORD dwAffinity)
     * }
     */
    public static FunctionDescriptor SetWindowDisplayAffinity$descriptor() {
        return SetWindowDisplayAffinity.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetWindowDisplayAffinity(HWND hWnd, DWORD dwAffinity)
     * }
     */
    public static MethodHandle SetWindowDisplayAffinity$handle() {
        return SetWindowDisplayAffinity.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL SetWindowDisplayAffinity(HWND hWnd, DWORD dwAffinity)
     * }
     */
    public static int SetWindowDisplayAffinity(MemorySegment hWnd, int dwAffinity) {
        var mh$ = SetWindowDisplayAffinity.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetWindowDisplayAffinity", hWnd, dwAffinity);
            }
            return (int)mh$.invokeExact(hWnd, dwAffinity);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class BeginDeferWindowPos {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("BeginDeferWindowPos"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HDWP BeginDeferWindowPos(int nNumWindows)
     * }
     */
    public static FunctionDescriptor BeginDeferWindowPos$descriptor() {
        return BeginDeferWindowPos.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HDWP BeginDeferWindowPos(int nNumWindows)
     * }
     */
    public static MethodHandle BeginDeferWindowPos$handle() {
        return BeginDeferWindowPos.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * HDWP BeginDeferWindowPos(int nNumWindows)
     * }
     */
    public static MemorySegment BeginDeferWindowPos(int nNumWindows) {
        var mh$ = BeginDeferWindowPos.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("BeginDeferWindowPos", nNumWindows);
            }
            return (MemorySegment)mh$.invokeExact(nNumWindows);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DeferWindowPos {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_INT,
            C_INT,
            C_INT,
            C_INT,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("DeferWindowPos"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HDWP DeferWindowPos(HDWP hWinPosInfo, HWND hWnd, HWND hWndInsertAfter, int x, int y, int cx, int cy, UINT uFlags)
     * }
     */
    public static FunctionDescriptor DeferWindowPos$descriptor() {
        return DeferWindowPos.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HDWP DeferWindowPos(HDWP hWinPosInfo, HWND hWnd, HWND hWndInsertAfter, int x, int y, int cx, int cy, UINT uFlags)
     * }
     */
    public static MethodHandle DeferWindowPos$handle() {
        return DeferWindowPos.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * HDWP DeferWindowPos(HDWP hWinPosInfo, HWND hWnd, HWND hWndInsertAfter, int x, int y, int cx, int cy, UINT uFlags)
     * }
     */
    public static MemorySegment DeferWindowPos(MemorySegment hWinPosInfo, MemorySegment hWnd, MemorySegment hWndInsertAfter, int x, int y, int cx, int cy, int uFlags) {
        var mh$ = DeferWindowPos.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DeferWindowPos", hWinPosInfo, hWnd, hWndInsertAfter, x, y, cx, cy, uFlags);
            }
            return (MemorySegment)mh$.invokeExact(hWinPosInfo, hWnd, hWndInsertAfter, x, y, cx, cy, uFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class EndDeferWindowPos {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("EndDeferWindowPos"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL EndDeferWindowPos(HDWP hWinPosInfo)
     * }
     */
    public static FunctionDescriptor EndDeferWindowPos$descriptor() {
        return EndDeferWindowPos.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL EndDeferWindowPos(HDWP hWinPosInfo)
     * }
     */
    public static MethodHandle EndDeferWindowPos$handle() {
        return EndDeferWindowPos.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL EndDeferWindowPos(HDWP hWinPosInfo)
     * }
     */
    public static int EndDeferWindowPos(MemorySegment hWinPosInfo) {
        var mh$ = EndDeferWindowPos.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("EndDeferWindowPos", hWinPosInfo);
            }
            return (int)mh$.invokeExact(hWinPosInfo);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class IsWindowVisible {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("IsWindowVisible"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL IsWindowVisible(HWND hWnd)
     * }
     */
    public static FunctionDescriptor IsWindowVisible$descriptor() {
        return IsWindowVisible.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL IsWindowVisible(HWND hWnd)
     * }
     */
    public static MethodHandle IsWindowVisible$handle() {
        return IsWindowVisible.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL IsWindowVisible(HWND hWnd)
     * }
     */
    public static int IsWindowVisible(MemorySegment hWnd) {
        var mh$ = IsWindowVisible.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("IsWindowVisible", hWnd);
            }
            return (int)mh$.invokeExact(hWnd);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class IsIconic {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("IsIconic"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL IsIconic(HWND hWnd)
     * }
     */
    public static FunctionDescriptor IsIconic$descriptor() {
        return IsIconic.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL IsIconic(HWND hWnd)
     * }
     */
    public static MethodHandle IsIconic$handle() {
        return IsIconic.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL IsIconic(HWND hWnd)
     * }
     */
    public static int IsIconic(MemorySegment hWnd) {
        var mh$ = IsIconic.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("IsIconic", hWnd);
            }
            return (int)mh$.invokeExact(hWnd);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class AnyPopup {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT    );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("AnyPopup"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL AnyPopup()
     * }
     */
    public static FunctionDescriptor AnyPopup$descriptor() {
        return AnyPopup.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL AnyPopup()
     * }
     */
    public static MethodHandle AnyPopup$handle() {
        return AnyPopup.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL AnyPopup()
     * }
     */
    public static int AnyPopup() {
        var mh$ = AnyPopup.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("AnyPopup");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class BringWindowToTop {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("BringWindowToTop"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL BringWindowToTop(HWND hWnd)
     * }
     */
    public static FunctionDescriptor BringWindowToTop$descriptor() {
        return BringWindowToTop.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL BringWindowToTop(HWND hWnd)
     * }
     */
    public static MethodHandle BringWindowToTop$handle() {
        return BringWindowToTop.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL BringWindowToTop(HWND hWnd)
     * }
     */
    public static int BringWindowToTop(MemorySegment hWnd) {
        var mh$ = BringWindowToTop.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("BringWindowToTop", hWnd);
            }
            return (int)mh$.invokeExact(hWnd);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class IsZoomed {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("IsZoomed"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL IsZoomed(HWND hWnd)
     * }
     */
    public static FunctionDescriptor IsZoomed$descriptor() {
        return IsZoomed.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL IsZoomed(HWND hWnd)
     * }
     */
    public static MethodHandle IsZoomed$handle() {
        return IsZoomed.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL IsZoomed(HWND hWnd)
     * }
     */
    public static int IsZoomed(MemorySegment hWnd) {
        var mh$ = IsZoomed.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("IsZoomed", hWnd);
            }
            return (int)mh$.invokeExact(hWnd);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef DLGTEMPLATE *LPDLGTEMPLATEA
     * }
     */
    public static final AddressLayout LPDLGTEMPLATEA = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef DLGTEMPLATE *LPDLGTEMPLATEW
     * }
     */
    public static final AddressLayout LPDLGTEMPLATEW = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef LPDLGTEMPLATEA LPDLGTEMPLATE
     * }
     */
    public static final AddressLayout LPDLGTEMPLATE = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef const DLGTEMPLATE *LPCDLGTEMPLATEA
     * }
     */
    public static final AddressLayout LPCDLGTEMPLATEA = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef const DLGTEMPLATE *LPCDLGTEMPLATEW
     * }
     */
    public static final AddressLayout LPCDLGTEMPLATEW = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef LPCDLGTEMPLATEA LPCDLGTEMPLATE
     * }
     */
    public static final AddressLayout LPCDLGTEMPLATE = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef DLGITEMTEMPLATE *PDLGITEMTEMPLATEA
     * }
     */
    public static final AddressLayout PDLGITEMTEMPLATEA = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef DLGITEMTEMPLATE *PDLGITEMTEMPLATEW
     * }
     */
    public static final AddressLayout PDLGITEMTEMPLATEW = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef PDLGITEMTEMPLATEA PDLGITEMTEMPLATE
     * }
     */
    public static final AddressLayout PDLGITEMTEMPLATE = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef DLGITEMTEMPLATE *LPDLGITEMTEMPLATEA
     * }
     */
    public static final AddressLayout LPDLGITEMTEMPLATEA = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef DLGITEMTEMPLATE *LPDLGITEMTEMPLATEW
     * }
     */
    public static final AddressLayout LPDLGITEMTEMPLATEW = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef LPDLGITEMTEMPLATEA LPDLGITEMTEMPLATE
     * }
     */
    public static final AddressLayout LPDLGITEMTEMPLATE = C_POINTER;

    private static class CreateDialogParamA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_LONG_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CreateDialogParamA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HWND CreateDialogParamA(HINSTANCE hInstance, LPCSTR lpTemplateName, HWND hWndParent, DLGPROC lpDialogFunc, LPARAM dwInitParam)
     * }
     */
    public static FunctionDescriptor CreateDialogParamA$descriptor() {
        return CreateDialogParamA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HWND CreateDialogParamA(HINSTANCE hInstance, LPCSTR lpTemplateName, HWND hWndParent, DLGPROC lpDialogFunc, LPARAM dwInitParam)
     * }
     */
    public static MethodHandle CreateDialogParamA$handle() {
        return CreateDialogParamA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * HWND CreateDialogParamA(HINSTANCE hInstance, LPCSTR lpTemplateName, HWND hWndParent, DLGPROC lpDialogFunc, LPARAM dwInitParam)
     * }
     */
    public static MemorySegment CreateDialogParamA(MemorySegment hInstance, MemorySegment lpTemplateName, MemorySegment hWndParent, MemorySegment lpDialogFunc, long dwInitParam) {
        var mh$ = CreateDialogParamA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateDialogParamA", hInstance, lpTemplateName, hWndParent, lpDialogFunc, dwInitParam);
            }
            return (MemorySegment)mh$.invokeExact(hInstance, lpTemplateName, hWndParent, lpDialogFunc, dwInitParam);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateDialogParamW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_LONG_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CreateDialogParamW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HWND CreateDialogParamW(HINSTANCE hInstance, LPCWSTR lpTemplateName, HWND hWndParent, DLGPROC lpDialogFunc, LPARAM dwInitParam)
     * }
     */
    public static FunctionDescriptor CreateDialogParamW$descriptor() {
        return CreateDialogParamW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HWND CreateDialogParamW(HINSTANCE hInstance, LPCWSTR lpTemplateName, HWND hWndParent, DLGPROC lpDialogFunc, LPARAM dwInitParam)
     * }
     */
    public static MethodHandle CreateDialogParamW$handle() {
        return CreateDialogParamW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * HWND CreateDialogParamW(HINSTANCE hInstance, LPCWSTR lpTemplateName, HWND hWndParent, DLGPROC lpDialogFunc, LPARAM dwInitParam)
     * }
     */
    public static MemorySegment CreateDialogParamW(MemorySegment hInstance, MemorySegment lpTemplateName, MemorySegment hWndParent, MemorySegment lpDialogFunc, long dwInitParam) {
        var mh$ = CreateDialogParamW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateDialogParamW", hInstance, lpTemplateName, hWndParent, lpDialogFunc, dwInitParam);
            }
            return (MemorySegment)mh$.invokeExact(hInstance, lpTemplateName, hWndParent, lpDialogFunc, dwInitParam);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateDialogIndirectParamA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_LONG_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CreateDialogIndirectParamA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HWND CreateDialogIndirectParamA(HINSTANCE hInstance, LPCDLGTEMPLATEA lpTemplate, HWND hWndParent, DLGPROC lpDialogFunc, LPARAM dwInitParam)
     * }
     */
    public static FunctionDescriptor CreateDialogIndirectParamA$descriptor() {
        return CreateDialogIndirectParamA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HWND CreateDialogIndirectParamA(HINSTANCE hInstance, LPCDLGTEMPLATEA lpTemplate, HWND hWndParent, DLGPROC lpDialogFunc, LPARAM dwInitParam)
     * }
     */
    public static MethodHandle CreateDialogIndirectParamA$handle() {
        return CreateDialogIndirectParamA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * HWND CreateDialogIndirectParamA(HINSTANCE hInstance, LPCDLGTEMPLATEA lpTemplate, HWND hWndParent, DLGPROC lpDialogFunc, LPARAM dwInitParam)
     * }
     */
    public static MemorySegment CreateDialogIndirectParamA(MemorySegment hInstance, MemorySegment lpTemplate, MemorySegment hWndParent, MemorySegment lpDialogFunc, long dwInitParam) {
        var mh$ = CreateDialogIndirectParamA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateDialogIndirectParamA", hInstance, lpTemplate, hWndParent, lpDialogFunc, dwInitParam);
            }
            return (MemorySegment)mh$.invokeExact(hInstance, lpTemplate, hWndParent, lpDialogFunc, dwInitParam);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateDialogIndirectParamW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_LONG_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CreateDialogIndirectParamW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HWND CreateDialogIndirectParamW(HINSTANCE hInstance, LPCDLGTEMPLATEW lpTemplate, HWND hWndParent, DLGPROC lpDialogFunc, LPARAM dwInitParam)
     * }
     */
    public static FunctionDescriptor CreateDialogIndirectParamW$descriptor() {
        return CreateDialogIndirectParamW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HWND CreateDialogIndirectParamW(HINSTANCE hInstance, LPCDLGTEMPLATEW lpTemplate, HWND hWndParent, DLGPROC lpDialogFunc, LPARAM dwInitParam)
     * }
     */
    public static MethodHandle CreateDialogIndirectParamW$handle() {
        return CreateDialogIndirectParamW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * HWND CreateDialogIndirectParamW(HINSTANCE hInstance, LPCDLGTEMPLATEW lpTemplate, HWND hWndParent, DLGPROC lpDialogFunc, LPARAM dwInitParam)
     * }
     */
    public static MemorySegment CreateDialogIndirectParamW(MemorySegment hInstance, MemorySegment lpTemplate, MemorySegment hWndParent, MemorySegment lpDialogFunc, long dwInitParam) {
        var mh$ = CreateDialogIndirectParamW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateDialogIndirectParamW", hInstance, lpTemplate, hWndParent, lpDialogFunc, dwInitParam);
            }
            return (MemorySegment)mh$.invokeExact(hInstance, lpTemplate, hWndParent, lpDialogFunc, dwInitParam);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DialogBoxParamA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG_LONG,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_LONG_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("DialogBoxParamA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * INT_PTR DialogBoxParamA(HINSTANCE hInstance, LPCSTR lpTemplateName, HWND hWndParent, DLGPROC lpDialogFunc, LPARAM dwInitParam)
     * }
     */
    public static FunctionDescriptor DialogBoxParamA$descriptor() {
        return DialogBoxParamA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * INT_PTR DialogBoxParamA(HINSTANCE hInstance, LPCSTR lpTemplateName, HWND hWndParent, DLGPROC lpDialogFunc, LPARAM dwInitParam)
     * }
     */
    public static MethodHandle DialogBoxParamA$handle() {
        return DialogBoxParamA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * INT_PTR DialogBoxParamA(HINSTANCE hInstance, LPCSTR lpTemplateName, HWND hWndParent, DLGPROC lpDialogFunc, LPARAM dwInitParam)
     * }
     */
    public static long DialogBoxParamA(MemorySegment hInstance, MemorySegment lpTemplateName, MemorySegment hWndParent, MemorySegment lpDialogFunc, long dwInitParam) {
        var mh$ = DialogBoxParamA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DialogBoxParamA", hInstance, lpTemplateName, hWndParent, lpDialogFunc, dwInitParam);
            }
            return (long)mh$.invokeExact(hInstance, lpTemplateName, hWndParent, lpDialogFunc, dwInitParam);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DialogBoxParamW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG_LONG,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_LONG_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("DialogBoxParamW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * INT_PTR DialogBoxParamW(HINSTANCE hInstance, LPCWSTR lpTemplateName, HWND hWndParent, DLGPROC lpDialogFunc, LPARAM dwInitParam)
     * }
     */
    public static FunctionDescriptor DialogBoxParamW$descriptor() {
        return DialogBoxParamW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * INT_PTR DialogBoxParamW(HINSTANCE hInstance, LPCWSTR lpTemplateName, HWND hWndParent, DLGPROC lpDialogFunc, LPARAM dwInitParam)
     * }
     */
    public static MethodHandle DialogBoxParamW$handle() {
        return DialogBoxParamW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * INT_PTR DialogBoxParamW(HINSTANCE hInstance, LPCWSTR lpTemplateName, HWND hWndParent, DLGPROC lpDialogFunc, LPARAM dwInitParam)
     * }
     */
    public static long DialogBoxParamW(MemorySegment hInstance, MemorySegment lpTemplateName, MemorySegment hWndParent, MemorySegment lpDialogFunc, long dwInitParam) {
        var mh$ = DialogBoxParamW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DialogBoxParamW", hInstance, lpTemplateName, hWndParent, lpDialogFunc, dwInitParam);
            }
            return (long)mh$.invokeExact(hInstance, lpTemplateName, hWndParent, lpDialogFunc, dwInitParam);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DialogBoxIndirectParamA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG_LONG,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_LONG_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("DialogBoxIndirectParamA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * INT_PTR DialogBoxIndirectParamA(HINSTANCE hInstance, LPCDLGTEMPLATEA hDialogTemplate, HWND hWndParent, DLGPROC lpDialogFunc, LPARAM dwInitParam)
     * }
     */
    public static FunctionDescriptor DialogBoxIndirectParamA$descriptor() {
        return DialogBoxIndirectParamA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * INT_PTR DialogBoxIndirectParamA(HINSTANCE hInstance, LPCDLGTEMPLATEA hDialogTemplate, HWND hWndParent, DLGPROC lpDialogFunc, LPARAM dwInitParam)
     * }
     */
    public static MethodHandle DialogBoxIndirectParamA$handle() {
        return DialogBoxIndirectParamA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * INT_PTR DialogBoxIndirectParamA(HINSTANCE hInstance, LPCDLGTEMPLATEA hDialogTemplate, HWND hWndParent, DLGPROC lpDialogFunc, LPARAM dwInitParam)
     * }
     */
    public static long DialogBoxIndirectParamA(MemorySegment hInstance, MemorySegment hDialogTemplate, MemorySegment hWndParent, MemorySegment lpDialogFunc, long dwInitParam) {
        var mh$ = DialogBoxIndirectParamA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DialogBoxIndirectParamA", hInstance, hDialogTemplate, hWndParent, lpDialogFunc, dwInitParam);
            }
            return (long)mh$.invokeExact(hInstance, hDialogTemplate, hWndParent, lpDialogFunc, dwInitParam);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DialogBoxIndirectParamW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG_LONG,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_LONG_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("DialogBoxIndirectParamW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * INT_PTR DialogBoxIndirectParamW(HINSTANCE hInstance, LPCDLGTEMPLATEW hDialogTemplate, HWND hWndParent, DLGPROC lpDialogFunc, LPARAM dwInitParam)
     * }
     */
    public static FunctionDescriptor DialogBoxIndirectParamW$descriptor() {
        return DialogBoxIndirectParamW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * INT_PTR DialogBoxIndirectParamW(HINSTANCE hInstance, LPCDLGTEMPLATEW hDialogTemplate, HWND hWndParent, DLGPROC lpDialogFunc, LPARAM dwInitParam)
     * }
     */
    public static MethodHandle DialogBoxIndirectParamW$handle() {
        return DialogBoxIndirectParamW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * INT_PTR DialogBoxIndirectParamW(HINSTANCE hInstance, LPCDLGTEMPLATEW hDialogTemplate, HWND hWndParent, DLGPROC lpDialogFunc, LPARAM dwInitParam)
     * }
     */
    public static long DialogBoxIndirectParamW(MemorySegment hInstance, MemorySegment hDialogTemplate, MemorySegment hWndParent, MemorySegment lpDialogFunc, long dwInitParam) {
        var mh$ = DialogBoxIndirectParamW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DialogBoxIndirectParamW", hInstance, hDialogTemplate, hWndParent, lpDialogFunc, dwInitParam);
            }
            return (long)mh$.invokeExact(hInstance, hDialogTemplate, hWndParent, lpDialogFunc, dwInitParam);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class EndDialog {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_LONG_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("EndDialog"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL EndDialog(HWND hDlg, INT_PTR nResult)
     * }
     */
    public static FunctionDescriptor EndDialog$descriptor() {
        return EndDialog.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL EndDialog(HWND hDlg, INT_PTR nResult)
     * }
     */
    public static MethodHandle EndDialog$handle() {
        return EndDialog.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL EndDialog(HWND hDlg, INT_PTR nResult)
     * }
     */
    public static int EndDialog(MemorySegment hDlg, long nResult) {
        var mh$ = EndDialog.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("EndDialog", hDlg, nResult);
            }
            return (int)mh$.invokeExact(hDlg, nResult);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetDlgItem {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetDlgItem"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HWND GetDlgItem(HWND hDlg, int nIDDlgItem)
     * }
     */
    public static FunctionDescriptor GetDlgItem$descriptor() {
        return GetDlgItem.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HWND GetDlgItem(HWND hDlg, int nIDDlgItem)
     * }
     */
    public static MethodHandle GetDlgItem$handle() {
        return GetDlgItem.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * HWND GetDlgItem(HWND hDlg, int nIDDlgItem)
     * }
     */
    public static MemorySegment GetDlgItem(MemorySegment hDlg, int nIDDlgItem) {
        var mh$ = GetDlgItem.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetDlgItem", hDlg, nIDDlgItem);
            }
            return (MemorySegment)mh$.invokeExact(hDlg, nIDDlgItem);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetDlgItemInt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_INT,
            C_INT,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("SetDlgItemInt"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetDlgItemInt(HWND hDlg, int nIDDlgItem, UINT uValue, BOOL bSigned)
     * }
     */
    public static FunctionDescriptor SetDlgItemInt$descriptor() {
        return SetDlgItemInt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetDlgItemInt(HWND hDlg, int nIDDlgItem, UINT uValue, BOOL bSigned)
     * }
     */
    public static MethodHandle SetDlgItemInt$handle() {
        return SetDlgItemInt.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL SetDlgItemInt(HWND hDlg, int nIDDlgItem, UINT uValue, BOOL bSigned)
     * }
     */
    public static int SetDlgItemInt(MemorySegment hDlg, int nIDDlgItem, int uValue, int bSigned) {
        var mh$ = SetDlgItemInt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetDlgItemInt", hDlg, nIDDlgItem, uValue, bSigned);
            }
            return (int)mh$.invokeExact(hDlg, nIDDlgItem, uValue, bSigned);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetDlgItemInt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_INT,
            C_POINTER,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetDlgItemInt"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * UINT GetDlgItemInt(HWND hDlg, int nIDDlgItem, BOOL *lpTranslated, BOOL bSigned)
     * }
     */
    public static FunctionDescriptor GetDlgItemInt$descriptor() {
        return GetDlgItemInt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * UINT GetDlgItemInt(HWND hDlg, int nIDDlgItem, BOOL *lpTranslated, BOOL bSigned)
     * }
     */
    public static MethodHandle GetDlgItemInt$handle() {
        return GetDlgItemInt.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * UINT GetDlgItemInt(HWND hDlg, int nIDDlgItem, BOOL *lpTranslated, BOOL bSigned)
     * }
     */
    public static int GetDlgItemInt(MemorySegment hDlg, int nIDDlgItem, MemorySegment lpTranslated, int bSigned) {
        var mh$ = GetDlgItemInt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetDlgItemInt", hDlg, nIDDlgItem, lpTranslated, bSigned);
            }
            return (int)mh$.invokeExact(hDlg, nIDDlgItem, lpTranslated, bSigned);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetDlgItemTextA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("SetDlgItemTextA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetDlgItemTextA(HWND hDlg, int nIDDlgItem, LPCSTR lpString)
     * }
     */
    public static FunctionDescriptor SetDlgItemTextA$descriptor() {
        return SetDlgItemTextA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetDlgItemTextA(HWND hDlg, int nIDDlgItem, LPCSTR lpString)
     * }
     */
    public static MethodHandle SetDlgItemTextA$handle() {
        return SetDlgItemTextA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL SetDlgItemTextA(HWND hDlg, int nIDDlgItem, LPCSTR lpString)
     * }
     */
    public static int SetDlgItemTextA(MemorySegment hDlg, int nIDDlgItem, MemorySegment lpString) {
        var mh$ = SetDlgItemTextA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetDlgItemTextA", hDlg, nIDDlgItem, lpString);
            }
            return (int)mh$.invokeExact(hDlg, nIDDlgItem, lpString);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetDlgItemTextW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("SetDlgItemTextW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetDlgItemTextW(HWND hDlg, int nIDDlgItem, LPCWSTR lpString)
     * }
     */
    public static FunctionDescriptor SetDlgItemTextW$descriptor() {
        return SetDlgItemTextW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetDlgItemTextW(HWND hDlg, int nIDDlgItem, LPCWSTR lpString)
     * }
     */
    public static MethodHandle SetDlgItemTextW$handle() {
        return SetDlgItemTextW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL SetDlgItemTextW(HWND hDlg, int nIDDlgItem, LPCWSTR lpString)
     * }
     */
    public static int SetDlgItemTextW(MemorySegment hDlg, int nIDDlgItem, MemorySegment lpString) {
        var mh$ = SetDlgItemTextW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetDlgItemTextW", hDlg, nIDDlgItem, lpString);
            }
            return (int)mh$.invokeExact(hDlg, nIDDlgItem, lpString);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetDlgItemTextA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_INT,
            C_POINTER,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetDlgItemTextA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * UINT GetDlgItemTextA(HWND hDlg, int nIDDlgItem, LPSTR lpString, int cchMax)
     * }
     */
    public static FunctionDescriptor GetDlgItemTextA$descriptor() {
        return GetDlgItemTextA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * UINT GetDlgItemTextA(HWND hDlg, int nIDDlgItem, LPSTR lpString, int cchMax)
     * }
     */
    public static MethodHandle GetDlgItemTextA$handle() {
        return GetDlgItemTextA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * UINT GetDlgItemTextA(HWND hDlg, int nIDDlgItem, LPSTR lpString, int cchMax)
     * }
     */
    public static int GetDlgItemTextA(MemorySegment hDlg, int nIDDlgItem, MemorySegment lpString, int cchMax) {
        var mh$ = GetDlgItemTextA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetDlgItemTextA", hDlg, nIDDlgItem, lpString, cchMax);
            }
            return (int)mh$.invokeExact(hDlg, nIDDlgItem, lpString, cchMax);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetDlgItemTextW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_INT,
            C_POINTER,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetDlgItemTextW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * UINT GetDlgItemTextW(HWND hDlg, int nIDDlgItem, LPWSTR lpString, int cchMax)
     * }
     */
    public static FunctionDescriptor GetDlgItemTextW$descriptor() {
        return GetDlgItemTextW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * UINT GetDlgItemTextW(HWND hDlg, int nIDDlgItem, LPWSTR lpString, int cchMax)
     * }
     */
    public static MethodHandle GetDlgItemTextW$handle() {
        return GetDlgItemTextW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * UINT GetDlgItemTextW(HWND hDlg, int nIDDlgItem, LPWSTR lpString, int cchMax)
     * }
     */
    public static int GetDlgItemTextW(MemorySegment hDlg, int nIDDlgItem, MemorySegment lpString, int cchMax) {
        var mh$ = GetDlgItemTextW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetDlgItemTextW", hDlg, nIDDlgItem, lpString, cchMax);
            }
            return (int)mh$.invokeExact(hDlg, nIDDlgItem, lpString, cchMax);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CheckDlgButton {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_INT,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CheckDlgButton"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CheckDlgButton(HWND hDlg, int nIDButton, UINT uCheck)
     * }
     */
    public static FunctionDescriptor CheckDlgButton$descriptor() {
        return CheckDlgButton.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CheckDlgButton(HWND hDlg, int nIDButton, UINT uCheck)
     * }
     */
    public static MethodHandle CheckDlgButton$handle() {
        return CheckDlgButton.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL CheckDlgButton(HWND hDlg, int nIDButton, UINT uCheck)
     * }
     */
    public static int CheckDlgButton(MemorySegment hDlg, int nIDButton, int uCheck) {
        var mh$ = CheckDlgButton.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CheckDlgButton", hDlg, nIDButton, uCheck);
            }
            return (int)mh$.invokeExact(hDlg, nIDButton, uCheck);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CheckRadioButton {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_INT,
            C_INT,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CheckRadioButton"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CheckRadioButton(HWND hDlg, int nIDFirstButton, int nIDLastButton, int nIDCheckButton)
     * }
     */
    public static FunctionDescriptor CheckRadioButton$descriptor() {
        return CheckRadioButton.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CheckRadioButton(HWND hDlg, int nIDFirstButton, int nIDLastButton, int nIDCheckButton)
     * }
     */
    public static MethodHandle CheckRadioButton$handle() {
        return CheckRadioButton.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL CheckRadioButton(HWND hDlg, int nIDFirstButton, int nIDLastButton, int nIDCheckButton)
     * }
     */
    public static int CheckRadioButton(MemorySegment hDlg, int nIDFirstButton, int nIDLastButton, int nIDCheckButton) {
        var mh$ = CheckRadioButton.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CheckRadioButton", hDlg, nIDFirstButton, nIDLastButton, nIDCheckButton);
            }
            return (int)mh$.invokeExact(hDlg, nIDFirstButton, nIDLastButton, nIDCheckButton);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class IsDlgButtonChecked {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("IsDlgButtonChecked"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * UINT IsDlgButtonChecked(HWND hDlg, int nIDButton)
     * }
     */
    public static FunctionDescriptor IsDlgButtonChecked$descriptor() {
        return IsDlgButtonChecked.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * UINT IsDlgButtonChecked(HWND hDlg, int nIDButton)
     * }
     */
    public static MethodHandle IsDlgButtonChecked$handle() {
        return IsDlgButtonChecked.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * UINT IsDlgButtonChecked(HWND hDlg, int nIDButton)
     * }
     */
    public static int IsDlgButtonChecked(MemorySegment hDlg, int nIDButton) {
        var mh$ = IsDlgButtonChecked.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("IsDlgButtonChecked", hDlg, nIDButton);
            }
            return (int)mh$.invokeExact(hDlg, nIDButton);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SendDlgItemMessageA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG_LONG,
            C_POINTER,
            C_INT,
            C_INT,
            C_LONG_LONG,
            C_LONG_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("SendDlgItemMessageA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LRESULT SendDlgItemMessageA(HWND hDlg, int nIDDlgItem, UINT Msg, WPARAM wParam, LPARAM lParam)
     * }
     */
    public static FunctionDescriptor SendDlgItemMessageA$descriptor() {
        return SendDlgItemMessageA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LRESULT SendDlgItemMessageA(HWND hDlg, int nIDDlgItem, UINT Msg, WPARAM wParam, LPARAM lParam)
     * }
     */
    public static MethodHandle SendDlgItemMessageA$handle() {
        return SendDlgItemMessageA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * LRESULT SendDlgItemMessageA(HWND hDlg, int nIDDlgItem, UINT Msg, WPARAM wParam, LPARAM lParam)
     * }
     */
    public static long SendDlgItemMessageA(MemorySegment hDlg, int nIDDlgItem, int Msg, long wParam, long lParam) {
        var mh$ = SendDlgItemMessageA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SendDlgItemMessageA", hDlg, nIDDlgItem, Msg, wParam, lParam);
            }
            return (long)mh$.invokeExact(hDlg, nIDDlgItem, Msg, wParam, lParam);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SendDlgItemMessageW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG_LONG,
            C_POINTER,
            C_INT,
            C_INT,
            C_LONG_LONG,
            C_LONG_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("SendDlgItemMessageW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LRESULT SendDlgItemMessageW(HWND hDlg, int nIDDlgItem, UINT Msg, WPARAM wParam, LPARAM lParam)
     * }
     */
    public static FunctionDescriptor SendDlgItemMessageW$descriptor() {
        return SendDlgItemMessageW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LRESULT SendDlgItemMessageW(HWND hDlg, int nIDDlgItem, UINT Msg, WPARAM wParam, LPARAM lParam)
     * }
     */
    public static MethodHandle SendDlgItemMessageW$handle() {
        return SendDlgItemMessageW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * LRESULT SendDlgItemMessageW(HWND hDlg, int nIDDlgItem, UINT Msg, WPARAM wParam, LPARAM lParam)
     * }
     */
    public static long SendDlgItemMessageW(MemorySegment hDlg, int nIDDlgItem, int Msg, long wParam, long lParam) {
        var mh$ = SendDlgItemMessageW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SendDlgItemMessageW", hDlg, nIDDlgItem, Msg, wParam, lParam);
            }
            return (long)mh$.invokeExact(hDlg, nIDDlgItem, Msg, wParam, lParam);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetNextDlgGroupItem {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetNextDlgGroupItem"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HWND GetNextDlgGroupItem(HWND hDlg, HWND hCtl, BOOL bPrevious)
     * }
     */
    public static FunctionDescriptor GetNextDlgGroupItem$descriptor() {
        return GetNextDlgGroupItem.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HWND GetNextDlgGroupItem(HWND hDlg, HWND hCtl, BOOL bPrevious)
     * }
     */
    public static MethodHandle GetNextDlgGroupItem$handle() {
        return GetNextDlgGroupItem.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * HWND GetNextDlgGroupItem(HWND hDlg, HWND hCtl, BOOL bPrevious)
     * }
     */
    public static MemorySegment GetNextDlgGroupItem(MemorySegment hDlg, MemorySegment hCtl, int bPrevious) {
        var mh$ = GetNextDlgGroupItem.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetNextDlgGroupItem", hDlg, hCtl, bPrevious);
            }
            return (MemorySegment)mh$.invokeExact(hDlg, hCtl, bPrevious);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetNextDlgTabItem {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetNextDlgTabItem"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HWND GetNextDlgTabItem(HWND hDlg, HWND hCtl, BOOL bPrevious)
     * }
     */
    public static FunctionDescriptor GetNextDlgTabItem$descriptor() {
        return GetNextDlgTabItem.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HWND GetNextDlgTabItem(HWND hDlg, HWND hCtl, BOOL bPrevious)
     * }
     */
    public static MethodHandle GetNextDlgTabItem$handle() {
        return GetNextDlgTabItem.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * HWND GetNextDlgTabItem(HWND hDlg, HWND hCtl, BOOL bPrevious)
     * }
     */
    public static MemorySegment GetNextDlgTabItem(MemorySegment hDlg, MemorySegment hCtl, int bPrevious) {
        var mh$ = GetNextDlgTabItem.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetNextDlgTabItem", hDlg, hCtl, bPrevious);
            }
            return (MemorySegment)mh$.invokeExact(hDlg, hCtl, bPrevious);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetDlgCtrlID {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetDlgCtrlID"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int GetDlgCtrlID(HWND hWnd)
     * }
     */
    public static FunctionDescriptor GetDlgCtrlID$descriptor() {
        return GetDlgCtrlID.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int GetDlgCtrlID(HWND hWnd)
     * }
     */
    public static MethodHandle GetDlgCtrlID$handle() {
        return GetDlgCtrlID.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int GetDlgCtrlID(HWND hWnd)
     * }
     */
    public static int GetDlgCtrlID(MemorySegment hWnd) {
        var mh$ = GetDlgCtrlID.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetDlgCtrlID", hWnd);
            }
            return (int)mh$.invokeExact(hWnd);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetDialogBaseUnits {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG    );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetDialogBaseUnits"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long GetDialogBaseUnits()
     * }
     */
    public static FunctionDescriptor GetDialogBaseUnits$descriptor() {
        return GetDialogBaseUnits.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long GetDialogBaseUnits()
     * }
     */
    public static MethodHandle GetDialogBaseUnits$handle() {
        return GetDialogBaseUnits.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * long GetDialogBaseUnits()
     * }
     */
    public static int GetDialogBaseUnits() {
        var mh$ = GetDialogBaseUnits.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetDialogBaseUnits");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DefDlgProcA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG_LONG,
            C_POINTER,
            C_INT,
            C_LONG_LONG,
            C_LONG_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("DefDlgProcA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LRESULT DefDlgProcA(HWND hDlg, UINT Msg, WPARAM wParam, LPARAM lParam)
     * }
     */
    public static FunctionDescriptor DefDlgProcA$descriptor() {
        return DefDlgProcA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LRESULT DefDlgProcA(HWND hDlg, UINT Msg, WPARAM wParam, LPARAM lParam)
     * }
     */
    public static MethodHandle DefDlgProcA$handle() {
        return DefDlgProcA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * LRESULT DefDlgProcA(HWND hDlg, UINT Msg, WPARAM wParam, LPARAM lParam)
     * }
     */
    public static long DefDlgProcA(MemorySegment hDlg, int Msg, long wParam, long lParam) {
        var mh$ = DefDlgProcA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DefDlgProcA", hDlg, Msg, wParam, lParam);
            }
            return (long)mh$.invokeExact(hDlg, Msg, wParam, lParam);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DefDlgProcW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG_LONG,
            C_POINTER,
            C_INT,
            C_LONG_LONG,
            C_LONG_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("DefDlgProcW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LRESULT DefDlgProcW(HWND hDlg, UINT Msg, WPARAM wParam, LPARAM lParam)
     * }
     */
    public static FunctionDescriptor DefDlgProcW$descriptor() {
        return DefDlgProcW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LRESULT DefDlgProcW(HWND hDlg, UINT Msg, WPARAM wParam, LPARAM lParam)
     * }
     */
    public static MethodHandle DefDlgProcW$handle() {
        return DefDlgProcW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * LRESULT DefDlgProcW(HWND hDlg, UINT Msg, WPARAM wParam, LPARAM lParam)
     * }
     */
    public static long DefDlgProcW(MemorySegment hDlg, int Msg, long wParam, long lParam) {
        var mh$ = DefDlgProcW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DefDlgProcW", hDlg, Msg, wParam, lParam);
            }
            return (long)mh$.invokeExact(hDlg, Msg, wParam, lParam);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int DCDC_DEFAULT = (int)0L;
    /**
     * {@snippet lang=c :
     * enum DIALOG_CONTROL_DPI_CHANGE_BEHAVIORS.DCDC_DEFAULT = 0
     * }
     */
    public static int DCDC_DEFAULT() {
        return DCDC_DEFAULT;
    }
    private static final int DCDC_DISABLE_FONT_UPDATE = (int)1L;
    /**
     * {@snippet lang=c :
     * enum DIALOG_CONTROL_DPI_CHANGE_BEHAVIORS.DCDC_DISABLE_FONT_UPDATE = 1
     * }
     */
    public static int DCDC_DISABLE_FONT_UPDATE() {
        return DCDC_DISABLE_FONT_UPDATE;
    }
    private static final int DCDC_DISABLE_RELAYOUT = (int)2L;
    /**
     * {@snippet lang=c :
     * enum DIALOG_CONTROL_DPI_CHANGE_BEHAVIORS.DCDC_DISABLE_RELAYOUT = 2
     * }
     */
    public static int DCDC_DISABLE_RELAYOUT() {
        return DCDC_DISABLE_RELAYOUT;
    }

    private static class SetDialogControlDpiChangeBehavior {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_INT,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("SetDialogControlDpiChangeBehavior"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetDialogControlDpiChangeBehavior(HWND hWnd, DIALOG_CONTROL_DPI_CHANGE_BEHAVIORS mask, DIALOG_CONTROL_DPI_CHANGE_BEHAVIORS values)
     * }
     */
    public static FunctionDescriptor SetDialogControlDpiChangeBehavior$descriptor() {
        return SetDialogControlDpiChangeBehavior.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetDialogControlDpiChangeBehavior(HWND hWnd, DIALOG_CONTROL_DPI_CHANGE_BEHAVIORS mask, DIALOG_CONTROL_DPI_CHANGE_BEHAVIORS values)
     * }
     */
    public static MethodHandle SetDialogControlDpiChangeBehavior$handle() {
        return SetDialogControlDpiChangeBehavior.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL SetDialogControlDpiChangeBehavior(HWND hWnd, DIALOG_CONTROL_DPI_CHANGE_BEHAVIORS mask, DIALOG_CONTROL_DPI_CHANGE_BEHAVIORS values)
     * }
     */
    public static int SetDialogControlDpiChangeBehavior(MemorySegment hWnd, int mask, int values) {
        var mh$ = SetDialogControlDpiChangeBehavior.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetDialogControlDpiChangeBehavior", hWnd, mask, values);
            }
            return (int)mh$.invokeExact(hWnd, mask, values);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetDialogControlDpiChangeBehavior {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetDialogControlDpiChangeBehavior"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DIALOG_CONTROL_DPI_CHANGE_BEHAVIORS GetDialogControlDpiChangeBehavior(HWND hWnd)
     * }
     */
    public static FunctionDescriptor GetDialogControlDpiChangeBehavior$descriptor() {
        return GetDialogControlDpiChangeBehavior.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DIALOG_CONTROL_DPI_CHANGE_BEHAVIORS GetDialogControlDpiChangeBehavior(HWND hWnd)
     * }
     */
    public static MethodHandle GetDialogControlDpiChangeBehavior$handle() {
        return GetDialogControlDpiChangeBehavior.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * DIALOG_CONTROL_DPI_CHANGE_BEHAVIORS GetDialogControlDpiChangeBehavior(HWND hWnd)
     * }
     */
    public static int GetDialogControlDpiChangeBehavior(MemorySegment hWnd) {
        var mh$ = GetDialogControlDpiChangeBehavior.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetDialogControlDpiChangeBehavior", hWnd);
            }
            return (int)mh$.invokeExact(hWnd);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int DDC_DEFAULT = (int)0L;
    /**
     * {@snippet lang=c :
     * enum DIALOG_DPI_CHANGE_BEHAVIORS.DDC_DEFAULT = 0
     * }
     */
    public static int DDC_DEFAULT() {
        return DDC_DEFAULT;
    }
    private static final int DDC_DISABLE_ALL = (int)1L;
    /**
     * {@snippet lang=c :
     * enum DIALOG_DPI_CHANGE_BEHAVIORS.DDC_DISABLE_ALL = 1
     * }
     */
    public static int DDC_DISABLE_ALL() {
        return DDC_DISABLE_ALL;
    }
    private static final int DDC_DISABLE_RESIZE = (int)2L;
    /**
     * {@snippet lang=c :
     * enum DIALOG_DPI_CHANGE_BEHAVIORS.DDC_DISABLE_RESIZE = 2
     * }
     */
    public static int DDC_DISABLE_RESIZE() {
        return DDC_DISABLE_RESIZE;
    }
    private static final int DDC_DISABLE_CONTROL_RELAYOUT = (int)4L;
    /**
     * {@snippet lang=c :
     * enum DIALOG_DPI_CHANGE_BEHAVIORS.DDC_DISABLE_CONTROL_RELAYOUT = 4
     * }
     */
    public static int DDC_DISABLE_CONTROL_RELAYOUT() {
        return DDC_DISABLE_CONTROL_RELAYOUT;
    }

    private static class SetDialogDpiChangeBehavior {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_INT,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("SetDialogDpiChangeBehavior"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetDialogDpiChangeBehavior(HWND hDlg, DIALOG_DPI_CHANGE_BEHAVIORS mask, DIALOG_DPI_CHANGE_BEHAVIORS values)
     * }
     */
    public static FunctionDescriptor SetDialogDpiChangeBehavior$descriptor() {
        return SetDialogDpiChangeBehavior.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetDialogDpiChangeBehavior(HWND hDlg, DIALOG_DPI_CHANGE_BEHAVIORS mask, DIALOG_DPI_CHANGE_BEHAVIORS values)
     * }
     */
    public static MethodHandle SetDialogDpiChangeBehavior$handle() {
        return SetDialogDpiChangeBehavior.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL SetDialogDpiChangeBehavior(HWND hDlg, DIALOG_DPI_CHANGE_BEHAVIORS mask, DIALOG_DPI_CHANGE_BEHAVIORS values)
     * }
     */
    public static int SetDialogDpiChangeBehavior(MemorySegment hDlg, int mask, int values) {
        var mh$ = SetDialogDpiChangeBehavior.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetDialogDpiChangeBehavior", hDlg, mask, values);
            }
            return (int)mh$.invokeExact(hDlg, mask, values);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetDialogDpiChangeBehavior {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetDialogDpiChangeBehavior"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DIALOG_DPI_CHANGE_BEHAVIORS GetDialogDpiChangeBehavior(HWND hDlg)
     * }
     */
    public static FunctionDescriptor GetDialogDpiChangeBehavior$descriptor() {
        return GetDialogDpiChangeBehavior.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DIALOG_DPI_CHANGE_BEHAVIORS GetDialogDpiChangeBehavior(HWND hDlg)
     * }
     */
    public static MethodHandle GetDialogDpiChangeBehavior$handle() {
        return GetDialogDpiChangeBehavior.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * DIALOG_DPI_CHANGE_BEHAVIORS GetDialogDpiChangeBehavior(HWND hDlg)
     * }
     */
    public static int GetDialogDpiChangeBehavior(MemorySegment hDlg) {
        var mh$ = GetDialogDpiChangeBehavior.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetDialogDpiChangeBehavior", hDlg);
            }
            return (int)mh$.invokeExact(hDlg);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CallMsgFilterA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CallMsgFilterA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CallMsgFilterA(LPMSG lpMsg, int nCode)
     * }
     */
    public static FunctionDescriptor CallMsgFilterA$descriptor() {
        return CallMsgFilterA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CallMsgFilterA(LPMSG lpMsg, int nCode)
     * }
     */
    public static MethodHandle CallMsgFilterA$handle() {
        return CallMsgFilterA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL CallMsgFilterA(LPMSG lpMsg, int nCode)
     * }
     */
    public static int CallMsgFilterA(MemorySegment lpMsg, int nCode) {
        var mh$ = CallMsgFilterA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CallMsgFilterA", lpMsg, nCode);
            }
            return (int)mh$.invokeExact(lpMsg, nCode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CallMsgFilterW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CallMsgFilterW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CallMsgFilterW(LPMSG lpMsg, int nCode)
     * }
     */
    public static FunctionDescriptor CallMsgFilterW$descriptor() {
        return CallMsgFilterW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CallMsgFilterW(LPMSG lpMsg, int nCode)
     * }
     */
    public static MethodHandle CallMsgFilterW$handle() {
        return CallMsgFilterW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL CallMsgFilterW(LPMSG lpMsg, int nCode)
     * }
     */
    public static int CallMsgFilterW(MemorySegment lpMsg, int nCode) {
        var mh$ = CallMsgFilterW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CallMsgFilterW", lpMsg, nCode);
            }
            return (int)mh$.invokeExact(lpMsg, nCode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class OpenClipboard {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("OpenClipboard"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL OpenClipboard(HWND hWndNewOwner)
     * }
     */
    public static FunctionDescriptor OpenClipboard$descriptor() {
        return OpenClipboard.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL OpenClipboard(HWND hWndNewOwner)
     * }
     */
    public static MethodHandle OpenClipboard$handle() {
        return OpenClipboard.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL OpenClipboard(HWND hWndNewOwner)
     * }
     */
    public static int OpenClipboard(MemorySegment hWndNewOwner) {
        var mh$ = OpenClipboard.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("OpenClipboard", hWndNewOwner);
            }
            return (int)mh$.invokeExact(hWndNewOwner);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CloseClipboard {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT    );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CloseClipboard"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CloseClipboard()
     * }
     */
    public static FunctionDescriptor CloseClipboard$descriptor() {
        return CloseClipboard.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CloseClipboard()
     * }
     */
    public static MethodHandle CloseClipboard$handle() {
        return CloseClipboard.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL CloseClipboard()
     * }
     */
    public static int CloseClipboard() {
        var mh$ = CloseClipboard.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CloseClipboard");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetClipboardSequenceNumber {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG    );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetClipboardSequenceNumber"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetClipboardSequenceNumber()
     * }
     */
    public static FunctionDescriptor GetClipboardSequenceNumber$descriptor() {
        return GetClipboardSequenceNumber.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetClipboardSequenceNumber()
     * }
     */
    public static MethodHandle GetClipboardSequenceNumber$handle() {
        return GetClipboardSequenceNumber.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * DWORD GetClipboardSequenceNumber()
     * }
     */
    public static int GetClipboardSequenceNumber() {
        var mh$ = GetClipboardSequenceNumber.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetClipboardSequenceNumber");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetClipboardOwner {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER    );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetClipboardOwner"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HWND GetClipboardOwner()
     * }
     */
    public static FunctionDescriptor GetClipboardOwner$descriptor() {
        return GetClipboardOwner.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HWND GetClipboardOwner()
     * }
     */
    public static MethodHandle GetClipboardOwner$handle() {
        return GetClipboardOwner.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * HWND GetClipboardOwner()
     * }
     */
    public static MemorySegment GetClipboardOwner() {
        var mh$ = GetClipboardOwner.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetClipboardOwner");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetClipboardViewer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("SetClipboardViewer"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HWND SetClipboardViewer(HWND hWndNewViewer)
     * }
     */
    public static FunctionDescriptor SetClipboardViewer$descriptor() {
        return SetClipboardViewer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HWND SetClipboardViewer(HWND hWndNewViewer)
     * }
     */
    public static MethodHandle SetClipboardViewer$handle() {
        return SetClipboardViewer.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * HWND SetClipboardViewer(HWND hWndNewViewer)
     * }
     */
    public static MemorySegment SetClipboardViewer(MemorySegment hWndNewViewer) {
        var mh$ = SetClipboardViewer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetClipboardViewer", hWndNewViewer);
            }
            return (MemorySegment)mh$.invokeExact(hWndNewViewer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetClipboardViewer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER    );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetClipboardViewer"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HWND GetClipboardViewer()
     * }
     */
    public static FunctionDescriptor GetClipboardViewer$descriptor() {
        return GetClipboardViewer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HWND GetClipboardViewer()
     * }
     */
    public static MethodHandle GetClipboardViewer$handle() {
        return GetClipboardViewer.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * HWND GetClipboardViewer()
     * }
     */
    public static MemorySegment GetClipboardViewer() {
        var mh$ = GetClipboardViewer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetClipboardViewer");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ChangeClipboardChain {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("ChangeClipboardChain"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL ChangeClipboardChain(HWND hWndRemove, HWND hWndNewNext)
     * }
     */
    public static FunctionDescriptor ChangeClipboardChain$descriptor() {
        return ChangeClipboardChain.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL ChangeClipboardChain(HWND hWndRemove, HWND hWndNewNext)
     * }
     */
    public static MethodHandle ChangeClipboardChain$handle() {
        return ChangeClipboardChain.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL ChangeClipboardChain(HWND hWndRemove, HWND hWndNewNext)
     * }
     */
    public static int ChangeClipboardChain(MemorySegment hWndRemove, MemorySegment hWndNewNext) {
        var mh$ = ChangeClipboardChain.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ChangeClipboardChain", hWndRemove, hWndNewNext);
            }
            return (int)mh$.invokeExact(hWndRemove, hWndNewNext);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetClipboardData {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("SetClipboardData"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HANDLE SetClipboardData(UINT uFormat, HANDLE hMem)
     * }
     */
    public static FunctionDescriptor SetClipboardData$descriptor() {
        return SetClipboardData.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HANDLE SetClipboardData(UINT uFormat, HANDLE hMem)
     * }
     */
    public static MethodHandle SetClipboardData$handle() {
        return SetClipboardData.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * HANDLE SetClipboardData(UINT uFormat, HANDLE hMem)
     * }
     */
    public static MemorySegment SetClipboardData(int uFormat, MemorySegment hMem) {
        var mh$ = SetClipboardData.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetClipboardData", uFormat, hMem);
            }
            return (MemorySegment)mh$.invokeExact(uFormat, hMem);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetClipboardData {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetClipboardData"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HANDLE GetClipboardData(UINT uFormat)
     * }
     */
    public static FunctionDescriptor GetClipboardData$descriptor() {
        return GetClipboardData.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HANDLE GetClipboardData(UINT uFormat)
     * }
     */
    public static MethodHandle GetClipboardData$handle() {
        return GetClipboardData.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * HANDLE GetClipboardData(UINT uFormat)
     * }
     */
    public static MemorySegment GetClipboardData(int uFormat) {
        var mh$ = GetClipboardData.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetClipboardData", uFormat);
            }
            return (MemorySegment)mh$.invokeExact(uFormat);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RegisterClipboardFormatA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("RegisterClipboardFormatA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * UINT RegisterClipboardFormatA(LPCSTR lpszFormat)
     * }
     */
    public static FunctionDescriptor RegisterClipboardFormatA$descriptor() {
        return RegisterClipboardFormatA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * UINT RegisterClipboardFormatA(LPCSTR lpszFormat)
     * }
     */
    public static MethodHandle RegisterClipboardFormatA$handle() {
        return RegisterClipboardFormatA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * UINT RegisterClipboardFormatA(LPCSTR lpszFormat)
     * }
     */
    public static int RegisterClipboardFormatA(MemorySegment lpszFormat) {
        var mh$ = RegisterClipboardFormatA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RegisterClipboardFormatA", lpszFormat);
            }
            return (int)mh$.invokeExact(lpszFormat);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RegisterClipboardFormatW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("RegisterClipboardFormatW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * UINT RegisterClipboardFormatW(LPCWSTR lpszFormat)
     * }
     */
    public static FunctionDescriptor RegisterClipboardFormatW$descriptor() {
        return RegisterClipboardFormatW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * UINT RegisterClipboardFormatW(LPCWSTR lpszFormat)
     * }
     */
    public static MethodHandle RegisterClipboardFormatW$handle() {
        return RegisterClipboardFormatW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * UINT RegisterClipboardFormatW(LPCWSTR lpszFormat)
     * }
     */
    public static int RegisterClipboardFormatW(MemorySegment lpszFormat) {
        var mh$ = RegisterClipboardFormatW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RegisterClipboardFormatW", lpszFormat);
            }
            return (int)mh$.invokeExact(lpszFormat);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CountClipboardFormats {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT    );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CountClipboardFormats"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int CountClipboardFormats()
     * }
     */
    public static FunctionDescriptor CountClipboardFormats$descriptor() {
        return CountClipboardFormats.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int CountClipboardFormats()
     * }
     */
    public static MethodHandle CountClipboardFormats$handle() {
        return CountClipboardFormats.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int CountClipboardFormats()
     * }
     */
    public static int CountClipboardFormats() {
        var mh$ = CountClipboardFormats.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CountClipboardFormats");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class EnumClipboardFormats {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("EnumClipboardFormats"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * UINT EnumClipboardFormats(UINT format)
     * }
     */
    public static FunctionDescriptor EnumClipboardFormats$descriptor() {
        return EnumClipboardFormats.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * UINT EnumClipboardFormats(UINT format)
     * }
     */
    public static MethodHandle EnumClipboardFormats$handle() {
        return EnumClipboardFormats.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * UINT EnumClipboardFormats(UINT format)
     * }
     */
    public static int EnumClipboardFormats(int format) {
        var mh$ = EnumClipboardFormats.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("EnumClipboardFormats", format);
            }
            return (int)mh$.invokeExact(format);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetClipboardFormatNameA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_INT,
            C_POINTER,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetClipboardFormatNameA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int GetClipboardFormatNameA(UINT format, LPSTR lpszFormatName, int cchMaxCount)
     * }
     */
    public static FunctionDescriptor GetClipboardFormatNameA$descriptor() {
        return GetClipboardFormatNameA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int GetClipboardFormatNameA(UINT format, LPSTR lpszFormatName, int cchMaxCount)
     * }
     */
    public static MethodHandle GetClipboardFormatNameA$handle() {
        return GetClipboardFormatNameA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int GetClipboardFormatNameA(UINT format, LPSTR lpszFormatName, int cchMaxCount)
     * }
     */
    public static int GetClipboardFormatNameA(int format, MemorySegment lpszFormatName, int cchMaxCount) {
        var mh$ = GetClipboardFormatNameA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetClipboardFormatNameA", format, lpszFormatName, cchMaxCount);
            }
            return (int)mh$.invokeExact(format, lpszFormatName, cchMaxCount);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetClipboardFormatNameW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_INT,
            C_POINTER,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetClipboardFormatNameW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int GetClipboardFormatNameW(UINT format, LPWSTR lpszFormatName, int cchMaxCount)
     * }
     */
    public static FunctionDescriptor GetClipboardFormatNameW$descriptor() {
        return GetClipboardFormatNameW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int GetClipboardFormatNameW(UINT format, LPWSTR lpszFormatName, int cchMaxCount)
     * }
     */
    public static MethodHandle GetClipboardFormatNameW$handle() {
        return GetClipboardFormatNameW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int GetClipboardFormatNameW(UINT format, LPWSTR lpszFormatName, int cchMaxCount)
     * }
     */
    public static int GetClipboardFormatNameW(int format, MemorySegment lpszFormatName, int cchMaxCount) {
        var mh$ = GetClipboardFormatNameW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetClipboardFormatNameW", format, lpszFormatName, cchMaxCount);
            }
            return (int)mh$.invokeExact(format, lpszFormatName, cchMaxCount);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class EmptyClipboard {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT    );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("EmptyClipboard"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL EmptyClipboard()
     * }
     */
    public static FunctionDescriptor EmptyClipboard$descriptor() {
        return EmptyClipboard.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL EmptyClipboard()
     * }
     */
    public static MethodHandle EmptyClipboard$handle() {
        return EmptyClipboard.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL EmptyClipboard()
     * }
     */
    public static int EmptyClipboard() {
        var mh$ = EmptyClipboard.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("EmptyClipboard");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class IsClipboardFormatAvailable {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("IsClipboardFormatAvailable"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL IsClipboardFormatAvailable(UINT format)
     * }
     */
    public static FunctionDescriptor IsClipboardFormatAvailable$descriptor() {
        return IsClipboardFormatAvailable.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL IsClipboardFormatAvailable(UINT format)
     * }
     */
    public static MethodHandle IsClipboardFormatAvailable$handle() {
        return IsClipboardFormatAvailable.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL IsClipboardFormatAvailable(UINT format)
     * }
     */
    public static int IsClipboardFormatAvailable(int format) {
        var mh$ = IsClipboardFormatAvailable.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("IsClipboardFormatAvailable", format);
            }
            return (int)mh$.invokeExact(format);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetPriorityClipboardFormat {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetPriorityClipboardFormat"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int GetPriorityClipboardFormat(UINT *paFormatPriorityList, int cFormats)
     * }
     */
    public static FunctionDescriptor GetPriorityClipboardFormat$descriptor() {
        return GetPriorityClipboardFormat.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int GetPriorityClipboardFormat(UINT *paFormatPriorityList, int cFormats)
     * }
     */
    public static MethodHandle GetPriorityClipboardFormat$handle() {
        return GetPriorityClipboardFormat.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int GetPriorityClipboardFormat(UINT *paFormatPriorityList, int cFormats)
     * }
     */
    public static int GetPriorityClipboardFormat(MemorySegment paFormatPriorityList, int cFormats) {
        var mh$ = GetPriorityClipboardFormat.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetPriorityClipboardFormat", paFormatPriorityList, cFormats);
            }
            return (int)mh$.invokeExact(paFormatPriorityList, cFormats);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetOpenClipboardWindow {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER    );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetOpenClipboardWindow"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HWND GetOpenClipboardWindow()
     * }
     */
    public static FunctionDescriptor GetOpenClipboardWindow$descriptor() {
        return GetOpenClipboardWindow.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HWND GetOpenClipboardWindow()
     * }
     */
    public static MethodHandle GetOpenClipboardWindow$handle() {
        return GetOpenClipboardWindow.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * HWND GetOpenClipboardWindow()
     * }
     */
    public static MemorySegment GetOpenClipboardWindow() {
        var mh$ = GetOpenClipboardWindow.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetOpenClipboardWindow");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class AddClipboardFormatListener {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("AddClipboardFormatListener"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL AddClipboardFormatListener(HWND hwnd)
     * }
     */
    public static FunctionDescriptor AddClipboardFormatListener$descriptor() {
        return AddClipboardFormatListener.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL AddClipboardFormatListener(HWND hwnd)
     * }
     */
    public static MethodHandle AddClipboardFormatListener$handle() {
        return AddClipboardFormatListener.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL AddClipboardFormatListener(HWND hwnd)
     * }
     */
    public static int AddClipboardFormatListener(MemorySegment hwnd) {
        var mh$ = AddClipboardFormatListener.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("AddClipboardFormatListener", hwnd);
            }
            return (int)mh$.invokeExact(hwnd);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RemoveClipboardFormatListener {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("RemoveClipboardFormatListener"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL RemoveClipboardFormatListener(HWND hwnd)
     * }
     */
    public static FunctionDescriptor RemoveClipboardFormatListener$descriptor() {
        return RemoveClipboardFormatListener.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL RemoveClipboardFormatListener(HWND hwnd)
     * }
     */
    public static MethodHandle RemoveClipboardFormatListener$handle() {
        return RemoveClipboardFormatListener.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL RemoveClipboardFormatListener(HWND hwnd)
     * }
     */
    public static int RemoveClipboardFormatListener(MemorySegment hwnd) {
        var mh$ = RemoveClipboardFormatListener.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RemoveClipboardFormatListener", hwnd);
            }
            return (int)mh$.invokeExact(hwnd);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetUpdatedClipboardFormats {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetUpdatedClipboardFormats"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetUpdatedClipboardFormats(PUINT lpuiFormats, UINT cFormats, PUINT pcFormatsOut)
     * }
     */
    public static FunctionDescriptor GetUpdatedClipboardFormats$descriptor() {
        return GetUpdatedClipboardFormats.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetUpdatedClipboardFormats(PUINT lpuiFormats, UINT cFormats, PUINT pcFormatsOut)
     * }
     */
    public static MethodHandle GetUpdatedClipboardFormats$handle() {
        return GetUpdatedClipboardFormats.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL GetUpdatedClipboardFormats(PUINT lpuiFormats, UINT cFormats, PUINT pcFormatsOut)
     * }
     */
    public static int GetUpdatedClipboardFormats(MemorySegment lpuiFormats, int cFormats, MemorySegment pcFormatsOut) {
        var mh$ = GetUpdatedClipboardFormats.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetUpdatedClipboardFormats", lpuiFormats, cFormats, pcFormatsOut);
            }
            return (int)mh$.invokeExact(lpuiFormats, cFormats, pcFormatsOut);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CharToOemA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CharToOemA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CharToOemA(LPCSTR pSrc, LPSTR pDst)
     * }
     */
    public static FunctionDescriptor CharToOemA$descriptor() {
        return CharToOemA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CharToOemA(LPCSTR pSrc, LPSTR pDst)
     * }
     */
    public static MethodHandle CharToOemA$handle() {
        return CharToOemA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL CharToOemA(LPCSTR pSrc, LPSTR pDst)
     * }
     */
    public static int CharToOemA(MemorySegment pSrc, MemorySegment pDst) {
        var mh$ = CharToOemA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CharToOemA", pSrc, pDst);
            }
            return (int)mh$.invokeExact(pSrc, pDst);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CharToOemW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CharToOemW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CharToOemW(LPCWSTR pSrc, LPSTR pDst)
     * }
     */
    public static FunctionDescriptor CharToOemW$descriptor() {
        return CharToOemW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CharToOemW(LPCWSTR pSrc, LPSTR pDst)
     * }
     */
    public static MethodHandle CharToOemW$handle() {
        return CharToOemW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL CharToOemW(LPCWSTR pSrc, LPSTR pDst)
     * }
     */
    public static int CharToOemW(MemorySegment pSrc, MemorySegment pDst) {
        var mh$ = CharToOemW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CharToOemW", pSrc, pDst);
            }
            return (int)mh$.invokeExact(pSrc, pDst);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class OemToCharA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("OemToCharA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL OemToCharA(LPCSTR pSrc, LPSTR pDst)
     * }
     */
    public static FunctionDescriptor OemToCharA$descriptor() {
        return OemToCharA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL OemToCharA(LPCSTR pSrc, LPSTR pDst)
     * }
     */
    public static MethodHandle OemToCharA$handle() {
        return OemToCharA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL OemToCharA(LPCSTR pSrc, LPSTR pDst)
     * }
     */
    public static int OemToCharA(MemorySegment pSrc, MemorySegment pDst) {
        var mh$ = OemToCharA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("OemToCharA", pSrc, pDst);
            }
            return (int)mh$.invokeExact(pSrc, pDst);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class OemToCharW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("OemToCharW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL OemToCharW(LPCSTR pSrc, LPWSTR pDst)
     * }
     */
    public static FunctionDescriptor OemToCharW$descriptor() {
        return OemToCharW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL OemToCharW(LPCSTR pSrc, LPWSTR pDst)
     * }
     */
    public static MethodHandle OemToCharW$handle() {
        return OemToCharW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL OemToCharW(LPCSTR pSrc, LPWSTR pDst)
     * }
     */
    public static int OemToCharW(MemorySegment pSrc, MemorySegment pDst) {
        var mh$ = OemToCharW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("OemToCharW", pSrc, pDst);
            }
            return (int)mh$.invokeExact(pSrc, pDst);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CharToOemBuffA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CharToOemBuffA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CharToOemBuffA(LPCSTR lpszSrc, LPSTR lpszDst, DWORD cchDstLength)
     * }
     */
    public static FunctionDescriptor CharToOemBuffA$descriptor() {
        return CharToOemBuffA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CharToOemBuffA(LPCSTR lpszSrc, LPSTR lpszDst, DWORD cchDstLength)
     * }
     */
    public static MethodHandle CharToOemBuffA$handle() {
        return CharToOemBuffA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL CharToOemBuffA(LPCSTR lpszSrc, LPSTR lpszDst, DWORD cchDstLength)
     * }
     */
    public static int CharToOemBuffA(MemorySegment lpszSrc, MemorySegment lpszDst, int cchDstLength) {
        var mh$ = CharToOemBuffA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CharToOemBuffA", lpszSrc, lpszDst, cchDstLength);
            }
            return (int)mh$.invokeExact(lpszSrc, lpszDst, cchDstLength);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CharToOemBuffW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CharToOemBuffW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CharToOemBuffW(LPCWSTR lpszSrc, LPSTR lpszDst, DWORD cchDstLength)
     * }
     */
    public static FunctionDescriptor CharToOemBuffW$descriptor() {
        return CharToOemBuffW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CharToOemBuffW(LPCWSTR lpszSrc, LPSTR lpszDst, DWORD cchDstLength)
     * }
     */
    public static MethodHandle CharToOemBuffW$handle() {
        return CharToOemBuffW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL CharToOemBuffW(LPCWSTR lpszSrc, LPSTR lpszDst, DWORD cchDstLength)
     * }
     */
    public static int CharToOemBuffW(MemorySegment lpszSrc, MemorySegment lpszDst, int cchDstLength) {
        var mh$ = CharToOemBuffW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CharToOemBuffW", lpszSrc, lpszDst, cchDstLength);
            }
            return (int)mh$.invokeExact(lpszSrc, lpszDst, cchDstLength);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class OemToCharBuffA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("OemToCharBuffA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL OemToCharBuffA(LPCSTR lpszSrc, LPSTR lpszDst, DWORD cchDstLength)
     * }
     */
    public static FunctionDescriptor OemToCharBuffA$descriptor() {
        return OemToCharBuffA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL OemToCharBuffA(LPCSTR lpszSrc, LPSTR lpszDst, DWORD cchDstLength)
     * }
     */
    public static MethodHandle OemToCharBuffA$handle() {
        return OemToCharBuffA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL OemToCharBuffA(LPCSTR lpszSrc, LPSTR lpszDst, DWORD cchDstLength)
     * }
     */
    public static int OemToCharBuffA(MemorySegment lpszSrc, MemorySegment lpszDst, int cchDstLength) {
        var mh$ = OemToCharBuffA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("OemToCharBuffA", lpszSrc, lpszDst, cchDstLength);
            }
            return (int)mh$.invokeExact(lpszSrc, lpszDst, cchDstLength);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class OemToCharBuffW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("OemToCharBuffW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL OemToCharBuffW(LPCSTR lpszSrc, LPWSTR lpszDst, DWORD cchDstLength)
     * }
     */
    public static FunctionDescriptor OemToCharBuffW$descriptor() {
        return OemToCharBuffW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL OemToCharBuffW(LPCSTR lpszSrc, LPWSTR lpszDst, DWORD cchDstLength)
     * }
     */
    public static MethodHandle OemToCharBuffW$handle() {
        return OemToCharBuffW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL OemToCharBuffW(LPCSTR lpszSrc, LPWSTR lpszDst, DWORD cchDstLength)
     * }
     */
    public static int OemToCharBuffW(MemorySegment lpszSrc, MemorySegment lpszDst, int cchDstLength) {
        var mh$ = OemToCharBuffW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("OemToCharBuffW", lpszSrc, lpszDst, cchDstLength);
            }
            return (int)mh$.invokeExact(lpszSrc, lpszDst, cchDstLength);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CharUpperA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CharUpperA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LPSTR CharUpperA(LPSTR lpsz)
     * }
     */
    public static FunctionDescriptor CharUpperA$descriptor() {
        return CharUpperA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LPSTR CharUpperA(LPSTR lpsz)
     * }
     */
    public static MethodHandle CharUpperA$handle() {
        return CharUpperA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * LPSTR CharUpperA(LPSTR lpsz)
     * }
     */
    public static MemorySegment CharUpperA(MemorySegment lpsz) {
        var mh$ = CharUpperA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CharUpperA", lpsz);
            }
            return (MemorySegment)mh$.invokeExact(lpsz);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CharUpperW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CharUpperW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LPWSTR CharUpperW(LPWSTR lpsz)
     * }
     */
    public static FunctionDescriptor CharUpperW$descriptor() {
        return CharUpperW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LPWSTR CharUpperW(LPWSTR lpsz)
     * }
     */
    public static MethodHandle CharUpperW$handle() {
        return CharUpperW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * LPWSTR CharUpperW(LPWSTR lpsz)
     * }
     */
    public static MemorySegment CharUpperW(MemorySegment lpsz) {
        var mh$ = CharUpperW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CharUpperW", lpsz);
            }
            return (MemorySegment)mh$.invokeExact(lpsz);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CharUpperBuffA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_POINTER,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CharUpperBuffA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD CharUpperBuffA(LPSTR lpsz, DWORD cchLength)
     * }
     */
    public static FunctionDescriptor CharUpperBuffA$descriptor() {
        return CharUpperBuffA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD CharUpperBuffA(LPSTR lpsz, DWORD cchLength)
     * }
     */
    public static MethodHandle CharUpperBuffA$handle() {
        return CharUpperBuffA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * DWORD CharUpperBuffA(LPSTR lpsz, DWORD cchLength)
     * }
     */
    public static int CharUpperBuffA(MemorySegment lpsz, int cchLength) {
        var mh$ = CharUpperBuffA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CharUpperBuffA", lpsz, cchLength);
            }
            return (int)mh$.invokeExact(lpsz, cchLength);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CharUpperBuffW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_POINTER,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CharUpperBuffW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD CharUpperBuffW(LPWSTR lpsz, DWORD cchLength)
     * }
     */
    public static FunctionDescriptor CharUpperBuffW$descriptor() {
        return CharUpperBuffW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD CharUpperBuffW(LPWSTR lpsz, DWORD cchLength)
     * }
     */
    public static MethodHandle CharUpperBuffW$handle() {
        return CharUpperBuffW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * DWORD CharUpperBuffW(LPWSTR lpsz, DWORD cchLength)
     * }
     */
    public static int CharUpperBuffW(MemorySegment lpsz, int cchLength) {
        var mh$ = CharUpperBuffW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CharUpperBuffW", lpsz, cchLength);
            }
            return (int)mh$.invokeExact(lpsz, cchLength);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CharLowerA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CharLowerA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LPSTR CharLowerA(LPSTR lpsz)
     * }
     */
    public static FunctionDescriptor CharLowerA$descriptor() {
        return CharLowerA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LPSTR CharLowerA(LPSTR lpsz)
     * }
     */
    public static MethodHandle CharLowerA$handle() {
        return CharLowerA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * LPSTR CharLowerA(LPSTR lpsz)
     * }
     */
    public static MemorySegment CharLowerA(MemorySegment lpsz) {
        var mh$ = CharLowerA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CharLowerA", lpsz);
            }
            return (MemorySegment)mh$.invokeExact(lpsz);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CharLowerW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CharLowerW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LPWSTR CharLowerW(LPWSTR lpsz)
     * }
     */
    public static FunctionDescriptor CharLowerW$descriptor() {
        return CharLowerW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LPWSTR CharLowerW(LPWSTR lpsz)
     * }
     */
    public static MethodHandle CharLowerW$handle() {
        return CharLowerW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * LPWSTR CharLowerW(LPWSTR lpsz)
     * }
     */
    public static MemorySegment CharLowerW(MemorySegment lpsz) {
        var mh$ = CharLowerW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CharLowerW", lpsz);
            }
            return (MemorySegment)mh$.invokeExact(lpsz);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CharLowerBuffA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_POINTER,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CharLowerBuffA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD CharLowerBuffA(LPSTR lpsz, DWORD cchLength)
     * }
     */
    public static FunctionDescriptor CharLowerBuffA$descriptor() {
        return CharLowerBuffA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD CharLowerBuffA(LPSTR lpsz, DWORD cchLength)
     * }
     */
    public static MethodHandle CharLowerBuffA$handle() {
        return CharLowerBuffA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * DWORD CharLowerBuffA(LPSTR lpsz, DWORD cchLength)
     * }
     */
    public static int CharLowerBuffA(MemorySegment lpsz, int cchLength) {
        var mh$ = CharLowerBuffA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CharLowerBuffA", lpsz, cchLength);
            }
            return (int)mh$.invokeExact(lpsz, cchLength);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CharLowerBuffW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_POINTER,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CharLowerBuffW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD CharLowerBuffW(LPWSTR lpsz, DWORD cchLength)
     * }
     */
    public static FunctionDescriptor CharLowerBuffW$descriptor() {
        return CharLowerBuffW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD CharLowerBuffW(LPWSTR lpsz, DWORD cchLength)
     * }
     */
    public static MethodHandle CharLowerBuffW$handle() {
        return CharLowerBuffW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * DWORD CharLowerBuffW(LPWSTR lpsz, DWORD cchLength)
     * }
     */
    public static int CharLowerBuffW(MemorySegment lpsz, int cchLength) {
        var mh$ = CharLowerBuffW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CharLowerBuffW", lpsz, cchLength);
            }
            return (int)mh$.invokeExact(lpsz, cchLength);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CharNextA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CharNextA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LPSTR CharNextA(LPCSTR lpsz)
     * }
     */
    public static FunctionDescriptor CharNextA$descriptor() {
        return CharNextA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LPSTR CharNextA(LPCSTR lpsz)
     * }
     */
    public static MethodHandle CharNextA$handle() {
        return CharNextA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * LPSTR CharNextA(LPCSTR lpsz)
     * }
     */
    public static MemorySegment CharNextA(MemorySegment lpsz) {
        var mh$ = CharNextA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CharNextA", lpsz);
            }
            return (MemorySegment)mh$.invokeExact(lpsz);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CharNextW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CharNextW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LPWSTR CharNextW(LPCWSTR lpsz)
     * }
     */
    public static FunctionDescriptor CharNextW$descriptor() {
        return CharNextW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LPWSTR CharNextW(LPCWSTR lpsz)
     * }
     */
    public static MethodHandle CharNextW$handle() {
        return CharNextW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * LPWSTR CharNextW(LPCWSTR lpsz)
     * }
     */
    public static MemorySegment CharNextW(MemorySegment lpsz) {
        var mh$ = CharNextW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CharNextW", lpsz);
            }
            return (MemorySegment)mh$.invokeExact(lpsz);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CharPrevA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CharPrevA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LPSTR CharPrevA(LPCSTR lpszStart, LPCSTR lpszCurrent)
     * }
     */
    public static FunctionDescriptor CharPrevA$descriptor() {
        return CharPrevA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LPSTR CharPrevA(LPCSTR lpszStart, LPCSTR lpszCurrent)
     * }
     */
    public static MethodHandle CharPrevA$handle() {
        return CharPrevA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * LPSTR CharPrevA(LPCSTR lpszStart, LPCSTR lpszCurrent)
     * }
     */
    public static MemorySegment CharPrevA(MemorySegment lpszStart, MemorySegment lpszCurrent) {
        var mh$ = CharPrevA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CharPrevA", lpszStart, lpszCurrent);
            }
            return (MemorySegment)mh$.invokeExact(lpszStart, lpszCurrent);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CharPrevW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CharPrevW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LPWSTR CharPrevW(LPCWSTR lpszStart, LPCWSTR lpszCurrent)
     * }
     */
    public static FunctionDescriptor CharPrevW$descriptor() {
        return CharPrevW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LPWSTR CharPrevW(LPCWSTR lpszStart, LPCWSTR lpszCurrent)
     * }
     */
    public static MethodHandle CharPrevW$handle() {
        return CharPrevW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * LPWSTR CharPrevW(LPCWSTR lpszStart, LPCWSTR lpszCurrent)
     * }
     */
    public static MemorySegment CharPrevW(MemorySegment lpszStart, MemorySegment lpszCurrent) {
        var mh$ = CharPrevW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CharPrevW", lpszStart, lpszCurrent);
            }
            return (MemorySegment)mh$.invokeExact(lpszStart, lpszCurrent);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CharNextExA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_SHORT,
            C_POINTER,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CharNextExA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LPSTR CharNextExA(WORD CodePage, LPCSTR lpCurrentChar, DWORD dwFlags)
     * }
     */
    public static FunctionDescriptor CharNextExA$descriptor() {
        return CharNextExA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LPSTR CharNextExA(WORD CodePage, LPCSTR lpCurrentChar, DWORD dwFlags)
     * }
     */
    public static MethodHandle CharNextExA$handle() {
        return CharNextExA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * LPSTR CharNextExA(WORD CodePage, LPCSTR lpCurrentChar, DWORD dwFlags)
     * }
     */
    public static MemorySegment CharNextExA(short CodePage, MemorySegment lpCurrentChar, int dwFlags) {
        var mh$ = CharNextExA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CharNextExA", CodePage, lpCurrentChar, dwFlags);
            }
            return (MemorySegment)mh$.invokeExact(CodePage, lpCurrentChar, dwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CharPrevExA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_SHORT,
            C_POINTER,
            C_POINTER,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CharPrevExA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LPSTR CharPrevExA(WORD CodePage, LPCSTR lpStart, LPCSTR lpCurrentChar, DWORD dwFlags)
     * }
     */
    public static FunctionDescriptor CharPrevExA$descriptor() {
        return CharPrevExA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LPSTR CharPrevExA(WORD CodePage, LPCSTR lpStart, LPCSTR lpCurrentChar, DWORD dwFlags)
     * }
     */
    public static MethodHandle CharPrevExA$handle() {
        return CharPrevExA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * LPSTR CharPrevExA(WORD CodePage, LPCSTR lpStart, LPCSTR lpCurrentChar, DWORD dwFlags)
     * }
     */
    public static MemorySegment CharPrevExA(short CodePage, MemorySegment lpStart, MemorySegment lpCurrentChar, int dwFlags) {
        var mh$ = CharPrevExA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CharPrevExA", CodePage, lpStart, lpCurrentChar, dwFlags);
            }
            return (MemorySegment)mh$.invokeExact(CodePage, lpStart, lpCurrentChar, dwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class IsCharAlphaA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_CHAR
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("IsCharAlphaA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL IsCharAlphaA(CHAR ch)
     * }
     */
    public static FunctionDescriptor IsCharAlphaA$descriptor() {
        return IsCharAlphaA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL IsCharAlphaA(CHAR ch)
     * }
     */
    public static MethodHandle IsCharAlphaA$handle() {
        return IsCharAlphaA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL IsCharAlphaA(CHAR ch)
     * }
     */
    public static int IsCharAlphaA(byte ch) {
        var mh$ = IsCharAlphaA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("IsCharAlphaA", ch);
            }
            return (int)mh$.invokeExact(ch);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class IsCharAlphaW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_SHORT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("IsCharAlphaW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL IsCharAlphaW(WCHAR ch)
     * }
     */
    public static FunctionDescriptor IsCharAlphaW$descriptor() {
        return IsCharAlphaW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL IsCharAlphaW(WCHAR ch)
     * }
     */
    public static MethodHandle IsCharAlphaW$handle() {
        return IsCharAlphaW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL IsCharAlphaW(WCHAR ch)
     * }
     */
    public static int IsCharAlphaW(short ch) {
        var mh$ = IsCharAlphaW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("IsCharAlphaW", ch);
            }
            return (int)mh$.invokeExact(ch);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class IsCharAlphaNumericA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_CHAR
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("IsCharAlphaNumericA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL IsCharAlphaNumericA(CHAR ch)
     * }
     */
    public static FunctionDescriptor IsCharAlphaNumericA$descriptor() {
        return IsCharAlphaNumericA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL IsCharAlphaNumericA(CHAR ch)
     * }
     */
    public static MethodHandle IsCharAlphaNumericA$handle() {
        return IsCharAlphaNumericA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL IsCharAlphaNumericA(CHAR ch)
     * }
     */
    public static int IsCharAlphaNumericA(byte ch) {
        var mh$ = IsCharAlphaNumericA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("IsCharAlphaNumericA", ch);
            }
            return (int)mh$.invokeExact(ch);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class IsCharAlphaNumericW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_SHORT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("IsCharAlphaNumericW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL IsCharAlphaNumericW(WCHAR ch)
     * }
     */
    public static FunctionDescriptor IsCharAlphaNumericW$descriptor() {
        return IsCharAlphaNumericW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL IsCharAlphaNumericW(WCHAR ch)
     * }
     */
    public static MethodHandle IsCharAlphaNumericW$handle() {
        return IsCharAlphaNumericW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL IsCharAlphaNumericW(WCHAR ch)
     * }
     */
    public static int IsCharAlphaNumericW(short ch) {
        var mh$ = IsCharAlphaNumericW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("IsCharAlphaNumericW", ch);
            }
            return (int)mh$.invokeExact(ch);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class IsCharUpperA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_CHAR
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("IsCharUpperA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL IsCharUpperA(CHAR ch)
     * }
     */
    public static FunctionDescriptor IsCharUpperA$descriptor() {
        return IsCharUpperA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL IsCharUpperA(CHAR ch)
     * }
     */
    public static MethodHandle IsCharUpperA$handle() {
        return IsCharUpperA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL IsCharUpperA(CHAR ch)
     * }
     */
    public static int IsCharUpperA(byte ch) {
        var mh$ = IsCharUpperA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("IsCharUpperA", ch);
            }
            return (int)mh$.invokeExact(ch);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class IsCharUpperW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_SHORT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("IsCharUpperW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL IsCharUpperW(WCHAR ch)
     * }
     */
    public static FunctionDescriptor IsCharUpperW$descriptor() {
        return IsCharUpperW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL IsCharUpperW(WCHAR ch)
     * }
     */
    public static MethodHandle IsCharUpperW$handle() {
        return IsCharUpperW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL IsCharUpperW(WCHAR ch)
     * }
     */
    public static int IsCharUpperW(short ch) {
        var mh$ = IsCharUpperW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("IsCharUpperW", ch);
            }
            return (int)mh$.invokeExact(ch);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class IsCharLowerA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_CHAR
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("IsCharLowerA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL IsCharLowerA(CHAR ch)
     * }
     */
    public static FunctionDescriptor IsCharLowerA$descriptor() {
        return IsCharLowerA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL IsCharLowerA(CHAR ch)
     * }
     */
    public static MethodHandle IsCharLowerA$handle() {
        return IsCharLowerA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL IsCharLowerA(CHAR ch)
     * }
     */
    public static int IsCharLowerA(byte ch) {
        var mh$ = IsCharLowerA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("IsCharLowerA", ch);
            }
            return (int)mh$.invokeExact(ch);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class IsCharLowerW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_SHORT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("IsCharLowerW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL IsCharLowerW(WCHAR ch)
     * }
     */
    public static FunctionDescriptor IsCharLowerW$descriptor() {
        return IsCharLowerW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL IsCharLowerW(WCHAR ch)
     * }
     */
    public static MethodHandle IsCharLowerW$handle() {
        return IsCharLowerW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL IsCharLowerW(WCHAR ch)
     * }
     */
    public static int IsCharLowerW(short ch) {
        var mh$ = IsCharLowerW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("IsCharLowerW", ch);
            }
            return (int)mh$.invokeExact(ch);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetFocus {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("SetFocus"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HWND SetFocus(HWND hWnd)
     * }
     */
    public static FunctionDescriptor SetFocus$descriptor() {
        return SetFocus.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HWND SetFocus(HWND hWnd)
     * }
     */
    public static MethodHandle SetFocus$handle() {
        return SetFocus.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * HWND SetFocus(HWND hWnd)
     * }
     */
    public static MemorySegment SetFocus(MemorySegment hWnd) {
        var mh$ = SetFocus.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetFocus", hWnd);
            }
            return (MemorySegment)mh$.invokeExact(hWnd);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetActiveWindow {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER    );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetActiveWindow"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HWND GetActiveWindow()
     * }
     */
    public static FunctionDescriptor GetActiveWindow$descriptor() {
        return GetActiveWindow.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HWND GetActiveWindow()
     * }
     */
    public static MethodHandle GetActiveWindow$handle() {
        return GetActiveWindow.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * HWND GetActiveWindow()
     * }
     */
    public static MemorySegment GetActiveWindow() {
        var mh$ = GetActiveWindow.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetActiveWindow");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetFocus {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER    );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetFocus"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HWND GetFocus()
     * }
     */
    public static FunctionDescriptor GetFocus$descriptor() {
        return GetFocus.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HWND GetFocus()
     * }
     */
    public static MethodHandle GetFocus$handle() {
        return GetFocus.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * HWND GetFocus()
     * }
     */
    public static MemorySegment GetFocus() {
        var mh$ = GetFocus.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetFocus");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetKBCodePage {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT    );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetKBCodePage"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * UINT GetKBCodePage()
     * }
     */
    public static FunctionDescriptor GetKBCodePage$descriptor() {
        return GetKBCodePage.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * UINT GetKBCodePage()
     * }
     */
    public static MethodHandle GetKBCodePage$handle() {
        return GetKBCodePage.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * UINT GetKBCodePage()
     * }
     */
    public static int GetKBCodePage() {
        var mh$ = GetKBCodePage.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetKBCodePage");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetKeyState {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_SHORT,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetKeyState"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SHORT GetKeyState(int nVirtKey)
     * }
     */
    public static FunctionDescriptor GetKeyState$descriptor() {
        return GetKeyState.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SHORT GetKeyState(int nVirtKey)
     * }
     */
    public static MethodHandle GetKeyState$handle() {
        return GetKeyState.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * SHORT GetKeyState(int nVirtKey)
     * }
     */
    public static short GetKeyState(int nVirtKey) {
        var mh$ = GetKeyState.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetKeyState", nVirtKey);
            }
            return (short)mh$.invokeExact(nVirtKey);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetAsyncKeyState {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_SHORT,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetAsyncKeyState"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SHORT GetAsyncKeyState(int vKey)
     * }
     */
    public static FunctionDescriptor GetAsyncKeyState$descriptor() {
        return GetAsyncKeyState.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SHORT GetAsyncKeyState(int vKey)
     * }
     */
    public static MethodHandle GetAsyncKeyState$handle() {
        return GetAsyncKeyState.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * SHORT GetAsyncKeyState(int vKey)
     * }
     */
    public static short GetAsyncKeyState(int vKey) {
        var mh$ = GetAsyncKeyState.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetAsyncKeyState", vKey);
            }
            return (short)mh$.invokeExact(vKey);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetKeyboardState {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetKeyboardState"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetKeyboardState(PBYTE lpKeyState)
     * }
     */
    public static FunctionDescriptor GetKeyboardState$descriptor() {
        return GetKeyboardState.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetKeyboardState(PBYTE lpKeyState)
     * }
     */
    public static MethodHandle GetKeyboardState$handle() {
        return GetKeyboardState.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL GetKeyboardState(PBYTE lpKeyState)
     * }
     */
    public static int GetKeyboardState(MemorySegment lpKeyState) {
        var mh$ = GetKeyboardState.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetKeyboardState", lpKeyState);
            }
            return (int)mh$.invokeExact(lpKeyState);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetKeyboardState {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("SetKeyboardState"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetKeyboardState(LPBYTE lpKeyState)
     * }
     */
    public static FunctionDescriptor SetKeyboardState$descriptor() {
        return SetKeyboardState.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetKeyboardState(LPBYTE lpKeyState)
     * }
     */
    public static MethodHandle SetKeyboardState$handle() {
        return SetKeyboardState.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL SetKeyboardState(LPBYTE lpKeyState)
     * }
     */
    public static int SetKeyboardState(MemorySegment lpKeyState) {
        var mh$ = SetKeyboardState.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetKeyboardState", lpKeyState);
            }
            return (int)mh$.invokeExact(lpKeyState);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetKeyNameTextA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_LONG,
            C_POINTER,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetKeyNameTextA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int GetKeyNameTextA(LONG lParam, LPSTR lpString, int cchSize)
     * }
     */
    public static FunctionDescriptor GetKeyNameTextA$descriptor() {
        return GetKeyNameTextA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int GetKeyNameTextA(LONG lParam, LPSTR lpString, int cchSize)
     * }
     */
    public static MethodHandle GetKeyNameTextA$handle() {
        return GetKeyNameTextA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int GetKeyNameTextA(LONG lParam, LPSTR lpString, int cchSize)
     * }
     */
    public static int GetKeyNameTextA(int lParam, MemorySegment lpString, int cchSize) {
        var mh$ = GetKeyNameTextA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetKeyNameTextA", lParam, lpString, cchSize);
            }
            return (int)mh$.invokeExact(lParam, lpString, cchSize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetKeyNameTextW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_LONG,
            C_POINTER,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetKeyNameTextW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int GetKeyNameTextW(LONG lParam, LPWSTR lpString, int cchSize)
     * }
     */
    public static FunctionDescriptor GetKeyNameTextW$descriptor() {
        return GetKeyNameTextW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int GetKeyNameTextW(LONG lParam, LPWSTR lpString, int cchSize)
     * }
     */
    public static MethodHandle GetKeyNameTextW$handle() {
        return GetKeyNameTextW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int GetKeyNameTextW(LONG lParam, LPWSTR lpString, int cchSize)
     * }
     */
    public static int GetKeyNameTextW(int lParam, MemorySegment lpString, int cchSize) {
        var mh$ = GetKeyNameTextW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetKeyNameTextW", lParam, lpString, cchSize);
            }
            return (int)mh$.invokeExact(lParam, lpString, cchSize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetKeyboardType {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetKeyboardType"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int GetKeyboardType(int nTypeFlag)
     * }
     */
    public static FunctionDescriptor GetKeyboardType$descriptor() {
        return GetKeyboardType.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int GetKeyboardType(int nTypeFlag)
     * }
     */
    public static MethodHandle GetKeyboardType$handle() {
        return GetKeyboardType.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int GetKeyboardType(int nTypeFlag)
     * }
     */
    public static int GetKeyboardType(int nTypeFlag) {
        var mh$ = GetKeyboardType.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetKeyboardType", nTypeFlag);
            }
            return (int)mh$.invokeExact(nTypeFlag);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ToAscii {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_INT,
            C_INT,
            C_POINTER,
            C_POINTER,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("ToAscii"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int ToAscii(UINT uVirtKey, UINT uScanCode, const BYTE *lpKeyState, LPWORD lpChar, UINT uFlags)
     * }
     */
    public static FunctionDescriptor ToAscii$descriptor() {
        return ToAscii.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int ToAscii(UINT uVirtKey, UINT uScanCode, const BYTE *lpKeyState, LPWORD lpChar, UINT uFlags)
     * }
     */
    public static MethodHandle ToAscii$handle() {
        return ToAscii.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int ToAscii(UINT uVirtKey, UINT uScanCode, const BYTE *lpKeyState, LPWORD lpChar, UINT uFlags)
     * }
     */
    public static int ToAscii(int uVirtKey, int uScanCode, MemorySegment lpKeyState, MemorySegment lpChar, int uFlags) {
        var mh$ = ToAscii.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ToAscii", uVirtKey, uScanCode, lpKeyState, lpChar, uFlags);
            }
            return (int)mh$.invokeExact(uVirtKey, uScanCode, lpKeyState, lpChar, uFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ToAsciiEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_INT,
            C_INT,
            C_POINTER,
            C_POINTER,
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("ToAsciiEx"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int ToAsciiEx(UINT uVirtKey, UINT uScanCode, const BYTE *lpKeyState, LPWORD lpChar, UINT uFlags, HKL dwhkl)
     * }
     */
    public static FunctionDescriptor ToAsciiEx$descriptor() {
        return ToAsciiEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int ToAsciiEx(UINT uVirtKey, UINT uScanCode, const BYTE *lpKeyState, LPWORD lpChar, UINT uFlags, HKL dwhkl)
     * }
     */
    public static MethodHandle ToAsciiEx$handle() {
        return ToAsciiEx.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int ToAsciiEx(UINT uVirtKey, UINT uScanCode, const BYTE *lpKeyState, LPWORD lpChar, UINT uFlags, HKL dwhkl)
     * }
     */
    public static int ToAsciiEx(int uVirtKey, int uScanCode, MemorySegment lpKeyState, MemorySegment lpChar, int uFlags, MemorySegment dwhkl) {
        var mh$ = ToAsciiEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ToAsciiEx", uVirtKey, uScanCode, lpKeyState, lpChar, uFlags, dwhkl);
            }
            return (int)mh$.invokeExact(uVirtKey, uScanCode, lpKeyState, lpChar, uFlags, dwhkl);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ToUnicode {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_INT,
            C_INT,
            C_POINTER,
            C_POINTER,
            C_INT,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("ToUnicode"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int ToUnicode(UINT wVirtKey, UINT wScanCode, const BYTE *lpKeyState, LPWSTR pwszBuff, int cchBuff, UINT wFlags)
     * }
     */
    public static FunctionDescriptor ToUnicode$descriptor() {
        return ToUnicode.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int ToUnicode(UINT wVirtKey, UINT wScanCode, const BYTE *lpKeyState, LPWSTR pwszBuff, int cchBuff, UINT wFlags)
     * }
     */
    public static MethodHandle ToUnicode$handle() {
        return ToUnicode.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int ToUnicode(UINT wVirtKey, UINT wScanCode, const BYTE *lpKeyState, LPWSTR pwszBuff, int cchBuff, UINT wFlags)
     * }
     */
    public static int ToUnicode(int wVirtKey, int wScanCode, MemorySegment lpKeyState, MemorySegment pwszBuff, int cchBuff, int wFlags) {
        var mh$ = ToUnicode.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ToUnicode", wVirtKey, wScanCode, lpKeyState, pwszBuff, cchBuff, wFlags);
            }
            return (int)mh$.invokeExact(wVirtKey, wScanCode, lpKeyState, pwszBuff, cchBuff, wFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class OemKeyScan {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_SHORT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("OemKeyScan"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD OemKeyScan(WORD wOemChar)
     * }
     */
    public static FunctionDescriptor OemKeyScan$descriptor() {
        return OemKeyScan.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD OemKeyScan(WORD wOemChar)
     * }
     */
    public static MethodHandle OemKeyScan$handle() {
        return OemKeyScan.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * DWORD OemKeyScan(WORD wOemChar)
     * }
     */
    public static int OemKeyScan(short wOemChar) {
        var mh$ = OemKeyScan.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("OemKeyScan", wOemChar);
            }
            return (int)mh$.invokeExact(wOemChar);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class VkKeyScanA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_SHORT,
            C_CHAR
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("VkKeyScanA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SHORT VkKeyScanA(CHAR ch)
     * }
     */
    public static FunctionDescriptor VkKeyScanA$descriptor() {
        return VkKeyScanA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SHORT VkKeyScanA(CHAR ch)
     * }
     */
    public static MethodHandle VkKeyScanA$handle() {
        return VkKeyScanA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * SHORT VkKeyScanA(CHAR ch)
     * }
     */
    public static short VkKeyScanA(byte ch) {
        var mh$ = VkKeyScanA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("VkKeyScanA", ch);
            }
            return (short)mh$.invokeExact(ch);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class VkKeyScanW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_SHORT,
            C_SHORT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("VkKeyScanW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SHORT VkKeyScanW(WCHAR ch)
     * }
     */
    public static FunctionDescriptor VkKeyScanW$descriptor() {
        return VkKeyScanW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SHORT VkKeyScanW(WCHAR ch)
     * }
     */
    public static MethodHandle VkKeyScanW$handle() {
        return VkKeyScanW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * SHORT VkKeyScanW(WCHAR ch)
     * }
     */
    public static short VkKeyScanW(short ch) {
        var mh$ = VkKeyScanW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("VkKeyScanW", ch);
            }
            return (short)mh$.invokeExact(ch);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class VkKeyScanExA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_SHORT,
            C_CHAR,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("VkKeyScanExA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SHORT VkKeyScanExA(CHAR ch, HKL dwhkl)
     * }
     */
    public static FunctionDescriptor VkKeyScanExA$descriptor() {
        return VkKeyScanExA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SHORT VkKeyScanExA(CHAR ch, HKL dwhkl)
     * }
     */
    public static MethodHandle VkKeyScanExA$handle() {
        return VkKeyScanExA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * SHORT VkKeyScanExA(CHAR ch, HKL dwhkl)
     * }
     */
    public static short VkKeyScanExA(byte ch, MemorySegment dwhkl) {
        var mh$ = VkKeyScanExA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("VkKeyScanExA", ch, dwhkl);
            }
            return (short)mh$.invokeExact(ch, dwhkl);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class VkKeyScanExW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_SHORT,
            C_SHORT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("VkKeyScanExW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SHORT VkKeyScanExW(WCHAR ch, HKL dwhkl)
     * }
     */
    public static FunctionDescriptor VkKeyScanExW$descriptor() {
        return VkKeyScanExW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SHORT VkKeyScanExW(WCHAR ch, HKL dwhkl)
     * }
     */
    public static MethodHandle VkKeyScanExW$handle() {
        return VkKeyScanExW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * SHORT VkKeyScanExW(WCHAR ch, HKL dwhkl)
     * }
     */
    public static short VkKeyScanExW(short ch, MemorySegment dwhkl) {
        var mh$ = VkKeyScanExW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("VkKeyScanExW", ch, dwhkl);
            }
            return (short)mh$.invokeExact(ch, dwhkl);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class keybd_event {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C_CHAR,
            C_CHAR,
            C_LONG,
            C_LONG_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("keybd_event"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void keybd_event(BYTE bVk, BYTE bScan, DWORD dwFlags, ULONG_PTR dwExtraInfo)
     * }
     */
    public static FunctionDescriptor keybd_event$descriptor() {
        return keybd_event.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void keybd_event(BYTE bVk, BYTE bScan, DWORD dwFlags, ULONG_PTR dwExtraInfo)
     * }
     */
    public static MethodHandle keybd_event$handle() {
        return keybd_event.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * void keybd_event(BYTE bVk, BYTE bScan, DWORD dwFlags, ULONG_PTR dwExtraInfo)
     * }
     */
    public static void keybd_event(byte bVk, byte bScan, int dwFlags, long dwExtraInfo) {
        var mh$ = keybd_event.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("keybd_event", bVk, bScan, dwFlags, dwExtraInfo);
            }
            mh$.invokeExact(bVk, bScan, dwFlags, dwExtraInfo);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mouse_event {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C_LONG,
            C_LONG,
            C_LONG,
            C_LONG,
            C_LONG_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("mouse_event"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void mouse_event(DWORD dwFlags, DWORD dx, DWORD dy, DWORD dwData, ULONG_PTR dwExtraInfo)
     * }
     */
    public static FunctionDescriptor mouse_event$descriptor() {
        return mouse_event.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void mouse_event(DWORD dwFlags, DWORD dx, DWORD dy, DWORD dwData, ULONG_PTR dwExtraInfo)
     * }
     */
    public static MethodHandle mouse_event$handle() {
        return mouse_event.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * void mouse_event(DWORD dwFlags, DWORD dx, DWORD dy, DWORD dwData, ULONG_PTR dwExtraInfo)
     * }
     */
    public static void mouse_event(int dwFlags, int dx, int dy, int dwData, long dwExtraInfo) {
        var mh$ = mouse_event.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mouse_event", dwFlags, dx, dy, dwData, dwExtraInfo);
            }
            mh$.invokeExact(dwFlags, dx, dy, dwData, dwExtraInfo);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct tagMOUSEINPUT {
     *     LONG dx;
     *     LONG dy;
     *     DWORD mouseData;
     *     DWORD dwFlags;
     *     DWORD time;
     *     ULONG_PTR dwExtraInfo;
     * } *PMOUSEINPUT
     * }
     */
    public static final AddressLayout PMOUSEINPUT = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagMOUSEINPUT {
     *     LONG dx;
     *     LONG dy;
     *     DWORD mouseData;
     *     DWORD dwFlags;
     *     DWORD time;
     *     ULONG_PTR dwExtraInfo;
     * } *LPMOUSEINPUT
     * }
     */
    public static final AddressLayout LPMOUSEINPUT = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagKEYBDINPUT {
     *     WORD wVk;
     *     WORD wScan;
     *     DWORD dwFlags;
     *     DWORD time;
     *     ULONG_PTR dwExtraInfo;
     * } *PKEYBDINPUT
     * }
     */
    public static final AddressLayout PKEYBDINPUT = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagKEYBDINPUT {
     *     WORD wVk;
     *     WORD wScan;
     *     DWORD dwFlags;
     *     DWORD time;
     *     ULONG_PTR dwExtraInfo;
     * } *LPKEYBDINPUT
     * }
     */
    public static final AddressLayout LPKEYBDINPUT = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagHARDWAREINPUT {
     *     DWORD uMsg;
     *     WORD wParamL;
     *     WORD wParamH;
     * } *PHARDWAREINPUT
     * }
     */
    public static final AddressLayout PHARDWAREINPUT = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagHARDWAREINPUT {
     *     DWORD uMsg;
     *     WORD wParamL;
     *     WORD wParamH;
     * } *LPHARDWAREINPUT
     * }
     */
    public static final AddressLayout LPHARDWAREINPUT = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagINPUT {
     *     DWORD type;
     *     union {
     *         MOUSEINPUT mi;
     *         KEYBDINPUT ki;
     *         HARDWAREINPUT hi;
     *     };
     * } *PINPUT
     * }
     */
    public static final AddressLayout PINPUT = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagINPUT {
     *     DWORD type;
     *     union {
     *         MOUSEINPUT mi;
     *         KEYBDINPUT ki;
     *         HARDWAREINPUT hi;
     *     };
     * } *LPINPUT
     * }
     */
    public static final AddressLayout LPINPUT = C_POINTER;

    private static class SendInput {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_INT,
            C_POINTER,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("SendInput"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * UINT SendInput(UINT cInputs, LPINPUT pInputs, int cbSize)
     * }
     */
    public static FunctionDescriptor SendInput$descriptor() {
        return SendInput.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * UINT SendInput(UINT cInputs, LPINPUT pInputs, int cbSize)
     * }
     */
    public static MethodHandle SendInput$handle() {
        return SendInput.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * UINT SendInput(UINT cInputs, LPINPUT pInputs, int cbSize)
     * }
     */
    public static int SendInput(int cInputs, MemorySegment pInputs, int cbSize) {
        var mh$ = SendInput.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SendInput", cInputs, pInputs, cbSize);
            }
            return (int)mh$.invokeExact(cInputs, pInputs, cbSize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct HTOUCHINPUT__ {
     *     int unused;
     * } *HTOUCHINPUT
     * }
     */
    public static final AddressLayout HTOUCHINPUT = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagTOUCHINPUT {
     *     LONG x;
     *     LONG y;
     *     HANDLE hSource;
     *     DWORD dwID;
     *     DWORD dwFlags;
     *     DWORD dwMask;
     *     DWORD dwTime;
     *     ULONG_PTR dwExtraInfo;
     *     DWORD cxContact;
     *     DWORD cyContact;
     * } *PTOUCHINPUT
     * }
     */
    public static final AddressLayout PTOUCHINPUT = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef const TOUCHINPUT *PCTOUCHINPUT
     * }
     */
    public static final AddressLayout PCTOUCHINPUT = C_POINTER;

    private static class GetTouchInputInfo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_INT,
            C_POINTER,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetTouchInputInfo"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetTouchInputInfo(HTOUCHINPUT hTouchInput, UINT cInputs, PTOUCHINPUT pInputs, int cbSize)
     * }
     */
    public static FunctionDescriptor GetTouchInputInfo$descriptor() {
        return GetTouchInputInfo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetTouchInputInfo(HTOUCHINPUT hTouchInput, UINT cInputs, PTOUCHINPUT pInputs, int cbSize)
     * }
     */
    public static MethodHandle GetTouchInputInfo$handle() {
        return GetTouchInputInfo.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL GetTouchInputInfo(HTOUCHINPUT hTouchInput, UINT cInputs, PTOUCHINPUT pInputs, int cbSize)
     * }
     */
    public static int GetTouchInputInfo(MemorySegment hTouchInput, int cInputs, MemorySegment pInputs, int cbSize) {
        var mh$ = GetTouchInputInfo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetTouchInputInfo", hTouchInput, cInputs, pInputs, cbSize);
            }
            return (int)mh$.invokeExact(hTouchInput, cInputs, pInputs, cbSize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CloseTouchInputHandle {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CloseTouchInputHandle"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CloseTouchInputHandle(HTOUCHINPUT hTouchInput)
     * }
     */
    public static FunctionDescriptor CloseTouchInputHandle$descriptor() {
        return CloseTouchInputHandle.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CloseTouchInputHandle(HTOUCHINPUT hTouchInput)
     * }
     */
    public static MethodHandle CloseTouchInputHandle$handle() {
        return CloseTouchInputHandle.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL CloseTouchInputHandle(HTOUCHINPUT hTouchInput)
     * }
     */
    public static int CloseTouchInputHandle(MemorySegment hTouchInput) {
        var mh$ = CloseTouchInputHandle.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CloseTouchInputHandle", hTouchInput);
            }
            return (int)mh$.invokeExact(hTouchInput);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RegisterTouchWindow {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("RegisterTouchWindow"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL RegisterTouchWindow(HWND hwnd, ULONG ulFlags)
     * }
     */
    public static FunctionDescriptor RegisterTouchWindow$descriptor() {
        return RegisterTouchWindow.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL RegisterTouchWindow(HWND hwnd, ULONG ulFlags)
     * }
     */
    public static MethodHandle RegisterTouchWindow$handle() {
        return RegisterTouchWindow.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL RegisterTouchWindow(HWND hwnd, ULONG ulFlags)
     * }
     */
    public static int RegisterTouchWindow(MemorySegment hwnd, int ulFlags) {
        var mh$ = RegisterTouchWindow.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RegisterTouchWindow", hwnd, ulFlags);
            }
            return (int)mh$.invokeExact(hwnd, ulFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class UnregisterTouchWindow {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("UnregisterTouchWindow"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL UnregisterTouchWindow(HWND hwnd)
     * }
     */
    public static FunctionDescriptor UnregisterTouchWindow$descriptor() {
        return UnregisterTouchWindow.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL UnregisterTouchWindow(HWND hwnd)
     * }
     */
    public static MethodHandle UnregisterTouchWindow$handle() {
        return UnregisterTouchWindow.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL UnregisterTouchWindow(HWND hwnd)
     * }
     */
    public static int UnregisterTouchWindow(MemorySegment hwnd) {
        var mh$ = UnregisterTouchWindow.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("UnregisterTouchWindow", hwnd);
            }
            return (int)mh$.invokeExact(hwnd);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class IsTouchWindow {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("IsTouchWindow"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL IsTouchWindow(HWND hwnd, PULONG pulFlags)
     * }
     */
    public static FunctionDescriptor IsTouchWindow$descriptor() {
        return IsTouchWindow.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL IsTouchWindow(HWND hwnd, PULONG pulFlags)
     * }
     */
    public static MethodHandle IsTouchWindow$handle() {
        return IsTouchWindow.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL IsTouchWindow(HWND hwnd, PULONG pulFlags)
     * }
     */
    public static int IsTouchWindow(MemorySegment hwnd, MemorySegment pulFlags) {
        var mh$ = IsTouchWindow.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("IsTouchWindow", hwnd, pulFlags);
            }
            return (int)mh$.invokeExact(hwnd, pulFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int PT_POINTER = (int)1L;
    /**
     * {@snippet lang=c :
     * enum tagPOINTER_INPUT_TYPE.PT_POINTER = 1
     * }
     */
    public static int PT_POINTER() {
        return PT_POINTER;
    }
    private static final int PT_TOUCH = (int)2L;
    /**
     * {@snippet lang=c :
     * enum tagPOINTER_INPUT_TYPE.PT_TOUCH = 2
     * }
     */
    public static int PT_TOUCH() {
        return PT_TOUCH;
    }
    private static final int PT_PEN = (int)3L;
    /**
     * {@snippet lang=c :
     * enum tagPOINTER_INPUT_TYPE.PT_PEN = 3
     * }
     */
    public static int PT_PEN() {
        return PT_PEN;
    }
    private static final int PT_MOUSE = (int)4L;
    /**
     * {@snippet lang=c :
     * enum tagPOINTER_INPUT_TYPE.PT_MOUSE = 4
     * }
     */
    public static int PT_MOUSE() {
        return PT_MOUSE;
    }
    private static final int PT_TOUCHPAD = (int)5L;
    /**
     * {@snippet lang=c :
     * enum tagPOINTER_INPUT_TYPE.PT_TOUCHPAD = 5
     * }
     */
    public static int PT_TOUCHPAD() {
        return PT_TOUCHPAD;
    }
    /**
     * {@snippet lang=c :
     * typedef DWORD POINTER_INPUT_TYPE
     * }
     */
    public static final OfInt POINTER_INPUT_TYPE = C_LONG;
    /**
     * {@snippet lang=c :
     * typedef UINT32 POINTER_FLAGS
     * }
     */
    public static final OfInt POINTER_FLAGS = C_INT;
    private static final int POINTER_CHANGE_NONE = (int)0L;
    /**
     * {@snippet lang=c :
     * enum tagPOINTER_BUTTON_CHANGE_TYPE.POINTER_CHANGE_NONE = 0
     * }
     */
    public static int POINTER_CHANGE_NONE() {
        return POINTER_CHANGE_NONE;
    }
    private static final int POINTER_CHANGE_FIRSTBUTTON_DOWN = (int)1L;
    /**
     * {@snippet lang=c :
     * enum tagPOINTER_BUTTON_CHANGE_TYPE.POINTER_CHANGE_FIRSTBUTTON_DOWN = 1
     * }
     */
    public static int POINTER_CHANGE_FIRSTBUTTON_DOWN() {
        return POINTER_CHANGE_FIRSTBUTTON_DOWN;
    }
    private static final int POINTER_CHANGE_FIRSTBUTTON_UP = (int)2L;
    /**
     * {@snippet lang=c :
     * enum tagPOINTER_BUTTON_CHANGE_TYPE.POINTER_CHANGE_FIRSTBUTTON_UP = 2
     * }
     */
    public static int POINTER_CHANGE_FIRSTBUTTON_UP() {
        return POINTER_CHANGE_FIRSTBUTTON_UP;
    }
    private static final int POINTER_CHANGE_SECONDBUTTON_DOWN = (int)3L;
    /**
     * {@snippet lang=c :
     * enum tagPOINTER_BUTTON_CHANGE_TYPE.POINTER_CHANGE_SECONDBUTTON_DOWN = 3
     * }
     */
    public static int POINTER_CHANGE_SECONDBUTTON_DOWN() {
        return POINTER_CHANGE_SECONDBUTTON_DOWN;
    }
    private static final int POINTER_CHANGE_SECONDBUTTON_UP = (int)4L;
    /**
     * {@snippet lang=c :
     * enum tagPOINTER_BUTTON_CHANGE_TYPE.POINTER_CHANGE_SECONDBUTTON_UP = 4
     * }
     */
    public static int POINTER_CHANGE_SECONDBUTTON_UP() {
        return POINTER_CHANGE_SECONDBUTTON_UP;
    }
    private static final int POINTER_CHANGE_THIRDBUTTON_DOWN = (int)5L;
    /**
     * {@snippet lang=c :
     * enum tagPOINTER_BUTTON_CHANGE_TYPE.POINTER_CHANGE_THIRDBUTTON_DOWN = 5
     * }
     */
    public static int POINTER_CHANGE_THIRDBUTTON_DOWN() {
        return POINTER_CHANGE_THIRDBUTTON_DOWN;
    }
    private static final int POINTER_CHANGE_THIRDBUTTON_UP = (int)6L;
    /**
     * {@snippet lang=c :
     * enum tagPOINTER_BUTTON_CHANGE_TYPE.POINTER_CHANGE_THIRDBUTTON_UP = 6
     * }
     */
    public static int POINTER_CHANGE_THIRDBUTTON_UP() {
        return POINTER_CHANGE_THIRDBUTTON_UP;
    }
    private static final int POINTER_CHANGE_FOURTHBUTTON_DOWN = (int)7L;
    /**
     * {@snippet lang=c :
     * enum tagPOINTER_BUTTON_CHANGE_TYPE.POINTER_CHANGE_FOURTHBUTTON_DOWN = 7
     * }
     */
    public static int POINTER_CHANGE_FOURTHBUTTON_DOWN() {
        return POINTER_CHANGE_FOURTHBUTTON_DOWN;
    }
    private static final int POINTER_CHANGE_FOURTHBUTTON_UP = (int)8L;
    /**
     * {@snippet lang=c :
     * enum tagPOINTER_BUTTON_CHANGE_TYPE.POINTER_CHANGE_FOURTHBUTTON_UP = 8
     * }
     */
    public static int POINTER_CHANGE_FOURTHBUTTON_UP() {
        return POINTER_CHANGE_FOURTHBUTTON_UP;
    }
    private static final int POINTER_CHANGE_FIFTHBUTTON_DOWN = (int)9L;
    /**
     * {@snippet lang=c :
     * enum tagPOINTER_BUTTON_CHANGE_TYPE.POINTER_CHANGE_FIFTHBUTTON_DOWN = 9
     * }
     */
    public static int POINTER_CHANGE_FIFTHBUTTON_DOWN() {
        return POINTER_CHANGE_FIFTHBUTTON_DOWN;
    }
    private static final int POINTER_CHANGE_FIFTHBUTTON_UP = (int)10L;
    /**
     * {@snippet lang=c :
     * enum tagPOINTER_BUTTON_CHANGE_TYPE.POINTER_CHANGE_FIFTHBUTTON_UP = 10
     * }
     */
    public static int POINTER_CHANGE_FIFTHBUTTON_UP() {
        return POINTER_CHANGE_FIFTHBUTTON_UP;
    }
    /**
     * {@snippet lang=c :
     * typedef UINT32 TOUCH_FLAGS
     * }
     */
    public static final OfInt TOUCH_FLAGS = C_INT;
    /**
     * {@snippet lang=c :
     * typedef UINT32 TOUCH_MASK
     * }
     */
    public static final OfInt TOUCH_MASK = C_INT;
    /**
     * {@snippet lang=c :
     * typedef UINT32 PEN_FLAGS
     * }
     */
    public static final OfInt PEN_FLAGS = C_INT;
    /**
     * {@snippet lang=c :
     * typedef UINT32 PEN_MASK
     * }
     */
    public static final OfInt PEN_MASK = C_INT;
    private static final int POINTER_FEEDBACK_DEFAULT = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.POINTER_FEEDBACK_DEFAULT = 1
     * }
     */
    public static int POINTER_FEEDBACK_DEFAULT() {
        return POINTER_FEEDBACK_DEFAULT;
    }
    private static final int POINTER_FEEDBACK_INDIRECT = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.POINTER_FEEDBACK_INDIRECT = 2
     * }
     */
    public static int POINTER_FEEDBACK_INDIRECT() {
        return POINTER_FEEDBACK_INDIRECT;
    }
    private static final int POINTER_FEEDBACK_NONE = (int)3L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.POINTER_FEEDBACK_NONE = 3
     * }
     */
    public static int POINTER_FEEDBACK_NONE() {
        return POINTER_FEEDBACK_NONE;
    }

    private static class InitializeTouchInjection {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_INT,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("InitializeTouchInjection"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL InitializeTouchInjection(UINT32 maxCount, DWORD dwMode)
     * }
     */
    public static FunctionDescriptor InitializeTouchInjection$descriptor() {
        return InitializeTouchInjection.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL InitializeTouchInjection(UINT32 maxCount, DWORD dwMode)
     * }
     */
    public static MethodHandle InitializeTouchInjection$handle() {
        return InitializeTouchInjection.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL InitializeTouchInjection(UINT32 maxCount, DWORD dwMode)
     * }
     */
    public static int InitializeTouchInjection(int maxCount, int dwMode) {
        var mh$ = InitializeTouchInjection.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("InitializeTouchInjection", maxCount, dwMode);
            }
            return (int)mh$.invokeExact(maxCount, dwMode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class InjectTouchInput {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("InjectTouchInput"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL InjectTouchInput(UINT32 count, const POINTER_TOUCH_INFO *contacts)
     * }
     */
    public static FunctionDescriptor InjectTouchInput$descriptor() {
        return InjectTouchInput.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL InjectTouchInput(UINT32 count, const POINTER_TOUCH_INFO *contacts)
     * }
     */
    public static MethodHandle InjectTouchInput$handle() {
        return InjectTouchInput.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL InjectTouchInput(UINT32 count, const POINTER_TOUCH_INFO *contacts)
     * }
     */
    public static int InjectTouchInput(int count, MemorySegment contacts) {
        var mh$ = InjectTouchInput.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("InjectTouchInput", count, contacts);
            }
            return (int)mh$.invokeExact(count, contacts);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct tagUSAGE_PROPERTIES {
     *     USHORT level;
     *     USHORT page;
     *     USHORT usage;
     *     INT32 logicalMinimum;
     *     INT32 logicalMaximum;
     *     USHORT unit;
     *     USHORT exponent;
     *     BYTE count;
     *     INT32 physicalMinimum;
     *     INT32 physicalMaximum;
     * } *PUSAGE_PROPERTIES
     * }
     */
    public static final AddressLayout PUSAGE_PROPERTIES = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagPOINTER_TYPE_INFO {
     *     POINTER_INPUT_TYPE type;
     *     union {
     *         POINTER_TOUCH_INFO touchInfo;
     *         POINTER_PEN_INFO penInfo;
     *     };
     * } *PPOINTER_TYPE_INFO
     * }
     */
    public static final AddressLayout PPOINTER_TYPE_INFO = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagINPUT_INJECTION_VALUE {
     *     USHORT page;
     *     USHORT usage;
     *     INT32 value;
     *     USHORT index;
     * } *PINPUT_INJECTION_VALUE
     * }
     */
    public static final AddressLayout PINPUT_INJECTION_VALUE = C_POINTER;

    private static class GetPointerType {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetPointerType"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetPointerType(UINT32 pointerId, POINTER_INPUT_TYPE *pointerType)
     * }
     */
    public static FunctionDescriptor GetPointerType$descriptor() {
        return GetPointerType.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetPointerType(UINT32 pointerId, POINTER_INPUT_TYPE *pointerType)
     * }
     */
    public static MethodHandle GetPointerType$handle() {
        return GetPointerType.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL GetPointerType(UINT32 pointerId, POINTER_INPUT_TYPE *pointerType)
     * }
     */
    public static int GetPointerType(int pointerId, MemorySegment pointerType) {
        var mh$ = GetPointerType.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetPointerType", pointerId, pointerType);
            }
            return (int)mh$.invokeExact(pointerId, pointerType);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetPointerCursorId {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetPointerCursorId"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetPointerCursorId(UINT32 pointerId, UINT32 *cursorId)
     * }
     */
    public static FunctionDescriptor GetPointerCursorId$descriptor() {
        return GetPointerCursorId.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetPointerCursorId(UINT32 pointerId, UINT32 *cursorId)
     * }
     */
    public static MethodHandle GetPointerCursorId$handle() {
        return GetPointerCursorId.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL GetPointerCursorId(UINT32 pointerId, UINT32 *cursorId)
     * }
     */
    public static int GetPointerCursorId(int pointerId, MemorySegment cursorId) {
        var mh$ = GetPointerCursorId.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetPointerCursorId", pointerId, cursorId);
            }
            return (int)mh$.invokeExact(pointerId, cursorId);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetPointerInfo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetPointerInfo"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetPointerInfo(UINT32 pointerId, POINTER_INFO *pointerInfo)
     * }
     */
    public static FunctionDescriptor GetPointerInfo$descriptor() {
        return GetPointerInfo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetPointerInfo(UINT32 pointerId, POINTER_INFO *pointerInfo)
     * }
     */
    public static MethodHandle GetPointerInfo$handle() {
        return GetPointerInfo.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL GetPointerInfo(UINT32 pointerId, POINTER_INFO *pointerInfo)
     * }
     */
    public static int GetPointerInfo(int pointerId, MemorySegment pointerInfo) {
        var mh$ = GetPointerInfo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetPointerInfo", pointerId, pointerInfo);
            }
            return (int)mh$.invokeExact(pointerId, pointerInfo);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetPointerInfoHistory {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_INT,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetPointerInfoHistory"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetPointerInfoHistory(UINT32 pointerId, UINT32 *entriesCount, POINTER_INFO *pointerInfo)
     * }
     */
    public static FunctionDescriptor GetPointerInfoHistory$descriptor() {
        return GetPointerInfoHistory.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetPointerInfoHistory(UINT32 pointerId, UINT32 *entriesCount, POINTER_INFO *pointerInfo)
     * }
     */
    public static MethodHandle GetPointerInfoHistory$handle() {
        return GetPointerInfoHistory.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL GetPointerInfoHistory(UINT32 pointerId, UINT32 *entriesCount, POINTER_INFO *pointerInfo)
     * }
     */
    public static int GetPointerInfoHistory(int pointerId, MemorySegment entriesCount, MemorySegment pointerInfo) {
        var mh$ = GetPointerInfoHistory.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetPointerInfoHistory", pointerId, entriesCount, pointerInfo);
            }
            return (int)mh$.invokeExact(pointerId, entriesCount, pointerInfo);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetPointerFrameInfo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_INT,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetPointerFrameInfo"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetPointerFrameInfo(UINT32 pointerId, UINT32 *pointerCount, POINTER_INFO *pointerInfo)
     * }
     */
    public static FunctionDescriptor GetPointerFrameInfo$descriptor() {
        return GetPointerFrameInfo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetPointerFrameInfo(UINT32 pointerId, UINT32 *pointerCount, POINTER_INFO *pointerInfo)
     * }
     */
    public static MethodHandle GetPointerFrameInfo$handle() {
        return GetPointerFrameInfo.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL GetPointerFrameInfo(UINT32 pointerId, UINT32 *pointerCount, POINTER_INFO *pointerInfo)
     * }
     */
    public static int GetPointerFrameInfo(int pointerId, MemorySegment pointerCount, MemorySegment pointerInfo) {
        var mh$ = GetPointerFrameInfo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetPointerFrameInfo", pointerId, pointerCount, pointerInfo);
            }
            return (int)mh$.invokeExact(pointerId, pointerCount, pointerInfo);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetPointerFrameInfoHistory {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_INT,
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetPointerFrameInfoHistory"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetPointerFrameInfoHistory(UINT32 pointerId, UINT32 *entriesCount, UINT32 *pointerCount, POINTER_INFO *pointerInfo)
     * }
     */
    public static FunctionDescriptor GetPointerFrameInfoHistory$descriptor() {
        return GetPointerFrameInfoHistory.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetPointerFrameInfoHistory(UINT32 pointerId, UINT32 *entriesCount, UINT32 *pointerCount, POINTER_INFO *pointerInfo)
     * }
     */
    public static MethodHandle GetPointerFrameInfoHistory$handle() {
        return GetPointerFrameInfoHistory.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL GetPointerFrameInfoHistory(UINT32 pointerId, UINT32 *entriesCount, UINT32 *pointerCount, POINTER_INFO *pointerInfo)
     * }
     */
    public static int GetPointerFrameInfoHistory(int pointerId, MemorySegment entriesCount, MemorySegment pointerCount, MemorySegment pointerInfo) {
        var mh$ = GetPointerFrameInfoHistory.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetPointerFrameInfoHistory", pointerId, entriesCount, pointerCount, pointerInfo);
            }
            return (int)mh$.invokeExact(pointerId, entriesCount, pointerCount, pointerInfo);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetPointerTouchInfo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetPointerTouchInfo"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetPointerTouchInfo(UINT32 pointerId, POINTER_TOUCH_INFO *touchInfo)
     * }
     */
    public static FunctionDescriptor GetPointerTouchInfo$descriptor() {
        return GetPointerTouchInfo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetPointerTouchInfo(UINT32 pointerId, POINTER_TOUCH_INFO *touchInfo)
     * }
     */
    public static MethodHandle GetPointerTouchInfo$handle() {
        return GetPointerTouchInfo.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL GetPointerTouchInfo(UINT32 pointerId, POINTER_TOUCH_INFO *touchInfo)
     * }
     */
    public static int GetPointerTouchInfo(int pointerId, MemorySegment touchInfo) {
        var mh$ = GetPointerTouchInfo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetPointerTouchInfo", pointerId, touchInfo);
            }
            return (int)mh$.invokeExact(pointerId, touchInfo);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
}

