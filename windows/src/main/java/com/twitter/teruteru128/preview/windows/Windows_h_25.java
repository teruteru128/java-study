// Generated by jextract

package com.twitter.teruteru128.preview.windows;

import java.lang.invoke.*;
import java.lang.foreign.*;
import java.nio.ByteOrder;
import java.util.*;
import java.util.function.*;
import java.util.stream.*;

import static java.lang.foreign.ValueLayout.*;
import static java.lang.foreign.MemoryLayout.PathElement.*;

public class Windows_h_25 extends Windows_h_26 {

    Windows_h_25() {
        // Should not be called directly
    }
    /**
     * {@snippet lang=c :
     * typedef struct _CUSTOM_SYSTEM_EVENT_TRIGGER_CONFIG {
     *     DWORD Size;
     *     PCWSTR TriggerId;
     * } *PCUSTOM_SYSTEM_EVENT_TRIGGER_CONFIG
     * }
     */
    public static final AddressLayout PCUSTOM_SYSTEM_EVENT_TRIGGER_CONFIG = C_POINTER;

    private static class RtlRaiseCustomSystemEventTrigger {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("RtlRaiseCustomSystemEventTrigger"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD RtlRaiseCustomSystemEventTrigger(PCUSTOM_SYSTEM_EVENT_TRIGGER_CONFIG TriggerConfig)
     * }
     */
    public static FunctionDescriptor RtlRaiseCustomSystemEventTrigger$descriptor() {
        return RtlRaiseCustomSystemEventTrigger.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD RtlRaiseCustomSystemEventTrigger(PCUSTOM_SYSTEM_EVENT_TRIGGER_CONFIG TriggerConfig)
     * }
     */
    public static MethodHandle RtlRaiseCustomSystemEventTrigger$handle() {
        return RtlRaiseCustomSystemEventTrigger.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * DWORD RtlRaiseCustomSystemEventTrigger(PCUSTOM_SYSTEM_EVENT_TRIGGER_CONFIG TriggerConfig)
     * }
     */
    public static int RtlRaiseCustomSystemEventTrigger(MemorySegment TriggerConfig) {
        var mh$ = RtlRaiseCustomSystemEventTrigger.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RtlRaiseCustomSystemEventTrigger", TriggerConfig);
            }
            return (int)mh$.invokeExact(TriggerConfig);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int ImagePolicyEntryTypeNone = (int)0L;
    /**
     * {@snippet lang=c :
     * enum _IMAGE_POLICY_ENTRY_TYPE.ImagePolicyEntryTypeNone = 0
     * }
     */
    public static int ImagePolicyEntryTypeNone() {
        return ImagePolicyEntryTypeNone;
    }
    private static final int ImagePolicyEntryTypeBool = (int)1L;
    /**
     * {@snippet lang=c :
     * enum _IMAGE_POLICY_ENTRY_TYPE.ImagePolicyEntryTypeBool = 1
     * }
     */
    public static int ImagePolicyEntryTypeBool() {
        return ImagePolicyEntryTypeBool;
    }
    private static final int ImagePolicyEntryTypeInt8 = (int)2L;
    /**
     * {@snippet lang=c :
     * enum _IMAGE_POLICY_ENTRY_TYPE.ImagePolicyEntryTypeInt8 = 2
     * }
     */
    public static int ImagePolicyEntryTypeInt8() {
        return ImagePolicyEntryTypeInt8;
    }
    private static final int ImagePolicyEntryTypeUInt8 = (int)3L;
    /**
     * {@snippet lang=c :
     * enum _IMAGE_POLICY_ENTRY_TYPE.ImagePolicyEntryTypeUInt8 = 3
     * }
     */
    public static int ImagePolicyEntryTypeUInt8() {
        return ImagePolicyEntryTypeUInt8;
    }
    private static final int ImagePolicyEntryTypeInt16 = (int)4L;
    /**
     * {@snippet lang=c :
     * enum _IMAGE_POLICY_ENTRY_TYPE.ImagePolicyEntryTypeInt16 = 4
     * }
     */
    public static int ImagePolicyEntryTypeInt16() {
        return ImagePolicyEntryTypeInt16;
    }
    private static final int ImagePolicyEntryTypeUInt16 = (int)5L;
    /**
     * {@snippet lang=c :
     * enum _IMAGE_POLICY_ENTRY_TYPE.ImagePolicyEntryTypeUInt16 = 5
     * }
     */
    public static int ImagePolicyEntryTypeUInt16() {
        return ImagePolicyEntryTypeUInt16;
    }
    private static final int ImagePolicyEntryTypeInt32 = (int)6L;
    /**
     * {@snippet lang=c :
     * enum _IMAGE_POLICY_ENTRY_TYPE.ImagePolicyEntryTypeInt32 = 6
     * }
     */
    public static int ImagePolicyEntryTypeInt32() {
        return ImagePolicyEntryTypeInt32;
    }
    private static final int ImagePolicyEntryTypeUInt32 = (int)7L;
    /**
     * {@snippet lang=c :
     * enum _IMAGE_POLICY_ENTRY_TYPE.ImagePolicyEntryTypeUInt32 = 7
     * }
     */
    public static int ImagePolicyEntryTypeUInt32() {
        return ImagePolicyEntryTypeUInt32;
    }
    private static final int ImagePolicyEntryTypeInt64 = (int)8L;
    /**
     * {@snippet lang=c :
     * enum _IMAGE_POLICY_ENTRY_TYPE.ImagePolicyEntryTypeInt64 = 8
     * }
     */
    public static int ImagePolicyEntryTypeInt64() {
        return ImagePolicyEntryTypeInt64;
    }
    private static final int ImagePolicyEntryTypeUInt64 = (int)9L;
    /**
     * {@snippet lang=c :
     * enum _IMAGE_POLICY_ENTRY_TYPE.ImagePolicyEntryTypeUInt64 = 9
     * }
     */
    public static int ImagePolicyEntryTypeUInt64() {
        return ImagePolicyEntryTypeUInt64;
    }
    private static final int ImagePolicyEntryTypeAnsiString = (int)10L;
    /**
     * {@snippet lang=c :
     * enum _IMAGE_POLICY_ENTRY_TYPE.ImagePolicyEntryTypeAnsiString = 10
     * }
     */
    public static int ImagePolicyEntryTypeAnsiString() {
        return ImagePolicyEntryTypeAnsiString;
    }
    private static final int ImagePolicyEntryTypeUnicodeString = (int)11L;
    /**
     * {@snippet lang=c :
     * enum _IMAGE_POLICY_ENTRY_TYPE.ImagePolicyEntryTypeUnicodeString = 11
     * }
     */
    public static int ImagePolicyEntryTypeUnicodeString() {
        return ImagePolicyEntryTypeUnicodeString;
    }
    private static final int ImagePolicyEntryTypeOverride = (int)12L;
    /**
     * {@snippet lang=c :
     * enum _IMAGE_POLICY_ENTRY_TYPE.ImagePolicyEntryTypeOverride = 12
     * }
     */
    public static int ImagePolicyEntryTypeOverride() {
        return ImagePolicyEntryTypeOverride;
    }
    private static final int ImagePolicyEntryTypeMaximum = (int)13L;
    /**
     * {@snippet lang=c :
     * enum _IMAGE_POLICY_ENTRY_TYPE.ImagePolicyEntryTypeMaximum = 13
     * }
     */
    public static int ImagePolicyEntryTypeMaximum() {
        return ImagePolicyEntryTypeMaximum;
    }
    private static final int ImagePolicyIdNone = (int)0L;
    /**
     * {@snippet lang=c :
     * enum _IMAGE_POLICY_ID.ImagePolicyIdNone = 0
     * }
     */
    public static int ImagePolicyIdNone() {
        return ImagePolicyIdNone;
    }
    private static final int ImagePolicyIdEtw = (int)1L;
    /**
     * {@snippet lang=c :
     * enum _IMAGE_POLICY_ID.ImagePolicyIdEtw = 1
     * }
     */
    public static int ImagePolicyIdEtw() {
        return ImagePolicyIdEtw;
    }
    private static final int ImagePolicyIdDebug = (int)2L;
    /**
     * {@snippet lang=c :
     * enum _IMAGE_POLICY_ID.ImagePolicyIdDebug = 2
     * }
     */
    public static int ImagePolicyIdDebug() {
        return ImagePolicyIdDebug;
    }
    private static final int ImagePolicyIdCrashDump = (int)3L;
    /**
     * {@snippet lang=c :
     * enum _IMAGE_POLICY_ID.ImagePolicyIdCrashDump = 3
     * }
     */
    public static int ImagePolicyIdCrashDump() {
        return ImagePolicyIdCrashDump;
    }
    private static final int ImagePolicyIdCrashDumpKey = (int)4L;
    /**
     * {@snippet lang=c :
     * enum _IMAGE_POLICY_ID.ImagePolicyIdCrashDumpKey = 4
     * }
     */
    public static int ImagePolicyIdCrashDumpKey() {
        return ImagePolicyIdCrashDumpKey;
    }
    private static final int ImagePolicyIdCrashDumpKeyGuid = (int)5L;
    /**
     * {@snippet lang=c :
     * enum _IMAGE_POLICY_ID.ImagePolicyIdCrashDumpKeyGuid = 5
     * }
     */
    public static int ImagePolicyIdCrashDumpKeyGuid() {
        return ImagePolicyIdCrashDumpKeyGuid;
    }
    private static final int ImagePolicyIdParentSd = (int)6L;
    /**
     * {@snippet lang=c :
     * enum _IMAGE_POLICY_ID.ImagePolicyIdParentSd = 6
     * }
     */
    public static int ImagePolicyIdParentSd() {
        return ImagePolicyIdParentSd;
    }
    private static final int ImagePolicyIdParentSdRev = (int)7L;
    /**
     * {@snippet lang=c :
     * enum _IMAGE_POLICY_ID.ImagePolicyIdParentSdRev = 7
     * }
     */
    public static int ImagePolicyIdParentSdRev() {
        return ImagePolicyIdParentSdRev;
    }
    private static final int ImagePolicyIdSvn = (int)8L;
    /**
     * {@snippet lang=c :
     * enum _IMAGE_POLICY_ID.ImagePolicyIdSvn = 8
     * }
     */
    public static int ImagePolicyIdSvn() {
        return ImagePolicyIdSvn;
    }
    private static final int ImagePolicyIdDeviceId = (int)9L;
    /**
     * {@snippet lang=c :
     * enum _IMAGE_POLICY_ID.ImagePolicyIdDeviceId = 9
     * }
     */
    public static int ImagePolicyIdDeviceId() {
        return ImagePolicyIdDeviceId;
    }
    private static final int ImagePolicyIdCapability = (int)10L;
    /**
     * {@snippet lang=c :
     * enum _IMAGE_POLICY_ID.ImagePolicyIdCapability = 10
     * }
     */
    public static int ImagePolicyIdCapability() {
        return ImagePolicyIdCapability;
    }
    private static final int ImagePolicyIdScenarioId = (int)11L;
    /**
     * {@snippet lang=c :
     * enum _IMAGE_POLICY_ID.ImagePolicyIdScenarioId = 11
     * }
     */
    public static int ImagePolicyIdScenarioId() {
        return ImagePolicyIdScenarioId;
    }
    private static final int ImagePolicyIdMaximum = (int)12L;
    /**
     * {@snippet lang=c :
     * enum _IMAGE_POLICY_ID.ImagePolicyIdMaximum = 12
     * }
     */
    public static int ImagePolicyIdMaximum() {
        return ImagePolicyIdMaximum;
    }
    /**
     * {@snippet lang=c :
     * typedef const IMAGE_POLICY_ENTRY *PCIMAGE_POLICY_ENTRY
     * }
     */
    public static final AddressLayout PCIMAGE_POLICY_ENTRY = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef const IMAGE_POLICY_METADATA *PCIMAGE_POLICY_METADATA
     * }
     */
    public static final AddressLayout PCIMAGE_POLICY_METADATA = C_POINTER;

    private static class RtlIsZeroMemory {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_CHAR,
            C_POINTER,
            C_LONG_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("RtlIsZeroMemory"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOLEAN RtlIsZeroMemory(PVOID Buffer, SIZE_T Length)
     * }
     */
    public static FunctionDescriptor RtlIsZeroMemory$descriptor() {
        return RtlIsZeroMemory.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOLEAN RtlIsZeroMemory(PVOID Buffer, SIZE_T Length)
     * }
     */
    public static MethodHandle RtlIsZeroMemory$handle() {
        return RtlIsZeroMemory.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOLEAN RtlIsZeroMemory(PVOID Buffer, SIZE_T Length)
     * }
     */
    public static byte RtlIsZeroMemory(MemorySegment Buffer, long Length) {
        var mh$ = RtlIsZeroMemory.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RtlIsZeroMemory", Buffer, Length);
            }
            return (byte)mh$.invokeExact(Buffer, Length);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RtlNormalizeSecurityDescriptor {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_CHAR,
            C_POINTER,
            C_LONG,
            C_POINTER,
            C_POINTER,
            C_CHAR
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("RtlNormalizeSecurityDescriptor"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOLEAN RtlNormalizeSecurityDescriptor(PSECURITY_DESCRIPTOR *SecurityDescriptor, DWORD SecurityDescriptorLength, PSECURITY_DESCRIPTOR *NewSecurityDescriptor, PDWORD NewSecurityDescriptorLength, BOOLEAN CheckOnly)
     * }
     */
    public static FunctionDescriptor RtlNormalizeSecurityDescriptor$descriptor() {
        return RtlNormalizeSecurityDescriptor.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOLEAN RtlNormalizeSecurityDescriptor(PSECURITY_DESCRIPTOR *SecurityDescriptor, DWORD SecurityDescriptorLength, PSECURITY_DESCRIPTOR *NewSecurityDescriptor, PDWORD NewSecurityDescriptorLength, BOOLEAN CheckOnly)
     * }
     */
    public static MethodHandle RtlNormalizeSecurityDescriptor$handle() {
        return RtlNormalizeSecurityDescriptor.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOLEAN RtlNormalizeSecurityDescriptor(PSECURITY_DESCRIPTOR *SecurityDescriptor, DWORD SecurityDescriptorLength, PSECURITY_DESCRIPTOR *NewSecurityDescriptor, PDWORD NewSecurityDescriptorLength, BOOLEAN CheckOnly)
     * }
     */
    public static byte RtlNormalizeSecurityDescriptor(MemorySegment SecurityDescriptor, int SecurityDescriptorLength, MemorySegment NewSecurityDescriptor, MemorySegment NewSecurityDescriptorLength, byte CheckOnly) {
        var mh$ = RtlNormalizeSecurityDescriptor.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RtlNormalizeSecurityDescriptor", SecurityDescriptor, SecurityDescriptorLength, NewSecurityDescriptor, NewSecurityDescriptorLength, CheckOnly);
            }
            return (byte)mh$.invokeExact(SecurityDescriptor, SecurityDescriptorLength, NewSecurityDescriptor, NewSecurityDescriptorLength, CheckOnly);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int GlobalDataIdUnknown = (int)0L;
    /**
     * {@snippet lang=c :
     * enum _RTL_SYSTEM_GLOBAL_DATA_ID.GlobalDataIdUnknown = 0
     * }
     */
    public static int GlobalDataIdUnknown() {
        return GlobalDataIdUnknown;
    }
    private static final int GlobalDataIdRngSeedVersion = (int)1L;
    /**
     * {@snippet lang=c :
     * enum _RTL_SYSTEM_GLOBAL_DATA_ID.GlobalDataIdRngSeedVersion = 1
     * }
     */
    public static int GlobalDataIdRngSeedVersion() {
        return GlobalDataIdRngSeedVersion;
    }
    private static final int GlobalDataIdInterruptTime = (int)2L;
    /**
     * {@snippet lang=c :
     * enum _RTL_SYSTEM_GLOBAL_DATA_ID.GlobalDataIdInterruptTime = 2
     * }
     */
    public static int GlobalDataIdInterruptTime() {
        return GlobalDataIdInterruptTime;
    }
    private static final int GlobalDataIdTimeZoneBias = (int)3L;
    /**
     * {@snippet lang=c :
     * enum _RTL_SYSTEM_GLOBAL_DATA_ID.GlobalDataIdTimeZoneBias = 3
     * }
     */
    public static int GlobalDataIdTimeZoneBias() {
        return GlobalDataIdTimeZoneBias;
    }
    private static final int GlobalDataIdImageNumberLow = (int)4L;
    /**
     * {@snippet lang=c :
     * enum _RTL_SYSTEM_GLOBAL_DATA_ID.GlobalDataIdImageNumberLow = 4
     * }
     */
    public static int GlobalDataIdImageNumberLow() {
        return GlobalDataIdImageNumberLow;
    }
    private static final int GlobalDataIdImageNumberHigh = (int)5L;
    /**
     * {@snippet lang=c :
     * enum _RTL_SYSTEM_GLOBAL_DATA_ID.GlobalDataIdImageNumberHigh = 5
     * }
     */
    public static int GlobalDataIdImageNumberHigh() {
        return GlobalDataIdImageNumberHigh;
    }
    private static final int GlobalDataIdTimeZoneId = (int)6L;
    /**
     * {@snippet lang=c :
     * enum _RTL_SYSTEM_GLOBAL_DATA_ID.GlobalDataIdTimeZoneId = 6
     * }
     */
    public static int GlobalDataIdTimeZoneId() {
        return GlobalDataIdTimeZoneId;
    }
    private static final int GlobalDataIdNtMajorVersion = (int)7L;
    /**
     * {@snippet lang=c :
     * enum _RTL_SYSTEM_GLOBAL_DATA_ID.GlobalDataIdNtMajorVersion = 7
     * }
     */
    public static int GlobalDataIdNtMajorVersion() {
        return GlobalDataIdNtMajorVersion;
    }
    private static final int GlobalDataIdNtMinorVersion = (int)8L;
    /**
     * {@snippet lang=c :
     * enum _RTL_SYSTEM_GLOBAL_DATA_ID.GlobalDataIdNtMinorVersion = 8
     * }
     */
    public static int GlobalDataIdNtMinorVersion() {
        return GlobalDataIdNtMinorVersion;
    }
    private static final int GlobalDataIdSystemExpirationDate = (int)9L;
    /**
     * {@snippet lang=c :
     * enum _RTL_SYSTEM_GLOBAL_DATA_ID.GlobalDataIdSystemExpirationDate = 9
     * }
     */
    public static int GlobalDataIdSystemExpirationDate() {
        return GlobalDataIdSystemExpirationDate;
    }
    private static final int GlobalDataIdKdDebuggerEnabled = (int)10L;
    /**
     * {@snippet lang=c :
     * enum _RTL_SYSTEM_GLOBAL_DATA_ID.GlobalDataIdKdDebuggerEnabled = 10
     * }
     */
    public static int GlobalDataIdKdDebuggerEnabled() {
        return GlobalDataIdKdDebuggerEnabled;
    }
    private static final int GlobalDataIdCyclesPerYield = (int)11L;
    /**
     * {@snippet lang=c :
     * enum _RTL_SYSTEM_GLOBAL_DATA_ID.GlobalDataIdCyclesPerYield = 11
     * }
     */
    public static int GlobalDataIdCyclesPerYield() {
        return GlobalDataIdCyclesPerYield;
    }
    private static final int GlobalDataIdSafeBootMode = (int)12L;
    /**
     * {@snippet lang=c :
     * enum _RTL_SYSTEM_GLOBAL_DATA_ID.GlobalDataIdSafeBootMode = 12
     * }
     */
    public static int GlobalDataIdSafeBootMode() {
        return GlobalDataIdSafeBootMode;
    }
    private static final int GlobalDataIdLastSystemRITEventTickCount = (int)13L;
    /**
     * {@snippet lang=c :
     * enum _RTL_SYSTEM_GLOBAL_DATA_ID.GlobalDataIdLastSystemRITEventTickCount = 13
     * }
     */
    public static int GlobalDataIdLastSystemRITEventTickCount() {
        return GlobalDataIdLastSystemRITEventTickCount;
    }
    /**
     * {@snippet lang=c :
     * typedef enum _RTL_SYSTEM_GLOBAL_DATA_ID {
     *     GlobalDataIdUnknown = 0,
     *     GlobalDataIdRngSeedVersion,
     *     GlobalDataIdInterruptTime,
     *     GlobalDataIdTimeZoneBias,
     *     GlobalDataIdImageNumberLow,
     *     GlobalDataIdImageNumberHigh,
     *     GlobalDataIdTimeZoneId,
     *     GlobalDataIdNtMajorVersion,
     *     GlobalDataIdNtMinorVersion,
     *     GlobalDataIdSystemExpirationDate,
     *     GlobalDataIdKdDebuggerEnabled,
     *     GlobalDataIdCyclesPerYield,
     *     GlobalDataIdSafeBootMode,
     *     GlobalDataIdLastSystemRITEventTickCount
     * } *PRTL_SYSTEM_GLOBAL_DATA_ID
     * }
     */
    public static final AddressLayout PRTL_SYSTEM_GLOBAL_DATA_ID = C_POINTER;

    private static class RtlGetSystemGlobalData {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_INT,
            C_POINTER,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("RtlGetSystemGlobalData"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD RtlGetSystemGlobalData(RTL_SYSTEM_GLOBAL_DATA_ID DataId, PVOID Buffer, DWORD Size)
     * }
     */
    public static FunctionDescriptor RtlGetSystemGlobalData$descriptor() {
        return RtlGetSystemGlobalData.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD RtlGetSystemGlobalData(RTL_SYSTEM_GLOBAL_DATA_ID DataId, PVOID Buffer, DWORD Size)
     * }
     */
    public static MethodHandle RtlGetSystemGlobalData$handle() {
        return RtlGetSystemGlobalData.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * DWORD RtlGetSystemGlobalData(RTL_SYSTEM_GLOBAL_DATA_ID DataId, PVOID Buffer, DWORD Size)
     * }
     */
    public static int RtlGetSystemGlobalData(int DataId, MemorySegment Buffer, int Size) {
        var mh$ = RtlGetSystemGlobalData.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RtlGetSystemGlobalData", DataId, Buffer, Size);
            }
            return (int)mh$.invokeExact(DataId, Buffer, Size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RtlSetSystemGlobalData {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_INT,
            C_POINTER,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("RtlSetSystemGlobalData"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD RtlSetSystemGlobalData(RTL_SYSTEM_GLOBAL_DATA_ID DataId, PVOID Buffer, DWORD Size)
     * }
     */
    public static FunctionDescriptor RtlSetSystemGlobalData$descriptor() {
        return RtlSetSystemGlobalData.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD RtlSetSystemGlobalData(RTL_SYSTEM_GLOBAL_DATA_ID DataId, PVOID Buffer, DWORD Size)
     * }
     */
    public static MethodHandle RtlSetSystemGlobalData$handle() {
        return RtlSetSystemGlobalData.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * DWORD RtlSetSystemGlobalData(RTL_SYSTEM_GLOBAL_DATA_ID DataId, PVOID Buffer, DWORD Size)
     * }
     */
    public static int RtlSetSystemGlobalData(int DataId, MemorySegment Buffer, int Size) {
        var mh$ = RtlSetSystemGlobalData.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RtlSetSystemGlobalData", DataId, Buffer, Size);
            }
            return (int)mh$.invokeExact(DataId, Buffer, Size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct _RTL_CRITICAL_SECTION_DEBUG {
     *     WORD Type;
     *     WORD CreatorBackTraceIndex;
     *     struct _RTL_CRITICAL_SECTION *CriticalSection;
     *     LIST_ENTRY ProcessLocksList;
     *     DWORD EntryCount;
     *     DWORD ContentionCount;
     *     DWORD Flags;
     *     WORD CreatorBackTraceIndexHigh;
     *     WORD SpareWORD;
     * } *PRTL_CRITICAL_SECTION_DEBUG
     * }
     */
    public static final AddressLayout PRTL_CRITICAL_SECTION_DEBUG = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _RTL_CRITICAL_SECTION_DEBUG {
     *     WORD Type;
     *     WORD CreatorBackTraceIndex;
     *     struct _RTL_CRITICAL_SECTION *CriticalSection;
     *     LIST_ENTRY ProcessLocksList;
     *     DWORD EntryCount;
     *     DWORD ContentionCount;
     *     DWORD Flags;
     *     WORD CreatorBackTraceIndexHigh;
     *     WORD SpareWORD;
     * } *PRTL_RESOURCE_DEBUG
     * }
     */
    public static final AddressLayout PRTL_RESOURCE_DEBUG = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _RTL_CRITICAL_SECTION {
     *     PRTL_CRITICAL_SECTION_DEBUG DebugInfo;
     *     LONG LockCount;
     *     LONG RecursionCount;
     *     HANDLE OwningThread;
     *     HANDLE LockSemaphore;
     *     ULONG_PTR SpinCount;
     * } *PRTL_CRITICAL_SECTION
     * }
     */
    public static final AddressLayout PRTL_CRITICAL_SECTION = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _RTL_SRWLOCK {
     *     PVOID Ptr;
     * } *PRTL_SRWLOCK
     * }
     */
    public static final AddressLayout PRTL_SRWLOCK = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _RTL_CONDITION_VARIABLE {
     *     PVOID Ptr;
     * } *PRTL_CONDITION_VARIABLE
     * }
     */
    public static final AddressLayout PRTL_CONDITION_VARIABLE = C_POINTER;
    private static final int HeapCompatibilityInformation = (int)0L;
    /**
     * {@snippet lang=c :
     * enum _HEAP_INFORMATION_CLASS.HeapCompatibilityInformation = 0
     * }
     */
    public static int HeapCompatibilityInformation() {
        return HeapCompatibilityInformation;
    }
    private static final int HeapEnableTerminationOnCorruption = (int)1L;
    /**
     * {@snippet lang=c :
     * enum _HEAP_INFORMATION_CLASS.HeapEnableTerminationOnCorruption = 1
     * }
     */
    public static int HeapEnableTerminationOnCorruption() {
        return HeapEnableTerminationOnCorruption;
    }
    private static final int HeapOptimizeResources = (int)3L;
    /**
     * {@snippet lang=c :
     * enum _HEAP_INFORMATION_CLASS.HeapOptimizeResources = 3
     * }
     */
    public static int HeapOptimizeResources() {
        return HeapOptimizeResources;
    }
    private static final int HeapTag = (int)7L;
    /**
     * {@snippet lang=c :
     * enum _HEAP_INFORMATION_CLASS.HeapTag = 7
     * }
     */
    public static int HeapTag() {
        return HeapTag;
    }
    /**
     * {@snippet lang=c :
     * typedef struct _HEAP_OPTIMIZE_RESOURCES_INFORMATION {
     *     DWORD Version;
     *     DWORD Flags;
     * } *PHEAP_OPTIMIZE_RESOURCES_INFORMATION
     * }
     */
    public static final AddressLayout PHEAP_OPTIMIZE_RESOURCES_INFORMATION = C_POINTER;
    private static final int ActivationContextBasicInformation = (int)1L;
    /**
     * {@snippet lang=c :
     * enum _ACTIVATION_CONTEXT_INFO_CLASS.ActivationContextBasicInformation = 1
     * }
     */
    public static int ActivationContextBasicInformation() {
        return ActivationContextBasicInformation;
    }
    private static final int ActivationContextDetailedInformation = (int)2L;
    /**
     * {@snippet lang=c :
     * enum _ACTIVATION_CONTEXT_INFO_CLASS.ActivationContextDetailedInformation = 2
     * }
     */
    public static int ActivationContextDetailedInformation() {
        return ActivationContextDetailedInformation;
    }
    private static final int AssemblyDetailedInformationInActivationContext = (int)3L;
    /**
     * {@snippet lang=c :
     * enum _ACTIVATION_CONTEXT_INFO_CLASS.AssemblyDetailedInformationInActivationContext = 3
     * }
     */
    public static int AssemblyDetailedInformationInActivationContext() {
        return AssemblyDetailedInformationInActivationContext;
    }
    private static final int FileInformationInAssemblyOfAssemblyInActivationContext = (int)4L;
    /**
     * {@snippet lang=c :
     * enum _ACTIVATION_CONTEXT_INFO_CLASS.FileInformationInAssemblyOfAssemblyInActivationContext = 4
     * }
     */
    public static int FileInformationInAssemblyOfAssemblyInActivationContext() {
        return FileInformationInAssemblyOfAssemblyInActivationContext;
    }
    private static final int RunlevelInformationInActivationContext = (int)5L;
    /**
     * {@snippet lang=c :
     * enum _ACTIVATION_CONTEXT_INFO_CLASS.RunlevelInformationInActivationContext = 5
     * }
     */
    public static int RunlevelInformationInActivationContext() {
        return RunlevelInformationInActivationContext;
    }
    private static final int CompatibilityInformationInActivationContext = (int)6L;
    /**
     * {@snippet lang=c :
     * enum _ACTIVATION_CONTEXT_INFO_CLASS.CompatibilityInformationInActivationContext = 6
     * }
     */
    public static int CompatibilityInformationInActivationContext() {
        return CompatibilityInformationInActivationContext;
    }
    private static final int ActivationContextManifestResourceName = (int)7L;
    /**
     * {@snippet lang=c :
     * enum _ACTIVATION_CONTEXT_INFO_CLASS.ActivationContextManifestResourceName = 7
     * }
     */
    public static int ActivationContextManifestResourceName() {
        return ActivationContextManifestResourceName;
    }
    private static final int MaxActivationContextInfoClass = (int)8L;
    /**
     * {@snippet lang=c :
     * enum _ACTIVATION_CONTEXT_INFO_CLASS.MaxActivationContextInfoClass = 8
     * }
     */
    public static int MaxActivationContextInfoClass() {
        return MaxActivationContextInfoClass;
    }
    private static final int AssemblyDetailedInformationInActivationContxt = (int)3L;
    /**
     * {@snippet lang=c :
     * enum _ACTIVATION_CONTEXT_INFO_CLASS.AssemblyDetailedInformationInActivationContxt = 3
     * }
     */
    public static int AssemblyDetailedInformationInActivationContxt() {
        return AssemblyDetailedInformationInActivationContxt;
    }
    private static final int FileInformationInAssemblyOfAssemblyInActivationContxt = (int)4L;
    /**
     * {@snippet lang=c :
     * enum _ACTIVATION_CONTEXT_INFO_CLASS.FileInformationInAssemblyOfAssemblyInActivationContxt = 4
     * }
     */
    public static int FileInformationInAssemblyOfAssemblyInActivationContxt() {
        return FileInformationInAssemblyOfAssemblyInActivationContxt;
    }
    /**
     * {@snippet lang=c :
     * typedef struct _ACTIVATION_CONTEXT_QUERY_INDEX {
     *     DWORD ulAssemblyIndex;
     *     DWORD ulFileIndexInAssembly;
     * } *PACTIVATION_CONTEXT_QUERY_INDEX
     * }
     */
    public static final AddressLayout PACTIVATION_CONTEXT_QUERY_INDEX = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef const struct _ACTIVATION_CONTEXT_QUERY_INDEX {
     *     DWORD ulAssemblyIndex;
     *     DWORD ulFileIndexInAssembly;
     * } *PCACTIVATION_CONTEXT_QUERY_INDEX
     * }
     */
    public static final AddressLayout PCACTIVATION_CONTEXT_QUERY_INDEX = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _ASSEMBLY_FILE_DETAILED_INFORMATION {
     *     DWORD ulFlags;
     *     DWORD ulFilenameLength;
     *     DWORD ulPathLength;
     *     PCWSTR lpFileName;
     *     PCWSTR lpFilePath;
     * } *PASSEMBLY_FILE_DETAILED_INFORMATION
     * }
     */
    public static final AddressLayout PASSEMBLY_FILE_DETAILED_INFORMATION = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef const ASSEMBLY_FILE_DETAILED_INFORMATION *PCASSEMBLY_FILE_DETAILED_INFORMATION
     * }
     */
    public static final AddressLayout PCASSEMBLY_FILE_DETAILED_INFORMATION = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _ACTIVATION_CONTEXT_ASSEMBLY_DETAILED_INFORMATION {
     *     DWORD ulFlags;
     *     DWORD ulEncodedAssemblyIdentityLength;
     *     DWORD ulManifestPathType;
     *     DWORD ulManifestPathLength;
     *     LARGE_INTEGER liManifestLastWriteTime;
     *     DWORD ulPolicyPathType;
     *     DWORD ulPolicyPathLength;
     *     LARGE_INTEGER liPolicyLastWriteTime;
     *     DWORD ulMetadataSatelliteRosterIndex;
     *     DWORD ulManifestVersionMajor;
     *     DWORD ulManifestVersionMinor;
     *     DWORD ulPolicyVersionMajor;
     *     DWORD ulPolicyVersionMinor;
     *     DWORD ulAssemblyDirectoryNameLength;
     *     PCWSTR lpAssemblyEncodedAssemblyIdentity;
     *     PCWSTR lpAssemblyManifestPath;
     *     PCWSTR lpAssemblyPolicyPath;
     *     PCWSTR lpAssemblyDirectoryName;
     *     DWORD ulFileCount;
     * } *PACTIVATION_CONTEXT_ASSEMBLY_DETAILED_INFORMATION
     * }
     */
    public static final AddressLayout PACTIVATION_CONTEXT_ASSEMBLY_DETAILED_INFORMATION = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef const struct _ACTIVATION_CONTEXT_ASSEMBLY_DETAILED_INFORMATION {
     *     DWORD ulFlags;
     *     DWORD ulEncodedAssemblyIdentityLength;
     *     DWORD ulManifestPathType;
     *     DWORD ulManifestPathLength;
     *     LARGE_INTEGER liManifestLastWriteTime;
     *     DWORD ulPolicyPathType;
     *     DWORD ulPolicyPathLength;
     *     LARGE_INTEGER liPolicyLastWriteTime;
     *     DWORD ulMetadataSatelliteRosterIndex;
     *     DWORD ulManifestVersionMajor;
     *     DWORD ulManifestVersionMinor;
     *     DWORD ulPolicyVersionMajor;
     *     DWORD ulPolicyVersionMinor;
     *     DWORD ulAssemblyDirectoryNameLength;
     *     PCWSTR lpAssemblyEncodedAssemblyIdentity;
     *     PCWSTR lpAssemblyManifestPath;
     *     PCWSTR lpAssemblyPolicyPath;
     *     PCWSTR lpAssemblyDirectoryName;
     *     DWORD ulFileCount;
     * } *PCACTIVATION_CONTEXT_ASSEMBLY_DETAILED_INFORMATION
     * }
     */
    public static final AddressLayout PCACTIVATION_CONTEXT_ASSEMBLY_DETAILED_INFORMATION = C_POINTER;
    private static final int ACTCTX_RUN_LEVEL_UNSPECIFIED = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.ACTCTX_RUN_LEVEL_UNSPECIFIED = 0
     * }
     */
    public static int ACTCTX_RUN_LEVEL_UNSPECIFIED() {
        return ACTCTX_RUN_LEVEL_UNSPECIFIED;
    }
    private static final int ACTCTX_RUN_LEVEL_AS_INVOKER = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.ACTCTX_RUN_LEVEL_AS_INVOKER = 1
     * }
     */
    public static int ACTCTX_RUN_LEVEL_AS_INVOKER() {
        return ACTCTX_RUN_LEVEL_AS_INVOKER;
    }
    private static final int ACTCTX_RUN_LEVEL_HIGHEST_AVAILABLE = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.ACTCTX_RUN_LEVEL_HIGHEST_AVAILABLE = 2
     * }
     */
    public static int ACTCTX_RUN_LEVEL_HIGHEST_AVAILABLE() {
        return ACTCTX_RUN_LEVEL_HIGHEST_AVAILABLE;
    }
    private static final int ACTCTX_RUN_LEVEL_REQUIRE_ADMIN = (int)3L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.ACTCTX_RUN_LEVEL_REQUIRE_ADMIN = 3
     * }
     */
    public static int ACTCTX_RUN_LEVEL_REQUIRE_ADMIN() {
        return ACTCTX_RUN_LEVEL_REQUIRE_ADMIN;
    }
    private static final int ACTCTX_RUN_LEVEL_NUMBERS = (int)4L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.ACTCTX_RUN_LEVEL_NUMBERS = 4
     * }
     */
    public static int ACTCTX_RUN_LEVEL_NUMBERS() {
        return ACTCTX_RUN_LEVEL_NUMBERS;
    }
    /**
     * {@snippet lang=c :
     * typedef struct _ACTIVATION_CONTEXT_RUN_LEVEL_INFORMATION {
     *     DWORD ulFlags;
     *     ACTCTX_REQUESTED_RUN_LEVEL RunLevel;
     *     DWORD UiAccess;
     * } *PACTIVATION_CONTEXT_RUN_LEVEL_INFORMATION
     * }
     */
    public static final AddressLayout PACTIVATION_CONTEXT_RUN_LEVEL_INFORMATION = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef const struct _ACTIVATION_CONTEXT_RUN_LEVEL_INFORMATION {
     *     DWORD ulFlags;
     *     ACTCTX_REQUESTED_RUN_LEVEL RunLevel;
     *     DWORD UiAccess;
     * } *PCACTIVATION_CONTEXT_RUN_LEVEL_INFORMATION
     * }
     */
    public static final AddressLayout PCACTIVATION_CONTEXT_RUN_LEVEL_INFORMATION = C_POINTER;
    private static final int ACTCTX_COMPATIBILITY_ELEMENT_TYPE_UNKNOWN = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.ACTCTX_COMPATIBILITY_ELEMENT_TYPE_UNKNOWN = 0
     * }
     */
    public static int ACTCTX_COMPATIBILITY_ELEMENT_TYPE_UNKNOWN() {
        return ACTCTX_COMPATIBILITY_ELEMENT_TYPE_UNKNOWN;
    }
    private static final int ACTCTX_COMPATIBILITY_ELEMENT_TYPE_OS = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.ACTCTX_COMPATIBILITY_ELEMENT_TYPE_OS = 1
     * }
     */
    public static int ACTCTX_COMPATIBILITY_ELEMENT_TYPE_OS() {
        return ACTCTX_COMPATIBILITY_ELEMENT_TYPE_OS;
    }
    private static final int ACTCTX_COMPATIBILITY_ELEMENT_TYPE_MITIGATION = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.ACTCTX_COMPATIBILITY_ELEMENT_TYPE_MITIGATION = 2
     * }
     */
    public static int ACTCTX_COMPATIBILITY_ELEMENT_TYPE_MITIGATION() {
        return ACTCTX_COMPATIBILITY_ELEMENT_TYPE_MITIGATION;
    }
    private static final int ACTCTX_COMPATIBILITY_ELEMENT_TYPE_MAXVERSIONTESTED = (int)3L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.ACTCTX_COMPATIBILITY_ELEMENT_TYPE_MAXVERSIONTESTED = 3
     * }
     */
    public static int ACTCTX_COMPATIBILITY_ELEMENT_TYPE_MAXVERSIONTESTED() {
        return ACTCTX_COMPATIBILITY_ELEMENT_TYPE_MAXVERSIONTESTED;
    }
    /**
     * {@snippet lang=c :
     * typedef struct _COMPATIBILITY_CONTEXT_ELEMENT {
     *     GUID Id;
     *     ACTCTX_COMPATIBILITY_ELEMENT_TYPE Type;
     *     ULONGLONG MaxVersionTested;
     * } *PCOMPATIBILITY_CONTEXT_ELEMENT
     * }
     */
    public static final AddressLayout PCOMPATIBILITY_CONTEXT_ELEMENT = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef const struct _COMPATIBILITY_CONTEXT_ELEMENT {
     *     GUID Id;
     *     ACTCTX_COMPATIBILITY_ELEMENT_TYPE Type;
     *     ULONGLONG MaxVersionTested;
     * } *PCCOMPATIBILITY_CONTEXT_ELEMENT
     * }
     */
    public static final AddressLayout PCCOMPATIBILITY_CONTEXT_ELEMENT = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _ACTIVATION_CONTEXT_COMPATIBILITY_INFORMATION {
     *     DWORD ElementCount;
     *     COMPATIBILITY_CONTEXT_ELEMENT Elements[];
     * } *PACTIVATION_CONTEXT_COMPATIBILITY_INFORMATION
     * }
     */
    public static final AddressLayout PACTIVATION_CONTEXT_COMPATIBILITY_INFORMATION = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef const struct _ACTIVATION_CONTEXT_COMPATIBILITY_INFORMATION {
     *     DWORD ElementCount;
     *     COMPATIBILITY_CONTEXT_ELEMENT Elements[];
     * } *PCACTIVATION_CONTEXT_COMPATIBILITY_INFORMATION
     * }
     */
    public static final AddressLayout PCACTIVATION_CONTEXT_COMPATIBILITY_INFORMATION = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _SUPPORTED_OS_INFO {
     *     WORD MajorVersion;
     *     WORD MinorVersion;
     * } *PSUPPORTED_OS_INFO
     * }
     */
    public static final AddressLayout PSUPPORTED_OS_INFO = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _MAXVERSIONTESTED_INFO {
     *     ULONGLONG MaxVersionTested;
     * } *PMAXVERSIONTESTED_INFO
     * }
     */
    public static final AddressLayout PMAXVERSIONTESTED_INFO = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _ACTIVATION_CONTEXT_DETAILED_INFORMATION {
     *     DWORD dwFlags;
     *     DWORD ulFormatVersion;
     *     DWORD ulAssemblyCount;
     *     DWORD ulRootManifestPathType;
     *     DWORD ulRootManifestPathChars;
     *     DWORD ulRootConfigurationPathType;
     *     DWORD ulRootConfigurationPathChars;
     *     DWORD ulAppDirPathType;
     *     DWORD ulAppDirPathChars;
     *     PCWSTR lpRootManifestPath;
     *     PCWSTR lpRootConfigurationPath;
     *     PCWSTR lpAppDirPath;
     * } *PACTIVATION_CONTEXT_DETAILED_INFORMATION
     * }
     */
    public static final AddressLayout PACTIVATION_CONTEXT_DETAILED_INFORMATION = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef const struct _ACTIVATION_CONTEXT_DETAILED_INFORMATION {
     *     DWORD dwFlags;
     *     DWORD ulFormatVersion;
     *     DWORD ulAssemblyCount;
     *     DWORD ulRootManifestPathType;
     *     DWORD ulRootManifestPathChars;
     *     DWORD ulRootConfigurationPathType;
     *     DWORD ulRootConfigurationPathChars;
     *     DWORD ulAppDirPathType;
     *     DWORD ulAppDirPathChars;
     *     PCWSTR lpRootManifestPath;
     *     PCWSTR lpRootConfigurationPath;
     *     PCWSTR lpAppDirPath;
     * } *PCACTIVATION_CONTEXT_DETAILED_INFORMATION
     * }
     */
    public static final AddressLayout PCACTIVATION_CONTEXT_DETAILED_INFORMATION = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _HARDWARE_COUNTER_DATA {
     *     HARDWARE_COUNTER_TYPE Type;
     *     DWORD Reserved;
     *     DWORD64 Value;
     * } *PHARDWARE_COUNTER_DATA
     * }
     */
    public static final AddressLayout PHARDWARE_COUNTER_DATA = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _PERFORMANCE_DATA {
     *     WORD Size;
     *     BYTE Version;
     *     BYTE HwCountersCount;
     *     DWORD ContextSwitchCount;
     *     DWORD64 WaitReasonBitMap;
     *     DWORD64 CycleTime;
     *     DWORD RetryCount;
     *     DWORD Reserved;
     *     HARDWARE_COUNTER_DATA HwCounters[16];
     * } *PPERFORMANCE_DATA
     * }
     */
    public static final AddressLayout PPERFORMANCE_DATA = C_POINTER;

    private static class RtlGetDeviceFamilyInfoEnum {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("RtlGetDeviceFamilyInfoEnum"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void RtlGetDeviceFamilyInfoEnum(ULONGLONG *pullUAPInfo, DWORD *pulDeviceFamily, DWORD *pulDeviceForm)
     * }
     */
    public static FunctionDescriptor RtlGetDeviceFamilyInfoEnum$descriptor() {
        return RtlGetDeviceFamilyInfoEnum.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void RtlGetDeviceFamilyInfoEnum(ULONGLONG *pullUAPInfo, DWORD *pulDeviceFamily, DWORD *pulDeviceForm)
     * }
     */
    public static MethodHandle RtlGetDeviceFamilyInfoEnum$handle() {
        return RtlGetDeviceFamilyInfoEnum.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * void RtlGetDeviceFamilyInfoEnum(ULONGLONG *pullUAPInfo, DWORD *pulDeviceFamily, DWORD *pulDeviceForm)
     * }
     */
    public static void RtlGetDeviceFamilyInfoEnum(MemorySegment pullUAPInfo, MemorySegment pulDeviceFamily, MemorySegment pulDeviceForm) {
        var mh$ = RtlGetDeviceFamilyInfoEnum.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RtlGetDeviceFamilyInfoEnum", pullUAPInfo, pulDeviceFamily, pulDeviceForm);
            }
            mh$.invokeExact(pullUAPInfo, pulDeviceFamily, pulDeviceForm);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RtlConvertDeviceFamilyInfoToString {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("RtlConvertDeviceFamilyInfoToString"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD RtlConvertDeviceFamilyInfoToString(PDWORD pulDeviceFamilyBufferSize, PDWORD pulDeviceFormBufferSize, PWSTR DeviceFamily, PWSTR DeviceForm)
     * }
     */
    public static FunctionDescriptor RtlConvertDeviceFamilyInfoToString$descriptor() {
        return RtlConvertDeviceFamilyInfoToString.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD RtlConvertDeviceFamilyInfoToString(PDWORD pulDeviceFamilyBufferSize, PDWORD pulDeviceFormBufferSize, PWSTR DeviceFamily, PWSTR DeviceForm)
     * }
     */
    public static MethodHandle RtlConvertDeviceFamilyInfoToString$handle() {
        return RtlConvertDeviceFamilyInfoToString.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * DWORD RtlConvertDeviceFamilyInfoToString(PDWORD pulDeviceFamilyBufferSize, PDWORD pulDeviceFormBufferSize, PWSTR DeviceFamily, PWSTR DeviceForm)
     * }
     */
    public static int RtlConvertDeviceFamilyInfoToString(MemorySegment pulDeviceFamilyBufferSize, MemorySegment pulDeviceFormBufferSize, MemorySegment DeviceFamily, MemorySegment DeviceForm) {
        var mh$ = RtlConvertDeviceFamilyInfoToString.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RtlConvertDeviceFamilyInfoToString", pulDeviceFamilyBufferSize, pulDeviceFormBufferSize, DeviceFamily, DeviceForm);
            }
            return (int)mh$.invokeExact(pulDeviceFamilyBufferSize, pulDeviceFormBufferSize, DeviceFamily, DeviceForm);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RtlSwitchedVVI {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_POINTER,
            C_LONG,
            C_LONG_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("RtlSwitchedVVI"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD RtlSwitchedVVI(PRTL_OSVERSIONINFOEXW VersionInfo, DWORD TypeMask, ULONGLONG ConditionMask)
     * }
     */
    public static FunctionDescriptor RtlSwitchedVVI$descriptor() {
        return RtlSwitchedVVI.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD RtlSwitchedVVI(PRTL_OSVERSIONINFOEXW VersionInfo, DWORD TypeMask, ULONGLONG ConditionMask)
     * }
     */
    public static MethodHandle RtlSwitchedVVI$handle() {
        return RtlSwitchedVVI.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * DWORD RtlSwitchedVVI(PRTL_OSVERSIONINFOEXW VersionInfo, DWORD TypeMask, ULONGLONG ConditionMask)
     * }
     */
    public static int RtlSwitchedVVI(MemorySegment VersionInfo, int TypeMask, long ConditionMask) {
        var mh$ = RtlSwitchedVVI.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RtlSwitchedVVI", VersionInfo, TypeMask, ConditionMask);
            }
            return (int)mh$.invokeExact(VersionInfo, TypeMask, ConditionMask);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct _EVENTLOGRECORD {
     *     DWORD Length;
     *     DWORD Reserved;
     *     DWORD RecordNumber;
     *     DWORD TimeGenerated;
     *     DWORD TimeWritten;
     *     DWORD EventID;
     *     WORD EventType;
     *     WORD NumStrings;
     *     WORD EventCategory;
     *     WORD ReservedFlags;
     *     DWORD ClosingRecordNumber;
     *     DWORD StringOffset;
     *     DWORD UserSidLength;
     *     DWORD UserSidOffset;
     *     DWORD DataLength;
     *     DWORD DataOffset;
     * } *PEVENTLOGRECORD
     * }
     */
    public static final AddressLayout PEVENTLOGRECORD = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _EVENTSFORLOGFILE {
     *     DWORD ulSize;
     *     WCHAR szLogicalLogFile[256];
     *     DWORD ulNumRecords;
     *     EVENTLOGRECORD pEventLogRecords[];
     * } *PEVENTSFORLOGFILE
     * }
     */
    public static final AddressLayout PEVENTSFORLOGFILE = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _PACKEDEVENTINFO {
     *     DWORD ulSize;
     *     DWORD ulNumEventsForLogFile;
     *     DWORD ulOffsets[];
     * } *PPACKEDEVENTINFO
     * }
     */
    public static final AddressLayout PPACKEDEVENTINFO = C_POINTER;
    private static final int DriverType = (int)1L;
    /**
     * {@snippet lang=c :
     * enum _CM_SERVICE_NODE_TYPE.DriverType = 1
     * }
     */
    public static int DriverType() {
        return DriverType;
    }
    private static final int FileSystemType = (int)2L;
    /**
     * {@snippet lang=c :
     * enum _CM_SERVICE_NODE_TYPE.FileSystemType = 2
     * }
     */
    public static int FileSystemType() {
        return FileSystemType;
    }
    private static final int Win32ServiceOwnProcess = (int)16L;
    /**
     * {@snippet lang=c :
     * enum _CM_SERVICE_NODE_TYPE.Win32ServiceOwnProcess = 16
     * }
     */
    public static int Win32ServiceOwnProcess() {
        return Win32ServiceOwnProcess;
    }
    private static final int Win32ServiceShareProcess = (int)32L;
    /**
     * {@snippet lang=c :
     * enum _CM_SERVICE_NODE_TYPE.Win32ServiceShareProcess = 32
     * }
     */
    public static int Win32ServiceShareProcess() {
        return Win32ServiceShareProcess;
    }
    private static final int AdapterType = (int)4L;
    /**
     * {@snippet lang=c :
     * enum _CM_SERVICE_NODE_TYPE.AdapterType = 4
     * }
     */
    public static int AdapterType() {
        return AdapterType;
    }
    private static final int RecognizerType = (int)8L;
    /**
     * {@snippet lang=c :
     * enum _CM_SERVICE_NODE_TYPE.RecognizerType = 8
     * }
     */
    public static int RecognizerType() {
        return RecognizerType;
    }
    private static final int BootLoad = (int)0L;
    /**
     * {@snippet lang=c :
     * enum _CM_SERVICE_LOAD_TYPE.BootLoad = 0
     * }
     */
    public static int BootLoad() {
        return BootLoad;
    }
    private static final int SystemLoad = (int)1L;
    /**
     * {@snippet lang=c :
     * enum _CM_SERVICE_LOAD_TYPE.SystemLoad = 1
     * }
     */
    public static int SystemLoad() {
        return SystemLoad;
    }
    private static final int AutoLoad = (int)2L;
    /**
     * {@snippet lang=c :
     * enum _CM_SERVICE_LOAD_TYPE.AutoLoad = 2
     * }
     */
    public static int AutoLoad() {
        return AutoLoad;
    }
    private static final int DemandLoad = (int)3L;
    /**
     * {@snippet lang=c :
     * enum _CM_SERVICE_LOAD_TYPE.DemandLoad = 3
     * }
     */
    public static int DemandLoad() {
        return DemandLoad;
    }
    private static final int DisableLoad = (int)4L;
    /**
     * {@snippet lang=c :
     * enum _CM_SERVICE_LOAD_TYPE.DisableLoad = 4
     * }
     */
    public static int DisableLoad() {
        return DisableLoad;
    }
    private static final int IgnoreError = (int)0L;
    /**
     * {@snippet lang=c :
     * enum _CM_ERROR_CONTROL_TYPE.IgnoreError = 0
     * }
     */
    public static int IgnoreError() {
        return IgnoreError;
    }
    private static final int NormalError = (int)1L;
    /**
     * {@snippet lang=c :
     * enum _CM_ERROR_CONTROL_TYPE.NormalError = 1
     * }
     */
    public static int NormalError() {
        return NormalError;
    }
    private static final int SevereError = (int)2L;
    /**
     * {@snippet lang=c :
     * enum _CM_ERROR_CONTROL_TYPE.SevereError = 2
     * }
     */
    public static int SevereError() {
        return SevereError;
    }
    private static final int CriticalError = (int)3L;
    /**
     * {@snippet lang=c :
     * enum _CM_ERROR_CONTROL_TYPE.CriticalError = 3
     * }
     */
    public static int CriticalError() {
        return CriticalError;
    }
    /**
     * {@snippet lang=c :
     * typedef struct _TAPE_ERASE {
     *     DWORD Type;
     *     BOOLEAN Immediate;
     * } *PTAPE_ERASE
     * }
     */
    public static final AddressLayout PTAPE_ERASE = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _TAPE_PREPARE {
     *     DWORD Operation;
     *     BOOLEAN Immediate;
     * } *PTAPE_PREPARE
     * }
     */
    public static final AddressLayout PTAPE_PREPARE = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _TAPE_WRITE_MARKS {
     *     DWORD Type;
     *     DWORD Count;
     *     BOOLEAN Immediate;
     * } *PTAPE_WRITE_MARKS
     * }
     */
    public static final AddressLayout PTAPE_WRITE_MARKS = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _TAPE_GET_POSITION {
     *     DWORD Type;
     *     DWORD Partition;
     *     LARGE_INTEGER Offset;
     * } *PTAPE_GET_POSITION
     * }
     */
    public static final AddressLayout PTAPE_GET_POSITION = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _TAPE_SET_POSITION {
     *     DWORD Method;
     *     DWORD Partition;
     *     LARGE_INTEGER Offset;
     *     BOOLEAN Immediate;
     * } *PTAPE_SET_POSITION
     * }
     */
    public static final AddressLayout PTAPE_SET_POSITION = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _TAPE_GET_DRIVE_PARAMETERS {
     *     BOOLEAN ECC;
     *     BOOLEAN Compression;
     *     BOOLEAN DataPadding;
     *     BOOLEAN ReportSetmarks;
     *     DWORD DefaultBlockSize;
     *     DWORD MaximumBlockSize;
     *     DWORD MinimumBlockSize;
     *     DWORD MaximumPartitionCount;
     *     DWORD FeaturesLow;
     *     DWORD FeaturesHigh;
     *     DWORD EOTWarningZoneSize;
     * } *PTAPE_GET_DRIVE_PARAMETERS
     * }
     */
    public static final AddressLayout PTAPE_GET_DRIVE_PARAMETERS = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _TAPE_SET_DRIVE_PARAMETERS {
     *     BOOLEAN ECC;
     *     BOOLEAN Compression;
     *     BOOLEAN DataPadding;
     *     BOOLEAN ReportSetmarks;
     *     DWORD EOTWarningZoneSize;
     * } *PTAPE_SET_DRIVE_PARAMETERS
     * }
     */
    public static final AddressLayout PTAPE_SET_DRIVE_PARAMETERS = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _TAPE_GET_MEDIA_PARAMETERS {
     *     LARGE_INTEGER Capacity;
     *     LARGE_INTEGER Remaining;
     *     DWORD BlockSize;
     *     DWORD PartitionCount;
     *     BOOLEAN WriteProtected;
     * } *PTAPE_GET_MEDIA_PARAMETERS
     * }
     */
    public static final AddressLayout PTAPE_GET_MEDIA_PARAMETERS = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _TAPE_SET_MEDIA_PARAMETERS {
     *     DWORD BlockSize;
     * } *PTAPE_SET_MEDIA_PARAMETERS
     * }
     */
    public static final AddressLayout PTAPE_SET_MEDIA_PARAMETERS = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _TAPE_CREATE_PARTITION {
     *     DWORD Method;
     *     DWORD Count;
     *     DWORD Size;
     * } *PTAPE_CREATE_PARTITION
     * }
     */
    public static final AddressLayout PTAPE_CREATE_PARTITION = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _TAPE_WMI_OPERATIONS {
     *     DWORD Method;
     *     DWORD DataBufferSize;
     *     PVOID DataBuffer;
     * } *PTAPE_WMI_OPERATIONS
     * }
     */
    public static final AddressLayout PTAPE_WMI_OPERATIONS = C_POINTER;
    private static final int TapeDriveProblemNone = (int)0L;
    /**
     * {@snippet lang=c :
     * enum _TAPE_DRIVE_PROBLEM_TYPE.TapeDriveProblemNone = 0
     * }
     */
    public static int TapeDriveProblemNone() {
        return TapeDriveProblemNone;
    }
    private static final int TapeDriveReadWriteWarning = (int)1L;
    /**
     * {@snippet lang=c :
     * enum _TAPE_DRIVE_PROBLEM_TYPE.TapeDriveReadWriteWarning = 1
     * }
     */
    public static int TapeDriveReadWriteWarning() {
        return TapeDriveReadWriteWarning;
    }
    private static final int TapeDriveReadWriteError = (int)2L;
    /**
     * {@snippet lang=c :
     * enum _TAPE_DRIVE_PROBLEM_TYPE.TapeDriveReadWriteError = 2
     * }
     */
    public static int TapeDriveReadWriteError() {
        return TapeDriveReadWriteError;
    }
    private static final int TapeDriveReadWarning = (int)3L;
    /**
     * {@snippet lang=c :
     * enum _TAPE_DRIVE_PROBLEM_TYPE.TapeDriveReadWarning = 3
     * }
     */
    public static int TapeDriveReadWarning() {
        return TapeDriveReadWarning;
    }
    private static final int TapeDriveWriteWarning = (int)4L;
    /**
     * {@snippet lang=c :
     * enum _TAPE_DRIVE_PROBLEM_TYPE.TapeDriveWriteWarning = 4
     * }
     */
    public static int TapeDriveWriteWarning() {
        return TapeDriveWriteWarning;
    }
    private static final int TapeDriveReadError = (int)5L;
    /**
     * {@snippet lang=c :
     * enum _TAPE_DRIVE_PROBLEM_TYPE.TapeDriveReadError = 5
     * }
     */
    public static int TapeDriveReadError() {
        return TapeDriveReadError;
    }
    private static final int TapeDriveWriteError = (int)6L;
    /**
     * {@snippet lang=c :
     * enum _TAPE_DRIVE_PROBLEM_TYPE.TapeDriveWriteError = 6
     * }
     */
    public static int TapeDriveWriteError() {
        return TapeDriveWriteError;
    }
    private static final int TapeDriveHardwareError = (int)7L;
    /**
     * {@snippet lang=c :
     * enum _TAPE_DRIVE_PROBLEM_TYPE.TapeDriveHardwareError = 7
     * }
     */
    public static int TapeDriveHardwareError() {
        return TapeDriveHardwareError;
    }
    private static final int TapeDriveUnsupportedMedia = (int)8L;
    /**
     * {@snippet lang=c :
     * enum _TAPE_DRIVE_PROBLEM_TYPE.TapeDriveUnsupportedMedia = 8
     * }
     */
    public static int TapeDriveUnsupportedMedia() {
        return TapeDriveUnsupportedMedia;
    }
    private static final int TapeDriveScsiConnectionError = (int)9L;
    /**
     * {@snippet lang=c :
     * enum _TAPE_DRIVE_PROBLEM_TYPE.TapeDriveScsiConnectionError = 9
     * }
     */
    public static int TapeDriveScsiConnectionError() {
        return TapeDriveScsiConnectionError;
    }
    private static final int TapeDriveTimetoClean = (int)10L;
    /**
     * {@snippet lang=c :
     * enum _TAPE_DRIVE_PROBLEM_TYPE.TapeDriveTimetoClean = 10
     * }
     */
    public static int TapeDriveTimetoClean() {
        return TapeDriveTimetoClean;
    }
    private static final int TapeDriveCleanDriveNow = (int)11L;
    /**
     * {@snippet lang=c :
     * enum _TAPE_DRIVE_PROBLEM_TYPE.TapeDriveCleanDriveNow = 11
     * }
     */
    public static int TapeDriveCleanDriveNow() {
        return TapeDriveCleanDriveNow;
    }
    private static final int TapeDriveMediaLifeExpired = (int)12L;
    /**
     * {@snippet lang=c :
     * enum _TAPE_DRIVE_PROBLEM_TYPE.TapeDriveMediaLifeExpired = 12
     * }
     */
    public static int TapeDriveMediaLifeExpired() {
        return TapeDriveMediaLifeExpired;
    }
    private static final int TapeDriveSnappedTape = (int)13L;
    /**
     * {@snippet lang=c :
     * enum _TAPE_DRIVE_PROBLEM_TYPE.TapeDriveSnappedTape = 13
     * }
     */
    public static int TapeDriveSnappedTape() {
        return TapeDriveSnappedTape;
    }
    /**
     * {@snippet lang=c :
     * typedef GUID *PUOW
     * }
     */
    public static final AddressLayout PUOW = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef GUID *PCRM_PROTOCOL_ID
     * }
     */
    public static final AddressLayout PCRM_PROTOCOL_ID = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef ULONG NOTIFICATION_MASK
     * }
     */
    public static final OfInt NOTIFICATION_MASK = C_LONG;
    /**
     * {@snippet lang=c :
     * typedef struct _TRANSACTION_NOTIFICATION {
     *     PVOID TransactionKey;
     *     ULONG TransactionNotification;
     *     LARGE_INTEGER TmVirtualClock;
     *     ULONG ArgumentLength;
     * } *PTRANSACTION_NOTIFICATION
     * }
     */
    public static final AddressLayout PTRANSACTION_NOTIFICATION = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _TRANSACTION_NOTIFICATION_RECOVERY_ARGUMENT {
     *     GUID EnlistmentId;
     *     UOW UOW;
     * } *PTRANSACTION_NOTIFICATION_RECOVERY_ARGUMENT
     * }
     */
    public static final AddressLayout PTRANSACTION_NOTIFICATION_RECOVERY_ARGUMENT = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _TRANSACTION_NOTIFICATION_TM_ONLINE_ARGUMENT {
     *     GUID TmIdentity;
     *     ULONG Flags;
     * } *PTRANSACTION_NOTIFICATION_TM_ONLINE_ARGUMENT
     * }
     */
    public static final AddressLayout PTRANSACTION_NOTIFICATION_TM_ONLINE_ARGUMENT = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef ULONG SAVEPOINT_ID
     * }
     */
    public static final OfInt SAVEPOINT_ID = C_LONG;
    /**
     * {@snippet lang=c :
     * typedef ULONG *PSAVEPOINT_ID
     * }
     */
    public static final AddressLayout PSAVEPOINT_ID = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _TRANSACTION_NOTIFICATION_SAVEPOINT_ARGUMENT {
     *     SAVEPOINT_ID SavepointId;
     * } *PTRANSACTION_NOTIFICATION_SAVEPOINT_ARGUMENT
     * }
     */
    public static final AddressLayout PTRANSACTION_NOTIFICATION_SAVEPOINT_ARGUMENT = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _TRANSACTION_NOTIFICATION_PROPAGATE_ARGUMENT {
     *     ULONG PropagationCookie;
     *     GUID UOW;
     *     GUID TmIdentity;
     *     ULONG BufferLength;
     * } *PTRANSACTION_NOTIFICATION_PROPAGATE_ARGUMENT
     * }
     */
    public static final AddressLayout PTRANSACTION_NOTIFICATION_PROPAGATE_ARGUMENT = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _TRANSACTION_NOTIFICATION_MARSHAL_ARGUMENT {
     *     ULONG MarshalCookie;
     *     GUID UOW;
     * } *PTRANSACTION_NOTIFICATION_MARSHAL_ARGUMENT
     * }
     */
    public static final AddressLayout PTRANSACTION_NOTIFICATION_MARSHAL_ARGUMENT = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef TRANSACTION_NOTIFICATION_PROPAGATE_ARGUMENT *PTRANSACTION_NOTIFICATION_PROMOTE_ARGUMENT
     * }
     */
    public static final AddressLayout PTRANSACTION_NOTIFICATION_PROMOTE_ARGUMENT = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _KCRM_MARSHAL_HEADER {
     *     ULONG VersionMajor;
     *     ULONG VersionMinor;
     *     ULONG NumProtocols;
     *     ULONG Unused;
     * } *PKCRM_MARSHAL_HEADER
     * }
     */
    public static final AddressLayout PKCRM_MARSHAL_HEADER = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _KCRM_MARSHAL_HEADER {
     *     ULONG VersionMajor;
     *     ULONG VersionMinor;
     *     ULONG NumProtocols;
     *     ULONG Unused;
     * } *PRKCRM_MARSHAL_HEADER
     * }
     */
    public static final AddressLayout PRKCRM_MARSHAL_HEADER = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _KCRM_TRANSACTION_BLOB {
     *     UOW UOW;
     *     GUID TmIdentity;
     *     ULONG IsolationLevel;
     *     ULONG IsolationFlags;
     *     ULONG Timeout;
     *     WCHAR Description[64];
     * } *PKCRM_TRANSACTION_BLOB
     * }
     */
    public static final AddressLayout PKCRM_TRANSACTION_BLOB = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _KCRM_TRANSACTION_BLOB {
     *     UOW UOW;
     *     GUID TmIdentity;
     *     ULONG IsolationLevel;
     *     ULONG IsolationFlags;
     *     ULONG Timeout;
     *     WCHAR Description[64];
     * } *PRKCRM_TRANSACTION_BLOB
     * }
     */
    public static final AddressLayout PRKCRM_TRANSACTION_BLOB = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _KCRM_PROTOCOL_BLOB {
     *     CRM_PROTOCOL_ID ProtocolId;
     *     ULONG StaticInfoLength;
     *     ULONG TransactionIdInfoLength;
     *     ULONG Unused1;
     *     ULONG Unused2;
     * } *PKCRM_PROTOCOL_BLOB
     * }
     */
    public static final AddressLayout PKCRM_PROTOCOL_BLOB = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _KCRM_PROTOCOL_BLOB {
     *     CRM_PROTOCOL_ID ProtocolId;
     *     ULONG StaticInfoLength;
     *     ULONG TransactionIdInfoLength;
     *     ULONG Unused1;
     *     ULONG Unused2;
     * } *PRKCRM_PROTOCOL_BLOB
     * }
     */
    public static final AddressLayout PRKCRM_PROTOCOL_BLOB = C_POINTER;
    private static final int TransactionOutcomeUndetermined = (int)1L;
    /**
     * {@snippet lang=c :
     * enum _TRANSACTION_OUTCOME.TransactionOutcomeUndetermined = 1
     * }
     */
    public static int TransactionOutcomeUndetermined() {
        return TransactionOutcomeUndetermined;
    }
    private static final int TransactionOutcomeCommitted = (int)2L;
    /**
     * {@snippet lang=c :
     * enum _TRANSACTION_OUTCOME.TransactionOutcomeCommitted = 2
     * }
     */
    public static int TransactionOutcomeCommitted() {
        return TransactionOutcomeCommitted;
    }
    private static final int TransactionOutcomeAborted = (int)3L;
    /**
     * {@snippet lang=c :
     * enum _TRANSACTION_OUTCOME.TransactionOutcomeAborted = 3
     * }
     */
    public static int TransactionOutcomeAborted() {
        return TransactionOutcomeAborted;
    }
    private static final int TransactionStateNormal = (int)1L;
    /**
     * {@snippet lang=c :
     * enum _TRANSACTION_STATE.TransactionStateNormal = 1
     * }
     */
    public static int TransactionStateNormal() {
        return TransactionStateNormal;
    }
    private static final int TransactionStateIndoubt = (int)2L;
    /**
     * {@snippet lang=c :
     * enum _TRANSACTION_STATE.TransactionStateIndoubt = 2
     * }
     */
    public static int TransactionStateIndoubt() {
        return TransactionStateIndoubt;
    }
    private static final int TransactionStateCommittedNotify = (int)3L;
    /**
     * {@snippet lang=c :
     * enum _TRANSACTION_STATE.TransactionStateCommittedNotify = 3
     * }
     */
    public static int TransactionStateCommittedNotify() {
        return TransactionStateCommittedNotify;
    }
    /**
     * {@snippet lang=c :
     * typedef struct _TRANSACTION_BASIC_INFORMATION {
     *     GUID TransactionId;
     *     DWORD State;
     *     DWORD Outcome;
     * } *PTRANSACTION_BASIC_INFORMATION
     * }
     */
    public static final AddressLayout PTRANSACTION_BASIC_INFORMATION = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _TRANSACTIONMANAGER_BASIC_INFORMATION {
     *     GUID TmIdentity;
     *     LARGE_INTEGER VirtualClock;
     * } *PTRANSACTIONMANAGER_BASIC_INFORMATION
     * }
     */
    public static final AddressLayout PTRANSACTIONMANAGER_BASIC_INFORMATION = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _TRANSACTIONMANAGER_LOG_INFORMATION {
     *     GUID LogIdentity;
     * } *PTRANSACTIONMANAGER_LOG_INFORMATION
     * }
     */
    public static final AddressLayout PTRANSACTIONMANAGER_LOG_INFORMATION = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _TRANSACTIONMANAGER_LOGPATH_INFORMATION {
     *     DWORD LogPathLength;
     *     WCHAR LogPath[1];
     * } *PTRANSACTIONMANAGER_LOGPATH_INFORMATION
     * }
     */
    public static final AddressLayout PTRANSACTIONMANAGER_LOGPATH_INFORMATION = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _TRANSACTIONMANAGER_RECOVERY_INFORMATION {
     *     ULONGLONG LastRecoveredLsn;
     * } *PTRANSACTIONMANAGER_RECOVERY_INFORMATION
     * }
     */
    public static final AddressLayout PTRANSACTIONMANAGER_RECOVERY_INFORMATION = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _TRANSACTIONMANAGER_OLDEST_INFORMATION {
     *     GUID OldestTransactionGuid;
     * } *PTRANSACTIONMANAGER_OLDEST_INFORMATION
     * }
     */
    public static final AddressLayout PTRANSACTIONMANAGER_OLDEST_INFORMATION = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _TRANSACTION_PROPERTIES_INFORMATION {
     *     DWORD IsolationLevel;
     *     DWORD IsolationFlags;
     *     LARGE_INTEGER Timeout;
     *     DWORD Outcome;
     *     DWORD DescriptionLength;
     *     WCHAR Description[1];
     * } *PTRANSACTION_PROPERTIES_INFORMATION
     * }
     */
    public static final AddressLayout PTRANSACTION_PROPERTIES_INFORMATION = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _TRANSACTION_BIND_INFORMATION {
     *     HANDLE TmHandle;
     * } *PTRANSACTION_BIND_INFORMATION
     * }
     */
    public static final AddressLayout PTRANSACTION_BIND_INFORMATION = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _TRANSACTION_ENLISTMENT_PAIR {
     *     GUID EnlistmentId;
     *     GUID ResourceManagerId;
     * } *PTRANSACTION_ENLISTMENT_PAIR
     * }
     */
    public static final AddressLayout PTRANSACTION_ENLISTMENT_PAIR = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _TRANSACTION_ENLISTMENTS_INFORMATION {
     *     DWORD NumberOfEnlistments;
     *     TRANSACTION_ENLISTMENT_PAIR EnlistmentPair[1];
     * } *PTRANSACTION_ENLISTMENTS_INFORMATION
     * }
     */
    public static final AddressLayout PTRANSACTION_ENLISTMENTS_INFORMATION = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _TRANSACTION_SUPERIOR_ENLISTMENT_INFORMATION {
     *     TRANSACTION_ENLISTMENT_PAIR SuperiorEnlistmentPair;
     * } *PTRANSACTION_SUPERIOR_ENLISTMENT_INFORMATION
     * }
     */
    public static final AddressLayout PTRANSACTION_SUPERIOR_ENLISTMENT_INFORMATION = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _RESOURCEMANAGER_BASIC_INFORMATION {
     *     GUID ResourceManagerId;
     *     DWORD DescriptionLength;
     *     WCHAR Description[1];
     * } *PRESOURCEMANAGER_BASIC_INFORMATION
     * }
     */
    public static final AddressLayout PRESOURCEMANAGER_BASIC_INFORMATION = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _RESOURCEMANAGER_COMPLETION_INFORMATION {
     *     HANDLE IoCompletionPortHandle;
     *     ULONG_PTR CompletionKey;
     * } *PRESOURCEMANAGER_COMPLETION_INFORMATION
     * }
     */
    public static final AddressLayout PRESOURCEMANAGER_COMPLETION_INFORMATION = C_POINTER;
    private static final int TransactionBasicInformation = (int)0L;
    /**
     * {@snippet lang=c :
     * enum _TRANSACTION_INFORMATION_CLASS.TransactionBasicInformation = 0
     * }
     */
    public static int TransactionBasicInformation() {
        return TransactionBasicInformation;
    }
    private static final int TransactionPropertiesInformation = (int)1L;
    /**
     * {@snippet lang=c :
     * enum _TRANSACTION_INFORMATION_CLASS.TransactionPropertiesInformation = 1
     * }
     */
    public static int TransactionPropertiesInformation() {
        return TransactionPropertiesInformation;
    }
    private static final int TransactionEnlistmentInformation = (int)2L;
    /**
     * {@snippet lang=c :
     * enum _TRANSACTION_INFORMATION_CLASS.TransactionEnlistmentInformation = 2
     * }
     */
    public static int TransactionEnlistmentInformation() {
        return TransactionEnlistmentInformation;
    }
    private static final int TransactionSuperiorEnlistmentInformation = (int)3L;
    /**
     * {@snippet lang=c :
     * enum _TRANSACTION_INFORMATION_CLASS.TransactionSuperiorEnlistmentInformation = 3
     * }
     */
    public static int TransactionSuperiorEnlistmentInformation() {
        return TransactionSuperiorEnlistmentInformation;
    }
    private static final int TransactionBindInformation = (int)4L;
    /**
     * {@snippet lang=c :
     * enum _TRANSACTION_INFORMATION_CLASS.TransactionBindInformation = 4
     * }
     */
    public static int TransactionBindInformation() {
        return TransactionBindInformation;
    }
    private static final int TransactionDTCPrivateInformation = (int)5L;
    /**
     * {@snippet lang=c :
     * enum _TRANSACTION_INFORMATION_CLASS.TransactionDTCPrivateInformation = 5
     * }
     */
    public static int TransactionDTCPrivateInformation() {
        return TransactionDTCPrivateInformation;
    }
    private static final int TransactionManagerBasicInformation = (int)0L;
    /**
     * {@snippet lang=c :
     * enum _TRANSACTIONMANAGER_INFORMATION_CLASS.TransactionManagerBasicInformation = 0
     * }
     */
    public static int TransactionManagerBasicInformation() {
        return TransactionManagerBasicInformation;
    }
    private static final int TransactionManagerLogInformation = (int)1L;
    /**
     * {@snippet lang=c :
     * enum _TRANSACTIONMANAGER_INFORMATION_CLASS.TransactionManagerLogInformation = 1
     * }
     */
    public static int TransactionManagerLogInformation() {
        return TransactionManagerLogInformation;
    }
    private static final int TransactionManagerLogPathInformation = (int)2L;
    /**
     * {@snippet lang=c :
     * enum _TRANSACTIONMANAGER_INFORMATION_CLASS.TransactionManagerLogPathInformation = 2
     * }
     */
    public static int TransactionManagerLogPathInformation() {
        return TransactionManagerLogPathInformation;
    }
    private static final int TransactionManagerRecoveryInformation = (int)4L;
    /**
     * {@snippet lang=c :
     * enum _TRANSACTIONMANAGER_INFORMATION_CLASS.TransactionManagerRecoveryInformation = 4
     * }
     */
    public static int TransactionManagerRecoveryInformation() {
        return TransactionManagerRecoveryInformation;
    }
    private static final int TransactionManagerOnlineProbeInformation = (int)3L;
    /**
     * {@snippet lang=c :
     * enum _TRANSACTIONMANAGER_INFORMATION_CLASS.TransactionManagerOnlineProbeInformation = 3
     * }
     */
    public static int TransactionManagerOnlineProbeInformation() {
        return TransactionManagerOnlineProbeInformation;
    }
    private static final int TransactionManagerOldestTransactionInformation = (int)5L;
    /**
     * {@snippet lang=c :
     * enum _TRANSACTIONMANAGER_INFORMATION_CLASS.TransactionManagerOldestTransactionInformation = 5
     * }
     */
    public static int TransactionManagerOldestTransactionInformation() {
        return TransactionManagerOldestTransactionInformation;
    }
    private static final int ResourceManagerBasicInformation = (int)0L;
    /**
     * {@snippet lang=c :
     * enum _RESOURCEMANAGER_INFORMATION_CLASS.ResourceManagerBasicInformation = 0
     * }
     */
    public static int ResourceManagerBasicInformation() {
        return ResourceManagerBasicInformation;
    }
    private static final int ResourceManagerCompletionInformation = (int)1L;
    /**
     * {@snippet lang=c :
     * enum _RESOURCEMANAGER_INFORMATION_CLASS.ResourceManagerCompletionInformation = 1
     * }
     */
    public static int ResourceManagerCompletionInformation() {
        return ResourceManagerCompletionInformation;
    }
    /**
     * {@snippet lang=c :
     * typedef struct _ENLISTMENT_BASIC_INFORMATION {
     *     GUID EnlistmentId;
     *     GUID TransactionId;
     *     GUID ResourceManagerId;
     * } *PENLISTMENT_BASIC_INFORMATION
     * }
     */
    public static final AddressLayout PENLISTMENT_BASIC_INFORMATION = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _ENLISTMENT_CRM_INFORMATION {
     *     GUID CrmTransactionManagerId;
     *     GUID CrmResourceManagerId;
     *     GUID CrmEnlistmentId;
     * } *PENLISTMENT_CRM_INFORMATION
     * }
     */
    public static final AddressLayout PENLISTMENT_CRM_INFORMATION = C_POINTER;
    private static final int EnlistmentBasicInformation = (int)0L;
    /**
     * {@snippet lang=c :
     * enum _ENLISTMENT_INFORMATION_CLASS.EnlistmentBasicInformation = 0
     * }
     */
    public static int EnlistmentBasicInformation() {
        return EnlistmentBasicInformation;
    }
    private static final int EnlistmentRecoveryInformation = (int)1L;
    /**
     * {@snippet lang=c :
     * enum _ENLISTMENT_INFORMATION_CLASS.EnlistmentRecoveryInformation = 1
     * }
     */
    public static int EnlistmentRecoveryInformation() {
        return EnlistmentRecoveryInformation;
    }
    private static final int EnlistmentCrmInformation = (int)2L;
    /**
     * {@snippet lang=c :
     * enum _ENLISTMENT_INFORMATION_CLASS.EnlistmentCrmInformation = 2
     * }
     */
    public static int EnlistmentCrmInformation() {
        return EnlistmentCrmInformation;
    }
    /**
     * {@snippet lang=c :
     * typedef struct _TRANSACTION_LIST_ENTRY {
     *     UOW UOW;
     * } *PTRANSACTION_LIST_ENTRY
     * }
     */
    public static final AddressLayout PTRANSACTION_LIST_ENTRY = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _TRANSACTION_LIST_INFORMATION {
     *     DWORD NumberOfTransactions;
     *     TRANSACTION_LIST_ENTRY TransactionInformation[1];
     * } *PTRANSACTION_LIST_INFORMATION
     * }
     */
    public static final AddressLayout PTRANSACTION_LIST_INFORMATION = C_POINTER;
    private static final int KTMOBJECT_TRANSACTION = (int)0L;
    /**
     * {@snippet lang=c :
     * enum _KTMOBJECT_TYPE.KTMOBJECT_TRANSACTION = 0
     * }
     */
    public static int KTMOBJECT_TRANSACTION() {
        return KTMOBJECT_TRANSACTION;
    }
    private static final int KTMOBJECT_TRANSACTION_MANAGER = (int)1L;
    /**
     * {@snippet lang=c :
     * enum _KTMOBJECT_TYPE.KTMOBJECT_TRANSACTION_MANAGER = 1
     * }
     */
    public static int KTMOBJECT_TRANSACTION_MANAGER() {
        return KTMOBJECT_TRANSACTION_MANAGER;
    }
    private static final int KTMOBJECT_RESOURCE_MANAGER = (int)2L;
    /**
     * {@snippet lang=c :
     * enum _KTMOBJECT_TYPE.KTMOBJECT_RESOURCE_MANAGER = 2
     * }
     */
    public static int KTMOBJECT_RESOURCE_MANAGER() {
        return KTMOBJECT_RESOURCE_MANAGER;
    }
    private static final int KTMOBJECT_ENLISTMENT = (int)3L;
    /**
     * {@snippet lang=c :
     * enum _KTMOBJECT_TYPE.KTMOBJECT_ENLISTMENT = 3
     * }
     */
    public static int KTMOBJECT_ENLISTMENT() {
        return KTMOBJECT_ENLISTMENT;
    }
    private static final int KTMOBJECT_INVALID = (int)4L;
    /**
     * {@snippet lang=c :
     * enum _KTMOBJECT_TYPE.KTMOBJECT_INVALID = 4
     * }
     */
    public static int KTMOBJECT_INVALID() {
        return KTMOBJECT_INVALID;
    }
    /**
     * {@snippet lang=c :
     * typedef enum _KTMOBJECT_TYPE {
     *     KTMOBJECT_TRANSACTION,
     *     KTMOBJECT_TRANSACTION_MANAGER,
     *     KTMOBJECT_RESOURCE_MANAGER,
     *     KTMOBJECT_ENLISTMENT,
     *     KTMOBJECT_INVALID
     * } *PKTMOBJECT_TYPE
     * }
     */
    public static final AddressLayout PKTMOBJECT_TYPE = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _KTMOBJECT_CURSOR {
     *     GUID LastQuery;
     *     DWORD ObjectIdCount;
     *     GUID ObjectIds[1];
     * } *PKTMOBJECT_CURSOR
     * }
     */
    public static final AddressLayout PKTMOBJECT_CURSOR = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef DWORD TP_VERSION
     * }
     */
    public static final OfInt TP_VERSION = C_LONG;
    /**
     * {@snippet lang=c :
     * typedef DWORD *PTP_VERSION
     * }
     */
    public static final AddressLayout PTP_VERSION = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _TP_CALLBACK_INSTANCE *PTP_CALLBACK_INSTANCE
     * }
     */
    public static final AddressLayout PTP_CALLBACK_INSTANCE = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _TP_POOL *PTP_POOL
     * }
     */
    public static final AddressLayout PTP_POOL = C_POINTER;
    private static final int TP_CALLBACK_PRIORITY_HIGH = (int)0L;
    /**
     * {@snippet lang=c :
     * enum _TP_CALLBACK_PRIORITY.TP_CALLBACK_PRIORITY_HIGH = 0
     * }
     */
    public static int TP_CALLBACK_PRIORITY_HIGH() {
        return TP_CALLBACK_PRIORITY_HIGH;
    }
    private static final int TP_CALLBACK_PRIORITY_NORMAL = (int)1L;
    /**
     * {@snippet lang=c :
     * enum _TP_CALLBACK_PRIORITY.TP_CALLBACK_PRIORITY_NORMAL = 1
     * }
     */
    public static int TP_CALLBACK_PRIORITY_NORMAL() {
        return TP_CALLBACK_PRIORITY_NORMAL;
    }
    private static final int TP_CALLBACK_PRIORITY_LOW = (int)2L;
    /**
     * {@snippet lang=c :
     * enum _TP_CALLBACK_PRIORITY.TP_CALLBACK_PRIORITY_LOW = 2
     * }
     */
    public static int TP_CALLBACK_PRIORITY_LOW() {
        return TP_CALLBACK_PRIORITY_LOW;
    }
    private static final int TP_CALLBACK_PRIORITY_INVALID = (int)3L;
    /**
     * {@snippet lang=c :
     * enum _TP_CALLBACK_PRIORITY.TP_CALLBACK_PRIORITY_INVALID = 3
     * }
     */
    public static int TP_CALLBACK_PRIORITY_INVALID() {
        return TP_CALLBACK_PRIORITY_INVALID;
    }
    private static final int TP_CALLBACK_PRIORITY_COUNT = (int)3L;
    /**
     * {@snippet lang=c :
     * enum _TP_CALLBACK_PRIORITY.TP_CALLBACK_PRIORITY_COUNT = 3
     * }
     */
    public static int TP_CALLBACK_PRIORITY_COUNT() {
        return TP_CALLBACK_PRIORITY_COUNT;
    }
    /**
     * {@snippet lang=c :
     * typedef struct _TP_POOL_STACK_INFORMATION {
     *     SIZE_T StackReserve;
     *     SIZE_T StackCommit;
     * } *PTP_POOL_STACK_INFORMATION
     * }
     */
    public static final AddressLayout PTP_POOL_STACK_INFORMATION = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _TP_CLEANUP_GROUP *PTP_CLEANUP_GROUP
     * }
     */
    public static final AddressLayout PTP_CLEANUP_GROUP = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef TP_CALLBACK_ENVIRON_V3 *PTP_CALLBACK_ENVIRON
     * }
     */
    public static final AddressLayout PTP_CALLBACK_ENVIRON = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _TP_WORK *PTP_WORK
     * }
     */
    public static final AddressLayout PTP_WORK = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _TP_TIMER *PTP_TIMER
     * }
     */
    public static final AddressLayout PTP_TIMER = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef DWORD TP_WAIT_RESULT
     * }
     */
    public static final OfInt TP_WAIT_RESULT = C_LONG;
    /**
     * {@snippet lang=c :
     * typedef struct _TP_WAIT *PTP_WAIT
     * }
     */
    public static final AddressLayout PTP_WAIT = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _TP_IO *PTP_IO
     * }
     */
    public static final AddressLayout PTP_IO = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef UINT_PTR WPARAM
     * }
     */
    public static final OfLong WPARAM = C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef LONG_PTR LPARAM
     * }
     */
    public static final OfLong LPARAM = C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef LONG_PTR LRESULT
     * }
     */
    public static final OfLong LRESULT = C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef HANDLE *SPHANDLE
     * }
     */
    public static final AddressLayout SPHANDLE = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef HANDLE *LPHANDLE
     * }
     */
    public static final AddressLayout LPHANDLE = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef HANDLE HGLOBAL
     * }
     */
    public static final AddressLayout HGLOBAL = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef HANDLE HLOCAL
     * }
     */
    public static final AddressLayout HLOCAL = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef HANDLE GLOBALHANDLE
     * }
     */
    public static final AddressLayout GLOBALHANDLE = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef HANDLE LOCALHANDLE
     * }
     */
    public static final AddressLayout LOCALHANDLE = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef WORD ATOM
     * }
     */
    public static final OfShort ATOM = C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef struct HKEY__ {
     *     int unused;
     * } *HKEY
     * }
     */
    public static final AddressLayout HKEY = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef HKEY *PHKEY
     * }
     */
    public static final AddressLayout PHKEY = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct HMETAFILE__ {
     *     int unused;
     * } *HMETAFILE
     * }
     */
    public static final AddressLayout HMETAFILE = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct HINSTANCE__ {
     *     int unused;
     * } *HINSTANCE
     * }
     */
    public static final AddressLayout HINSTANCE = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef HINSTANCE HMODULE
     * }
     */
    public static final AddressLayout HMODULE = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct HRGN__ {
     *     int unused;
     * } *HRGN
     * }
     */
    public static final AddressLayout HRGN = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct HRSRC__ {
     *     int unused;
     * } *HRSRC
     * }
     */
    public static final AddressLayout HRSRC = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct HSPRITE__ {
     *     int unused;
     * } *HSPRITE
     * }
     */
    public static final AddressLayout HSPRITE = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct HLSURF__ {
     *     int unused;
     * } *HLSURF
     * }
     */
    public static final AddressLayout HLSURF = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct HSTR__ {
     *     int unused;
     * } *HSTR
     * }
     */
    public static final AddressLayout HSTR = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct HTASK__ {
     *     int unused;
     * } *HTASK
     * }
     */
    public static final AddressLayout HTASK = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct HWINSTA__ {
     *     int unused;
     * } *HWINSTA
     * }
     */
    public static final AddressLayout HWINSTA = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct HKL__ {
     *     int unused;
     * } *HKL
     * }
     */
    public static final AddressLayout HKL = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef int HFILE
     * }
     */
    public static final OfInt HFILE = C_INT;
    /**
     * {@snippet lang=c :
     * typedef struct _FILETIME {
     *     DWORD dwLowDateTime;
     *     DWORD dwHighDateTime;
     * } *PFILETIME
     * }
     */
    public static final AddressLayout PFILETIME = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _FILETIME {
     *     DWORD dwLowDateTime;
     *     DWORD dwHighDateTime;
     * } *LPFILETIME
     * }
     */
    public static final AddressLayout LPFILETIME = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct HWND__ {
     *     int unused;
     * } *HWND
     * }
     */
    public static final AddressLayout HWND = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct HHOOK__ {
     *     int unused;
     * } *HHOOK
     * }
     */
    public static final AddressLayout HHOOK = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef void *HGDIOBJ
     * }
     */
    public static final AddressLayout HGDIOBJ = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct HACCEL__ {
     *     int unused;
     * } *HACCEL
     * }
     */
    public static final AddressLayout HACCEL = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct HBITMAP__ {
     *     int unused;
     * } *HBITMAP
     * }
     */
    public static final AddressLayout HBITMAP = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct HBRUSH__ {
     *     int unused;
     * } *HBRUSH
     * }
     */
    public static final AddressLayout HBRUSH = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct HCOLORSPACE__ {
     *     int unused;
     * } *HCOLORSPACE
     * }
     */
    public static final AddressLayout HCOLORSPACE = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct HDC__ {
     *     int unused;
     * } *HDC
     * }
     */
    public static final AddressLayout HDC = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct HGLRC__ {
     *     int unused;
     * } *HGLRC
     * }
     */
    public static final AddressLayout HGLRC = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct HDESK__ {
     *     int unused;
     * } *HDESK
     * }
     */
    public static final AddressLayout HDESK = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct HENHMETAFILE__ {
     *     int unused;
     * } *HENHMETAFILE
     * }
     */
    public static final AddressLayout HENHMETAFILE = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct HFONT__ {
     *     int unused;
     * } *HFONT
     * }
     */
    public static final AddressLayout HFONT = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct HICON__ {
     *     int unused;
     * } *HICON
     * }
     */
    public static final AddressLayout HICON = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct HMENU__ {
     *     int unused;
     * } *HMENU
     * }
     */
    public static final AddressLayout HMENU = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct HPALETTE__ {
     *     int unused;
     * } *HPALETTE
     * }
     */
    public static final AddressLayout HPALETTE = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct HPEN__ {
     *     int unused;
     * } *HPEN
     * }
     */
    public static final AddressLayout HPEN = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct HWINEVENTHOOK__ {
     *     int unused;
     * } *HWINEVENTHOOK
     * }
     */
    public static final AddressLayout HWINEVENTHOOK = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct HMONITOR__ {
     *     int unused;
     * } *HMONITOR
     * }
     */
    public static final AddressLayout HMONITOR = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct HUMPD__ {
     *     int unused;
     * } *HUMPD
     * }
     */
    public static final AddressLayout HUMPD = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef HICON HCURSOR
     * }
     */
    public static final AddressLayout HCURSOR = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef DWORD COLORREF
     * }
     */
    public static final OfInt COLORREF = C_LONG;
    /**
     * {@snippet lang=c :
     * typedef DWORD *LPCOLORREF
     * }
     */
    public static final AddressLayout LPCOLORREF = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagRECT {
     *     LONG left;
     *     LONG top;
     *     LONG right;
     *     LONG bottom;
     * } *PRECT
     * }
     */
    public static final AddressLayout PRECT = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagRECT {
     *     LONG left;
     *     LONG top;
     *     LONG right;
     *     LONG bottom;
     * } *NPRECT
     * }
     */
    public static final AddressLayout NPRECT = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagRECT {
     *     LONG left;
     *     LONG top;
     *     LONG right;
     *     LONG bottom;
     * } *LPRECT
     * }
     */
    public static final AddressLayout LPRECT = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef const RECT *LPCRECT
     * }
     */
    public static final AddressLayout LPCRECT = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _RECTL {
     *     LONG left;
     *     LONG top;
     *     LONG right;
     *     LONG bottom;
     * } *PRECTL
     * }
     */
    public static final AddressLayout PRECTL = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _RECTL {
     *     LONG left;
     *     LONG top;
     *     LONG right;
     *     LONG bottom;
     * } *LPRECTL
     * }
     */
    public static final AddressLayout LPRECTL = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef const RECTL *LPCRECTL
     * }
     */
    public static final AddressLayout LPCRECTL = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagPOINT {
     *     LONG x;
     *     LONG y;
     * } *PPOINT
     * }
     */
    public static final AddressLayout PPOINT = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagPOINT {
     *     LONG x;
     *     LONG y;
     * } *NPPOINT
     * }
     */
    public static final AddressLayout NPPOINT = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagPOINT {
     *     LONG x;
     *     LONG y;
     * } *LPPOINT
     * }
     */
    public static final AddressLayout LPPOINT = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _POINTL {
     *     LONG x;
     *     LONG y;
     * } *PPOINTL
     * }
     */
    public static final AddressLayout PPOINTL = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagSIZE {
     *     LONG cx;
     *     LONG cy;
     * } *PSIZE
     * }
     */
    public static final AddressLayout PSIZE = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagSIZE {
     *     LONG cx;
     *     LONG cy;
     * } *LPSIZE
     * }
     */
    public static final AddressLayout LPSIZE = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef SIZE *PSIZEL
     * }
     */
    public static final AddressLayout PSIZEL = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef SIZE *LPSIZEL
     * }
     */
    public static final AddressLayout LPSIZEL = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagPOINTS {
     *     SHORT x;
     *     SHORT y;
     * } *PPOINTS
     * }
     */
    public static final AddressLayout PPOINTS = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct tagPOINTS {
     *     SHORT x;
     *     SHORT y;
     * } *LPPOINTS
     * }
     */
    public static final AddressLayout LPPOINTS = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct DPI_AWARENESS_CONTEXT__ {
     *     int unused;
     * } *DPI_AWARENESS_CONTEXT
     * }
     */
    public static final AddressLayout DPI_AWARENESS_CONTEXT = C_POINTER;
    private static final int DPI_AWARENESS_INVALID = (int)-1L;
    /**
     * {@snippet lang=c :
     * enum DPI_AWARENESS.DPI_AWARENESS_INVALID = -1
     * }
     */
    public static int DPI_AWARENESS_INVALID() {
        return DPI_AWARENESS_INVALID;
    }
    private static final int DPI_AWARENESS_UNAWARE = (int)0L;
    /**
     * {@snippet lang=c :
     * enum DPI_AWARENESS.DPI_AWARENESS_UNAWARE = 0
     * }
     */
    public static int DPI_AWARENESS_UNAWARE() {
        return DPI_AWARENESS_UNAWARE;
    }
    private static final int DPI_AWARENESS_SYSTEM_AWARE = (int)1L;
    /**
     * {@snippet lang=c :
     * enum DPI_AWARENESS.DPI_AWARENESS_SYSTEM_AWARE = 1
     * }
     */
    public static int DPI_AWARENESS_SYSTEM_AWARE() {
        return DPI_AWARENESS_SYSTEM_AWARE;
    }
    private static final int DPI_AWARENESS_PER_MONITOR_AWARE = (int)2L;
    /**
     * {@snippet lang=c :
     * enum DPI_AWARENESS.DPI_AWARENESS_PER_MONITOR_AWARE = 2
     * }
     */
    public static int DPI_AWARENESS_PER_MONITOR_AWARE() {
        return DPI_AWARENESS_PER_MONITOR_AWARE;
    }
    private static final int DPI_HOSTING_BEHAVIOR_INVALID = (int)-1L;
    /**
     * {@snippet lang=c :
     * enum DPI_HOSTING_BEHAVIOR.DPI_HOSTING_BEHAVIOR_INVALID = -1
     * }
     */
    public static int DPI_HOSTING_BEHAVIOR_INVALID() {
        return DPI_HOSTING_BEHAVIOR_INVALID;
    }
    private static final int DPI_HOSTING_BEHAVIOR_DEFAULT = (int)0L;
    /**
     * {@snippet lang=c :
     * enum DPI_HOSTING_BEHAVIOR.DPI_HOSTING_BEHAVIOR_DEFAULT = 0
     * }
     */
    public static int DPI_HOSTING_BEHAVIOR_DEFAULT() {
        return DPI_HOSTING_BEHAVIOR_DEFAULT;
    }
    private static final int DPI_HOSTING_BEHAVIOR_MIXED = (int)1L;
    /**
     * {@snippet lang=c :
     * enum DPI_HOSTING_BEHAVIOR.DPI_HOSTING_BEHAVIOR_MIXED = 1
     * }
     */
    public static int DPI_HOSTING_BEHAVIOR_MIXED() {
        return DPI_HOSTING_BEHAVIOR_MIXED;
    }
    /**
     * {@snippet lang=c :
     * typedef struct _SECURITY_ATTRIBUTES {
     *     DWORD nLength;
     *     LPVOID lpSecurityDescriptor;
     *     BOOL bInheritHandle;
     * } *PSECURITY_ATTRIBUTES
     * }
     */
    public static final AddressLayout PSECURITY_ATTRIBUTES = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _SECURITY_ATTRIBUTES {
     *     DWORD nLength;
     *     LPVOID lpSecurityDescriptor;
     *     BOOL bInheritHandle;
     * } *LPSECURITY_ATTRIBUTES
     * }
     */
    public static final AddressLayout LPSECURITY_ATTRIBUTES = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _OVERLAPPED {
     *     ULONG_PTR Internal;
     *     ULONG_PTR InternalHigh;
     *     union {
     *         struct {
     *             DWORD Offset;
     *             DWORD OffsetHigh;
     *         };
     *         PVOID Pointer;
     *     };
     *     HANDLE hEvent;
     * } *LPOVERLAPPED
     * }
     */
    public static final AddressLayout LPOVERLAPPED = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _OVERLAPPED_ENTRY {
     *     ULONG_PTR lpCompletionKey;
     *     LPOVERLAPPED lpOverlapped;
     *     ULONG_PTR Internal;
     *     DWORD dwNumberOfBytesTransferred;
     * } *LPOVERLAPPED_ENTRY
     * }
     */
    public static final AddressLayout LPOVERLAPPED_ENTRY = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _SYSTEMTIME {
     *     WORD wYear;
     *     WORD wMonth;
     *     WORD wDayOfWeek;
     *     WORD wDay;
     *     WORD wHour;
     *     WORD wMinute;
     *     WORD wSecond;
     *     WORD wMilliseconds;
     * } *PSYSTEMTIME
     * }
     */
    public static final AddressLayout PSYSTEMTIME = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _SYSTEMTIME {
     *     WORD wYear;
     *     WORD wMonth;
     *     WORD wDayOfWeek;
     *     WORD wDay;
     *     WORD wHour;
     *     WORD wMinute;
     *     WORD wSecond;
     *     WORD wMilliseconds;
     * } *LPSYSTEMTIME
     * }
     */
    public static final AddressLayout LPSYSTEMTIME = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _WIN32_FIND_DATAA {
     *     DWORD dwFileAttributes;
     *     FILETIME ftCreationTime;
     *     FILETIME ftLastAccessTime;
     *     FILETIME ftLastWriteTime;
     *     DWORD nFileSizeHigh;
     *     DWORD nFileSizeLow;
     *     DWORD dwReserved0;
     *     DWORD dwReserved1;
     *     CHAR cFileName[260];
     *     CHAR cAlternateFileName[14];
     * } *PWIN32_FIND_DATAA
     * }
     */
    public static final AddressLayout PWIN32_FIND_DATAA = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _WIN32_FIND_DATAA {
     *     DWORD dwFileAttributes;
     *     FILETIME ftCreationTime;
     *     FILETIME ftLastAccessTime;
     *     FILETIME ftLastWriteTime;
     *     DWORD nFileSizeHigh;
     *     DWORD nFileSizeLow;
     *     DWORD dwReserved0;
     *     DWORD dwReserved1;
     *     CHAR cFileName[260];
     *     CHAR cAlternateFileName[14];
     * } *LPWIN32_FIND_DATAA
     * }
     */
    public static final AddressLayout LPWIN32_FIND_DATAA = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _WIN32_FIND_DATAW {
     *     DWORD dwFileAttributes;
     *     FILETIME ftCreationTime;
     *     FILETIME ftLastAccessTime;
     *     FILETIME ftLastWriteTime;
     *     DWORD nFileSizeHigh;
     *     DWORD nFileSizeLow;
     *     DWORD dwReserved0;
     *     DWORD dwReserved1;
     *     WCHAR cFileName[260];
     *     WCHAR cAlternateFileName[14];
     * } *PWIN32_FIND_DATAW
     * }
     */
    public static final AddressLayout PWIN32_FIND_DATAW = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _WIN32_FIND_DATAW {
     *     DWORD dwFileAttributes;
     *     FILETIME ftCreationTime;
     *     FILETIME ftLastAccessTime;
     *     FILETIME ftLastWriteTime;
     *     DWORD nFileSizeHigh;
     *     DWORD nFileSizeLow;
     *     DWORD dwReserved0;
     *     DWORD dwReserved1;
     *     WCHAR cFileName[260];
     *     WCHAR cAlternateFileName[14];
     * } *LPWIN32_FIND_DATAW
     * }
     */
    public static final AddressLayout LPWIN32_FIND_DATAW = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef PWIN32_FIND_DATAA PWIN32_FIND_DATA
     * }
     */
    public static final AddressLayout PWIN32_FIND_DATA = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef LPWIN32_FIND_DATAA LPWIN32_FIND_DATA
     * }
     */
    public static final AddressLayout LPWIN32_FIND_DATA = C_POINTER;
    private static final int FindExInfoStandard = (int)0L;
    /**
     * {@snippet lang=c :
     * enum _FINDEX_INFO_LEVELS.FindExInfoStandard = 0
     * }
     */
    public static int FindExInfoStandard() {
        return FindExInfoStandard;
    }
    private static final int FindExInfoBasic = (int)1L;
    /**
     * {@snippet lang=c :
     * enum _FINDEX_INFO_LEVELS.FindExInfoBasic = 1
     * }
     */
    public static int FindExInfoBasic() {
        return FindExInfoBasic;
    }
    private static final int FindExInfoMaxInfoLevel = (int)2L;
    /**
     * {@snippet lang=c :
     * enum _FINDEX_INFO_LEVELS.FindExInfoMaxInfoLevel = 2
     * }
     */
    public static int FindExInfoMaxInfoLevel() {
        return FindExInfoMaxInfoLevel;
    }
    private static final int FindExSearchNameMatch = (int)0L;
    /**
     * {@snippet lang=c :
     * enum _FINDEX_SEARCH_OPS.FindExSearchNameMatch = 0
     * }
     */
    public static int FindExSearchNameMatch() {
        return FindExSearchNameMatch;
    }
    private static final int FindExSearchLimitToDirectories = (int)1L;
    /**
     * {@snippet lang=c :
     * enum _FINDEX_SEARCH_OPS.FindExSearchLimitToDirectories = 1
     * }
     */
    public static int FindExSearchLimitToDirectories() {
        return FindExSearchLimitToDirectories;
    }
    private static final int FindExSearchLimitToDevices = (int)2L;
    /**
     * {@snippet lang=c :
     * enum _FINDEX_SEARCH_OPS.FindExSearchLimitToDevices = 2
     * }
     */
    public static int FindExSearchLimitToDevices() {
        return FindExSearchLimitToDevices;
    }
    private static final int FindExSearchMaxSearchOp = (int)3L;
    /**
     * {@snippet lang=c :
     * enum _FINDEX_SEARCH_OPS.FindExSearchMaxSearchOp = 3
     * }
     */
    public static int FindExSearchMaxSearchOp() {
        return FindExSearchMaxSearchOp;
    }
    private static final int ReadDirectoryNotifyInformation = (int)1L;
    /**
     * {@snippet lang=c :
     * enum _READ_DIRECTORY_NOTIFY_INFORMATION_CLASS.ReadDirectoryNotifyInformation = 1
     * }
     */
    public static int ReadDirectoryNotifyInformation() {
        return ReadDirectoryNotifyInformation;
    }
    private static final int ReadDirectoryNotifyExtendedInformation = (int)2L;
    /**
     * {@snippet lang=c :
     * enum _READ_DIRECTORY_NOTIFY_INFORMATION_CLASS.ReadDirectoryNotifyExtendedInformation = 2
     * }
     */
    public static int ReadDirectoryNotifyExtendedInformation() {
        return ReadDirectoryNotifyExtendedInformation;
    }
    /**
     * {@snippet lang=c :
     * typedef enum _READ_DIRECTORY_NOTIFY_INFORMATION_CLASS {
     *     ReadDirectoryNotifyInformation = 1,
     *     ReadDirectoryNotifyExtendedInformation
     * } *PREAD_DIRECTORY_NOTIFY_INFORMATION_CLASS
     * }
     */
    public static final AddressLayout PREAD_DIRECTORY_NOTIFY_INFORMATION_CLASS = C_POINTER;
    private static final int GetFileExInfoStandard = (int)0L;
    /**
     * {@snippet lang=c :
     * enum _GET_FILEEX_INFO_LEVELS.GetFileExInfoStandard = 0
     * }
     */
    public static int GetFileExInfoStandard() {
        return GetFileExInfoStandard;
    }
    private static final int GetFileExMaxInfoLevel = (int)1L;
    /**
     * {@snippet lang=c :
     * enum _GET_FILEEX_INFO_LEVELS.GetFileExMaxInfoLevel = 1
     * }
     */
    public static int GetFileExMaxInfoLevel() {
        return GetFileExMaxInfoLevel;
    }
    private static final int FileBasicInfo = (int)0L;
    /**
     * {@snippet lang=c :
     * enum _FILE_INFO_BY_HANDLE_CLASS.FileBasicInfo = 0
     * }
     */
    public static int FileBasicInfo() {
        return FileBasicInfo;
    }
    private static final int FileStandardInfo = (int)1L;
    /**
     * {@snippet lang=c :
     * enum _FILE_INFO_BY_HANDLE_CLASS.FileStandardInfo = 1
     * }
     */
    public static int FileStandardInfo() {
        return FileStandardInfo;
    }
    private static final int FileNameInfo = (int)2L;
    /**
     * {@snippet lang=c :
     * enum _FILE_INFO_BY_HANDLE_CLASS.FileNameInfo = 2
     * }
     */
    public static int FileNameInfo() {
        return FileNameInfo;
    }
    private static final int FileRenameInfo = (int)3L;
    /**
     * {@snippet lang=c :
     * enum _FILE_INFO_BY_HANDLE_CLASS.FileRenameInfo = 3
     * }
     */
    public static int FileRenameInfo() {
        return FileRenameInfo;
    }
    private static final int FileDispositionInfo = (int)4L;
    /**
     * {@snippet lang=c :
     * enum _FILE_INFO_BY_HANDLE_CLASS.FileDispositionInfo = 4
     * }
     */
    public static int FileDispositionInfo() {
        return FileDispositionInfo;
    }
    private static final int FileAllocationInfo = (int)5L;
    /**
     * {@snippet lang=c :
     * enum _FILE_INFO_BY_HANDLE_CLASS.FileAllocationInfo = 5
     * }
     */
    public static int FileAllocationInfo() {
        return FileAllocationInfo;
    }
    private static final int FileEndOfFileInfo = (int)6L;
    /**
     * {@snippet lang=c :
     * enum _FILE_INFO_BY_HANDLE_CLASS.FileEndOfFileInfo = 6
     * }
     */
    public static int FileEndOfFileInfo() {
        return FileEndOfFileInfo;
    }
    private static final int FileStreamInfo = (int)7L;
    /**
     * {@snippet lang=c :
     * enum _FILE_INFO_BY_HANDLE_CLASS.FileStreamInfo = 7
     * }
     */
    public static int FileStreamInfo() {
        return FileStreamInfo;
    }
    private static final int FileCompressionInfo = (int)8L;
    /**
     * {@snippet lang=c :
     * enum _FILE_INFO_BY_HANDLE_CLASS.FileCompressionInfo = 8
     * }
     */
    public static int FileCompressionInfo() {
        return FileCompressionInfo;
    }
    private static final int FileAttributeTagInfo = (int)9L;
    /**
     * {@snippet lang=c :
     * enum _FILE_INFO_BY_HANDLE_CLASS.FileAttributeTagInfo = 9
     * }
     */
    public static int FileAttributeTagInfo() {
        return FileAttributeTagInfo;
    }
    private static final int FileIdBothDirectoryInfo = (int)10L;
    /**
     * {@snippet lang=c :
     * enum _FILE_INFO_BY_HANDLE_CLASS.FileIdBothDirectoryInfo = 10
     * }
     */
    public static int FileIdBothDirectoryInfo() {
        return FileIdBothDirectoryInfo;
    }
    private static final int FileIdBothDirectoryRestartInfo = (int)11L;
    /**
     * {@snippet lang=c :
     * enum _FILE_INFO_BY_HANDLE_CLASS.FileIdBothDirectoryRestartInfo = 11
     * }
     */
    public static int FileIdBothDirectoryRestartInfo() {
        return FileIdBothDirectoryRestartInfo;
    }
    private static final int FileIoPriorityHintInfo = (int)12L;
    /**
     * {@snippet lang=c :
     * enum _FILE_INFO_BY_HANDLE_CLASS.FileIoPriorityHintInfo = 12
     * }
     */
    public static int FileIoPriorityHintInfo() {
        return FileIoPriorityHintInfo;
    }
    private static final int FileRemoteProtocolInfo = (int)13L;
    /**
     * {@snippet lang=c :
     * enum _FILE_INFO_BY_HANDLE_CLASS.FileRemoteProtocolInfo = 13
     * }
     */
    public static int FileRemoteProtocolInfo() {
        return FileRemoteProtocolInfo;
    }
    private static final int FileFullDirectoryInfo = (int)14L;
    /**
     * {@snippet lang=c :
     * enum _FILE_INFO_BY_HANDLE_CLASS.FileFullDirectoryInfo = 14
     * }
     */
    public static int FileFullDirectoryInfo() {
        return FileFullDirectoryInfo;
    }
    private static final int FileFullDirectoryRestartInfo = (int)15L;
    /**
     * {@snippet lang=c :
     * enum _FILE_INFO_BY_HANDLE_CLASS.FileFullDirectoryRestartInfo = 15
     * }
     */
    public static int FileFullDirectoryRestartInfo() {
        return FileFullDirectoryRestartInfo;
    }
    private static final int FileStorageInfo = (int)16L;
    /**
     * {@snippet lang=c :
     * enum _FILE_INFO_BY_HANDLE_CLASS.FileStorageInfo = 16
     * }
     */
    public static int FileStorageInfo() {
        return FileStorageInfo;
    }
    private static final int FileAlignmentInfo = (int)17L;
    /**
     * {@snippet lang=c :
     * enum _FILE_INFO_BY_HANDLE_CLASS.FileAlignmentInfo = 17
     * }
     */
    public static int FileAlignmentInfo() {
        return FileAlignmentInfo;
    }
    private static final int FileIdInfo = (int)18L;
    /**
     * {@snippet lang=c :
     * enum _FILE_INFO_BY_HANDLE_CLASS.FileIdInfo = 18
     * }
     */
    public static int FileIdInfo() {
        return FileIdInfo;
    }
    private static final int FileIdExtdDirectoryInfo = (int)19L;
    /**
     * {@snippet lang=c :
     * enum _FILE_INFO_BY_HANDLE_CLASS.FileIdExtdDirectoryInfo = 19
     * }
     */
    public static int FileIdExtdDirectoryInfo() {
        return FileIdExtdDirectoryInfo;
    }
    private static final int FileIdExtdDirectoryRestartInfo = (int)20L;
    /**
     * {@snippet lang=c :
     * enum _FILE_INFO_BY_HANDLE_CLASS.FileIdExtdDirectoryRestartInfo = 20
     * }
     */
    public static int FileIdExtdDirectoryRestartInfo() {
        return FileIdExtdDirectoryRestartInfo;
    }
    private static final int FileDispositionInfoEx = (int)21L;
    /**
     * {@snippet lang=c :
     * enum _FILE_INFO_BY_HANDLE_CLASS.FileDispositionInfoEx = 21
     * }
     */
    public static int FileDispositionInfoEx() {
        return FileDispositionInfoEx;
    }
    private static final int FileRenameInfoEx = (int)22L;
    /**
     * {@snippet lang=c :
     * enum _FILE_INFO_BY_HANDLE_CLASS.FileRenameInfoEx = 22
     * }
     */
    public static int FileRenameInfoEx() {
        return FileRenameInfoEx;
    }
    private static final int FileCaseSensitiveInfo = (int)23L;
    /**
     * {@snippet lang=c :
     * enum _FILE_INFO_BY_HANDLE_CLASS.FileCaseSensitiveInfo = 23
     * }
     */
    public static int FileCaseSensitiveInfo() {
        return FileCaseSensitiveInfo;
    }
    private static final int FileNormalizedNameInfo = (int)24L;
    /**
     * {@snippet lang=c :
     * enum _FILE_INFO_BY_HANDLE_CLASS.FileNormalizedNameInfo = 24
     * }
     */
    public static int FileNormalizedNameInfo() {
        return FileNormalizedNameInfo;
    }
    private static final int MaximumFileInfoByHandleClass = (int)25L;
    /**
     * {@snippet lang=c :
     * enum _FILE_INFO_BY_HANDLE_CLASS.MaximumFileInfoByHandleClass = 25
     * }
     */
    public static int MaximumFileInfoByHandleClass() {
        return MaximumFileInfoByHandleClass;
    }
    /**
     * {@snippet lang=c :
     * typedef enum _FILE_INFO_BY_HANDLE_CLASS {
     *     FileBasicInfo,
     *     FileStandardInfo,
     *     FileNameInfo,
     *     FileRenameInfo,
     *     FileDispositionInfo,
     *     FileAllocationInfo,
     *     FileEndOfFileInfo,
     *     FileStreamInfo,
     *     FileCompressionInfo,
     *     FileAttributeTagInfo,
     *     FileIdBothDirectoryInfo,
     *     FileIdBothDirectoryRestartInfo,
     *     FileIoPriorityHintInfo,
     *     FileRemoteProtocolInfo,
     *     FileFullDirectoryInfo,
     *     FileFullDirectoryRestartInfo,
     *     FileStorageInfo,
     *     FileAlignmentInfo,
     *     FileIdInfo,
     *     FileIdExtdDirectoryInfo,
     *     FileIdExtdDirectoryRestartInfo,
     *     FileDispositionInfoEx,
     *     FileRenameInfoEx,
     *     FileCaseSensitiveInfo,
     *     FileNormalizedNameInfo,
     *     MaximumFileInfoByHandleClass
     * } *PFILE_INFO_BY_HANDLE_CLASS
     * }
     */
    public static final AddressLayout PFILE_INFO_BY_HANDLE_CLASS = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef PRTL_CRITICAL_SECTION PCRITICAL_SECTION
     * }
     */
    public static final AddressLayout PCRITICAL_SECTION = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef PRTL_CRITICAL_SECTION LPCRITICAL_SECTION
     * }
     */
    public static final AddressLayout LPCRITICAL_SECTION = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef PRTL_CRITICAL_SECTION_DEBUG PCRITICAL_SECTION_DEBUG
     * }
     */
    public static final AddressLayout PCRITICAL_SECTION_DEBUG = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef PRTL_CRITICAL_SECTION_DEBUG LPCRITICAL_SECTION_DEBUG
     * }
     */
    public static final AddressLayout LPCRITICAL_SECTION_DEBUG = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _PROCESS_HEAP_ENTRY {
     *     PVOID lpData;
     *     DWORD cbData;
     *     BYTE cbOverhead;
     *     BYTE iRegionIndex;
     *     WORD wFlags;
     *     union {
     *         struct {
     *             HANDLE hMem;
     *             DWORD dwReserved[3];
     *         } Block;
     *         struct {
     *             DWORD dwCommittedSize;
     *             DWORD dwUnCommittedSize;
     *             LPVOID lpFirstBlock;
     *             LPVOID lpLastBlock;
     *         } Region;
     *     };
     * } *LPPROCESS_HEAP_ENTRY
     * }
     */
    public static final AddressLayout LPPROCESS_HEAP_ENTRY = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _PROCESS_HEAP_ENTRY {
     *     PVOID lpData;
     *     DWORD cbData;
     *     BYTE cbOverhead;
     *     BYTE iRegionIndex;
     *     WORD wFlags;
     *     union {
     *         struct {
     *             HANDLE hMem;
     *             DWORD dwReserved[3];
     *         } Block;
     *         struct {
     *             DWORD dwCommittedSize;
     *             DWORD dwUnCommittedSize;
     *             LPVOID lpFirstBlock;
     *             LPVOID lpLastBlock;
     *         } Region;
     *     };
     * } *PPROCESS_HEAP_ENTRY
     * }
     */
    public static final AddressLayout PPROCESS_HEAP_ENTRY = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _REASON_CONTEXT {
     *     ULONG Version;
     *     DWORD Flags;
     *     union {
     *         struct {
     *             HMODULE LocalizedReasonModule;
     *             ULONG LocalizedReasonId;
     *             ULONG ReasonStringCount;
     *             LPWSTR *ReasonStrings;
     *         } Detailed;
     *         LPWSTR SimpleReasonString;
     *     } Reason;
     * } *PREASON_CONTEXT
     * }
     */
    public static final AddressLayout PREASON_CONTEXT = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _EXCEPTION_DEBUG_INFO {
     *     EXCEPTION_RECORD ExceptionRecord;
     *     DWORD dwFirstChance;
     * } *LPEXCEPTION_DEBUG_INFO
     * }
     */
    public static final AddressLayout LPEXCEPTION_DEBUG_INFO = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CREATE_THREAD_DEBUG_INFO {
     *     HANDLE hThread;
     *     LPVOID lpThreadLocalBase;
     *     LPTHREAD_START_ROUTINE lpStartAddress;
     * } *LPCREATE_THREAD_DEBUG_INFO
     * }
     */
    public static final AddressLayout LPCREATE_THREAD_DEBUG_INFO = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CREATE_PROCESS_DEBUG_INFO {
     *     HANDLE hFile;
     *     HANDLE hProcess;
     *     HANDLE hThread;
     *     LPVOID lpBaseOfImage;
     *     DWORD dwDebugInfoFileOffset;
     *     DWORD nDebugInfoSize;
     *     LPVOID lpThreadLocalBase;
     *     LPTHREAD_START_ROUTINE lpStartAddress;
     *     LPVOID lpImageName;
     *     WORD fUnicode;
     * } *LPCREATE_PROCESS_DEBUG_INFO
     * }
     */
    public static final AddressLayout LPCREATE_PROCESS_DEBUG_INFO = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _EXIT_THREAD_DEBUG_INFO {
     *     DWORD dwExitCode;
     * } *LPEXIT_THREAD_DEBUG_INFO
     * }
     */
    public static final AddressLayout LPEXIT_THREAD_DEBUG_INFO = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _EXIT_PROCESS_DEBUG_INFO {
     *     DWORD dwExitCode;
     * } *LPEXIT_PROCESS_DEBUG_INFO
     * }
     */
    public static final AddressLayout LPEXIT_PROCESS_DEBUG_INFO = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _LOAD_DLL_DEBUG_INFO {
     *     HANDLE hFile;
     *     LPVOID lpBaseOfDll;
     *     DWORD dwDebugInfoFileOffset;
     *     DWORD nDebugInfoSize;
     *     LPVOID lpImageName;
     *     WORD fUnicode;
     * } *LPLOAD_DLL_DEBUG_INFO
     * }
     */
    public static final AddressLayout LPLOAD_DLL_DEBUG_INFO = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _UNLOAD_DLL_DEBUG_INFO {
     *     LPVOID lpBaseOfDll;
     * } *LPUNLOAD_DLL_DEBUG_INFO
     * }
     */
    public static final AddressLayout LPUNLOAD_DLL_DEBUG_INFO = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _OUTPUT_DEBUG_STRING_INFO {
     *     LPSTR lpDebugStringData;
     *     WORD fUnicode;
     *     WORD nDebugStringLength;
     * } *LPOUTPUT_DEBUG_STRING_INFO
     * }
     */
    public static final AddressLayout LPOUTPUT_DEBUG_STRING_INFO = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _RIP_INFO {
     *     DWORD dwError;
     *     DWORD dwType;
     * } *LPRIP_INFO
     * }
     */
    public static final AddressLayout LPRIP_INFO = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _DEBUG_EVENT {
     *     DWORD dwDebugEventCode;
     *     DWORD dwProcessId;
     *     DWORD dwThreadId;
     *     union {
     *         EXCEPTION_DEBUG_INFO Exception;
     *         CREATE_THREAD_DEBUG_INFO CreateThread;
     *         CREATE_PROCESS_DEBUG_INFO CreateProcessInfo;
     *         EXIT_THREAD_DEBUG_INFO ExitThread;
     *         EXIT_PROCESS_DEBUG_INFO ExitProcess;
     *         LOAD_DLL_DEBUG_INFO LoadDll;
     *         UNLOAD_DLL_DEBUG_INFO UnloadDll;
     *         OUTPUT_DEBUG_STRING_INFO DebugString;
     *         RIP_INFO RipInfo;
     *     } u;
     * } *LPDEBUG_EVENT
     * }
     */
    public static final AddressLayout LPDEBUG_EVENT = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef PCONTEXT LPCONTEXT
     * }
     */
    public static final AddressLayout LPCONTEXT = C_POINTER;

    private static class IsApiSetImplemented {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("IsApiSetImplemented"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL IsApiSetImplemented(PCSTR Contract)
     * }
     */
    public static FunctionDescriptor IsApiSetImplemented$descriptor() {
        return IsApiSetImplemented.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL IsApiSetImplemented(PCSTR Contract)
     * }
     */
    public static MethodHandle IsApiSetImplemented$handle() {
        return IsApiSetImplemented.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL IsApiSetImplemented(PCSTR Contract)
     * }
     */
    public static int IsApiSetImplemented(MemorySegment Contract) {
        var mh$ = IsApiSetImplemented.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("IsApiSetImplemented", Contract);
            }
            return (int)mh$.invokeExact(Contract);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetEnvironmentStringsW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("SetEnvironmentStringsW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetEnvironmentStringsW(LPWCH NewEnvironment)
     * }
     */
    public static FunctionDescriptor SetEnvironmentStringsW$descriptor() {
        return SetEnvironmentStringsW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetEnvironmentStringsW(LPWCH NewEnvironment)
     * }
     */
    public static MethodHandle SetEnvironmentStringsW$handle() {
        return SetEnvironmentStringsW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL SetEnvironmentStringsW(LPWCH NewEnvironment)
     * }
     */
    public static int SetEnvironmentStringsW(MemorySegment NewEnvironment) {
        var mh$ = SetEnvironmentStringsW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetEnvironmentStringsW", NewEnvironment);
            }
            return (int)mh$.invokeExact(NewEnvironment);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetStdHandle {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetStdHandle"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HANDLE GetStdHandle(DWORD nStdHandle)
     * }
     */
    public static FunctionDescriptor GetStdHandle$descriptor() {
        return GetStdHandle.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HANDLE GetStdHandle(DWORD nStdHandle)
     * }
     */
    public static MethodHandle GetStdHandle$handle() {
        return GetStdHandle.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * HANDLE GetStdHandle(DWORD nStdHandle)
     * }
     */
    public static MemorySegment GetStdHandle(int nStdHandle) {
        var mh$ = GetStdHandle.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetStdHandle", nStdHandle);
            }
            return (MemorySegment)mh$.invokeExact(nStdHandle);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetStdHandle {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_LONG,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("SetStdHandle"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetStdHandle(DWORD nStdHandle, HANDLE hHandle)
     * }
     */
    public static FunctionDescriptor SetStdHandle$descriptor() {
        return SetStdHandle.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetStdHandle(DWORD nStdHandle, HANDLE hHandle)
     * }
     */
    public static MethodHandle SetStdHandle$handle() {
        return SetStdHandle.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL SetStdHandle(DWORD nStdHandle, HANDLE hHandle)
     * }
     */
    public static int SetStdHandle(int nStdHandle, MemorySegment hHandle) {
        var mh$ = SetStdHandle.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetStdHandle", nStdHandle, hHandle);
            }
            return (int)mh$.invokeExact(nStdHandle, hHandle);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetStdHandleEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_LONG,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("SetStdHandleEx"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetStdHandleEx(DWORD nStdHandle, HANDLE hHandle, PHANDLE phPrevValue)
     * }
     */
    public static FunctionDescriptor SetStdHandleEx$descriptor() {
        return SetStdHandleEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetStdHandleEx(DWORD nStdHandle, HANDLE hHandle, PHANDLE phPrevValue)
     * }
     */
    public static MethodHandle SetStdHandleEx$handle() {
        return SetStdHandleEx.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL SetStdHandleEx(DWORD nStdHandle, HANDLE hHandle, PHANDLE phPrevValue)
     * }
     */
    public static int SetStdHandleEx(int nStdHandle, MemorySegment hHandle, MemorySegment phPrevValue) {
        var mh$ = SetStdHandleEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetStdHandleEx", nStdHandle, hHandle, phPrevValue);
            }
            return (int)mh$.invokeExact(nStdHandle, hHandle, phPrevValue);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetCommandLineA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER    );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetCommandLineA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LPSTR GetCommandLineA()
     * }
     */
    public static FunctionDescriptor GetCommandLineA$descriptor() {
        return GetCommandLineA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LPSTR GetCommandLineA()
     * }
     */
    public static MethodHandle GetCommandLineA$handle() {
        return GetCommandLineA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * LPSTR GetCommandLineA()
     * }
     */
    public static MemorySegment GetCommandLineA() {
        var mh$ = GetCommandLineA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetCommandLineA");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetCommandLineW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER    );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetCommandLineW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LPWSTR GetCommandLineW()
     * }
     */
    public static FunctionDescriptor GetCommandLineW$descriptor() {
        return GetCommandLineW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LPWSTR GetCommandLineW()
     * }
     */
    public static MethodHandle GetCommandLineW$handle() {
        return GetCommandLineW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * LPWSTR GetCommandLineW()
     * }
     */
    public static MemorySegment GetCommandLineW() {
        var mh$ = GetCommandLineW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetCommandLineW");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetEnvironmentStrings {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER    );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetEnvironmentStrings"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LPCH GetEnvironmentStrings()
     * }
     */
    public static FunctionDescriptor GetEnvironmentStrings$descriptor() {
        return GetEnvironmentStrings.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LPCH GetEnvironmentStrings()
     * }
     */
    public static MethodHandle GetEnvironmentStrings$handle() {
        return GetEnvironmentStrings.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * LPCH GetEnvironmentStrings()
     * }
     */
    public static MemorySegment GetEnvironmentStrings() {
        var mh$ = GetEnvironmentStrings.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetEnvironmentStrings");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetEnvironmentStringsW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER    );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetEnvironmentStringsW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LPWCH GetEnvironmentStringsW()
     * }
     */
    public static FunctionDescriptor GetEnvironmentStringsW$descriptor() {
        return GetEnvironmentStringsW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LPWCH GetEnvironmentStringsW()
     * }
     */
    public static MethodHandle GetEnvironmentStringsW$handle() {
        return GetEnvironmentStringsW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * LPWCH GetEnvironmentStringsW()
     * }
     */
    public static MemorySegment GetEnvironmentStringsW() {
        var mh$ = GetEnvironmentStringsW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetEnvironmentStringsW");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FreeEnvironmentStringsA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("FreeEnvironmentStringsA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL FreeEnvironmentStringsA(LPCH penv)
     * }
     */
    public static FunctionDescriptor FreeEnvironmentStringsA$descriptor() {
        return FreeEnvironmentStringsA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL FreeEnvironmentStringsA(LPCH penv)
     * }
     */
    public static MethodHandle FreeEnvironmentStringsA$handle() {
        return FreeEnvironmentStringsA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL FreeEnvironmentStringsA(LPCH penv)
     * }
     */
    public static int FreeEnvironmentStringsA(MemorySegment penv) {
        var mh$ = FreeEnvironmentStringsA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FreeEnvironmentStringsA", penv);
            }
            return (int)mh$.invokeExact(penv);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FreeEnvironmentStringsW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("FreeEnvironmentStringsW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL FreeEnvironmentStringsW(LPWCH penv)
     * }
     */
    public static FunctionDescriptor FreeEnvironmentStringsW$descriptor() {
        return FreeEnvironmentStringsW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL FreeEnvironmentStringsW(LPWCH penv)
     * }
     */
    public static MethodHandle FreeEnvironmentStringsW$handle() {
        return FreeEnvironmentStringsW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL FreeEnvironmentStringsW(LPWCH penv)
     * }
     */
    public static int FreeEnvironmentStringsW(MemorySegment penv) {
        var mh$ = FreeEnvironmentStringsW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FreeEnvironmentStringsW", penv);
            }
            return (int)mh$.invokeExact(penv);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetEnvironmentVariableA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_POINTER,
            C_POINTER,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetEnvironmentVariableA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetEnvironmentVariableA(LPCSTR lpName, LPSTR lpBuffer, DWORD nSize)
     * }
     */
    public static FunctionDescriptor GetEnvironmentVariableA$descriptor() {
        return GetEnvironmentVariableA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetEnvironmentVariableA(LPCSTR lpName, LPSTR lpBuffer, DWORD nSize)
     * }
     */
    public static MethodHandle GetEnvironmentVariableA$handle() {
        return GetEnvironmentVariableA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * DWORD GetEnvironmentVariableA(LPCSTR lpName, LPSTR lpBuffer, DWORD nSize)
     * }
     */
    public static int GetEnvironmentVariableA(MemorySegment lpName, MemorySegment lpBuffer, int nSize) {
        var mh$ = GetEnvironmentVariableA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetEnvironmentVariableA", lpName, lpBuffer, nSize);
            }
            return (int)mh$.invokeExact(lpName, lpBuffer, nSize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetEnvironmentVariableW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_POINTER,
            C_POINTER,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetEnvironmentVariableW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetEnvironmentVariableW(LPCWSTR lpName, LPWSTR lpBuffer, DWORD nSize)
     * }
     */
    public static FunctionDescriptor GetEnvironmentVariableW$descriptor() {
        return GetEnvironmentVariableW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetEnvironmentVariableW(LPCWSTR lpName, LPWSTR lpBuffer, DWORD nSize)
     * }
     */
    public static MethodHandle GetEnvironmentVariableW$handle() {
        return GetEnvironmentVariableW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * DWORD GetEnvironmentVariableW(LPCWSTR lpName, LPWSTR lpBuffer, DWORD nSize)
     * }
     */
    public static int GetEnvironmentVariableW(MemorySegment lpName, MemorySegment lpBuffer, int nSize) {
        var mh$ = GetEnvironmentVariableW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetEnvironmentVariableW", lpName, lpBuffer, nSize);
            }
            return (int)mh$.invokeExact(lpName, lpBuffer, nSize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetEnvironmentVariableA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("SetEnvironmentVariableA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetEnvironmentVariableA(LPCSTR lpName, LPCSTR lpValue)
     * }
     */
    public static FunctionDescriptor SetEnvironmentVariableA$descriptor() {
        return SetEnvironmentVariableA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetEnvironmentVariableA(LPCSTR lpName, LPCSTR lpValue)
     * }
     */
    public static MethodHandle SetEnvironmentVariableA$handle() {
        return SetEnvironmentVariableA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL SetEnvironmentVariableA(LPCSTR lpName, LPCSTR lpValue)
     * }
     */
    public static int SetEnvironmentVariableA(MemorySegment lpName, MemorySegment lpValue) {
        var mh$ = SetEnvironmentVariableA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetEnvironmentVariableA", lpName, lpValue);
            }
            return (int)mh$.invokeExact(lpName, lpValue);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetEnvironmentVariableW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("SetEnvironmentVariableW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetEnvironmentVariableW(LPCWSTR lpName, LPCWSTR lpValue)
     * }
     */
    public static FunctionDescriptor SetEnvironmentVariableW$descriptor() {
        return SetEnvironmentVariableW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetEnvironmentVariableW(LPCWSTR lpName, LPCWSTR lpValue)
     * }
     */
    public static MethodHandle SetEnvironmentVariableW$handle() {
        return SetEnvironmentVariableW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL SetEnvironmentVariableW(LPCWSTR lpName, LPCWSTR lpValue)
     * }
     */
    public static int SetEnvironmentVariableW(MemorySegment lpName, MemorySegment lpValue) {
        var mh$ = SetEnvironmentVariableW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetEnvironmentVariableW", lpName, lpValue);
            }
            return (int)mh$.invokeExact(lpName, lpValue);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ExpandEnvironmentStringsA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_POINTER,
            C_POINTER,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("ExpandEnvironmentStringsA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD ExpandEnvironmentStringsA(LPCSTR lpSrc, LPSTR lpDst, DWORD nSize)
     * }
     */
    public static FunctionDescriptor ExpandEnvironmentStringsA$descriptor() {
        return ExpandEnvironmentStringsA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD ExpandEnvironmentStringsA(LPCSTR lpSrc, LPSTR lpDst, DWORD nSize)
     * }
     */
    public static MethodHandle ExpandEnvironmentStringsA$handle() {
        return ExpandEnvironmentStringsA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * DWORD ExpandEnvironmentStringsA(LPCSTR lpSrc, LPSTR lpDst, DWORD nSize)
     * }
     */
    public static int ExpandEnvironmentStringsA(MemorySegment lpSrc, MemorySegment lpDst, int nSize) {
        var mh$ = ExpandEnvironmentStringsA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ExpandEnvironmentStringsA", lpSrc, lpDst, nSize);
            }
            return (int)mh$.invokeExact(lpSrc, lpDst, nSize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ExpandEnvironmentStringsW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_POINTER,
            C_POINTER,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("ExpandEnvironmentStringsW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD ExpandEnvironmentStringsW(LPCWSTR lpSrc, LPWSTR lpDst, DWORD nSize)
     * }
     */
    public static FunctionDescriptor ExpandEnvironmentStringsW$descriptor() {
        return ExpandEnvironmentStringsW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD ExpandEnvironmentStringsW(LPCWSTR lpSrc, LPWSTR lpDst, DWORD nSize)
     * }
     */
    public static MethodHandle ExpandEnvironmentStringsW$handle() {
        return ExpandEnvironmentStringsW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * DWORD ExpandEnvironmentStringsW(LPCWSTR lpSrc, LPWSTR lpDst, DWORD nSize)
     * }
     */
    public static int ExpandEnvironmentStringsW(MemorySegment lpSrc, MemorySegment lpDst, int nSize) {
        var mh$ = ExpandEnvironmentStringsW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ExpandEnvironmentStringsW", lpSrc, lpDst, nSize);
            }
            return (int)mh$.invokeExact(lpSrc, lpDst, nSize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetCurrentDirectoryA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("SetCurrentDirectoryA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetCurrentDirectoryA(LPCSTR lpPathName)
     * }
     */
    public static FunctionDescriptor SetCurrentDirectoryA$descriptor() {
        return SetCurrentDirectoryA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetCurrentDirectoryA(LPCSTR lpPathName)
     * }
     */
    public static MethodHandle SetCurrentDirectoryA$handle() {
        return SetCurrentDirectoryA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL SetCurrentDirectoryA(LPCSTR lpPathName)
     * }
     */
    public static int SetCurrentDirectoryA(MemorySegment lpPathName) {
        var mh$ = SetCurrentDirectoryA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetCurrentDirectoryA", lpPathName);
            }
            return (int)mh$.invokeExact(lpPathName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetCurrentDirectoryW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("SetCurrentDirectoryW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetCurrentDirectoryW(LPCWSTR lpPathName)
     * }
     */
    public static FunctionDescriptor SetCurrentDirectoryW$descriptor() {
        return SetCurrentDirectoryW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetCurrentDirectoryW(LPCWSTR lpPathName)
     * }
     */
    public static MethodHandle SetCurrentDirectoryW$handle() {
        return SetCurrentDirectoryW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL SetCurrentDirectoryW(LPCWSTR lpPathName)
     * }
     */
    public static int SetCurrentDirectoryW(MemorySegment lpPathName) {
        var mh$ = SetCurrentDirectoryW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetCurrentDirectoryW", lpPathName);
            }
            return (int)mh$.invokeExact(lpPathName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetCurrentDirectoryA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_LONG,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetCurrentDirectoryA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetCurrentDirectoryA(DWORD nBufferLength, LPSTR lpBuffer)
     * }
     */
    public static FunctionDescriptor GetCurrentDirectoryA$descriptor() {
        return GetCurrentDirectoryA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetCurrentDirectoryA(DWORD nBufferLength, LPSTR lpBuffer)
     * }
     */
    public static MethodHandle GetCurrentDirectoryA$handle() {
        return GetCurrentDirectoryA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * DWORD GetCurrentDirectoryA(DWORD nBufferLength, LPSTR lpBuffer)
     * }
     */
    public static int GetCurrentDirectoryA(int nBufferLength, MemorySegment lpBuffer) {
        var mh$ = GetCurrentDirectoryA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetCurrentDirectoryA", nBufferLength, lpBuffer);
            }
            return (int)mh$.invokeExact(nBufferLength, lpBuffer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetCurrentDirectoryW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_LONG,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetCurrentDirectoryW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetCurrentDirectoryW(DWORD nBufferLength, LPWSTR lpBuffer)
     * }
     */
    public static FunctionDescriptor GetCurrentDirectoryW$descriptor() {
        return GetCurrentDirectoryW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetCurrentDirectoryW(DWORD nBufferLength, LPWSTR lpBuffer)
     * }
     */
    public static MethodHandle GetCurrentDirectoryW$handle() {
        return GetCurrentDirectoryW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * DWORD GetCurrentDirectoryW(DWORD nBufferLength, LPWSTR lpBuffer)
     * }
     */
    public static int GetCurrentDirectoryW(int nBufferLength, MemorySegment lpBuffer) {
        var mh$ = GetCurrentDirectoryW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetCurrentDirectoryW", nBufferLength, lpBuffer);
            }
            return (int)mh$.invokeExact(nBufferLength, lpBuffer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SearchPathW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_LONG,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("SearchPathW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD SearchPathW(LPCWSTR lpPath, LPCWSTR lpFileName, LPCWSTR lpExtension, DWORD nBufferLength, LPWSTR lpBuffer, LPWSTR *lpFilePart)
     * }
     */
    public static FunctionDescriptor SearchPathW$descriptor() {
        return SearchPathW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD SearchPathW(LPCWSTR lpPath, LPCWSTR lpFileName, LPCWSTR lpExtension, DWORD nBufferLength, LPWSTR lpBuffer, LPWSTR *lpFilePart)
     * }
     */
    public static MethodHandle SearchPathW$handle() {
        return SearchPathW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * DWORD SearchPathW(LPCWSTR lpPath, LPCWSTR lpFileName, LPCWSTR lpExtension, DWORD nBufferLength, LPWSTR lpBuffer, LPWSTR *lpFilePart)
     * }
     */
    public static int SearchPathW(MemorySegment lpPath, MemorySegment lpFileName, MemorySegment lpExtension, int nBufferLength, MemorySegment lpBuffer, MemorySegment lpFilePart) {
        var mh$ = SearchPathW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SearchPathW", lpPath, lpFileName, lpExtension, nBufferLength, lpBuffer, lpFilePart);
            }
            return (int)mh$.invokeExact(lpPath, lpFileName, lpExtension, nBufferLength, lpBuffer, lpFilePart);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SearchPathA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_LONG,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("SearchPathA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD SearchPathA(LPCSTR lpPath, LPCSTR lpFileName, LPCSTR lpExtension, DWORD nBufferLength, LPSTR lpBuffer, LPSTR *lpFilePart)
     * }
     */
    public static FunctionDescriptor SearchPathA$descriptor() {
        return SearchPathA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD SearchPathA(LPCSTR lpPath, LPCSTR lpFileName, LPCSTR lpExtension, DWORD nBufferLength, LPSTR lpBuffer, LPSTR *lpFilePart)
     * }
     */
    public static MethodHandle SearchPathA$handle() {
        return SearchPathA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * DWORD SearchPathA(LPCSTR lpPath, LPCSTR lpFileName, LPCSTR lpExtension, DWORD nBufferLength, LPSTR lpBuffer, LPSTR *lpFilePart)
     * }
     */
    public static int SearchPathA(MemorySegment lpPath, MemorySegment lpFileName, MemorySegment lpExtension, int nBufferLength, MemorySegment lpBuffer, MemorySegment lpFilePart) {
        var mh$ = SearchPathA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SearchPathA", lpPath, lpFileName, lpExtension, nBufferLength, lpBuffer, lpFilePart);
            }
            return (int)mh$.invokeExact(lpPath, lpFileName, lpExtension, nBufferLength, lpBuffer, lpFilePart);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class NeedCurrentDirectoryForExePathA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("NeedCurrentDirectoryForExePathA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL NeedCurrentDirectoryForExePathA(LPCSTR ExeName)
     * }
     */
    public static FunctionDescriptor NeedCurrentDirectoryForExePathA$descriptor() {
        return NeedCurrentDirectoryForExePathA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL NeedCurrentDirectoryForExePathA(LPCSTR ExeName)
     * }
     */
    public static MethodHandle NeedCurrentDirectoryForExePathA$handle() {
        return NeedCurrentDirectoryForExePathA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL NeedCurrentDirectoryForExePathA(LPCSTR ExeName)
     * }
     */
    public static int NeedCurrentDirectoryForExePathA(MemorySegment ExeName) {
        var mh$ = NeedCurrentDirectoryForExePathA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("NeedCurrentDirectoryForExePathA", ExeName);
            }
            return (int)mh$.invokeExact(ExeName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class NeedCurrentDirectoryForExePathW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("NeedCurrentDirectoryForExePathW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL NeedCurrentDirectoryForExePathW(LPCWSTR ExeName)
     * }
     */
    public static FunctionDescriptor NeedCurrentDirectoryForExePathW$descriptor() {
        return NeedCurrentDirectoryForExePathW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL NeedCurrentDirectoryForExePathW(LPCWSTR ExeName)
     * }
     */
    public static MethodHandle NeedCurrentDirectoryForExePathW$handle() {
        return NeedCurrentDirectoryForExePathW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL NeedCurrentDirectoryForExePathW(LPCWSTR ExeName)
     * }
     */
    public static int NeedCurrentDirectoryForExePathW(MemorySegment ExeName) {
        var mh$ = NeedCurrentDirectoryForExePathW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("NeedCurrentDirectoryForExePathW", ExeName);
            }
            return (int)mh$.invokeExact(ExeName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CompareFileTime {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CompareFileTime"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LONG CompareFileTime(const FILETIME *lpFileTime1, const FILETIME *lpFileTime2)
     * }
     */
    public static FunctionDescriptor CompareFileTime$descriptor() {
        return CompareFileTime.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LONG CompareFileTime(const FILETIME *lpFileTime1, const FILETIME *lpFileTime2)
     * }
     */
    public static MethodHandle CompareFileTime$handle() {
        return CompareFileTime.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * LONG CompareFileTime(const FILETIME *lpFileTime1, const FILETIME *lpFileTime2)
     * }
     */
    public static int CompareFileTime(MemorySegment lpFileTime1, MemorySegment lpFileTime2) {
        var mh$ = CompareFileTime.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CompareFileTime", lpFileTime1, lpFileTime2);
            }
            return (int)mh$.invokeExact(lpFileTime1, lpFileTime2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateDirectoryA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CreateDirectoryA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CreateDirectoryA(LPCSTR lpPathName, LPSECURITY_ATTRIBUTES lpSecurityAttributes)
     * }
     */
    public static FunctionDescriptor CreateDirectoryA$descriptor() {
        return CreateDirectoryA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CreateDirectoryA(LPCSTR lpPathName, LPSECURITY_ATTRIBUTES lpSecurityAttributes)
     * }
     */
    public static MethodHandle CreateDirectoryA$handle() {
        return CreateDirectoryA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL CreateDirectoryA(LPCSTR lpPathName, LPSECURITY_ATTRIBUTES lpSecurityAttributes)
     * }
     */
    public static int CreateDirectoryA(MemorySegment lpPathName, MemorySegment lpSecurityAttributes) {
        var mh$ = CreateDirectoryA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateDirectoryA", lpPathName, lpSecurityAttributes);
            }
            return (int)mh$.invokeExact(lpPathName, lpSecurityAttributes);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateDirectoryW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CreateDirectoryW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CreateDirectoryW(LPCWSTR lpPathName, LPSECURITY_ATTRIBUTES lpSecurityAttributes)
     * }
     */
    public static FunctionDescriptor CreateDirectoryW$descriptor() {
        return CreateDirectoryW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CreateDirectoryW(LPCWSTR lpPathName, LPSECURITY_ATTRIBUTES lpSecurityAttributes)
     * }
     */
    public static MethodHandle CreateDirectoryW$handle() {
        return CreateDirectoryW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL CreateDirectoryW(LPCWSTR lpPathName, LPSECURITY_ATTRIBUTES lpSecurityAttributes)
     * }
     */
    public static int CreateDirectoryW(MemorySegment lpPathName, MemorySegment lpSecurityAttributes) {
        var mh$ = CreateDirectoryW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateDirectoryW", lpPathName, lpSecurityAttributes);
            }
            return (int)mh$.invokeExact(lpPathName, lpSecurityAttributes);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateFileA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER,
            C_LONG,
            C_LONG,
            C_POINTER,
            C_LONG,
            C_LONG,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CreateFileA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HANDLE CreateFileA(LPCSTR lpFileName, DWORD dwDesiredAccess, DWORD dwShareMode, LPSECURITY_ATTRIBUTES lpSecurityAttributes, DWORD dwCreationDisposition, DWORD dwFlagsAndAttributes, HANDLE hTemplateFile)
     * }
     */
    public static FunctionDescriptor CreateFileA$descriptor() {
        return CreateFileA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HANDLE CreateFileA(LPCSTR lpFileName, DWORD dwDesiredAccess, DWORD dwShareMode, LPSECURITY_ATTRIBUTES lpSecurityAttributes, DWORD dwCreationDisposition, DWORD dwFlagsAndAttributes, HANDLE hTemplateFile)
     * }
     */
    public static MethodHandle CreateFileA$handle() {
        return CreateFileA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * HANDLE CreateFileA(LPCSTR lpFileName, DWORD dwDesiredAccess, DWORD dwShareMode, LPSECURITY_ATTRIBUTES lpSecurityAttributes, DWORD dwCreationDisposition, DWORD dwFlagsAndAttributes, HANDLE hTemplateFile)
     * }
     */
    public static MemorySegment CreateFileA(MemorySegment lpFileName, int dwDesiredAccess, int dwShareMode, MemorySegment lpSecurityAttributes, int dwCreationDisposition, int dwFlagsAndAttributes, MemorySegment hTemplateFile) {
        var mh$ = CreateFileA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateFileA", lpFileName, dwDesiredAccess, dwShareMode, lpSecurityAttributes, dwCreationDisposition, dwFlagsAndAttributes, hTemplateFile);
            }
            return (MemorySegment)mh$.invokeExact(lpFileName, dwDesiredAccess, dwShareMode, lpSecurityAttributes, dwCreationDisposition, dwFlagsAndAttributes, hTemplateFile);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateFileW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER,
            C_LONG,
            C_LONG,
            C_POINTER,
            C_LONG,
            C_LONG,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CreateFileW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HANDLE CreateFileW(LPCWSTR lpFileName, DWORD dwDesiredAccess, DWORD dwShareMode, LPSECURITY_ATTRIBUTES lpSecurityAttributes, DWORD dwCreationDisposition, DWORD dwFlagsAndAttributes, HANDLE hTemplateFile)
     * }
     */
    public static FunctionDescriptor CreateFileW$descriptor() {
        return CreateFileW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HANDLE CreateFileW(LPCWSTR lpFileName, DWORD dwDesiredAccess, DWORD dwShareMode, LPSECURITY_ATTRIBUTES lpSecurityAttributes, DWORD dwCreationDisposition, DWORD dwFlagsAndAttributes, HANDLE hTemplateFile)
     * }
     */
    public static MethodHandle CreateFileW$handle() {
        return CreateFileW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * HANDLE CreateFileW(LPCWSTR lpFileName, DWORD dwDesiredAccess, DWORD dwShareMode, LPSECURITY_ATTRIBUTES lpSecurityAttributes, DWORD dwCreationDisposition, DWORD dwFlagsAndAttributes, HANDLE hTemplateFile)
     * }
     */
    public static MemorySegment CreateFileW(MemorySegment lpFileName, int dwDesiredAccess, int dwShareMode, MemorySegment lpSecurityAttributes, int dwCreationDisposition, int dwFlagsAndAttributes, MemorySegment hTemplateFile) {
        var mh$ = CreateFileW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateFileW", lpFileName, dwDesiredAccess, dwShareMode, lpSecurityAttributes, dwCreationDisposition, dwFlagsAndAttributes, hTemplateFile);
            }
            return (MemorySegment)mh$.invokeExact(lpFileName, dwDesiredAccess, dwShareMode, lpSecurityAttributes, dwCreationDisposition, dwFlagsAndAttributes, hTemplateFile);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DefineDosDeviceW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_LONG,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("DefineDosDeviceW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL DefineDosDeviceW(DWORD dwFlags, LPCWSTR lpDeviceName, LPCWSTR lpTargetPath)
     * }
     */
    public static FunctionDescriptor DefineDosDeviceW$descriptor() {
        return DefineDosDeviceW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL DefineDosDeviceW(DWORD dwFlags, LPCWSTR lpDeviceName, LPCWSTR lpTargetPath)
     * }
     */
    public static MethodHandle DefineDosDeviceW$handle() {
        return DefineDosDeviceW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL DefineDosDeviceW(DWORD dwFlags, LPCWSTR lpDeviceName, LPCWSTR lpTargetPath)
     * }
     */
    public static int DefineDosDeviceW(int dwFlags, MemorySegment lpDeviceName, MemorySegment lpTargetPath) {
        var mh$ = DefineDosDeviceW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DefineDosDeviceW", dwFlags, lpDeviceName, lpTargetPath);
            }
            return (int)mh$.invokeExact(dwFlags, lpDeviceName, lpTargetPath);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DeleteFileA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("DeleteFileA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL DeleteFileA(LPCSTR lpFileName)
     * }
     */
    public static FunctionDescriptor DeleteFileA$descriptor() {
        return DeleteFileA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL DeleteFileA(LPCSTR lpFileName)
     * }
     */
    public static MethodHandle DeleteFileA$handle() {
        return DeleteFileA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL DeleteFileA(LPCSTR lpFileName)
     * }
     */
    public static int DeleteFileA(MemorySegment lpFileName) {
        var mh$ = DeleteFileA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DeleteFileA", lpFileName);
            }
            return (int)mh$.invokeExact(lpFileName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DeleteFileW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("DeleteFileW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL DeleteFileW(LPCWSTR lpFileName)
     * }
     */
    public static FunctionDescriptor DeleteFileW$descriptor() {
        return DeleteFileW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL DeleteFileW(LPCWSTR lpFileName)
     * }
     */
    public static MethodHandle DeleteFileW$handle() {
        return DeleteFileW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL DeleteFileW(LPCWSTR lpFileName)
     * }
     */
    public static int DeleteFileW(MemorySegment lpFileName) {
        var mh$ = DeleteFileW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DeleteFileW", lpFileName);
            }
            return (int)mh$.invokeExact(lpFileName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DeleteVolumeMountPointW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("DeleteVolumeMountPointW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL DeleteVolumeMountPointW(LPCWSTR lpszVolumeMountPoint)
     * }
     */
    public static FunctionDescriptor DeleteVolumeMountPointW$descriptor() {
        return DeleteVolumeMountPointW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL DeleteVolumeMountPointW(LPCWSTR lpszVolumeMountPoint)
     * }
     */
    public static MethodHandle DeleteVolumeMountPointW$handle() {
        return DeleteVolumeMountPointW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL DeleteVolumeMountPointW(LPCWSTR lpszVolumeMountPoint)
     * }
     */
    public static int DeleteVolumeMountPointW(MemorySegment lpszVolumeMountPoint) {
        var mh$ = DeleteVolumeMountPointW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DeleteVolumeMountPointW", lpszVolumeMountPoint);
            }
            return (int)mh$.invokeExact(lpszVolumeMountPoint);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FileTimeToLocalFileTime {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("FileTimeToLocalFileTime"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL FileTimeToLocalFileTime(const FILETIME *lpFileTime, LPFILETIME lpLocalFileTime)
     * }
     */
    public static FunctionDescriptor FileTimeToLocalFileTime$descriptor() {
        return FileTimeToLocalFileTime.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL FileTimeToLocalFileTime(const FILETIME *lpFileTime, LPFILETIME lpLocalFileTime)
     * }
     */
    public static MethodHandle FileTimeToLocalFileTime$handle() {
        return FileTimeToLocalFileTime.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL FileTimeToLocalFileTime(const FILETIME *lpFileTime, LPFILETIME lpLocalFileTime)
     * }
     */
    public static int FileTimeToLocalFileTime(MemorySegment lpFileTime, MemorySegment lpLocalFileTime) {
        var mh$ = FileTimeToLocalFileTime.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FileTimeToLocalFileTime", lpFileTime, lpLocalFileTime);
            }
            return (int)mh$.invokeExact(lpFileTime, lpLocalFileTime);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FindClose {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("FindClose"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL FindClose(HANDLE hFindFile)
     * }
     */
    public static FunctionDescriptor FindClose$descriptor() {
        return FindClose.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL FindClose(HANDLE hFindFile)
     * }
     */
    public static MethodHandle FindClose$handle() {
        return FindClose.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL FindClose(HANDLE hFindFile)
     * }
     */
    public static int FindClose(MemorySegment hFindFile) {
        var mh$ = FindClose.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FindClose", hFindFile);
            }
            return (int)mh$.invokeExact(hFindFile);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FindCloseChangeNotification {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("FindCloseChangeNotification"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL FindCloseChangeNotification(HANDLE hChangeHandle)
     * }
     */
    public static FunctionDescriptor FindCloseChangeNotification$descriptor() {
        return FindCloseChangeNotification.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL FindCloseChangeNotification(HANDLE hChangeHandle)
     * }
     */
    public static MethodHandle FindCloseChangeNotification$handle() {
        return FindCloseChangeNotification.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL FindCloseChangeNotification(HANDLE hChangeHandle)
     * }
     */
    public static int FindCloseChangeNotification(MemorySegment hChangeHandle) {
        var mh$ = FindCloseChangeNotification.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FindCloseChangeNotification", hChangeHandle);
            }
            return (int)mh$.invokeExact(hChangeHandle);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FindFirstChangeNotificationA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER,
            C_INT,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("FindFirstChangeNotificationA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HANDLE FindFirstChangeNotificationA(LPCSTR lpPathName, BOOL bWatchSubtree, DWORD dwNotifyFilter)
     * }
     */
    public static FunctionDescriptor FindFirstChangeNotificationA$descriptor() {
        return FindFirstChangeNotificationA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HANDLE FindFirstChangeNotificationA(LPCSTR lpPathName, BOOL bWatchSubtree, DWORD dwNotifyFilter)
     * }
     */
    public static MethodHandle FindFirstChangeNotificationA$handle() {
        return FindFirstChangeNotificationA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * HANDLE FindFirstChangeNotificationA(LPCSTR lpPathName, BOOL bWatchSubtree, DWORD dwNotifyFilter)
     * }
     */
    public static MemorySegment FindFirstChangeNotificationA(MemorySegment lpPathName, int bWatchSubtree, int dwNotifyFilter) {
        var mh$ = FindFirstChangeNotificationA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FindFirstChangeNotificationA", lpPathName, bWatchSubtree, dwNotifyFilter);
            }
            return (MemorySegment)mh$.invokeExact(lpPathName, bWatchSubtree, dwNotifyFilter);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FindFirstChangeNotificationW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER,
            C_INT,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("FindFirstChangeNotificationW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HANDLE FindFirstChangeNotificationW(LPCWSTR lpPathName, BOOL bWatchSubtree, DWORD dwNotifyFilter)
     * }
     */
    public static FunctionDescriptor FindFirstChangeNotificationW$descriptor() {
        return FindFirstChangeNotificationW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HANDLE FindFirstChangeNotificationW(LPCWSTR lpPathName, BOOL bWatchSubtree, DWORD dwNotifyFilter)
     * }
     */
    public static MethodHandle FindFirstChangeNotificationW$handle() {
        return FindFirstChangeNotificationW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * HANDLE FindFirstChangeNotificationW(LPCWSTR lpPathName, BOOL bWatchSubtree, DWORD dwNotifyFilter)
     * }
     */
    public static MemorySegment FindFirstChangeNotificationW(MemorySegment lpPathName, int bWatchSubtree, int dwNotifyFilter) {
        var mh$ = FindFirstChangeNotificationW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FindFirstChangeNotificationW", lpPathName, bWatchSubtree, dwNotifyFilter);
            }
            return (MemorySegment)mh$.invokeExact(lpPathName, bWatchSubtree, dwNotifyFilter);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FindFirstFileA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("FindFirstFileA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HANDLE FindFirstFileA(LPCSTR lpFileName, LPWIN32_FIND_DATAA lpFindFileData)
     * }
     */
    public static FunctionDescriptor FindFirstFileA$descriptor() {
        return FindFirstFileA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HANDLE FindFirstFileA(LPCSTR lpFileName, LPWIN32_FIND_DATAA lpFindFileData)
     * }
     */
    public static MethodHandle FindFirstFileA$handle() {
        return FindFirstFileA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * HANDLE FindFirstFileA(LPCSTR lpFileName, LPWIN32_FIND_DATAA lpFindFileData)
     * }
     */
    public static MemorySegment FindFirstFileA(MemorySegment lpFileName, MemorySegment lpFindFileData) {
        var mh$ = FindFirstFileA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FindFirstFileA", lpFileName, lpFindFileData);
            }
            return (MemorySegment)mh$.invokeExact(lpFileName, lpFindFileData);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FindFirstFileW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("FindFirstFileW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HANDLE FindFirstFileW(LPCWSTR lpFileName, LPWIN32_FIND_DATAW lpFindFileData)
     * }
     */
    public static FunctionDescriptor FindFirstFileW$descriptor() {
        return FindFirstFileW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HANDLE FindFirstFileW(LPCWSTR lpFileName, LPWIN32_FIND_DATAW lpFindFileData)
     * }
     */
    public static MethodHandle FindFirstFileW$handle() {
        return FindFirstFileW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * HANDLE FindFirstFileW(LPCWSTR lpFileName, LPWIN32_FIND_DATAW lpFindFileData)
     * }
     */
    public static MemorySegment FindFirstFileW(MemorySegment lpFileName, MemorySegment lpFindFileData) {
        var mh$ = FindFirstFileW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FindFirstFileW", lpFileName, lpFindFileData);
            }
            return (MemorySegment)mh$.invokeExact(lpFileName, lpFindFileData);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FindFirstFileExA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER,
            C_INT,
            C_POINTER,
            C_INT,
            C_POINTER,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("FindFirstFileExA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HANDLE FindFirstFileExA(LPCSTR lpFileName, FINDEX_INFO_LEVELS fInfoLevelId, LPVOID lpFindFileData, FINDEX_SEARCH_OPS fSearchOp, LPVOID lpSearchFilter, DWORD dwAdditionalFlags)
     * }
     */
    public static FunctionDescriptor FindFirstFileExA$descriptor() {
        return FindFirstFileExA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HANDLE FindFirstFileExA(LPCSTR lpFileName, FINDEX_INFO_LEVELS fInfoLevelId, LPVOID lpFindFileData, FINDEX_SEARCH_OPS fSearchOp, LPVOID lpSearchFilter, DWORD dwAdditionalFlags)
     * }
     */
    public static MethodHandle FindFirstFileExA$handle() {
        return FindFirstFileExA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * HANDLE FindFirstFileExA(LPCSTR lpFileName, FINDEX_INFO_LEVELS fInfoLevelId, LPVOID lpFindFileData, FINDEX_SEARCH_OPS fSearchOp, LPVOID lpSearchFilter, DWORD dwAdditionalFlags)
     * }
     */
    public static MemorySegment FindFirstFileExA(MemorySegment lpFileName, int fInfoLevelId, MemorySegment lpFindFileData, int fSearchOp, MemorySegment lpSearchFilter, int dwAdditionalFlags) {
        var mh$ = FindFirstFileExA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FindFirstFileExA", lpFileName, fInfoLevelId, lpFindFileData, fSearchOp, lpSearchFilter, dwAdditionalFlags);
            }
            return (MemorySegment)mh$.invokeExact(lpFileName, fInfoLevelId, lpFindFileData, fSearchOp, lpSearchFilter, dwAdditionalFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FindFirstFileExW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER,
            C_INT,
            C_POINTER,
            C_INT,
            C_POINTER,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("FindFirstFileExW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HANDLE FindFirstFileExW(LPCWSTR lpFileName, FINDEX_INFO_LEVELS fInfoLevelId, LPVOID lpFindFileData, FINDEX_SEARCH_OPS fSearchOp, LPVOID lpSearchFilter, DWORD dwAdditionalFlags)
     * }
     */
    public static FunctionDescriptor FindFirstFileExW$descriptor() {
        return FindFirstFileExW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HANDLE FindFirstFileExW(LPCWSTR lpFileName, FINDEX_INFO_LEVELS fInfoLevelId, LPVOID lpFindFileData, FINDEX_SEARCH_OPS fSearchOp, LPVOID lpSearchFilter, DWORD dwAdditionalFlags)
     * }
     */
    public static MethodHandle FindFirstFileExW$handle() {
        return FindFirstFileExW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * HANDLE FindFirstFileExW(LPCWSTR lpFileName, FINDEX_INFO_LEVELS fInfoLevelId, LPVOID lpFindFileData, FINDEX_SEARCH_OPS fSearchOp, LPVOID lpSearchFilter, DWORD dwAdditionalFlags)
     * }
     */
    public static MemorySegment FindFirstFileExW(MemorySegment lpFileName, int fInfoLevelId, MemorySegment lpFindFileData, int fSearchOp, MemorySegment lpSearchFilter, int dwAdditionalFlags) {
        var mh$ = FindFirstFileExW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FindFirstFileExW", lpFileName, fInfoLevelId, lpFindFileData, fSearchOp, lpSearchFilter, dwAdditionalFlags);
            }
            return (MemorySegment)mh$.invokeExact(lpFileName, fInfoLevelId, lpFindFileData, fSearchOp, lpSearchFilter, dwAdditionalFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FindFirstVolumeW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("FindFirstVolumeW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HANDLE FindFirstVolumeW(LPWSTR lpszVolumeName, DWORD cchBufferLength)
     * }
     */
    public static FunctionDescriptor FindFirstVolumeW$descriptor() {
        return FindFirstVolumeW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HANDLE FindFirstVolumeW(LPWSTR lpszVolumeName, DWORD cchBufferLength)
     * }
     */
    public static MethodHandle FindFirstVolumeW$handle() {
        return FindFirstVolumeW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * HANDLE FindFirstVolumeW(LPWSTR lpszVolumeName, DWORD cchBufferLength)
     * }
     */
    public static MemorySegment FindFirstVolumeW(MemorySegment lpszVolumeName, int cchBufferLength) {
        var mh$ = FindFirstVolumeW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FindFirstVolumeW", lpszVolumeName, cchBufferLength);
            }
            return (MemorySegment)mh$.invokeExact(lpszVolumeName, cchBufferLength);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FindNextChangeNotification {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("FindNextChangeNotification"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL FindNextChangeNotification(HANDLE hChangeHandle)
     * }
     */
    public static FunctionDescriptor FindNextChangeNotification$descriptor() {
        return FindNextChangeNotification.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL FindNextChangeNotification(HANDLE hChangeHandle)
     * }
     */
    public static MethodHandle FindNextChangeNotification$handle() {
        return FindNextChangeNotification.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL FindNextChangeNotification(HANDLE hChangeHandle)
     * }
     */
    public static int FindNextChangeNotification(MemorySegment hChangeHandle) {
        var mh$ = FindNextChangeNotification.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FindNextChangeNotification", hChangeHandle);
            }
            return (int)mh$.invokeExact(hChangeHandle);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FindNextFileA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("FindNextFileA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL FindNextFileA(HANDLE hFindFile, LPWIN32_FIND_DATAA lpFindFileData)
     * }
     */
    public static FunctionDescriptor FindNextFileA$descriptor() {
        return FindNextFileA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL FindNextFileA(HANDLE hFindFile, LPWIN32_FIND_DATAA lpFindFileData)
     * }
     */
    public static MethodHandle FindNextFileA$handle() {
        return FindNextFileA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL FindNextFileA(HANDLE hFindFile, LPWIN32_FIND_DATAA lpFindFileData)
     * }
     */
    public static int FindNextFileA(MemorySegment hFindFile, MemorySegment lpFindFileData) {
        var mh$ = FindNextFileA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FindNextFileA", hFindFile, lpFindFileData);
            }
            return (int)mh$.invokeExact(hFindFile, lpFindFileData);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FindNextFileW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("FindNextFileW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL FindNextFileW(HANDLE hFindFile, LPWIN32_FIND_DATAW lpFindFileData)
     * }
     */
    public static FunctionDescriptor FindNextFileW$descriptor() {
        return FindNextFileW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL FindNextFileW(HANDLE hFindFile, LPWIN32_FIND_DATAW lpFindFileData)
     * }
     */
    public static MethodHandle FindNextFileW$handle() {
        return FindNextFileW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL FindNextFileW(HANDLE hFindFile, LPWIN32_FIND_DATAW lpFindFileData)
     * }
     */
    public static int FindNextFileW(MemorySegment hFindFile, MemorySegment lpFindFileData) {
        var mh$ = FindNextFileW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FindNextFileW", hFindFile, lpFindFileData);
            }
            return (int)mh$.invokeExact(hFindFile, lpFindFileData);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FindNextVolumeW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("FindNextVolumeW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL FindNextVolumeW(HANDLE hFindVolume, LPWSTR lpszVolumeName, DWORD cchBufferLength)
     * }
     */
    public static FunctionDescriptor FindNextVolumeW$descriptor() {
        return FindNextVolumeW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL FindNextVolumeW(HANDLE hFindVolume, LPWSTR lpszVolumeName, DWORD cchBufferLength)
     * }
     */
    public static MethodHandle FindNextVolumeW$handle() {
        return FindNextVolumeW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL FindNextVolumeW(HANDLE hFindVolume, LPWSTR lpszVolumeName, DWORD cchBufferLength)
     * }
     */
    public static int FindNextVolumeW(MemorySegment hFindVolume, MemorySegment lpszVolumeName, int cchBufferLength) {
        var mh$ = FindNextVolumeW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FindNextVolumeW", hFindVolume, lpszVolumeName, cchBufferLength);
            }
            return (int)mh$.invokeExact(hFindVolume, lpszVolumeName, cchBufferLength);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FindVolumeClose {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("FindVolumeClose"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL FindVolumeClose(HANDLE hFindVolume)
     * }
     */
    public static FunctionDescriptor FindVolumeClose$descriptor() {
        return FindVolumeClose.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL FindVolumeClose(HANDLE hFindVolume)
     * }
     */
    public static MethodHandle FindVolumeClose$handle() {
        return FindVolumeClose.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL FindVolumeClose(HANDLE hFindVolume)
     * }
     */
    public static int FindVolumeClose(MemorySegment hFindVolume) {
        var mh$ = FindVolumeClose.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FindVolumeClose", hFindVolume);
            }
            return (int)mh$.invokeExact(hFindVolume);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FlushFileBuffers {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("FlushFileBuffers"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL FlushFileBuffers(HANDLE hFile)
     * }
     */
    public static FunctionDescriptor FlushFileBuffers$descriptor() {
        return FlushFileBuffers.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL FlushFileBuffers(HANDLE hFile)
     * }
     */
    public static MethodHandle FlushFileBuffers$handle() {
        return FlushFileBuffers.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL FlushFileBuffers(HANDLE hFile)
     * }
     */
    public static int FlushFileBuffers(MemorySegment hFile) {
        var mh$ = FlushFileBuffers.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FlushFileBuffers", hFile);
            }
            return (int)mh$.invokeExact(hFile);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetDiskFreeSpaceA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetDiskFreeSpaceA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetDiskFreeSpaceA(LPCSTR lpRootPathName, LPDWORD lpSectorsPerCluster, LPDWORD lpBytesPerSector, LPDWORD lpNumberOfFreeClusters, LPDWORD lpTotalNumberOfClusters)
     * }
     */
    public static FunctionDescriptor GetDiskFreeSpaceA$descriptor() {
        return GetDiskFreeSpaceA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetDiskFreeSpaceA(LPCSTR lpRootPathName, LPDWORD lpSectorsPerCluster, LPDWORD lpBytesPerSector, LPDWORD lpNumberOfFreeClusters, LPDWORD lpTotalNumberOfClusters)
     * }
     */
    public static MethodHandle GetDiskFreeSpaceA$handle() {
        return GetDiskFreeSpaceA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL GetDiskFreeSpaceA(LPCSTR lpRootPathName, LPDWORD lpSectorsPerCluster, LPDWORD lpBytesPerSector, LPDWORD lpNumberOfFreeClusters, LPDWORD lpTotalNumberOfClusters)
     * }
     */
    public static int GetDiskFreeSpaceA(MemorySegment lpRootPathName, MemorySegment lpSectorsPerCluster, MemorySegment lpBytesPerSector, MemorySegment lpNumberOfFreeClusters, MemorySegment lpTotalNumberOfClusters) {
        var mh$ = GetDiskFreeSpaceA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetDiskFreeSpaceA", lpRootPathName, lpSectorsPerCluster, lpBytesPerSector, lpNumberOfFreeClusters, lpTotalNumberOfClusters);
            }
            return (int)mh$.invokeExact(lpRootPathName, lpSectorsPerCluster, lpBytesPerSector, lpNumberOfFreeClusters, lpTotalNumberOfClusters);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetDiskFreeSpaceW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetDiskFreeSpaceW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetDiskFreeSpaceW(LPCWSTR lpRootPathName, LPDWORD lpSectorsPerCluster, LPDWORD lpBytesPerSector, LPDWORD lpNumberOfFreeClusters, LPDWORD lpTotalNumberOfClusters)
     * }
     */
    public static FunctionDescriptor GetDiskFreeSpaceW$descriptor() {
        return GetDiskFreeSpaceW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetDiskFreeSpaceW(LPCWSTR lpRootPathName, LPDWORD lpSectorsPerCluster, LPDWORD lpBytesPerSector, LPDWORD lpNumberOfFreeClusters, LPDWORD lpTotalNumberOfClusters)
     * }
     */
    public static MethodHandle GetDiskFreeSpaceW$handle() {
        return GetDiskFreeSpaceW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL GetDiskFreeSpaceW(LPCWSTR lpRootPathName, LPDWORD lpSectorsPerCluster, LPDWORD lpBytesPerSector, LPDWORD lpNumberOfFreeClusters, LPDWORD lpTotalNumberOfClusters)
     * }
     */
    public static int GetDiskFreeSpaceW(MemorySegment lpRootPathName, MemorySegment lpSectorsPerCluster, MemorySegment lpBytesPerSector, MemorySegment lpNumberOfFreeClusters, MemorySegment lpTotalNumberOfClusters) {
        var mh$ = GetDiskFreeSpaceW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetDiskFreeSpaceW", lpRootPathName, lpSectorsPerCluster, lpBytesPerSector, lpNumberOfFreeClusters, lpTotalNumberOfClusters);
            }
            return (int)mh$.invokeExact(lpRootPathName, lpSectorsPerCluster, lpBytesPerSector, lpNumberOfFreeClusters, lpTotalNumberOfClusters);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetDiskFreeSpaceExA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetDiskFreeSpaceExA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetDiskFreeSpaceExA(LPCSTR lpDirectoryName, PULARGE_INTEGER lpFreeBytesAvailableToCaller, PULARGE_INTEGER lpTotalNumberOfBytes, PULARGE_INTEGER lpTotalNumberOfFreeBytes)
     * }
     */
    public static FunctionDescriptor GetDiskFreeSpaceExA$descriptor() {
        return GetDiskFreeSpaceExA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetDiskFreeSpaceExA(LPCSTR lpDirectoryName, PULARGE_INTEGER lpFreeBytesAvailableToCaller, PULARGE_INTEGER lpTotalNumberOfBytes, PULARGE_INTEGER lpTotalNumberOfFreeBytes)
     * }
     */
    public static MethodHandle GetDiskFreeSpaceExA$handle() {
        return GetDiskFreeSpaceExA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL GetDiskFreeSpaceExA(LPCSTR lpDirectoryName, PULARGE_INTEGER lpFreeBytesAvailableToCaller, PULARGE_INTEGER lpTotalNumberOfBytes, PULARGE_INTEGER lpTotalNumberOfFreeBytes)
     * }
     */
    public static int GetDiskFreeSpaceExA(MemorySegment lpDirectoryName, MemorySegment lpFreeBytesAvailableToCaller, MemorySegment lpTotalNumberOfBytes, MemorySegment lpTotalNumberOfFreeBytes) {
        var mh$ = GetDiskFreeSpaceExA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetDiskFreeSpaceExA", lpDirectoryName, lpFreeBytesAvailableToCaller, lpTotalNumberOfBytes, lpTotalNumberOfFreeBytes);
            }
            return (int)mh$.invokeExact(lpDirectoryName, lpFreeBytesAvailableToCaller, lpTotalNumberOfBytes, lpTotalNumberOfFreeBytes);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetDiskFreeSpaceExW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetDiskFreeSpaceExW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetDiskFreeSpaceExW(LPCWSTR lpDirectoryName, PULARGE_INTEGER lpFreeBytesAvailableToCaller, PULARGE_INTEGER lpTotalNumberOfBytes, PULARGE_INTEGER lpTotalNumberOfFreeBytes)
     * }
     */
    public static FunctionDescriptor GetDiskFreeSpaceExW$descriptor() {
        return GetDiskFreeSpaceExW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetDiskFreeSpaceExW(LPCWSTR lpDirectoryName, PULARGE_INTEGER lpFreeBytesAvailableToCaller, PULARGE_INTEGER lpTotalNumberOfBytes, PULARGE_INTEGER lpTotalNumberOfFreeBytes)
     * }
     */
    public static MethodHandle GetDiskFreeSpaceExW$handle() {
        return GetDiskFreeSpaceExW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL GetDiskFreeSpaceExW(LPCWSTR lpDirectoryName, PULARGE_INTEGER lpFreeBytesAvailableToCaller, PULARGE_INTEGER lpTotalNumberOfBytes, PULARGE_INTEGER lpTotalNumberOfFreeBytes)
     * }
     */
    public static int GetDiskFreeSpaceExW(MemorySegment lpDirectoryName, MemorySegment lpFreeBytesAvailableToCaller, MemorySegment lpTotalNumberOfBytes, MemorySegment lpTotalNumberOfFreeBytes) {
        var mh$ = GetDiskFreeSpaceExW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetDiskFreeSpaceExW", lpDirectoryName, lpFreeBytesAvailableToCaller, lpTotalNumberOfBytes, lpTotalNumberOfFreeBytes);
            }
            return (int)mh$.invokeExact(lpDirectoryName, lpFreeBytesAvailableToCaller, lpTotalNumberOfBytes, lpTotalNumberOfFreeBytes);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetDiskSpaceInformationA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetDiskSpaceInformationA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HRESULT GetDiskSpaceInformationA(LPCSTR rootPath, DISK_SPACE_INFORMATION *diskSpaceInfo)
     * }
     */
    public static FunctionDescriptor GetDiskSpaceInformationA$descriptor() {
        return GetDiskSpaceInformationA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HRESULT GetDiskSpaceInformationA(LPCSTR rootPath, DISK_SPACE_INFORMATION *diskSpaceInfo)
     * }
     */
    public static MethodHandle GetDiskSpaceInformationA$handle() {
        return GetDiskSpaceInformationA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * HRESULT GetDiskSpaceInformationA(LPCSTR rootPath, DISK_SPACE_INFORMATION *diskSpaceInfo)
     * }
     */
    public static int GetDiskSpaceInformationA(MemorySegment rootPath, MemorySegment diskSpaceInfo) {
        var mh$ = GetDiskSpaceInformationA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetDiskSpaceInformationA", rootPath, diskSpaceInfo);
            }
            return (int)mh$.invokeExact(rootPath, diskSpaceInfo);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetDiskSpaceInformationW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetDiskSpaceInformationW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HRESULT GetDiskSpaceInformationW(LPCWSTR rootPath, DISK_SPACE_INFORMATION *diskSpaceInfo)
     * }
     */
    public static FunctionDescriptor GetDiskSpaceInformationW$descriptor() {
        return GetDiskSpaceInformationW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HRESULT GetDiskSpaceInformationW(LPCWSTR rootPath, DISK_SPACE_INFORMATION *diskSpaceInfo)
     * }
     */
    public static MethodHandle GetDiskSpaceInformationW$handle() {
        return GetDiskSpaceInformationW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * HRESULT GetDiskSpaceInformationW(LPCWSTR rootPath, DISK_SPACE_INFORMATION *diskSpaceInfo)
     * }
     */
    public static int GetDiskSpaceInformationW(MemorySegment rootPath, MemorySegment diskSpaceInfo) {
        var mh$ = GetDiskSpaceInformationW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetDiskSpaceInformationW", rootPath, diskSpaceInfo);
            }
            return (int)mh$.invokeExact(rootPath, diskSpaceInfo);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetDriveTypeA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetDriveTypeA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * UINT GetDriveTypeA(LPCSTR lpRootPathName)
     * }
     */
    public static FunctionDescriptor GetDriveTypeA$descriptor() {
        return GetDriveTypeA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * UINT GetDriveTypeA(LPCSTR lpRootPathName)
     * }
     */
    public static MethodHandle GetDriveTypeA$handle() {
        return GetDriveTypeA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * UINT GetDriveTypeA(LPCSTR lpRootPathName)
     * }
     */
    public static int GetDriveTypeA(MemorySegment lpRootPathName) {
        var mh$ = GetDriveTypeA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetDriveTypeA", lpRootPathName);
            }
            return (int)mh$.invokeExact(lpRootPathName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetDriveTypeW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetDriveTypeW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * UINT GetDriveTypeW(LPCWSTR lpRootPathName)
     * }
     */
    public static FunctionDescriptor GetDriveTypeW$descriptor() {
        return GetDriveTypeW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * UINT GetDriveTypeW(LPCWSTR lpRootPathName)
     * }
     */
    public static MethodHandle GetDriveTypeW$handle() {
        return GetDriveTypeW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * UINT GetDriveTypeW(LPCWSTR lpRootPathName)
     * }
     */
    public static int GetDriveTypeW(MemorySegment lpRootPathName) {
        var mh$ = GetDriveTypeW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetDriveTypeW", lpRootPathName);
            }
            return (int)mh$.invokeExact(lpRootPathName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct _WIN32_FILE_ATTRIBUTE_DATA {
     *     DWORD dwFileAttributes;
     *     FILETIME ftCreationTime;
     *     FILETIME ftLastAccessTime;
     *     FILETIME ftLastWriteTime;
     *     DWORD nFileSizeHigh;
     *     DWORD nFileSizeLow;
     * } *LPWIN32_FILE_ATTRIBUTE_DATA
     * }
     */
    public static final AddressLayout LPWIN32_FILE_ATTRIBUTE_DATA = C_POINTER;

    private static class GetFileAttributesA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetFileAttributesA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetFileAttributesA(LPCSTR lpFileName)
     * }
     */
    public static FunctionDescriptor GetFileAttributesA$descriptor() {
        return GetFileAttributesA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetFileAttributesA(LPCSTR lpFileName)
     * }
     */
    public static MethodHandle GetFileAttributesA$handle() {
        return GetFileAttributesA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * DWORD GetFileAttributesA(LPCSTR lpFileName)
     * }
     */
    public static int GetFileAttributesA(MemorySegment lpFileName) {
        var mh$ = GetFileAttributesA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetFileAttributesA", lpFileName);
            }
            return (int)mh$.invokeExact(lpFileName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetFileAttributesW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetFileAttributesW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetFileAttributesW(LPCWSTR lpFileName)
     * }
     */
    public static FunctionDescriptor GetFileAttributesW$descriptor() {
        return GetFileAttributesW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetFileAttributesW(LPCWSTR lpFileName)
     * }
     */
    public static MethodHandle GetFileAttributesW$handle() {
        return GetFileAttributesW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * DWORD GetFileAttributesW(LPCWSTR lpFileName)
     * }
     */
    public static int GetFileAttributesW(MemorySegment lpFileName) {
        var mh$ = GetFileAttributesW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetFileAttributesW", lpFileName);
            }
            return (int)mh$.invokeExact(lpFileName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetFileAttributesExA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetFileAttributesExA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetFileAttributesExA(LPCSTR lpFileName, GET_FILEEX_INFO_LEVELS fInfoLevelId, LPVOID lpFileInformation)
     * }
     */
    public static FunctionDescriptor GetFileAttributesExA$descriptor() {
        return GetFileAttributesExA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetFileAttributesExA(LPCSTR lpFileName, GET_FILEEX_INFO_LEVELS fInfoLevelId, LPVOID lpFileInformation)
     * }
     */
    public static MethodHandle GetFileAttributesExA$handle() {
        return GetFileAttributesExA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL GetFileAttributesExA(LPCSTR lpFileName, GET_FILEEX_INFO_LEVELS fInfoLevelId, LPVOID lpFileInformation)
     * }
     */
    public static int GetFileAttributesExA(MemorySegment lpFileName, int fInfoLevelId, MemorySegment lpFileInformation) {
        var mh$ = GetFileAttributesExA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetFileAttributesExA", lpFileName, fInfoLevelId, lpFileInformation);
            }
            return (int)mh$.invokeExact(lpFileName, fInfoLevelId, lpFileInformation);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetFileAttributesExW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetFileAttributesExW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetFileAttributesExW(LPCWSTR lpFileName, GET_FILEEX_INFO_LEVELS fInfoLevelId, LPVOID lpFileInformation)
     * }
     */
    public static FunctionDescriptor GetFileAttributesExW$descriptor() {
        return GetFileAttributesExW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetFileAttributesExW(LPCWSTR lpFileName, GET_FILEEX_INFO_LEVELS fInfoLevelId, LPVOID lpFileInformation)
     * }
     */
    public static MethodHandle GetFileAttributesExW$handle() {
        return GetFileAttributesExW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL GetFileAttributesExW(LPCWSTR lpFileName, GET_FILEEX_INFO_LEVELS fInfoLevelId, LPVOID lpFileInformation)
     * }
     */
    public static int GetFileAttributesExW(MemorySegment lpFileName, int fInfoLevelId, MemorySegment lpFileInformation) {
        var mh$ = GetFileAttributesExW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetFileAttributesExW", lpFileName, fInfoLevelId, lpFileInformation);
            }
            return (int)mh$.invokeExact(lpFileName, fInfoLevelId, lpFileInformation);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct _BY_HANDLE_FILE_INFORMATION {
     *     DWORD dwFileAttributes;
     *     FILETIME ftCreationTime;
     *     FILETIME ftLastAccessTime;
     *     FILETIME ftLastWriteTime;
     *     DWORD dwVolumeSerialNumber;
     *     DWORD nFileSizeHigh;
     *     DWORD nFileSizeLow;
     *     DWORD nNumberOfLinks;
     *     DWORD nFileIndexHigh;
     *     DWORD nFileIndexLow;
     * } *PBY_HANDLE_FILE_INFORMATION
     * }
     */
    public static final AddressLayout PBY_HANDLE_FILE_INFORMATION = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _BY_HANDLE_FILE_INFORMATION {
     *     DWORD dwFileAttributes;
     *     FILETIME ftCreationTime;
     *     FILETIME ftLastAccessTime;
     *     FILETIME ftLastWriteTime;
     *     DWORD dwVolumeSerialNumber;
     *     DWORD nFileSizeHigh;
     *     DWORD nFileSizeLow;
     *     DWORD nNumberOfLinks;
     *     DWORD nFileIndexHigh;
     *     DWORD nFileIndexLow;
     * } *LPBY_HANDLE_FILE_INFORMATION
     * }
     */
    public static final AddressLayout LPBY_HANDLE_FILE_INFORMATION = C_POINTER;

    private static class GetFileInformationByHandle {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetFileInformationByHandle"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetFileInformationByHandle(HANDLE hFile, LPBY_HANDLE_FILE_INFORMATION lpFileInformation)
     * }
     */
    public static FunctionDescriptor GetFileInformationByHandle$descriptor() {
        return GetFileInformationByHandle.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetFileInformationByHandle(HANDLE hFile, LPBY_HANDLE_FILE_INFORMATION lpFileInformation)
     * }
     */
    public static MethodHandle GetFileInformationByHandle$handle() {
        return GetFileInformationByHandle.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL GetFileInformationByHandle(HANDLE hFile, LPBY_HANDLE_FILE_INFORMATION lpFileInformation)
     * }
     */
    public static int GetFileInformationByHandle(MemorySegment hFile, MemorySegment lpFileInformation) {
        var mh$ = GetFileInformationByHandle.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetFileInformationByHandle", hFile, lpFileInformation);
            }
            return (int)mh$.invokeExact(hFile, lpFileInformation);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetFileSize {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetFileSize"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetFileSize(HANDLE hFile, LPDWORD lpFileSizeHigh)
     * }
     */
    public static FunctionDescriptor GetFileSize$descriptor() {
        return GetFileSize.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetFileSize(HANDLE hFile, LPDWORD lpFileSizeHigh)
     * }
     */
    public static MethodHandle GetFileSize$handle() {
        return GetFileSize.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * DWORD GetFileSize(HANDLE hFile, LPDWORD lpFileSizeHigh)
     * }
     */
    public static int GetFileSize(MemorySegment hFile, MemorySegment lpFileSizeHigh) {
        var mh$ = GetFileSize.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetFileSize", hFile, lpFileSizeHigh);
            }
            return (int)mh$.invokeExact(hFile, lpFileSizeHigh);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetFileSizeEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetFileSizeEx"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetFileSizeEx(HANDLE hFile, PLARGE_INTEGER lpFileSize)
     * }
     */
    public static FunctionDescriptor GetFileSizeEx$descriptor() {
        return GetFileSizeEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetFileSizeEx(HANDLE hFile, PLARGE_INTEGER lpFileSize)
     * }
     */
    public static MethodHandle GetFileSizeEx$handle() {
        return GetFileSizeEx.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL GetFileSizeEx(HANDLE hFile, PLARGE_INTEGER lpFileSize)
     * }
     */
    public static int GetFileSizeEx(MemorySegment hFile, MemorySegment lpFileSize) {
        var mh$ = GetFileSizeEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetFileSizeEx", hFile, lpFileSize);
            }
            return (int)mh$.invokeExact(hFile, lpFileSize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetFileType {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetFileType"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetFileType(HANDLE hFile)
     * }
     */
    public static FunctionDescriptor GetFileType$descriptor() {
        return GetFileType.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetFileType(HANDLE hFile)
     * }
     */
    public static MethodHandle GetFileType$handle() {
        return GetFileType.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * DWORD GetFileType(HANDLE hFile)
     * }
     */
    public static int GetFileType(MemorySegment hFile) {
        var mh$ = GetFileType.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetFileType", hFile);
            }
            return (int)mh$.invokeExact(hFile);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetFinalPathNameByHandleA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_POINTER,
            C_POINTER,
            C_LONG,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetFinalPathNameByHandleA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetFinalPathNameByHandleA(HANDLE hFile, LPSTR lpszFilePath, DWORD cchFilePath, DWORD dwFlags)
     * }
     */
    public static FunctionDescriptor GetFinalPathNameByHandleA$descriptor() {
        return GetFinalPathNameByHandleA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetFinalPathNameByHandleA(HANDLE hFile, LPSTR lpszFilePath, DWORD cchFilePath, DWORD dwFlags)
     * }
     */
    public static MethodHandle GetFinalPathNameByHandleA$handle() {
        return GetFinalPathNameByHandleA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * DWORD GetFinalPathNameByHandleA(HANDLE hFile, LPSTR lpszFilePath, DWORD cchFilePath, DWORD dwFlags)
     * }
     */
    public static int GetFinalPathNameByHandleA(MemorySegment hFile, MemorySegment lpszFilePath, int cchFilePath, int dwFlags) {
        var mh$ = GetFinalPathNameByHandleA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetFinalPathNameByHandleA", hFile, lpszFilePath, cchFilePath, dwFlags);
            }
            return (int)mh$.invokeExact(hFile, lpszFilePath, cchFilePath, dwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetFinalPathNameByHandleW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_POINTER,
            C_POINTER,
            C_LONG,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetFinalPathNameByHandleW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetFinalPathNameByHandleW(HANDLE hFile, LPWSTR lpszFilePath, DWORD cchFilePath, DWORD dwFlags)
     * }
     */
    public static FunctionDescriptor GetFinalPathNameByHandleW$descriptor() {
        return GetFinalPathNameByHandleW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetFinalPathNameByHandleW(HANDLE hFile, LPWSTR lpszFilePath, DWORD cchFilePath, DWORD dwFlags)
     * }
     */
    public static MethodHandle GetFinalPathNameByHandleW$handle() {
        return GetFinalPathNameByHandleW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * DWORD GetFinalPathNameByHandleW(HANDLE hFile, LPWSTR lpszFilePath, DWORD cchFilePath, DWORD dwFlags)
     * }
     */
    public static int GetFinalPathNameByHandleW(MemorySegment hFile, MemorySegment lpszFilePath, int cchFilePath, int dwFlags) {
        var mh$ = GetFinalPathNameByHandleW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetFinalPathNameByHandleW", hFile, lpszFilePath, cchFilePath, dwFlags);
            }
            return (int)mh$.invokeExact(hFile, lpszFilePath, cchFilePath, dwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetFileTime {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetFileTime"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetFileTime(HANDLE hFile, LPFILETIME lpCreationTime, LPFILETIME lpLastAccessTime, LPFILETIME lpLastWriteTime)
     * }
     */
    public static FunctionDescriptor GetFileTime$descriptor() {
        return GetFileTime.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetFileTime(HANDLE hFile, LPFILETIME lpCreationTime, LPFILETIME lpLastAccessTime, LPFILETIME lpLastWriteTime)
     * }
     */
    public static MethodHandle GetFileTime$handle() {
        return GetFileTime.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL GetFileTime(HANDLE hFile, LPFILETIME lpCreationTime, LPFILETIME lpLastAccessTime, LPFILETIME lpLastWriteTime)
     * }
     */
    public static int GetFileTime(MemorySegment hFile, MemorySegment lpCreationTime, MemorySegment lpLastAccessTime, MemorySegment lpLastWriteTime) {
        var mh$ = GetFileTime.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetFileTime", hFile, lpCreationTime, lpLastAccessTime, lpLastWriteTime);
            }
            return (int)mh$.invokeExact(hFile, lpCreationTime, lpLastAccessTime, lpLastWriteTime);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetFullPathNameW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_POINTER,
            C_LONG,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetFullPathNameW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetFullPathNameW(LPCWSTR lpFileName, DWORD nBufferLength, LPWSTR lpBuffer, LPWSTR *lpFilePart)
     * }
     */
    public static FunctionDescriptor GetFullPathNameW$descriptor() {
        return GetFullPathNameW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetFullPathNameW(LPCWSTR lpFileName, DWORD nBufferLength, LPWSTR lpBuffer, LPWSTR *lpFilePart)
     * }
     */
    public static MethodHandle GetFullPathNameW$handle() {
        return GetFullPathNameW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * DWORD GetFullPathNameW(LPCWSTR lpFileName, DWORD nBufferLength, LPWSTR lpBuffer, LPWSTR *lpFilePart)
     * }
     */
    public static int GetFullPathNameW(MemorySegment lpFileName, int nBufferLength, MemorySegment lpBuffer, MemorySegment lpFilePart) {
        var mh$ = GetFullPathNameW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetFullPathNameW", lpFileName, nBufferLength, lpBuffer, lpFilePart);
            }
            return (int)mh$.invokeExact(lpFileName, nBufferLength, lpBuffer, lpFilePart);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetFullPathNameA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_POINTER,
            C_LONG,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetFullPathNameA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetFullPathNameA(LPCSTR lpFileName, DWORD nBufferLength, LPSTR lpBuffer, LPSTR *lpFilePart)
     * }
     */
    public static FunctionDescriptor GetFullPathNameA$descriptor() {
        return GetFullPathNameA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetFullPathNameA(LPCSTR lpFileName, DWORD nBufferLength, LPSTR lpBuffer, LPSTR *lpFilePart)
     * }
     */
    public static MethodHandle GetFullPathNameA$handle() {
        return GetFullPathNameA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * DWORD GetFullPathNameA(LPCSTR lpFileName, DWORD nBufferLength, LPSTR lpBuffer, LPSTR *lpFilePart)
     * }
     */
    public static int GetFullPathNameA(MemorySegment lpFileName, int nBufferLength, MemorySegment lpBuffer, MemorySegment lpFilePart) {
        var mh$ = GetFullPathNameA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetFullPathNameA", lpFileName, nBufferLength, lpBuffer, lpFilePart);
            }
            return (int)mh$.invokeExact(lpFileName, nBufferLength, lpBuffer, lpFilePart);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetLogicalDrives {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG    );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetLogicalDrives"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetLogicalDrives()
     * }
     */
    public static FunctionDescriptor GetLogicalDrives$descriptor() {
        return GetLogicalDrives.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetLogicalDrives()
     * }
     */
    public static MethodHandle GetLogicalDrives$handle() {
        return GetLogicalDrives.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * DWORD GetLogicalDrives()
     * }
     */
    public static int GetLogicalDrives() {
        var mh$ = GetLogicalDrives.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetLogicalDrives");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetLogicalDriveStringsW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_LONG,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetLogicalDriveStringsW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetLogicalDriveStringsW(DWORD nBufferLength, LPWSTR lpBuffer)
     * }
     */
    public static FunctionDescriptor GetLogicalDriveStringsW$descriptor() {
        return GetLogicalDriveStringsW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetLogicalDriveStringsW(DWORD nBufferLength, LPWSTR lpBuffer)
     * }
     */
    public static MethodHandle GetLogicalDriveStringsW$handle() {
        return GetLogicalDriveStringsW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * DWORD GetLogicalDriveStringsW(DWORD nBufferLength, LPWSTR lpBuffer)
     * }
     */
    public static int GetLogicalDriveStringsW(int nBufferLength, MemorySegment lpBuffer) {
        var mh$ = GetLogicalDriveStringsW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetLogicalDriveStringsW", nBufferLength, lpBuffer);
            }
            return (int)mh$.invokeExact(nBufferLength, lpBuffer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetLongPathNameA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_POINTER,
            C_POINTER,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetLongPathNameA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetLongPathNameA(LPCSTR lpszShortPath, LPSTR lpszLongPath, DWORD cchBuffer)
     * }
     */
    public static FunctionDescriptor GetLongPathNameA$descriptor() {
        return GetLongPathNameA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetLongPathNameA(LPCSTR lpszShortPath, LPSTR lpszLongPath, DWORD cchBuffer)
     * }
     */
    public static MethodHandle GetLongPathNameA$handle() {
        return GetLongPathNameA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * DWORD GetLongPathNameA(LPCSTR lpszShortPath, LPSTR lpszLongPath, DWORD cchBuffer)
     * }
     */
    public static int GetLongPathNameA(MemorySegment lpszShortPath, MemorySegment lpszLongPath, int cchBuffer) {
        var mh$ = GetLongPathNameA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetLongPathNameA", lpszShortPath, lpszLongPath, cchBuffer);
            }
            return (int)mh$.invokeExact(lpszShortPath, lpszLongPath, cchBuffer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetLongPathNameW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_POINTER,
            C_POINTER,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetLongPathNameW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetLongPathNameW(LPCWSTR lpszShortPath, LPWSTR lpszLongPath, DWORD cchBuffer)
     * }
     */
    public static FunctionDescriptor GetLongPathNameW$descriptor() {
        return GetLongPathNameW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetLongPathNameW(LPCWSTR lpszShortPath, LPWSTR lpszLongPath, DWORD cchBuffer)
     * }
     */
    public static MethodHandle GetLongPathNameW$handle() {
        return GetLongPathNameW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * DWORD GetLongPathNameW(LPCWSTR lpszShortPath, LPWSTR lpszLongPath, DWORD cchBuffer)
     * }
     */
    public static int GetLongPathNameW(MemorySegment lpszShortPath, MemorySegment lpszLongPath, int cchBuffer) {
        var mh$ = GetLongPathNameW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetLongPathNameW", lpszShortPath, lpszLongPath, cchBuffer);
            }
            return (int)mh$.invokeExact(lpszShortPath, lpszLongPath, cchBuffer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class AreShortNamesEnabled {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("AreShortNamesEnabled"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL AreShortNamesEnabled(HANDLE Handle, BOOL *Enabled)
     * }
     */
    public static FunctionDescriptor AreShortNamesEnabled$descriptor() {
        return AreShortNamesEnabled.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL AreShortNamesEnabled(HANDLE Handle, BOOL *Enabled)
     * }
     */
    public static MethodHandle AreShortNamesEnabled$handle() {
        return AreShortNamesEnabled.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL AreShortNamesEnabled(HANDLE Handle, BOOL *Enabled)
     * }
     */
    public static int AreShortNamesEnabled(MemorySegment Handle, MemorySegment Enabled) {
        var mh$ = AreShortNamesEnabled.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("AreShortNamesEnabled", Handle, Enabled);
            }
            return (int)mh$.invokeExact(Handle, Enabled);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetShortPathNameW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_POINTER,
            C_POINTER,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetShortPathNameW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetShortPathNameW(LPCWSTR lpszLongPath, LPWSTR lpszShortPath, DWORD cchBuffer)
     * }
     */
    public static FunctionDescriptor GetShortPathNameW$descriptor() {
        return GetShortPathNameW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetShortPathNameW(LPCWSTR lpszLongPath, LPWSTR lpszShortPath, DWORD cchBuffer)
     * }
     */
    public static MethodHandle GetShortPathNameW$handle() {
        return GetShortPathNameW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * DWORD GetShortPathNameW(LPCWSTR lpszLongPath, LPWSTR lpszShortPath, DWORD cchBuffer)
     * }
     */
    public static int GetShortPathNameW(MemorySegment lpszLongPath, MemorySegment lpszShortPath, int cchBuffer) {
        var mh$ = GetShortPathNameW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetShortPathNameW", lpszLongPath, lpszShortPath, cchBuffer);
            }
            return (int)mh$.invokeExact(lpszLongPath, lpszShortPath, cchBuffer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetTempFileNameW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetTempFileNameW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * UINT GetTempFileNameW(LPCWSTR lpPathName, LPCWSTR lpPrefixString, UINT uUnique, LPWSTR lpTempFileName)
     * }
     */
    public static FunctionDescriptor GetTempFileNameW$descriptor() {
        return GetTempFileNameW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * UINT GetTempFileNameW(LPCWSTR lpPathName, LPCWSTR lpPrefixString, UINT uUnique, LPWSTR lpTempFileName)
     * }
     */
    public static MethodHandle GetTempFileNameW$handle() {
        return GetTempFileNameW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * UINT GetTempFileNameW(LPCWSTR lpPathName, LPCWSTR lpPrefixString, UINT uUnique, LPWSTR lpTempFileName)
     * }
     */
    public static int GetTempFileNameW(MemorySegment lpPathName, MemorySegment lpPrefixString, int uUnique, MemorySegment lpTempFileName) {
        var mh$ = GetTempFileNameW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetTempFileNameW", lpPathName, lpPrefixString, uUnique, lpTempFileName);
            }
            return (int)mh$.invokeExact(lpPathName, lpPrefixString, uUnique, lpTempFileName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetVolumeInformationByHandleW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_LONG,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetVolumeInformationByHandleW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetVolumeInformationByHandleW(HANDLE hFile, LPWSTR lpVolumeNameBuffer, DWORD nVolumeNameSize, LPDWORD lpVolumeSerialNumber, LPDWORD lpMaximumComponentLength, LPDWORD lpFileSystemFlags, LPWSTR lpFileSystemNameBuffer, DWORD nFileSystemNameSize)
     * }
     */
    public static FunctionDescriptor GetVolumeInformationByHandleW$descriptor() {
        return GetVolumeInformationByHandleW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetVolumeInformationByHandleW(HANDLE hFile, LPWSTR lpVolumeNameBuffer, DWORD nVolumeNameSize, LPDWORD lpVolumeSerialNumber, LPDWORD lpMaximumComponentLength, LPDWORD lpFileSystemFlags, LPWSTR lpFileSystemNameBuffer, DWORD nFileSystemNameSize)
     * }
     */
    public static MethodHandle GetVolumeInformationByHandleW$handle() {
        return GetVolumeInformationByHandleW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL GetVolumeInformationByHandleW(HANDLE hFile, LPWSTR lpVolumeNameBuffer, DWORD nVolumeNameSize, LPDWORD lpVolumeSerialNumber, LPDWORD lpMaximumComponentLength, LPDWORD lpFileSystemFlags, LPWSTR lpFileSystemNameBuffer, DWORD nFileSystemNameSize)
     * }
     */
    public static int GetVolumeInformationByHandleW(MemorySegment hFile, MemorySegment lpVolumeNameBuffer, int nVolumeNameSize, MemorySegment lpVolumeSerialNumber, MemorySegment lpMaximumComponentLength, MemorySegment lpFileSystemFlags, MemorySegment lpFileSystemNameBuffer, int nFileSystemNameSize) {
        var mh$ = GetVolumeInformationByHandleW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetVolumeInformationByHandleW", hFile, lpVolumeNameBuffer, nVolumeNameSize, lpVolumeSerialNumber, lpMaximumComponentLength, lpFileSystemFlags, lpFileSystemNameBuffer, nFileSystemNameSize);
            }
            return (int)mh$.invokeExact(hFile, lpVolumeNameBuffer, nVolumeNameSize, lpVolumeSerialNumber, lpMaximumComponentLength, lpFileSystemFlags, lpFileSystemNameBuffer, nFileSystemNameSize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetVolumeInformationW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_LONG,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetVolumeInformationW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetVolumeInformationW(LPCWSTR lpRootPathName, LPWSTR lpVolumeNameBuffer, DWORD nVolumeNameSize, LPDWORD lpVolumeSerialNumber, LPDWORD lpMaximumComponentLength, LPDWORD lpFileSystemFlags, LPWSTR lpFileSystemNameBuffer, DWORD nFileSystemNameSize)
     * }
     */
    public static FunctionDescriptor GetVolumeInformationW$descriptor() {
        return GetVolumeInformationW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetVolumeInformationW(LPCWSTR lpRootPathName, LPWSTR lpVolumeNameBuffer, DWORD nVolumeNameSize, LPDWORD lpVolumeSerialNumber, LPDWORD lpMaximumComponentLength, LPDWORD lpFileSystemFlags, LPWSTR lpFileSystemNameBuffer, DWORD nFileSystemNameSize)
     * }
     */
    public static MethodHandle GetVolumeInformationW$handle() {
        return GetVolumeInformationW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL GetVolumeInformationW(LPCWSTR lpRootPathName, LPWSTR lpVolumeNameBuffer, DWORD nVolumeNameSize, LPDWORD lpVolumeSerialNumber, LPDWORD lpMaximumComponentLength, LPDWORD lpFileSystemFlags, LPWSTR lpFileSystemNameBuffer, DWORD nFileSystemNameSize)
     * }
     */
    public static int GetVolumeInformationW(MemorySegment lpRootPathName, MemorySegment lpVolumeNameBuffer, int nVolumeNameSize, MemorySegment lpVolumeSerialNumber, MemorySegment lpMaximumComponentLength, MemorySegment lpFileSystemFlags, MemorySegment lpFileSystemNameBuffer, int nFileSystemNameSize) {
        var mh$ = GetVolumeInformationW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetVolumeInformationW", lpRootPathName, lpVolumeNameBuffer, nVolumeNameSize, lpVolumeSerialNumber, lpMaximumComponentLength, lpFileSystemFlags, lpFileSystemNameBuffer, nFileSystemNameSize);
            }
            return (int)mh$.invokeExact(lpRootPathName, lpVolumeNameBuffer, nVolumeNameSize, lpVolumeSerialNumber, lpMaximumComponentLength, lpFileSystemFlags, lpFileSystemNameBuffer, nFileSystemNameSize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetVolumePathNameW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetVolumePathNameW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetVolumePathNameW(LPCWSTR lpszFileName, LPWSTR lpszVolumePathName, DWORD cchBufferLength)
     * }
     */
    public static FunctionDescriptor GetVolumePathNameW$descriptor() {
        return GetVolumePathNameW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetVolumePathNameW(LPCWSTR lpszFileName, LPWSTR lpszVolumePathName, DWORD cchBufferLength)
     * }
     */
    public static MethodHandle GetVolumePathNameW$handle() {
        return GetVolumePathNameW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL GetVolumePathNameW(LPCWSTR lpszFileName, LPWSTR lpszVolumePathName, DWORD cchBufferLength)
     * }
     */
    public static int GetVolumePathNameW(MemorySegment lpszFileName, MemorySegment lpszVolumePathName, int cchBufferLength) {
        var mh$ = GetVolumePathNameW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetVolumePathNameW", lpszFileName, lpszVolumePathName, cchBufferLength);
            }
            return (int)mh$.invokeExact(lpszFileName, lpszVolumePathName, cchBufferLength);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LocalFileTimeToFileTime {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("LocalFileTimeToFileTime"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL LocalFileTimeToFileTime(const FILETIME *lpLocalFileTime, LPFILETIME lpFileTime)
     * }
     */
    public static FunctionDescriptor LocalFileTimeToFileTime$descriptor() {
        return LocalFileTimeToFileTime.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL LocalFileTimeToFileTime(const FILETIME *lpLocalFileTime, LPFILETIME lpFileTime)
     * }
     */
    public static MethodHandle LocalFileTimeToFileTime$handle() {
        return LocalFileTimeToFileTime.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL LocalFileTimeToFileTime(const FILETIME *lpLocalFileTime, LPFILETIME lpFileTime)
     * }
     */
    public static int LocalFileTimeToFileTime(MemorySegment lpLocalFileTime, MemorySegment lpFileTime) {
        var mh$ = LocalFileTimeToFileTime.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LocalFileTimeToFileTime", lpLocalFileTime, lpFileTime);
            }
            return (int)mh$.invokeExact(lpLocalFileTime, lpFileTime);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LockFile {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_LONG,
            C_LONG,
            C_LONG,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("LockFile"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL LockFile(HANDLE hFile, DWORD dwFileOffsetLow, DWORD dwFileOffsetHigh, DWORD nNumberOfBytesToLockLow, DWORD nNumberOfBytesToLockHigh)
     * }
     */
    public static FunctionDescriptor LockFile$descriptor() {
        return LockFile.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL LockFile(HANDLE hFile, DWORD dwFileOffsetLow, DWORD dwFileOffsetHigh, DWORD nNumberOfBytesToLockLow, DWORD nNumberOfBytesToLockHigh)
     * }
     */
    public static MethodHandle LockFile$handle() {
        return LockFile.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL LockFile(HANDLE hFile, DWORD dwFileOffsetLow, DWORD dwFileOffsetHigh, DWORD nNumberOfBytesToLockLow, DWORD nNumberOfBytesToLockHigh)
     * }
     */
    public static int LockFile(MemorySegment hFile, int dwFileOffsetLow, int dwFileOffsetHigh, int nNumberOfBytesToLockLow, int nNumberOfBytesToLockHigh) {
        var mh$ = LockFile.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LockFile", hFile, dwFileOffsetLow, dwFileOffsetHigh, nNumberOfBytesToLockLow, nNumberOfBytesToLockHigh);
            }
            return (int)mh$.invokeExact(hFile, dwFileOffsetLow, dwFileOffsetHigh, nNumberOfBytesToLockLow, nNumberOfBytesToLockHigh);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LockFileEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_LONG,
            C_LONG,
            C_LONG,
            C_LONG,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("LockFileEx"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL LockFileEx(HANDLE hFile, DWORD dwFlags, DWORD dwReserved, DWORD nNumberOfBytesToLockLow, DWORD nNumberOfBytesToLockHigh, LPOVERLAPPED lpOverlapped)
     * }
     */
    public static FunctionDescriptor LockFileEx$descriptor() {
        return LockFileEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL LockFileEx(HANDLE hFile, DWORD dwFlags, DWORD dwReserved, DWORD nNumberOfBytesToLockLow, DWORD nNumberOfBytesToLockHigh, LPOVERLAPPED lpOverlapped)
     * }
     */
    public static MethodHandle LockFileEx$handle() {
        return LockFileEx.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL LockFileEx(HANDLE hFile, DWORD dwFlags, DWORD dwReserved, DWORD nNumberOfBytesToLockLow, DWORD nNumberOfBytesToLockHigh, LPOVERLAPPED lpOverlapped)
     * }
     */
    public static int LockFileEx(MemorySegment hFile, int dwFlags, int dwReserved, int nNumberOfBytesToLockLow, int nNumberOfBytesToLockHigh, MemorySegment lpOverlapped) {
        var mh$ = LockFileEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LockFileEx", hFile, dwFlags, dwReserved, nNumberOfBytesToLockLow, nNumberOfBytesToLockHigh, lpOverlapped);
            }
            return (int)mh$.invokeExact(hFile, dwFlags, dwReserved, nNumberOfBytesToLockLow, nNumberOfBytesToLockHigh, lpOverlapped);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class QueryDosDeviceW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_POINTER,
            C_POINTER,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("QueryDosDeviceW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD QueryDosDeviceW(LPCWSTR lpDeviceName, LPWSTR lpTargetPath, DWORD ucchMax)
     * }
     */
    public static FunctionDescriptor QueryDosDeviceW$descriptor() {
        return QueryDosDeviceW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD QueryDosDeviceW(LPCWSTR lpDeviceName, LPWSTR lpTargetPath, DWORD ucchMax)
     * }
     */
    public static MethodHandle QueryDosDeviceW$handle() {
        return QueryDosDeviceW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * DWORD QueryDosDeviceW(LPCWSTR lpDeviceName, LPWSTR lpTargetPath, DWORD ucchMax)
     * }
     */
    public static int QueryDosDeviceW(MemorySegment lpDeviceName, MemorySegment lpTargetPath, int ucchMax) {
        var mh$ = QueryDosDeviceW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("QueryDosDeviceW", lpDeviceName, lpTargetPath, ucchMax);
            }
            return (int)mh$.invokeExact(lpDeviceName, lpTargetPath, ucchMax);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ReadFile {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_LONG,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("ReadFile"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL ReadFile(HANDLE hFile, LPVOID lpBuffer, DWORD nNumberOfBytesToRead, LPDWORD lpNumberOfBytesRead, LPOVERLAPPED lpOverlapped)
     * }
     */
    public static FunctionDescriptor ReadFile$descriptor() {
        return ReadFile.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL ReadFile(HANDLE hFile, LPVOID lpBuffer, DWORD nNumberOfBytesToRead, LPDWORD lpNumberOfBytesRead, LPOVERLAPPED lpOverlapped)
     * }
     */
    public static MethodHandle ReadFile$handle() {
        return ReadFile.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL ReadFile(HANDLE hFile, LPVOID lpBuffer, DWORD nNumberOfBytesToRead, LPDWORD lpNumberOfBytesRead, LPOVERLAPPED lpOverlapped)
     * }
     */
    public static int ReadFile(MemorySegment hFile, MemorySegment lpBuffer, int nNumberOfBytesToRead, MemorySegment lpNumberOfBytesRead, MemorySegment lpOverlapped) {
        var mh$ = ReadFile.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ReadFile", hFile, lpBuffer, nNumberOfBytesToRead, lpNumberOfBytesRead, lpOverlapped);
            }
            return (int)mh$.invokeExact(hFile, lpBuffer, nNumberOfBytesToRead, lpNumberOfBytesRead, lpOverlapped);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ReadFileEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_LONG,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("ReadFileEx"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL ReadFileEx(HANDLE hFile, LPVOID lpBuffer, DWORD nNumberOfBytesToRead, LPOVERLAPPED lpOverlapped, LPOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine)
     * }
     */
    public static FunctionDescriptor ReadFileEx$descriptor() {
        return ReadFileEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL ReadFileEx(HANDLE hFile, LPVOID lpBuffer, DWORD nNumberOfBytesToRead, LPOVERLAPPED lpOverlapped, LPOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine)
     * }
     */
    public static MethodHandle ReadFileEx$handle() {
        return ReadFileEx.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL ReadFileEx(HANDLE hFile, LPVOID lpBuffer, DWORD nNumberOfBytesToRead, LPOVERLAPPED lpOverlapped, LPOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine)
     * }
     */
    public static int ReadFileEx(MemorySegment hFile, MemorySegment lpBuffer, int nNumberOfBytesToRead, MemorySegment lpOverlapped, MemorySegment lpCompletionRoutine) {
        var mh$ = ReadFileEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ReadFileEx", hFile, lpBuffer, nNumberOfBytesToRead, lpOverlapped, lpCompletionRoutine);
            }
            return (int)mh$.invokeExact(hFile, lpBuffer, nNumberOfBytesToRead, lpOverlapped, lpCompletionRoutine);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ReadFileScatter {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_LONG,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("ReadFileScatter"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL ReadFileScatter(HANDLE hFile, FILE_SEGMENT_ELEMENT aSegmentArray[], DWORD nNumberOfBytesToRead, LPDWORD lpReserved, LPOVERLAPPED lpOverlapped)
     * }
     */
    public static FunctionDescriptor ReadFileScatter$descriptor() {
        return ReadFileScatter.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL ReadFileScatter(HANDLE hFile, FILE_SEGMENT_ELEMENT aSegmentArray[], DWORD nNumberOfBytesToRead, LPDWORD lpReserved, LPOVERLAPPED lpOverlapped)
     * }
     */
    public static MethodHandle ReadFileScatter$handle() {
        return ReadFileScatter.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL ReadFileScatter(HANDLE hFile, FILE_SEGMENT_ELEMENT aSegmentArray[], DWORD nNumberOfBytesToRead, LPDWORD lpReserved, LPOVERLAPPED lpOverlapped)
     * }
     */
    public static int ReadFileScatter(MemorySegment hFile, MemorySegment aSegmentArray, int nNumberOfBytesToRead, MemorySegment lpReserved, MemorySegment lpOverlapped) {
        var mh$ = ReadFileScatter.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ReadFileScatter", hFile, aSegmentArray, nNumberOfBytesToRead, lpReserved, lpOverlapped);
            }
            return (int)mh$.invokeExact(hFile, aSegmentArray, nNumberOfBytesToRead, lpReserved, lpOverlapped);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RemoveDirectoryA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("RemoveDirectoryA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL RemoveDirectoryA(LPCSTR lpPathName)
     * }
     */
    public static FunctionDescriptor RemoveDirectoryA$descriptor() {
        return RemoveDirectoryA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL RemoveDirectoryA(LPCSTR lpPathName)
     * }
     */
    public static MethodHandle RemoveDirectoryA$handle() {
        return RemoveDirectoryA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL RemoveDirectoryA(LPCSTR lpPathName)
     * }
     */
    public static int RemoveDirectoryA(MemorySegment lpPathName) {
        var mh$ = RemoveDirectoryA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RemoveDirectoryA", lpPathName);
            }
            return (int)mh$.invokeExact(lpPathName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RemoveDirectoryW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("RemoveDirectoryW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL RemoveDirectoryW(LPCWSTR lpPathName)
     * }
     */
    public static FunctionDescriptor RemoveDirectoryW$descriptor() {
        return RemoveDirectoryW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL RemoveDirectoryW(LPCWSTR lpPathName)
     * }
     */
    public static MethodHandle RemoveDirectoryW$handle() {
        return RemoveDirectoryW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL RemoveDirectoryW(LPCWSTR lpPathName)
     * }
     */
    public static int RemoveDirectoryW(MemorySegment lpPathName) {
        var mh$ = RemoveDirectoryW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RemoveDirectoryW", lpPathName);
            }
            return (int)mh$.invokeExact(lpPathName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetEndOfFile {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("SetEndOfFile"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetEndOfFile(HANDLE hFile)
     * }
     */
    public static FunctionDescriptor SetEndOfFile$descriptor() {
        return SetEndOfFile.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetEndOfFile(HANDLE hFile)
     * }
     */
    public static MethodHandle SetEndOfFile$handle() {
        return SetEndOfFile.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL SetEndOfFile(HANDLE hFile)
     * }
     */
    public static int SetEndOfFile(MemorySegment hFile) {
        var mh$ = SetEndOfFile.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetEndOfFile", hFile);
            }
            return (int)mh$.invokeExact(hFile);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetFileAttributesA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("SetFileAttributesA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetFileAttributesA(LPCSTR lpFileName, DWORD dwFileAttributes)
     * }
     */
    public static FunctionDescriptor SetFileAttributesA$descriptor() {
        return SetFileAttributesA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetFileAttributesA(LPCSTR lpFileName, DWORD dwFileAttributes)
     * }
     */
    public static MethodHandle SetFileAttributesA$handle() {
        return SetFileAttributesA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL SetFileAttributesA(LPCSTR lpFileName, DWORD dwFileAttributes)
     * }
     */
    public static int SetFileAttributesA(MemorySegment lpFileName, int dwFileAttributes) {
        var mh$ = SetFileAttributesA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetFileAttributesA", lpFileName, dwFileAttributes);
            }
            return (int)mh$.invokeExact(lpFileName, dwFileAttributes);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetFileAttributesW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("SetFileAttributesW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetFileAttributesW(LPCWSTR lpFileName, DWORD dwFileAttributes)
     * }
     */
    public static FunctionDescriptor SetFileAttributesW$descriptor() {
        return SetFileAttributesW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetFileAttributesW(LPCWSTR lpFileName, DWORD dwFileAttributes)
     * }
     */
    public static MethodHandle SetFileAttributesW$handle() {
        return SetFileAttributesW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL SetFileAttributesW(LPCWSTR lpFileName, DWORD dwFileAttributes)
     * }
     */
    public static int SetFileAttributesW(MemorySegment lpFileName, int dwFileAttributes) {
        var mh$ = SetFileAttributesW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetFileAttributesW", lpFileName, dwFileAttributes);
            }
            return (int)mh$.invokeExact(lpFileName, dwFileAttributes);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetFileInformationByHandle {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_INT,
            C_POINTER,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("SetFileInformationByHandle"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetFileInformationByHandle(HANDLE hFile, FILE_INFO_BY_HANDLE_CLASS FileInformationClass, LPVOID lpFileInformation, DWORD dwBufferSize)
     * }
     */
    public static FunctionDescriptor SetFileInformationByHandle$descriptor() {
        return SetFileInformationByHandle.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetFileInformationByHandle(HANDLE hFile, FILE_INFO_BY_HANDLE_CLASS FileInformationClass, LPVOID lpFileInformation, DWORD dwBufferSize)
     * }
     */
    public static MethodHandle SetFileInformationByHandle$handle() {
        return SetFileInformationByHandle.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL SetFileInformationByHandle(HANDLE hFile, FILE_INFO_BY_HANDLE_CLASS FileInformationClass, LPVOID lpFileInformation, DWORD dwBufferSize)
     * }
     */
    public static int SetFileInformationByHandle(MemorySegment hFile, int FileInformationClass, MemorySegment lpFileInformation, int dwBufferSize) {
        var mh$ = SetFileInformationByHandle.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetFileInformationByHandle", hFile, FileInformationClass, lpFileInformation, dwBufferSize);
            }
            return (int)mh$.invokeExact(hFile, FileInformationClass, lpFileInformation, dwBufferSize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetFilePointer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_POINTER,
            C_LONG,
            C_POINTER,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("SetFilePointer"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD SetFilePointer(HANDLE hFile, LONG lDistanceToMove, PLONG lpDistanceToMoveHigh, DWORD dwMoveMethod)
     * }
     */
    public static FunctionDescriptor SetFilePointer$descriptor() {
        return SetFilePointer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD SetFilePointer(HANDLE hFile, LONG lDistanceToMove, PLONG lpDistanceToMoveHigh, DWORD dwMoveMethod)
     * }
     */
    public static MethodHandle SetFilePointer$handle() {
        return SetFilePointer.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * DWORD SetFilePointer(HANDLE hFile, LONG lDistanceToMove, PLONG lpDistanceToMoveHigh, DWORD dwMoveMethod)
     * }
     */
    public static int SetFilePointer(MemorySegment hFile, int lDistanceToMove, MemorySegment lpDistanceToMoveHigh, int dwMoveMethod) {
        var mh$ = SetFilePointer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetFilePointer", hFile, lDistanceToMove, lpDistanceToMoveHigh, dwMoveMethod);
            }
            return (int)mh$.invokeExact(hFile, lDistanceToMove, lpDistanceToMoveHigh, dwMoveMethod);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetFilePointerEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            _LARGE_INTEGER.layout(),
            C_POINTER,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("SetFilePointerEx"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetFilePointerEx(HANDLE hFile, LARGE_INTEGER liDistanceToMove, PLARGE_INTEGER lpNewFilePointer, DWORD dwMoveMethod)
     * }
     */
    public static FunctionDescriptor SetFilePointerEx$descriptor() {
        return SetFilePointerEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetFilePointerEx(HANDLE hFile, LARGE_INTEGER liDistanceToMove, PLARGE_INTEGER lpNewFilePointer, DWORD dwMoveMethod)
     * }
     */
    public static MethodHandle SetFilePointerEx$handle() {
        return SetFilePointerEx.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL SetFilePointerEx(HANDLE hFile, LARGE_INTEGER liDistanceToMove, PLARGE_INTEGER lpNewFilePointer, DWORD dwMoveMethod)
     * }
     */
    public static int SetFilePointerEx(MemorySegment hFile, MemorySegment liDistanceToMove, MemorySegment lpNewFilePointer, int dwMoveMethod) {
        var mh$ = SetFilePointerEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetFilePointerEx", hFile, liDistanceToMove, lpNewFilePointer, dwMoveMethod);
            }
            return (int)mh$.invokeExact(hFile, liDistanceToMove, lpNewFilePointer, dwMoveMethod);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetFileTime {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("SetFileTime"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetFileTime(HANDLE hFile, const FILETIME *lpCreationTime, const FILETIME *lpLastAccessTime, const FILETIME *lpLastWriteTime)
     * }
     */
    public static FunctionDescriptor SetFileTime$descriptor() {
        return SetFileTime.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetFileTime(HANDLE hFile, const FILETIME *lpCreationTime, const FILETIME *lpLastAccessTime, const FILETIME *lpLastWriteTime)
     * }
     */
    public static MethodHandle SetFileTime$handle() {
        return SetFileTime.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL SetFileTime(HANDLE hFile, const FILETIME *lpCreationTime, const FILETIME *lpLastAccessTime, const FILETIME *lpLastWriteTime)
     * }
     */
    public static int SetFileTime(MemorySegment hFile, MemorySegment lpCreationTime, MemorySegment lpLastAccessTime, MemorySegment lpLastWriteTime) {
        var mh$ = SetFileTime.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetFileTime", hFile, lpCreationTime, lpLastAccessTime, lpLastWriteTime);
            }
            return (int)mh$.invokeExact(hFile, lpCreationTime, lpLastAccessTime, lpLastWriteTime);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetFileValidData {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_LONG_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("SetFileValidData"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetFileValidData(HANDLE hFile, LONGLONG ValidDataLength)
     * }
     */
    public static FunctionDescriptor SetFileValidData$descriptor() {
        return SetFileValidData.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetFileValidData(HANDLE hFile, LONGLONG ValidDataLength)
     * }
     */
    public static MethodHandle SetFileValidData$handle() {
        return SetFileValidData.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL SetFileValidData(HANDLE hFile, LONGLONG ValidDataLength)
     * }
     */
    public static int SetFileValidData(MemorySegment hFile, long ValidDataLength) {
        var mh$ = SetFileValidData.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetFileValidData", hFile, ValidDataLength);
            }
            return (int)mh$.invokeExact(hFile, ValidDataLength);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class UnlockFile {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_LONG,
            C_LONG,
            C_LONG,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("UnlockFile"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL UnlockFile(HANDLE hFile, DWORD dwFileOffsetLow, DWORD dwFileOffsetHigh, DWORD nNumberOfBytesToUnlockLow, DWORD nNumberOfBytesToUnlockHigh)
     * }
     */
    public static FunctionDescriptor UnlockFile$descriptor() {
        return UnlockFile.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL UnlockFile(HANDLE hFile, DWORD dwFileOffsetLow, DWORD dwFileOffsetHigh, DWORD nNumberOfBytesToUnlockLow, DWORD nNumberOfBytesToUnlockHigh)
     * }
     */
    public static MethodHandle UnlockFile$handle() {
        return UnlockFile.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL UnlockFile(HANDLE hFile, DWORD dwFileOffsetLow, DWORD dwFileOffsetHigh, DWORD nNumberOfBytesToUnlockLow, DWORD nNumberOfBytesToUnlockHigh)
     * }
     */
    public static int UnlockFile(MemorySegment hFile, int dwFileOffsetLow, int dwFileOffsetHigh, int nNumberOfBytesToUnlockLow, int nNumberOfBytesToUnlockHigh) {
        var mh$ = UnlockFile.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("UnlockFile", hFile, dwFileOffsetLow, dwFileOffsetHigh, nNumberOfBytesToUnlockLow, nNumberOfBytesToUnlockHigh);
            }
            return (int)mh$.invokeExact(hFile, dwFileOffsetLow, dwFileOffsetHigh, nNumberOfBytesToUnlockLow, nNumberOfBytesToUnlockHigh);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class UnlockFileEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_LONG,
            C_LONG,
            C_LONG,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("UnlockFileEx"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL UnlockFileEx(HANDLE hFile, DWORD dwReserved, DWORD nNumberOfBytesToUnlockLow, DWORD nNumberOfBytesToUnlockHigh, LPOVERLAPPED lpOverlapped)
     * }
     */
    public static FunctionDescriptor UnlockFileEx$descriptor() {
        return UnlockFileEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL UnlockFileEx(HANDLE hFile, DWORD dwReserved, DWORD nNumberOfBytesToUnlockLow, DWORD nNumberOfBytesToUnlockHigh, LPOVERLAPPED lpOverlapped)
     * }
     */
    public static MethodHandle UnlockFileEx$handle() {
        return UnlockFileEx.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL UnlockFileEx(HANDLE hFile, DWORD dwReserved, DWORD nNumberOfBytesToUnlockLow, DWORD nNumberOfBytesToUnlockHigh, LPOVERLAPPED lpOverlapped)
     * }
     */
    public static int UnlockFileEx(MemorySegment hFile, int dwReserved, int nNumberOfBytesToUnlockLow, int nNumberOfBytesToUnlockHigh, MemorySegment lpOverlapped) {
        var mh$ = UnlockFileEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("UnlockFileEx", hFile, dwReserved, nNumberOfBytesToUnlockLow, nNumberOfBytesToUnlockHigh, lpOverlapped);
            }
            return (int)mh$.invokeExact(hFile, dwReserved, nNumberOfBytesToUnlockLow, nNumberOfBytesToUnlockHigh, lpOverlapped);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class WriteFile {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_LONG,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("WriteFile"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL WriteFile(HANDLE hFile, LPCVOID lpBuffer, DWORD nNumberOfBytesToWrite, LPDWORD lpNumberOfBytesWritten, LPOVERLAPPED lpOverlapped)
     * }
     */
    public static FunctionDescriptor WriteFile$descriptor() {
        return WriteFile.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL WriteFile(HANDLE hFile, LPCVOID lpBuffer, DWORD nNumberOfBytesToWrite, LPDWORD lpNumberOfBytesWritten, LPOVERLAPPED lpOverlapped)
     * }
     */
    public static MethodHandle WriteFile$handle() {
        return WriteFile.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL WriteFile(HANDLE hFile, LPCVOID lpBuffer, DWORD nNumberOfBytesToWrite, LPDWORD lpNumberOfBytesWritten, LPOVERLAPPED lpOverlapped)
     * }
     */
    public static int WriteFile(MemorySegment hFile, MemorySegment lpBuffer, int nNumberOfBytesToWrite, MemorySegment lpNumberOfBytesWritten, MemorySegment lpOverlapped) {
        var mh$ = WriteFile.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WriteFile", hFile, lpBuffer, nNumberOfBytesToWrite, lpNumberOfBytesWritten, lpOverlapped);
            }
            return (int)mh$.invokeExact(hFile, lpBuffer, nNumberOfBytesToWrite, lpNumberOfBytesWritten, lpOverlapped);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class WriteFileEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_LONG,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("WriteFileEx"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL WriteFileEx(HANDLE hFile, LPCVOID lpBuffer, DWORD nNumberOfBytesToWrite, LPOVERLAPPED lpOverlapped, LPOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine)
     * }
     */
    public static FunctionDescriptor WriteFileEx$descriptor() {
        return WriteFileEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL WriteFileEx(HANDLE hFile, LPCVOID lpBuffer, DWORD nNumberOfBytesToWrite, LPOVERLAPPED lpOverlapped, LPOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine)
     * }
     */
    public static MethodHandle WriteFileEx$handle() {
        return WriteFileEx.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL WriteFileEx(HANDLE hFile, LPCVOID lpBuffer, DWORD nNumberOfBytesToWrite, LPOVERLAPPED lpOverlapped, LPOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine)
     * }
     */
    public static int WriteFileEx(MemorySegment hFile, MemorySegment lpBuffer, int nNumberOfBytesToWrite, MemorySegment lpOverlapped, MemorySegment lpCompletionRoutine) {
        var mh$ = WriteFileEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WriteFileEx", hFile, lpBuffer, nNumberOfBytesToWrite, lpOverlapped, lpCompletionRoutine);
            }
            return (int)mh$.invokeExact(hFile, lpBuffer, nNumberOfBytesToWrite, lpOverlapped, lpCompletionRoutine);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class WriteFileGather {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_LONG,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("WriteFileGather"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL WriteFileGather(HANDLE hFile, FILE_SEGMENT_ELEMENT aSegmentArray[], DWORD nNumberOfBytesToWrite, LPDWORD lpReserved, LPOVERLAPPED lpOverlapped)
     * }
     */
    public static FunctionDescriptor WriteFileGather$descriptor() {
        return WriteFileGather.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL WriteFileGather(HANDLE hFile, FILE_SEGMENT_ELEMENT aSegmentArray[], DWORD nNumberOfBytesToWrite, LPDWORD lpReserved, LPOVERLAPPED lpOverlapped)
     * }
     */
    public static MethodHandle WriteFileGather$handle() {
        return WriteFileGather.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL WriteFileGather(HANDLE hFile, FILE_SEGMENT_ELEMENT aSegmentArray[], DWORD nNumberOfBytesToWrite, LPDWORD lpReserved, LPOVERLAPPED lpOverlapped)
     * }
     */
    public static int WriteFileGather(MemorySegment hFile, MemorySegment aSegmentArray, int nNumberOfBytesToWrite, MemorySegment lpReserved, MemorySegment lpOverlapped) {
        var mh$ = WriteFileGather.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WriteFileGather", hFile, aSegmentArray, nNumberOfBytesToWrite, lpReserved, lpOverlapped);
            }
            return (int)mh$.invokeExact(hFile, aSegmentArray, nNumberOfBytesToWrite, lpReserved, lpOverlapped);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetTempPathW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_LONG,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetTempPathW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetTempPathW(DWORD nBufferLength, LPWSTR lpBuffer)
     * }
     */
    public static FunctionDescriptor GetTempPathW$descriptor() {
        return GetTempPathW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetTempPathW(DWORD nBufferLength, LPWSTR lpBuffer)
     * }
     */
    public static MethodHandle GetTempPathW$handle() {
        return GetTempPathW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * DWORD GetTempPathW(DWORD nBufferLength, LPWSTR lpBuffer)
     * }
     */
    public static int GetTempPathW(int nBufferLength, MemorySegment lpBuffer) {
        var mh$ = GetTempPathW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetTempPathW", nBufferLength, lpBuffer);
            }
            return (int)mh$.invokeExact(nBufferLength, lpBuffer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetVolumeNameForVolumeMountPointW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetVolumeNameForVolumeMountPointW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetVolumeNameForVolumeMountPointW(LPCWSTR lpszVolumeMountPoint, LPWSTR lpszVolumeName, DWORD cchBufferLength)
     * }
     */
    public static FunctionDescriptor GetVolumeNameForVolumeMountPointW$descriptor() {
        return GetVolumeNameForVolumeMountPointW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetVolumeNameForVolumeMountPointW(LPCWSTR lpszVolumeMountPoint, LPWSTR lpszVolumeName, DWORD cchBufferLength)
     * }
     */
    public static MethodHandle GetVolumeNameForVolumeMountPointW$handle() {
        return GetVolumeNameForVolumeMountPointW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL GetVolumeNameForVolumeMountPointW(LPCWSTR lpszVolumeMountPoint, LPWSTR lpszVolumeName, DWORD cchBufferLength)
     * }
     */
    public static int GetVolumeNameForVolumeMountPointW(MemorySegment lpszVolumeMountPoint, MemorySegment lpszVolumeName, int cchBufferLength) {
        var mh$ = GetVolumeNameForVolumeMountPointW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetVolumeNameForVolumeMountPointW", lpszVolumeMountPoint, lpszVolumeName, cchBufferLength);
            }
            return (int)mh$.invokeExact(lpszVolumeMountPoint, lpszVolumeName, cchBufferLength);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetVolumePathNamesForVolumeNameW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_LONG,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetVolumePathNamesForVolumeNameW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetVolumePathNamesForVolumeNameW(LPCWSTR lpszVolumeName, LPWCH lpszVolumePathNames, DWORD cchBufferLength, PDWORD lpcchReturnLength)
     * }
     */
    public static FunctionDescriptor GetVolumePathNamesForVolumeNameW$descriptor() {
        return GetVolumePathNamesForVolumeNameW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetVolumePathNamesForVolumeNameW(LPCWSTR lpszVolumeName, LPWCH lpszVolumePathNames, DWORD cchBufferLength, PDWORD lpcchReturnLength)
     * }
     */
    public static MethodHandle GetVolumePathNamesForVolumeNameW$handle() {
        return GetVolumePathNamesForVolumeNameW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL GetVolumePathNamesForVolumeNameW(LPCWSTR lpszVolumeName, LPWCH lpszVolumePathNames, DWORD cchBufferLength, PDWORD lpcchReturnLength)
     * }
     */
    public static int GetVolumePathNamesForVolumeNameW(MemorySegment lpszVolumeName, MemorySegment lpszVolumePathNames, int cchBufferLength, MemorySegment lpcchReturnLength) {
        var mh$ = GetVolumePathNamesForVolumeNameW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetVolumePathNamesForVolumeNameW", lpszVolumeName, lpszVolumePathNames, cchBufferLength, lpcchReturnLength);
            }
            return (int)mh$.invokeExact(lpszVolumeName, lpszVolumePathNames, cchBufferLength, lpcchReturnLength);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct _CREATEFILE2_EXTENDED_PARAMETERS {
     *     DWORD dwSize;
     *     DWORD dwFileAttributes;
     *     DWORD dwFileFlags;
     *     DWORD dwSecurityQosFlags;
     *     LPSECURITY_ATTRIBUTES lpSecurityAttributes;
     *     HANDLE hTemplateFile;
     * } *PCREATEFILE2_EXTENDED_PARAMETERS
     * }
     */
    public static final AddressLayout PCREATEFILE2_EXTENDED_PARAMETERS = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _CREATEFILE2_EXTENDED_PARAMETERS {
     *     DWORD dwSize;
     *     DWORD dwFileAttributes;
     *     DWORD dwFileFlags;
     *     DWORD dwSecurityQosFlags;
     *     LPSECURITY_ATTRIBUTES lpSecurityAttributes;
     *     HANDLE hTemplateFile;
     * } *LPCREATEFILE2_EXTENDED_PARAMETERS
     * }
     */
    public static final AddressLayout LPCREATEFILE2_EXTENDED_PARAMETERS = C_POINTER;

    private static class CreateFile2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER,
            C_LONG,
            C_LONG,
            C_LONG,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CreateFile2"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HANDLE CreateFile2(LPCWSTR lpFileName, DWORD dwDesiredAccess, DWORD dwShareMode, DWORD dwCreationDisposition, LPCREATEFILE2_EXTENDED_PARAMETERS pCreateExParams)
     * }
     */
    public static FunctionDescriptor CreateFile2$descriptor() {
        return CreateFile2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HANDLE CreateFile2(LPCWSTR lpFileName, DWORD dwDesiredAccess, DWORD dwShareMode, DWORD dwCreationDisposition, LPCREATEFILE2_EXTENDED_PARAMETERS pCreateExParams)
     * }
     */
    public static MethodHandle CreateFile2$handle() {
        return CreateFile2.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * HANDLE CreateFile2(LPCWSTR lpFileName, DWORD dwDesiredAccess, DWORD dwShareMode, DWORD dwCreationDisposition, LPCREATEFILE2_EXTENDED_PARAMETERS pCreateExParams)
     * }
     */
    public static MemorySegment CreateFile2(MemorySegment lpFileName, int dwDesiredAccess, int dwShareMode, int dwCreationDisposition, MemorySegment pCreateExParams) {
        var mh$ = CreateFile2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateFile2", lpFileName, dwDesiredAccess, dwShareMode, dwCreationDisposition, pCreateExParams);
            }
            return (MemorySegment)mh$.invokeExact(lpFileName, dwDesiredAccess, dwShareMode, dwCreationDisposition, pCreateExParams);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetFileIoOverlappedRange {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("SetFileIoOverlappedRange"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetFileIoOverlappedRange(HANDLE FileHandle, PUCHAR OverlappedRangeStart, ULONG Length)
     * }
     */
    public static FunctionDescriptor SetFileIoOverlappedRange$descriptor() {
        return SetFileIoOverlappedRange.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetFileIoOverlappedRange(HANDLE FileHandle, PUCHAR OverlappedRangeStart, ULONG Length)
     * }
     */
    public static MethodHandle SetFileIoOverlappedRange$handle() {
        return SetFileIoOverlappedRange.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL SetFileIoOverlappedRange(HANDLE FileHandle, PUCHAR OverlappedRangeStart, ULONG Length)
     * }
     */
    public static int SetFileIoOverlappedRange(MemorySegment FileHandle, MemorySegment OverlappedRangeStart, int Length) {
        var mh$ = SetFileIoOverlappedRange.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetFileIoOverlappedRange", FileHandle, OverlappedRangeStart, Length);
            }
            return (int)mh$.invokeExact(FileHandle, OverlappedRangeStart, Length);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetCompressedFileSizeA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetCompressedFileSizeA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetCompressedFileSizeA(LPCSTR lpFileName, LPDWORD lpFileSizeHigh)
     * }
     */
    public static FunctionDescriptor GetCompressedFileSizeA$descriptor() {
        return GetCompressedFileSizeA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetCompressedFileSizeA(LPCSTR lpFileName, LPDWORD lpFileSizeHigh)
     * }
     */
    public static MethodHandle GetCompressedFileSizeA$handle() {
        return GetCompressedFileSizeA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * DWORD GetCompressedFileSizeA(LPCSTR lpFileName, LPDWORD lpFileSizeHigh)
     * }
     */
    public static int GetCompressedFileSizeA(MemorySegment lpFileName, MemorySegment lpFileSizeHigh) {
        var mh$ = GetCompressedFileSizeA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetCompressedFileSizeA", lpFileName, lpFileSizeHigh);
            }
            return (int)mh$.invokeExact(lpFileName, lpFileSizeHigh);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetCompressedFileSizeW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetCompressedFileSizeW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetCompressedFileSizeW(LPCWSTR lpFileName, LPDWORD lpFileSizeHigh)
     * }
     */
    public static FunctionDescriptor GetCompressedFileSizeW$descriptor() {
        return GetCompressedFileSizeW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetCompressedFileSizeW(LPCWSTR lpFileName, LPDWORD lpFileSizeHigh)
     * }
     */
    public static MethodHandle GetCompressedFileSizeW$handle() {
        return GetCompressedFileSizeW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * DWORD GetCompressedFileSizeW(LPCWSTR lpFileName, LPDWORD lpFileSizeHigh)
     * }
     */
    public static int GetCompressedFileSizeW(MemorySegment lpFileName, MemorySegment lpFileSizeHigh) {
        var mh$ = GetCompressedFileSizeW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetCompressedFileSizeW", lpFileName, lpFileSizeHigh);
            }
            return (int)mh$.invokeExact(lpFileName, lpFileSizeHigh);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int FindStreamInfoStandard = (int)0L;
    /**
     * {@snippet lang=c :
     * enum _STREAM_INFO_LEVELS.FindStreamInfoStandard = 0
     * }
     */
    public static int FindStreamInfoStandard() {
        return FindStreamInfoStandard;
    }
    private static final int FindStreamInfoMaxInfoLevel = (int)1L;
    /**
     * {@snippet lang=c :
     * enum _STREAM_INFO_LEVELS.FindStreamInfoMaxInfoLevel = 1
     * }
     */
    public static int FindStreamInfoMaxInfoLevel() {
        return FindStreamInfoMaxInfoLevel;
    }
    /**
     * {@snippet lang=c :
     * typedef struct _WIN32_FIND_STREAM_DATA {
     *     LARGE_INTEGER StreamSize;
     *     WCHAR cStreamName[296];
     * } *PWIN32_FIND_STREAM_DATA
     * }
     */
    public static final AddressLayout PWIN32_FIND_STREAM_DATA = C_POINTER;

    private static class FindFirstStreamW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER,
            C_INT,
            C_POINTER,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("FindFirstStreamW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HANDLE FindFirstStreamW(LPCWSTR lpFileName, STREAM_INFO_LEVELS InfoLevel, LPVOID lpFindStreamData, DWORD dwFlags)
     * }
     */
    public static FunctionDescriptor FindFirstStreamW$descriptor() {
        return FindFirstStreamW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HANDLE FindFirstStreamW(LPCWSTR lpFileName, STREAM_INFO_LEVELS InfoLevel, LPVOID lpFindStreamData, DWORD dwFlags)
     * }
     */
    public static MethodHandle FindFirstStreamW$handle() {
        return FindFirstStreamW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * HANDLE FindFirstStreamW(LPCWSTR lpFileName, STREAM_INFO_LEVELS InfoLevel, LPVOID lpFindStreamData, DWORD dwFlags)
     * }
     */
    public static MemorySegment FindFirstStreamW(MemorySegment lpFileName, int InfoLevel, MemorySegment lpFindStreamData, int dwFlags) {
        var mh$ = FindFirstStreamW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FindFirstStreamW", lpFileName, InfoLevel, lpFindStreamData, dwFlags);
            }
            return (MemorySegment)mh$.invokeExact(lpFileName, InfoLevel, lpFindStreamData, dwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FindNextStreamW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("FindNextStreamW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL FindNextStreamW(HANDLE hFindStream, LPVOID lpFindStreamData)
     * }
     */
    public static FunctionDescriptor FindNextStreamW$descriptor() {
        return FindNextStreamW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL FindNextStreamW(HANDLE hFindStream, LPVOID lpFindStreamData)
     * }
     */
    public static MethodHandle FindNextStreamW$handle() {
        return FindNextStreamW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL FindNextStreamW(HANDLE hFindStream, LPVOID lpFindStreamData)
     * }
     */
    public static int FindNextStreamW(MemorySegment hFindStream, MemorySegment lpFindStreamData) {
        var mh$ = FindNextStreamW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FindNextStreamW", hFindStream, lpFindStreamData);
            }
            return (int)mh$.invokeExact(hFindStream, lpFindStreamData);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class AreFileApisANSI {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT    );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("AreFileApisANSI"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL AreFileApisANSI()
     * }
     */
    public static FunctionDescriptor AreFileApisANSI$descriptor() {
        return AreFileApisANSI.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL AreFileApisANSI()
     * }
     */
    public static MethodHandle AreFileApisANSI$handle() {
        return AreFileApisANSI.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL AreFileApisANSI()
     * }
     */
    public static int AreFileApisANSI() {
        var mh$ = AreFileApisANSI.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("AreFileApisANSI");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetTempPathA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_LONG,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetTempPathA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetTempPathA(DWORD nBufferLength, LPSTR lpBuffer)
     * }
     */
    public static FunctionDescriptor GetTempPathA$descriptor() {
        return GetTempPathA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetTempPathA(DWORD nBufferLength, LPSTR lpBuffer)
     * }
     */
    public static MethodHandle GetTempPathA$handle() {
        return GetTempPathA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * DWORD GetTempPathA(DWORD nBufferLength, LPSTR lpBuffer)
     * }
     */
    public static int GetTempPathA(int nBufferLength, MemorySegment lpBuffer) {
        var mh$ = GetTempPathA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetTempPathA", nBufferLength, lpBuffer);
            }
            return (int)mh$.invokeExact(nBufferLength, lpBuffer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FindFirstFileNameW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER,
            C_LONG,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("FindFirstFileNameW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HANDLE FindFirstFileNameW(LPCWSTR lpFileName, DWORD dwFlags, LPDWORD StringLength, PWSTR LinkName)
     * }
     */
    public static FunctionDescriptor FindFirstFileNameW$descriptor() {
        return FindFirstFileNameW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HANDLE FindFirstFileNameW(LPCWSTR lpFileName, DWORD dwFlags, LPDWORD StringLength, PWSTR LinkName)
     * }
     */
    public static MethodHandle FindFirstFileNameW$handle() {
        return FindFirstFileNameW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * HANDLE FindFirstFileNameW(LPCWSTR lpFileName, DWORD dwFlags, LPDWORD StringLength, PWSTR LinkName)
     * }
     */
    public static MemorySegment FindFirstFileNameW(MemorySegment lpFileName, int dwFlags, MemorySegment StringLength, MemorySegment LinkName) {
        var mh$ = FindFirstFileNameW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FindFirstFileNameW", lpFileName, dwFlags, StringLength, LinkName);
            }
            return (MemorySegment)mh$.invokeExact(lpFileName, dwFlags, StringLength, LinkName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FindNextFileNameW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("FindNextFileNameW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL FindNextFileNameW(HANDLE hFindStream, LPDWORD StringLength, PWSTR LinkName)
     * }
     */
    public static FunctionDescriptor FindNextFileNameW$descriptor() {
        return FindNextFileNameW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL FindNextFileNameW(HANDLE hFindStream, LPDWORD StringLength, PWSTR LinkName)
     * }
     */
    public static MethodHandle FindNextFileNameW$handle() {
        return FindNextFileNameW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL FindNextFileNameW(HANDLE hFindStream, LPDWORD StringLength, PWSTR LinkName)
     * }
     */
    public static int FindNextFileNameW(MemorySegment hFindStream, MemorySegment StringLength, MemorySegment LinkName) {
        var mh$ = FindNextFileNameW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FindNextFileNameW", hFindStream, StringLength, LinkName);
            }
            return (int)mh$.invokeExact(hFindStream, StringLength, LinkName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetVolumeInformationA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_LONG,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetVolumeInformationA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetVolumeInformationA(LPCSTR lpRootPathName, LPSTR lpVolumeNameBuffer, DWORD nVolumeNameSize, LPDWORD lpVolumeSerialNumber, LPDWORD lpMaximumComponentLength, LPDWORD lpFileSystemFlags, LPSTR lpFileSystemNameBuffer, DWORD nFileSystemNameSize)
     * }
     */
    public static FunctionDescriptor GetVolumeInformationA$descriptor() {
        return GetVolumeInformationA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetVolumeInformationA(LPCSTR lpRootPathName, LPSTR lpVolumeNameBuffer, DWORD nVolumeNameSize, LPDWORD lpVolumeSerialNumber, LPDWORD lpMaximumComponentLength, LPDWORD lpFileSystemFlags, LPSTR lpFileSystemNameBuffer, DWORD nFileSystemNameSize)
     * }
     */
    public static MethodHandle GetVolumeInformationA$handle() {
        return GetVolumeInformationA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL GetVolumeInformationA(LPCSTR lpRootPathName, LPSTR lpVolumeNameBuffer, DWORD nVolumeNameSize, LPDWORD lpVolumeSerialNumber, LPDWORD lpMaximumComponentLength, LPDWORD lpFileSystemFlags, LPSTR lpFileSystemNameBuffer, DWORD nFileSystemNameSize)
     * }
     */
    public static int GetVolumeInformationA(MemorySegment lpRootPathName, MemorySegment lpVolumeNameBuffer, int nVolumeNameSize, MemorySegment lpVolumeSerialNumber, MemorySegment lpMaximumComponentLength, MemorySegment lpFileSystemFlags, MemorySegment lpFileSystemNameBuffer, int nFileSystemNameSize) {
        var mh$ = GetVolumeInformationA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetVolumeInformationA", lpRootPathName, lpVolumeNameBuffer, nVolumeNameSize, lpVolumeSerialNumber, lpMaximumComponentLength, lpFileSystemFlags, lpFileSystemNameBuffer, nFileSystemNameSize);
            }
            return (int)mh$.invokeExact(lpRootPathName, lpVolumeNameBuffer, nVolumeNameSize, lpVolumeSerialNumber, lpMaximumComponentLength, lpFileSystemFlags, lpFileSystemNameBuffer, nFileSystemNameSize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetTempFileNameA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetTempFileNameA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * UINT GetTempFileNameA(LPCSTR lpPathName, LPCSTR lpPrefixString, UINT uUnique, LPSTR lpTempFileName)
     * }
     */
    public static FunctionDescriptor GetTempFileNameA$descriptor() {
        return GetTempFileNameA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * UINT GetTempFileNameA(LPCSTR lpPathName, LPCSTR lpPrefixString, UINT uUnique, LPSTR lpTempFileName)
     * }
     */
    public static MethodHandle GetTempFileNameA$handle() {
        return GetTempFileNameA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * UINT GetTempFileNameA(LPCSTR lpPathName, LPCSTR lpPrefixString, UINT uUnique, LPSTR lpTempFileName)
     * }
     */
    public static int GetTempFileNameA(MemorySegment lpPathName, MemorySegment lpPrefixString, int uUnique, MemorySegment lpTempFileName) {
        var mh$ = GetTempFileNameA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetTempFileNameA", lpPathName, lpPrefixString, uUnique, lpTempFileName);
            }
            return (int)mh$.invokeExact(lpPathName, lpPrefixString, uUnique, lpTempFileName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetFileApisToOEM {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("SetFileApisToOEM"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SetFileApisToOEM()
     * }
     */
    public static FunctionDescriptor SetFileApisToOEM$descriptor() {
        return SetFileApisToOEM.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SetFileApisToOEM()
     * }
     */
    public static MethodHandle SetFileApisToOEM$handle() {
        return SetFileApisToOEM.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * void SetFileApisToOEM()
     * }
     */
    public static void SetFileApisToOEM() {
        var mh$ = SetFileApisToOEM.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetFileApisToOEM");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetFileApisToANSI {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("SetFileApisToANSI"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SetFileApisToANSI()
     * }
     */
    public static FunctionDescriptor SetFileApisToANSI$descriptor() {
        return SetFileApisToANSI.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SetFileApisToANSI()
     * }
     */
    public static MethodHandle SetFileApisToANSI$handle() {
        return SetFileApisToANSI.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * void SetFileApisToANSI()
     * }
     */
    public static void SetFileApisToANSI() {
        var mh$ = SetFileApisToANSI.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetFileApisToANSI");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetTempPath2W {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_LONG,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetTempPath2W"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetTempPath2W(DWORD BufferLength, LPWSTR Buffer)
     * }
     */
    public static FunctionDescriptor GetTempPath2W$descriptor() {
        return GetTempPath2W.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetTempPath2W(DWORD BufferLength, LPWSTR Buffer)
     * }
     */
    public static MethodHandle GetTempPath2W$handle() {
        return GetTempPath2W.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * DWORD GetTempPath2W(DWORD BufferLength, LPWSTR Buffer)
     * }
     */
    public static int GetTempPath2W(int BufferLength, MemorySegment Buffer) {
        var mh$ = GetTempPath2W.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetTempPath2W", BufferLength, Buffer);
            }
            return (int)mh$.invokeExact(BufferLength, Buffer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetTempPath2A {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_LONG,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetTempPath2A"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetTempPath2A(DWORD BufferLength, LPSTR Buffer)
     * }
     */
    public static FunctionDescriptor GetTempPath2A$descriptor() {
        return GetTempPath2A.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetTempPath2A(DWORD BufferLength, LPSTR Buffer)
     * }
     */
    public static MethodHandle GetTempPath2A$handle() {
        return GetTempPath2A.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * DWORD GetTempPath2A(DWORD BufferLength, LPSTR Buffer)
     * }
     */
    public static int GetTempPath2A(int BufferLength, MemorySegment Buffer) {
        var mh$ = GetTempPath2A.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetTempPath2A", BufferLength, Buffer);
            }
            return (int)mh$.invokeExact(BufferLength, Buffer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CopyFileFromAppW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CopyFileFromAppW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CopyFileFromAppW(LPCWSTR lpExistingFileName, LPCWSTR lpNewFileName, BOOL bFailIfExists)
     * }
     */
    public static FunctionDescriptor CopyFileFromAppW$descriptor() {
        return CopyFileFromAppW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CopyFileFromAppW(LPCWSTR lpExistingFileName, LPCWSTR lpNewFileName, BOOL bFailIfExists)
     * }
     */
    public static MethodHandle CopyFileFromAppW$handle() {
        return CopyFileFromAppW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL CopyFileFromAppW(LPCWSTR lpExistingFileName, LPCWSTR lpNewFileName, BOOL bFailIfExists)
     * }
     */
    public static int CopyFileFromAppW(MemorySegment lpExistingFileName, MemorySegment lpNewFileName, int bFailIfExists) {
        var mh$ = CopyFileFromAppW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CopyFileFromAppW", lpExistingFileName, lpNewFileName, bFailIfExists);
            }
            return (int)mh$.invokeExact(lpExistingFileName, lpNewFileName, bFailIfExists);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateDirectoryFromAppW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CreateDirectoryFromAppW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CreateDirectoryFromAppW(LPCWSTR lpPathName, LPSECURITY_ATTRIBUTES lpSecurityAttributes)
     * }
     */
    public static FunctionDescriptor CreateDirectoryFromAppW$descriptor() {
        return CreateDirectoryFromAppW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CreateDirectoryFromAppW(LPCWSTR lpPathName, LPSECURITY_ATTRIBUTES lpSecurityAttributes)
     * }
     */
    public static MethodHandle CreateDirectoryFromAppW$handle() {
        return CreateDirectoryFromAppW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL CreateDirectoryFromAppW(LPCWSTR lpPathName, LPSECURITY_ATTRIBUTES lpSecurityAttributes)
     * }
     */
    public static int CreateDirectoryFromAppW(MemorySegment lpPathName, MemorySegment lpSecurityAttributes) {
        var mh$ = CreateDirectoryFromAppW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateDirectoryFromAppW", lpPathName, lpSecurityAttributes);
            }
            return (int)mh$.invokeExact(lpPathName, lpSecurityAttributes);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateFileFromAppW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER,
            C_LONG,
            C_LONG,
            C_POINTER,
            C_LONG,
            C_LONG,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CreateFileFromAppW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HANDLE CreateFileFromAppW(LPCWSTR lpFileName, DWORD dwDesiredAccess, DWORD dwShareMode, LPSECURITY_ATTRIBUTES lpSecurityAttributes, DWORD dwCreationDisposition, DWORD dwFlagsAndAttributes, HANDLE hTemplateFile)
     * }
     */
    public static FunctionDescriptor CreateFileFromAppW$descriptor() {
        return CreateFileFromAppW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HANDLE CreateFileFromAppW(LPCWSTR lpFileName, DWORD dwDesiredAccess, DWORD dwShareMode, LPSECURITY_ATTRIBUTES lpSecurityAttributes, DWORD dwCreationDisposition, DWORD dwFlagsAndAttributes, HANDLE hTemplateFile)
     * }
     */
    public static MethodHandle CreateFileFromAppW$handle() {
        return CreateFileFromAppW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * HANDLE CreateFileFromAppW(LPCWSTR lpFileName, DWORD dwDesiredAccess, DWORD dwShareMode, LPSECURITY_ATTRIBUTES lpSecurityAttributes, DWORD dwCreationDisposition, DWORD dwFlagsAndAttributes, HANDLE hTemplateFile)
     * }
     */
    public static MemorySegment CreateFileFromAppW(MemorySegment lpFileName, int dwDesiredAccess, int dwShareMode, MemorySegment lpSecurityAttributes, int dwCreationDisposition, int dwFlagsAndAttributes, MemorySegment hTemplateFile) {
        var mh$ = CreateFileFromAppW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateFileFromAppW", lpFileName, dwDesiredAccess, dwShareMode, lpSecurityAttributes, dwCreationDisposition, dwFlagsAndAttributes, hTemplateFile);
            }
            return (MemorySegment)mh$.invokeExact(lpFileName, dwDesiredAccess, dwShareMode, lpSecurityAttributes, dwCreationDisposition, dwFlagsAndAttributes, hTemplateFile);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateFile2FromAppW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER,
            C_LONG,
            C_LONG,
            C_LONG,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CreateFile2FromAppW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HANDLE CreateFile2FromAppW(LPCWSTR lpFileName, DWORD dwDesiredAccess, DWORD dwShareMode, DWORD dwCreationDisposition, LPCREATEFILE2_EXTENDED_PARAMETERS pCreateExParams)
     * }
     */
    public static FunctionDescriptor CreateFile2FromAppW$descriptor() {
        return CreateFile2FromAppW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HANDLE CreateFile2FromAppW(LPCWSTR lpFileName, DWORD dwDesiredAccess, DWORD dwShareMode, DWORD dwCreationDisposition, LPCREATEFILE2_EXTENDED_PARAMETERS pCreateExParams)
     * }
     */
    public static MethodHandle CreateFile2FromAppW$handle() {
        return CreateFile2FromAppW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * HANDLE CreateFile2FromAppW(LPCWSTR lpFileName, DWORD dwDesiredAccess, DWORD dwShareMode, DWORD dwCreationDisposition, LPCREATEFILE2_EXTENDED_PARAMETERS pCreateExParams)
     * }
     */
    public static MemorySegment CreateFile2FromAppW(MemorySegment lpFileName, int dwDesiredAccess, int dwShareMode, int dwCreationDisposition, MemorySegment pCreateExParams) {
        var mh$ = CreateFile2FromAppW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateFile2FromAppW", lpFileName, dwDesiredAccess, dwShareMode, dwCreationDisposition, pCreateExParams);
            }
            return (MemorySegment)mh$.invokeExact(lpFileName, dwDesiredAccess, dwShareMode, dwCreationDisposition, pCreateExParams);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DeleteFileFromAppW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("DeleteFileFromAppW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL DeleteFileFromAppW(LPCWSTR lpFileName)
     * }
     */
    public static FunctionDescriptor DeleteFileFromAppW$descriptor() {
        return DeleteFileFromAppW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL DeleteFileFromAppW(LPCWSTR lpFileName)
     * }
     */
    public static MethodHandle DeleteFileFromAppW$handle() {
        return DeleteFileFromAppW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL DeleteFileFromAppW(LPCWSTR lpFileName)
     * }
     */
    public static int DeleteFileFromAppW(MemorySegment lpFileName) {
        var mh$ = DeleteFileFromAppW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DeleteFileFromAppW", lpFileName);
            }
            return (int)mh$.invokeExact(lpFileName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FindFirstFileExFromAppW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER,
            C_INT,
            C_POINTER,
            C_INT,
            C_POINTER,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("FindFirstFileExFromAppW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HANDLE FindFirstFileExFromAppW(LPCWSTR lpFileName, FINDEX_INFO_LEVELS fInfoLevelId, LPVOID lpFindFileData, FINDEX_SEARCH_OPS fSearchOp, LPVOID lpSearchFilter, DWORD dwAdditionalFlags)
     * }
     */
    public static FunctionDescriptor FindFirstFileExFromAppW$descriptor() {
        return FindFirstFileExFromAppW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HANDLE FindFirstFileExFromAppW(LPCWSTR lpFileName, FINDEX_INFO_LEVELS fInfoLevelId, LPVOID lpFindFileData, FINDEX_SEARCH_OPS fSearchOp, LPVOID lpSearchFilter, DWORD dwAdditionalFlags)
     * }
     */
    public static MethodHandle FindFirstFileExFromAppW$handle() {
        return FindFirstFileExFromAppW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * HANDLE FindFirstFileExFromAppW(LPCWSTR lpFileName, FINDEX_INFO_LEVELS fInfoLevelId, LPVOID lpFindFileData, FINDEX_SEARCH_OPS fSearchOp, LPVOID lpSearchFilter, DWORD dwAdditionalFlags)
     * }
     */
    public static MemorySegment FindFirstFileExFromAppW(MemorySegment lpFileName, int fInfoLevelId, MemorySegment lpFindFileData, int fSearchOp, MemorySegment lpSearchFilter, int dwAdditionalFlags) {
        var mh$ = FindFirstFileExFromAppW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FindFirstFileExFromAppW", lpFileName, fInfoLevelId, lpFindFileData, fSearchOp, lpSearchFilter, dwAdditionalFlags);
            }
            return (MemorySegment)mh$.invokeExact(lpFileName, fInfoLevelId, lpFindFileData, fSearchOp, lpSearchFilter, dwAdditionalFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetFileAttributesExFromAppW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetFileAttributesExFromAppW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetFileAttributesExFromAppW(LPCWSTR lpFileName, GET_FILEEX_INFO_LEVELS fInfoLevelId, LPVOID lpFileInformation)
     * }
     */
    public static FunctionDescriptor GetFileAttributesExFromAppW$descriptor() {
        return GetFileAttributesExFromAppW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetFileAttributesExFromAppW(LPCWSTR lpFileName, GET_FILEEX_INFO_LEVELS fInfoLevelId, LPVOID lpFileInformation)
     * }
     */
    public static MethodHandle GetFileAttributesExFromAppW$handle() {
        return GetFileAttributesExFromAppW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL GetFileAttributesExFromAppW(LPCWSTR lpFileName, GET_FILEEX_INFO_LEVELS fInfoLevelId, LPVOID lpFileInformation)
     * }
     */
    public static int GetFileAttributesExFromAppW(MemorySegment lpFileName, int fInfoLevelId, MemorySegment lpFileInformation) {
        var mh$ = GetFileAttributesExFromAppW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetFileAttributesExFromAppW", lpFileName, fInfoLevelId, lpFileInformation);
            }
            return (int)mh$.invokeExact(lpFileName, fInfoLevelId, lpFileInformation);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MoveFileFromAppW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("MoveFileFromAppW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL MoveFileFromAppW(LPCWSTR lpExistingFileName, LPCWSTR lpNewFileName)
     * }
     */
    public static FunctionDescriptor MoveFileFromAppW$descriptor() {
        return MoveFileFromAppW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL MoveFileFromAppW(LPCWSTR lpExistingFileName, LPCWSTR lpNewFileName)
     * }
     */
    public static MethodHandle MoveFileFromAppW$handle() {
        return MoveFileFromAppW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL MoveFileFromAppW(LPCWSTR lpExistingFileName, LPCWSTR lpNewFileName)
     * }
     */
    public static int MoveFileFromAppW(MemorySegment lpExistingFileName, MemorySegment lpNewFileName) {
        var mh$ = MoveFileFromAppW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MoveFileFromAppW", lpExistingFileName, lpNewFileName);
            }
            return (int)mh$.invokeExact(lpExistingFileName, lpNewFileName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RemoveDirectoryFromAppW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("RemoveDirectoryFromAppW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL RemoveDirectoryFromAppW(LPCWSTR lpPathName)
     * }
     */
    public static FunctionDescriptor RemoveDirectoryFromAppW$descriptor() {
        return RemoveDirectoryFromAppW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL RemoveDirectoryFromAppW(LPCWSTR lpPathName)
     * }
     */
    public static MethodHandle RemoveDirectoryFromAppW$handle() {
        return RemoveDirectoryFromAppW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL RemoveDirectoryFromAppW(LPCWSTR lpPathName)
     * }
     */
    public static int RemoveDirectoryFromAppW(MemorySegment lpPathName) {
        var mh$ = RemoveDirectoryFromAppW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RemoveDirectoryFromAppW", lpPathName);
            }
            return (int)mh$.invokeExact(lpPathName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ReplaceFileFromAppW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_LONG,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("ReplaceFileFromAppW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL ReplaceFileFromAppW(LPCWSTR lpReplacedFileName, LPCWSTR lpReplacementFileName, LPCWSTR lpBackupFileName, DWORD dwReplaceFlags, LPVOID lpExclude, LPVOID lpReserved)
     * }
     */
    public static FunctionDescriptor ReplaceFileFromAppW$descriptor() {
        return ReplaceFileFromAppW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL ReplaceFileFromAppW(LPCWSTR lpReplacedFileName, LPCWSTR lpReplacementFileName, LPCWSTR lpBackupFileName, DWORD dwReplaceFlags, LPVOID lpExclude, LPVOID lpReserved)
     * }
     */
    public static MethodHandle ReplaceFileFromAppW$handle() {
        return ReplaceFileFromAppW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL ReplaceFileFromAppW(LPCWSTR lpReplacedFileName, LPCWSTR lpReplacementFileName, LPCWSTR lpBackupFileName, DWORD dwReplaceFlags, LPVOID lpExclude, LPVOID lpReserved)
     * }
     */
    public static int ReplaceFileFromAppW(MemorySegment lpReplacedFileName, MemorySegment lpReplacementFileName, MemorySegment lpBackupFileName, int dwReplaceFlags, MemorySegment lpExclude, MemorySegment lpReserved) {
        var mh$ = ReplaceFileFromAppW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ReplaceFileFromAppW", lpReplacedFileName, lpReplacementFileName, lpBackupFileName, dwReplaceFlags, lpExclude, lpReserved);
            }
            return (int)mh$.invokeExact(lpReplacedFileName, lpReplacementFileName, lpBackupFileName, dwReplaceFlags, lpExclude, lpReserved);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetFileAttributesFromAppW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("SetFileAttributesFromAppW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetFileAttributesFromAppW(LPCWSTR lpFileName, DWORD dwFileAttributes)
     * }
     */
    public static FunctionDescriptor SetFileAttributesFromAppW$descriptor() {
        return SetFileAttributesFromAppW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetFileAttributesFromAppW(LPCWSTR lpFileName, DWORD dwFileAttributes)
     * }
     */
    public static MethodHandle SetFileAttributesFromAppW$handle() {
        return SetFileAttributesFromAppW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL SetFileAttributesFromAppW(LPCWSTR lpFileName, DWORD dwFileAttributes)
     * }
     */
    public static int SetFileAttributesFromAppW(MemorySegment lpFileName, int dwFileAttributes) {
        var mh$ = SetFileAttributesFromAppW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetFileAttributesFromAppW", lpFileName, dwFileAttributes);
            }
            return (int)mh$.invokeExact(lpFileName, dwFileAttributes);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class IsDebuggerPresent {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT    );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("IsDebuggerPresent"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL IsDebuggerPresent()
     * }
     */
    public static FunctionDescriptor IsDebuggerPresent$descriptor() {
        return IsDebuggerPresent.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL IsDebuggerPresent()
     * }
     */
    public static MethodHandle IsDebuggerPresent$handle() {
        return IsDebuggerPresent.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL IsDebuggerPresent()
     * }
     */
    public static int IsDebuggerPresent() {
        var mh$ = IsDebuggerPresent.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("IsDebuggerPresent");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DebugBreak {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("DebugBreak"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void DebugBreak()
     * }
     */
    public static FunctionDescriptor DebugBreak$descriptor() {
        return DebugBreak.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void DebugBreak()
     * }
     */
    public static MethodHandle DebugBreak$handle() {
        return DebugBreak.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * void DebugBreak()
     * }
     */
    public static void DebugBreak() {
        var mh$ = DebugBreak.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DebugBreak");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class OutputDebugStringA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("OutputDebugStringA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void OutputDebugStringA(LPCSTR lpOutputString)
     * }
     */
    public static FunctionDescriptor OutputDebugStringA$descriptor() {
        return OutputDebugStringA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void OutputDebugStringA(LPCSTR lpOutputString)
     * }
     */
    public static MethodHandle OutputDebugStringA$handle() {
        return OutputDebugStringA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * void OutputDebugStringA(LPCSTR lpOutputString)
     * }
     */
    public static void OutputDebugStringA(MemorySegment lpOutputString) {
        var mh$ = OutputDebugStringA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("OutputDebugStringA", lpOutputString);
            }
            mh$.invokeExact(lpOutputString);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class OutputDebugStringW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("OutputDebugStringW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void OutputDebugStringW(LPCWSTR lpOutputString)
     * }
     */
    public static FunctionDescriptor OutputDebugStringW$descriptor() {
        return OutputDebugStringW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void OutputDebugStringW(LPCWSTR lpOutputString)
     * }
     */
    public static MethodHandle OutputDebugStringW$handle() {
        return OutputDebugStringW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * void OutputDebugStringW(LPCWSTR lpOutputString)
     * }
     */
    public static void OutputDebugStringW(MemorySegment lpOutputString) {
        var mh$ = OutputDebugStringW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("OutputDebugStringW", lpOutputString);
            }
            mh$.invokeExact(lpOutputString);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ContinueDebugEvent {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_LONG,
            C_LONG,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("ContinueDebugEvent"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL ContinueDebugEvent(DWORD dwProcessId, DWORD dwThreadId, DWORD dwContinueStatus)
     * }
     */
    public static FunctionDescriptor ContinueDebugEvent$descriptor() {
        return ContinueDebugEvent.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL ContinueDebugEvent(DWORD dwProcessId, DWORD dwThreadId, DWORD dwContinueStatus)
     * }
     */
    public static MethodHandle ContinueDebugEvent$handle() {
        return ContinueDebugEvent.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL ContinueDebugEvent(DWORD dwProcessId, DWORD dwThreadId, DWORD dwContinueStatus)
     * }
     */
    public static int ContinueDebugEvent(int dwProcessId, int dwThreadId, int dwContinueStatus) {
        var mh$ = ContinueDebugEvent.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ContinueDebugEvent", dwProcessId, dwThreadId, dwContinueStatus);
            }
            return (int)mh$.invokeExact(dwProcessId, dwThreadId, dwContinueStatus);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class WaitForDebugEvent {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("WaitForDebugEvent"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL WaitForDebugEvent(LPDEBUG_EVENT lpDebugEvent, DWORD dwMilliseconds)
     * }
     */
    public static FunctionDescriptor WaitForDebugEvent$descriptor() {
        return WaitForDebugEvent.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL WaitForDebugEvent(LPDEBUG_EVENT lpDebugEvent, DWORD dwMilliseconds)
     * }
     */
    public static MethodHandle WaitForDebugEvent$handle() {
        return WaitForDebugEvent.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL WaitForDebugEvent(LPDEBUG_EVENT lpDebugEvent, DWORD dwMilliseconds)
     * }
     */
    public static int WaitForDebugEvent(MemorySegment lpDebugEvent, int dwMilliseconds) {
        var mh$ = WaitForDebugEvent.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WaitForDebugEvent", lpDebugEvent, dwMilliseconds);
            }
            return (int)mh$.invokeExact(lpDebugEvent, dwMilliseconds);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DebugActiveProcess {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("DebugActiveProcess"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL DebugActiveProcess(DWORD dwProcessId)
     * }
     */
    public static FunctionDescriptor DebugActiveProcess$descriptor() {
        return DebugActiveProcess.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL DebugActiveProcess(DWORD dwProcessId)
     * }
     */
    public static MethodHandle DebugActiveProcess$handle() {
        return DebugActiveProcess.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL DebugActiveProcess(DWORD dwProcessId)
     * }
     */
    public static int DebugActiveProcess(int dwProcessId) {
        var mh$ = DebugActiveProcess.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DebugActiveProcess", dwProcessId);
            }
            return (int)mh$.invokeExact(dwProcessId);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DebugActiveProcessStop {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("DebugActiveProcessStop"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL DebugActiveProcessStop(DWORD dwProcessId)
     * }
     */
    public static FunctionDescriptor DebugActiveProcessStop$descriptor() {
        return DebugActiveProcessStop.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL DebugActiveProcessStop(DWORD dwProcessId)
     * }
     */
    public static MethodHandle DebugActiveProcessStop$handle() {
        return DebugActiveProcessStop.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL DebugActiveProcessStop(DWORD dwProcessId)
     * }
     */
    public static int DebugActiveProcessStop(int dwProcessId) {
        var mh$ = DebugActiveProcessStop.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DebugActiveProcessStop", dwProcessId);
            }
            return (int)mh$.invokeExact(dwProcessId);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CheckRemoteDebuggerPresent {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CheckRemoteDebuggerPresent"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CheckRemoteDebuggerPresent(HANDLE hProcess, PBOOL pbDebuggerPresent)
     * }
     */
    public static FunctionDescriptor CheckRemoteDebuggerPresent$descriptor() {
        return CheckRemoteDebuggerPresent.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CheckRemoteDebuggerPresent(HANDLE hProcess, PBOOL pbDebuggerPresent)
     * }
     */
    public static MethodHandle CheckRemoteDebuggerPresent$handle() {
        return CheckRemoteDebuggerPresent.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL CheckRemoteDebuggerPresent(HANDLE hProcess, PBOOL pbDebuggerPresent)
     * }
     */
    public static int CheckRemoteDebuggerPresent(MemorySegment hProcess, MemorySegment pbDebuggerPresent) {
        var mh$ = CheckRemoteDebuggerPresent.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CheckRemoteDebuggerPresent", hProcess, pbDebuggerPresent);
            }
            return (int)mh$.invokeExact(hProcess, pbDebuggerPresent);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class WaitForDebugEventEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("WaitForDebugEventEx"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL WaitForDebugEventEx(LPDEBUG_EVENT lpDebugEvent, DWORD dwMilliseconds)
     * }
     */
    public static FunctionDescriptor WaitForDebugEventEx$descriptor() {
        return WaitForDebugEventEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL WaitForDebugEventEx(LPDEBUG_EVENT lpDebugEvent, DWORD dwMilliseconds)
     * }
     */
    public static MethodHandle WaitForDebugEventEx$handle() {
        return WaitForDebugEventEx.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL WaitForDebugEventEx(LPDEBUG_EVENT lpDebugEvent, DWORD dwMilliseconds)
     * }
     */
    public static int WaitForDebugEventEx(MemorySegment lpDebugEvent, int dwMilliseconds) {
        var mh$ = WaitForDebugEventEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WaitForDebugEventEx", lpDebugEvent, dwMilliseconds);
            }
            return (int)mh$.invokeExact(lpDebugEvent, dwMilliseconds);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class EncodePointer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("EncodePointer"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PVOID EncodePointer(PVOID Ptr)
     * }
     */
    public static FunctionDescriptor EncodePointer$descriptor() {
        return EncodePointer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PVOID EncodePointer(PVOID Ptr)
     * }
     */
    public static MethodHandle EncodePointer$handle() {
        return EncodePointer.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * PVOID EncodePointer(PVOID Ptr)
     * }
     */
    public static MemorySegment EncodePointer(MemorySegment Ptr) {
        var mh$ = EncodePointer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("EncodePointer", Ptr);
            }
            return (MemorySegment)mh$.invokeExact(Ptr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DecodePointer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("DecodePointer"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PVOID DecodePointer(PVOID Ptr)
     * }
     */
    public static FunctionDescriptor DecodePointer$descriptor() {
        return DecodePointer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PVOID DecodePointer(PVOID Ptr)
     * }
     */
    public static MethodHandle DecodePointer$handle() {
        return DecodePointer.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * PVOID DecodePointer(PVOID Ptr)
     * }
     */
    public static MemorySegment DecodePointer(MemorySegment Ptr) {
        var mh$ = DecodePointer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DecodePointer", Ptr);
            }
            return (MemorySegment)mh$.invokeExact(Ptr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class EncodeSystemPointer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("EncodeSystemPointer"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PVOID EncodeSystemPointer(PVOID Ptr)
     * }
     */
    public static FunctionDescriptor EncodeSystemPointer$descriptor() {
        return EncodeSystemPointer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PVOID EncodeSystemPointer(PVOID Ptr)
     * }
     */
    public static MethodHandle EncodeSystemPointer$handle() {
        return EncodeSystemPointer.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * PVOID EncodeSystemPointer(PVOID Ptr)
     * }
     */
    public static MemorySegment EncodeSystemPointer(MemorySegment Ptr) {
        var mh$ = EncodeSystemPointer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("EncodeSystemPointer", Ptr);
            }
            return (MemorySegment)mh$.invokeExact(Ptr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DecodeSystemPointer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("DecodeSystemPointer"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PVOID DecodeSystemPointer(PVOID Ptr)
     * }
     */
    public static FunctionDescriptor DecodeSystemPointer$descriptor() {
        return DecodeSystemPointer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PVOID DecodeSystemPointer(PVOID Ptr)
     * }
     */
    public static MethodHandle DecodeSystemPointer$handle() {
        return DecodeSystemPointer.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * PVOID DecodeSystemPointer(PVOID Ptr)
     * }
     */
    public static MemorySegment DecodeSystemPointer(MemorySegment Ptr) {
        var mh$ = DecodeSystemPointer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DecodeSystemPointer", Ptr);
            }
            return (MemorySegment)mh$.invokeExact(Ptr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class EncodeRemotePointer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("EncodeRemotePointer"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HRESULT EncodeRemotePointer(HANDLE ProcessHandle, PVOID Ptr, PVOID *EncodedPtr)
     * }
     */
    public static FunctionDescriptor EncodeRemotePointer$descriptor() {
        return EncodeRemotePointer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HRESULT EncodeRemotePointer(HANDLE ProcessHandle, PVOID Ptr, PVOID *EncodedPtr)
     * }
     */
    public static MethodHandle EncodeRemotePointer$handle() {
        return EncodeRemotePointer.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * HRESULT EncodeRemotePointer(HANDLE ProcessHandle, PVOID Ptr, PVOID *EncodedPtr)
     * }
     */
    public static int EncodeRemotePointer(MemorySegment ProcessHandle, MemorySegment Ptr, MemorySegment EncodedPtr) {
        var mh$ = EncodeRemotePointer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("EncodeRemotePointer", ProcessHandle, Ptr, EncodedPtr);
            }
            return (int)mh$.invokeExact(ProcessHandle, Ptr, EncodedPtr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DecodeRemotePointer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("DecodeRemotePointer"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HRESULT DecodeRemotePointer(HANDLE ProcessHandle, PVOID Ptr, PVOID *DecodedPtr)
     * }
     */
    public static FunctionDescriptor DecodeRemotePointer$descriptor() {
        return DecodeRemotePointer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HRESULT DecodeRemotePointer(HANDLE ProcessHandle, PVOID Ptr, PVOID *DecodedPtr)
     * }
     */
    public static MethodHandle DecodeRemotePointer$handle() {
        return DecodeRemotePointer.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * HRESULT DecodeRemotePointer(HANDLE ProcessHandle, PVOID Ptr, PVOID *DecodedPtr)
     * }
     */
    public static int DecodeRemotePointer(MemorySegment ProcessHandle, MemorySegment Ptr, MemorySegment DecodedPtr) {
        var mh$ = DecodeRemotePointer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DecodeRemotePointer", ProcessHandle, Ptr, DecodedPtr);
            }
            return (int)mh$.invokeExact(ProcessHandle, Ptr, DecodedPtr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Beep {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_LONG,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("Beep"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL Beep(DWORD dwFreq, DWORD dwDuration)
     * }
     */
    public static FunctionDescriptor Beep$descriptor() {
        return Beep.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL Beep(DWORD dwFreq, DWORD dwDuration)
     * }
     */
    public static MethodHandle Beep$handle() {
        return Beep.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL Beep(DWORD dwFreq, DWORD dwDuration)
     * }
     */
    public static int Beep(int dwFreq, int dwDuration) {
        var mh$ = Beep.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Beep", dwFreq, dwDuration);
            }
            return (int)mh$.invokeExact(dwFreq, dwDuration);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CloseHandle {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CloseHandle"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CloseHandle(HANDLE hObject)
     * }
     */
    public static FunctionDescriptor CloseHandle$descriptor() {
        return CloseHandle.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CloseHandle(HANDLE hObject)
     * }
     */
    public static MethodHandle CloseHandle$handle() {
        return CloseHandle.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL CloseHandle(HANDLE hObject)
     * }
     */
    public static int CloseHandle(MemorySegment hObject) {
        var mh$ = CloseHandle.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CloseHandle", hObject);
            }
            return (int)mh$.invokeExact(hObject);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DuplicateHandle {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_LONG,
            C_INT,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("DuplicateHandle"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL DuplicateHandle(HANDLE hSourceProcessHandle, HANDLE hSourceHandle, HANDLE hTargetProcessHandle, LPHANDLE lpTargetHandle, DWORD dwDesiredAccess, BOOL bInheritHandle, DWORD dwOptions)
     * }
     */
    public static FunctionDescriptor DuplicateHandle$descriptor() {
        return DuplicateHandle.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL DuplicateHandle(HANDLE hSourceProcessHandle, HANDLE hSourceHandle, HANDLE hTargetProcessHandle, LPHANDLE lpTargetHandle, DWORD dwDesiredAccess, BOOL bInheritHandle, DWORD dwOptions)
     * }
     */
    public static MethodHandle DuplicateHandle$handle() {
        return DuplicateHandle.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL DuplicateHandle(HANDLE hSourceProcessHandle, HANDLE hSourceHandle, HANDLE hTargetProcessHandle, LPHANDLE lpTargetHandle, DWORD dwDesiredAccess, BOOL bInheritHandle, DWORD dwOptions)
     * }
     */
    public static int DuplicateHandle(MemorySegment hSourceProcessHandle, MemorySegment hSourceHandle, MemorySegment hTargetProcessHandle, MemorySegment lpTargetHandle, int dwDesiredAccess, int bInheritHandle, int dwOptions) {
        var mh$ = DuplicateHandle.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DuplicateHandle", hSourceProcessHandle, hSourceHandle, hTargetProcessHandle, lpTargetHandle, dwDesiredAccess, bInheritHandle, dwOptions);
            }
            return (int)mh$.invokeExact(hSourceProcessHandle, hSourceHandle, hTargetProcessHandle, lpTargetHandle, dwDesiredAccess, bInheritHandle, dwOptions);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CompareObjectHandles {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CompareObjectHandles"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CompareObjectHandles(HANDLE hFirstObjectHandle, HANDLE hSecondObjectHandle)
     * }
     */
    public static FunctionDescriptor CompareObjectHandles$descriptor() {
        return CompareObjectHandles.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CompareObjectHandles(HANDLE hFirstObjectHandle, HANDLE hSecondObjectHandle)
     * }
     */
    public static MethodHandle CompareObjectHandles$handle() {
        return CompareObjectHandles.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL CompareObjectHandles(HANDLE hFirstObjectHandle, HANDLE hSecondObjectHandle)
     * }
     */
    public static int CompareObjectHandles(MemorySegment hFirstObjectHandle, MemorySegment hSecondObjectHandle) {
        var mh$ = CompareObjectHandles.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CompareObjectHandles", hFirstObjectHandle, hSecondObjectHandle);
            }
            return (int)mh$.invokeExact(hFirstObjectHandle, hSecondObjectHandle);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetHandleInformation {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetHandleInformation"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetHandleInformation(HANDLE hObject, LPDWORD lpdwFlags)
     * }
     */
    public static FunctionDescriptor GetHandleInformation$descriptor() {
        return GetHandleInformation.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetHandleInformation(HANDLE hObject, LPDWORD lpdwFlags)
     * }
     */
    public static MethodHandle GetHandleInformation$handle() {
        return GetHandleInformation.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL GetHandleInformation(HANDLE hObject, LPDWORD lpdwFlags)
     * }
     */
    public static int GetHandleInformation(MemorySegment hObject, MemorySegment lpdwFlags) {
        var mh$ = GetHandleInformation.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetHandleInformation", hObject, lpdwFlags);
            }
            return (int)mh$.invokeExact(hObject, lpdwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetHandleInformation {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_LONG,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("SetHandleInformation"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetHandleInformation(HANDLE hObject, DWORD dwMask, DWORD dwFlags)
     * }
     */
    public static FunctionDescriptor SetHandleInformation$descriptor() {
        return SetHandleInformation.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetHandleInformation(HANDLE hObject, DWORD dwMask, DWORD dwFlags)
     * }
     */
    public static MethodHandle SetHandleInformation$handle() {
        return SetHandleInformation.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL SetHandleInformation(HANDLE hObject, DWORD dwMask, DWORD dwFlags)
     * }
     */
    public static int SetHandleInformation(MemorySegment hObject, int dwMask, int dwFlags) {
        var mh$ = SetHandleInformation.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetHandleInformation", hObject, dwMask, dwFlags);
            }
            return (int)mh$.invokeExact(hObject, dwMask, dwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RaiseException {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C_LONG,
            C_LONG,
            C_LONG,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("RaiseException"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void RaiseException(DWORD dwExceptionCode, DWORD dwExceptionFlags, DWORD nNumberOfArguments, const ULONG_PTR *lpArguments)
     * }
     */
    public static FunctionDescriptor RaiseException$descriptor() {
        return RaiseException.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void RaiseException(DWORD dwExceptionCode, DWORD dwExceptionFlags, DWORD nNumberOfArguments, const ULONG_PTR *lpArguments)
     * }
     */
    public static MethodHandle RaiseException$handle() {
        return RaiseException.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * void RaiseException(DWORD dwExceptionCode, DWORD dwExceptionFlags, DWORD nNumberOfArguments, const ULONG_PTR *lpArguments)
     * }
     */
    public static void RaiseException(int dwExceptionCode, int dwExceptionFlags, int nNumberOfArguments, MemorySegment lpArguments) {
        var mh$ = RaiseException.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RaiseException", dwExceptionCode, dwExceptionFlags, nNumberOfArguments, lpArguments);
            }
            mh$.invokeExact(dwExceptionCode, dwExceptionFlags, nNumberOfArguments, lpArguments);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class UnhandledExceptionFilter {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("UnhandledExceptionFilter"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LONG UnhandledExceptionFilter(struct _EXCEPTION_POINTERS *ExceptionInfo)
     * }
     */
    public static FunctionDescriptor UnhandledExceptionFilter$descriptor() {
        return UnhandledExceptionFilter.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LONG UnhandledExceptionFilter(struct _EXCEPTION_POINTERS *ExceptionInfo)
     * }
     */
    public static MethodHandle UnhandledExceptionFilter$handle() {
        return UnhandledExceptionFilter.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * LONG UnhandledExceptionFilter(struct _EXCEPTION_POINTERS *ExceptionInfo)
     * }
     */
    public static int UnhandledExceptionFilter(MemorySegment ExceptionInfo) {
        var mh$ = UnhandledExceptionFilter.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("UnhandledExceptionFilter", ExceptionInfo);
            }
            return (int)mh$.invokeExact(ExceptionInfo);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetUnhandledExceptionFilter {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("SetUnhandledExceptionFilter"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LPTOP_LEVEL_EXCEPTION_FILTER SetUnhandledExceptionFilter(LPTOP_LEVEL_EXCEPTION_FILTER lpTopLevelExceptionFilter)
     * }
     */
    public static FunctionDescriptor SetUnhandledExceptionFilter$descriptor() {
        return SetUnhandledExceptionFilter.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LPTOP_LEVEL_EXCEPTION_FILTER SetUnhandledExceptionFilter(LPTOP_LEVEL_EXCEPTION_FILTER lpTopLevelExceptionFilter)
     * }
     */
    public static MethodHandle SetUnhandledExceptionFilter$handle() {
        return SetUnhandledExceptionFilter.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * LPTOP_LEVEL_EXCEPTION_FILTER SetUnhandledExceptionFilter(LPTOP_LEVEL_EXCEPTION_FILTER lpTopLevelExceptionFilter)
     * }
     */
    public static MemorySegment SetUnhandledExceptionFilter(MemorySegment lpTopLevelExceptionFilter) {
        var mh$ = SetUnhandledExceptionFilter.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetUnhandledExceptionFilter", lpTopLevelExceptionFilter);
            }
            return (MemorySegment)mh$.invokeExact(lpTopLevelExceptionFilter);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetLastError {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG    );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetLastError"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetLastError()
     * }
     */
    public static FunctionDescriptor GetLastError$descriptor() {
        return GetLastError.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetLastError()
     * }
     */
    public static MethodHandle GetLastError$handle() {
        return GetLastError.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * DWORD GetLastError()
     * }
     */
    public static int GetLastError() {
        var mh$ = GetLastError.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetLastError");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetLastError {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("SetLastError"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SetLastError(DWORD dwErrCode)
     * }
     */
    public static FunctionDescriptor SetLastError$descriptor() {
        return SetLastError.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SetLastError(DWORD dwErrCode)
     * }
     */
    public static MethodHandle SetLastError$handle() {
        return SetLastError.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * void SetLastError(DWORD dwErrCode)
     * }
     */
    public static void SetLastError(int dwErrCode) {
        var mh$ = SetLastError.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetLastError", dwErrCode);
            }
            mh$.invokeExact(dwErrCode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetErrorMode {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT    );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetErrorMode"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * UINT GetErrorMode()
     * }
     */
    public static FunctionDescriptor GetErrorMode$descriptor() {
        return GetErrorMode.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * UINT GetErrorMode()
     * }
     */
    public static MethodHandle GetErrorMode$handle() {
        return GetErrorMode.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * UINT GetErrorMode()
     * }
     */
    public static int GetErrorMode() {
        var mh$ = GetErrorMode.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetErrorMode");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetErrorMode {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("SetErrorMode"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * UINT SetErrorMode(UINT uMode)
     * }
     */
    public static FunctionDescriptor SetErrorMode$descriptor() {
        return SetErrorMode.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * UINT SetErrorMode(UINT uMode)
     * }
     */
    public static MethodHandle SetErrorMode$handle() {
        return SetErrorMode.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * UINT SetErrorMode(UINT uMode)
     * }
     */
    public static int SetErrorMode(int uMode) {
        var mh$ = SetErrorMode.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetErrorMode", uMode);
            }
            return (int)mh$.invokeExact(uMode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class AddVectoredExceptionHandler {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_LONG,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("AddVectoredExceptionHandler"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PVOID AddVectoredExceptionHandler(ULONG First, PVECTORED_EXCEPTION_HANDLER Handler)
     * }
     */
    public static FunctionDescriptor AddVectoredExceptionHandler$descriptor() {
        return AddVectoredExceptionHandler.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PVOID AddVectoredExceptionHandler(ULONG First, PVECTORED_EXCEPTION_HANDLER Handler)
     * }
     */
    public static MethodHandle AddVectoredExceptionHandler$handle() {
        return AddVectoredExceptionHandler.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * PVOID AddVectoredExceptionHandler(ULONG First, PVECTORED_EXCEPTION_HANDLER Handler)
     * }
     */
    public static MemorySegment AddVectoredExceptionHandler(int First, MemorySegment Handler) {
        var mh$ = AddVectoredExceptionHandler.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("AddVectoredExceptionHandler", First, Handler);
            }
            return (MemorySegment)mh$.invokeExact(First, Handler);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RemoveVectoredExceptionHandler {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("RemoveVectoredExceptionHandler"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ULONG RemoveVectoredExceptionHandler(PVOID Handle)
     * }
     */
    public static FunctionDescriptor RemoveVectoredExceptionHandler$descriptor() {
        return RemoveVectoredExceptionHandler.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ULONG RemoveVectoredExceptionHandler(PVOID Handle)
     * }
     */
    public static MethodHandle RemoveVectoredExceptionHandler$handle() {
        return RemoveVectoredExceptionHandler.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * ULONG RemoveVectoredExceptionHandler(PVOID Handle)
     * }
     */
    public static int RemoveVectoredExceptionHandler(MemorySegment Handle) {
        var mh$ = RemoveVectoredExceptionHandler.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RemoveVectoredExceptionHandler", Handle);
            }
            return (int)mh$.invokeExact(Handle);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class AddVectoredContinueHandler {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_LONG,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("AddVectoredContinueHandler"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PVOID AddVectoredContinueHandler(ULONG First, PVECTORED_EXCEPTION_HANDLER Handler)
     * }
     */
    public static FunctionDescriptor AddVectoredContinueHandler$descriptor() {
        return AddVectoredContinueHandler.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PVOID AddVectoredContinueHandler(ULONG First, PVECTORED_EXCEPTION_HANDLER Handler)
     * }
     */
    public static MethodHandle AddVectoredContinueHandler$handle() {
        return AddVectoredContinueHandler.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * PVOID AddVectoredContinueHandler(ULONG First, PVECTORED_EXCEPTION_HANDLER Handler)
     * }
     */
    public static MemorySegment AddVectoredContinueHandler(int First, MemorySegment Handler) {
        var mh$ = AddVectoredContinueHandler.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("AddVectoredContinueHandler", First, Handler);
            }
            return (MemorySegment)mh$.invokeExact(First, Handler);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RemoveVectoredContinueHandler {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("RemoveVectoredContinueHandler"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ULONG RemoveVectoredContinueHandler(PVOID Handle)
     * }
     */
    public static FunctionDescriptor RemoveVectoredContinueHandler$descriptor() {
        return RemoveVectoredContinueHandler.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ULONG RemoveVectoredContinueHandler(PVOID Handle)
     * }
     */
    public static MethodHandle RemoveVectoredContinueHandler$handle() {
        return RemoveVectoredContinueHandler.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * ULONG RemoveVectoredContinueHandler(PVOID Handle)
     * }
     */
    public static int RemoveVectoredContinueHandler(MemorySegment Handle) {
        var mh$ = RemoveVectoredContinueHandler.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RemoveVectoredContinueHandler", Handle);
            }
            return (int)mh$.invokeExact(Handle);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RaiseFailFastException {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C_POINTER,
            C_POINTER,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("RaiseFailFastException"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void RaiseFailFastException(PEXCEPTION_RECORD pExceptionRecord, PCONTEXT pContextRecord, DWORD dwFlags)
     * }
     */
    public static FunctionDescriptor RaiseFailFastException$descriptor() {
        return RaiseFailFastException.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void RaiseFailFastException(PEXCEPTION_RECORD pExceptionRecord, PCONTEXT pContextRecord, DWORD dwFlags)
     * }
     */
    public static MethodHandle RaiseFailFastException$handle() {
        return RaiseFailFastException.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * void RaiseFailFastException(PEXCEPTION_RECORD pExceptionRecord, PCONTEXT pContextRecord, DWORD dwFlags)
     * }
     */
    public static void RaiseFailFastException(MemorySegment pExceptionRecord, MemorySegment pContextRecord, int dwFlags) {
        var mh$ = RaiseFailFastException.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RaiseFailFastException", pExceptionRecord, pContextRecord, dwFlags);
            }
            mh$.invokeExact(pExceptionRecord, pContextRecord, dwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FatalAppExitA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("FatalAppExitA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void FatalAppExitA(UINT uAction, LPCSTR lpMessageText)
     * }
     */
    public static FunctionDescriptor FatalAppExitA$descriptor() {
        return FatalAppExitA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void FatalAppExitA(UINT uAction, LPCSTR lpMessageText)
     * }
     */
    public static MethodHandle FatalAppExitA$handle() {
        return FatalAppExitA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * void FatalAppExitA(UINT uAction, LPCSTR lpMessageText)
     * }
     */
    public static void FatalAppExitA(int uAction, MemorySegment lpMessageText) {
        var mh$ = FatalAppExitA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FatalAppExitA", uAction, lpMessageText);
            }
            mh$.invokeExact(uAction, lpMessageText);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FatalAppExitW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("FatalAppExitW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void FatalAppExitW(UINT uAction, LPCWSTR lpMessageText)
     * }
     */
    public static FunctionDescriptor FatalAppExitW$descriptor() {
        return FatalAppExitW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void FatalAppExitW(UINT uAction, LPCWSTR lpMessageText)
     * }
     */
    public static MethodHandle FatalAppExitW$handle() {
        return FatalAppExitW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * void FatalAppExitW(UINT uAction, LPCWSTR lpMessageText)
     * }
     */
    public static void FatalAppExitW(int uAction, MemorySegment lpMessageText) {
        var mh$ = FatalAppExitW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FatalAppExitW", uAction, lpMessageText);
            }
            mh$.invokeExact(uAction, lpMessageText);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetThreadErrorMode {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG    );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetThreadErrorMode"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetThreadErrorMode()
     * }
     */
    public static FunctionDescriptor GetThreadErrorMode$descriptor() {
        return GetThreadErrorMode.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetThreadErrorMode()
     * }
     */
    public static MethodHandle GetThreadErrorMode$handle() {
        return GetThreadErrorMode.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * DWORD GetThreadErrorMode()
     * }
     */
    public static int GetThreadErrorMode() {
        var mh$ = GetThreadErrorMode.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetThreadErrorMode");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetThreadErrorMode {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_LONG,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("SetThreadErrorMode"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetThreadErrorMode(DWORD dwNewMode, LPDWORD lpOldMode)
     * }
     */
    public static FunctionDescriptor SetThreadErrorMode$descriptor() {
        return SetThreadErrorMode.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetThreadErrorMode(DWORD dwNewMode, LPDWORD lpOldMode)
     * }
     */
    public static MethodHandle SetThreadErrorMode$handle() {
        return SetThreadErrorMode.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL SetThreadErrorMode(DWORD dwNewMode, LPDWORD lpOldMode)
     * }
     */
    public static int SetThreadErrorMode(int dwNewMode, MemorySegment lpOldMode) {
        var mh$ = SetThreadErrorMode.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetThreadErrorMode", dwNewMode, lpOldMode);
            }
            return (int)mh$.invokeExact(dwNewMode, lpOldMode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TerminateProcessOnMemoryExhaustion {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C_LONG_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("TerminateProcessOnMemoryExhaustion"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void TerminateProcessOnMemoryExhaustion(SIZE_T FailedAllocationSize)
     * }
     */
    public static FunctionDescriptor TerminateProcessOnMemoryExhaustion$descriptor() {
        return TerminateProcessOnMemoryExhaustion.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void TerminateProcessOnMemoryExhaustion(SIZE_T FailedAllocationSize)
     * }
     */
    public static MethodHandle TerminateProcessOnMemoryExhaustion$handle() {
        return TerminateProcessOnMemoryExhaustion.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * void TerminateProcessOnMemoryExhaustion(SIZE_T FailedAllocationSize)
     * }
     */
    public static void TerminateProcessOnMemoryExhaustion(long FailedAllocationSize) {
        var mh$ = TerminateProcessOnMemoryExhaustion.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TerminateProcessOnMemoryExhaustion", FailedAllocationSize);
            }
            mh$.invokeExact(FailedAllocationSize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FlsAlloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("FlsAlloc"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD FlsAlloc(PFLS_CALLBACK_FUNCTION lpCallback)
     * }
     */
    public static FunctionDescriptor FlsAlloc$descriptor() {
        return FlsAlloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD FlsAlloc(PFLS_CALLBACK_FUNCTION lpCallback)
     * }
     */
    public static MethodHandle FlsAlloc$handle() {
        return FlsAlloc.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * DWORD FlsAlloc(PFLS_CALLBACK_FUNCTION lpCallback)
     * }
     */
    public static int FlsAlloc(MemorySegment lpCallback) {
        var mh$ = FlsAlloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FlsAlloc", lpCallback);
            }
            return (int)mh$.invokeExact(lpCallback);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FlsGetValue {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("FlsGetValue"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PVOID FlsGetValue(DWORD dwFlsIndex)
     * }
     */
    public static FunctionDescriptor FlsGetValue$descriptor() {
        return FlsGetValue.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PVOID FlsGetValue(DWORD dwFlsIndex)
     * }
     */
    public static MethodHandle FlsGetValue$handle() {
        return FlsGetValue.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * PVOID FlsGetValue(DWORD dwFlsIndex)
     * }
     */
    public static MemorySegment FlsGetValue(int dwFlsIndex) {
        var mh$ = FlsGetValue.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FlsGetValue", dwFlsIndex);
            }
            return (MemorySegment)mh$.invokeExact(dwFlsIndex);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FlsSetValue {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_LONG,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("FlsSetValue"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL FlsSetValue(DWORD dwFlsIndex, PVOID lpFlsData)
     * }
     */
    public static FunctionDescriptor FlsSetValue$descriptor() {
        return FlsSetValue.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL FlsSetValue(DWORD dwFlsIndex, PVOID lpFlsData)
     * }
     */
    public static MethodHandle FlsSetValue$handle() {
        return FlsSetValue.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL FlsSetValue(DWORD dwFlsIndex, PVOID lpFlsData)
     * }
     */
    public static int FlsSetValue(int dwFlsIndex, MemorySegment lpFlsData) {
        var mh$ = FlsSetValue.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FlsSetValue", dwFlsIndex, lpFlsData);
            }
            return (int)mh$.invokeExact(dwFlsIndex, lpFlsData);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FlsFree {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("FlsFree"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL FlsFree(DWORD dwFlsIndex)
     * }
     */
    public static FunctionDescriptor FlsFree$descriptor() {
        return FlsFree.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL FlsFree(DWORD dwFlsIndex)
     * }
     */
    public static MethodHandle FlsFree$handle() {
        return FlsFree.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL FlsFree(DWORD dwFlsIndex)
     * }
     */
    public static int FlsFree(int dwFlsIndex) {
        var mh$ = FlsFree.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FlsFree", dwFlsIndex);
            }
            return (int)mh$.invokeExact(dwFlsIndex);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class IsThreadAFiber {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT    );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("IsThreadAFiber"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL IsThreadAFiber()
     * }
     */
    public static FunctionDescriptor IsThreadAFiber$descriptor() {
        return IsThreadAFiber.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL IsThreadAFiber()
     * }
     */
    public static MethodHandle IsThreadAFiber$handle() {
        return IsThreadAFiber.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL IsThreadAFiber()
     * }
     */
    public static int IsThreadAFiber() {
        var mh$ = IsThreadAFiber.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("IsThreadAFiber");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreatePipe {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CreatePipe"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CreatePipe(PHANDLE hReadPipe, PHANDLE hWritePipe, LPSECURITY_ATTRIBUTES lpPipeAttributes, DWORD nSize)
     * }
     */
    public static FunctionDescriptor CreatePipe$descriptor() {
        return CreatePipe.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CreatePipe(PHANDLE hReadPipe, PHANDLE hWritePipe, LPSECURITY_ATTRIBUTES lpPipeAttributes, DWORD nSize)
     * }
     */
    public static MethodHandle CreatePipe$handle() {
        return CreatePipe.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL CreatePipe(PHANDLE hReadPipe, PHANDLE hWritePipe, LPSECURITY_ATTRIBUTES lpPipeAttributes, DWORD nSize)
     * }
     */
    public static int CreatePipe(MemorySegment hReadPipe, MemorySegment hWritePipe, MemorySegment lpPipeAttributes, int nSize) {
        var mh$ = CreatePipe.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreatePipe", hReadPipe, hWritePipe, lpPipeAttributes, nSize);
            }
            return (int)mh$.invokeExact(hReadPipe, hWritePipe, lpPipeAttributes, nSize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ConnectNamedPipe {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("ConnectNamedPipe"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL ConnectNamedPipe(HANDLE hNamedPipe, LPOVERLAPPED lpOverlapped)
     * }
     */
    public static FunctionDescriptor ConnectNamedPipe$descriptor() {
        return ConnectNamedPipe.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL ConnectNamedPipe(HANDLE hNamedPipe, LPOVERLAPPED lpOverlapped)
     * }
     */
    public static MethodHandle ConnectNamedPipe$handle() {
        return ConnectNamedPipe.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL ConnectNamedPipe(HANDLE hNamedPipe, LPOVERLAPPED lpOverlapped)
     * }
     */
    public static int ConnectNamedPipe(MemorySegment hNamedPipe, MemorySegment lpOverlapped) {
        var mh$ = ConnectNamedPipe.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ConnectNamedPipe", hNamedPipe, lpOverlapped);
            }
            return (int)mh$.invokeExact(hNamedPipe, lpOverlapped);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DisconnectNamedPipe {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("DisconnectNamedPipe"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL DisconnectNamedPipe(HANDLE hNamedPipe)
     * }
     */
    public static FunctionDescriptor DisconnectNamedPipe$descriptor() {
        return DisconnectNamedPipe.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL DisconnectNamedPipe(HANDLE hNamedPipe)
     * }
     */
    public static MethodHandle DisconnectNamedPipe$handle() {
        return DisconnectNamedPipe.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL DisconnectNamedPipe(HANDLE hNamedPipe)
     * }
     */
    public static int DisconnectNamedPipe(MemorySegment hNamedPipe) {
        var mh$ = DisconnectNamedPipe.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DisconnectNamedPipe", hNamedPipe);
            }
            return (int)mh$.invokeExact(hNamedPipe);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetNamedPipeHandleState {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("SetNamedPipeHandleState"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetNamedPipeHandleState(HANDLE hNamedPipe, LPDWORD lpMode, LPDWORD lpMaxCollectionCount, LPDWORD lpCollectDataTimeout)
     * }
     */
    public static FunctionDescriptor SetNamedPipeHandleState$descriptor() {
        return SetNamedPipeHandleState.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetNamedPipeHandleState(HANDLE hNamedPipe, LPDWORD lpMode, LPDWORD lpMaxCollectionCount, LPDWORD lpCollectDataTimeout)
     * }
     */
    public static MethodHandle SetNamedPipeHandleState$handle() {
        return SetNamedPipeHandleState.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL SetNamedPipeHandleState(HANDLE hNamedPipe, LPDWORD lpMode, LPDWORD lpMaxCollectionCount, LPDWORD lpCollectDataTimeout)
     * }
     */
    public static int SetNamedPipeHandleState(MemorySegment hNamedPipe, MemorySegment lpMode, MemorySegment lpMaxCollectionCount, MemorySegment lpCollectDataTimeout) {
        var mh$ = SetNamedPipeHandleState.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetNamedPipeHandleState", hNamedPipe, lpMode, lpMaxCollectionCount, lpCollectDataTimeout);
            }
            return (int)mh$.invokeExact(hNamedPipe, lpMode, lpMaxCollectionCount, lpCollectDataTimeout);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PeekNamedPipe {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_LONG,
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("PeekNamedPipe"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL PeekNamedPipe(HANDLE hNamedPipe, LPVOID lpBuffer, DWORD nBufferSize, LPDWORD lpBytesRead, LPDWORD lpTotalBytesAvail, LPDWORD lpBytesLeftThisMessage)
     * }
     */
    public static FunctionDescriptor PeekNamedPipe$descriptor() {
        return PeekNamedPipe.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL PeekNamedPipe(HANDLE hNamedPipe, LPVOID lpBuffer, DWORD nBufferSize, LPDWORD lpBytesRead, LPDWORD lpTotalBytesAvail, LPDWORD lpBytesLeftThisMessage)
     * }
     */
    public static MethodHandle PeekNamedPipe$handle() {
        return PeekNamedPipe.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL PeekNamedPipe(HANDLE hNamedPipe, LPVOID lpBuffer, DWORD nBufferSize, LPDWORD lpBytesRead, LPDWORD lpTotalBytesAvail, LPDWORD lpBytesLeftThisMessage)
     * }
     */
    public static int PeekNamedPipe(MemorySegment hNamedPipe, MemorySegment lpBuffer, int nBufferSize, MemorySegment lpBytesRead, MemorySegment lpTotalBytesAvail, MemorySegment lpBytesLeftThisMessage) {
        var mh$ = PeekNamedPipe.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PeekNamedPipe", hNamedPipe, lpBuffer, nBufferSize, lpBytesRead, lpTotalBytesAvail, lpBytesLeftThisMessage);
            }
            return (int)mh$.invokeExact(hNamedPipe, lpBuffer, nBufferSize, lpBytesRead, lpTotalBytesAvail, lpBytesLeftThisMessage);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TransactNamedPipe {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_LONG,
            C_POINTER,
            C_LONG,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("TransactNamedPipe"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL TransactNamedPipe(HANDLE hNamedPipe, LPVOID lpInBuffer, DWORD nInBufferSize, LPVOID lpOutBuffer, DWORD nOutBufferSize, LPDWORD lpBytesRead, LPOVERLAPPED lpOverlapped)
     * }
     */
    public static FunctionDescriptor TransactNamedPipe$descriptor() {
        return TransactNamedPipe.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL TransactNamedPipe(HANDLE hNamedPipe, LPVOID lpInBuffer, DWORD nInBufferSize, LPVOID lpOutBuffer, DWORD nOutBufferSize, LPDWORD lpBytesRead, LPOVERLAPPED lpOverlapped)
     * }
     */
    public static MethodHandle TransactNamedPipe$handle() {
        return TransactNamedPipe.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL TransactNamedPipe(HANDLE hNamedPipe, LPVOID lpInBuffer, DWORD nInBufferSize, LPVOID lpOutBuffer, DWORD nOutBufferSize, LPDWORD lpBytesRead, LPOVERLAPPED lpOverlapped)
     * }
     */
    public static int TransactNamedPipe(MemorySegment hNamedPipe, MemorySegment lpInBuffer, int nInBufferSize, MemorySegment lpOutBuffer, int nOutBufferSize, MemorySegment lpBytesRead, MemorySegment lpOverlapped) {
        var mh$ = TransactNamedPipe.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TransactNamedPipe", hNamedPipe, lpInBuffer, nInBufferSize, lpOutBuffer, nOutBufferSize, lpBytesRead, lpOverlapped);
            }
            return (int)mh$.invokeExact(hNamedPipe, lpInBuffer, nInBufferSize, lpOutBuffer, nOutBufferSize, lpBytesRead, lpOverlapped);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateNamedPipeW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER,
            C_LONG,
            C_LONG,
            C_LONG,
            C_LONG,
            C_LONG,
            C_LONG,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CreateNamedPipeW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HANDLE CreateNamedPipeW(LPCWSTR lpName, DWORD dwOpenMode, DWORD dwPipeMode, DWORD nMaxInstances, DWORD nOutBufferSize, DWORD nInBufferSize, DWORD nDefaultTimeOut, LPSECURITY_ATTRIBUTES lpSecurityAttributes)
     * }
     */
    public static FunctionDescriptor CreateNamedPipeW$descriptor() {
        return CreateNamedPipeW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HANDLE CreateNamedPipeW(LPCWSTR lpName, DWORD dwOpenMode, DWORD dwPipeMode, DWORD nMaxInstances, DWORD nOutBufferSize, DWORD nInBufferSize, DWORD nDefaultTimeOut, LPSECURITY_ATTRIBUTES lpSecurityAttributes)
     * }
     */
    public static MethodHandle CreateNamedPipeW$handle() {
        return CreateNamedPipeW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * HANDLE CreateNamedPipeW(LPCWSTR lpName, DWORD dwOpenMode, DWORD dwPipeMode, DWORD nMaxInstances, DWORD nOutBufferSize, DWORD nInBufferSize, DWORD nDefaultTimeOut, LPSECURITY_ATTRIBUTES lpSecurityAttributes)
     * }
     */
    public static MemorySegment CreateNamedPipeW(MemorySegment lpName, int dwOpenMode, int dwPipeMode, int nMaxInstances, int nOutBufferSize, int nInBufferSize, int nDefaultTimeOut, MemorySegment lpSecurityAttributes) {
        var mh$ = CreateNamedPipeW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateNamedPipeW", lpName, dwOpenMode, dwPipeMode, nMaxInstances, nOutBufferSize, nInBufferSize, nDefaultTimeOut, lpSecurityAttributes);
            }
            return (MemorySegment)mh$.invokeExact(lpName, dwOpenMode, dwPipeMode, nMaxInstances, nOutBufferSize, nInBufferSize, nDefaultTimeOut, lpSecurityAttributes);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class WaitNamedPipeW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("WaitNamedPipeW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL WaitNamedPipeW(LPCWSTR lpNamedPipeName, DWORD nTimeOut)
     * }
     */
    public static FunctionDescriptor WaitNamedPipeW$descriptor() {
        return WaitNamedPipeW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL WaitNamedPipeW(LPCWSTR lpNamedPipeName, DWORD nTimeOut)
     * }
     */
    public static MethodHandle WaitNamedPipeW$handle() {
        return WaitNamedPipeW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL WaitNamedPipeW(LPCWSTR lpNamedPipeName, DWORD nTimeOut)
     * }
     */
    public static int WaitNamedPipeW(MemorySegment lpNamedPipeName, int nTimeOut) {
        var mh$ = WaitNamedPipeW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WaitNamedPipeW", lpNamedPipeName, nTimeOut);
            }
            return (int)mh$.invokeExact(lpNamedPipeName, nTimeOut);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetNamedPipeClientComputerNameW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetNamedPipeClientComputerNameW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetNamedPipeClientComputerNameW(HANDLE Pipe, LPWSTR ClientComputerName, ULONG ClientComputerNameLength)
     * }
     */
    public static FunctionDescriptor GetNamedPipeClientComputerNameW$descriptor() {
        return GetNamedPipeClientComputerNameW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetNamedPipeClientComputerNameW(HANDLE Pipe, LPWSTR ClientComputerName, ULONG ClientComputerNameLength)
     * }
     */
    public static MethodHandle GetNamedPipeClientComputerNameW$handle() {
        return GetNamedPipeClientComputerNameW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL GetNamedPipeClientComputerNameW(HANDLE Pipe, LPWSTR ClientComputerName, ULONG ClientComputerNameLength)
     * }
     */
    public static int GetNamedPipeClientComputerNameW(MemorySegment Pipe, MemorySegment ClientComputerName, int ClientComputerNameLength) {
        var mh$ = GetNamedPipeClientComputerNameW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetNamedPipeClientComputerNameW", Pipe, ClientComputerName, ClientComputerNameLength);
            }
            return (int)mh$.invokeExact(Pipe, ClientComputerName, ClientComputerNameLength);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ImpersonateNamedPipeClient {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("ImpersonateNamedPipeClient"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL ImpersonateNamedPipeClient(HANDLE hNamedPipe)
     * }
     */
    public static FunctionDescriptor ImpersonateNamedPipeClient$descriptor() {
        return ImpersonateNamedPipeClient.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL ImpersonateNamedPipeClient(HANDLE hNamedPipe)
     * }
     */
    public static MethodHandle ImpersonateNamedPipeClient$handle() {
        return ImpersonateNamedPipeClient.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL ImpersonateNamedPipeClient(HANDLE hNamedPipe)
     * }
     */
    public static int ImpersonateNamedPipeClient(MemorySegment hNamedPipe) {
        var mh$ = ImpersonateNamedPipeClient.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ImpersonateNamedPipeClient", hNamedPipe);
            }
            return (int)mh$.invokeExact(hNamedPipe);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetNamedPipeInfo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetNamedPipeInfo"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetNamedPipeInfo(HANDLE hNamedPipe, LPDWORD lpFlags, LPDWORD lpOutBufferSize, LPDWORD lpInBufferSize, LPDWORD lpMaxInstances)
     * }
     */
    public static FunctionDescriptor GetNamedPipeInfo$descriptor() {
        return GetNamedPipeInfo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetNamedPipeInfo(HANDLE hNamedPipe, LPDWORD lpFlags, LPDWORD lpOutBufferSize, LPDWORD lpInBufferSize, LPDWORD lpMaxInstances)
     * }
     */
    public static MethodHandle GetNamedPipeInfo$handle() {
        return GetNamedPipeInfo.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL GetNamedPipeInfo(HANDLE hNamedPipe, LPDWORD lpFlags, LPDWORD lpOutBufferSize, LPDWORD lpInBufferSize, LPDWORD lpMaxInstances)
     * }
     */
    public static int GetNamedPipeInfo(MemorySegment hNamedPipe, MemorySegment lpFlags, MemorySegment lpOutBufferSize, MemorySegment lpInBufferSize, MemorySegment lpMaxInstances) {
        var mh$ = GetNamedPipeInfo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetNamedPipeInfo", hNamedPipe, lpFlags, lpOutBufferSize, lpInBufferSize, lpMaxInstances);
            }
            return (int)mh$.invokeExact(hNamedPipe, lpFlags, lpOutBufferSize, lpInBufferSize, lpMaxInstances);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetNamedPipeHandleStateW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetNamedPipeHandleStateW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetNamedPipeHandleStateW(HANDLE hNamedPipe, LPDWORD lpState, LPDWORD lpCurInstances, LPDWORD lpMaxCollectionCount, LPDWORD lpCollectDataTimeout, LPWSTR lpUserName, DWORD nMaxUserNameSize)
     * }
     */
    public static FunctionDescriptor GetNamedPipeHandleStateW$descriptor() {
        return GetNamedPipeHandleStateW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetNamedPipeHandleStateW(HANDLE hNamedPipe, LPDWORD lpState, LPDWORD lpCurInstances, LPDWORD lpMaxCollectionCount, LPDWORD lpCollectDataTimeout, LPWSTR lpUserName, DWORD nMaxUserNameSize)
     * }
     */
    public static MethodHandle GetNamedPipeHandleStateW$handle() {
        return GetNamedPipeHandleStateW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL GetNamedPipeHandleStateW(HANDLE hNamedPipe, LPDWORD lpState, LPDWORD lpCurInstances, LPDWORD lpMaxCollectionCount, LPDWORD lpCollectDataTimeout, LPWSTR lpUserName, DWORD nMaxUserNameSize)
     * }
     */
    public static int GetNamedPipeHandleStateW(MemorySegment hNamedPipe, MemorySegment lpState, MemorySegment lpCurInstances, MemorySegment lpMaxCollectionCount, MemorySegment lpCollectDataTimeout, MemorySegment lpUserName, int nMaxUserNameSize) {
        var mh$ = GetNamedPipeHandleStateW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetNamedPipeHandleStateW", hNamedPipe, lpState, lpCurInstances, lpMaxCollectionCount, lpCollectDataTimeout, lpUserName, nMaxUserNameSize);
            }
            return (int)mh$.invokeExact(hNamedPipe, lpState, lpCurInstances, lpMaxCollectionCount, lpCollectDataTimeout, lpUserName, nMaxUserNameSize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CallNamedPipeW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_LONG,
            C_POINTER,
            C_LONG,
            C_POINTER,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CallNamedPipeW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CallNamedPipeW(LPCWSTR lpNamedPipeName, LPVOID lpInBuffer, DWORD nInBufferSize, LPVOID lpOutBuffer, DWORD nOutBufferSize, LPDWORD lpBytesRead, DWORD nTimeOut)
     * }
     */
    public static FunctionDescriptor CallNamedPipeW$descriptor() {
        return CallNamedPipeW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CallNamedPipeW(LPCWSTR lpNamedPipeName, LPVOID lpInBuffer, DWORD nInBufferSize, LPVOID lpOutBuffer, DWORD nOutBufferSize, LPDWORD lpBytesRead, DWORD nTimeOut)
     * }
     */
    public static MethodHandle CallNamedPipeW$handle() {
        return CallNamedPipeW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL CallNamedPipeW(LPCWSTR lpNamedPipeName, LPVOID lpInBuffer, DWORD nInBufferSize, LPVOID lpOutBuffer, DWORD nOutBufferSize, LPDWORD lpBytesRead, DWORD nTimeOut)
     * }
     */
    public static int CallNamedPipeW(MemorySegment lpNamedPipeName, MemorySegment lpInBuffer, int nInBufferSize, MemorySegment lpOutBuffer, int nOutBufferSize, MemorySegment lpBytesRead, int nTimeOut) {
        var mh$ = CallNamedPipeW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CallNamedPipeW", lpNamedPipeName, lpInBuffer, nInBufferSize, lpOutBuffer, nOutBufferSize, lpBytesRead, nTimeOut);
            }
            return (int)mh$.invokeExact(lpNamedPipeName, lpInBuffer, nInBufferSize, lpOutBuffer, nOutBufferSize, lpBytesRead, nTimeOut);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class QueryPerformanceCounter {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("QueryPerformanceCounter"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL QueryPerformanceCounter(LARGE_INTEGER *lpPerformanceCount)
     * }
     */
    public static FunctionDescriptor QueryPerformanceCounter$descriptor() {
        return QueryPerformanceCounter.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL QueryPerformanceCounter(LARGE_INTEGER *lpPerformanceCount)
     * }
     */
    public static MethodHandle QueryPerformanceCounter$handle() {
        return QueryPerformanceCounter.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL QueryPerformanceCounter(LARGE_INTEGER *lpPerformanceCount)
     * }
     */
    public static int QueryPerformanceCounter(MemorySegment lpPerformanceCount) {
        var mh$ = QueryPerformanceCounter.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("QueryPerformanceCounter", lpPerformanceCount);
            }
            return (int)mh$.invokeExact(lpPerformanceCount);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class QueryPerformanceFrequency {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("QueryPerformanceFrequency"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL QueryPerformanceFrequency(LARGE_INTEGER *lpFrequency)
     * }
     */
    public static FunctionDescriptor QueryPerformanceFrequency$descriptor() {
        return QueryPerformanceFrequency.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL QueryPerformanceFrequency(LARGE_INTEGER *lpFrequency)
     * }
     */
    public static MethodHandle QueryPerformanceFrequency$handle() {
        return QueryPerformanceFrequency.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL QueryPerformanceFrequency(LARGE_INTEGER *lpFrequency)
     * }
     */
    public static int QueryPerformanceFrequency(MemorySegment lpFrequency) {
        var mh$ = QueryPerformanceFrequency.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("QueryPerformanceFrequency", lpFrequency);
            }
            return (int)mh$.invokeExact(lpFrequency);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct _HEAP_SUMMARY {
     *     DWORD cb;
     *     SIZE_T cbAllocated;
     *     SIZE_T cbCommitted;
     *     SIZE_T cbReserved;
     *     SIZE_T cbMaxReserve;
     * } *PHEAP_SUMMARY
     * }
     */
    public static final AddressLayout PHEAP_SUMMARY = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef PHEAP_SUMMARY LPHEAP_SUMMARY
     * }
     */
    public static final AddressLayout LPHEAP_SUMMARY = C_POINTER;

    private static class HeapCreate {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_LONG,
            C_LONG_LONG,
            C_LONG_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("HeapCreate"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HANDLE HeapCreate(DWORD flOptions, SIZE_T dwInitialSize, SIZE_T dwMaximumSize)
     * }
     */
    public static FunctionDescriptor HeapCreate$descriptor() {
        return HeapCreate.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HANDLE HeapCreate(DWORD flOptions, SIZE_T dwInitialSize, SIZE_T dwMaximumSize)
     * }
     */
    public static MethodHandle HeapCreate$handle() {
        return HeapCreate.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * HANDLE HeapCreate(DWORD flOptions, SIZE_T dwInitialSize, SIZE_T dwMaximumSize)
     * }
     */
    public static MemorySegment HeapCreate(int flOptions, long dwInitialSize, long dwMaximumSize) {
        var mh$ = HeapCreate.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("HeapCreate", flOptions, dwInitialSize, dwMaximumSize);
            }
            return (MemorySegment)mh$.invokeExact(flOptions, dwInitialSize, dwMaximumSize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class HeapDestroy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("HeapDestroy"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL HeapDestroy(HANDLE hHeap)
     * }
     */
    public static FunctionDescriptor HeapDestroy$descriptor() {
        return HeapDestroy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL HeapDestroy(HANDLE hHeap)
     * }
     */
    public static MethodHandle HeapDestroy$handle() {
        return HeapDestroy.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL HeapDestroy(HANDLE hHeap)
     * }
     */
    public static int HeapDestroy(MemorySegment hHeap) {
        var mh$ = HeapDestroy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("HeapDestroy", hHeap);
            }
            return (int)mh$.invokeExact(hHeap);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class HeapAlloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER,
            C_LONG,
            C_LONG_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("HeapAlloc"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LPVOID HeapAlloc(HANDLE hHeap, DWORD dwFlags, SIZE_T dwBytes)
     * }
     */
    public static FunctionDescriptor HeapAlloc$descriptor() {
        return HeapAlloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LPVOID HeapAlloc(HANDLE hHeap, DWORD dwFlags, SIZE_T dwBytes)
     * }
     */
    public static MethodHandle HeapAlloc$handle() {
        return HeapAlloc.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * LPVOID HeapAlloc(HANDLE hHeap, DWORD dwFlags, SIZE_T dwBytes)
     * }
     */
    public static MemorySegment HeapAlloc(MemorySegment hHeap, int dwFlags, long dwBytes) {
        var mh$ = HeapAlloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("HeapAlloc", hHeap, dwFlags, dwBytes);
            }
            return (MemorySegment)mh$.invokeExact(hHeap, dwFlags, dwBytes);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class HeapReAlloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER,
            C_LONG,
            C_POINTER,
            C_LONG_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("HeapReAlloc"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LPVOID HeapReAlloc(HANDLE hHeap, DWORD dwFlags, LPVOID lpMem, SIZE_T dwBytes)
     * }
     */
    public static FunctionDescriptor HeapReAlloc$descriptor() {
        return HeapReAlloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LPVOID HeapReAlloc(HANDLE hHeap, DWORD dwFlags, LPVOID lpMem, SIZE_T dwBytes)
     * }
     */
    public static MethodHandle HeapReAlloc$handle() {
        return HeapReAlloc.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * LPVOID HeapReAlloc(HANDLE hHeap, DWORD dwFlags, LPVOID lpMem, SIZE_T dwBytes)
     * }
     */
    public static MemorySegment HeapReAlloc(MemorySegment hHeap, int dwFlags, MemorySegment lpMem, long dwBytes) {
        var mh$ = HeapReAlloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("HeapReAlloc", hHeap, dwFlags, lpMem, dwBytes);
            }
            return (MemorySegment)mh$.invokeExact(hHeap, dwFlags, lpMem, dwBytes);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class HeapFree {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_LONG,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("HeapFree"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL HeapFree(HANDLE hHeap, DWORD dwFlags, LPVOID lpMem)
     * }
     */
    public static FunctionDescriptor HeapFree$descriptor() {
        return HeapFree.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL HeapFree(HANDLE hHeap, DWORD dwFlags, LPVOID lpMem)
     * }
     */
    public static MethodHandle HeapFree$handle() {
        return HeapFree.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL HeapFree(HANDLE hHeap, DWORD dwFlags, LPVOID lpMem)
     * }
     */
    public static int HeapFree(MemorySegment hHeap, int dwFlags, MemorySegment lpMem) {
        var mh$ = HeapFree.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("HeapFree", hHeap, dwFlags, lpMem);
            }
            return (int)mh$.invokeExact(hHeap, dwFlags, lpMem);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class HeapSize {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG_LONG,
            C_POINTER,
            C_LONG,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("HeapSize"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SIZE_T HeapSize(HANDLE hHeap, DWORD dwFlags, LPCVOID lpMem)
     * }
     */
    public static FunctionDescriptor HeapSize$descriptor() {
        return HeapSize.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SIZE_T HeapSize(HANDLE hHeap, DWORD dwFlags, LPCVOID lpMem)
     * }
     */
    public static MethodHandle HeapSize$handle() {
        return HeapSize.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * SIZE_T HeapSize(HANDLE hHeap, DWORD dwFlags, LPCVOID lpMem)
     * }
     */
    public static long HeapSize(MemorySegment hHeap, int dwFlags, MemorySegment lpMem) {
        var mh$ = HeapSize.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("HeapSize", hHeap, dwFlags, lpMem);
            }
            return (long)mh$.invokeExact(hHeap, dwFlags, lpMem);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetProcessHeap {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER    );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetProcessHeap"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HANDLE GetProcessHeap()
     * }
     */
    public static FunctionDescriptor GetProcessHeap$descriptor() {
        return GetProcessHeap.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HANDLE GetProcessHeap()
     * }
     */
    public static MethodHandle GetProcessHeap$handle() {
        return GetProcessHeap.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * HANDLE GetProcessHeap()
     * }
     */
    public static MemorySegment GetProcessHeap() {
        var mh$ = GetProcessHeap.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetProcessHeap");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class HeapCompact {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG_LONG,
            C_POINTER,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("HeapCompact"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SIZE_T HeapCompact(HANDLE hHeap, DWORD dwFlags)
     * }
     */
    public static FunctionDescriptor HeapCompact$descriptor() {
        return HeapCompact.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SIZE_T HeapCompact(HANDLE hHeap, DWORD dwFlags)
     * }
     */
    public static MethodHandle HeapCompact$handle() {
        return HeapCompact.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * SIZE_T HeapCompact(HANDLE hHeap, DWORD dwFlags)
     * }
     */
    public static long HeapCompact(MemorySegment hHeap, int dwFlags) {
        var mh$ = HeapCompact.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("HeapCompact", hHeap, dwFlags);
            }
            return (long)mh$.invokeExact(hHeap, dwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class HeapSetInformation {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_INT,
            C_POINTER,
            C_LONG_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("HeapSetInformation"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL HeapSetInformation(HANDLE HeapHandle, HEAP_INFORMATION_CLASS HeapInformationClass, PVOID HeapInformation, SIZE_T HeapInformationLength)
     * }
     */
    public static FunctionDescriptor HeapSetInformation$descriptor() {
        return HeapSetInformation.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL HeapSetInformation(HANDLE HeapHandle, HEAP_INFORMATION_CLASS HeapInformationClass, PVOID HeapInformation, SIZE_T HeapInformationLength)
     * }
     */
    public static MethodHandle HeapSetInformation$handle() {
        return HeapSetInformation.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL HeapSetInformation(HANDLE HeapHandle, HEAP_INFORMATION_CLASS HeapInformationClass, PVOID HeapInformation, SIZE_T HeapInformationLength)
     * }
     */
    public static int HeapSetInformation(MemorySegment HeapHandle, int HeapInformationClass, MemorySegment HeapInformation, long HeapInformationLength) {
        var mh$ = HeapSetInformation.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("HeapSetInformation", HeapHandle, HeapInformationClass, HeapInformation, HeapInformationLength);
            }
            return (int)mh$.invokeExact(HeapHandle, HeapInformationClass, HeapInformation, HeapInformationLength);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class HeapValidate {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_LONG,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("HeapValidate"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL HeapValidate(HANDLE hHeap, DWORD dwFlags, LPCVOID lpMem)
     * }
     */
    public static FunctionDescriptor HeapValidate$descriptor() {
        return HeapValidate.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL HeapValidate(HANDLE hHeap, DWORD dwFlags, LPCVOID lpMem)
     * }
     */
    public static MethodHandle HeapValidate$handle() {
        return HeapValidate.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL HeapValidate(HANDLE hHeap, DWORD dwFlags, LPCVOID lpMem)
     * }
     */
    public static int HeapValidate(MemorySegment hHeap, int dwFlags, MemorySegment lpMem) {
        var mh$ = HeapValidate.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("HeapValidate", hHeap, dwFlags, lpMem);
            }
            return (int)mh$.invokeExact(hHeap, dwFlags, lpMem);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class HeapSummary {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_LONG,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("HeapSummary"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL HeapSummary(HANDLE hHeap, DWORD dwFlags, LPHEAP_SUMMARY lpSummary)
     * }
     */
    public static FunctionDescriptor HeapSummary$descriptor() {
        return HeapSummary.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL HeapSummary(HANDLE hHeap, DWORD dwFlags, LPHEAP_SUMMARY lpSummary)
     * }
     */
    public static MethodHandle HeapSummary$handle() {
        return HeapSummary.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL HeapSummary(HANDLE hHeap, DWORD dwFlags, LPHEAP_SUMMARY lpSummary)
     * }
     */
    public static int HeapSummary(MemorySegment hHeap, int dwFlags, MemorySegment lpSummary) {
        var mh$ = HeapSummary.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("HeapSummary", hHeap, dwFlags, lpSummary);
            }
            return (int)mh$.invokeExact(hHeap, dwFlags, lpSummary);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetProcessHeaps {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_LONG,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetProcessHeaps"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetProcessHeaps(DWORD NumberOfHeaps, PHANDLE ProcessHeaps)
     * }
     */
    public static FunctionDescriptor GetProcessHeaps$descriptor() {
        return GetProcessHeaps.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetProcessHeaps(DWORD NumberOfHeaps, PHANDLE ProcessHeaps)
     * }
     */
    public static MethodHandle GetProcessHeaps$handle() {
        return GetProcessHeaps.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * DWORD GetProcessHeaps(DWORD NumberOfHeaps, PHANDLE ProcessHeaps)
     * }
     */
    public static int GetProcessHeaps(int NumberOfHeaps, MemorySegment ProcessHeaps) {
        var mh$ = GetProcessHeaps.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetProcessHeaps", NumberOfHeaps, ProcessHeaps);
            }
            return (int)mh$.invokeExact(NumberOfHeaps, ProcessHeaps);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class HeapLock {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("HeapLock"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL HeapLock(HANDLE hHeap)
     * }
     */
    public static FunctionDescriptor HeapLock$descriptor() {
        return HeapLock.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL HeapLock(HANDLE hHeap)
     * }
     */
    public static MethodHandle HeapLock$handle() {
        return HeapLock.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL HeapLock(HANDLE hHeap)
     * }
     */
    public static int HeapLock(MemorySegment hHeap) {
        var mh$ = HeapLock.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("HeapLock", hHeap);
            }
            return (int)mh$.invokeExact(hHeap);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class HeapUnlock {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("HeapUnlock"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL HeapUnlock(HANDLE hHeap)
     * }
     */
    public static FunctionDescriptor HeapUnlock$descriptor() {
        return HeapUnlock.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL HeapUnlock(HANDLE hHeap)
     * }
     */
    public static MethodHandle HeapUnlock$handle() {
        return HeapUnlock.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL HeapUnlock(HANDLE hHeap)
     * }
     */
    public static int HeapUnlock(MemorySegment hHeap) {
        var mh$ = HeapUnlock.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("HeapUnlock", hHeap);
            }
            return (int)mh$.invokeExact(hHeap);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class HeapWalk {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("HeapWalk"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL HeapWalk(HANDLE hHeap, LPPROCESS_HEAP_ENTRY lpEntry)
     * }
     */
    public static FunctionDescriptor HeapWalk$descriptor() {
        return HeapWalk.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL HeapWalk(HANDLE hHeap, LPPROCESS_HEAP_ENTRY lpEntry)
     * }
     */
    public static MethodHandle HeapWalk$handle() {
        return HeapWalk.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL HeapWalk(HANDLE hHeap, LPPROCESS_HEAP_ENTRY lpEntry)
     * }
     */
    public static int HeapWalk(MemorySegment hHeap, MemorySegment lpEntry) {
        var mh$ = HeapWalk.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("HeapWalk", hHeap, lpEntry);
            }
            return (int)mh$.invokeExact(hHeap, lpEntry);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class HeapQueryInformation {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_INT,
            C_POINTER,
            C_LONG_LONG,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("HeapQueryInformation"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL HeapQueryInformation(HANDLE HeapHandle, HEAP_INFORMATION_CLASS HeapInformationClass, PVOID HeapInformation, SIZE_T HeapInformationLength, PSIZE_T ReturnLength)
     * }
     */
    public static FunctionDescriptor HeapQueryInformation$descriptor() {
        return HeapQueryInformation.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL HeapQueryInformation(HANDLE HeapHandle, HEAP_INFORMATION_CLASS HeapInformationClass, PVOID HeapInformation, SIZE_T HeapInformationLength, PSIZE_T ReturnLength)
     * }
     */
    public static MethodHandle HeapQueryInformation$handle() {
        return HeapQueryInformation.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL HeapQueryInformation(HANDLE HeapHandle, HEAP_INFORMATION_CLASS HeapInformationClass, PVOID HeapInformation, SIZE_T HeapInformationLength, PSIZE_T ReturnLength)
     * }
     */
    public static int HeapQueryInformation(MemorySegment HeapHandle, int HeapInformationClass, MemorySegment HeapInformation, long HeapInformationLength, MemorySegment ReturnLength) {
        var mh$ = HeapQueryInformation.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("HeapQueryInformation", HeapHandle, HeapInformationClass, HeapInformation, HeapInformationLength, ReturnLength);
            }
            return (int)mh$.invokeExact(HeapHandle, HeapInformationClass, HeapInformation, HeapInformationLength, ReturnLength);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateIoCompletionPort {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_LONG_LONG,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CreateIoCompletionPort"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HANDLE CreateIoCompletionPort(HANDLE FileHandle, HANDLE ExistingCompletionPort, ULONG_PTR CompletionKey, DWORD NumberOfConcurrentThreads)
     * }
     */
    public static FunctionDescriptor CreateIoCompletionPort$descriptor() {
        return CreateIoCompletionPort.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HANDLE CreateIoCompletionPort(HANDLE FileHandle, HANDLE ExistingCompletionPort, ULONG_PTR CompletionKey, DWORD NumberOfConcurrentThreads)
     * }
     */
    public static MethodHandle CreateIoCompletionPort$handle() {
        return CreateIoCompletionPort.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * HANDLE CreateIoCompletionPort(HANDLE FileHandle, HANDLE ExistingCompletionPort, ULONG_PTR CompletionKey, DWORD NumberOfConcurrentThreads)
     * }
     */
    public static MemorySegment CreateIoCompletionPort(MemorySegment FileHandle, MemorySegment ExistingCompletionPort, long CompletionKey, int NumberOfConcurrentThreads) {
        var mh$ = CreateIoCompletionPort.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateIoCompletionPort", FileHandle, ExistingCompletionPort, CompletionKey, NumberOfConcurrentThreads);
            }
            return (MemorySegment)mh$.invokeExact(FileHandle, ExistingCompletionPort, CompletionKey, NumberOfConcurrentThreads);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetQueuedCompletionStatus {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetQueuedCompletionStatus"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetQueuedCompletionStatus(HANDLE CompletionPort, LPDWORD lpNumberOfBytesTransferred, PULONG_PTR lpCompletionKey, LPOVERLAPPED *lpOverlapped, DWORD dwMilliseconds)
     * }
     */
    public static FunctionDescriptor GetQueuedCompletionStatus$descriptor() {
        return GetQueuedCompletionStatus.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetQueuedCompletionStatus(HANDLE CompletionPort, LPDWORD lpNumberOfBytesTransferred, PULONG_PTR lpCompletionKey, LPOVERLAPPED *lpOverlapped, DWORD dwMilliseconds)
     * }
     */
    public static MethodHandle GetQueuedCompletionStatus$handle() {
        return GetQueuedCompletionStatus.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL GetQueuedCompletionStatus(HANDLE CompletionPort, LPDWORD lpNumberOfBytesTransferred, PULONG_PTR lpCompletionKey, LPOVERLAPPED *lpOverlapped, DWORD dwMilliseconds)
     * }
     */
    public static int GetQueuedCompletionStatus(MemorySegment CompletionPort, MemorySegment lpNumberOfBytesTransferred, MemorySegment lpCompletionKey, MemorySegment lpOverlapped, int dwMilliseconds) {
        var mh$ = GetQueuedCompletionStatus.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetQueuedCompletionStatus", CompletionPort, lpNumberOfBytesTransferred, lpCompletionKey, lpOverlapped, dwMilliseconds);
            }
            return (int)mh$.invokeExact(CompletionPort, lpNumberOfBytesTransferred, lpCompletionKey, lpOverlapped, dwMilliseconds);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetQueuedCompletionStatusEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_LONG,
            C_POINTER,
            C_LONG,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetQueuedCompletionStatusEx"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetQueuedCompletionStatusEx(HANDLE CompletionPort, LPOVERLAPPED_ENTRY lpCompletionPortEntries, ULONG ulCount, PULONG ulNumEntriesRemoved, DWORD dwMilliseconds, BOOL fAlertable)
     * }
     */
    public static FunctionDescriptor GetQueuedCompletionStatusEx$descriptor() {
        return GetQueuedCompletionStatusEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetQueuedCompletionStatusEx(HANDLE CompletionPort, LPOVERLAPPED_ENTRY lpCompletionPortEntries, ULONG ulCount, PULONG ulNumEntriesRemoved, DWORD dwMilliseconds, BOOL fAlertable)
     * }
     */
    public static MethodHandle GetQueuedCompletionStatusEx$handle() {
        return GetQueuedCompletionStatusEx.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL GetQueuedCompletionStatusEx(HANDLE CompletionPort, LPOVERLAPPED_ENTRY lpCompletionPortEntries, ULONG ulCount, PULONG ulNumEntriesRemoved, DWORD dwMilliseconds, BOOL fAlertable)
     * }
     */
    public static int GetQueuedCompletionStatusEx(MemorySegment CompletionPort, MemorySegment lpCompletionPortEntries, int ulCount, MemorySegment ulNumEntriesRemoved, int dwMilliseconds, int fAlertable) {
        var mh$ = GetQueuedCompletionStatusEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetQueuedCompletionStatusEx", CompletionPort, lpCompletionPortEntries, ulCount, ulNumEntriesRemoved, dwMilliseconds, fAlertable);
            }
            return (int)mh$.invokeExact(CompletionPort, lpCompletionPortEntries, ulCount, ulNumEntriesRemoved, dwMilliseconds, fAlertable);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PostQueuedCompletionStatus {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_LONG,
            C_LONG_LONG,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("PostQueuedCompletionStatus"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL PostQueuedCompletionStatus(HANDLE CompletionPort, DWORD dwNumberOfBytesTransferred, ULONG_PTR dwCompletionKey, LPOVERLAPPED lpOverlapped)
     * }
     */
    public static FunctionDescriptor PostQueuedCompletionStatus$descriptor() {
        return PostQueuedCompletionStatus.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL PostQueuedCompletionStatus(HANDLE CompletionPort, DWORD dwNumberOfBytesTransferred, ULONG_PTR dwCompletionKey, LPOVERLAPPED lpOverlapped)
     * }
     */
    public static MethodHandle PostQueuedCompletionStatus$handle() {
        return PostQueuedCompletionStatus.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL PostQueuedCompletionStatus(HANDLE CompletionPort, DWORD dwNumberOfBytesTransferred, ULONG_PTR dwCompletionKey, LPOVERLAPPED lpOverlapped)
     * }
     */
    public static int PostQueuedCompletionStatus(MemorySegment CompletionPort, int dwNumberOfBytesTransferred, long dwCompletionKey, MemorySegment lpOverlapped) {
        var mh$ = PostQueuedCompletionStatus.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PostQueuedCompletionStatus", CompletionPort, dwNumberOfBytesTransferred, dwCompletionKey, lpOverlapped);
            }
            return (int)mh$.invokeExact(CompletionPort, dwNumberOfBytesTransferred, dwCompletionKey, lpOverlapped);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DeviceIoControl {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_LONG,
            C_POINTER,
            C_LONG,
            C_POINTER,
            C_LONG,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("DeviceIoControl"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL DeviceIoControl(HANDLE hDevice, DWORD dwIoControlCode, LPVOID lpInBuffer, DWORD nInBufferSize, LPVOID lpOutBuffer, DWORD nOutBufferSize, LPDWORD lpBytesReturned, LPOVERLAPPED lpOverlapped)
     * }
     */
    public static FunctionDescriptor DeviceIoControl$descriptor() {
        return DeviceIoControl.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL DeviceIoControl(HANDLE hDevice, DWORD dwIoControlCode, LPVOID lpInBuffer, DWORD nInBufferSize, LPVOID lpOutBuffer, DWORD nOutBufferSize, LPDWORD lpBytesReturned, LPOVERLAPPED lpOverlapped)
     * }
     */
    public static MethodHandle DeviceIoControl$handle() {
        return DeviceIoControl.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL DeviceIoControl(HANDLE hDevice, DWORD dwIoControlCode, LPVOID lpInBuffer, DWORD nInBufferSize, LPVOID lpOutBuffer, DWORD nOutBufferSize, LPDWORD lpBytesReturned, LPOVERLAPPED lpOverlapped)
     * }
     */
    public static int DeviceIoControl(MemorySegment hDevice, int dwIoControlCode, MemorySegment lpInBuffer, int nInBufferSize, MemorySegment lpOutBuffer, int nOutBufferSize, MemorySegment lpBytesReturned, MemorySegment lpOverlapped) {
        var mh$ = DeviceIoControl.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DeviceIoControl", hDevice, dwIoControlCode, lpInBuffer, nInBufferSize, lpOutBuffer, nOutBufferSize, lpBytesReturned, lpOverlapped);
            }
            return (int)mh$.invokeExact(hDevice, dwIoControlCode, lpInBuffer, nInBufferSize, lpOutBuffer, nOutBufferSize, lpBytesReturned, lpOverlapped);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetOverlappedResult {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetOverlappedResult"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetOverlappedResult(HANDLE hFile, LPOVERLAPPED lpOverlapped, LPDWORD lpNumberOfBytesTransferred, BOOL bWait)
     * }
     */
    public static FunctionDescriptor GetOverlappedResult$descriptor() {
        return GetOverlappedResult.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetOverlappedResult(HANDLE hFile, LPOVERLAPPED lpOverlapped, LPDWORD lpNumberOfBytesTransferred, BOOL bWait)
     * }
     */
    public static MethodHandle GetOverlappedResult$handle() {
        return GetOverlappedResult.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL GetOverlappedResult(HANDLE hFile, LPOVERLAPPED lpOverlapped, LPDWORD lpNumberOfBytesTransferred, BOOL bWait)
     * }
     */
    public static int GetOverlappedResult(MemorySegment hFile, MemorySegment lpOverlapped, MemorySegment lpNumberOfBytesTransferred, int bWait) {
        var mh$ = GetOverlappedResult.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetOverlappedResult", hFile, lpOverlapped, lpNumberOfBytesTransferred, bWait);
            }
            return (int)mh$.invokeExact(hFile, lpOverlapped, lpNumberOfBytesTransferred, bWait);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CancelIoEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CancelIoEx"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CancelIoEx(HANDLE hFile, LPOVERLAPPED lpOverlapped)
     * }
     */
    public static FunctionDescriptor CancelIoEx$descriptor() {
        return CancelIoEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CancelIoEx(HANDLE hFile, LPOVERLAPPED lpOverlapped)
     * }
     */
    public static MethodHandle CancelIoEx$handle() {
        return CancelIoEx.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL CancelIoEx(HANDLE hFile, LPOVERLAPPED lpOverlapped)
     * }
     */
    public static int CancelIoEx(MemorySegment hFile, MemorySegment lpOverlapped) {
        var mh$ = CancelIoEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CancelIoEx", hFile, lpOverlapped);
            }
            return (int)mh$.invokeExact(hFile, lpOverlapped);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CancelIo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CancelIo"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CancelIo(HANDLE hFile)
     * }
     */
    public static FunctionDescriptor CancelIo$descriptor() {
        return CancelIo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CancelIo(HANDLE hFile)
     * }
     */
    public static MethodHandle CancelIo$handle() {
        return CancelIo.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL CancelIo(HANDLE hFile)
     * }
     */
    public static int CancelIo(MemorySegment hFile) {
        var mh$ = CancelIo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CancelIo", hFile);
            }
            return (int)mh$.invokeExact(hFile);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetOverlappedResultEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_LONG,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetOverlappedResultEx"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetOverlappedResultEx(HANDLE hFile, LPOVERLAPPED lpOverlapped, LPDWORD lpNumberOfBytesTransferred, DWORD dwMilliseconds, BOOL bAlertable)
     * }
     */
    public static FunctionDescriptor GetOverlappedResultEx$descriptor() {
        return GetOverlappedResultEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetOverlappedResultEx(HANDLE hFile, LPOVERLAPPED lpOverlapped, LPDWORD lpNumberOfBytesTransferred, DWORD dwMilliseconds, BOOL bAlertable)
     * }
     */
    public static MethodHandle GetOverlappedResultEx$handle() {
        return GetOverlappedResultEx.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL GetOverlappedResultEx(HANDLE hFile, LPOVERLAPPED lpOverlapped, LPDWORD lpNumberOfBytesTransferred, DWORD dwMilliseconds, BOOL bAlertable)
     * }
     */
    public static int GetOverlappedResultEx(MemorySegment hFile, MemorySegment lpOverlapped, MemorySegment lpNumberOfBytesTransferred, int dwMilliseconds, int bAlertable) {
        var mh$ = GetOverlappedResultEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetOverlappedResultEx", hFile, lpOverlapped, lpNumberOfBytesTransferred, dwMilliseconds, bAlertable);
            }
            return (int)mh$.invokeExact(hFile, lpOverlapped, lpNumberOfBytesTransferred, dwMilliseconds, bAlertable);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CancelSynchronousIo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CancelSynchronousIo"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CancelSynchronousIo(HANDLE hThread)
     * }
     */
    public static FunctionDescriptor CancelSynchronousIo$descriptor() {
        return CancelSynchronousIo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CancelSynchronousIo(HANDLE hThread)
     * }
     */
    public static MethodHandle CancelSynchronousIo$handle() {
        return CancelSynchronousIo.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL CancelSynchronousIo(HANDLE hThread)
     * }
     */
    public static int CancelSynchronousIo(MemorySegment hThread) {
        var mh$ = CancelSynchronousIo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CancelSynchronousIo", hThread);
            }
            return (int)mh$.invokeExact(hThread);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef RTL_SRWLOCK *PSRWLOCK
     * }
     */
    public static final AddressLayout PSRWLOCK = C_POINTER;

    private static class InitializeSRWLock {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("InitializeSRWLock"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void InitializeSRWLock(PSRWLOCK SRWLock)
     * }
     */
    public static FunctionDescriptor InitializeSRWLock$descriptor() {
        return InitializeSRWLock.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void InitializeSRWLock(PSRWLOCK SRWLock)
     * }
     */
    public static MethodHandle InitializeSRWLock$handle() {
        return InitializeSRWLock.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * void InitializeSRWLock(PSRWLOCK SRWLock)
     * }
     */
    public static void InitializeSRWLock(MemorySegment SRWLock) {
        var mh$ = InitializeSRWLock.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("InitializeSRWLock", SRWLock);
            }
            mh$.invokeExact(SRWLock);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ReleaseSRWLockExclusive {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("ReleaseSRWLockExclusive"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ReleaseSRWLockExclusive(PSRWLOCK SRWLock)
     * }
     */
    public static FunctionDescriptor ReleaseSRWLockExclusive$descriptor() {
        return ReleaseSRWLockExclusive.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ReleaseSRWLockExclusive(PSRWLOCK SRWLock)
     * }
     */
    public static MethodHandle ReleaseSRWLockExclusive$handle() {
        return ReleaseSRWLockExclusive.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * void ReleaseSRWLockExclusive(PSRWLOCK SRWLock)
     * }
     */
    public static void ReleaseSRWLockExclusive(MemorySegment SRWLock) {
        var mh$ = ReleaseSRWLockExclusive.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ReleaseSRWLockExclusive", SRWLock);
            }
            mh$.invokeExact(SRWLock);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ReleaseSRWLockShared {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("ReleaseSRWLockShared"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ReleaseSRWLockShared(PSRWLOCK SRWLock)
     * }
     */
    public static FunctionDescriptor ReleaseSRWLockShared$descriptor() {
        return ReleaseSRWLockShared.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ReleaseSRWLockShared(PSRWLOCK SRWLock)
     * }
     */
    public static MethodHandle ReleaseSRWLockShared$handle() {
        return ReleaseSRWLockShared.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * void ReleaseSRWLockShared(PSRWLOCK SRWLock)
     * }
     */
    public static void ReleaseSRWLockShared(MemorySegment SRWLock) {
        var mh$ = ReleaseSRWLockShared.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ReleaseSRWLockShared", SRWLock);
            }
            mh$.invokeExact(SRWLock);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class AcquireSRWLockExclusive {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("AcquireSRWLockExclusive"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void AcquireSRWLockExclusive(PSRWLOCK SRWLock)
     * }
     */
    public static FunctionDescriptor AcquireSRWLockExclusive$descriptor() {
        return AcquireSRWLockExclusive.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void AcquireSRWLockExclusive(PSRWLOCK SRWLock)
     * }
     */
    public static MethodHandle AcquireSRWLockExclusive$handle() {
        return AcquireSRWLockExclusive.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * void AcquireSRWLockExclusive(PSRWLOCK SRWLock)
     * }
     */
    public static void AcquireSRWLockExclusive(MemorySegment SRWLock) {
        var mh$ = AcquireSRWLockExclusive.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("AcquireSRWLockExclusive", SRWLock);
            }
            mh$.invokeExact(SRWLock);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class AcquireSRWLockShared {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("AcquireSRWLockShared"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void AcquireSRWLockShared(PSRWLOCK SRWLock)
     * }
     */
    public static FunctionDescriptor AcquireSRWLockShared$descriptor() {
        return AcquireSRWLockShared.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void AcquireSRWLockShared(PSRWLOCK SRWLock)
     * }
     */
    public static MethodHandle AcquireSRWLockShared$handle() {
        return AcquireSRWLockShared.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * void AcquireSRWLockShared(PSRWLOCK SRWLock)
     * }
     */
    public static void AcquireSRWLockShared(MemorySegment SRWLock) {
        var mh$ = AcquireSRWLockShared.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("AcquireSRWLockShared", SRWLock);
            }
            mh$.invokeExact(SRWLock);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TryAcquireSRWLockExclusive {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_CHAR,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("TryAcquireSRWLockExclusive"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOLEAN TryAcquireSRWLockExclusive(PSRWLOCK SRWLock)
     * }
     */
    public static FunctionDescriptor TryAcquireSRWLockExclusive$descriptor() {
        return TryAcquireSRWLockExclusive.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOLEAN TryAcquireSRWLockExclusive(PSRWLOCK SRWLock)
     * }
     */
    public static MethodHandle TryAcquireSRWLockExclusive$handle() {
        return TryAcquireSRWLockExclusive.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOLEAN TryAcquireSRWLockExclusive(PSRWLOCK SRWLock)
     * }
     */
    public static byte TryAcquireSRWLockExclusive(MemorySegment SRWLock) {
        var mh$ = TryAcquireSRWLockExclusive.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TryAcquireSRWLockExclusive", SRWLock);
            }
            return (byte)mh$.invokeExact(SRWLock);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TryAcquireSRWLockShared {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_CHAR,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("TryAcquireSRWLockShared"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOLEAN TryAcquireSRWLockShared(PSRWLOCK SRWLock)
     * }
     */
    public static FunctionDescriptor TryAcquireSRWLockShared$descriptor() {
        return TryAcquireSRWLockShared.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOLEAN TryAcquireSRWLockShared(PSRWLOCK SRWLock)
     * }
     */
    public static MethodHandle TryAcquireSRWLockShared$handle() {
        return TryAcquireSRWLockShared.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOLEAN TryAcquireSRWLockShared(PSRWLOCK SRWLock)
     * }
     */
    public static byte TryAcquireSRWLockShared(MemorySegment SRWLock) {
        var mh$ = TryAcquireSRWLockShared.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TryAcquireSRWLockShared", SRWLock);
            }
            return (byte)mh$.invokeExact(SRWLock);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class InitializeCriticalSection {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("InitializeCriticalSection"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void InitializeCriticalSection(LPCRITICAL_SECTION lpCriticalSection)
     * }
     */
    public static FunctionDescriptor InitializeCriticalSection$descriptor() {
        return InitializeCriticalSection.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void InitializeCriticalSection(LPCRITICAL_SECTION lpCriticalSection)
     * }
     */
    public static MethodHandle InitializeCriticalSection$handle() {
        return InitializeCriticalSection.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * void InitializeCriticalSection(LPCRITICAL_SECTION lpCriticalSection)
     * }
     */
    public static void InitializeCriticalSection(MemorySegment lpCriticalSection) {
        var mh$ = InitializeCriticalSection.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("InitializeCriticalSection", lpCriticalSection);
            }
            mh$.invokeExact(lpCriticalSection);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class EnterCriticalSection {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("EnterCriticalSection"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void EnterCriticalSection(LPCRITICAL_SECTION lpCriticalSection)
     * }
     */
    public static FunctionDescriptor EnterCriticalSection$descriptor() {
        return EnterCriticalSection.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void EnterCriticalSection(LPCRITICAL_SECTION lpCriticalSection)
     * }
     */
    public static MethodHandle EnterCriticalSection$handle() {
        return EnterCriticalSection.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * void EnterCriticalSection(LPCRITICAL_SECTION lpCriticalSection)
     * }
     */
    public static void EnterCriticalSection(MemorySegment lpCriticalSection) {
        var mh$ = EnterCriticalSection.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("EnterCriticalSection", lpCriticalSection);
            }
            mh$.invokeExact(lpCriticalSection);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LeaveCriticalSection {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("LeaveCriticalSection"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void LeaveCriticalSection(LPCRITICAL_SECTION lpCriticalSection)
     * }
     */
    public static FunctionDescriptor LeaveCriticalSection$descriptor() {
        return LeaveCriticalSection.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void LeaveCriticalSection(LPCRITICAL_SECTION lpCriticalSection)
     * }
     */
    public static MethodHandle LeaveCriticalSection$handle() {
        return LeaveCriticalSection.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * void LeaveCriticalSection(LPCRITICAL_SECTION lpCriticalSection)
     * }
     */
    public static void LeaveCriticalSection(MemorySegment lpCriticalSection) {
        var mh$ = LeaveCriticalSection.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LeaveCriticalSection", lpCriticalSection);
            }
            mh$.invokeExact(lpCriticalSection);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class InitializeCriticalSectionAndSpinCount {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("InitializeCriticalSectionAndSpinCount"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL InitializeCriticalSectionAndSpinCount(LPCRITICAL_SECTION lpCriticalSection, DWORD dwSpinCount)
     * }
     */
    public static FunctionDescriptor InitializeCriticalSectionAndSpinCount$descriptor() {
        return InitializeCriticalSectionAndSpinCount.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL InitializeCriticalSectionAndSpinCount(LPCRITICAL_SECTION lpCriticalSection, DWORD dwSpinCount)
     * }
     */
    public static MethodHandle InitializeCriticalSectionAndSpinCount$handle() {
        return InitializeCriticalSectionAndSpinCount.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL InitializeCriticalSectionAndSpinCount(LPCRITICAL_SECTION lpCriticalSection, DWORD dwSpinCount)
     * }
     */
    public static int InitializeCriticalSectionAndSpinCount(MemorySegment lpCriticalSection, int dwSpinCount) {
        var mh$ = InitializeCriticalSectionAndSpinCount.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("InitializeCriticalSectionAndSpinCount", lpCriticalSection, dwSpinCount);
            }
            return (int)mh$.invokeExact(lpCriticalSection, dwSpinCount);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class InitializeCriticalSectionEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_LONG,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("InitializeCriticalSectionEx"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL InitializeCriticalSectionEx(LPCRITICAL_SECTION lpCriticalSection, DWORD dwSpinCount, DWORD Flags)
     * }
     */
    public static FunctionDescriptor InitializeCriticalSectionEx$descriptor() {
        return InitializeCriticalSectionEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL InitializeCriticalSectionEx(LPCRITICAL_SECTION lpCriticalSection, DWORD dwSpinCount, DWORD Flags)
     * }
     */
    public static MethodHandle InitializeCriticalSectionEx$handle() {
        return InitializeCriticalSectionEx.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL InitializeCriticalSectionEx(LPCRITICAL_SECTION lpCriticalSection, DWORD dwSpinCount, DWORD Flags)
     * }
     */
    public static int InitializeCriticalSectionEx(MemorySegment lpCriticalSection, int dwSpinCount, int Flags) {
        var mh$ = InitializeCriticalSectionEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("InitializeCriticalSectionEx", lpCriticalSection, dwSpinCount, Flags);
            }
            return (int)mh$.invokeExact(lpCriticalSection, dwSpinCount, Flags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetCriticalSectionSpinCount {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_POINTER,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("SetCriticalSectionSpinCount"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD SetCriticalSectionSpinCount(LPCRITICAL_SECTION lpCriticalSection, DWORD dwSpinCount)
     * }
     */
    public static FunctionDescriptor SetCriticalSectionSpinCount$descriptor() {
        return SetCriticalSectionSpinCount.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD SetCriticalSectionSpinCount(LPCRITICAL_SECTION lpCriticalSection, DWORD dwSpinCount)
     * }
     */
    public static MethodHandle SetCriticalSectionSpinCount$handle() {
        return SetCriticalSectionSpinCount.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * DWORD SetCriticalSectionSpinCount(LPCRITICAL_SECTION lpCriticalSection, DWORD dwSpinCount)
     * }
     */
    public static int SetCriticalSectionSpinCount(MemorySegment lpCriticalSection, int dwSpinCount) {
        var mh$ = SetCriticalSectionSpinCount.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetCriticalSectionSpinCount", lpCriticalSection, dwSpinCount);
            }
            return (int)mh$.invokeExact(lpCriticalSection, dwSpinCount);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TryEnterCriticalSection {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("TryEnterCriticalSection"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL TryEnterCriticalSection(LPCRITICAL_SECTION lpCriticalSection)
     * }
     */
    public static FunctionDescriptor TryEnterCriticalSection$descriptor() {
        return TryEnterCriticalSection.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL TryEnterCriticalSection(LPCRITICAL_SECTION lpCriticalSection)
     * }
     */
    public static MethodHandle TryEnterCriticalSection$handle() {
        return TryEnterCriticalSection.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL TryEnterCriticalSection(LPCRITICAL_SECTION lpCriticalSection)
     * }
     */
    public static int TryEnterCriticalSection(MemorySegment lpCriticalSection) {
        var mh$ = TryEnterCriticalSection.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TryEnterCriticalSection", lpCriticalSection);
            }
            return (int)mh$.invokeExact(lpCriticalSection);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DeleteCriticalSection {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("DeleteCriticalSection"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void DeleteCriticalSection(LPCRITICAL_SECTION lpCriticalSection)
     * }
     */
    public static FunctionDescriptor DeleteCriticalSection$descriptor() {
        return DeleteCriticalSection.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void DeleteCriticalSection(LPCRITICAL_SECTION lpCriticalSection)
     * }
     */
    public static MethodHandle DeleteCriticalSection$handle() {
        return DeleteCriticalSection.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * void DeleteCriticalSection(LPCRITICAL_SECTION lpCriticalSection)
     * }
     */
    public static void DeleteCriticalSection(MemorySegment lpCriticalSection) {
        var mh$ = DeleteCriticalSection.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DeleteCriticalSection", lpCriticalSection);
            }
            mh$.invokeExact(lpCriticalSection);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef PRTL_RUN_ONCE PINIT_ONCE
     * }
     */
    public static final AddressLayout PINIT_ONCE = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef PRTL_RUN_ONCE LPINIT_ONCE
     * }
     */
    public static final AddressLayout LPINIT_ONCE = C_POINTER;

    private static class InitOnceInitialize {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("InitOnceInitialize"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void InitOnceInitialize(PINIT_ONCE InitOnce)
     * }
     */
    public static FunctionDescriptor InitOnceInitialize$descriptor() {
        return InitOnceInitialize.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void InitOnceInitialize(PINIT_ONCE InitOnce)
     * }
     */
    public static MethodHandle InitOnceInitialize$handle() {
        return InitOnceInitialize.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * void InitOnceInitialize(PINIT_ONCE InitOnce)
     * }
     */
    public static void InitOnceInitialize(MemorySegment InitOnce) {
        var mh$ = InitOnceInitialize.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("InitOnceInitialize", InitOnce);
            }
            mh$.invokeExact(InitOnce);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class InitOnceExecuteOnce {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("InitOnceExecuteOnce"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL InitOnceExecuteOnce(PINIT_ONCE InitOnce, PINIT_ONCE_FN InitFn, PVOID Parameter, LPVOID *Context)
     * }
     */
    public static FunctionDescriptor InitOnceExecuteOnce$descriptor() {
        return InitOnceExecuteOnce.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL InitOnceExecuteOnce(PINIT_ONCE InitOnce, PINIT_ONCE_FN InitFn, PVOID Parameter, LPVOID *Context)
     * }
     */
    public static MethodHandle InitOnceExecuteOnce$handle() {
        return InitOnceExecuteOnce.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL InitOnceExecuteOnce(PINIT_ONCE InitOnce, PINIT_ONCE_FN InitFn, PVOID Parameter, LPVOID *Context)
     * }
     */
    public static int InitOnceExecuteOnce(MemorySegment InitOnce, MemorySegment InitFn, MemorySegment Parameter, MemorySegment Context) {
        var mh$ = InitOnceExecuteOnce.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("InitOnceExecuteOnce", InitOnce, InitFn, Parameter, Context);
            }
            return (int)mh$.invokeExact(InitOnce, InitFn, Parameter, Context);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class InitOnceBeginInitialize {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_LONG,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("InitOnceBeginInitialize"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL InitOnceBeginInitialize(LPINIT_ONCE lpInitOnce, DWORD dwFlags, PBOOL fPending, LPVOID *lpContext)
     * }
     */
    public static FunctionDescriptor InitOnceBeginInitialize$descriptor() {
        return InitOnceBeginInitialize.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL InitOnceBeginInitialize(LPINIT_ONCE lpInitOnce, DWORD dwFlags, PBOOL fPending, LPVOID *lpContext)
     * }
     */
    public static MethodHandle InitOnceBeginInitialize$handle() {
        return InitOnceBeginInitialize.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL InitOnceBeginInitialize(LPINIT_ONCE lpInitOnce, DWORD dwFlags, PBOOL fPending, LPVOID *lpContext)
     * }
     */
    public static int InitOnceBeginInitialize(MemorySegment lpInitOnce, int dwFlags, MemorySegment fPending, MemorySegment lpContext) {
        var mh$ = InitOnceBeginInitialize.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("InitOnceBeginInitialize", lpInitOnce, dwFlags, fPending, lpContext);
            }
            return (int)mh$.invokeExact(lpInitOnce, dwFlags, fPending, lpContext);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class InitOnceComplete {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_LONG,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("InitOnceComplete"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL InitOnceComplete(LPINIT_ONCE lpInitOnce, DWORD dwFlags, LPVOID lpContext)
     * }
     */
    public static FunctionDescriptor InitOnceComplete$descriptor() {
        return InitOnceComplete.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL InitOnceComplete(LPINIT_ONCE lpInitOnce, DWORD dwFlags, LPVOID lpContext)
     * }
     */
    public static MethodHandle InitOnceComplete$handle() {
        return InitOnceComplete.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL InitOnceComplete(LPINIT_ONCE lpInitOnce, DWORD dwFlags, LPVOID lpContext)
     * }
     */
    public static int InitOnceComplete(MemorySegment lpInitOnce, int dwFlags, MemorySegment lpContext) {
        var mh$ = InitOnceComplete.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("InitOnceComplete", lpInitOnce, dwFlags, lpContext);
            }
            return (int)mh$.invokeExact(lpInitOnce, dwFlags, lpContext);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef RTL_CONDITION_VARIABLE *PCONDITION_VARIABLE
     * }
     */
    public static final AddressLayout PCONDITION_VARIABLE = C_POINTER;

    private static class InitializeConditionVariable {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("InitializeConditionVariable"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void InitializeConditionVariable(PCONDITION_VARIABLE ConditionVariable)
     * }
     */
    public static FunctionDescriptor InitializeConditionVariable$descriptor() {
        return InitializeConditionVariable.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void InitializeConditionVariable(PCONDITION_VARIABLE ConditionVariable)
     * }
     */
    public static MethodHandle InitializeConditionVariable$handle() {
        return InitializeConditionVariable.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * void InitializeConditionVariable(PCONDITION_VARIABLE ConditionVariable)
     * }
     */
    public static void InitializeConditionVariable(MemorySegment ConditionVariable) {
        var mh$ = InitializeConditionVariable.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("InitializeConditionVariable", ConditionVariable);
            }
            mh$.invokeExact(ConditionVariable);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class WakeConditionVariable {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("WakeConditionVariable"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void WakeConditionVariable(PCONDITION_VARIABLE ConditionVariable)
     * }
     */
    public static FunctionDescriptor WakeConditionVariable$descriptor() {
        return WakeConditionVariable.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void WakeConditionVariable(PCONDITION_VARIABLE ConditionVariable)
     * }
     */
    public static MethodHandle WakeConditionVariable$handle() {
        return WakeConditionVariable.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * void WakeConditionVariable(PCONDITION_VARIABLE ConditionVariable)
     * }
     */
    public static void WakeConditionVariable(MemorySegment ConditionVariable) {
        var mh$ = WakeConditionVariable.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WakeConditionVariable", ConditionVariable);
            }
            mh$.invokeExact(ConditionVariable);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class WakeAllConditionVariable {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("WakeAllConditionVariable"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void WakeAllConditionVariable(PCONDITION_VARIABLE ConditionVariable)
     * }
     */
    public static FunctionDescriptor WakeAllConditionVariable$descriptor() {
        return WakeAllConditionVariable.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void WakeAllConditionVariable(PCONDITION_VARIABLE ConditionVariable)
     * }
     */
    public static MethodHandle WakeAllConditionVariable$handle() {
        return WakeAllConditionVariable.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * void WakeAllConditionVariable(PCONDITION_VARIABLE ConditionVariable)
     * }
     */
    public static void WakeAllConditionVariable(MemorySegment ConditionVariable) {
        var mh$ = WakeAllConditionVariable.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WakeAllConditionVariable", ConditionVariable);
            }
            mh$.invokeExact(ConditionVariable);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SleepConditionVariableCS {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("SleepConditionVariableCS"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SleepConditionVariableCS(PCONDITION_VARIABLE ConditionVariable, PCRITICAL_SECTION CriticalSection, DWORD dwMilliseconds)
     * }
     */
    public static FunctionDescriptor SleepConditionVariableCS$descriptor() {
        return SleepConditionVariableCS.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SleepConditionVariableCS(PCONDITION_VARIABLE ConditionVariable, PCRITICAL_SECTION CriticalSection, DWORD dwMilliseconds)
     * }
     */
    public static MethodHandle SleepConditionVariableCS$handle() {
        return SleepConditionVariableCS.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL SleepConditionVariableCS(PCONDITION_VARIABLE ConditionVariable, PCRITICAL_SECTION CriticalSection, DWORD dwMilliseconds)
     * }
     */
    public static int SleepConditionVariableCS(MemorySegment ConditionVariable, MemorySegment CriticalSection, int dwMilliseconds) {
        var mh$ = SleepConditionVariableCS.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SleepConditionVariableCS", ConditionVariable, CriticalSection, dwMilliseconds);
            }
            return (int)mh$.invokeExact(ConditionVariable, CriticalSection, dwMilliseconds);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SleepConditionVariableSRW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_LONG,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("SleepConditionVariableSRW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SleepConditionVariableSRW(PCONDITION_VARIABLE ConditionVariable, PSRWLOCK SRWLock, DWORD dwMilliseconds, ULONG Flags)
     * }
     */
    public static FunctionDescriptor SleepConditionVariableSRW$descriptor() {
        return SleepConditionVariableSRW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SleepConditionVariableSRW(PCONDITION_VARIABLE ConditionVariable, PSRWLOCK SRWLock, DWORD dwMilliseconds, ULONG Flags)
     * }
     */
    public static MethodHandle SleepConditionVariableSRW$handle() {
        return SleepConditionVariableSRW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL SleepConditionVariableSRW(PCONDITION_VARIABLE ConditionVariable, PSRWLOCK SRWLock, DWORD dwMilliseconds, ULONG Flags)
     * }
     */
    public static int SleepConditionVariableSRW(MemorySegment ConditionVariable, MemorySegment SRWLock, int dwMilliseconds, int Flags) {
        var mh$ = SleepConditionVariableSRW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SleepConditionVariableSRW", ConditionVariable, SRWLock, dwMilliseconds, Flags);
            }
            return (int)mh$.invokeExact(ConditionVariable, SRWLock, dwMilliseconds, Flags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetEvent {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("SetEvent"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetEvent(HANDLE hEvent)
     * }
     */
    public static FunctionDescriptor SetEvent$descriptor() {
        return SetEvent.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetEvent(HANDLE hEvent)
     * }
     */
    public static MethodHandle SetEvent$handle() {
        return SetEvent.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL SetEvent(HANDLE hEvent)
     * }
     */
    public static int SetEvent(MemorySegment hEvent) {
        var mh$ = SetEvent.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetEvent", hEvent);
            }
            return (int)mh$.invokeExact(hEvent);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ResetEvent {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("ResetEvent"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL ResetEvent(HANDLE hEvent)
     * }
     */
    public static FunctionDescriptor ResetEvent$descriptor() {
        return ResetEvent.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL ResetEvent(HANDLE hEvent)
     * }
     */
    public static MethodHandle ResetEvent$handle() {
        return ResetEvent.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL ResetEvent(HANDLE hEvent)
     * }
     */
    public static int ResetEvent(MemorySegment hEvent) {
        var mh$ = ResetEvent.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ResetEvent", hEvent);
            }
            return (int)mh$.invokeExact(hEvent);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ReleaseSemaphore {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_LONG,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("ReleaseSemaphore"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL ReleaseSemaphore(HANDLE hSemaphore, LONG lReleaseCount, LPLONG lpPreviousCount)
     * }
     */
    public static FunctionDescriptor ReleaseSemaphore$descriptor() {
        return ReleaseSemaphore.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL ReleaseSemaphore(HANDLE hSemaphore, LONG lReleaseCount, LPLONG lpPreviousCount)
     * }
     */
    public static MethodHandle ReleaseSemaphore$handle() {
        return ReleaseSemaphore.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL ReleaseSemaphore(HANDLE hSemaphore, LONG lReleaseCount, LPLONG lpPreviousCount)
     * }
     */
    public static int ReleaseSemaphore(MemorySegment hSemaphore, int lReleaseCount, MemorySegment lpPreviousCount) {
        var mh$ = ReleaseSemaphore.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ReleaseSemaphore", hSemaphore, lReleaseCount, lpPreviousCount);
            }
            return (int)mh$.invokeExact(hSemaphore, lReleaseCount, lpPreviousCount);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ReleaseMutex {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("ReleaseMutex"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL ReleaseMutex(HANDLE hMutex)
     * }
     */
    public static FunctionDescriptor ReleaseMutex$descriptor() {
        return ReleaseMutex.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL ReleaseMutex(HANDLE hMutex)
     * }
     */
    public static MethodHandle ReleaseMutex$handle() {
        return ReleaseMutex.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL ReleaseMutex(HANDLE hMutex)
     * }
     */
    public static int ReleaseMutex(MemorySegment hMutex) {
        var mh$ = ReleaseMutex.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ReleaseMutex", hMutex);
            }
            return (int)mh$.invokeExact(hMutex);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class WaitForSingleObject {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_POINTER,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("WaitForSingleObject"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD WaitForSingleObject(HANDLE hHandle, DWORD dwMilliseconds)
     * }
     */
    public static FunctionDescriptor WaitForSingleObject$descriptor() {
        return WaitForSingleObject.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD WaitForSingleObject(HANDLE hHandle, DWORD dwMilliseconds)
     * }
     */
    public static MethodHandle WaitForSingleObject$handle() {
        return WaitForSingleObject.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * DWORD WaitForSingleObject(HANDLE hHandle, DWORD dwMilliseconds)
     * }
     */
    public static int WaitForSingleObject(MemorySegment hHandle, int dwMilliseconds) {
        var mh$ = WaitForSingleObject.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WaitForSingleObject", hHandle, dwMilliseconds);
            }
            return (int)mh$.invokeExact(hHandle, dwMilliseconds);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SleepEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_LONG,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("SleepEx"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD SleepEx(DWORD dwMilliseconds, BOOL bAlertable)
     * }
     */
    public static FunctionDescriptor SleepEx$descriptor() {
        return SleepEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD SleepEx(DWORD dwMilliseconds, BOOL bAlertable)
     * }
     */
    public static MethodHandle SleepEx$handle() {
        return SleepEx.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * DWORD SleepEx(DWORD dwMilliseconds, BOOL bAlertable)
     * }
     */
    public static int SleepEx(int dwMilliseconds, int bAlertable) {
        var mh$ = SleepEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SleepEx", dwMilliseconds, bAlertable);
            }
            return (int)mh$.invokeExact(dwMilliseconds, bAlertable);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class WaitForSingleObjectEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_POINTER,
            C_LONG,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("WaitForSingleObjectEx"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD WaitForSingleObjectEx(HANDLE hHandle, DWORD dwMilliseconds, BOOL bAlertable)
     * }
     */
    public static FunctionDescriptor WaitForSingleObjectEx$descriptor() {
        return WaitForSingleObjectEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD WaitForSingleObjectEx(HANDLE hHandle, DWORD dwMilliseconds, BOOL bAlertable)
     * }
     */
    public static MethodHandle WaitForSingleObjectEx$handle() {
        return WaitForSingleObjectEx.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * DWORD WaitForSingleObjectEx(HANDLE hHandle, DWORD dwMilliseconds, BOOL bAlertable)
     * }
     */
    public static int WaitForSingleObjectEx(MemorySegment hHandle, int dwMilliseconds, int bAlertable) {
        var mh$ = WaitForSingleObjectEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WaitForSingleObjectEx", hHandle, dwMilliseconds, bAlertable);
            }
            return (int)mh$.invokeExact(hHandle, dwMilliseconds, bAlertable);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class WaitForMultipleObjectsEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_LONG,
            C_POINTER,
            C_INT,
            C_LONG,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("WaitForMultipleObjectsEx"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD WaitForMultipleObjectsEx(DWORD nCount, const HANDLE *lpHandles, BOOL bWaitAll, DWORD dwMilliseconds, BOOL bAlertable)
     * }
     */
    public static FunctionDescriptor WaitForMultipleObjectsEx$descriptor() {
        return WaitForMultipleObjectsEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD WaitForMultipleObjectsEx(DWORD nCount, const HANDLE *lpHandles, BOOL bWaitAll, DWORD dwMilliseconds, BOOL bAlertable)
     * }
     */
    public static MethodHandle WaitForMultipleObjectsEx$handle() {
        return WaitForMultipleObjectsEx.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * DWORD WaitForMultipleObjectsEx(DWORD nCount, const HANDLE *lpHandles, BOOL bWaitAll, DWORD dwMilliseconds, BOOL bAlertable)
     * }
     */
    public static int WaitForMultipleObjectsEx(int nCount, MemorySegment lpHandles, int bWaitAll, int dwMilliseconds, int bAlertable) {
        var mh$ = WaitForMultipleObjectsEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WaitForMultipleObjectsEx", nCount, lpHandles, bWaitAll, dwMilliseconds, bAlertable);
            }
            return (int)mh$.invokeExact(nCount, lpHandles, bWaitAll, dwMilliseconds, bAlertable);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateMutexA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER,
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CreateMutexA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HANDLE CreateMutexA(LPSECURITY_ATTRIBUTES lpMutexAttributes, BOOL bInitialOwner, LPCSTR lpName)
     * }
     */
    public static FunctionDescriptor CreateMutexA$descriptor() {
        return CreateMutexA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HANDLE CreateMutexA(LPSECURITY_ATTRIBUTES lpMutexAttributes, BOOL bInitialOwner, LPCSTR lpName)
     * }
     */
    public static MethodHandle CreateMutexA$handle() {
        return CreateMutexA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * HANDLE CreateMutexA(LPSECURITY_ATTRIBUTES lpMutexAttributes, BOOL bInitialOwner, LPCSTR lpName)
     * }
     */
    public static MemorySegment CreateMutexA(MemorySegment lpMutexAttributes, int bInitialOwner, MemorySegment lpName) {
        var mh$ = CreateMutexA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateMutexA", lpMutexAttributes, bInitialOwner, lpName);
            }
            return (MemorySegment)mh$.invokeExact(lpMutexAttributes, bInitialOwner, lpName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateMutexW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER,
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CreateMutexW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HANDLE CreateMutexW(LPSECURITY_ATTRIBUTES lpMutexAttributes, BOOL bInitialOwner, LPCWSTR lpName)
     * }
     */
    public static FunctionDescriptor CreateMutexW$descriptor() {
        return CreateMutexW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HANDLE CreateMutexW(LPSECURITY_ATTRIBUTES lpMutexAttributes, BOOL bInitialOwner, LPCWSTR lpName)
     * }
     */
    public static MethodHandle CreateMutexW$handle() {
        return CreateMutexW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * HANDLE CreateMutexW(LPSECURITY_ATTRIBUTES lpMutexAttributes, BOOL bInitialOwner, LPCWSTR lpName)
     * }
     */
    public static MemorySegment CreateMutexW(MemorySegment lpMutexAttributes, int bInitialOwner, MemorySegment lpName) {
        var mh$ = CreateMutexW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateMutexW", lpMutexAttributes, bInitialOwner, lpName);
            }
            return (MemorySegment)mh$.invokeExact(lpMutexAttributes, bInitialOwner, lpName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class OpenMutexW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_LONG,
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("OpenMutexW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HANDLE OpenMutexW(DWORD dwDesiredAccess, BOOL bInheritHandle, LPCWSTR lpName)
     * }
     */
    public static FunctionDescriptor OpenMutexW$descriptor() {
        return OpenMutexW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HANDLE OpenMutexW(DWORD dwDesiredAccess, BOOL bInheritHandle, LPCWSTR lpName)
     * }
     */
    public static MethodHandle OpenMutexW$handle() {
        return OpenMutexW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * HANDLE OpenMutexW(DWORD dwDesiredAccess, BOOL bInheritHandle, LPCWSTR lpName)
     * }
     */
    public static MemorySegment OpenMutexW(int dwDesiredAccess, int bInheritHandle, MemorySegment lpName) {
        var mh$ = OpenMutexW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("OpenMutexW", dwDesiredAccess, bInheritHandle, lpName);
            }
            return (MemorySegment)mh$.invokeExact(dwDesiredAccess, bInheritHandle, lpName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateEventA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER,
            C_INT,
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CreateEventA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HANDLE CreateEventA(LPSECURITY_ATTRIBUTES lpEventAttributes, BOOL bManualReset, BOOL bInitialState, LPCSTR lpName)
     * }
     */
    public static FunctionDescriptor CreateEventA$descriptor() {
        return CreateEventA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HANDLE CreateEventA(LPSECURITY_ATTRIBUTES lpEventAttributes, BOOL bManualReset, BOOL bInitialState, LPCSTR lpName)
     * }
     */
    public static MethodHandle CreateEventA$handle() {
        return CreateEventA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * HANDLE CreateEventA(LPSECURITY_ATTRIBUTES lpEventAttributes, BOOL bManualReset, BOOL bInitialState, LPCSTR lpName)
     * }
     */
    public static MemorySegment CreateEventA(MemorySegment lpEventAttributes, int bManualReset, int bInitialState, MemorySegment lpName) {
        var mh$ = CreateEventA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateEventA", lpEventAttributes, bManualReset, bInitialState, lpName);
            }
            return (MemorySegment)mh$.invokeExact(lpEventAttributes, bManualReset, bInitialState, lpName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateEventW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER,
            C_INT,
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CreateEventW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HANDLE CreateEventW(LPSECURITY_ATTRIBUTES lpEventAttributes, BOOL bManualReset, BOOL bInitialState, LPCWSTR lpName)
     * }
     */
    public static FunctionDescriptor CreateEventW$descriptor() {
        return CreateEventW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HANDLE CreateEventW(LPSECURITY_ATTRIBUTES lpEventAttributes, BOOL bManualReset, BOOL bInitialState, LPCWSTR lpName)
     * }
     */
    public static MethodHandle CreateEventW$handle() {
        return CreateEventW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * HANDLE CreateEventW(LPSECURITY_ATTRIBUTES lpEventAttributes, BOOL bManualReset, BOOL bInitialState, LPCWSTR lpName)
     * }
     */
    public static MemorySegment CreateEventW(MemorySegment lpEventAttributes, int bManualReset, int bInitialState, MemorySegment lpName) {
        var mh$ = CreateEventW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateEventW", lpEventAttributes, bManualReset, bInitialState, lpName);
            }
            return (MemorySegment)mh$.invokeExact(lpEventAttributes, bManualReset, bInitialState, lpName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class OpenEventA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_LONG,
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("OpenEventA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HANDLE OpenEventA(DWORD dwDesiredAccess, BOOL bInheritHandle, LPCSTR lpName)
     * }
     */
    public static FunctionDescriptor OpenEventA$descriptor() {
        return OpenEventA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HANDLE OpenEventA(DWORD dwDesiredAccess, BOOL bInheritHandle, LPCSTR lpName)
     * }
     */
    public static MethodHandle OpenEventA$handle() {
        return OpenEventA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * HANDLE OpenEventA(DWORD dwDesiredAccess, BOOL bInheritHandle, LPCSTR lpName)
     * }
     */
    public static MemorySegment OpenEventA(int dwDesiredAccess, int bInheritHandle, MemorySegment lpName) {
        var mh$ = OpenEventA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("OpenEventA", dwDesiredAccess, bInheritHandle, lpName);
            }
            return (MemorySegment)mh$.invokeExact(dwDesiredAccess, bInheritHandle, lpName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class OpenEventW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_LONG,
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("OpenEventW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HANDLE OpenEventW(DWORD dwDesiredAccess, BOOL bInheritHandle, LPCWSTR lpName)
     * }
     */
    public static FunctionDescriptor OpenEventW$descriptor() {
        return OpenEventW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HANDLE OpenEventW(DWORD dwDesiredAccess, BOOL bInheritHandle, LPCWSTR lpName)
     * }
     */
    public static MethodHandle OpenEventW$handle() {
        return OpenEventW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * HANDLE OpenEventW(DWORD dwDesiredAccess, BOOL bInheritHandle, LPCWSTR lpName)
     * }
     */
    public static MemorySegment OpenEventW(int dwDesiredAccess, int bInheritHandle, MemorySegment lpName) {
        var mh$ = OpenEventW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("OpenEventW", dwDesiredAccess, bInheritHandle, lpName);
            }
            return (MemorySegment)mh$.invokeExact(dwDesiredAccess, bInheritHandle, lpName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class OpenSemaphoreW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_LONG,
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("OpenSemaphoreW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HANDLE OpenSemaphoreW(DWORD dwDesiredAccess, BOOL bInheritHandle, LPCWSTR lpName)
     * }
     */
    public static FunctionDescriptor OpenSemaphoreW$descriptor() {
        return OpenSemaphoreW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HANDLE OpenSemaphoreW(DWORD dwDesiredAccess, BOOL bInheritHandle, LPCWSTR lpName)
     * }
     */
    public static MethodHandle OpenSemaphoreW$handle() {
        return OpenSemaphoreW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * HANDLE OpenSemaphoreW(DWORD dwDesiredAccess, BOOL bInheritHandle, LPCWSTR lpName)
     * }
     */
    public static MemorySegment OpenSemaphoreW(int dwDesiredAccess, int bInheritHandle, MemorySegment lpName) {
        var mh$ = OpenSemaphoreW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("OpenSemaphoreW", dwDesiredAccess, bInheritHandle, lpName);
            }
            return (MemorySegment)mh$.invokeExact(dwDesiredAccess, bInheritHandle, lpName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class OpenWaitableTimerW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_LONG,
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("OpenWaitableTimerW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HANDLE OpenWaitableTimerW(DWORD dwDesiredAccess, BOOL bInheritHandle, LPCWSTR lpTimerName)
     * }
     */
    public static FunctionDescriptor OpenWaitableTimerW$descriptor() {
        return OpenWaitableTimerW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HANDLE OpenWaitableTimerW(DWORD dwDesiredAccess, BOOL bInheritHandle, LPCWSTR lpTimerName)
     * }
     */
    public static MethodHandle OpenWaitableTimerW$handle() {
        return OpenWaitableTimerW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * HANDLE OpenWaitableTimerW(DWORD dwDesiredAccess, BOOL bInheritHandle, LPCWSTR lpTimerName)
     * }
     */
    public static MemorySegment OpenWaitableTimerW(int dwDesiredAccess, int bInheritHandle, MemorySegment lpTimerName) {
        var mh$ = OpenWaitableTimerW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("OpenWaitableTimerW", dwDesiredAccess, bInheritHandle, lpTimerName);
            }
            return (MemorySegment)mh$.invokeExact(dwDesiredAccess, bInheritHandle, lpTimerName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetWaitableTimerEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_LONG,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("SetWaitableTimerEx"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetWaitableTimerEx(HANDLE hTimer, const LARGE_INTEGER *lpDueTime, LONG lPeriod, PTIMERAPCROUTINE pfnCompletionRoutine, LPVOID lpArgToCompletionRoutine, PREASON_CONTEXT WakeContext, ULONG TolerableDelay)
     * }
     */
    public static FunctionDescriptor SetWaitableTimerEx$descriptor() {
        return SetWaitableTimerEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetWaitableTimerEx(HANDLE hTimer, const LARGE_INTEGER *lpDueTime, LONG lPeriod, PTIMERAPCROUTINE pfnCompletionRoutine, LPVOID lpArgToCompletionRoutine, PREASON_CONTEXT WakeContext, ULONG TolerableDelay)
     * }
     */
    public static MethodHandle SetWaitableTimerEx$handle() {
        return SetWaitableTimerEx.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL SetWaitableTimerEx(HANDLE hTimer, const LARGE_INTEGER *lpDueTime, LONG lPeriod, PTIMERAPCROUTINE pfnCompletionRoutine, LPVOID lpArgToCompletionRoutine, PREASON_CONTEXT WakeContext, ULONG TolerableDelay)
     * }
     */
    public static int SetWaitableTimerEx(MemorySegment hTimer, MemorySegment lpDueTime, int lPeriod, MemorySegment pfnCompletionRoutine, MemorySegment lpArgToCompletionRoutine, MemorySegment WakeContext, int TolerableDelay) {
        var mh$ = SetWaitableTimerEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetWaitableTimerEx", hTimer, lpDueTime, lPeriod, pfnCompletionRoutine, lpArgToCompletionRoutine, WakeContext, TolerableDelay);
            }
            return (int)mh$.invokeExact(hTimer, lpDueTime, lPeriod, pfnCompletionRoutine, lpArgToCompletionRoutine, WakeContext, TolerableDelay);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetWaitableTimer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_LONG,
            C_POINTER,
            C_POINTER,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("SetWaitableTimer"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetWaitableTimer(HANDLE hTimer, const LARGE_INTEGER *lpDueTime, LONG lPeriod, PTIMERAPCROUTINE pfnCompletionRoutine, LPVOID lpArgToCompletionRoutine, BOOL fResume)
     * }
     */
    public static FunctionDescriptor SetWaitableTimer$descriptor() {
        return SetWaitableTimer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetWaitableTimer(HANDLE hTimer, const LARGE_INTEGER *lpDueTime, LONG lPeriod, PTIMERAPCROUTINE pfnCompletionRoutine, LPVOID lpArgToCompletionRoutine, BOOL fResume)
     * }
     */
    public static MethodHandle SetWaitableTimer$handle() {
        return SetWaitableTimer.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL SetWaitableTimer(HANDLE hTimer, const LARGE_INTEGER *lpDueTime, LONG lPeriod, PTIMERAPCROUTINE pfnCompletionRoutine, LPVOID lpArgToCompletionRoutine, BOOL fResume)
     * }
     */
    public static int SetWaitableTimer(MemorySegment hTimer, MemorySegment lpDueTime, int lPeriod, MemorySegment pfnCompletionRoutine, MemorySegment lpArgToCompletionRoutine, int fResume) {
        var mh$ = SetWaitableTimer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetWaitableTimer", hTimer, lpDueTime, lPeriod, pfnCompletionRoutine, lpArgToCompletionRoutine, fResume);
            }
            return (int)mh$.invokeExact(hTimer, lpDueTime, lPeriod, pfnCompletionRoutine, lpArgToCompletionRoutine, fResume);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CancelWaitableTimer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CancelWaitableTimer"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CancelWaitableTimer(HANDLE hTimer)
     * }
     */
    public static FunctionDescriptor CancelWaitableTimer$descriptor() {
        return CancelWaitableTimer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CancelWaitableTimer(HANDLE hTimer)
     * }
     */
    public static MethodHandle CancelWaitableTimer$handle() {
        return CancelWaitableTimer.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL CancelWaitableTimer(HANDLE hTimer)
     * }
     */
    public static int CancelWaitableTimer(MemorySegment hTimer) {
        var mh$ = CancelWaitableTimer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CancelWaitableTimer", hTimer);
            }
            return (int)mh$.invokeExact(hTimer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateMutexExA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_LONG,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CreateMutexExA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HANDLE CreateMutexExA(LPSECURITY_ATTRIBUTES lpMutexAttributes, LPCSTR lpName, DWORD dwFlags, DWORD dwDesiredAccess)
     * }
     */
    public static FunctionDescriptor CreateMutexExA$descriptor() {
        return CreateMutexExA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HANDLE CreateMutexExA(LPSECURITY_ATTRIBUTES lpMutexAttributes, LPCSTR lpName, DWORD dwFlags, DWORD dwDesiredAccess)
     * }
     */
    public static MethodHandle CreateMutexExA$handle() {
        return CreateMutexExA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * HANDLE CreateMutexExA(LPSECURITY_ATTRIBUTES lpMutexAttributes, LPCSTR lpName, DWORD dwFlags, DWORD dwDesiredAccess)
     * }
     */
    public static MemorySegment CreateMutexExA(MemorySegment lpMutexAttributes, MemorySegment lpName, int dwFlags, int dwDesiredAccess) {
        var mh$ = CreateMutexExA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateMutexExA", lpMutexAttributes, lpName, dwFlags, dwDesiredAccess);
            }
            return (MemorySegment)mh$.invokeExact(lpMutexAttributes, lpName, dwFlags, dwDesiredAccess);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateMutexExW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_LONG,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CreateMutexExW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HANDLE CreateMutexExW(LPSECURITY_ATTRIBUTES lpMutexAttributes, LPCWSTR lpName, DWORD dwFlags, DWORD dwDesiredAccess)
     * }
     */
    public static FunctionDescriptor CreateMutexExW$descriptor() {
        return CreateMutexExW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HANDLE CreateMutexExW(LPSECURITY_ATTRIBUTES lpMutexAttributes, LPCWSTR lpName, DWORD dwFlags, DWORD dwDesiredAccess)
     * }
     */
    public static MethodHandle CreateMutexExW$handle() {
        return CreateMutexExW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * HANDLE CreateMutexExW(LPSECURITY_ATTRIBUTES lpMutexAttributes, LPCWSTR lpName, DWORD dwFlags, DWORD dwDesiredAccess)
     * }
     */
    public static MemorySegment CreateMutexExW(MemorySegment lpMutexAttributes, MemorySegment lpName, int dwFlags, int dwDesiredAccess) {
        var mh$ = CreateMutexExW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateMutexExW", lpMutexAttributes, lpName, dwFlags, dwDesiredAccess);
            }
            return (MemorySegment)mh$.invokeExact(lpMutexAttributes, lpName, dwFlags, dwDesiredAccess);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateEventExA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_LONG,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CreateEventExA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HANDLE CreateEventExA(LPSECURITY_ATTRIBUTES lpEventAttributes, LPCSTR lpName, DWORD dwFlags, DWORD dwDesiredAccess)
     * }
     */
    public static FunctionDescriptor CreateEventExA$descriptor() {
        return CreateEventExA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HANDLE CreateEventExA(LPSECURITY_ATTRIBUTES lpEventAttributes, LPCSTR lpName, DWORD dwFlags, DWORD dwDesiredAccess)
     * }
     */
    public static MethodHandle CreateEventExA$handle() {
        return CreateEventExA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * HANDLE CreateEventExA(LPSECURITY_ATTRIBUTES lpEventAttributes, LPCSTR lpName, DWORD dwFlags, DWORD dwDesiredAccess)
     * }
     */
    public static MemorySegment CreateEventExA(MemorySegment lpEventAttributes, MemorySegment lpName, int dwFlags, int dwDesiredAccess) {
        var mh$ = CreateEventExA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateEventExA", lpEventAttributes, lpName, dwFlags, dwDesiredAccess);
            }
            return (MemorySegment)mh$.invokeExact(lpEventAttributes, lpName, dwFlags, dwDesiredAccess);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateEventExW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_LONG,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CreateEventExW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HANDLE CreateEventExW(LPSECURITY_ATTRIBUTES lpEventAttributes, LPCWSTR lpName, DWORD dwFlags, DWORD dwDesiredAccess)
     * }
     */
    public static FunctionDescriptor CreateEventExW$descriptor() {
        return CreateEventExW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HANDLE CreateEventExW(LPSECURITY_ATTRIBUTES lpEventAttributes, LPCWSTR lpName, DWORD dwFlags, DWORD dwDesiredAccess)
     * }
     */
    public static MethodHandle CreateEventExW$handle() {
        return CreateEventExW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * HANDLE CreateEventExW(LPSECURITY_ATTRIBUTES lpEventAttributes, LPCWSTR lpName, DWORD dwFlags, DWORD dwDesiredAccess)
     * }
     */
    public static MemorySegment CreateEventExW(MemorySegment lpEventAttributes, MemorySegment lpName, int dwFlags, int dwDesiredAccess) {
        var mh$ = CreateEventExW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateEventExW", lpEventAttributes, lpName, dwFlags, dwDesiredAccess);
            }
            return (MemorySegment)mh$.invokeExact(lpEventAttributes, lpName, dwFlags, dwDesiredAccess);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateSemaphoreExW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER,
            C_LONG,
            C_LONG,
            C_POINTER,
            C_LONG,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CreateSemaphoreExW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HANDLE CreateSemaphoreExW(LPSECURITY_ATTRIBUTES lpSemaphoreAttributes, LONG lInitialCount, LONG lMaximumCount, LPCWSTR lpName, DWORD dwFlags, DWORD dwDesiredAccess)
     * }
     */
    public static FunctionDescriptor CreateSemaphoreExW$descriptor() {
        return CreateSemaphoreExW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HANDLE CreateSemaphoreExW(LPSECURITY_ATTRIBUTES lpSemaphoreAttributes, LONG lInitialCount, LONG lMaximumCount, LPCWSTR lpName, DWORD dwFlags, DWORD dwDesiredAccess)
     * }
     */
    public static MethodHandle CreateSemaphoreExW$handle() {
        return CreateSemaphoreExW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * HANDLE CreateSemaphoreExW(LPSECURITY_ATTRIBUTES lpSemaphoreAttributes, LONG lInitialCount, LONG lMaximumCount, LPCWSTR lpName, DWORD dwFlags, DWORD dwDesiredAccess)
     * }
     */
    public static MemorySegment CreateSemaphoreExW(MemorySegment lpSemaphoreAttributes, int lInitialCount, int lMaximumCount, MemorySegment lpName, int dwFlags, int dwDesiredAccess) {
        var mh$ = CreateSemaphoreExW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateSemaphoreExW", lpSemaphoreAttributes, lInitialCount, lMaximumCount, lpName, dwFlags, dwDesiredAccess);
            }
            return (MemorySegment)mh$.invokeExact(lpSemaphoreAttributes, lInitialCount, lMaximumCount, lpName, dwFlags, dwDesiredAccess);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateWaitableTimerExW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_LONG,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CreateWaitableTimerExW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HANDLE CreateWaitableTimerExW(LPSECURITY_ATTRIBUTES lpTimerAttributes, LPCWSTR lpTimerName, DWORD dwFlags, DWORD dwDesiredAccess)
     * }
     */
    public static FunctionDescriptor CreateWaitableTimerExW$descriptor() {
        return CreateWaitableTimerExW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HANDLE CreateWaitableTimerExW(LPSECURITY_ATTRIBUTES lpTimerAttributes, LPCWSTR lpTimerName, DWORD dwFlags, DWORD dwDesiredAccess)
     * }
     */
    public static MethodHandle CreateWaitableTimerExW$handle() {
        return CreateWaitableTimerExW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * HANDLE CreateWaitableTimerExW(LPSECURITY_ATTRIBUTES lpTimerAttributes, LPCWSTR lpTimerName, DWORD dwFlags, DWORD dwDesiredAccess)
     * }
     */
    public static MemorySegment CreateWaitableTimerExW(MemorySegment lpTimerAttributes, MemorySegment lpTimerName, int dwFlags, int dwDesiredAccess) {
        var mh$ = CreateWaitableTimerExW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateWaitableTimerExW", lpTimerAttributes, lpTimerName, dwFlags, dwDesiredAccess);
            }
            return (MemorySegment)mh$.invokeExact(lpTimerAttributes, lpTimerName, dwFlags, dwDesiredAccess);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef PRTL_BARRIER PSYNCHRONIZATION_BARRIER
     * }
     */
    public static final AddressLayout PSYNCHRONIZATION_BARRIER = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef PRTL_BARRIER LPSYNCHRONIZATION_BARRIER
     * }
     */
    public static final AddressLayout LPSYNCHRONIZATION_BARRIER = C_POINTER;

    private static class EnterSynchronizationBarrier {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("EnterSynchronizationBarrier"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL EnterSynchronizationBarrier(LPSYNCHRONIZATION_BARRIER lpBarrier, DWORD dwFlags)
     * }
     */
    public static FunctionDescriptor EnterSynchronizationBarrier$descriptor() {
        return EnterSynchronizationBarrier.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL EnterSynchronizationBarrier(LPSYNCHRONIZATION_BARRIER lpBarrier, DWORD dwFlags)
     * }
     */
    public static MethodHandle EnterSynchronizationBarrier$handle() {
        return EnterSynchronizationBarrier.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL EnterSynchronizationBarrier(LPSYNCHRONIZATION_BARRIER lpBarrier, DWORD dwFlags)
     * }
     */
    public static int EnterSynchronizationBarrier(MemorySegment lpBarrier, int dwFlags) {
        var mh$ = EnterSynchronizationBarrier.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("EnterSynchronizationBarrier", lpBarrier, dwFlags);
            }
            return (int)mh$.invokeExact(lpBarrier, dwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class InitializeSynchronizationBarrier {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_LONG,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("InitializeSynchronizationBarrier"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL InitializeSynchronizationBarrier(LPSYNCHRONIZATION_BARRIER lpBarrier, LONG lTotalThreads, LONG lSpinCount)
     * }
     */
    public static FunctionDescriptor InitializeSynchronizationBarrier$descriptor() {
        return InitializeSynchronizationBarrier.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL InitializeSynchronizationBarrier(LPSYNCHRONIZATION_BARRIER lpBarrier, LONG lTotalThreads, LONG lSpinCount)
     * }
     */
    public static MethodHandle InitializeSynchronizationBarrier$handle() {
        return InitializeSynchronizationBarrier.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL InitializeSynchronizationBarrier(LPSYNCHRONIZATION_BARRIER lpBarrier, LONG lTotalThreads, LONG lSpinCount)
     * }
     */
    public static int InitializeSynchronizationBarrier(MemorySegment lpBarrier, int lTotalThreads, int lSpinCount) {
        var mh$ = InitializeSynchronizationBarrier.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("InitializeSynchronizationBarrier", lpBarrier, lTotalThreads, lSpinCount);
            }
            return (int)mh$.invokeExact(lpBarrier, lTotalThreads, lSpinCount);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DeleteSynchronizationBarrier {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("DeleteSynchronizationBarrier"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL DeleteSynchronizationBarrier(LPSYNCHRONIZATION_BARRIER lpBarrier)
     * }
     */
    public static FunctionDescriptor DeleteSynchronizationBarrier$descriptor() {
        return DeleteSynchronizationBarrier.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL DeleteSynchronizationBarrier(LPSYNCHRONIZATION_BARRIER lpBarrier)
     * }
     */
    public static MethodHandle DeleteSynchronizationBarrier$handle() {
        return DeleteSynchronizationBarrier.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL DeleteSynchronizationBarrier(LPSYNCHRONIZATION_BARRIER lpBarrier)
     * }
     */
    public static int DeleteSynchronizationBarrier(MemorySegment lpBarrier) {
        var mh$ = DeleteSynchronizationBarrier.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DeleteSynchronizationBarrier", lpBarrier);
            }
            return (int)mh$.invokeExact(lpBarrier);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Sleep {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("Sleep"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void Sleep(DWORD dwMilliseconds)
     * }
     */
    public static FunctionDescriptor Sleep$descriptor() {
        return Sleep.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void Sleep(DWORD dwMilliseconds)
     * }
     */
    public static MethodHandle Sleep$handle() {
        return Sleep.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * void Sleep(DWORD dwMilliseconds)
     * }
     */
    public static void Sleep(int dwMilliseconds) {
        var mh$ = Sleep.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Sleep", dwMilliseconds);
            }
            mh$.invokeExact(dwMilliseconds);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class WaitOnAddress {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_LONG_LONG,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("WaitOnAddress"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL WaitOnAddress(volatile void *Address, PVOID CompareAddress, SIZE_T AddressSize, DWORD dwMilliseconds)
     * }
     */
    public static FunctionDescriptor WaitOnAddress$descriptor() {
        return WaitOnAddress.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL WaitOnAddress(volatile void *Address, PVOID CompareAddress, SIZE_T AddressSize, DWORD dwMilliseconds)
     * }
     */
    public static MethodHandle WaitOnAddress$handle() {
        return WaitOnAddress.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL WaitOnAddress(volatile void *Address, PVOID CompareAddress, SIZE_T AddressSize, DWORD dwMilliseconds)
     * }
     */
    public static int WaitOnAddress(MemorySegment Address, MemorySegment CompareAddress, long AddressSize, int dwMilliseconds) {
        var mh$ = WaitOnAddress.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WaitOnAddress", Address, CompareAddress, AddressSize, dwMilliseconds);
            }
            return (int)mh$.invokeExact(Address, CompareAddress, AddressSize, dwMilliseconds);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class WakeByAddressSingle {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("WakeByAddressSingle"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void WakeByAddressSingle(PVOID Address)
     * }
     */
    public static FunctionDescriptor WakeByAddressSingle$descriptor() {
        return WakeByAddressSingle.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void WakeByAddressSingle(PVOID Address)
     * }
     */
    public static MethodHandle WakeByAddressSingle$handle() {
        return WakeByAddressSingle.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * void WakeByAddressSingle(PVOID Address)
     * }
     */
    public static void WakeByAddressSingle(MemorySegment Address) {
        var mh$ = WakeByAddressSingle.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WakeByAddressSingle", Address);
            }
            mh$.invokeExact(Address);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class WakeByAddressAll {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("WakeByAddressAll"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void WakeByAddressAll(PVOID Address)
     * }
     */
    public static FunctionDescriptor WakeByAddressAll$descriptor() {
        return WakeByAddressAll.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void WakeByAddressAll(PVOID Address)
     * }
     */
    public static MethodHandle WakeByAddressAll$handle() {
        return WakeByAddressAll.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * void WakeByAddressAll(PVOID Address)
     * }
     */
    public static void WakeByAddressAll(MemorySegment Address) {
        var mh$ = WakeByAddressAll.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WakeByAddressAll", Address);
            }
            mh$.invokeExact(Address);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SignalObjectAndWait {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_POINTER,
            C_POINTER,
            C_LONG,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("SignalObjectAndWait"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD SignalObjectAndWait(HANDLE hObjectToSignal, HANDLE hObjectToWaitOn, DWORD dwMilliseconds, BOOL bAlertable)
     * }
     */
    public static FunctionDescriptor SignalObjectAndWait$descriptor() {
        return SignalObjectAndWait.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD SignalObjectAndWait(HANDLE hObjectToSignal, HANDLE hObjectToWaitOn, DWORD dwMilliseconds, BOOL bAlertable)
     * }
     */
    public static MethodHandle SignalObjectAndWait$handle() {
        return SignalObjectAndWait.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * DWORD SignalObjectAndWait(HANDLE hObjectToSignal, HANDLE hObjectToWaitOn, DWORD dwMilliseconds, BOOL bAlertable)
     * }
     */
    public static int SignalObjectAndWait(MemorySegment hObjectToSignal, MemorySegment hObjectToWaitOn, int dwMilliseconds, int bAlertable) {
        var mh$ = SignalObjectAndWait.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SignalObjectAndWait", hObjectToSignal, hObjectToWaitOn, dwMilliseconds, bAlertable);
            }
            return (int)mh$.invokeExact(hObjectToSignal, hObjectToWaitOn, dwMilliseconds, bAlertable);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class WaitForMultipleObjects {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_LONG,
            C_POINTER,
            C_INT,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("WaitForMultipleObjects"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD WaitForMultipleObjects(DWORD nCount, const HANDLE *lpHandles, BOOL bWaitAll, DWORD dwMilliseconds)
     * }
     */
    public static FunctionDescriptor WaitForMultipleObjects$descriptor() {
        return WaitForMultipleObjects.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD WaitForMultipleObjects(DWORD nCount, const HANDLE *lpHandles, BOOL bWaitAll, DWORD dwMilliseconds)
     * }
     */
    public static MethodHandle WaitForMultipleObjects$handle() {
        return WaitForMultipleObjects.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * DWORD WaitForMultipleObjects(DWORD nCount, const HANDLE *lpHandles, BOOL bWaitAll, DWORD dwMilliseconds)
     * }
     */
    public static int WaitForMultipleObjects(int nCount, MemorySegment lpHandles, int bWaitAll, int dwMilliseconds) {
        var mh$ = WaitForMultipleObjects.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WaitForMultipleObjects", nCount, lpHandles, bWaitAll, dwMilliseconds);
            }
            return (int)mh$.invokeExact(nCount, lpHandles, bWaitAll, dwMilliseconds);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateSemaphoreW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER,
            C_LONG,
            C_LONG,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CreateSemaphoreW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HANDLE CreateSemaphoreW(LPSECURITY_ATTRIBUTES lpSemaphoreAttributes, LONG lInitialCount, LONG lMaximumCount, LPCWSTR lpName)
     * }
     */
    public static FunctionDescriptor CreateSemaphoreW$descriptor() {
        return CreateSemaphoreW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HANDLE CreateSemaphoreW(LPSECURITY_ATTRIBUTES lpSemaphoreAttributes, LONG lInitialCount, LONG lMaximumCount, LPCWSTR lpName)
     * }
     */
    public static MethodHandle CreateSemaphoreW$handle() {
        return CreateSemaphoreW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * HANDLE CreateSemaphoreW(LPSECURITY_ATTRIBUTES lpSemaphoreAttributes, LONG lInitialCount, LONG lMaximumCount, LPCWSTR lpName)
     * }
     */
    public static MemorySegment CreateSemaphoreW(MemorySegment lpSemaphoreAttributes, int lInitialCount, int lMaximumCount, MemorySegment lpName) {
        var mh$ = CreateSemaphoreW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateSemaphoreW", lpSemaphoreAttributes, lInitialCount, lMaximumCount, lpName);
            }
            return (MemorySegment)mh$.invokeExact(lpSemaphoreAttributes, lInitialCount, lMaximumCount, lpName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateWaitableTimerW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER,
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CreateWaitableTimerW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HANDLE CreateWaitableTimerW(LPSECURITY_ATTRIBUTES lpTimerAttributes, BOOL bManualReset, LPCWSTR lpTimerName)
     * }
     */
    public static FunctionDescriptor CreateWaitableTimerW$descriptor() {
        return CreateWaitableTimerW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HANDLE CreateWaitableTimerW(LPSECURITY_ATTRIBUTES lpTimerAttributes, BOOL bManualReset, LPCWSTR lpTimerName)
     * }
     */
    public static MethodHandle CreateWaitableTimerW$handle() {
        return CreateWaitableTimerW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * HANDLE CreateWaitableTimerW(LPSECURITY_ATTRIBUTES lpTimerAttributes, BOOL bManualReset, LPCWSTR lpTimerName)
     * }
     */
    public static MemorySegment CreateWaitableTimerW(MemorySegment lpTimerAttributes, int bManualReset, MemorySegment lpTimerName) {
        var mh$ = CreateWaitableTimerW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateWaitableTimerW", lpTimerAttributes, bManualReset, lpTimerName);
            }
            return (MemorySegment)mh$.invokeExact(lpTimerAttributes, bManualReset, lpTimerName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class InitializeSListHead {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("InitializeSListHead"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void InitializeSListHead(PSLIST_HEADER ListHead)
     * }
     */
    public static FunctionDescriptor InitializeSListHead$descriptor() {
        return InitializeSListHead.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void InitializeSListHead(PSLIST_HEADER ListHead)
     * }
     */
    public static MethodHandle InitializeSListHead$handle() {
        return InitializeSListHead.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * void InitializeSListHead(PSLIST_HEADER ListHead)
     * }
     */
    public static void InitializeSListHead(MemorySegment ListHead) {
        var mh$ = InitializeSListHead.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("InitializeSListHead", ListHead);
            }
            mh$.invokeExact(ListHead);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class InterlockedPopEntrySList {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("InterlockedPopEntrySList"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PSLIST_ENTRY InterlockedPopEntrySList(PSLIST_HEADER ListHead)
     * }
     */
    public static FunctionDescriptor InterlockedPopEntrySList$descriptor() {
        return InterlockedPopEntrySList.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PSLIST_ENTRY InterlockedPopEntrySList(PSLIST_HEADER ListHead)
     * }
     */
    public static MethodHandle InterlockedPopEntrySList$handle() {
        return InterlockedPopEntrySList.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * PSLIST_ENTRY InterlockedPopEntrySList(PSLIST_HEADER ListHead)
     * }
     */
    public static MemorySegment InterlockedPopEntrySList(MemorySegment ListHead) {
        var mh$ = InterlockedPopEntrySList.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("InterlockedPopEntrySList", ListHead);
            }
            return (MemorySegment)mh$.invokeExact(ListHead);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class InterlockedPushEntrySList {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("InterlockedPushEntrySList"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PSLIST_ENTRY InterlockedPushEntrySList(PSLIST_HEADER ListHead, PSLIST_ENTRY ListEntry)
     * }
     */
    public static FunctionDescriptor InterlockedPushEntrySList$descriptor() {
        return InterlockedPushEntrySList.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PSLIST_ENTRY InterlockedPushEntrySList(PSLIST_HEADER ListHead, PSLIST_ENTRY ListEntry)
     * }
     */
    public static MethodHandle InterlockedPushEntrySList$handle() {
        return InterlockedPushEntrySList.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * PSLIST_ENTRY InterlockedPushEntrySList(PSLIST_HEADER ListHead, PSLIST_ENTRY ListEntry)
     * }
     */
    public static MemorySegment InterlockedPushEntrySList(MemorySegment ListHead, MemorySegment ListEntry) {
        var mh$ = InterlockedPushEntrySList.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("InterlockedPushEntrySList", ListHead, ListEntry);
            }
            return (MemorySegment)mh$.invokeExact(ListHead, ListEntry);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class InterlockedPushListSListEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("InterlockedPushListSListEx"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PSLIST_ENTRY InterlockedPushListSListEx(PSLIST_HEADER ListHead, PSLIST_ENTRY List, PSLIST_ENTRY ListEnd, ULONG Count)
     * }
     */
    public static FunctionDescriptor InterlockedPushListSListEx$descriptor() {
        return InterlockedPushListSListEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PSLIST_ENTRY InterlockedPushListSListEx(PSLIST_HEADER ListHead, PSLIST_ENTRY List, PSLIST_ENTRY ListEnd, ULONG Count)
     * }
     */
    public static MethodHandle InterlockedPushListSListEx$handle() {
        return InterlockedPushListSListEx.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * PSLIST_ENTRY InterlockedPushListSListEx(PSLIST_HEADER ListHead, PSLIST_ENTRY List, PSLIST_ENTRY ListEnd, ULONG Count)
     * }
     */
    public static MemorySegment InterlockedPushListSListEx(MemorySegment ListHead, MemorySegment List, MemorySegment ListEnd, int Count) {
        var mh$ = InterlockedPushListSListEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("InterlockedPushListSListEx", ListHead, List, ListEnd, Count);
            }
            return (MemorySegment)mh$.invokeExact(ListHead, List, ListEnd, Count);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class InterlockedFlushSList {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("InterlockedFlushSList"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PSLIST_ENTRY InterlockedFlushSList(PSLIST_HEADER ListHead)
     * }
     */
    public static FunctionDescriptor InterlockedFlushSList$descriptor() {
        return InterlockedFlushSList.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PSLIST_ENTRY InterlockedFlushSList(PSLIST_HEADER ListHead)
     * }
     */
    public static MethodHandle InterlockedFlushSList$handle() {
        return InterlockedFlushSList.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * PSLIST_ENTRY InterlockedFlushSList(PSLIST_HEADER ListHead)
     * }
     */
    public static MemorySegment InterlockedFlushSList(MemorySegment ListHead) {
        var mh$ = InterlockedFlushSList.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("InterlockedFlushSList", ListHead);
            }
            return (MemorySegment)mh$.invokeExact(ListHead);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class QueryDepthSList {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_SHORT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("QueryDepthSList"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * USHORT QueryDepthSList(PSLIST_HEADER ListHead)
     * }
     */
    public static FunctionDescriptor QueryDepthSList$descriptor() {
        return QueryDepthSList.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * USHORT QueryDepthSList(PSLIST_HEADER ListHead)
     * }
     */
    public static MethodHandle QueryDepthSList$handle() {
        return QueryDepthSList.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * USHORT QueryDepthSList(PSLIST_HEADER ListHead)
     * }
     */
    public static short QueryDepthSList(MemorySegment ListHead) {
        var mh$ = QueryDepthSList.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("QueryDepthSList", ListHead);
            }
            return (short)mh$.invokeExact(ListHead);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct _PROCESS_INFORMATION {
     *     HANDLE hProcess;
     *     HANDLE hThread;
     *     DWORD dwProcessId;
     *     DWORD dwThreadId;
     * } *PPROCESS_INFORMATION
     * }
     */
    public static final AddressLayout PPROCESS_INFORMATION = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _PROCESS_INFORMATION {
     *     HANDLE hProcess;
     *     HANDLE hThread;
     *     DWORD dwProcessId;
     *     DWORD dwThreadId;
     * } *LPPROCESS_INFORMATION
     * }
     */
    public static final AddressLayout LPPROCESS_INFORMATION = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _STARTUPINFOA {
     *     DWORD cb;
     *     LPSTR lpReserved;
     *     LPSTR lpDesktop;
     *     LPSTR lpTitle;
     *     DWORD dwX;
     *     DWORD dwY;
     *     DWORD dwXSize;
     *     DWORD dwYSize;
     *     DWORD dwXCountChars;
     *     DWORD dwYCountChars;
     *     DWORD dwFillAttribute;
     *     DWORD dwFlags;
     *     WORD wShowWindow;
     *     WORD cbReserved2;
     *     LPBYTE lpReserved2;
     *     HANDLE hStdInput;
     *     HANDLE hStdOutput;
     *     HANDLE hStdError;
     * } *LPSTARTUPINFOA
     * }
     */
    public static final AddressLayout LPSTARTUPINFOA = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _STARTUPINFOW {
     *     DWORD cb;
     *     LPWSTR lpReserved;
     *     LPWSTR lpDesktop;
     *     LPWSTR lpTitle;
     *     DWORD dwX;
     *     DWORD dwY;
     *     DWORD dwXSize;
     *     DWORD dwYSize;
     *     DWORD dwXCountChars;
     *     DWORD dwYCountChars;
     *     DWORD dwFillAttribute;
     *     DWORD dwFlags;
     *     WORD wShowWindow;
     *     WORD cbReserved2;
     *     LPBYTE lpReserved2;
     *     HANDLE hStdInput;
     *     HANDLE hStdOutput;
     *     HANDLE hStdError;
     * } *LPSTARTUPINFOW
     * }
     */
    public static final AddressLayout LPSTARTUPINFOW = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef LPSTARTUPINFOA LPSTARTUPINFO
     * }
     */
    public static final AddressLayout LPSTARTUPINFO = C_POINTER;

    private static class QueueUserAPC {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_POINTER,
            C_POINTER,
            C_LONG_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("QueueUserAPC"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD QueueUserAPC(PAPCFUNC pfnAPC, HANDLE hThread, ULONG_PTR dwData)
     * }
     */
    public static FunctionDescriptor QueueUserAPC$descriptor() {
        return QueueUserAPC.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD QueueUserAPC(PAPCFUNC pfnAPC, HANDLE hThread, ULONG_PTR dwData)
     * }
     */
    public static MethodHandle QueueUserAPC$handle() {
        return QueueUserAPC.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * DWORD QueueUserAPC(PAPCFUNC pfnAPC, HANDLE hThread, ULONG_PTR dwData)
     * }
     */
    public static int QueueUserAPC(MemorySegment pfnAPC, MemorySegment hThread, long dwData) {
        var mh$ = QueueUserAPC.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("QueueUserAPC", pfnAPC, hThread, dwData);
            }
            return (int)mh$.invokeExact(pfnAPC, hThread, dwData);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int QUEUE_USER_APC_FLAGS_NONE = (int)0L;
    /**
     * {@snippet lang=c :
     * enum _QUEUE_USER_APC_FLAGS.QUEUE_USER_APC_FLAGS_NONE = 0
     * }
     */
    public static int QUEUE_USER_APC_FLAGS_NONE() {
        return QUEUE_USER_APC_FLAGS_NONE;
    }
    private static final int QUEUE_USER_APC_FLAGS_SPECIAL_USER_APC = (int)1L;
    /**
     * {@snippet lang=c :
     * enum _QUEUE_USER_APC_FLAGS.QUEUE_USER_APC_FLAGS_SPECIAL_USER_APC = 1
     * }
     */
    public static int QUEUE_USER_APC_FLAGS_SPECIAL_USER_APC() {
        return QUEUE_USER_APC_FLAGS_SPECIAL_USER_APC;
    }

    private static class QueueUserAPC2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_LONG_LONG,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("QueueUserAPC2"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL QueueUserAPC2(PAPCFUNC ApcRoutine, HANDLE Thread, ULONG_PTR Data, QUEUE_USER_APC_FLAGS Flags)
     * }
     */
    public static FunctionDescriptor QueueUserAPC2$descriptor() {
        return QueueUserAPC2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL QueueUserAPC2(PAPCFUNC ApcRoutine, HANDLE Thread, ULONG_PTR Data, QUEUE_USER_APC_FLAGS Flags)
     * }
     */
    public static MethodHandle QueueUserAPC2$handle() {
        return QueueUserAPC2.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL QueueUserAPC2(PAPCFUNC ApcRoutine, HANDLE Thread, ULONG_PTR Data, QUEUE_USER_APC_FLAGS Flags)
     * }
     */
    public static int QueueUserAPC2(MemorySegment ApcRoutine, MemorySegment Thread, long Data, int Flags) {
        var mh$ = QueueUserAPC2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("QueueUserAPC2", ApcRoutine, Thread, Data, Flags);
            }
            return (int)mh$.invokeExact(ApcRoutine, Thread, Data, Flags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetProcessTimes {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetProcessTimes"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetProcessTimes(HANDLE hProcess, LPFILETIME lpCreationTime, LPFILETIME lpExitTime, LPFILETIME lpKernelTime, LPFILETIME lpUserTime)
     * }
     */
    public static FunctionDescriptor GetProcessTimes$descriptor() {
        return GetProcessTimes.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetProcessTimes(HANDLE hProcess, LPFILETIME lpCreationTime, LPFILETIME lpExitTime, LPFILETIME lpKernelTime, LPFILETIME lpUserTime)
     * }
     */
    public static MethodHandle GetProcessTimes$handle() {
        return GetProcessTimes.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL GetProcessTimes(HANDLE hProcess, LPFILETIME lpCreationTime, LPFILETIME lpExitTime, LPFILETIME lpKernelTime, LPFILETIME lpUserTime)
     * }
     */
    public static int GetProcessTimes(MemorySegment hProcess, MemorySegment lpCreationTime, MemorySegment lpExitTime, MemorySegment lpKernelTime, MemorySegment lpUserTime) {
        var mh$ = GetProcessTimes.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetProcessTimes", hProcess, lpCreationTime, lpExitTime, lpKernelTime, lpUserTime);
            }
            return (int)mh$.invokeExact(hProcess, lpCreationTime, lpExitTime, lpKernelTime, lpUserTime);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetCurrentProcess {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER    );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetCurrentProcess"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HANDLE GetCurrentProcess()
     * }
     */
    public static FunctionDescriptor GetCurrentProcess$descriptor() {
        return GetCurrentProcess.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HANDLE GetCurrentProcess()
     * }
     */
    public static MethodHandle GetCurrentProcess$handle() {
        return GetCurrentProcess.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * HANDLE GetCurrentProcess()
     * }
     */
    public static MemorySegment GetCurrentProcess() {
        var mh$ = GetCurrentProcess.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetCurrentProcess");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetCurrentProcessId {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG    );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetCurrentProcessId"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetCurrentProcessId()
     * }
     */
    public static FunctionDescriptor GetCurrentProcessId$descriptor() {
        return GetCurrentProcessId.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetCurrentProcessId()
     * }
     */
    public static MethodHandle GetCurrentProcessId$handle() {
        return GetCurrentProcessId.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * DWORD GetCurrentProcessId()
     * }
     */
    public static int GetCurrentProcessId() {
        var mh$ = GetCurrentProcessId.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetCurrentProcessId");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ExitProcess {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("ExitProcess"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ExitProcess(UINT uExitCode)
     * }
     */
    public static FunctionDescriptor ExitProcess$descriptor() {
        return ExitProcess.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ExitProcess(UINT uExitCode)
     * }
     */
    public static MethodHandle ExitProcess$handle() {
        return ExitProcess.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * void ExitProcess(UINT uExitCode)
     * }
     */
    public static void ExitProcess(int uExitCode) {
        var mh$ = ExitProcess.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ExitProcess", uExitCode);
            }
            mh$.invokeExact(uExitCode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TerminateProcess {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("TerminateProcess"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL TerminateProcess(HANDLE hProcess, UINT uExitCode)
     * }
     */
    public static FunctionDescriptor TerminateProcess$descriptor() {
        return TerminateProcess.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL TerminateProcess(HANDLE hProcess, UINT uExitCode)
     * }
     */
    public static MethodHandle TerminateProcess$handle() {
        return TerminateProcess.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL TerminateProcess(HANDLE hProcess, UINT uExitCode)
     * }
     */
    public static int TerminateProcess(MemorySegment hProcess, int uExitCode) {
        var mh$ = TerminateProcess.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TerminateProcess", hProcess, uExitCode);
            }
            return (int)mh$.invokeExact(hProcess, uExitCode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetExitCodeProcess {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetExitCodeProcess"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetExitCodeProcess(HANDLE hProcess, LPDWORD lpExitCode)
     * }
     */
    public static FunctionDescriptor GetExitCodeProcess$descriptor() {
        return GetExitCodeProcess.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetExitCodeProcess(HANDLE hProcess, LPDWORD lpExitCode)
     * }
     */
    public static MethodHandle GetExitCodeProcess$handle() {
        return GetExitCodeProcess.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL GetExitCodeProcess(HANDLE hProcess, LPDWORD lpExitCode)
     * }
     */
    public static int GetExitCodeProcess(MemorySegment hProcess, MemorySegment lpExitCode) {
        var mh$ = GetExitCodeProcess.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetExitCodeProcess", hProcess, lpExitCode);
            }
            return (int)mh$.invokeExact(hProcess, lpExitCode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SwitchToThread {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT    );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("SwitchToThread"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SwitchToThread()
     * }
     */
    public static FunctionDescriptor SwitchToThread$descriptor() {
        return SwitchToThread.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SwitchToThread()
     * }
     */
    public static MethodHandle SwitchToThread$handle() {
        return SwitchToThread.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL SwitchToThread()
     * }
     */
    public static int SwitchToThread() {
        var mh$ = SwitchToThread.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SwitchToThread");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateThread {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER,
            C_LONG_LONG,
            C_POINTER,
            C_POINTER,
            C_LONG,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CreateThread"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HANDLE CreateThread(LPSECURITY_ATTRIBUTES lpThreadAttributes, SIZE_T dwStackSize, LPTHREAD_START_ROUTINE lpStartAddress, LPVOID lpParameter, DWORD dwCreationFlags, LPDWORD lpThreadId)
     * }
     */
    public static FunctionDescriptor CreateThread$descriptor() {
        return CreateThread.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HANDLE CreateThread(LPSECURITY_ATTRIBUTES lpThreadAttributes, SIZE_T dwStackSize, LPTHREAD_START_ROUTINE lpStartAddress, LPVOID lpParameter, DWORD dwCreationFlags, LPDWORD lpThreadId)
     * }
     */
    public static MethodHandle CreateThread$handle() {
        return CreateThread.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * HANDLE CreateThread(LPSECURITY_ATTRIBUTES lpThreadAttributes, SIZE_T dwStackSize, LPTHREAD_START_ROUTINE lpStartAddress, LPVOID lpParameter, DWORD dwCreationFlags, LPDWORD lpThreadId)
     * }
     */
    public static MemorySegment CreateThread(MemorySegment lpThreadAttributes, long dwStackSize, MemorySegment lpStartAddress, MemorySegment lpParameter, int dwCreationFlags, MemorySegment lpThreadId) {
        var mh$ = CreateThread.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateThread", lpThreadAttributes, dwStackSize, lpStartAddress, lpParameter, dwCreationFlags, lpThreadId);
            }
            return (MemorySegment)mh$.invokeExact(lpThreadAttributes, dwStackSize, lpStartAddress, lpParameter, dwCreationFlags, lpThreadId);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateRemoteThread {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_LONG_LONG,
            C_POINTER,
            C_POINTER,
            C_LONG,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CreateRemoteThread"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HANDLE CreateRemoteThread(HANDLE hProcess, LPSECURITY_ATTRIBUTES lpThreadAttributes, SIZE_T dwStackSize, LPTHREAD_START_ROUTINE lpStartAddress, LPVOID lpParameter, DWORD dwCreationFlags, LPDWORD lpThreadId)
     * }
     */
    public static FunctionDescriptor CreateRemoteThread$descriptor() {
        return CreateRemoteThread.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HANDLE CreateRemoteThread(HANDLE hProcess, LPSECURITY_ATTRIBUTES lpThreadAttributes, SIZE_T dwStackSize, LPTHREAD_START_ROUTINE lpStartAddress, LPVOID lpParameter, DWORD dwCreationFlags, LPDWORD lpThreadId)
     * }
     */
    public static MethodHandle CreateRemoteThread$handle() {
        return CreateRemoteThread.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * HANDLE CreateRemoteThread(HANDLE hProcess, LPSECURITY_ATTRIBUTES lpThreadAttributes, SIZE_T dwStackSize, LPTHREAD_START_ROUTINE lpStartAddress, LPVOID lpParameter, DWORD dwCreationFlags, LPDWORD lpThreadId)
     * }
     */
    public static MemorySegment CreateRemoteThread(MemorySegment hProcess, MemorySegment lpThreadAttributes, long dwStackSize, MemorySegment lpStartAddress, MemorySegment lpParameter, int dwCreationFlags, MemorySegment lpThreadId) {
        var mh$ = CreateRemoteThread.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateRemoteThread", hProcess, lpThreadAttributes, dwStackSize, lpStartAddress, lpParameter, dwCreationFlags, lpThreadId);
            }
            return (MemorySegment)mh$.invokeExact(hProcess, lpThreadAttributes, dwStackSize, lpStartAddress, lpParameter, dwCreationFlags, lpThreadId);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetCurrentThread {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER    );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetCurrentThread"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HANDLE GetCurrentThread()
     * }
     */
    public static FunctionDescriptor GetCurrentThread$descriptor() {
        return GetCurrentThread.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HANDLE GetCurrentThread()
     * }
     */
    public static MethodHandle GetCurrentThread$handle() {
        return GetCurrentThread.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * HANDLE GetCurrentThread()
     * }
     */
    public static MemorySegment GetCurrentThread() {
        var mh$ = GetCurrentThread.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetCurrentThread");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetCurrentThreadId {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG    );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetCurrentThreadId"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetCurrentThreadId()
     * }
     */
    public static FunctionDescriptor GetCurrentThreadId$descriptor() {
        return GetCurrentThreadId.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetCurrentThreadId()
     * }
     */
    public static MethodHandle GetCurrentThreadId$handle() {
        return GetCurrentThreadId.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * DWORD GetCurrentThreadId()
     * }
     */
    public static int GetCurrentThreadId() {
        var mh$ = GetCurrentThreadId.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetCurrentThreadId");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class OpenThread {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_LONG,
            C_INT,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("OpenThread"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HANDLE OpenThread(DWORD dwDesiredAccess, BOOL bInheritHandle, DWORD dwThreadId)
     * }
     */
    public static FunctionDescriptor OpenThread$descriptor() {
        return OpenThread.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HANDLE OpenThread(DWORD dwDesiredAccess, BOOL bInheritHandle, DWORD dwThreadId)
     * }
     */
    public static MethodHandle OpenThread$handle() {
        return OpenThread.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * HANDLE OpenThread(DWORD dwDesiredAccess, BOOL bInheritHandle, DWORD dwThreadId)
     * }
     */
    public static MemorySegment OpenThread(int dwDesiredAccess, int bInheritHandle, int dwThreadId) {
        var mh$ = OpenThread.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("OpenThread", dwDesiredAccess, bInheritHandle, dwThreadId);
            }
            return (MemorySegment)mh$.invokeExact(dwDesiredAccess, bInheritHandle, dwThreadId);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetThreadPriority {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("SetThreadPriority"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetThreadPriority(HANDLE hThread, int nPriority)
     * }
     */
    public static FunctionDescriptor SetThreadPriority$descriptor() {
        return SetThreadPriority.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetThreadPriority(HANDLE hThread, int nPriority)
     * }
     */
    public static MethodHandle SetThreadPriority$handle() {
        return SetThreadPriority.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL SetThreadPriority(HANDLE hThread, int nPriority)
     * }
     */
    public static int SetThreadPriority(MemorySegment hThread, int nPriority) {
        var mh$ = SetThreadPriority.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetThreadPriority", hThread, nPriority);
            }
            return (int)mh$.invokeExact(hThread, nPriority);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetThreadPriorityBoost {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("SetThreadPriorityBoost"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetThreadPriorityBoost(HANDLE hThread, BOOL bDisablePriorityBoost)
     * }
     */
    public static FunctionDescriptor SetThreadPriorityBoost$descriptor() {
        return SetThreadPriorityBoost.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetThreadPriorityBoost(HANDLE hThread, BOOL bDisablePriorityBoost)
     * }
     */
    public static MethodHandle SetThreadPriorityBoost$handle() {
        return SetThreadPriorityBoost.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL SetThreadPriorityBoost(HANDLE hThread, BOOL bDisablePriorityBoost)
     * }
     */
    public static int SetThreadPriorityBoost(MemorySegment hThread, int bDisablePriorityBoost) {
        var mh$ = SetThreadPriorityBoost.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetThreadPriorityBoost", hThread, bDisablePriorityBoost);
            }
            return (int)mh$.invokeExact(hThread, bDisablePriorityBoost);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetThreadPriorityBoost {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetThreadPriorityBoost"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetThreadPriorityBoost(HANDLE hThread, PBOOL pDisablePriorityBoost)
     * }
     */
    public static FunctionDescriptor GetThreadPriorityBoost$descriptor() {
        return GetThreadPriorityBoost.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetThreadPriorityBoost(HANDLE hThread, PBOOL pDisablePriorityBoost)
     * }
     */
    public static MethodHandle GetThreadPriorityBoost$handle() {
        return GetThreadPriorityBoost.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL GetThreadPriorityBoost(HANDLE hThread, PBOOL pDisablePriorityBoost)
     * }
     */
    public static int GetThreadPriorityBoost(MemorySegment hThread, MemorySegment pDisablePriorityBoost) {
        var mh$ = GetThreadPriorityBoost.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetThreadPriorityBoost", hThread, pDisablePriorityBoost);
            }
            return (int)mh$.invokeExact(hThread, pDisablePriorityBoost);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetThreadPriority {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetThreadPriority"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int GetThreadPriority(HANDLE hThread)
     * }
     */
    public static FunctionDescriptor GetThreadPriority$descriptor() {
        return GetThreadPriority.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int GetThreadPriority(HANDLE hThread)
     * }
     */
    public static MethodHandle GetThreadPriority$handle() {
        return GetThreadPriority.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * int GetThreadPriority(HANDLE hThread)
     * }
     */
    public static int GetThreadPriority(MemorySegment hThread) {
        var mh$ = GetThreadPriority.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetThreadPriority", hThread);
            }
            return (int)mh$.invokeExact(hThread);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ExitThread {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("ExitThread"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ExitThread(DWORD dwExitCode)
     * }
     */
    public static FunctionDescriptor ExitThread$descriptor() {
        return ExitThread.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ExitThread(DWORD dwExitCode)
     * }
     */
    public static MethodHandle ExitThread$handle() {
        return ExitThread.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * void ExitThread(DWORD dwExitCode)
     * }
     */
    public static void ExitThread(int dwExitCode) {
        var mh$ = ExitThread.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ExitThread", dwExitCode);
            }
            mh$.invokeExact(dwExitCode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TerminateThread {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("TerminateThread"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL TerminateThread(HANDLE hThread, DWORD dwExitCode)
     * }
     */
    public static FunctionDescriptor TerminateThread$descriptor() {
        return TerminateThread.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL TerminateThread(HANDLE hThread, DWORD dwExitCode)
     * }
     */
    public static MethodHandle TerminateThread$handle() {
        return TerminateThread.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL TerminateThread(HANDLE hThread, DWORD dwExitCode)
     * }
     */
    public static int TerminateThread(MemorySegment hThread, int dwExitCode) {
        var mh$ = TerminateThread.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TerminateThread", hThread, dwExitCode);
            }
            return (int)mh$.invokeExact(hThread, dwExitCode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetExitCodeThread {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetExitCodeThread"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetExitCodeThread(HANDLE hThread, LPDWORD lpExitCode)
     * }
     */
    public static FunctionDescriptor GetExitCodeThread$descriptor() {
        return GetExitCodeThread.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetExitCodeThread(HANDLE hThread, LPDWORD lpExitCode)
     * }
     */
    public static MethodHandle GetExitCodeThread$handle() {
        return GetExitCodeThread.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL GetExitCodeThread(HANDLE hThread, LPDWORD lpExitCode)
     * }
     */
    public static int GetExitCodeThread(MemorySegment hThread, MemorySegment lpExitCode) {
        var mh$ = GetExitCodeThread.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetExitCodeThread", hThread, lpExitCode);
            }
            return (int)mh$.invokeExact(hThread, lpExitCode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SuspendThread {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("SuspendThread"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD SuspendThread(HANDLE hThread)
     * }
     */
    public static FunctionDescriptor SuspendThread$descriptor() {
        return SuspendThread.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD SuspendThread(HANDLE hThread)
     * }
     */
    public static MethodHandle SuspendThread$handle() {
        return SuspendThread.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * DWORD SuspendThread(HANDLE hThread)
     * }
     */
    public static int SuspendThread(MemorySegment hThread) {
        var mh$ = SuspendThread.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SuspendThread", hThread);
            }
            return (int)mh$.invokeExact(hThread);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ResumeThread {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("ResumeThread"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD ResumeThread(HANDLE hThread)
     * }
     */
    public static FunctionDescriptor ResumeThread$descriptor() {
        return ResumeThread.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD ResumeThread(HANDLE hThread)
     * }
     */
    public static MethodHandle ResumeThread$handle() {
        return ResumeThread.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * DWORD ResumeThread(HANDLE hThread)
     * }
     */
    public static int ResumeThread(MemorySegment hThread) {
        var mh$ = ResumeThread.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ResumeThread", hThread);
            }
            return (int)mh$.invokeExact(hThread);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TlsAlloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG    );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("TlsAlloc"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD TlsAlloc()
     * }
     */
    public static FunctionDescriptor TlsAlloc$descriptor() {
        return TlsAlloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD TlsAlloc()
     * }
     */
    public static MethodHandle TlsAlloc$handle() {
        return TlsAlloc.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * DWORD TlsAlloc()
     * }
     */
    public static int TlsAlloc() {
        var mh$ = TlsAlloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TlsAlloc");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TlsGetValue {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("TlsGetValue"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LPVOID TlsGetValue(DWORD dwTlsIndex)
     * }
     */
    public static FunctionDescriptor TlsGetValue$descriptor() {
        return TlsGetValue.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LPVOID TlsGetValue(DWORD dwTlsIndex)
     * }
     */
    public static MethodHandle TlsGetValue$handle() {
        return TlsGetValue.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * LPVOID TlsGetValue(DWORD dwTlsIndex)
     * }
     */
    public static MemorySegment TlsGetValue(int dwTlsIndex) {
        var mh$ = TlsGetValue.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TlsGetValue", dwTlsIndex);
            }
            return (MemorySegment)mh$.invokeExact(dwTlsIndex);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TlsSetValue {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_LONG,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("TlsSetValue"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL TlsSetValue(DWORD dwTlsIndex, LPVOID lpTlsValue)
     * }
     */
    public static FunctionDescriptor TlsSetValue$descriptor() {
        return TlsSetValue.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL TlsSetValue(DWORD dwTlsIndex, LPVOID lpTlsValue)
     * }
     */
    public static MethodHandle TlsSetValue$handle() {
        return TlsSetValue.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL TlsSetValue(DWORD dwTlsIndex, LPVOID lpTlsValue)
     * }
     */
    public static int TlsSetValue(int dwTlsIndex, MemorySegment lpTlsValue) {
        var mh$ = TlsSetValue.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TlsSetValue", dwTlsIndex, lpTlsValue);
            }
            return (int)mh$.invokeExact(dwTlsIndex, lpTlsValue);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TlsFree {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("TlsFree"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL TlsFree(DWORD dwTlsIndex)
     * }
     */
    public static FunctionDescriptor TlsFree$descriptor() {
        return TlsFree.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL TlsFree(DWORD dwTlsIndex)
     * }
     */
    public static MethodHandle TlsFree$handle() {
        return TlsFree.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL TlsFree(DWORD dwTlsIndex)
     * }
     */
    public static int TlsFree(int dwTlsIndex) {
        var mh$ = TlsFree.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TlsFree", dwTlsIndex);
            }
            return (int)mh$.invokeExact(dwTlsIndex);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateProcessA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_INT,
            C_LONG,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CreateProcessA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CreateProcessA(LPCSTR lpApplicationName, LPSTR lpCommandLine, LPSECURITY_ATTRIBUTES lpProcessAttributes, LPSECURITY_ATTRIBUTES lpThreadAttributes, BOOL bInheritHandles, DWORD dwCreationFlags, LPVOID lpEnvironment, LPCSTR lpCurrentDirectory, LPSTARTUPINFOA lpStartupInfo, LPPROCESS_INFORMATION lpProcessInformation)
     * }
     */
    public static FunctionDescriptor CreateProcessA$descriptor() {
        return CreateProcessA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CreateProcessA(LPCSTR lpApplicationName, LPSTR lpCommandLine, LPSECURITY_ATTRIBUTES lpProcessAttributes, LPSECURITY_ATTRIBUTES lpThreadAttributes, BOOL bInheritHandles, DWORD dwCreationFlags, LPVOID lpEnvironment, LPCSTR lpCurrentDirectory, LPSTARTUPINFOA lpStartupInfo, LPPROCESS_INFORMATION lpProcessInformation)
     * }
     */
    public static MethodHandle CreateProcessA$handle() {
        return CreateProcessA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL CreateProcessA(LPCSTR lpApplicationName, LPSTR lpCommandLine, LPSECURITY_ATTRIBUTES lpProcessAttributes, LPSECURITY_ATTRIBUTES lpThreadAttributes, BOOL bInheritHandles, DWORD dwCreationFlags, LPVOID lpEnvironment, LPCSTR lpCurrentDirectory, LPSTARTUPINFOA lpStartupInfo, LPPROCESS_INFORMATION lpProcessInformation)
     * }
     */
    public static int CreateProcessA(MemorySegment lpApplicationName, MemorySegment lpCommandLine, MemorySegment lpProcessAttributes, MemorySegment lpThreadAttributes, int bInheritHandles, int dwCreationFlags, MemorySegment lpEnvironment, MemorySegment lpCurrentDirectory, MemorySegment lpStartupInfo, MemorySegment lpProcessInformation) {
        var mh$ = CreateProcessA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateProcessA", lpApplicationName, lpCommandLine, lpProcessAttributes, lpThreadAttributes, bInheritHandles, dwCreationFlags, lpEnvironment, lpCurrentDirectory, lpStartupInfo, lpProcessInformation);
            }
            return (int)mh$.invokeExact(lpApplicationName, lpCommandLine, lpProcessAttributes, lpThreadAttributes, bInheritHandles, dwCreationFlags, lpEnvironment, lpCurrentDirectory, lpStartupInfo, lpProcessInformation);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateProcessW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_INT,
            C_LONG,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CreateProcessW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CreateProcessW(LPCWSTR lpApplicationName, LPWSTR lpCommandLine, LPSECURITY_ATTRIBUTES lpProcessAttributes, LPSECURITY_ATTRIBUTES lpThreadAttributes, BOOL bInheritHandles, DWORD dwCreationFlags, LPVOID lpEnvironment, LPCWSTR lpCurrentDirectory, LPSTARTUPINFOW lpStartupInfo, LPPROCESS_INFORMATION lpProcessInformation)
     * }
     */
    public static FunctionDescriptor CreateProcessW$descriptor() {
        return CreateProcessW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CreateProcessW(LPCWSTR lpApplicationName, LPWSTR lpCommandLine, LPSECURITY_ATTRIBUTES lpProcessAttributes, LPSECURITY_ATTRIBUTES lpThreadAttributes, BOOL bInheritHandles, DWORD dwCreationFlags, LPVOID lpEnvironment, LPCWSTR lpCurrentDirectory, LPSTARTUPINFOW lpStartupInfo, LPPROCESS_INFORMATION lpProcessInformation)
     * }
     */
    public static MethodHandle CreateProcessW$handle() {
        return CreateProcessW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL CreateProcessW(LPCWSTR lpApplicationName, LPWSTR lpCommandLine, LPSECURITY_ATTRIBUTES lpProcessAttributes, LPSECURITY_ATTRIBUTES lpThreadAttributes, BOOL bInheritHandles, DWORD dwCreationFlags, LPVOID lpEnvironment, LPCWSTR lpCurrentDirectory, LPSTARTUPINFOW lpStartupInfo, LPPROCESS_INFORMATION lpProcessInformation)
     * }
     */
    public static int CreateProcessW(MemorySegment lpApplicationName, MemorySegment lpCommandLine, MemorySegment lpProcessAttributes, MemorySegment lpThreadAttributes, int bInheritHandles, int dwCreationFlags, MemorySegment lpEnvironment, MemorySegment lpCurrentDirectory, MemorySegment lpStartupInfo, MemorySegment lpProcessInformation) {
        var mh$ = CreateProcessW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateProcessW", lpApplicationName, lpCommandLine, lpProcessAttributes, lpThreadAttributes, bInheritHandles, dwCreationFlags, lpEnvironment, lpCurrentDirectory, lpStartupInfo, lpProcessInformation);
            }
            return (int)mh$.invokeExact(lpApplicationName, lpCommandLine, lpProcessAttributes, lpThreadAttributes, bInheritHandles, dwCreationFlags, lpEnvironment, lpCurrentDirectory, lpStartupInfo, lpProcessInformation);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetProcessShutdownParameters {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_LONG,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("SetProcessShutdownParameters"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetProcessShutdownParameters(DWORD dwLevel, DWORD dwFlags)
     * }
     */
    public static FunctionDescriptor SetProcessShutdownParameters$descriptor() {
        return SetProcessShutdownParameters.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetProcessShutdownParameters(DWORD dwLevel, DWORD dwFlags)
     * }
     */
    public static MethodHandle SetProcessShutdownParameters$handle() {
        return SetProcessShutdownParameters.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL SetProcessShutdownParameters(DWORD dwLevel, DWORD dwFlags)
     * }
     */
    public static int SetProcessShutdownParameters(int dwLevel, int dwFlags) {
        var mh$ = SetProcessShutdownParameters.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetProcessShutdownParameters", dwLevel, dwFlags);
            }
            return (int)mh$.invokeExact(dwLevel, dwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetProcessVersion {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetProcessVersion"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetProcessVersion(DWORD ProcessId)
     * }
     */
    public static FunctionDescriptor GetProcessVersion$descriptor() {
        return GetProcessVersion.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetProcessVersion(DWORD ProcessId)
     * }
     */
    public static MethodHandle GetProcessVersion$handle() {
        return GetProcessVersion.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * DWORD GetProcessVersion(DWORD ProcessId)
     * }
     */
    public static int GetProcessVersion(int ProcessId) {
        var mh$ = GetProcessVersion.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetProcessVersion", ProcessId);
            }
            return (int)mh$.invokeExact(ProcessId);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetStartupInfoW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetStartupInfoW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void GetStartupInfoW(LPSTARTUPINFOW lpStartupInfo)
     * }
     */
    public static FunctionDescriptor GetStartupInfoW$descriptor() {
        return GetStartupInfoW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void GetStartupInfoW(LPSTARTUPINFOW lpStartupInfo)
     * }
     */
    public static MethodHandle GetStartupInfoW$handle() {
        return GetStartupInfoW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * void GetStartupInfoW(LPSTARTUPINFOW lpStartupInfo)
     * }
     */
    public static void GetStartupInfoW(MemorySegment lpStartupInfo) {
        var mh$ = GetStartupInfoW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetStartupInfoW", lpStartupInfo);
            }
            mh$.invokeExact(lpStartupInfo);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateProcessAsUserW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_INT,
            C_LONG,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CreateProcessAsUserW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CreateProcessAsUserW(HANDLE hToken, LPCWSTR lpApplicationName, LPWSTR lpCommandLine, LPSECURITY_ATTRIBUTES lpProcessAttributes, LPSECURITY_ATTRIBUTES lpThreadAttributes, BOOL bInheritHandles, DWORD dwCreationFlags, LPVOID lpEnvironment, LPCWSTR lpCurrentDirectory, LPSTARTUPINFOW lpStartupInfo, LPPROCESS_INFORMATION lpProcessInformation)
     * }
     */
    public static FunctionDescriptor CreateProcessAsUserW$descriptor() {
        return CreateProcessAsUserW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CreateProcessAsUserW(HANDLE hToken, LPCWSTR lpApplicationName, LPWSTR lpCommandLine, LPSECURITY_ATTRIBUTES lpProcessAttributes, LPSECURITY_ATTRIBUTES lpThreadAttributes, BOOL bInheritHandles, DWORD dwCreationFlags, LPVOID lpEnvironment, LPCWSTR lpCurrentDirectory, LPSTARTUPINFOW lpStartupInfo, LPPROCESS_INFORMATION lpProcessInformation)
     * }
     */
    public static MethodHandle CreateProcessAsUserW$handle() {
        return CreateProcessAsUserW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL CreateProcessAsUserW(HANDLE hToken, LPCWSTR lpApplicationName, LPWSTR lpCommandLine, LPSECURITY_ATTRIBUTES lpProcessAttributes, LPSECURITY_ATTRIBUTES lpThreadAttributes, BOOL bInheritHandles, DWORD dwCreationFlags, LPVOID lpEnvironment, LPCWSTR lpCurrentDirectory, LPSTARTUPINFOW lpStartupInfo, LPPROCESS_INFORMATION lpProcessInformation)
     * }
     */
    public static int CreateProcessAsUserW(MemorySegment hToken, MemorySegment lpApplicationName, MemorySegment lpCommandLine, MemorySegment lpProcessAttributes, MemorySegment lpThreadAttributes, int bInheritHandles, int dwCreationFlags, MemorySegment lpEnvironment, MemorySegment lpCurrentDirectory, MemorySegment lpStartupInfo, MemorySegment lpProcessInformation) {
        var mh$ = CreateProcessAsUserW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateProcessAsUserW", hToken, lpApplicationName, lpCommandLine, lpProcessAttributes, lpThreadAttributes, bInheritHandles, dwCreationFlags, lpEnvironment, lpCurrentDirectory, lpStartupInfo, lpProcessInformation);
            }
            return (int)mh$.invokeExact(hToken, lpApplicationName, lpCommandLine, lpProcessAttributes, lpThreadAttributes, bInheritHandles, dwCreationFlags, lpEnvironment, lpCurrentDirectory, lpStartupInfo, lpProcessInformation);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetThreadToken {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("SetThreadToken"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetThreadToken(PHANDLE Thread, HANDLE Token)
     * }
     */
    public static FunctionDescriptor SetThreadToken$descriptor() {
        return SetThreadToken.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetThreadToken(PHANDLE Thread, HANDLE Token)
     * }
     */
    public static MethodHandle SetThreadToken$handle() {
        return SetThreadToken.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL SetThreadToken(PHANDLE Thread, HANDLE Token)
     * }
     */
    public static int SetThreadToken(MemorySegment Thread, MemorySegment Token) {
        var mh$ = SetThreadToken.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetThreadToken", Thread, Token);
            }
            return (int)mh$.invokeExact(Thread, Token);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class OpenProcessToken {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_LONG,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("OpenProcessToken"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL OpenProcessToken(HANDLE ProcessHandle, DWORD DesiredAccess, PHANDLE TokenHandle)
     * }
     */
    public static FunctionDescriptor OpenProcessToken$descriptor() {
        return OpenProcessToken.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL OpenProcessToken(HANDLE ProcessHandle, DWORD DesiredAccess, PHANDLE TokenHandle)
     * }
     */
    public static MethodHandle OpenProcessToken$handle() {
        return OpenProcessToken.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL OpenProcessToken(HANDLE ProcessHandle, DWORD DesiredAccess, PHANDLE TokenHandle)
     * }
     */
    public static int OpenProcessToken(MemorySegment ProcessHandle, int DesiredAccess, MemorySegment TokenHandle) {
        var mh$ = OpenProcessToken.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("OpenProcessToken", ProcessHandle, DesiredAccess, TokenHandle);
            }
            return (int)mh$.invokeExact(ProcessHandle, DesiredAccess, TokenHandle);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class OpenThreadToken {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_LONG,
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("OpenThreadToken"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL OpenThreadToken(HANDLE ThreadHandle, DWORD DesiredAccess, BOOL OpenAsSelf, PHANDLE TokenHandle)
     * }
     */
    public static FunctionDescriptor OpenThreadToken$descriptor() {
        return OpenThreadToken.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL OpenThreadToken(HANDLE ThreadHandle, DWORD DesiredAccess, BOOL OpenAsSelf, PHANDLE TokenHandle)
     * }
     */
    public static MethodHandle OpenThreadToken$handle() {
        return OpenThreadToken.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL OpenThreadToken(HANDLE ThreadHandle, DWORD DesiredAccess, BOOL OpenAsSelf, PHANDLE TokenHandle)
     * }
     */
    public static int OpenThreadToken(MemorySegment ThreadHandle, int DesiredAccess, int OpenAsSelf, MemorySegment TokenHandle) {
        var mh$ = OpenThreadToken.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("OpenThreadToken", ThreadHandle, DesiredAccess, OpenAsSelf, TokenHandle);
            }
            return (int)mh$.invokeExact(ThreadHandle, DesiredAccess, OpenAsSelf, TokenHandle);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetPriorityClass {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("SetPriorityClass"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetPriorityClass(HANDLE hProcess, DWORD dwPriorityClass)
     * }
     */
    public static FunctionDescriptor SetPriorityClass$descriptor() {
        return SetPriorityClass.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetPriorityClass(HANDLE hProcess, DWORD dwPriorityClass)
     * }
     */
    public static MethodHandle SetPriorityClass$handle() {
        return SetPriorityClass.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL SetPriorityClass(HANDLE hProcess, DWORD dwPriorityClass)
     * }
     */
    public static int SetPriorityClass(MemorySegment hProcess, int dwPriorityClass) {
        var mh$ = SetPriorityClass.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetPriorityClass", hProcess, dwPriorityClass);
            }
            return (int)mh$.invokeExact(hProcess, dwPriorityClass);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetPriorityClass {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetPriorityClass"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetPriorityClass(HANDLE hProcess)
     * }
     */
    public static FunctionDescriptor GetPriorityClass$descriptor() {
        return GetPriorityClass.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetPriorityClass(HANDLE hProcess)
     * }
     */
    public static MethodHandle GetPriorityClass$handle() {
        return GetPriorityClass.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * DWORD GetPriorityClass(HANDLE hProcess)
     * }
     */
    public static int GetPriorityClass(MemorySegment hProcess) {
        var mh$ = GetPriorityClass.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetPriorityClass", hProcess);
            }
            return (int)mh$.invokeExact(hProcess);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetThreadStackGuarantee {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("SetThreadStackGuarantee"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetThreadStackGuarantee(PULONG StackSizeInBytes)
     * }
     */
    public static FunctionDescriptor SetThreadStackGuarantee$descriptor() {
        return SetThreadStackGuarantee.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetThreadStackGuarantee(PULONG StackSizeInBytes)
     * }
     */
    public static MethodHandle SetThreadStackGuarantee$handle() {
        return SetThreadStackGuarantee.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL SetThreadStackGuarantee(PULONG StackSizeInBytes)
     * }
     */
    public static int SetThreadStackGuarantee(MemorySegment StackSizeInBytes) {
        var mh$ = SetThreadStackGuarantee.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetThreadStackGuarantee", StackSizeInBytes);
            }
            return (int)mh$.invokeExact(StackSizeInBytes);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ProcessIdToSessionId {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_LONG,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("ProcessIdToSessionId"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL ProcessIdToSessionId(DWORD dwProcessId, DWORD *pSessionId)
     * }
     */
    public static FunctionDescriptor ProcessIdToSessionId$descriptor() {
        return ProcessIdToSessionId.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL ProcessIdToSessionId(DWORD dwProcessId, DWORD *pSessionId)
     * }
     */
    public static MethodHandle ProcessIdToSessionId$handle() {
        return ProcessIdToSessionId.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL ProcessIdToSessionId(DWORD dwProcessId, DWORD *pSessionId)
     * }
     */
    public static int ProcessIdToSessionId(int dwProcessId, MemorySegment pSessionId) {
        var mh$ = ProcessIdToSessionId.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ProcessIdToSessionId", dwProcessId, pSessionId);
            }
            return (int)mh$.invokeExact(dwProcessId, pSessionId);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct _PROC_THREAD_ATTRIBUTE_LIST *PPROC_THREAD_ATTRIBUTE_LIST
     * }
     */
    public static final AddressLayout PPROC_THREAD_ATTRIBUTE_LIST = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _PROC_THREAD_ATTRIBUTE_LIST *LPPROC_THREAD_ATTRIBUTE_LIST
     * }
     */
    public static final AddressLayout LPPROC_THREAD_ATTRIBUTE_LIST = C_POINTER;

    private static class GetProcessId {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetProcessId"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetProcessId(HANDLE Process)
     * }
     */
    public static FunctionDescriptor GetProcessId$descriptor() {
        return GetProcessId.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetProcessId(HANDLE Process)
     * }
     */
    public static MethodHandle GetProcessId$handle() {
        return GetProcessId.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * DWORD GetProcessId(HANDLE Process)
     * }
     */
    public static int GetProcessId(MemorySegment Process) {
        var mh$ = GetProcessId.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetProcessId", Process);
            }
            return (int)mh$.invokeExact(Process);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetThreadId {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetThreadId"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetThreadId(HANDLE Thread)
     * }
     */
    public static FunctionDescriptor GetThreadId$descriptor() {
        return GetThreadId.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetThreadId(HANDLE Thread)
     * }
     */
    public static MethodHandle GetThreadId$handle() {
        return GetThreadId.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * DWORD GetThreadId(HANDLE Thread)
     * }
     */
    public static int GetThreadId(MemorySegment Thread) {
        var mh$ = GetThreadId.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetThreadId", Thread);
            }
            return (int)mh$.invokeExact(Thread);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FlushProcessWriteBuffers {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("FlushProcessWriteBuffers"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void FlushProcessWriteBuffers()
     * }
     */
    public static FunctionDescriptor FlushProcessWriteBuffers$descriptor() {
        return FlushProcessWriteBuffers.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void FlushProcessWriteBuffers()
     * }
     */
    public static MethodHandle FlushProcessWriteBuffers$handle() {
        return FlushProcessWriteBuffers.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * void FlushProcessWriteBuffers()
     * }
     */
    public static void FlushProcessWriteBuffers() {
        var mh$ = FlushProcessWriteBuffers.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FlushProcessWriteBuffers");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetProcessIdOfThread {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetProcessIdOfThread"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetProcessIdOfThread(HANDLE Thread)
     * }
     */
    public static FunctionDescriptor GetProcessIdOfThread$descriptor() {
        return GetProcessIdOfThread.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetProcessIdOfThread(HANDLE Thread)
     * }
     */
    public static MethodHandle GetProcessIdOfThread$handle() {
        return GetProcessIdOfThread.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * DWORD GetProcessIdOfThread(HANDLE Thread)
     * }
     */
    public static int GetProcessIdOfThread(MemorySegment Thread) {
        var mh$ = GetProcessIdOfThread.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetProcessIdOfThread", Thread);
            }
            return (int)mh$.invokeExact(Thread);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class InitializeProcThreadAttributeList {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_LONG,
            C_LONG,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("InitializeProcThreadAttributeList"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL InitializeProcThreadAttributeList(LPPROC_THREAD_ATTRIBUTE_LIST lpAttributeList, DWORD dwAttributeCount, DWORD dwFlags, PSIZE_T lpSize)
     * }
     */
    public static FunctionDescriptor InitializeProcThreadAttributeList$descriptor() {
        return InitializeProcThreadAttributeList.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL InitializeProcThreadAttributeList(LPPROC_THREAD_ATTRIBUTE_LIST lpAttributeList, DWORD dwAttributeCount, DWORD dwFlags, PSIZE_T lpSize)
     * }
     */
    public static MethodHandle InitializeProcThreadAttributeList$handle() {
        return InitializeProcThreadAttributeList.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL InitializeProcThreadAttributeList(LPPROC_THREAD_ATTRIBUTE_LIST lpAttributeList, DWORD dwAttributeCount, DWORD dwFlags, PSIZE_T lpSize)
     * }
     */
    public static int InitializeProcThreadAttributeList(MemorySegment lpAttributeList, int dwAttributeCount, int dwFlags, MemorySegment lpSize) {
        var mh$ = InitializeProcThreadAttributeList.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("InitializeProcThreadAttributeList", lpAttributeList, dwAttributeCount, dwFlags, lpSize);
            }
            return (int)mh$.invokeExact(lpAttributeList, dwAttributeCount, dwFlags, lpSize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DeleteProcThreadAttributeList {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("DeleteProcThreadAttributeList"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void DeleteProcThreadAttributeList(LPPROC_THREAD_ATTRIBUTE_LIST lpAttributeList)
     * }
     */
    public static FunctionDescriptor DeleteProcThreadAttributeList$descriptor() {
        return DeleteProcThreadAttributeList.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void DeleteProcThreadAttributeList(LPPROC_THREAD_ATTRIBUTE_LIST lpAttributeList)
     * }
     */
    public static MethodHandle DeleteProcThreadAttributeList$handle() {
        return DeleteProcThreadAttributeList.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * void DeleteProcThreadAttributeList(LPPROC_THREAD_ATTRIBUTE_LIST lpAttributeList)
     * }
     */
    public static void DeleteProcThreadAttributeList(MemorySegment lpAttributeList) {
        var mh$ = DeleteProcThreadAttributeList.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DeleteProcThreadAttributeList", lpAttributeList);
            }
            mh$.invokeExact(lpAttributeList);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class UpdateProcThreadAttribute {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_LONG,
            C_LONG_LONG,
            C_POINTER,
            C_LONG_LONG,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("UpdateProcThreadAttribute"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL UpdateProcThreadAttribute(LPPROC_THREAD_ATTRIBUTE_LIST lpAttributeList, DWORD dwFlags, DWORD_PTR Attribute, PVOID lpValue, SIZE_T cbSize, PVOID lpPreviousValue, PSIZE_T lpReturnSize)
     * }
     */
    public static FunctionDescriptor UpdateProcThreadAttribute$descriptor() {
        return UpdateProcThreadAttribute.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL UpdateProcThreadAttribute(LPPROC_THREAD_ATTRIBUTE_LIST lpAttributeList, DWORD dwFlags, DWORD_PTR Attribute, PVOID lpValue, SIZE_T cbSize, PVOID lpPreviousValue, PSIZE_T lpReturnSize)
     * }
     */
    public static MethodHandle UpdateProcThreadAttribute$handle() {
        return UpdateProcThreadAttribute.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL UpdateProcThreadAttribute(LPPROC_THREAD_ATTRIBUTE_LIST lpAttributeList, DWORD dwFlags, DWORD_PTR Attribute, PVOID lpValue, SIZE_T cbSize, PVOID lpPreviousValue, PSIZE_T lpReturnSize)
     * }
     */
    public static int UpdateProcThreadAttribute(MemorySegment lpAttributeList, int dwFlags, long Attribute, MemorySegment lpValue, long cbSize, MemorySegment lpPreviousValue, MemorySegment lpReturnSize) {
        var mh$ = UpdateProcThreadAttribute.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("UpdateProcThreadAttribute", lpAttributeList, dwFlags, Attribute, lpValue, cbSize, lpPreviousValue, lpReturnSize);
            }
            return (int)mh$.invokeExact(lpAttributeList, dwFlags, Attribute, lpValue, cbSize, lpPreviousValue, lpReturnSize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetProcessDynamicEHContinuationTargets {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_SHORT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("SetProcessDynamicEHContinuationTargets"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetProcessDynamicEHContinuationTargets(HANDLE Process, USHORT NumberOfTargets, PPROCESS_DYNAMIC_EH_CONTINUATION_TARGET Targets)
     * }
     */
    public static FunctionDescriptor SetProcessDynamicEHContinuationTargets$descriptor() {
        return SetProcessDynamicEHContinuationTargets.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetProcessDynamicEHContinuationTargets(HANDLE Process, USHORT NumberOfTargets, PPROCESS_DYNAMIC_EH_CONTINUATION_TARGET Targets)
     * }
     */
    public static MethodHandle SetProcessDynamicEHContinuationTargets$handle() {
        return SetProcessDynamicEHContinuationTargets.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL SetProcessDynamicEHContinuationTargets(HANDLE Process, USHORT NumberOfTargets, PPROCESS_DYNAMIC_EH_CONTINUATION_TARGET Targets)
     * }
     */
    public static int SetProcessDynamicEHContinuationTargets(MemorySegment Process, short NumberOfTargets, MemorySegment Targets) {
        var mh$ = SetProcessDynamicEHContinuationTargets.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetProcessDynamicEHContinuationTargets", Process, NumberOfTargets, Targets);
            }
            return (int)mh$.invokeExact(Process, NumberOfTargets, Targets);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetProcessDynamicEnforcedCetCompatibleRanges {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_SHORT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("SetProcessDynamicEnforcedCetCompatibleRanges"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetProcessDynamicEnforcedCetCompatibleRanges(HANDLE Process, USHORT NumberOfRanges, PPROCESS_DYNAMIC_ENFORCED_ADDRESS_RANGE Ranges)
     * }
     */
    public static FunctionDescriptor SetProcessDynamicEnforcedCetCompatibleRanges$descriptor() {
        return SetProcessDynamicEnforcedCetCompatibleRanges.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetProcessDynamicEnforcedCetCompatibleRanges(HANDLE Process, USHORT NumberOfRanges, PPROCESS_DYNAMIC_ENFORCED_ADDRESS_RANGE Ranges)
     * }
     */
    public static MethodHandle SetProcessDynamicEnforcedCetCompatibleRanges$handle() {
        return SetProcessDynamicEnforcedCetCompatibleRanges.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL SetProcessDynamicEnforcedCetCompatibleRanges(HANDLE Process, USHORT NumberOfRanges, PPROCESS_DYNAMIC_ENFORCED_ADDRESS_RANGE Ranges)
     * }
     */
    public static int SetProcessDynamicEnforcedCetCompatibleRanges(MemorySegment Process, short NumberOfRanges, MemorySegment Ranges) {
        var mh$ = SetProcessDynamicEnforcedCetCompatibleRanges.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetProcessDynamicEnforcedCetCompatibleRanges", Process, NumberOfRanges, Ranges);
            }
            return (int)mh$.invokeExact(Process, NumberOfRanges, Ranges);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetProcessAffinityUpdateMode {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("SetProcessAffinityUpdateMode"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetProcessAffinityUpdateMode(HANDLE hProcess, DWORD dwFlags)
     * }
     */
    public static FunctionDescriptor SetProcessAffinityUpdateMode$descriptor() {
        return SetProcessAffinityUpdateMode.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetProcessAffinityUpdateMode(HANDLE hProcess, DWORD dwFlags)
     * }
     */
    public static MethodHandle SetProcessAffinityUpdateMode$handle() {
        return SetProcessAffinityUpdateMode.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL SetProcessAffinityUpdateMode(HANDLE hProcess, DWORD dwFlags)
     * }
     */
    public static int SetProcessAffinityUpdateMode(MemorySegment hProcess, int dwFlags) {
        var mh$ = SetProcessAffinityUpdateMode.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetProcessAffinityUpdateMode", hProcess, dwFlags);
            }
            return (int)mh$.invokeExact(hProcess, dwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class QueryProcessAffinityUpdateMode {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("QueryProcessAffinityUpdateMode"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL QueryProcessAffinityUpdateMode(HANDLE hProcess, LPDWORD lpdwFlags)
     * }
     */
    public static FunctionDescriptor QueryProcessAffinityUpdateMode$descriptor() {
        return QueryProcessAffinityUpdateMode.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL QueryProcessAffinityUpdateMode(HANDLE hProcess, LPDWORD lpdwFlags)
     * }
     */
    public static MethodHandle QueryProcessAffinityUpdateMode$handle() {
        return QueryProcessAffinityUpdateMode.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL QueryProcessAffinityUpdateMode(HANDLE hProcess, LPDWORD lpdwFlags)
     * }
     */
    public static int QueryProcessAffinityUpdateMode(MemorySegment hProcess, MemorySegment lpdwFlags) {
        var mh$ = QueryProcessAffinityUpdateMode.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("QueryProcessAffinityUpdateMode", hProcess, lpdwFlags);
            }
            return (int)mh$.invokeExact(hProcess, lpdwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateRemoteThreadEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_LONG_LONG,
            C_POINTER,
            C_POINTER,
            C_LONG,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CreateRemoteThreadEx"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HANDLE CreateRemoteThreadEx(HANDLE hProcess, LPSECURITY_ATTRIBUTES lpThreadAttributes, SIZE_T dwStackSize, LPTHREAD_START_ROUTINE lpStartAddress, LPVOID lpParameter, DWORD dwCreationFlags, LPPROC_THREAD_ATTRIBUTE_LIST lpAttributeList, LPDWORD lpThreadId)
     * }
     */
    public static FunctionDescriptor CreateRemoteThreadEx$descriptor() {
        return CreateRemoteThreadEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HANDLE CreateRemoteThreadEx(HANDLE hProcess, LPSECURITY_ATTRIBUTES lpThreadAttributes, SIZE_T dwStackSize, LPTHREAD_START_ROUTINE lpStartAddress, LPVOID lpParameter, DWORD dwCreationFlags, LPPROC_THREAD_ATTRIBUTE_LIST lpAttributeList, LPDWORD lpThreadId)
     * }
     */
    public static MethodHandle CreateRemoteThreadEx$handle() {
        return CreateRemoteThreadEx.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * HANDLE CreateRemoteThreadEx(HANDLE hProcess, LPSECURITY_ATTRIBUTES lpThreadAttributes, SIZE_T dwStackSize, LPTHREAD_START_ROUTINE lpStartAddress, LPVOID lpParameter, DWORD dwCreationFlags, LPPROC_THREAD_ATTRIBUTE_LIST lpAttributeList, LPDWORD lpThreadId)
     * }
     */
    public static MemorySegment CreateRemoteThreadEx(MemorySegment hProcess, MemorySegment lpThreadAttributes, long dwStackSize, MemorySegment lpStartAddress, MemorySegment lpParameter, int dwCreationFlags, MemorySegment lpAttributeList, MemorySegment lpThreadId) {
        var mh$ = CreateRemoteThreadEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateRemoteThreadEx", hProcess, lpThreadAttributes, dwStackSize, lpStartAddress, lpParameter, dwCreationFlags, lpAttributeList, lpThreadId);
            }
            return (MemorySegment)mh$.invokeExact(hProcess, lpThreadAttributes, dwStackSize, lpStartAddress, lpParameter, dwCreationFlags, lpAttributeList, lpThreadId);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetCurrentThreadStackLimits {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetCurrentThreadStackLimits"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void GetCurrentThreadStackLimits(PULONG_PTR LowLimit, PULONG_PTR HighLimit)
     * }
     */
    public static FunctionDescriptor GetCurrentThreadStackLimits$descriptor() {
        return GetCurrentThreadStackLimits.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void GetCurrentThreadStackLimits(PULONG_PTR LowLimit, PULONG_PTR HighLimit)
     * }
     */
    public static MethodHandle GetCurrentThreadStackLimits$handle() {
        return GetCurrentThreadStackLimits.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * void GetCurrentThreadStackLimits(PULONG_PTR LowLimit, PULONG_PTR HighLimit)
     * }
     */
    public static void GetCurrentThreadStackLimits(MemorySegment LowLimit, MemorySegment HighLimit) {
        var mh$ = GetCurrentThreadStackLimits.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetCurrentThreadStackLimits", LowLimit, HighLimit);
            }
            mh$.invokeExact(LowLimit, HighLimit);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetThreadContext {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetThreadContext"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetThreadContext(HANDLE hThread, LPCONTEXT lpContext)
     * }
     */
    public static FunctionDescriptor GetThreadContext$descriptor() {
        return GetThreadContext.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetThreadContext(HANDLE hThread, LPCONTEXT lpContext)
     * }
     */
    public static MethodHandle GetThreadContext$handle() {
        return GetThreadContext.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL GetThreadContext(HANDLE hThread, LPCONTEXT lpContext)
     * }
     */
    public static int GetThreadContext(MemorySegment hThread, MemorySegment lpContext) {
        var mh$ = GetThreadContext.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetThreadContext", hThread, lpContext);
            }
            return (int)mh$.invokeExact(hThread, lpContext);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetProcessMitigationPolicy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_INT,
            C_POINTER,
            C_LONG_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetProcessMitigationPolicy"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetProcessMitigationPolicy(HANDLE hProcess, PROCESS_MITIGATION_POLICY MitigationPolicy, PVOID lpBuffer, SIZE_T dwLength)
     * }
     */
    public static FunctionDescriptor GetProcessMitigationPolicy$descriptor() {
        return GetProcessMitigationPolicy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetProcessMitigationPolicy(HANDLE hProcess, PROCESS_MITIGATION_POLICY MitigationPolicy, PVOID lpBuffer, SIZE_T dwLength)
     * }
     */
    public static MethodHandle GetProcessMitigationPolicy$handle() {
        return GetProcessMitigationPolicy.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL GetProcessMitigationPolicy(HANDLE hProcess, PROCESS_MITIGATION_POLICY MitigationPolicy, PVOID lpBuffer, SIZE_T dwLength)
     * }
     */
    public static int GetProcessMitigationPolicy(MemorySegment hProcess, int MitigationPolicy, MemorySegment lpBuffer, long dwLength) {
        var mh$ = GetProcessMitigationPolicy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetProcessMitigationPolicy", hProcess, MitigationPolicy, lpBuffer, dwLength);
            }
            return (int)mh$.invokeExact(hProcess, MitigationPolicy, lpBuffer, dwLength);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetThreadContext {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("SetThreadContext"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetThreadContext(HANDLE hThread, const CONTEXT *lpContext)
     * }
     */
    public static FunctionDescriptor SetThreadContext$descriptor() {
        return SetThreadContext.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetThreadContext(HANDLE hThread, const CONTEXT *lpContext)
     * }
     */
    public static MethodHandle SetThreadContext$handle() {
        return SetThreadContext.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL SetThreadContext(HANDLE hThread, const CONTEXT *lpContext)
     * }
     */
    public static int SetThreadContext(MemorySegment hThread, MemorySegment lpContext) {
        var mh$ = SetThreadContext.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetThreadContext", hThread, lpContext);
            }
            return (int)mh$.invokeExact(hThread, lpContext);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetProcessMitigationPolicy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_INT,
            C_POINTER,
            C_LONG_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("SetProcessMitigationPolicy"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetProcessMitigationPolicy(PROCESS_MITIGATION_POLICY MitigationPolicy, PVOID lpBuffer, SIZE_T dwLength)
     * }
     */
    public static FunctionDescriptor SetProcessMitigationPolicy$descriptor() {
        return SetProcessMitigationPolicy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetProcessMitigationPolicy(PROCESS_MITIGATION_POLICY MitigationPolicy, PVOID lpBuffer, SIZE_T dwLength)
     * }
     */
    public static MethodHandle SetProcessMitigationPolicy$handle() {
        return SetProcessMitigationPolicy.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL SetProcessMitigationPolicy(PROCESS_MITIGATION_POLICY MitigationPolicy, PVOID lpBuffer, SIZE_T dwLength)
     * }
     */
    public static int SetProcessMitigationPolicy(int MitigationPolicy, MemorySegment lpBuffer, long dwLength) {
        var mh$ = SetProcessMitigationPolicy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetProcessMitigationPolicy", MitigationPolicy, lpBuffer, dwLength);
            }
            return (int)mh$.invokeExact(MitigationPolicy, lpBuffer, dwLength);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FlushInstructionCache {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_LONG_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("FlushInstructionCache"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL FlushInstructionCache(HANDLE hProcess, LPCVOID lpBaseAddress, SIZE_T dwSize)
     * }
     */
    public static FunctionDescriptor FlushInstructionCache$descriptor() {
        return FlushInstructionCache.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL FlushInstructionCache(HANDLE hProcess, LPCVOID lpBaseAddress, SIZE_T dwSize)
     * }
     */
    public static MethodHandle FlushInstructionCache$handle() {
        return FlushInstructionCache.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL FlushInstructionCache(HANDLE hProcess, LPCVOID lpBaseAddress, SIZE_T dwSize)
     * }
     */
    public static int FlushInstructionCache(MemorySegment hProcess, MemorySegment lpBaseAddress, long dwSize) {
        var mh$ = FlushInstructionCache.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FlushInstructionCache", hProcess, lpBaseAddress, dwSize);
            }
            return (int)mh$.invokeExact(hProcess, lpBaseAddress, dwSize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetThreadTimes {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetThreadTimes"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetThreadTimes(HANDLE hThread, LPFILETIME lpCreationTime, LPFILETIME lpExitTime, LPFILETIME lpKernelTime, LPFILETIME lpUserTime)
     * }
     */
    public static FunctionDescriptor GetThreadTimes$descriptor() {
        return GetThreadTimes.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetThreadTimes(HANDLE hThread, LPFILETIME lpCreationTime, LPFILETIME lpExitTime, LPFILETIME lpKernelTime, LPFILETIME lpUserTime)
     * }
     */
    public static MethodHandle GetThreadTimes$handle() {
        return GetThreadTimes.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL GetThreadTimes(HANDLE hThread, LPFILETIME lpCreationTime, LPFILETIME lpExitTime, LPFILETIME lpKernelTime, LPFILETIME lpUserTime)
     * }
     */
    public static int GetThreadTimes(MemorySegment hThread, MemorySegment lpCreationTime, MemorySegment lpExitTime, MemorySegment lpKernelTime, MemorySegment lpUserTime) {
        var mh$ = GetThreadTimes.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetThreadTimes", hThread, lpCreationTime, lpExitTime, lpKernelTime, lpUserTime);
            }
            return (int)mh$.invokeExact(hThread, lpCreationTime, lpExitTime, lpKernelTime, lpUserTime);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class OpenProcess {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_LONG,
            C_INT,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("OpenProcess"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HANDLE OpenProcess(DWORD dwDesiredAccess, BOOL bInheritHandle, DWORD dwProcessId)
     * }
     */
    public static FunctionDescriptor OpenProcess$descriptor() {
        return OpenProcess.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HANDLE OpenProcess(DWORD dwDesiredAccess, BOOL bInheritHandle, DWORD dwProcessId)
     * }
     */
    public static MethodHandle OpenProcess$handle() {
        return OpenProcess.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * HANDLE OpenProcess(DWORD dwDesiredAccess, BOOL bInheritHandle, DWORD dwProcessId)
     * }
     */
    public static MemorySegment OpenProcess(int dwDesiredAccess, int bInheritHandle, int dwProcessId) {
        var mh$ = OpenProcess.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("OpenProcess", dwDesiredAccess, bInheritHandle, dwProcessId);
            }
            return (MemorySegment)mh$.invokeExact(dwDesiredAccess, bInheritHandle, dwProcessId);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class IsProcessorFeaturePresent {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("IsProcessorFeaturePresent"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL IsProcessorFeaturePresent(DWORD ProcessorFeature)
     * }
     */
    public static FunctionDescriptor IsProcessorFeaturePresent$descriptor() {
        return IsProcessorFeaturePresent.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL IsProcessorFeaturePresent(DWORD ProcessorFeature)
     * }
     */
    public static MethodHandle IsProcessorFeaturePresent$handle() {
        return IsProcessorFeaturePresent.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL IsProcessorFeaturePresent(DWORD ProcessorFeature)
     * }
     */
    public static int IsProcessorFeaturePresent(int ProcessorFeature) {
        var mh$ = IsProcessorFeaturePresent.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("IsProcessorFeaturePresent", ProcessorFeature);
            }
            return (int)mh$.invokeExact(ProcessorFeature);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetProcessHandleCount {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetProcessHandleCount"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetProcessHandleCount(HANDLE hProcess, PDWORD pdwHandleCount)
     * }
     */
    public static FunctionDescriptor GetProcessHandleCount$descriptor() {
        return GetProcessHandleCount.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetProcessHandleCount(HANDLE hProcess, PDWORD pdwHandleCount)
     * }
     */
    public static MethodHandle GetProcessHandleCount$handle() {
        return GetProcessHandleCount.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL GetProcessHandleCount(HANDLE hProcess, PDWORD pdwHandleCount)
     * }
     */
    public static int GetProcessHandleCount(MemorySegment hProcess, MemorySegment pdwHandleCount) {
        var mh$ = GetProcessHandleCount.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetProcessHandleCount", hProcess, pdwHandleCount);
            }
            return (int)mh$.invokeExact(hProcess, pdwHandleCount);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetCurrentProcessorNumber {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG    );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetCurrentProcessorNumber"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetCurrentProcessorNumber()
     * }
     */
    public static FunctionDescriptor GetCurrentProcessorNumber$descriptor() {
        return GetCurrentProcessorNumber.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetCurrentProcessorNumber()
     * }
     */
    public static MethodHandle GetCurrentProcessorNumber$handle() {
        return GetCurrentProcessorNumber.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * DWORD GetCurrentProcessorNumber()
     * }
     */
    public static int GetCurrentProcessorNumber() {
        var mh$ = GetCurrentProcessorNumber.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetCurrentProcessorNumber");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetThreadIdealProcessorEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("SetThreadIdealProcessorEx"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetThreadIdealProcessorEx(HANDLE hThread, PPROCESSOR_NUMBER lpIdealProcessor, PPROCESSOR_NUMBER lpPreviousIdealProcessor)
     * }
     */
    public static FunctionDescriptor SetThreadIdealProcessorEx$descriptor() {
        return SetThreadIdealProcessorEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetThreadIdealProcessorEx(HANDLE hThread, PPROCESSOR_NUMBER lpIdealProcessor, PPROCESSOR_NUMBER lpPreviousIdealProcessor)
     * }
     */
    public static MethodHandle SetThreadIdealProcessorEx$handle() {
        return SetThreadIdealProcessorEx.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL SetThreadIdealProcessorEx(HANDLE hThread, PPROCESSOR_NUMBER lpIdealProcessor, PPROCESSOR_NUMBER lpPreviousIdealProcessor)
     * }
     */
    public static int SetThreadIdealProcessorEx(MemorySegment hThread, MemorySegment lpIdealProcessor, MemorySegment lpPreviousIdealProcessor) {
        var mh$ = SetThreadIdealProcessorEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetThreadIdealProcessorEx", hThread, lpIdealProcessor, lpPreviousIdealProcessor);
            }
            return (int)mh$.invokeExact(hThread, lpIdealProcessor, lpPreviousIdealProcessor);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetThreadIdealProcessorEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetThreadIdealProcessorEx"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetThreadIdealProcessorEx(HANDLE hThread, PPROCESSOR_NUMBER lpIdealProcessor)
     * }
     */
    public static FunctionDescriptor GetThreadIdealProcessorEx$descriptor() {
        return GetThreadIdealProcessorEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetThreadIdealProcessorEx(HANDLE hThread, PPROCESSOR_NUMBER lpIdealProcessor)
     * }
     */
    public static MethodHandle GetThreadIdealProcessorEx$handle() {
        return GetThreadIdealProcessorEx.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL GetThreadIdealProcessorEx(HANDLE hThread, PPROCESSOR_NUMBER lpIdealProcessor)
     * }
     */
    public static int GetThreadIdealProcessorEx(MemorySegment hThread, MemorySegment lpIdealProcessor) {
        var mh$ = GetThreadIdealProcessorEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetThreadIdealProcessorEx", hThread, lpIdealProcessor);
            }
            return (int)mh$.invokeExact(hThread, lpIdealProcessor);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetCurrentProcessorNumberEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetCurrentProcessorNumberEx"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void GetCurrentProcessorNumberEx(PPROCESSOR_NUMBER ProcNumber)
     * }
     */
    public static FunctionDescriptor GetCurrentProcessorNumberEx$descriptor() {
        return GetCurrentProcessorNumberEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void GetCurrentProcessorNumberEx(PPROCESSOR_NUMBER ProcNumber)
     * }
     */
    public static MethodHandle GetCurrentProcessorNumberEx$handle() {
        return GetCurrentProcessorNumberEx.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * void GetCurrentProcessorNumberEx(PPROCESSOR_NUMBER ProcNumber)
     * }
     */
    public static void GetCurrentProcessorNumberEx(MemorySegment ProcNumber) {
        var mh$ = GetCurrentProcessorNumberEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetCurrentProcessorNumberEx", ProcNumber);
            }
            mh$.invokeExact(ProcNumber);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetProcessPriorityBoost {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetProcessPriorityBoost"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetProcessPriorityBoost(HANDLE hProcess, PBOOL pDisablePriorityBoost)
     * }
     */
    public static FunctionDescriptor GetProcessPriorityBoost$descriptor() {
        return GetProcessPriorityBoost.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetProcessPriorityBoost(HANDLE hProcess, PBOOL pDisablePriorityBoost)
     * }
     */
    public static MethodHandle GetProcessPriorityBoost$handle() {
        return GetProcessPriorityBoost.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL GetProcessPriorityBoost(HANDLE hProcess, PBOOL pDisablePriorityBoost)
     * }
     */
    public static int GetProcessPriorityBoost(MemorySegment hProcess, MemorySegment pDisablePriorityBoost) {
        var mh$ = GetProcessPriorityBoost.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetProcessPriorityBoost", hProcess, pDisablePriorityBoost);
            }
            return (int)mh$.invokeExact(hProcess, pDisablePriorityBoost);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetProcessPriorityBoost {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("SetProcessPriorityBoost"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetProcessPriorityBoost(HANDLE hProcess, BOOL bDisablePriorityBoost)
     * }
     */
    public static FunctionDescriptor SetProcessPriorityBoost$descriptor() {
        return SetProcessPriorityBoost.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetProcessPriorityBoost(HANDLE hProcess, BOOL bDisablePriorityBoost)
     * }
     */
    public static MethodHandle SetProcessPriorityBoost$handle() {
        return SetProcessPriorityBoost.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL SetProcessPriorityBoost(HANDLE hProcess, BOOL bDisablePriorityBoost)
     * }
     */
    public static int SetProcessPriorityBoost(MemorySegment hProcess, int bDisablePriorityBoost) {
        var mh$ = SetProcessPriorityBoost.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetProcessPriorityBoost", hProcess, bDisablePriorityBoost);
            }
            return (int)mh$.invokeExact(hProcess, bDisablePriorityBoost);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetThreadIOPendingFlag {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetThreadIOPendingFlag"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetThreadIOPendingFlag(HANDLE hThread, PBOOL lpIOIsPending)
     * }
     */
    public static FunctionDescriptor GetThreadIOPendingFlag$descriptor() {
        return GetThreadIOPendingFlag.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetThreadIOPendingFlag(HANDLE hThread, PBOOL lpIOIsPending)
     * }
     */
    public static MethodHandle GetThreadIOPendingFlag$handle() {
        return GetThreadIOPendingFlag.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL GetThreadIOPendingFlag(HANDLE hThread, PBOOL lpIOIsPending)
     * }
     */
    public static int GetThreadIOPendingFlag(MemorySegment hThread, MemorySegment lpIOIsPending) {
        var mh$ = GetThreadIOPendingFlag.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetThreadIOPendingFlag", hThread, lpIOIsPending);
            }
            return (int)mh$.invokeExact(hThread, lpIOIsPending);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetSystemTimes {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetSystemTimes"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetSystemTimes(PFILETIME lpIdleTime, PFILETIME lpKernelTime, PFILETIME lpUserTime)
     * }
     */
    public static FunctionDescriptor GetSystemTimes$descriptor() {
        return GetSystemTimes.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetSystemTimes(PFILETIME lpIdleTime, PFILETIME lpKernelTime, PFILETIME lpUserTime)
     * }
     */
    public static MethodHandle GetSystemTimes$handle() {
        return GetSystemTimes.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL GetSystemTimes(PFILETIME lpIdleTime, PFILETIME lpKernelTime, PFILETIME lpUserTime)
     * }
     */
    public static int GetSystemTimes(MemorySegment lpIdleTime, MemorySegment lpKernelTime, MemorySegment lpUserTime) {
        var mh$ = GetSystemTimes.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetSystemTimes", lpIdleTime, lpKernelTime, lpUserTime);
            }
            return (int)mh$.invokeExact(lpIdleTime, lpKernelTime, lpUserTime);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int ThreadMemoryPriority = (int)0L;
    /**
     * {@snippet lang=c :
     * enum _THREAD_INFORMATION_CLASS.ThreadMemoryPriority = 0
     * }
     */
    public static int ThreadMemoryPriority() {
        return ThreadMemoryPriority;
    }
    private static final int ThreadAbsoluteCpuPriority = (int)1L;
    /**
     * {@snippet lang=c :
     * enum _THREAD_INFORMATION_CLASS.ThreadAbsoluteCpuPriority = 1
     * }
     */
    public static int ThreadAbsoluteCpuPriority() {
        return ThreadAbsoluteCpuPriority;
    }
    private static final int ThreadDynamicCodePolicy = (int)2L;
    /**
     * {@snippet lang=c :
     * enum _THREAD_INFORMATION_CLASS.ThreadDynamicCodePolicy = 2
     * }
     */
    public static int ThreadDynamicCodePolicy() {
        return ThreadDynamicCodePolicy;
    }
    private static final int ThreadPowerThrottling = (int)3L;
    /**
     * {@snippet lang=c :
     * enum _THREAD_INFORMATION_CLASS.ThreadPowerThrottling = 3
     * }
     */
    public static int ThreadPowerThrottling() {
        return ThreadPowerThrottling;
    }
    private static final int ThreadInformationClassMax = (int)4L;
    /**
     * {@snippet lang=c :
     * enum _THREAD_INFORMATION_CLASS.ThreadInformationClassMax = 4
     * }
     */
    public static int ThreadInformationClassMax() {
        return ThreadInformationClassMax;
    }
    /**
     * {@snippet lang=c :
     * typedef struct _MEMORY_PRIORITY_INFORMATION {
     *     ULONG MemoryPriority;
     * } *PMEMORY_PRIORITY_INFORMATION
     * }
     */
    public static final AddressLayout PMEMORY_PRIORITY_INFORMATION = C_POINTER;

    private static class GetThreadInformation {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_INT,
            C_POINTER,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetThreadInformation"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetThreadInformation(HANDLE hThread, THREAD_INFORMATION_CLASS ThreadInformationClass, LPVOID ThreadInformation, DWORD ThreadInformationSize)
     * }
     */
    public static FunctionDescriptor GetThreadInformation$descriptor() {
        return GetThreadInformation.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetThreadInformation(HANDLE hThread, THREAD_INFORMATION_CLASS ThreadInformationClass, LPVOID ThreadInformation, DWORD ThreadInformationSize)
     * }
     */
    public static MethodHandle GetThreadInformation$handle() {
        return GetThreadInformation.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL GetThreadInformation(HANDLE hThread, THREAD_INFORMATION_CLASS ThreadInformationClass, LPVOID ThreadInformation, DWORD ThreadInformationSize)
     * }
     */
    public static int GetThreadInformation(MemorySegment hThread, int ThreadInformationClass, MemorySegment ThreadInformation, int ThreadInformationSize) {
        var mh$ = GetThreadInformation.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetThreadInformation", hThread, ThreadInformationClass, ThreadInformation, ThreadInformationSize);
            }
            return (int)mh$.invokeExact(hThread, ThreadInformationClass, ThreadInformation, ThreadInformationSize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetThreadInformation {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_INT,
            C_POINTER,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("SetThreadInformation"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetThreadInformation(HANDLE hThread, THREAD_INFORMATION_CLASS ThreadInformationClass, LPVOID ThreadInformation, DWORD ThreadInformationSize)
     * }
     */
    public static FunctionDescriptor SetThreadInformation$descriptor() {
        return SetThreadInformation.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetThreadInformation(HANDLE hThread, THREAD_INFORMATION_CLASS ThreadInformationClass, LPVOID ThreadInformation, DWORD ThreadInformationSize)
     * }
     */
    public static MethodHandle SetThreadInformation$handle() {
        return SetThreadInformation.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL SetThreadInformation(HANDLE hThread, THREAD_INFORMATION_CLASS ThreadInformationClass, LPVOID ThreadInformation, DWORD ThreadInformationSize)
     * }
     */
    public static int SetThreadInformation(MemorySegment hThread, int ThreadInformationClass, MemorySegment ThreadInformation, int ThreadInformationSize) {
        var mh$ = SetThreadInformation.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetThreadInformation", hThread, ThreadInformationClass, ThreadInformation, ThreadInformationSize);
            }
            return (int)mh$.invokeExact(hThread, ThreadInformationClass, ThreadInformation, ThreadInformationSize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class IsProcessCritical {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("IsProcessCritical"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL IsProcessCritical(HANDLE hProcess, PBOOL Critical)
     * }
     */
    public static FunctionDescriptor IsProcessCritical$descriptor() {
        return IsProcessCritical.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL IsProcessCritical(HANDLE hProcess, PBOOL Critical)
     * }
     */
    public static MethodHandle IsProcessCritical$handle() {
        return IsProcessCritical.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL IsProcessCritical(HANDLE hProcess, PBOOL Critical)
     * }
     */
    public static int IsProcessCritical(MemorySegment hProcess, MemorySegment Critical) {
        var mh$ = IsProcessCritical.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("IsProcessCritical", hProcess, Critical);
            }
            return (int)mh$.invokeExact(hProcess, Critical);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetProtectedPolicy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_LONG_LONG,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("SetProtectedPolicy"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetProtectedPolicy(LPCGUID PolicyGuid, ULONG_PTR PolicyValue, PULONG_PTR OldPolicyValue)
     * }
     */
    public static FunctionDescriptor SetProtectedPolicy$descriptor() {
        return SetProtectedPolicy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetProtectedPolicy(LPCGUID PolicyGuid, ULONG_PTR PolicyValue, PULONG_PTR OldPolicyValue)
     * }
     */
    public static MethodHandle SetProtectedPolicy$handle() {
        return SetProtectedPolicy.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL SetProtectedPolicy(LPCGUID PolicyGuid, ULONG_PTR PolicyValue, PULONG_PTR OldPolicyValue)
     * }
     */
    public static int SetProtectedPolicy(MemorySegment PolicyGuid, long PolicyValue, MemorySegment OldPolicyValue) {
        var mh$ = SetProtectedPolicy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetProtectedPolicy", PolicyGuid, PolicyValue, OldPolicyValue);
            }
            return (int)mh$.invokeExact(PolicyGuid, PolicyValue, OldPolicyValue);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class QueryProtectedPolicy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("QueryProtectedPolicy"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL QueryProtectedPolicy(LPCGUID PolicyGuid, PULONG_PTR PolicyValue)
     * }
     */
    public static FunctionDescriptor QueryProtectedPolicy$descriptor() {
        return QueryProtectedPolicy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL QueryProtectedPolicy(LPCGUID PolicyGuid, PULONG_PTR PolicyValue)
     * }
     */
    public static MethodHandle QueryProtectedPolicy$handle() {
        return QueryProtectedPolicy.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL QueryProtectedPolicy(LPCGUID PolicyGuid, PULONG_PTR PolicyValue)
     * }
     */
    public static int QueryProtectedPolicy(MemorySegment PolicyGuid, MemorySegment PolicyValue) {
        var mh$ = QueryProtectedPolicy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("QueryProtectedPolicy", PolicyGuid, PolicyValue);
            }
            return (int)mh$.invokeExact(PolicyGuid, PolicyValue);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetThreadIdealProcessor {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_POINTER,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("SetThreadIdealProcessor"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD SetThreadIdealProcessor(HANDLE hThread, DWORD dwIdealProcessor)
     * }
     */
    public static FunctionDescriptor SetThreadIdealProcessor$descriptor() {
        return SetThreadIdealProcessor.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD SetThreadIdealProcessor(HANDLE hThread, DWORD dwIdealProcessor)
     * }
     */
    public static MethodHandle SetThreadIdealProcessor$handle() {
        return SetThreadIdealProcessor.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * DWORD SetThreadIdealProcessor(HANDLE hThread, DWORD dwIdealProcessor)
     * }
     */
    public static int SetThreadIdealProcessor(MemorySegment hThread, int dwIdealProcessor) {
        var mh$ = SetThreadIdealProcessor.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetThreadIdealProcessor", hThread, dwIdealProcessor);
            }
            return (int)mh$.invokeExact(hThread, dwIdealProcessor);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int ProcessMemoryPriority = (int)0L;
    /**
     * {@snippet lang=c :
     * enum _PROCESS_INFORMATION_CLASS.ProcessMemoryPriority = 0
     * }
     */
    public static int ProcessMemoryPriority() {
        return ProcessMemoryPriority;
    }
    private static final int ProcessMemoryExhaustionInfo = (int)1L;
    /**
     * {@snippet lang=c :
     * enum _PROCESS_INFORMATION_CLASS.ProcessMemoryExhaustionInfo = 1
     * }
     */
    public static int ProcessMemoryExhaustionInfo() {
        return ProcessMemoryExhaustionInfo;
    }
    private static final int ProcessAppMemoryInfo = (int)2L;
    /**
     * {@snippet lang=c :
     * enum _PROCESS_INFORMATION_CLASS.ProcessAppMemoryInfo = 2
     * }
     */
    public static int ProcessAppMemoryInfo() {
        return ProcessAppMemoryInfo;
    }
    private static final int ProcessInPrivateInfo = (int)3L;
    /**
     * {@snippet lang=c :
     * enum _PROCESS_INFORMATION_CLASS.ProcessInPrivateInfo = 3
     * }
     */
    public static int ProcessInPrivateInfo() {
        return ProcessInPrivateInfo;
    }
    private static final int ProcessPowerThrottling = (int)4L;
    /**
     * {@snippet lang=c :
     * enum _PROCESS_INFORMATION_CLASS.ProcessPowerThrottling = 4
     * }
     */
    public static int ProcessPowerThrottling() {
        return ProcessPowerThrottling;
    }
    private static final int ProcessReservedValue1 = (int)5L;
    /**
     * {@snippet lang=c :
     * enum _PROCESS_INFORMATION_CLASS.ProcessReservedValue1 = 5
     * }
     */
    public static int ProcessReservedValue1() {
        return ProcessReservedValue1;
    }
    private static final int ProcessTelemetryCoverageInfo = (int)6L;
    /**
     * {@snippet lang=c :
     * enum _PROCESS_INFORMATION_CLASS.ProcessTelemetryCoverageInfo = 6
     * }
     */
    public static int ProcessTelemetryCoverageInfo() {
        return ProcessTelemetryCoverageInfo;
    }
    private static final int ProcessProtectionLevelInfo = (int)7L;
    /**
     * {@snippet lang=c :
     * enum _PROCESS_INFORMATION_CLASS.ProcessProtectionLevelInfo = 7
     * }
     */
    public static int ProcessProtectionLevelInfo() {
        return ProcessProtectionLevelInfo;
    }
    private static final int ProcessLeapSecondInfo = (int)8L;
    /**
     * {@snippet lang=c :
     * enum _PROCESS_INFORMATION_CLASS.ProcessLeapSecondInfo = 8
     * }
     */
    public static int ProcessLeapSecondInfo() {
        return ProcessLeapSecondInfo;
    }
    private static final int ProcessMachineTypeInfo = (int)9L;
    /**
     * {@snippet lang=c :
     * enum _PROCESS_INFORMATION_CLASS.ProcessMachineTypeInfo = 9
     * }
     */
    public static int ProcessMachineTypeInfo() {
        return ProcessMachineTypeInfo;
    }
    private static final int ProcessInformationClassMax = (int)10L;
    /**
     * {@snippet lang=c :
     * enum _PROCESS_INFORMATION_CLASS.ProcessInformationClassMax = 10
     * }
     */
    public static int ProcessInformationClassMax() {
        return ProcessInformationClassMax;
    }
    /**
     * {@snippet lang=c :
     * typedef struct _APP_MEMORY_INFORMATION {
     *     ULONG64 AvailableCommit;
     *     ULONG64 PrivateCommitUsage;
     *     ULONG64 PeakPrivateCommitUsage;
     *     ULONG64 TotalCommitUsage;
     * } *PAPP_MEMORY_INFORMATION
     * }
     */
    public static final AddressLayout PAPP_MEMORY_INFORMATION = C_POINTER;
    private static final int UserEnabled = (int)1L;
    /**
     * {@snippet lang=c :
     * enum _MACHINE_ATTRIBUTES.UserEnabled = 1
     * }
     */
    public static int UserEnabled() {
        return UserEnabled;
    }
    private static final int KernelEnabled = (int)2L;
    /**
     * {@snippet lang=c :
     * enum _MACHINE_ATTRIBUTES.KernelEnabled = 2
     * }
     */
    public static int KernelEnabled() {
        return KernelEnabled;
    }
    private static final int Wow64Container = (int)4L;
    /**
     * {@snippet lang=c :
     * enum _MACHINE_ATTRIBUTES.Wow64Container = 4
     * }
     */
    public static int Wow64Container() {
        return Wow64Container;
    }
    private static final int PMETypeFailFastOnCommitFailure = (int)0L;
    /**
     * {@snippet lang=c :
     * enum _PROCESS_MEMORY_EXHAUSTION_TYPE.PMETypeFailFastOnCommitFailure = 0
     * }
     */
    public static int PMETypeFailFastOnCommitFailure() {
        return PMETypeFailFastOnCommitFailure;
    }
    private static final int PMETypeMax = (int)1L;
    /**
     * {@snippet lang=c :
     * enum _PROCESS_MEMORY_EXHAUSTION_TYPE.PMETypeMax = 1
     * }
     */
    public static int PMETypeMax() {
        return PMETypeMax;
    }
    /**
     * {@snippet lang=c :
     * typedef enum _PROCESS_MEMORY_EXHAUSTION_TYPE {
     *     PMETypeFailFastOnCommitFailure,
     *     PMETypeMax
     * } *PPROCESS_MEMORY_EXHAUSTION_TYPE
     * }
     */
    public static final AddressLayout PPROCESS_MEMORY_EXHAUSTION_TYPE = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _PROCESS_MEMORY_EXHAUSTION_INFO {
     *     USHORT Version;
     *     USHORT Reserved;
     *     PROCESS_MEMORY_EXHAUSTION_TYPE Type;
     *     ULONG_PTR Value;
     * } *PPROCESS_MEMORY_EXHAUSTION_INFO
     * }
     */
    public static final AddressLayout PPROCESS_MEMORY_EXHAUSTION_INFO = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _PROCESS_POWER_THROTTLING_STATE {
     *     ULONG Version;
     *     ULONG ControlMask;
     *     ULONG StateMask;
     * } *PPROCESS_POWER_THROTTLING_STATE
     * }
     */
    public static final AddressLayout PPROCESS_POWER_THROTTLING_STATE = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _PROCESS_LEAP_SECOND_INFO {
     *     ULONG Flags;
     *     ULONG Reserved;
     * } *PPROCESS_LEAP_SECOND_INFO
     * }
     */
    public static final AddressLayout PPROCESS_LEAP_SECOND_INFO = C_POINTER;

    private static class SetProcessInformation {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_INT,
            C_POINTER,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("SetProcessInformation"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetProcessInformation(HANDLE hProcess, PROCESS_INFORMATION_CLASS ProcessInformationClass, LPVOID ProcessInformation, DWORD ProcessInformationSize)
     * }
     */
    public static FunctionDescriptor SetProcessInformation$descriptor() {
        return SetProcessInformation.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetProcessInformation(HANDLE hProcess, PROCESS_INFORMATION_CLASS ProcessInformationClass, LPVOID ProcessInformation, DWORD ProcessInformationSize)
     * }
     */
    public static MethodHandle SetProcessInformation$handle() {
        return SetProcessInformation.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL SetProcessInformation(HANDLE hProcess, PROCESS_INFORMATION_CLASS ProcessInformationClass, LPVOID ProcessInformation, DWORD ProcessInformationSize)
     * }
     */
    public static int SetProcessInformation(MemorySegment hProcess, int ProcessInformationClass, MemorySegment ProcessInformation, int ProcessInformationSize) {
        var mh$ = SetProcessInformation.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetProcessInformation", hProcess, ProcessInformationClass, ProcessInformation, ProcessInformationSize);
            }
            return (int)mh$.invokeExact(hProcess, ProcessInformationClass, ProcessInformation, ProcessInformationSize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetProcessInformation {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_INT,
            C_POINTER,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetProcessInformation"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetProcessInformation(HANDLE hProcess, PROCESS_INFORMATION_CLASS ProcessInformationClass, LPVOID ProcessInformation, DWORD ProcessInformationSize)
     * }
     */
    public static FunctionDescriptor GetProcessInformation$descriptor() {
        return GetProcessInformation.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetProcessInformation(HANDLE hProcess, PROCESS_INFORMATION_CLASS ProcessInformationClass, LPVOID ProcessInformation, DWORD ProcessInformationSize)
     * }
     */
    public static MethodHandle GetProcessInformation$handle() {
        return GetProcessInformation.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL GetProcessInformation(HANDLE hProcess, PROCESS_INFORMATION_CLASS ProcessInformationClass, LPVOID ProcessInformation, DWORD ProcessInformationSize)
     * }
     */
    public static int GetProcessInformation(MemorySegment hProcess, int ProcessInformationClass, MemorySegment ProcessInformation, int ProcessInformationSize) {
        var mh$ = GetProcessInformation.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetProcessInformation", hProcess, ProcessInformationClass, ProcessInformation, ProcessInformationSize);
            }
            return (int)mh$.invokeExact(hProcess, ProcessInformationClass, ProcessInformation, ProcessInformationSize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetSystemCpuSetInformation {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_LONG,
            C_POINTER,
            C_POINTER,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetSystemCpuSetInformation"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetSystemCpuSetInformation(PSYSTEM_CPU_SET_INFORMATION Information, ULONG BufferLength, PULONG ReturnedLength, HANDLE Process, ULONG Flags)
     * }
     */
    public static FunctionDescriptor GetSystemCpuSetInformation$descriptor() {
        return GetSystemCpuSetInformation.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetSystemCpuSetInformation(PSYSTEM_CPU_SET_INFORMATION Information, ULONG BufferLength, PULONG ReturnedLength, HANDLE Process, ULONG Flags)
     * }
     */
    public static MethodHandle GetSystemCpuSetInformation$handle() {
        return GetSystemCpuSetInformation.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL GetSystemCpuSetInformation(PSYSTEM_CPU_SET_INFORMATION Information, ULONG BufferLength, PULONG ReturnedLength, HANDLE Process, ULONG Flags)
     * }
     */
    public static int GetSystemCpuSetInformation(MemorySegment Information, int BufferLength, MemorySegment ReturnedLength, MemorySegment Process, int Flags) {
        var mh$ = GetSystemCpuSetInformation.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetSystemCpuSetInformation", Information, BufferLength, ReturnedLength, Process, Flags);
            }
            return (int)mh$.invokeExact(Information, BufferLength, ReturnedLength, Process, Flags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetProcessDefaultCpuSets {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_LONG,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetProcessDefaultCpuSets"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetProcessDefaultCpuSets(HANDLE Process, PULONG CpuSetIds, ULONG CpuSetIdCount, PULONG RequiredIdCount)
     * }
     */
    public static FunctionDescriptor GetProcessDefaultCpuSets$descriptor() {
        return GetProcessDefaultCpuSets.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetProcessDefaultCpuSets(HANDLE Process, PULONG CpuSetIds, ULONG CpuSetIdCount, PULONG RequiredIdCount)
     * }
     */
    public static MethodHandle GetProcessDefaultCpuSets$handle() {
        return GetProcessDefaultCpuSets.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL GetProcessDefaultCpuSets(HANDLE Process, PULONG CpuSetIds, ULONG CpuSetIdCount, PULONG RequiredIdCount)
     * }
     */
    public static int GetProcessDefaultCpuSets(MemorySegment Process, MemorySegment CpuSetIds, int CpuSetIdCount, MemorySegment RequiredIdCount) {
        var mh$ = GetProcessDefaultCpuSets.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetProcessDefaultCpuSets", Process, CpuSetIds, CpuSetIdCount, RequiredIdCount);
            }
            return (int)mh$.invokeExact(Process, CpuSetIds, CpuSetIdCount, RequiredIdCount);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetProcessDefaultCpuSets {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("SetProcessDefaultCpuSets"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetProcessDefaultCpuSets(HANDLE Process, const ULONG *CpuSetIds, ULONG CpuSetIdCount)
     * }
     */
    public static FunctionDescriptor SetProcessDefaultCpuSets$descriptor() {
        return SetProcessDefaultCpuSets.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetProcessDefaultCpuSets(HANDLE Process, const ULONG *CpuSetIds, ULONG CpuSetIdCount)
     * }
     */
    public static MethodHandle SetProcessDefaultCpuSets$handle() {
        return SetProcessDefaultCpuSets.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL SetProcessDefaultCpuSets(HANDLE Process, const ULONG *CpuSetIds, ULONG CpuSetIdCount)
     * }
     */
    public static int SetProcessDefaultCpuSets(MemorySegment Process, MemorySegment CpuSetIds, int CpuSetIdCount) {
        var mh$ = SetProcessDefaultCpuSets.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetProcessDefaultCpuSets", Process, CpuSetIds, CpuSetIdCount);
            }
            return (int)mh$.invokeExact(Process, CpuSetIds, CpuSetIdCount);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetThreadSelectedCpuSets {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_LONG,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetThreadSelectedCpuSets"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetThreadSelectedCpuSets(HANDLE Thread, PULONG CpuSetIds, ULONG CpuSetIdCount, PULONG RequiredIdCount)
     * }
     */
    public static FunctionDescriptor GetThreadSelectedCpuSets$descriptor() {
        return GetThreadSelectedCpuSets.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetThreadSelectedCpuSets(HANDLE Thread, PULONG CpuSetIds, ULONG CpuSetIdCount, PULONG RequiredIdCount)
     * }
     */
    public static MethodHandle GetThreadSelectedCpuSets$handle() {
        return GetThreadSelectedCpuSets.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL GetThreadSelectedCpuSets(HANDLE Thread, PULONG CpuSetIds, ULONG CpuSetIdCount, PULONG RequiredIdCount)
     * }
     */
    public static int GetThreadSelectedCpuSets(MemorySegment Thread, MemorySegment CpuSetIds, int CpuSetIdCount, MemorySegment RequiredIdCount) {
        var mh$ = GetThreadSelectedCpuSets.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetThreadSelectedCpuSets", Thread, CpuSetIds, CpuSetIdCount, RequiredIdCount);
            }
            return (int)mh$.invokeExact(Thread, CpuSetIds, CpuSetIdCount, RequiredIdCount);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetThreadSelectedCpuSets {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("SetThreadSelectedCpuSets"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetThreadSelectedCpuSets(HANDLE Thread, const ULONG *CpuSetIds, ULONG CpuSetIdCount)
     * }
     */
    public static FunctionDescriptor SetThreadSelectedCpuSets$descriptor() {
        return SetThreadSelectedCpuSets.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetThreadSelectedCpuSets(HANDLE Thread, const ULONG *CpuSetIds, ULONG CpuSetIdCount)
     * }
     */
    public static MethodHandle SetThreadSelectedCpuSets$handle() {
        return SetThreadSelectedCpuSets.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL SetThreadSelectedCpuSets(HANDLE Thread, const ULONG *CpuSetIds, ULONG CpuSetIdCount)
     * }
     */
    public static int SetThreadSelectedCpuSets(MemorySegment Thread, MemorySegment CpuSetIds, int CpuSetIdCount) {
        var mh$ = SetThreadSelectedCpuSets.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetThreadSelectedCpuSets", Thread, CpuSetIds, CpuSetIdCount);
            }
            return (int)mh$.invokeExact(Thread, CpuSetIds, CpuSetIdCount);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateProcessAsUserA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_INT,
            C_LONG,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CreateProcessAsUserA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CreateProcessAsUserA(HANDLE hToken, LPCSTR lpApplicationName, LPSTR lpCommandLine, LPSECURITY_ATTRIBUTES lpProcessAttributes, LPSECURITY_ATTRIBUTES lpThreadAttributes, BOOL bInheritHandles, DWORD dwCreationFlags, LPVOID lpEnvironment, LPCSTR lpCurrentDirectory, LPSTARTUPINFOA lpStartupInfo, LPPROCESS_INFORMATION lpProcessInformation)
     * }
     */
    public static FunctionDescriptor CreateProcessAsUserA$descriptor() {
        return CreateProcessAsUserA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CreateProcessAsUserA(HANDLE hToken, LPCSTR lpApplicationName, LPSTR lpCommandLine, LPSECURITY_ATTRIBUTES lpProcessAttributes, LPSECURITY_ATTRIBUTES lpThreadAttributes, BOOL bInheritHandles, DWORD dwCreationFlags, LPVOID lpEnvironment, LPCSTR lpCurrentDirectory, LPSTARTUPINFOA lpStartupInfo, LPPROCESS_INFORMATION lpProcessInformation)
     * }
     */
    public static MethodHandle CreateProcessAsUserA$handle() {
        return CreateProcessAsUserA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL CreateProcessAsUserA(HANDLE hToken, LPCSTR lpApplicationName, LPSTR lpCommandLine, LPSECURITY_ATTRIBUTES lpProcessAttributes, LPSECURITY_ATTRIBUTES lpThreadAttributes, BOOL bInheritHandles, DWORD dwCreationFlags, LPVOID lpEnvironment, LPCSTR lpCurrentDirectory, LPSTARTUPINFOA lpStartupInfo, LPPROCESS_INFORMATION lpProcessInformation)
     * }
     */
    public static int CreateProcessAsUserA(MemorySegment hToken, MemorySegment lpApplicationName, MemorySegment lpCommandLine, MemorySegment lpProcessAttributes, MemorySegment lpThreadAttributes, int bInheritHandles, int dwCreationFlags, MemorySegment lpEnvironment, MemorySegment lpCurrentDirectory, MemorySegment lpStartupInfo, MemorySegment lpProcessInformation) {
        var mh$ = CreateProcessAsUserA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateProcessAsUserA", hToken, lpApplicationName, lpCommandLine, lpProcessAttributes, lpThreadAttributes, bInheritHandles, dwCreationFlags, lpEnvironment, lpCurrentDirectory, lpStartupInfo, lpProcessInformation);
            }
            return (int)mh$.invokeExact(hToken, lpApplicationName, lpCommandLine, lpProcessAttributes, lpThreadAttributes, bInheritHandles, dwCreationFlags, lpEnvironment, lpCurrentDirectory, lpStartupInfo, lpProcessInformation);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetProcessShutdownParameters {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetProcessShutdownParameters"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetProcessShutdownParameters(LPDWORD lpdwLevel, LPDWORD lpdwFlags)
     * }
     */
    public static FunctionDescriptor GetProcessShutdownParameters$descriptor() {
        return GetProcessShutdownParameters.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetProcessShutdownParameters(LPDWORD lpdwLevel, LPDWORD lpdwFlags)
     * }
     */
    public static MethodHandle GetProcessShutdownParameters$handle() {
        return GetProcessShutdownParameters.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL GetProcessShutdownParameters(LPDWORD lpdwLevel, LPDWORD lpdwFlags)
     * }
     */
    public static int GetProcessShutdownParameters(MemorySegment lpdwLevel, MemorySegment lpdwFlags) {
        var mh$ = GetProcessShutdownParameters.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetProcessShutdownParameters", lpdwLevel, lpdwFlags);
            }
            return (int)mh$.invokeExact(lpdwLevel, lpdwFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetProcessDefaultCpuSetMasks {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_SHORT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetProcessDefaultCpuSetMasks"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetProcessDefaultCpuSetMasks(HANDLE Process, PGROUP_AFFINITY CpuSetMasks, USHORT CpuSetMaskCount, PUSHORT RequiredMaskCount)
     * }
     */
    public static FunctionDescriptor GetProcessDefaultCpuSetMasks$descriptor() {
        return GetProcessDefaultCpuSetMasks.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetProcessDefaultCpuSetMasks(HANDLE Process, PGROUP_AFFINITY CpuSetMasks, USHORT CpuSetMaskCount, PUSHORT RequiredMaskCount)
     * }
     */
    public static MethodHandle GetProcessDefaultCpuSetMasks$handle() {
        return GetProcessDefaultCpuSetMasks.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL GetProcessDefaultCpuSetMasks(HANDLE Process, PGROUP_AFFINITY CpuSetMasks, USHORT CpuSetMaskCount, PUSHORT RequiredMaskCount)
     * }
     */
    public static int GetProcessDefaultCpuSetMasks(MemorySegment Process, MemorySegment CpuSetMasks, short CpuSetMaskCount, MemorySegment RequiredMaskCount) {
        var mh$ = GetProcessDefaultCpuSetMasks.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetProcessDefaultCpuSetMasks", Process, CpuSetMasks, CpuSetMaskCount, RequiredMaskCount);
            }
            return (int)mh$.invokeExact(Process, CpuSetMasks, CpuSetMaskCount, RequiredMaskCount);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetProcessDefaultCpuSetMasks {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_SHORT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("SetProcessDefaultCpuSetMasks"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetProcessDefaultCpuSetMasks(HANDLE Process, PGROUP_AFFINITY CpuSetMasks, USHORT CpuSetMaskCount)
     * }
     */
    public static FunctionDescriptor SetProcessDefaultCpuSetMasks$descriptor() {
        return SetProcessDefaultCpuSetMasks.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetProcessDefaultCpuSetMasks(HANDLE Process, PGROUP_AFFINITY CpuSetMasks, USHORT CpuSetMaskCount)
     * }
     */
    public static MethodHandle SetProcessDefaultCpuSetMasks$handle() {
        return SetProcessDefaultCpuSetMasks.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL SetProcessDefaultCpuSetMasks(HANDLE Process, PGROUP_AFFINITY CpuSetMasks, USHORT CpuSetMaskCount)
     * }
     */
    public static int SetProcessDefaultCpuSetMasks(MemorySegment Process, MemorySegment CpuSetMasks, short CpuSetMaskCount) {
        var mh$ = SetProcessDefaultCpuSetMasks.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetProcessDefaultCpuSetMasks", Process, CpuSetMasks, CpuSetMaskCount);
            }
            return (int)mh$.invokeExact(Process, CpuSetMasks, CpuSetMaskCount);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetThreadSelectedCpuSetMasks {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_SHORT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetThreadSelectedCpuSetMasks"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetThreadSelectedCpuSetMasks(HANDLE Thread, PGROUP_AFFINITY CpuSetMasks, USHORT CpuSetMaskCount, PUSHORT RequiredMaskCount)
     * }
     */
    public static FunctionDescriptor GetThreadSelectedCpuSetMasks$descriptor() {
        return GetThreadSelectedCpuSetMasks.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetThreadSelectedCpuSetMasks(HANDLE Thread, PGROUP_AFFINITY CpuSetMasks, USHORT CpuSetMaskCount, PUSHORT RequiredMaskCount)
     * }
     */
    public static MethodHandle GetThreadSelectedCpuSetMasks$handle() {
        return GetThreadSelectedCpuSetMasks.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL GetThreadSelectedCpuSetMasks(HANDLE Thread, PGROUP_AFFINITY CpuSetMasks, USHORT CpuSetMaskCount, PUSHORT RequiredMaskCount)
     * }
     */
    public static int GetThreadSelectedCpuSetMasks(MemorySegment Thread, MemorySegment CpuSetMasks, short CpuSetMaskCount, MemorySegment RequiredMaskCount) {
        var mh$ = GetThreadSelectedCpuSetMasks.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetThreadSelectedCpuSetMasks", Thread, CpuSetMasks, CpuSetMaskCount, RequiredMaskCount);
            }
            return (int)mh$.invokeExact(Thread, CpuSetMasks, CpuSetMaskCount, RequiredMaskCount);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetThreadSelectedCpuSetMasks {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_SHORT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("SetThreadSelectedCpuSetMasks"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetThreadSelectedCpuSetMasks(HANDLE Thread, PGROUP_AFFINITY CpuSetMasks, USHORT CpuSetMaskCount)
     * }
     */
    public static FunctionDescriptor SetThreadSelectedCpuSetMasks$descriptor() {
        return SetThreadSelectedCpuSetMasks.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetThreadSelectedCpuSetMasks(HANDLE Thread, PGROUP_AFFINITY CpuSetMasks, USHORT CpuSetMaskCount)
     * }
     */
    public static MethodHandle SetThreadSelectedCpuSetMasks$handle() {
        return SetThreadSelectedCpuSetMasks.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL SetThreadSelectedCpuSetMasks(HANDLE Thread, PGROUP_AFFINITY CpuSetMasks, USHORT CpuSetMaskCount)
     * }
     */
    public static int SetThreadSelectedCpuSetMasks(MemorySegment Thread, MemorySegment CpuSetMasks, short CpuSetMaskCount) {
        var mh$ = SetThreadSelectedCpuSetMasks.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetThreadSelectedCpuSetMasks", Thread, CpuSetMasks, CpuSetMaskCount);
            }
            return (int)mh$.invokeExact(Thread, CpuSetMasks, CpuSetMaskCount);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetMachineTypeAttributes {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_SHORT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetMachineTypeAttributes"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HRESULT GetMachineTypeAttributes(USHORT Machine, MACHINE_ATTRIBUTES *MachineTypeAttributes)
     * }
     */
    public static FunctionDescriptor GetMachineTypeAttributes$descriptor() {
        return GetMachineTypeAttributes.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HRESULT GetMachineTypeAttributes(USHORT Machine, MACHINE_ATTRIBUTES *MachineTypeAttributes)
     * }
     */
    public static MethodHandle GetMachineTypeAttributes$handle() {
        return GetMachineTypeAttributes.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * HRESULT GetMachineTypeAttributes(USHORT Machine, MACHINE_ATTRIBUTES *MachineTypeAttributes)
     * }
     */
    public static int GetMachineTypeAttributes(short Machine, MemorySegment MachineTypeAttributes) {
        var mh$ = GetMachineTypeAttributes.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetMachineTypeAttributes", Machine, MachineTypeAttributes);
            }
            return (int)mh$.invokeExact(Machine, MachineTypeAttributes);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetThreadDescription {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("SetThreadDescription"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HRESULT SetThreadDescription(HANDLE hThread, PCWSTR lpThreadDescription)
     * }
     */
    public static FunctionDescriptor SetThreadDescription$descriptor() {
        return SetThreadDescription.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HRESULT SetThreadDescription(HANDLE hThread, PCWSTR lpThreadDescription)
     * }
     */
    public static MethodHandle SetThreadDescription$handle() {
        return SetThreadDescription.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * HRESULT SetThreadDescription(HANDLE hThread, PCWSTR lpThreadDescription)
     * }
     */
    public static int SetThreadDescription(MemorySegment hThread, MemorySegment lpThreadDescription) {
        var mh$ = SetThreadDescription.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetThreadDescription", hThread, lpThreadDescription);
            }
            return (int)mh$.invokeExact(hThread, lpThreadDescription);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetThreadDescription {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetThreadDescription"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HRESULT GetThreadDescription(HANDLE hThread, PWSTR *ppszThreadDescription)
     * }
     */
    public static FunctionDescriptor GetThreadDescription$descriptor() {
        return GetThreadDescription.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HRESULT GetThreadDescription(HANDLE hThread, PWSTR *ppszThreadDescription)
     * }
     */
    public static MethodHandle GetThreadDescription$handle() {
        return GetThreadDescription.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * HRESULT GetThreadDescription(HANDLE hThread, PWSTR *ppszThreadDescription)
     * }
     */
    public static int GetThreadDescription(MemorySegment hThread, MemorySegment ppszThreadDescription) {
        var mh$ = GetThreadDescription.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetThreadDescription", hThread, ppszThreadDescription);
            }
            return (int)mh$.invokeExact(hThread, ppszThreadDescription);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct _SYSTEM_INFO {
     *     union {
     *         DWORD dwOemId;
     *         struct {
     *             WORD wProcessorArchitecture;
     *             WORD wReserved;
     *         };
     *     };
     *     DWORD dwPageSize;
     *     LPVOID lpMinimumApplicationAddress;
     *     LPVOID lpMaximumApplicationAddress;
     *     DWORD_PTR dwActiveProcessorMask;
     *     DWORD dwNumberOfProcessors;
     *     DWORD dwProcessorType;
     *     DWORD dwAllocationGranularity;
     *     WORD wProcessorLevel;
     *     WORD wProcessorRevision;
     * } *LPSYSTEM_INFO
     * }
     */
    public static final AddressLayout LPSYSTEM_INFO = C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef struct _MEMORYSTATUSEX {
     *     DWORD dwLength;
     *     DWORD dwMemoryLoad;
     *     DWORDLONG ullTotalPhys;
     *     DWORDLONG ullAvailPhys;
     *     DWORDLONG ullTotalPageFile;
     *     DWORDLONG ullAvailPageFile;
     *     DWORDLONG ullTotalVirtual;
     *     DWORDLONG ullAvailVirtual;
     *     DWORDLONG ullAvailExtendedVirtual;
     * } *LPMEMORYSTATUSEX
     * }
     */
    public static final AddressLayout LPMEMORYSTATUSEX = C_POINTER;

    private static class GlobalMemoryStatusEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GlobalMemoryStatusEx"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GlobalMemoryStatusEx(LPMEMORYSTATUSEX lpBuffer)
     * }
     */
    public static FunctionDescriptor GlobalMemoryStatusEx$descriptor() {
        return GlobalMemoryStatusEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GlobalMemoryStatusEx(LPMEMORYSTATUSEX lpBuffer)
     * }
     */
    public static MethodHandle GlobalMemoryStatusEx$handle() {
        return GlobalMemoryStatusEx.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL GlobalMemoryStatusEx(LPMEMORYSTATUSEX lpBuffer)
     * }
     */
    public static int GlobalMemoryStatusEx(MemorySegment lpBuffer) {
        var mh$ = GlobalMemoryStatusEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GlobalMemoryStatusEx", lpBuffer);
            }
            return (int)mh$.invokeExact(lpBuffer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetSystemInfo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetSystemInfo"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void GetSystemInfo(LPSYSTEM_INFO lpSystemInfo)
     * }
     */
    public static FunctionDescriptor GetSystemInfo$descriptor() {
        return GetSystemInfo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void GetSystemInfo(LPSYSTEM_INFO lpSystemInfo)
     * }
     */
    public static MethodHandle GetSystemInfo$handle() {
        return GetSystemInfo.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * void GetSystemInfo(LPSYSTEM_INFO lpSystemInfo)
     * }
     */
    public static void GetSystemInfo(MemorySegment lpSystemInfo) {
        var mh$ = GetSystemInfo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetSystemInfo", lpSystemInfo);
            }
            mh$.invokeExact(lpSystemInfo);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetSystemTime {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetSystemTime"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void GetSystemTime(LPSYSTEMTIME lpSystemTime)
     * }
     */
    public static FunctionDescriptor GetSystemTime$descriptor() {
        return GetSystemTime.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void GetSystemTime(LPSYSTEMTIME lpSystemTime)
     * }
     */
    public static MethodHandle GetSystemTime$handle() {
        return GetSystemTime.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * void GetSystemTime(LPSYSTEMTIME lpSystemTime)
     * }
     */
    public static void GetSystemTime(MemorySegment lpSystemTime) {
        var mh$ = GetSystemTime.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetSystemTime", lpSystemTime);
            }
            mh$.invokeExact(lpSystemTime);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetSystemTimeAsFileTime {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetSystemTimeAsFileTime"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void GetSystemTimeAsFileTime(LPFILETIME lpSystemTimeAsFileTime)
     * }
     */
    public static FunctionDescriptor GetSystemTimeAsFileTime$descriptor() {
        return GetSystemTimeAsFileTime.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void GetSystemTimeAsFileTime(LPFILETIME lpSystemTimeAsFileTime)
     * }
     */
    public static MethodHandle GetSystemTimeAsFileTime$handle() {
        return GetSystemTimeAsFileTime.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * void GetSystemTimeAsFileTime(LPFILETIME lpSystemTimeAsFileTime)
     * }
     */
    public static void GetSystemTimeAsFileTime(MemorySegment lpSystemTimeAsFileTime) {
        var mh$ = GetSystemTimeAsFileTime.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetSystemTimeAsFileTime", lpSystemTimeAsFileTime);
            }
            mh$.invokeExact(lpSystemTimeAsFileTime);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetLocalTime {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetLocalTime"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void GetLocalTime(LPSYSTEMTIME lpSystemTime)
     * }
     */
    public static FunctionDescriptor GetLocalTime$descriptor() {
        return GetLocalTime.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void GetLocalTime(LPSYSTEMTIME lpSystemTime)
     * }
     */
    public static MethodHandle GetLocalTime$handle() {
        return GetLocalTime.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * void GetLocalTime(LPSYSTEMTIME lpSystemTime)
     * }
     */
    public static void GetLocalTime(MemorySegment lpSystemTime) {
        var mh$ = GetLocalTime.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetLocalTime", lpSystemTime);
            }
            mh$.invokeExact(lpSystemTime);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class IsUserCetAvailableInEnvironment {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("IsUserCetAvailableInEnvironment"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL IsUserCetAvailableInEnvironment(DWORD UserCetEnvironment)
     * }
     */
    public static FunctionDescriptor IsUserCetAvailableInEnvironment$descriptor() {
        return IsUserCetAvailableInEnvironment.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL IsUserCetAvailableInEnvironment(DWORD UserCetEnvironment)
     * }
     */
    public static MethodHandle IsUserCetAvailableInEnvironment$handle() {
        return IsUserCetAvailableInEnvironment.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL IsUserCetAvailableInEnvironment(DWORD UserCetEnvironment)
     * }
     */
    public static int IsUserCetAvailableInEnvironment(int UserCetEnvironment) {
        var mh$ = IsUserCetAvailableInEnvironment.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("IsUserCetAvailableInEnvironment", UserCetEnvironment);
            }
            return (int)mh$.invokeExact(UserCetEnvironment);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetSystemLeapSecondInformation {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetSystemLeapSecondInformation"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetSystemLeapSecondInformation(PBOOL Enabled, PDWORD Flags)
     * }
     */
    public static FunctionDescriptor GetSystemLeapSecondInformation$descriptor() {
        return GetSystemLeapSecondInformation.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetSystemLeapSecondInformation(PBOOL Enabled, PDWORD Flags)
     * }
     */
    public static MethodHandle GetSystemLeapSecondInformation$handle() {
        return GetSystemLeapSecondInformation.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL GetSystemLeapSecondInformation(PBOOL Enabled, PDWORD Flags)
     * }
     */
    public static int GetSystemLeapSecondInformation(MemorySegment Enabled, MemorySegment Flags) {
        var mh$ = GetSystemLeapSecondInformation.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetSystemLeapSecondInformation", Enabled, Flags);
            }
            return (int)mh$.invokeExact(Enabled, Flags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetVersion {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG    );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetVersion"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetVersion()
     * }
     */
    public static FunctionDescriptor GetVersion$descriptor() {
        return GetVersion.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetVersion()
     * }
     */
    public static MethodHandle GetVersion$handle() {
        return GetVersion.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * DWORD GetVersion()
     * }
     */
    public static int GetVersion() {
        var mh$ = GetVersion.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetVersion");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetLocalTime {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("SetLocalTime"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetLocalTime(const SYSTEMTIME *lpSystemTime)
     * }
     */
    public static FunctionDescriptor SetLocalTime$descriptor() {
        return SetLocalTime.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetLocalTime(const SYSTEMTIME *lpSystemTime)
     * }
     */
    public static MethodHandle SetLocalTime$handle() {
        return SetLocalTime.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL SetLocalTime(const SYSTEMTIME *lpSystemTime)
     * }
     */
    public static int SetLocalTime(MemorySegment lpSystemTime) {
        var mh$ = SetLocalTime.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetLocalTime", lpSystemTime);
            }
            return (int)mh$.invokeExact(lpSystemTime);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetTickCount {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG    );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetTickCount"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD GetTickCount()
     * }
     */
    public static FunctionDescriptor GetTickCount$descriptor() {
        return GetTickCount.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD GetTickCount()
     * }
     */
    public static MethodHandle GetTickCount$handle() {
        return GetTickCount.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * DWORD GetTickCount()
     * }
     */
    public static int GetTickCount() {
        var mh$ = GetTickCount.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetTickCount");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetTickCount64 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG_LONG    );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetTickCount64"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ULONGLONG GetTickCount64()
     * }
     */
    public static FunctionDescriptor GetTickCount64$descriptor() {
        return GetTickCount64.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ULONGLONG GetTickCount64()
     * }
     */
    public static MethodHandle GetTickCount64$handle() {
        return GetTickCount64.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * ULONGLONG GetTickCount64()
     * }
     */
    public static long GetTickCount64() {
        var mh$ = GetTickCount64.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetTickCount64");
            }
            return (long)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetSystemTimeAdjustment {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetSystemTimeAdjustment"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetSystemTimeAdjustment(PDWORD lpTimeAdjustment, PDWORD lpTimeIncrement, PBOOL lpTimeAdjustmentDisabled)
     * }
     */
    public static FunctionDescriptor GetSystemTimeAdjustment$descriptor() {
        return GetSystemTimeAdjustment.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetSystemTimeAdjustment(PDWORD lpTimeAdjustment, PDWORD lpTimeIncrement, PBOOL lpTimeAdjustmentDisabled)
     * }
     */
    public static MethodHandle GetSystemTimeAdjustment$handle() {
        return GetSystemTimeAdjustment.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL GetSystemTimeAdjustment(PDWORD lpTimeAdjustment, PDWORD lpTimeIncrement, PBOOL lpTimeAdjustmentDisabled)
     * }
     */
    public static int GetSystemTimeAdjustment(MemorySegment lpTimeAdjustment, MemorySegment lpTimeIncrement, MemorySegment lpTimeAdjustmentDisabled) {
        var mh$ = GetSystemTimeAdjustment.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetSystemTimeAdjustment", lpTimeAdjustment, lpTimeIncrement, lpTimeAdjustmentDisabled);
            }
            return (int)mh$.invokeExact(lpTimeAdjustment, lpTimeIncrement, lpTimeAdjustmentDisabled);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetSystemTimeAdjustmentPrecise {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetSystemTimeAdjustmentPrecise"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetSystemTimeAdjustmentPrecise(PDWORD64 lpTimeAdjustment, PDWORD64 lpTimeIncrement, PBOOL lpTimeAdjustmentDisabled)
     * }
     */
    public static FunctionDescriptor GetSystemTimeAdjustmentPrecise$descriptor() {
        return GetSystemTimeAdjustmentPrecise.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetSystemTimeAdjustmentPrecise(PDWORD64 lpTimeAdjustment, PDWORD64 lpTimeIncrement, PBOOL lpTimeAdjustmentDisabled)
     * }
     */
    public static MethodHandle GetSystemTimeAdjustmentPrecise$handle() {
        return GetSystemTimeAdjustmentPrecise.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL GetSystemTimeAdjustmentPrecise(PDWORD64 lpTimeAdjustment, PDWORD64 lpTimeIncrement, PBOOL lpTimeAdjustmentDisabled)
     * }
     */
    public static int GetSystemTimeAdjustmentPrecise(MemorySegment lpTimeAdjustment, MemorySegment lpTimeIncrement, MemorySegment lpTimeAdjustmentDisabled) {
        var mh$ = GetSystemTimeAdjustmentPrecise.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetSystemTimeAdjustmentPrecise", lpTimeAdjustment, lpTimeIncrement, lpTimeAdjustmentDisabled);
            }
            return (int)mh$.invokeExact(lpTimeAdjustment, lpTimeIncrement, lpTimeAdjustmentDisabled);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetSystemDirectoryA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetSystemDirectoryA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * UINT GetSystemDirectoryA(LPSTR lpBuffer, UINT uSize)
     * }
     */
    public static FunctionDescriptor GetSystemDirectoryA$descriptor() {
        return GetSystemDirectoryA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * UINT GetSystemDirectoryA(LPSTR lpBuffer, UINT uSize)
     * }
     */
    public static MethodHandle GetSystemDirectoryA$handle() {
        return GetSystemDirectoryA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * UINT GetSystemDirectoryA(LPSTR lpBuffer, UINT uSize)
     * }
     */
    public static int GetSystemDirectoryA(MemorySegment lpBuffer, int uSize) {
        var mh$ = GetSystemDirectoryA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetSystemDirectoryA", lpBuffer, uSize);
            }
            return (int)mh$.invokeExact(lpBuffer, uSize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetSystemDirectoryW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetSystemDirectoryW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * UINT GetSystemDirectoryW(LPWSTR lpBuffer, UINT uSize)
     * }
     */
    public static FunctionDescriptor GetSystemDirectoryW$descriptor() {
        return GetSystemDirectoryW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * UINT GetSystemDirectoryW(LPWSTR lpBuffer, UINT uSize)
     * }
     */
    public static MethodHandle GetSystemDirectoryW$handle() {
        return GetSystemDirectoryW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * UINT GetSystemDirectoryW(LPWSTR lpBuffer, UINT uSize)
     * }
     */
    public static int GetSystemDirectoryW(MemorySegment lpBuffer, int uSize) {
        var mh$ = GetSystemDirectoryW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetSystemDirectoryW", lpBuffer, uSize);
            }
            return (int)mh$.invokeExact(lpBuffer, uSize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetWindowsDirectoryA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetWindowsDirectoryA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * UINT GetWindowsDirectoryA(LPSTR lpBuffer, UINT uSize)
     * }
     */
    public static FunctionDescriptor GetWindowsDirectoryA$descriptor() {
        return GetWindowsDirectoryA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * UINT GetWindowsDirectoryA(LPSTR lpBuffer, UINT uSize)
     * }
     */
    public static MethodHandle GetWindowsDirectoryA$handle() {
        return GetWindowsDirectoryA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * UINT GetWindowsDirectoryA(LPSTR lpBuffer, UINT uSize)
     * }
     */
    public static int GetWindowsDirectoryA(MemorySegment lpBuffer, int uSize) {
        var mh$ = GetWindowsDirectoryA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetWindowsDirectoryA", lpBuffer, uSize);
            }
            return (int)mh$.invokeExact(lpBuffer, uSize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetWindowsDirectoryW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetWindowsDirectoryW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * UINT GetWindowsDirectoryW(LPWSTR lpBuffer, UINT uSize)
     * }
     */
    public static FunctionDescriptor GetWindowsDirectoryW$descriptor() {
        return GetWindowsDirectoryW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * UINT GetWindowsDirectoryW(LPWSTR lpBuffer, UINT uSize)
     * }
     */
    public static MethodHandle GetWindowsDirectoryW$handle() {
        return GetWindowsDirectoryW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * UINT GetWindowsDirectoryW(LPWSTR lpBuffer, UINT uSize)
     * }
     */
    public static int GetWindowsDirectoryW(MemorySegment lpBuffer, int uSize) {
        var mh$ = GetWindowsDirectoryW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetWindowsDirectoryW", lpBuffer, uSize);
            }
            return (int)mh$.invokeExact(lpBuffer, uSize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetSystemWindowsDirectoryA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetSystemWindowsDirectoryA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * UINT GetSystemWindowsDirectoryA(LPSTR lpBuffer, UINT uSize)
     * }
     */
    public static FunctionDescriptor GetSystemWindowsDirectoryA$descriptor() {
        return GetSystemWindowsDirectoryA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * UINT GetSystemWindowsDirectoryA(LPSTR lpBuffer, UINT uSize)
     * }
     */
    public static MethodHandle GetSystemWindowsDirectoryA$handle() {
        return GetSystemWindowsDirectoryA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * UINT GetSystemWindowsDirectoryA(LPSTR lpBuffer, UINT uSize)
     * }
     */
    public static int GetSystemWindowsDirectoryA(MemorySegment lpBuffer, int uSize) {
        var mh$ = GetSystemWindowsDirectoryA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetSystemWindowsDirectoryA", lpBuffer, uSize);
            }
            return (int)mh$.invokeExact(lpBuffer, uSize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetSystemWindowsDirectoryW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetSystemWindowsDirectoryW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * UINT GetSystemWindowsDirectoryW(LPWSTR lpBuffer, UINT uSize)
     * }
     */
    public static FunctionDescriptor GetSystemWindowsDirectoryW$descriptor() {
        return GetSystemWindowsDirectoryW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * UINT GetSystemWindowsDirectoryW(LPWSTR lpBuffer, UINT uSize)
     * }
     */
    public static MethodHandle GetSystemWindowsDirectoryW$handle() {
        return GetSystemWindowsDirectoryW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * UINT GetSystemWindowsDirectoryW(LPWSTR lpBuffer, UINT uSize)
     * }
     */
    public static int GetSystemWindowsDirectoryW(MemorySegment lpBuffer, int uSize) {
        var mh$ = GetSystemWindowsDirectoryW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetSystemWindowsDirectoryW", lpBuffer, uSize);
            }
            return (int)mh$.invokeExact(lpBuffer, uSize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int ComputerNameNetBIOS = (int)0L;
    /**
     * {@snippet lang=c :
     * enum _COMPUTER_NAME_FORMAT.ComputerNameNetBIOS = 0
     * }
     */
    public static int ComputerNameNetBIOS() {
        return ComputerNameNetBIOS;
    }
    private static final int ComputerNameDnsHostname = (int)1L;
    /**
     * {@snippet lang=c :
     * enum _COMPUTER_NAME_FORMAT.ComputerNameDnsHostname = 1
     * }
     */
    public static int ComputerNameDnsHostname() {
        return ComputerNameDnsHostname;
    }
    private static final int ComputerNameDnsDomain = (int)2L;
    /**
     * {@snippet lang=c :
     * enum _COMPUTER_NAME_FORMAT.ComputerNameDnsDomain = 2
     * }
     */
    public static int ComputerNameDnsDomain() {
        return ComputerNameDnsDomain;
    }
    private static final int ComputerNameDnsFullyQualified = (int)3L;
    /**
     * {@snippet lang=c :
     * enum _COMPUTER_NAME_FORMAT.ComputerNameDnsFullyQualified = 3
     * }
     */
    public static int ComputerNameDnsFullyQualified() {
        return ComputerNameDnsFullyQualified;
    }
    private static final int ComputerNamePhysicalNetBIOS = (int)4L;
    /**
     * {@snippet lang=c :
     * enum _COMPUTER_NAME_FORMAT.ComputerNamePhysicalNetBIOS = 4
     * }
     */
    public static int ComputerNamePhysicalNetBIOS() {
        return ComputerNamePhysicalNetBIOS;
    }
    private static final int ComputerNamePhysicalDnsHostname = (int)5L;
    /**
     * {@snippet lang=c :
     * enum _COMPUTER_NAME_FORMAT.ComputerNamePhysicalDnsHostname = 5
     * }
     */
    public static int ComputerNamePhysicalDnsHostname() {
        return ComputerNamePhysicalDnsHostname;
    }
    private static final int ComputerNamePhysicalDnsDomain = (int)6L;
    /**
     * {@snippet lang=c :
     * enum _COMPUTER_NAME_FORMAT.ComputerNamePhysicalDnsDomain = 6
     * }
     */
    public static int ComputerNamePhysicalDnsDomain() {
        return ComputerNamePhysicalDnsDomain;
    }
    private static final int ComputerNamePhysicalDnsFullyQualified = (int)7L;
    /**
     * {@snippet lang=c :
     * enum _COMPUTER_NAME_FORMAT.ComputerNamePhysicalDnsFullyQualified = 7
     * }
     */
    public static int ComputerNamePhysicalDnsFullyQualified() {
        return ComputerNamePhysicalDnsFullyQualified;
    }
    private static final int ComputerNameMax = (int)8L;
    /**
     * {@snippet lang=c :
     * enum _COMPUTER_NAME_FORMAT.ComputerNameMax = 8
     * }
     */
    public static int ComputerNameMax() {
        return ComputerNameMax;
    }

    private static class GetComputerNameExA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_INT,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetComputerNameExA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetComputerNameExA(COMPUTER_NAME_FORMAT NameType, LPSTR lpBuffer, LPDWORD nSize)
     * }
     */
    public static FunctionDescriptor GetComputerNameExA$descriptor() {
        return GetComputerNameExA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetComputerNameExA(COMPUTER_NAME_FORMAT NameType, LPSTR lpBuffer, LPDWORD nSize)
     * }
     */
    public static MethodHandle GetComputerNameExA$handle() {
        return GetComputerNameExA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL GetComputerNameExA(COMPUTER_NAME_FORMAT NameType, LPSTR lpBuffer, LPDWORD nSize)
     * }
     */
    public static int GetComputerNameExA(int NameType, MemorySegment lpBuffer, MemorySegment nSize) {
        var mh$ = GetComputerNameExA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetComputerNameExA", NameType, lpBuffer, nSize);
            }
            return (int)mh$.invokeExact(NameType, lpBuffer, nSize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetComputerNameExW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_INT,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetComputerNameExW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetComputerNameExW(COMPUTER_NAME_FORMAT NameType, LPWSTR lpBuffer, LPDWORD nSize)
     * }
     */
    public static FunctionDescriptor GetComputerNameExW$descriptor() {
        return GetComputerNameExW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetComputerNameExW(COMPUTER_NAME_FORMAT NameType, LPWSTR lpBuffer, LPDWORD nSize)
     * }
     */
    public static MethodHandle GetComputerNameExW$handle() {
        return GetComputerNameExW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL GetComputerNameExW(COMPUTER_NAME_FORMAT NameType, LPWSTR lpBuffer, LPDWORD nSize)
     * }
     */
    public static int GetComputerNameExW(int NameType, MemorySegment lpBuffer, MemorySegment nSize) {
        var mh$ = GetComputerNameExW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetComputerNameExW", NameType, lpBuffer, nSize);
            }
            return (int)mh$.invokeExact(NameType, lpBuffer, nSize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetComputerNameExW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("SetComputerNameExW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetComputerNameExW(COMPUTER_NAME_FORMAT NameType, LPCWSTR lpBuffer)
     * }
     */
    public static FunctionDescriptor SetComputerNameExW$descriptor() {
        return SetComputerNameExW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetComputerNameExW(COMPUTER_NAME_FORMAT NameType, LPCWSTR lpBuffer)
     * }
     */
    public static MethodHandle SetComputerNameExW$handle() {
        return SetComputerNameExW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL SetComputerNameExW(COMPUTER_NAME_FORMAT NameType, LPCWSTR lpBuffer)
     * }
     */
    public static int SetComputerNameExW(int NameType, MemorySegment lpBuffer) {
        var mh$ = SetComputerNameExW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetComputerNameExW", NameType, lpBuffer);
            }
            return (int)mh$.invokeExact(NameType, lpBuffer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetSystemTime {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("SetSystemTime"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetSystemTime(const SYSTEMTIME *lpSystemTime)
     * }
     */
    public static FunctionDescriptor SetSystemTime$descriptor() {
        return SetSystemTime.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetSystemTime(const SYSTEMTIME *lpSystemTime)
     * }
     */
    public static MethodHandle SetSystemTime$handle() {
        return SetSystemTime.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL SetSystemTime(const SYSTEMTIME *lpSystemTime)
     * }
     */
    public static int SetSystemTime(MemorySegment lpSystemTime) {
        var mh$ = SetSystemTime.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetSystemTime", lpSystemTime);
            }
            return (int)mh$.invokeExact(lpSystemTime);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetVersionExA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetVersionExA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetVersionExA(LPOSVERSIONINFOA lpVersionInformation)
     * }
     */
    public static FunctionDescriptor GetVersionExA$descriptor() {
        return GetVersionExA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetVersionExA(LPOSVERSIONINFOA lpVersionInformation)
     * }
     */
    public static MethodHandle GetVersionExA$handle() {
        return GetVersionExA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL GetVersionExA(LPOSVERSIONINFOA lpVersionInformation)
     * }
     */
    public static int GetVersionExA(MemorySegment lpVersionInformation) {
        var mh$ = GetVersionExA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetVersionExA", lpVersionInformation);
            }
            return (int)mh$.invokeExact(lpVersionInformation);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetVersionExW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetVersionExW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetVersionExW(LPOSVERSIONINFOW lpVersionInformation)
     * }
     */
    public static FunctionDescriptor GetVersionExW$descriptor() {
        return GetVersionExW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetVersionExW(LPOSVERSIONINFOW lpVersionInformation)
     * }
     */
    public static MethodHandle GetVersionExW$handle() {
        return GetVersionExW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL GetVersionExW(LPOSVERSIONINFOW lpVersionInformation)
     * }
     */
    public static int GetVersionExW(MemorySegment lpVersionInformation) {
        var mh$ = GetVersionExW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetVersionExW", lpVersionInformation);
            }
            return (int)mh$.invokeExact(lpVersionInformation);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetLogicalProcessorInformation {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetLogicalProcessorInformation"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetLogicalProcessorInformation(PSYSTEM_LOGICAL_PROCESSOR_INFORMATION Buffer, PDWORD ReturnedLength)
     * }
     */
    public static FunctionDescriptor GetLogicalProcessorInformation$descriptor() {
        return GetLogicalProcessorInformation.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetLogicalProcessorInformation(PSYSTEM_LOGICAL_PROCESSOR_INFORMATION Buffer, PDWORD ReturnedLength)
     * }
     */
    public static MethodHandle GetLogicalProcessorInformation$handle() {
        return GetLogicalProcessorInformation.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL GetLogicalProcessorInformation(PSYSTEM_LOGICAL_PROCESSOR_INFORMATION Buffer, PDWORD ReturnedLength)
     * }
     */
    public static int GetLogicalProcessorInformation(MemorySegment Buffer, MemorySegment ReturnedLength) {
        var mh$ = GetLogicalProcessorInformation.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetLogicalProcessorInformation", Buffer, ReturnedLength);
            }
            return (int)mh$.invokeExact(Buffer, ReturnedLength);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetLogicalProcessorInformationEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_INT,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetLogicalProcessorInformationEx"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetLogicalProcessorInformationEx(LOGICAL_PROCESSOR_RELATIONSHIP RelationshipType, PSYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX Buffer, PDWORD ReturnedLength)
     * }
     */
    public static FunctionDescriptor GetLogicalProcessorInformationEx$descriptor() {
        return GetLogicalProcessorInformationEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetLogicalProcessorInformationEx(LOGICAL_PROCESSOR_RELATIONSHIP RelationshipType, PSYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX Buffer, PDWORD ReturnedLength)
     * }
     */
    public static MethodHandle GetLogicalProcessorInformationEx$handle() {
        return GetLogicalProcessorInformationEx.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL GetLogicalProcessorInformationEx(LOGICAL_PROCESSOR_RELATIONSHIP RelationshipType, PSYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX Buffer, PDWORD ReturnedLength)
     * }
     */
    public static int GetLogicalProcessorInformationEx(int RelationshipType, MemorySegment Buffer, MemorySegment ReturnedLength) {
        var mh$ = GetLogicalProcessorInformationEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetLogicalProcessorInformationEx", RelationshipType, Buffer, ReturnedLength);
            }
            return (int)mh$.invokeExact(RelationshipType, Buffer, ReturnedLength);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetNativeSystemInfo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetNativeSystemInfo"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void GetNativeSystemInfo(LPSYSTEM_INFO lpSystemInfo)
     * }
     */
    public static FunctionDescriptor GetNativeSystemInfo$descriptor() {
        return GetNativeSystemInfo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void GetNativeSystemInfo(LPSYSTEM_INFO lpSystemInfo)
     * }
     */
    public static MethodHandle GetNativeSystemInfo$handle() {
        return GetNativeSystemInfo.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * void GetNativeSystemInfo(LPSYSTEM_INFO lpSystemInfo)
     * }
     */
    public static void GetNativeSystemInfo(MemorySegment lpSystemInfo) {
        var mh$ = GetNativeSystemInfo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetNativeSystemInfo", lpSystemInfo);
            }
            mh$.invokeExact(lpSystemInfo);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetSystemTimePreciseAsFileTime {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetSystemTimePreciseAsFileTime"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void GetSystemTimePreciseAsFileTime(LPFILETIME lpSystemTimeAsFileTime)
     * }
     */
    public static FunctionDescriptor GetSystemTimePreciseAsFileTime$descriptor() {
        return GetSystemTimePreciseAsFileTime.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void GetSystemTimePreciseAsFileTime(LPFILETIME lpSystemTimeAsFileTime)
     * }
     */
    public static MethodHandle GetSystemTimePreciseAsFileTime$handle() {
        return GetSystemTimePreciseAsFileTime.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * void GetSystemTimePreciseAsFileTime(LPFILETIME lpSystemTimeAsFileTime)
     * }
     */
    public static void GetSystemTimePreciseAsFileTime(MemorySegment lpSystemTimeAsFileTime) {
        var mh$ = GetSystemTimePreciseAsFileTime.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetSystemTimePreciseAsFileTime", lpSystemTimeAsFileTime);
            }
            mh$.invokeExact(lpSystemTimeAsFileTime);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetProductInfo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_LONG,
            C_LONG,
            C_LONG,
            C_LONG,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetProductInfo"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetProductInfo(DWORD dwOSMajorVersion, DWORD dwOSMinorVersion, DWORD dwSpMajorVersion, DWORD dwSpMinorVersion, PDWORD pdwReturnedProductType)
     * }
     */
    public static FunctionDescriptor GetProductInfo$descriptor() {
        return GetProductInfo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetProductInfo(DWORD dwOSMajorVersion, DWORD dwOSMinorVersion, DWORD dwSpMajorVersion, DWORD dwSpMinorVersion, PDWORD pdwReturnedProductType)
     * }
     */
    public static MethodHandle GetProductInfo$handle() {
        return GetProductInfo.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL GetProductInfo(DWORD dwOSMajorVersion, DWORD dwOSMinorVersion, DWORD dwSpMajorVersion, DWORD dwSpMinorVersion, PDWORD pdwReturnedProductType)
     * }
     */
    public static int GetProductInfo(int dwOSMajorVersion, int dwOSMinorVersion, int dwSpMajorVersion, int dwSpMinorVersion, MemorySegment pdwReturnedProductType) {
        var mh$ = GetProductInfo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetProductInfo", dwOSMajorVersion, dwOSMinorVersion, dwSpMajorVersion, dwSpMinorVersion, pdwReturnedProductType);
            }
            return (int)mh$.invokeExact(dwOSMajorVersion, dwOSMinorVersion, dwSpMajorVersion, dwSpMinorVersion, pdwReturnedProductType);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetOsSafeBootMode {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetOsSafeBootMode"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetOsSafeBootMode(PDWORD Flags)
     * }
     */
    public static FunctionDescriptor GetOsSafeBootMode$descriptor() {
        return GetOsSafeBootMode.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetOsSafeBootMode(PDWORD Flags)
     * }
     */
    public static MethodHandle GetOsSafeBootMode$handle() {
        return GetOsSafeBootMode.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL GetOsSafeBootMode(PDWORD Flags)
     * }
     */
    public static int GetOsSafeBootMode(MemorySegment Flags) {
        var mh$ = GetOsSafeBootMode.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetOsSafeBootMode", Flags);
            }
            return (int)mh$.invokeExact(Flags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class EnumSystemFirmwareTables {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_LONG,
            C_POINTER,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("EnumSystemFirmwareTables"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * UINT EnumSystemFirmwareTables(DWORD FirmwareTableProviderSignature, PVOID pFirmwareTableEnumBuffer, DWORD BufferSize)
     * }
     */
    public static FunctionDescriptor EnumSystemFirmwareTables$descriptor() {
        return EnumSystemFirmwareTables.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * UINT EnumSystemFirmwareTables(DWORD FirmwareTableProviderSignature, PVOID pFirmwareTableEnumBuffer, DWORD BufferSize)
     * }
     */
    public static MethodHandle EnumSystemFirmwareTables$handle() {
        return EnumSystemFirmwareTables.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * UINT EnumSystemFirmwareTables(DWORD FirmwareTableProviderSignature, PVOID pFirmwareTableEnumBuffer, DWORD BufferSize)
     * }
     */
    public static int EnumSystemFirmwareTables(int FirmwareTableProviderSignature, MemorySegment pFirmwareTableEnumBuffer, int BufferSize) {
        var mh$ = EnumSystemFirmwareTables.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("EnumSystemFirmwareTables", FirmwareTableProviderSignature, pFirmwareTableEnumBuffer, BufferSize);
            }
            return (int)mh$.invokeExact(FirmwareTableProviderSignature, pFirmwareTableEnumBuffer, BufferSize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetSystemFirmwareTable {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_LONG,
            C_LONG,
            C_POINTER,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetSystemFirmwareTable"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * UINT GetSystemFirmwareTable(DWORD FirmwareTableProviderSignature, DWORD FirmwareTableID, PVOID pFirmwareTableBuffer, DWORD BufferSize)
     * }
     */
    public static FunctionDescriptor GetSystemFirmwareTable$descriptor() {
        return GetSystemFirmwareTable.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * UINT GetSystemFirmwareTable(DWORD FirmwareTableProviderSignature, DWORD FirmwareTableID, PVOID pFirmwareTableBuffer, DWORD BufferSize)
     * }
     */
    public static MethodHandle GetSystemFirmwareTable$handle() {
        return GetSystemFirmwareTable.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * UINT GetSystemFirmwareTable(DWORD FirmwareTableProviderSignature, DWORD FirmwareTableID, PVOID pFirmwareTableBuffer, DWORD BufferSize)
     * }
     */
    public static int GetSystemFirmwareTable(int FirmwareTableProviderSignature, int FirmwareTableID, MemorySegment pFirmwareTableBuffer, int BufferSize) {
        var mh$ = GetSystemFirmwareTable.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetSystemFirmwareTable", FirmwareTableProviderSignature, FirmwareTableID, pFirmwareTableBuffer, BufferSize);
            }
            return (int)mh$.invokeExact(FirmwareTableProviderSignature, FirmwareTableID, pFirmwareTableBuffer, BufferSize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DnsHostnameToComputerNameExW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("DnsHostnameToComputerNameExW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL DnsHostnameToComputerNameExW(LPCWSTR Hostname, LPWSTR ComputerName, LPDWORD nSize)
     * }
     */
    public static FunctionDescriptor DnsHostnameToComputerNameExW$descriptor() {
        return DnsHostnameToComputerNameExW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL DnsHostnameToComputerNameExW(LPCWSTR Hostname, LPWSTR ComputerName, LPDWORD nSize)
     * }
     */
    public static MethodHandle DnsHostnameToComputerNameExW$handle() {
        return DnsHostnameToComputerNameExW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL DnsHostnameToComputerNameExW(LPCWSTR Hostname, LPWSTR ComputerName, LPDWORD nSize)
     * }
     */
    public static int DnsHostnameToComputerNameExW(MemorySegment Hostname, MemorySegment ComputerName, MemorySegment nSize) {
        var mh$ = DnsHostnameToComputerNameExW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DnsHostnameToComputerNameExW", Hostname, ComputerName, nSize);
            }
            return (int)mh$.invokeExact(Hostname, ComputerName, nSize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetPhysicallyInstalledSystemMemory {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetPhysicallyInstalledSystemMemory"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetPhysicallyInstalledSystemMemory(PULONGLONG TotalMemoryInKilobytes)
     * }
     */
    public static FunctionDescriptor GetPhysicallyInstalledSystemMemory$descriptor() {
        return GetPhysicallyInstalledSystemMemory.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetPhysicallyInstalledSystemMemory(PULONGLONG TotalMemoryInKilobytes)
     * }
     */
    public static MethodHandle GetPhysicallyInstalledSystemMemory$handle() {
        return GetPhysicallyInstalledSystemMemory.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL GetPhysicallyInstalledSystemMemory(PULONGLONG TotalMemoryInKilobytes)
     * }
     */
    public static int GetPhysicallyInstalledSystemMemory(MemorySegment TotalMemoryInKilobytes) {
        var mh$ = GetPhysicallyInstalledSystemMemory.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetPhysicallyInstalledSystemMemory", TotalMemoryInKilobytes);
            }
            return (int)mh$.invokeExact(TotalMemoryInKilobytes);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetComputerNameEx2W {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_INT,
            C_LONG,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("SetComputerNameEx2W"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetComputerNameEx2W(COMPUTER_NAME_FORMAT NameType, DWORD Flags, LPCWSTR lpBuffer)
     * }
     */
    public static FunctionDescriptor SetComputerNameEx2W$descriptor() {
        return SetComputerNameEx2W.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetComputerNameEx2W(COMPUTER_NAME_FORMAT NameType, DWORD Flags, LPCWSTR lpBuffer)
     * }
     */
    public static MethodHandle SetComputerNameEx2W$handle() {
        return SetComputerNameEx2W.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL SetComputerNameEx2W(COMPUTER_NAME_FORMAT NameType, DWORD Flags, LPCWSTR lpBuffer)
     * }
     */
    public static int SetComputerNameEx2W(int NameType, int Flags, MemorySegment lpBuffer) {
        var mh$ = SetComputerNameEx2W.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetComputerNameEx2W", NameType, Flags, lpBuffer);
            }
            return (int)mh$.invokeExact(NameType, Flags, lpBuffer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetSystemTimeAdjustment {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_LONG,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("SetSystemTimeAdjustment"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetSystemTimeAdjustment(DWORD dwTimeAdjustment, BOOL bTimeAdjustmentDisabled)
     * }
     */
    public static FunctionDescriptor SetSystemTimeAdjustment$descriptor() {
        return SetSystemTimeAdjustment.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetSystemTimeAdjustment(DWORD dwTimeAdjustment, BOOL bTimeAdjustmentDisabled)
     * }
     */
    public static MethodHandle SetSystemTimeAdjustment$handle() {
        return SetSystemTimeAdjustment.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL SetSystemTimeAdjustment(DWORD dwTimeAdjustment, BOOL bTimeAdjustmentDisabled)
     * }
     */
    public static int SetSystemTimeAdjustment(int dwTimeAdjustment, int bTimeAdjustmentDisabled) {
        var mh$ = SetSystemTimeAdjustment.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetSystemTimeAdjustment", dwTimeAdjustment, bTimeAdjustmentDisabled);
            }
            return (int)mh$.invokeExact(dwTimeAdjustment, bTimeAdjustmentDisabled);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetSystemTimeAdjustmentPrecise {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_LONG_LONG,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("SetSystemTimeAdjustmentPrecise"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetSystemTimeAdjustmentPrecise(DWORD64 dwTimeAdjustment, BOOL bTimeAdjustmentDisabled)
     * }
     */
    public static FunctionDescriptor SetSystemTimeAdjustmentPrecise$descriptor() {
        return SetSystemTimeAdjustmentPrecise.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetSystemTimeAdjustmentPrecise(DWORD64 dwTimeAdjustment, BOOL bTimeAdjustmentDisabled)
     * }
     */
    public static MethodHandle SetSystemTimeAdjustmentPrecise$handle() {
        return SetSystemTimeAdjustmentPrecise.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL SetSystemTimeAdjustmentPrecise(DWORD64 dwTimeAdjustment, BOOL bTimeAdjustmentDisabled)
     * }
     */
    public static int SetSystemTimeAdjustmentPrecise(long dwTimeAdjustment, int bTimeAdjustmentDisabled) {
        var mh$ = SetSystemTimeAdjustmentPrecise.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetSystemTimeAdjustmentPrecise", dwTimeAdjustment, bTimeAdjustmentDisabled);
            }
            return (int)mh$.invokeExact(dwTimeAdjustment, bTimeAdjustmentDisabled);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class InstallELAMCertificateInfo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("InstallELAMCertificateInfo"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL InstallELAMCertificateInfo(HANDLE ELAMFile)
     * }
     */
    public static FunctionDescriptor InstallELAMCertificateInfo$descriptor() {
        return InstallELAMCertificateInfo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL InstallELAMCertificateInfo(HANDLE ELAMFile)
     * }
     */
    public static MethodHandle InstallELAMCertificateInfo$handle() {
        return InstallELAMCertificateInfo.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL InstallELAMCertificateInfo(HANDLE ELAMFile)
     * }
     */
    public static int InstallELAMCertificateInfo(MemorySegment ELAMFile) {
        var mh$ = InstallELAMCertificateInfo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("InstallELAMCertificateInfo", ELAMFile);
            }
            return (int)mh$.invokeExact(ELAMFile);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetProcessorSystemCycleTime {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_SHORT,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetProcessorSystemCycleTime"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetProcessorSystemCycleTime(USHORT Group, PSYSTEM_PROCESSOR_CYCLE_TIME_INFORMATION Buffer, PDWORD ReturnedLength)
     * }
     */
    public static FunctionDescriptor GetProcessorSystemCycleTime$descriptor() {
        return GetProcessorSystemCycleTime.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetProcessorSystemCycleTime(USHORT Group, PSYSTEM_PROCESSOR_CYCLE_TIME_INFORMATION Buffer, PDWORD ReturnedLength)
     * }
     */
    public static MethodHandle GetProcessorSystemCycleTime$handle() {
        return GetProcessorSystemCycleTime.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL GetProcessorSystemCycleTime(USHORT Group, PSYSTEM_PROCESSOR_CYCLE_TIME_INFORMATION Buffer, PDWORD ReturnedLength)
     * }
     */
    public static int GetProcessorSystemCycleTime(short Group, MemorySegment Buffer, MemorySegment ReturnedLength) {
        var mh$ = GetProcessorSystemCycleTime.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetProcessorSystemCycleTime", Group, Buffer, ReturnedLength);
            }
            return (int)mh$.invokeExact(Group, Buffer, ReturnedLength);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetOsManufacturingMode {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetOsManufacturingMode"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetOsManufacturingMode(PBOOL pbEnabled)
     * }
     */
    public static FunctionDescriptor GetOsManufacturingMode$descriptor() {
        return GetOsManufacturingMode.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetOsManufacturingMode(PBOOL pbEnabled)
     * }
     */
    public static MethodHandle GetOsManufacturingMode$handle() {
        return GetOsManufacturingMode.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL GetOsManufacturingMode(PBOOL pbEnabled)
     * }
     */
    public static int GetOsManufacturingMode(MemorySegment pbEnabled) {
        var mh$ = GetOsManufacturingMode.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetOsManufacturingMode", pbEnabled);
            }
            return (int)mh$.invokeExact(pbEnabled);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetIntegratedDisplaySize {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetIntegratedDisplaySize"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HRESULT GetIntegratedDisplaySize(double *sizeInInches)
     * }
     */
    public static FunctionDescriptor GetIntegratedDisplaySize$descriptor() {
        return GetIntegratedDisplaySize.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HRESULT GetIntegratedDisplaySize(double *sizeInInches)
     * }
     */
    public static MethodHandle GetIntegratedDisplaySize$handle() {
        return GetIntegratedDisplaySize.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * HRESULT GetIntegratedDisplaySize(double *sizeInInches)
     * }
     */
    public static int GetIntegratedDisplaySize(MemorySegment sizeInInches) {
        var mh$ = GetIntegratedDisplaySize.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetIntegratedDisplaySize", sizeInInches);
            }
            return (int)mh$.invokeExact(sizeInInches);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetComputerNameA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("SetComputerNameA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetComputerNameA(LPCSTR lpComputerName)
     * }
     */
    public static FunctionDescriptor SetComputerNameA$descriptor() {
        return SetComputerNameA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetComputerNameA(LPCSTR lpComputerName)
     * }
     */
    public static MethodHandle SetComputerNameA$handle() {
        return SetComputerNameA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL SetComputerNameA(LPCSTR lpComputerName)
     * }
     */
    public static int SetComputerNameA(MemorySegment lpComputerName) {
        var mh$ = SetComputerNameA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetComputerNameA", lpComputerName);
            }
            return (int)mh$.invokeExact(lpComputerName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetComputerNameW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("SetComputerNameW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetComputerNameW(LPCWSTR lpComputerName)
     * }
     */
    public static FunctionDescriptor SetComputerNameW$descriptor() {
        return SetComputerNameW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetComputerNameW(LPCWSTR lpComputerName)
     * }
     */
    public static MethodHandle SetComputerNameW$handle() {
        return SetComputerNameW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL SetComputerNameW(LPCWSTR lpComputerName)
     * }
     */
    public static int SetComputerNameW(MemorySegment lpComputerName) {
        var mh$ = SetComputerNameW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetComputerNameW", lpComputerName);
            }
            return (int)mh$.invokeExact(lpComputerName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetComputerNameExA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("SetComputerNameExA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetComputerNameExA(COMPUTER_NAME_FORMAT NameType, LPCSTR lpBuffer)
     * }
     */
    public static FunctionDescriptor SetComputerNameExA$descriptor() {
        return SetComputerNameExA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetComputerNameExA(COMPUTER_NAME_FORMAT NameType, LPCSTR lpBuffer)
     * }
     */
    public static MethodHandle SetComputerNameExA$handle() {
        return SetComputerNameExA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL SetComputerNameExA(COMPUTER_NAME_FORMAT NameType, LPCSTR lpBuffer)
     * }
     */
    public static int SetComputerNameExA(int NameType, MemorySegment lpBuffer) {
        var mh$ = SetComputerNameExA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetComputerNameExA", NameType, lpBuffer);
            }
            return (int)mh$.invokeExact(NameType, lpBuffer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class VirtualAlloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER,
            C_LONG_LONG,
            C_LONG,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("VirtualAlloc"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LPVOID VirtualAlloc(LPVOID lpAddress, SIZE_T dwSize, DWORD flAllocationType, DWORD flProtect)
     * }
     */
    public static FunctionDescriptor VirtualAlloc$descriptor() {
        return VirtualAlloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LPVOID VirtualAlloc(LPVOID lpAddress, SIZE_T dwSize, DWORD flAllocationType, DWORD flProtect)
     * }
     */
    public static MethodHandle VirtualAlloc$handle() {
        return VirtualAlloc.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * LPVOID VirtualAlloc(LPVOID lpAddress, SIZE_T dwSize, DWORD flAllocationType, DWORD flProtect)
     * }
     */
    public static MemorySegment VirtualAlloc(MemorySegment lpAddress, long dwSize, int flAllocationType, int flProtect) {
        var mh$ = VirtualAlloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("VirtualAlloc", lpAddress, dwSize, flAllocationType, flProtect);
            }
            return (MemorySegment)mh$.invokeExact(lpAddress, dwSize, flAllocationType, flProtect);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class VirtualProtect {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_LONG_LONG,
            C_LONG,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("VirtualProtect"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL VirtualProtect(LPVOID lpAddress, SIZE_T dwSize, DWORD flNewProtect, PDWORD lpflOldProtect)
     * }
     */
    public static FunctionDescriptor VirtualProtect$descriptor() {
        return VirtualProtect.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL VirtualProtect(LPVOID lpAddress, SIZE_T dwSize, DWORD flNewProtect, PDWORD lpflOldProtect)
     * }
     */
    public static MethodHandle VirtualProtect$handle() {
        return VirtualProtect.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL VirtualProtect(LPVOID lpAddress, SIZE_T dwSize, DWORD flNewProtect, PDWORD lpflOldProtect)
     * }
     */
    public static int VirtualProtect(MemorySegment lpAddress, long dwSize, int flNewProtect, MemorySegment lpflOldProtect) {
        var mh$ = VirtualProtect.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("VirtualProtect", lpAddress, dwSize, flNewProtect, lpflOldProtect);
            }
            return (int)mh$.invokeExact(lpAddress, dwSize, flNewProtect, lpflOldProtect);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class VirtualFree {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_LONG_LONG,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("VirtualFree"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL VirtualFree(LPVOID lpAddress, SIZE_T dwSize, DWORD dwFreeType)
     * }
     */
    public static FunctionDescriptor VirtualFree$descriptor() {
        return VirtualFree.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL VirtualFree(LPVOID lpAddress, SIZE_T dwSize, DWORD dwFreeType)
     * }
     */
    public static MethodHandle VirtualFree$handle() {
        return VirtualFree.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL VirtualFree(LPVOID lpAddress, SIZE_T dwSize, DWORD dwFreeType)
     * }
     */
    public static int VirtualFree(MemorySegment lpAddress, long dwSize, int dwFreeType) {
        var mh$ = VirtualFree.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("VirtualFree", lpAddress, dwSize, dwFreeType);
            }
            return (int)mh$.invokeExact(lpAddress, dwSize, dwFreeType);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class VirtualQuery {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG_LONG,
            C_POINTER,
            C_POINTER,
            C_LONG_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("VirtualQuery"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SIZE_T VirtualQuery(LPCVOID lpAddress, PMEMORY_BASIC_INFORMATION lpBuffer, SIZE_T dwLength)
     * }
     */
    public static FunctionDescriptor VirtualQuery$descriptor() {
        return VirtualQuery.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SIZE_T VirtualQuery(LPCVOID lpAddress, PMEMORY_BASIC_INFORMATION lpBuffer, SIZE_T dwLength)
     * }
     */
    public static MethodHandle VirtualQuery$handle() {
        return VirtualQuery.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * SIZE_T VirtualQuery(LPCVOID lpAddress, PMEMORY_BASIC_INFORMATION lpBuffer, SIZE_T dwLength)
     * }
     */
    public static long VirtualQuery(MemorySegment lpAddress, MemorySegment lpBuffer, long dwLength) {
        var mh$ = VirtualQuery.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("VirtualQuery", lpAddress, lpBuffer, dwLength);
            }
            return (long)mh$.invokeExact(lpAddress, lpBuffer, dwLength);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class VirtualAllocEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_LONG_LONG,
            C_LONG,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("VirtualAllocEx"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LPVOID VirtualAllocEx(HANDLE hProcess, LPVOID lpAddress, SIZE_T dwSize, DWORD flAllocationType, DWORD flProtect)
     * }
     */
    public static FunctionDescriptor VirtualAllocEx$descriptor() {
        return VirtualAllocEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LPVOID VirtualAllocEx(HANDLE hProcess, LPVOID lpAddress, SIZE_T dwSize, DWORD flAllocationType, DWORD flProtect)
     * }
     */
    public static MethodHandle VirtualAllocEx$handle() {
        return VirtualAllocEx.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * LPVOID VirtualAllocEx(HANDLE hProcess, LPVOID lpAddress, SIZE_T dwSize, DWORD flAllocationType, DWORD flProtect)
     * }
     */
    public static MemorySegment VirtualAllocEx(MemorySegment hProcess, MemorySegment lpAddress, long dwSize, int flAllocationType, int flProtect) {
        var mh$ = VirtualAllocEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("VirtualAllocEx", hProcess, lpAddress, dwSize, flAllocationType, flProtect);
            }
            return (MemorySegment)mh$.invokeExact(hProcess, lpAddress, dwSize, flAllocationType, flProtect);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class VirtualProtectEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_LONG_LONG,
            C_LONG,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("VirtualProtectEx"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL VirtualProtectEx(HANDLE hProcess, LPVOID lpAddress, SIZE_T dwSize, DWORD flNewProtect, PDWORD lpflOldProtect)
     * }
     */
    public static FunctionDescriptor VirtualProtectEx$descriptor() {
        return VirtualProtectEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL VirtualProtectEx(HANDLE hProcess, LPVOID lpAddress, SIZE_T dwSize, DWORD flNewProtect, PDWORD lpflOldProtect)
     * }
     */
    public static MethodHandle VirtualProtectEx$handle() {
        return VirtualProtectEx.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL VirtualProtectEx(HANDLE hProcess, LPVOID lpAddress, SIZE_T dwSize, DWORD flNewProtect, PDWORD lpflOldProtect)
     * }
     */
    public static int VirtualProtectEx(MemorySegment hProcess, MemorySegment lpAddress, long dwSize, int flNewProtect, MemorySegment lpflOldProtect) {
        var mh$ = VirtualProtectEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("VirtualProtectEx", hProcess, lpAddress, dwSize, flNewProtect, lpflOldProtect);
            }
            return (int)mh$.invokeExact(hProcess, lpAddress, dwSize, flNewProtect, lpflOldProtect);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class VirtualQueryEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG_LONG,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_LONG_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("VirtualQueryEx"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SIZE_T VirtualQueryEx(HANDLE hProcess, LPCVOID lpAddress, PMEMORY_BASIC_INFORMATION lpBuffer, SIZE_T dwLength)
     * }
     */
    public static FunctionDescriptor VirtualQueryEx$descriptor() {
        return VirtualQueryEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SIZE_T VirtualQueryEx(HANDLE hProcess, LPCVOID lpAddress, PMEMORY_BASIC_INFORMATION lpBuffer, SIZE_T dwLength)
     * }
     */
    public static MethodHandle VirtualQueryEx$handle() {
        return VirtualQueryEx.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * SIZE_T VirtualQueryEx(HANDLE hProcess, LPCVOID lpAddress, PMEMORY_BASIC_INFORMATION lpBuffer, SIZE_T dwLength)
     * }
     */
    public static long VirtualQueryEx(MemorySegment hProcess, MemorySegment lpAddress, MemorySegment lpBuffer, long dwLength) {
        var mh$ = VirtualQueryEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("VirtualQueryEx", hProcess, lpAddress, lpBuffer, dwLength);
            }
            return (long)mh$.invokeExact(hProcess, lpAddress, lpBuffer, dwLength);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ReadProcessMemory {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_LONG_LONG,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("ReadProcessMemory"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL ReadProcessMemory(HANDLE hProcess, LPCVOID lpBaseAddress, LPVOID lpBuffer, SIZE_T nSize, SIZE_T *lpNumberOfBytesRead)
     * }
     */
    public static FunctionDescriptor ReadProcessMemory$descriptor() {
        return ReadProcessMemory.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL ReadProcessMemory(HANDLE hProcess, LPCVOID lpBaseAddress, LPVOID lpBuffer, SIZE_T nSize, SIZE_T *lpNumberOfBytesRead)
     * }
     */
    public static MethodHandle ReadProcessMemory$handle() {
        return ReadProcessMemory.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL ReadProcessMemory(HANDLE hProcess, LPCVOID lpBaseAddress, LPVOID lpBuffer, SIZE_T nSize, SIZE_T *lpNumberOfBytesRead)
     * }
     */
    public static int ReadProcessMemory(MemorySegment hProcess, MemorySegment lpBaseAddress, MemorySegment lpBuffer, long nSize, MemorySegment lpNumberOfBytesRead) {
        var mh$ = ReadProcessMemory.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ReadProcessMemory", hProcess, lpBaseAddress, lpBuffer, nSize, lpNumberOfBytesRead);
            }
            return (int)mh$.invokeExact(hProcess, lpBaseAddress, lpBuffer, nSize, lpNumberOfBytesRead);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class WriteProcessMemory {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_LONG_LONG,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("WriteProcessMemory"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL WriteProcessMemory(HANDLE hProcess, LPVOID lpBaseAddress, LPCVOID lpBuffer, SIZE_T nSize, SIZE_T *lpNumberOfBytesWritten)
     * }
     */
    public static FunctionDescriptor WriteProcessMemory$descriptor() {
        return WriteProcessMemory.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL WriteProcessMemory(HANDLE hProcess, LPVOID lpBaseAddress, LPCVOID lpBuffer, SIZE_T nSize, SIZE_T *lpNumberOfBytesWritten)
     * }
     */
    public static MethodHandle WriteProcessMemory$handle() {
        return WriteProcessMemory.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL WriteProcessMemory(HANDLE hProcess, LPVOID lpBaseAddress, LPCVOID lpBuffer, SIZE_T nSize, SIZE_T *lpNumberOfBytesWritten)
     * }
     */
    public static int WriteProcessMemory(MemorySegment hProcess, MemorySegment lpBaseAddress, MemorySegment lpBuffer, long nSize, MemorySegment lpNumberOfBytesWritten) {
        var mh$ = WriteProcessMemory.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WriteProcessMemory", hProcess, lpBaseAddress, lpBuffer, nSize, lpNumberOfBytesWritten);
            }
            return (int)mh$.invokeExact(hProcess, lpBaseAddress, lpBuffer, nSize, lpNumberOfBytesWritten);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateFileMappingW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_LONG,
            C_LONG,
            C_LONG,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CreateFileMappingW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HANDLE CreateFileMappingW(HANDLE hFile, LPSECURITY_ATTRIBUTES lpFileMappingAttributes, DWORD flProtect, DWORD dwMaximumSizeHigh, DWORD dwMaximumSizeLow, LPCWSTR lpName)
     * }
     */
    public static FunctionDescriptor CreateFileMappingW$descriptor() {
        return CreateFileMappingW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HANDLE CreateFileMappingW(HANDLE hFile, LPSECURITY_ATTRIBUTES lpFileMappingAttributes, DWORD flProtect, DWORD dwMaximumSizeHigh, DWORD dwMaximumSizeLow, LPCWSTR lpName)
     * }
     */
    public static MethodHandle CreateFileMappingW$handle() {
        return CreateFileMappingW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * HANDLE CreateFileMappingW(HANDLE hFile, LPSECURITY_ATTRIBUTES lpFileMappingAttributes, DWORD flProtect, DWORD dwMaximumSizeHigh, DWORD dwMaximumSizeLow, LPCWSTR lpName)
     * }
     */
    public static MemorySegment CreateFileMappingW(MemorySegment hFile, MemorySegment lpFileMappingAttributes, int flProtect, int dwMaximumSizeHigh, int dwMaximumSizeLow, MemorySegment lpName) {
        var mh$ = CreateFileMappingW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateFileMappingW", hFile, lpFileMappingAttributes, flProtect, dwMaximumSizeHigh, dwMaximumSizeLow, lpName);
            }
            return (MemorySegment)mh$.invokeExact(hFile, lpFileMappingAttributes, flProtect, dwMaximumSizeHigh, dwMaximumSizeLow, lpName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class OpenFileMappingW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_LONG,
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("OpenFileMappingW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HANDLE OpenFileMappingW(DWORD dwDesiredAccess, BOOL bInheritHandle, LPCWSTR lpName)
     * }
     */
    public static FunctionDescriptor OpenFileMappingW$descriptor() {
        return OpenFileMappingW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HANDLE OpenFileMappingW(DWORD dwDesiredAccess, BOOL bInheritHandle, LPCWSTR lpName)
     * }
     */
    public static MethodHandle OpenFileMappingW$handle() {
        return OpenFileMappingW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * HANDLE OpenFileMappingW(DWORD dwDesiredAccess, BOOL bInheritHandle, LPCWSTR lpName)
     * }
     */
    public static MemorySegment OpenFileMappingW(int dwDesiredAccess, int bInheritHandle, MemorySegment lpName) {
        var mh$ = OpenFileMappingW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("OpenFileMappingW", dwDesiredAccess, bInheritHandle, lpName);
            }
            return (MemorySegment)mh$.invokeExact(dwDesiredAccess, bInheritHandle, lpName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MapViewOfFile {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER,
            C_LONG,
            C_LONG,
            C_LONG,
            C_LONG_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("MapViewOfFile"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LPVOID MapViewOfFile(HANDLE hFileMappingObject, DWORD dwDesiredAccess, DWORD dwFileOffsetHigh, DWORD dwFileOffsetLow, SIZE_T dwNumberOfBytesToMap)
     * }
     */
    public static FunctionDescriptor MapViewOfFile$descriptor() {
        return MapViewOfFile.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LPVOID MapViewOfFile(HANDLE hFileMappingObject, DWORD dwDesiredAccess, DWORD dwFileOffsetHigh, DWORD dwFileOffsetLow, SIZE_T dwNumberOfBytesToMap)
     * }
     */
    public static MethodHandle MapViewOfFile$handle() {
        return MapViewOfFile.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * LPVOID MapViewOfFile(HANDLE hFileMappingObject, DWORD dwDesiredAccess, DWORD dwFileOffsetHigh, DWORD dwFileOffsetLow, SIZE_T dwNumberOfBytesToMap)
     * }
     */
    public static MemorySegment MapViewOfFile(MemorySegment hFileMappingObject, int dwDesiredAccess, int dwFileOffsetHigh, int dwFileOffsetLow, long dwNumberOfBytesToMap) {
        var mh$ = MapViewOfFile.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MapViewOfFile", hFileMappingObject, dwDesiredAccess, dwFileOffsetHigh, dwFileOffsetLow, dwNumberOfBytesToMap);
            }
            return (MemorySegment)mh$.invokeExact(hFileMappingObject, dwDesiredAccess, dwFileOffsetHigh, dwFileOffsetLow, dwNumberOfBytesToMap);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MapViewOfFileEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER,
            C_LONG,
            C_LONG,
            C_LONG,
            C_LONG_LONG,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("MapViewOfFileEx"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LPVOID MapViewOfFileEx(HANDLE hFileMappingObject, DWORD dwDesiredAccess, DWORD dwFileOffsetHigh, DWORD dwFileOffsetLow, SIZE_T dwNumberOfBytesToMap, LPVOID lpBaseAddress)
     * }
     */
    public static FunctionDescriptor MapViewOfFileEx$descriptor() {
        return MapViewOfFileEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LPVOID MapViewOfFileEx(HANDLE hFileMappingObject, DWORD dwDesiredAccess, DWORD dwFileOffsetHigh, DWORD dwFileOffsetLow, SIZE_T dwNumberOfBytesToMap, LPVOID lpBaseAddress)
     * }
     */
    public static MethodHandle MapViewOfFileEx$handle() {
        return MapViewOfFileEx.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * LPVOID MapViewOfFileEx(HANDLE hFileMappingObject, DWORD dwDesiredAccess, DWORD dwFileOffsetHigh, DWORD dwFileOffsetLow, SIZE_T dwNumberOfBytesToMap, LPVOID lpBaseAddress)
     * }
     */
    public static MemorySegment MapViewOfFileEx(MemorySegment hFileMappingObject, int dwDesiredAccess, int dwFileOffsetHigh, int dwFileOffsetLow, long dwNumberOfBytesToMap, MemorySegment lpBaseAddress) {
        var mh$ = MapViewOfFileEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MapViewOfFileEx", hFileMappingObject, dwDesiredAccess, dwFileOffsetHigh, dwFileOffsetLow, dwNumberOfBytesToMap, lpBaseAddress);
            }
            return (MemorySegment)mh$.invokeExact(hFileMappingObject, dwDesiredAccess, dwFileOffsetHigh, dwFileOffsetLow, dwNumberOfBytesToMap, lpBaseAddress);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class VirtualFreeEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_LONG_LONG,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("VirtualFreeEx"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL VirtualFreeEx(HANDLE hProcess, LPVOID lpAddress, SIZE_T dwSize, DWORD dwFreeType)
     * }
     */
    public static FunctionDescriptor VirtualFreeEx$descriptor() {
        return VirtualFreeEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL VirtualFreeEx(HANDLE hProcess, LPVOID lpAddress, SIZE_T dwSize, DWORD dwFreeType)
     * }
     */
    public static MethodHandle VirtualFreeEx$handle() {
        return VirtualFreeEx.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL VirtualFreeEx(HANDLE hProcess, LPVOID lpAddress, SIZE_T dwSize, DWORD dwFreeType)
     * }
     */
    public static int VirtualFreeEx(MemorySegment hProcess, MemorySegment lpAddress, long dwSize, int dwFreeType) {
        var mh$ = VirtualFreeEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("VirtualFreeEx", hProcess, lpAddress, dwSize, dwFreeType);
            }
            return (int)mh$.invokeExact(hProcess, lpAddress, dwSize, dwFreeType);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FlushViewOfFile {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_LONG_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("FlushViewOfFile"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL FlushViewOfFile(LPCVOID lpBaseAddress, SIZE_T dwNumberOfBytesToFlush)
     * }
     */
    public static FunctionDescriptor FlushViewOfFile$descriptor() {
        return FlushViewOfFile.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL FlushViewOfFile(LPCVOID lpBaseAddress, SIZE_T dwNumberOfBytesToFlush)
     * }
     */
    public static MethodHandle FlushViewOfFile$handle() {
        return FlushViewOfFile.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL FlushViewOfFile(LPCVOID lpBaseAddress, SIZE_T dwNumberOfBytesToFlush)
     * }
     */
    public static int FlushViewOfFile(MemorySegment lpBaseAddress, long dwNumberOfBytesToFlush) {
        var mh$ = FlushViewOfFile.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FlushViewOfFile", lpBaseAddress, dwNumberOfBytesToFlush);
            }
            return (int)mh$.invokeExact(lpBaseAddress, dwNumberOfBytesToFlush);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class UnmapViewOfFile {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("UnmapViewOfFile"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL UnmapViewOfFile(LPCVOID lpBaseAddress)
     * }
     */
    public static FunctionDescriptor UnmapViewOfFile$descriptor() {
        return UnmapViewOfFile.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL UnmapViewOfFile(LPCVOID lpBaseAddress)
     * }
     */
    public static MethodHandle UnmapViewOfFile$handle() {
        return UnmapViewOfFile.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL UnmapViewOfFile(LPCVOID lpBaseAddress)
     * }
     */
    public static int UnmapViewOfFile(MemorySegment lpBaseAddress) {
        var mh$ = UnmapViewOfFile.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("UnmapViewOfFile", lpBaseAddress);
            }
            return (int)mh$.invokeExact(lpBaseAddress);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetLargePageMinimum {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG_LONG    );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetLargePageMinimum"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SIZE_T GetLargePageMinimum()
     * }
     */
    public static FunctionDescriptor GetLargePageMinimum$descriptor() {
        return GetLargePageMinimum.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SIZE_T GetLargePageMinimum()
     * }
     */
    public static MethodHandle GetLargePageMinimum$handle() {
        return GetLargePageMinimum.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * SIZE_T GetLargePageMinimum()
     * }
     */
    public static long GetLargePageMinimum() {
        var mh$ = GetLargePageMinimum.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetLargePageMinimum");
            }
            return (long)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetProcessWorkingSetSize {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetProcessWorkingSetSize"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetProcessWorkingSetSize(HANDLE hProcess, PSIZE_T lpMinimumWorkingSetSize, PSIZE_T lpMaximumWorkingSetSize)
     * }
     */
    public static FunctionDescriptor GetProcessWorkingSetSize$descriptor() {
        return GetProcessWorkingSetSize.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetProcessWorkingSetSize(HANDLE hProcess, PSIZE_T lpMinimumWorkingSetSize, PSIZE_T lpMaximumWorkingSetSize)
     * }
     */
    public static MethodHandle GetProcessWorkingSetSize$handle() {
        return GetProcessWorkingSetSize.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL GetProcessWorkingSetSize(HANDLE hProcess, PSIZE_T lpMinimumWorkingSetSize, PSIZE_T lpMaximumWorkingSetSize)
     * }
     */
    public static int GetProcessWorkingSetSize(MemorySegment hProcess, MemorySegment lpMinimumWorkingSetSize, MemorySegment lpMaximumWorkingSetSize) {
        var mh$ = GetProcessWorkingSetSize.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetProcessWorkingSetSize", hProcess, lpMinimumWorkingSetSize, lpMaximumWorkingSetSize);
            }
            return (int)mh$.invokeExact(hProcess, lpMinimumWorkingSetSize, lpMaximumWorkingSetSize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetProcessWorkingSetSizeEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetProcessWorkingSetSizeEx"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetProcessWorkingSetSizeEx(HANDLE hProcess, PSIZE_T lpMinimumWorkingSetSize, PSIZE_T lpMaximumWorkingSetSize, PDWORD Flags)
     * }
     */
    public static FunctionDescriptor GetProcessWorkingSetSizeEx$descriptor() {
        return GetProcessWorkingSetSizeEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetProcessWorkingSetSizeEx(HANDLE hProcess, PSIZE_T lpMinimumWorkingSetSize, PSIZE_T lpMaximumWorkingSetSize, PDWORD Flags)
     * }
     */
    public static MethodHandle GetProcessWorkingSetSizeEx$handle() {
        return GetProcessWorkingSetSizeEx.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL GetProcessWorkingSetSizeEx(HANDLE hProcess, PSIZE_T lpMinimumWorkingSetSize, PSIZE_T lpMaximumWorkingSetSize, PDWORD Flags)
     * }
     */
    public static int GetProcessWorkingSetSizeEx(MemorySegment hProcess, MemorySegment lpMinimumWorkingSetSize, MemorySegment lpMaximumWorkingSetSize, MemorySegment Flags) {
        var mh$ = GetProcessWorkingSetSizeEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetProcessWorkingSetSizeEx", hProcess, lpMinimumWorkingSetSize, lpMaximumWorkingSetSize, Flags);
            }
            return (int)mh$.invokeExact(hProcess, lpMinimumWorkingSetSize, lpMaximumWorkingSetSize, Flags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetProcessWorkingSetSize {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_LONG_LONG,
            C_LONG_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("SetProcessWorkingSetSize"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetProcessWorkingSetSize(HANDLE hProcess, SIZE_T dwMinimumWorkingSetSize, SIZE_T dwMaximumWorkingSetSize)
     * }
     */
    public static FunctionDescriptor SetProcessWorkingSetSize$descriptor() {
        return SetProcessWorkingSetSize.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetProcessWorkingSetSize(HANDLE hProcess, SIZE_T dwMinimumWorkingSetSize, SIZE_T dwMaximumWorkingSetSize)
     * }
     */
    public static MethodHandle SetProcessWorkingSetSize$handle() {
        return SetProcessWorkingSetSize.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL SetProcessWorkingSetSize(HANDLE hProcess, SIZE_T dwMinimumWorkingSetSize, SIZE_T dwMaximumWorkingSetSize)
     * }
     */
    public static int SetProcessWorkingSetSize(MemorySegment hProcess, long dwMinimumWorkingSetSize, long dwMaximumWorkingSetSize) {
        var mh$ = SetProcessWorkingSetSize.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetProcessWorkingSetSize", hProcess, dwMinimumWorkingSetSize, dwMaximumWorkingSetSize);
            }
            return (int)mh$.invokeExact(hProcess, dwMinimumWorkingSetSize, dwMaximumWorkingSetSize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetProcessWorkingSetSizeEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_LONG_LONG,
            C_LONG_LONG,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("SetProcessWorkingSetSizeEx"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetProcessWorkingSetSizeEx(HANDLE hProcess, SIZE_T dwMinimumWorkingSetSize, SIZE_T dwMaximumWorkingSetSize, DWORD Flags)
     * }
     */
    public static FunctionDescriptor SetProcessWorkingSetSizeEx$descriptor() {
        return SetProcessWorkingSetSizeEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetProcessWorkingSetSizeEx(HANDLE hProcess, SIZE_T dwMinimumWorkingSetSize, SIZE_T dwMaximumWorkingSetSize, DWORD Flags)
     * }
     */
    public static MethodHandle SetProcessWorkingSetSizeEx$handle() {
        return SetProcessWorkingSetSizeEx.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL SetProcessWorkingSetSizeEx(HANDLE hProcess, SIZE_T dwMinimumWorkingSetSize, SIZE_T dwMaximumWorkingSetSize, DWORD Flags)
     * }
     */
    public static int SetProcessWorkingSetSizeEx(MemorySegment hProcess, long dwMinimumWorkingSetSize, long dwMaximumWorkingSetSize, int Flags) {
        var mh$ = SetProcessWorkingSetSizeEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetProcessWorkingSetSizeEx", hProcess, dwMinimumWorkingSetSize, dwMaximumWorkingSetSize, Flags);
            }
            return (int)mh$.invokeExact(hProcess, dwMinimumWorkingSetSize, dwMaximumWorkingSetSize, Flags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class VirtualLock {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_LONG_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("VirtualLock"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL VirtualLock(LPVOID lpAddress, SIZE_T dwSize)
     * }
     */
    public static FunctionDescriptor VirtualLock$descriptor() {
        return VirtualLock.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL VirtualLock(LPVOID lpAddress, SIZE_T dwSize)
     * }
     */
    public static MethodHandle VirtualLock$handle() {
        return VirtualLock.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL VirtualLock(LPVOID lpAddress, SIZE_T dwSize)
     * }
     */
    public static int VirtualLock(MemorySegment lpAddress, long dwSize) {
        var mh$ = VirtualLock.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("VirtualLock", lpAddress, dwSize);
            }
            return (int)mh$.invokeExact(lpAddress, dwSize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class VirtualUnlock {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_LONG_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("VirtualUnlock"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL VirtualUnlock(LPVOID lpAddress, SIZE_T dwSize)
     * }
     */
    public static FunctionDescriptor VirtualUnlock$descriptor() {
        return VirtualUnlock.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL VirtualUnlock(LPVOID lpAddress, SIZE_T dwSize)
     * }
     */
    public static MethodHandle VirtualUnlock$handle() {
        return VirtualUnlock.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL VirtualUnlock(LPVOID lpAddress, SIZE_T dwSize)
     * }
     */
    public static int VirtualUnlock(MemorySegment lpAddress, long dwSize) {
        var mh$ = VirtualUnlock.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("VirtualUnlock", lpAddress, dwSize);
            }
            return (int)mh$.invokeExact(lpAddress, dwSize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetWriteWatch {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_LONG,
            C_POINTER,
            C_LONG_LONG,
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetWriteWatch"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * UINT GetWriteWatch(DWORD dwFlags, PVOID lpBaseAddress, SIZE_T dwRegionSize, PVOID *lpAddresses, ULONG_PTR *lpdwCount, LPDWORD lpdwGranularity)
     * }
     */
    public static FunctionDescriptor GetWriteWatch$descriptor() {
        return GetWriteWatch.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * UINT GetWriteWatch(DWORD dwFlags, PVOID lpBaseAddress, SIZE_T dwRegionSize, PVOID *lpAddresses, ULONG_PTR *lpdwCount, LPDWORD lpdwGranularity)
     * }
     */
    public static MethodHandle GetWriteWatch$handle() {
        return GetWriteWatch.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * UINT GetWriteWatch(DWORD dwFlags, PVOID lpBaseAddress, SIZE_T dwRegionSize, PVOID *lpAddresses, ULONG_PTR *lpdwCount, LPDWORD lpdwGranularity)
     * }
     */
    public static int GetWriteWatch(int dwFlags, MemorySegment lpBaseAddress, long dwRegionSize, MemorySegment lpAddresses, MemorySegment lpdwCount, MemorySegment lpdwGranularity) {
        var mh$ = GetWriteWatch.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetWriteWatch", dwFlags, lpBaseAddress, dwRegionSize, lpAddresses, lpdwCount, lpdwGranularity);
            }
            return (int)mh$.invokeExact(dwFlags, lpBaseAddress, dwRegionSize, lpAddresses, lpdwCount, lpdwGranularity);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ResetWriteWatch {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_LONG_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("ResetWriteWatch"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * UINT ResetWriteWatch(LPVOID lpBaseAddress, SIZE_T dwRegionSize)
     * }
     */
    public static FunctionDescriptor ResetWriteWatch$descriptor() {
        return ResetWriteWatch.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * UINT ResetWriteWatch(LPVOID lpBaseAddress, SIZE_T dwRegionSize)
     * }
     */
    public static MethodHandle ResetWriteWatch$handle() {
        return ResetWriteWatch.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * UINT ResetWriteWatch(LPVOID lpBaseAddress, SIZE_T dwRegionSize)
     * }
     */
    public static int ResetWriteWatch(MemorySegment lpBaseAddress, long dwRegionSize) {
        var mh$ = ResetWriteWatch.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ResetWriteWatch", lpBaseAddress, dwRegionSize);
            }
            return (int)mh$.invokeExact(lpBaseAddress, dwRegionSize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int LowMemoryResourceNotification = (int)0L;
    /**
     * {@snippet lang=c :
     * enum _MEMORY_RESOURCE_NOTIFICATION_TYPE.LowMemoryResourceNotification = 0
     * }
     */
    public static int LowMemoryResourceNotification() {
        return LowMemoryResourceNotification;
    }
    private static final int HighMemoryResourceNotification = (int)1L;
    /**
     * {@snippet lang=c :
     * enum _MEMORY_RESOURCE_NOTIFICATION_TYPE.HighMemoryResourceNotification = 1
     * }
     */
    public static int HighMemoryResourceNotification() {
        return HighMemoryResourceNotification;
    }

    private static class CreateMemoryResourceNotification {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CreateMemoryResourceNotification"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HANDLE CreateMemoryResourceNotification(MEMORY_RESOURCE_NOTIFICATION_TYPE NotificationType)
     * }
     */
    public static FunctionDescriptor CreateMemoryResourceNotification$descriptor() {
        return CreateMemoryResourceNotification.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HANDLE CreateMemoryResourceNotification(MEMORY_RESOURCE_NOTIFICATION_TYPE NotificationType)
     * }
     */
    public static MethodHandle CreateMemoryResourceNotification$handle() {
        return CreateMemoryResourceNotification.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * HANDLE CreateMemoryResourceNotification(MEMORY_RESOURCE_NOTIFICATION_TYPE NotificationType)
     * }
     */
    public static MemorySegment CreateMemoryResourceNotification(int NotificationType) {
        var mh$ = CreateMemoryResourceNotification.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateMemoryResourceNotification", NotificationType);
            }
            return (MemorySegment)mh$.invokeExact(NotificationType);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class QueryMemoryResourceNotification {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("QueryMemoryResourceNotification"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL QueryMemoryResourceNotification(HANDLE ResourceNotificationHandle, PBOOL ResourceState)
     * }
     */
    public static FunctionDescriptor QueryMemoryResourceNotification$descriptor() {
        return QueryMemoryResourceNotification.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL QueryMemoryResourceNotification(HANDLE ResourceNotificationHandle, PBOOL ResourceState)
     * }
     */
    public static MethodHandle QueryMemoryResourceNotification$handle() {
        return QueryMemoryResourceNotification.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL QueryMemoryResourceNotification(HANDLE ResourceNotificationHandle, PBOOL ResourceState)
     * }
     */
    public static int QueryMemoryResourceNotification(MemorySegment ResourceNotificationHandle, MemorySegment ResourceState) {
        var mh$ = QueryMemoryResourceNotification.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("QueryMemoryResourceNotification", ResourceNotificationHandle, ResourceState);
            }
            return (int)mh$.invokeExact(ResourceNotificationHandle, ResourceState);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetSystemFileCacheSize {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetSystemFileCacheSize"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetSystemFileCacheSize(PSIZE_T lpMinimumFileCacheSize, PSIZE_T lpMaximumFileCacheSize, PDWORD lpFlags)
     * }
     */
    public static FunctionDescriptor GetSystemFileCacheSize$descriptor() {
        return GetSystemFileCacheSize.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetSystemFileCacheSize(PSIZE_T lpMinimumFileCacheSize, PSIZE_T lpMaximumFileCacheSize, PDWORD lpFlags)
     * }
     */
    public static MethodHandle GetSystemFileCacheSize$handle() {
        return GetSystemFileCacheSize.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL GetSystemFileCacheSize(PSIZE_T lpMinimumFileCacheSize, PSIZE_T lpMaximumFileCacheSize, PDWORD lpFlags)
     * }
     */
    public static int GetSystemFileCacheSize(MemorySegment lpMinimumFileCacheSize, MemorySegment lpMaximumFileCacheSize, MemorySegment lpFlags) {
        var mh$ = GetSystemFileCacheSize.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetSystemFileCacheSize", lpMinimumFileCacheSize, lpMaximumFileCacheSize, lpFlags);
            }
            return (int)mh$.invokeExact(lpMinimumFileCacheSize, lpMaximumFileCacheSize, lpFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetSystemFileCacheSize {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_LONG_LONG,
            C_LONG_LONG,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("SetSystemFileCacheSize"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetSystemFileCacheSize(SIZE_T MinimumFileCacheSize, SIZE_T MaximumFileCacheSize, DWORD Flags)
     * }
     */
    public static FunctionDescriptor SetSystemFileCacheSize$descriptor() {
        return SetSystemFileCacheSize.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetSystemFileCacheSize(SIZE_T MinimumFileCacheSize, SIZE_T MaximumFileCacheSize, DWORD Flags)
     * }
     */
    public static MethodHandle SetSystemFileCacheSize$handle() {
        return SetSystemFileCacheSize.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL SetSystemFileCacheSize(SIZE_T MinimumFileCacheSize, SIZE_T MaximumFileCacheSize, DWORD Flags)
     * }
     */
    public static int SetSystemFileCacheSize(long MinimumFileCacheSize, long MaximumFileCacheSize, int Flags) {
        var mh$ = SetSystemFileCacheSize.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetSystemFileCacheSize", MinimumFileCacheSize, MaximumFileCacheSize, Flags);
            }
            return (int)mh$.invokeExact(MinimumFileCacheSize, MaximumFileCacheSize, Flags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateFileMappingNumaW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_LONG,
            C_LONG,
            C_LONG,
            C_POINTER,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CreateFileMappingNumaW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HANDLE CreateFileMappingNumaW(HANDLE hFile, LPSECURITY_ATTRIBUTES lpFileMappingAttributes, DWORD flProtect, DWORD dwMaximumSizeHigh, DWORD dwMaximumSizeLow, LPCWSTR lpName, DWORD nndPreferred)
     * }
     */
    public static FunctionDescriptor CreateFileMappingNumaW$descriptor() {
        return CreateFileMappingNumaW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HANDLE CreateFileMappingNumaW(HANDLE hFile, LPSECURITY_ATTRIBUTES lpFileMappingAttributes, DWORD flProtect, DWORD dwMaximumSizeHigh, DWORD dwMaximumSizeLow, LPCWSTR lpName, DWORD nndPreferred)
     * }
     */
    public static MethodHandle CreateFileMappingNumaW$handle() {
        return CreateFileMappingNumaW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * HANDLE CreateFileMappingNumaW(HANDLE hFile, LPSECURITY_ATTRIBUTES lpFileMappingAttributes, DWORD flProtect, DWORD dwMaximumSizeHigh, DWORD dwMaximumSizeLow, LPCWSTR lpName, DWORD nndPreferred)
     * }
     */
    public static MemorySegment CreateFileMappingNumaW(MemorySegment hFile, MemorySegment lpFileMappingAttributes, int flProtect, int dwMaximumSizeHigh, int dwMaximumSizeLow, MemorySegment lpName, int nndPreferred) {
        var mh$ = CreateFileMappingNumaW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateFileMappingNumaW", hFile, lpFileMappingAttributes, flProtect, dwMaximumSizeHigh, dwMaximumSizeLow, lpName, nndPreferred);
            }
            return (MemorySegment)mh$.invokeExact(hFile, lpFileMappingAttributes, flProtect, dwMaximumSizeHigh, dwMaximumSizeLow, lpName, nndPreferred);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct _WIN32_MEMORY_RANGE_ENTRY {
     *     PVOID VirtualAddress;
     *     SIZE_T NumberOfBytes;
     * } *PWIN32_MEMORY_RANGE_ENTRY
     * }
     */
    public static final AddressLayout PWIN32_MEMORY_RANGE_ENTRY = C_POINTER;

    private static class PrefetchVirtualMemory {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_LONG_LONG,
            C_POINTER,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("PrefetchVirtualMemory"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL PrefetchVirtualMemory(HANDLE hProcess, ULONG_PTR NumberOfEntries, PWIN32_MEMORY_RANGE_ENTRY VirtualAddresses, ULONG Flags)
     * }
     */
    public static FunctionDescriptor PrefetchVirtualMemory$descriptor() {
        return PrefetchVirtualMemory.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL PrefetchVirtualMemory(HANDLE hProcess, ULONG_PTR NumberOfEntries, PWIN32_MEMORY_RANGE_ENTRY VirtualAddresses, ULONG Flags)
     * }
     */
    public static MethodHandle PrefetchVirtualMemory$handle() {
        return PrefetchVirtualMemory.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL PrefetchVirtualMemory(HANDLE hProcess, ULONG_PTR NumberOfEntries, PWIN32_MEMORY_RANGE_ENTRY VirtualAddresses, ULONG Flags)
     * }
     */
    public static int PrefetchVirtualMemory(MemorySegment hProcess, long NumberOfEntries, MemorySegment VirtualAddresses, int Flags) {
        var mh$ = PrefetchVirtualMemory.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PrefetchVirtualMemory", hProcess, NumberOfEntries, VirtualAddresses, Flags);
            }
            return (int)mh$.invokeExact(hProcess, NumberOfEntries, VirtualAddresses, Flags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateFileMappingFromApp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_LONG,
            C_LONG_LONG,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CreateFileMappingFromApp"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HANDLE CreateFileMappingFromApp(HANDLE hFile, PSECURITY_ATTRIBUTES SecurityAttributes, ULONG PageProtection, ULONG64 MaximumSize, PCWSTR Name)
     * }
     */
    public static FunctionDescriptor CreateFileMappingFromApp$descriptor() {
        return CreateFileMappingFromApp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HANDLE CreateFileMappingFromApp(HANDLE hFile, PSECURITY_ATTRIBUTES SecurityAttributes, ULONG PageProtection, ULONG64 MaximumSize, PCWSTR Name)
     * }
     */
    public static MethodHandle CreateFileMappingFromApp$handle() {
        return CreateFileMappingFromApp.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * HANDLE CreateFileMappingFromApp(HANDLE hFile, PSECURITY_ATTRIBUTES SecurityAttributes, ULONG PageProtection, ULONG64 MaximumSize, PCWSTR Name)
     * }
     */
    public static MemorySegment CreateFileMappingFromApp(MemorySegment hFile, MemorySegment SecurityAttributes, int PageProtection, long MaximumSize, MemorySegment Name) {
        var mh$ = CreateFileMappingFromApp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateFileMappingFromApp", hFile, SecurityAttributes, PageProtection, MaximumSize, Name);
            }
            return (MemorySegment)mh$.invokeExact(hFile, SecurityAttributes, PageProtection, MaximumSize, Name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MapViewOfFileFromApp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER,
            C_LONG,
            C_LONG_LONG,
            C_LONG_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("MapViewOfFileFromApp"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PVOID MapViewOfFileFromApp(HANDLE hFileMappingObject, ULONG DesiredAccess, ULONG64 FileOffset, SIZE_T NumberOfBytesToMap)
     * }
     */
    public static FunctionDescriptor MapViewOfFileFromApp$descriptor() {
        return MapViewOfFileFromApp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PVOID MapViewOfFileFromApp(HANDLE hFileMappingObject, ULONG DesiredAccess, ULONG64 FileOffset, SIZE_T NumberOfBytesToMap)
     * }
     */
    public static MethodHandle MapViewOfFileFromApp$handle() {
        return MapViewOfFileFromApp.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * PVOID MapViewOfFileFromApp(HANDLE hFileMappingObject, ULONG DesiredAccess, ULONG64 FileOffset, SIZE_T NumberOfBytesToMap)
     * }
     */
    public static MemorySegment MapViewOfFileFromApp(MemorySegment hFileMappingObject, int DesiredAccess, long FileOffset, long NumberOfBytesToMap) {
        var mh$ = MapViewOfFileFromApp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MapViewOfFileFromApp", hFileMappingObject, DesiredAccess, FileOffset, NumberOfBytesToMap);
            }
            return (MemorySegment)mh$.invokeExact(hFileMappingObject, DesiredAccess, FileOffset, NumberOfBytesToMap);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class UnmapViewOfFileEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("UnmapViewOfFileEx"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL UnmapViewOfFileEx(PVOID BaseAddress, ULONG UnmapFlags)
     * }
     */
    public static FunctionDescriptor UnmapViewOfFileEx$descriptor() {
        return UnmapViewOfFileEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL UnmapViewOfFileEx(PVOID BaseAddress, ULONG UnmapFlags)
     * }
     */
    public static MethodHandle UnmapViewOfFileEx$handle() {
        return UnmapViewOfFileEx.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL UnmapViewOfFileEx(PVOID BaseAddress, ULONG UnmapFlags)
     * }
     */
    public static int UnmapViewOfFileEx(MemorySegment BaseAddress, int UnmapFlags) {
        var mh$ = UnmapViewOfFileEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("UnmapViewOfFileEx", BaseAddress, UnmapFlags);
            }
            return (int)mh$.invokeExact(BaseAddress, UnmapFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class AllocateUserPhysicalPages {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("AllocateUserPhysicalPages"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL AllocateUserPhysicalPages(HANDLE hProcess, PULONG_PTR NumberOfPages, PULONG_PTR PageArray)
     * }
     */
    public static FunctionDescriptor AllocateUserPhysicalPages$descriptor() {
        return AllocateUserPhysicalPages.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL AllocateUserPhysicalPages(HANDLE hProcess, PULONG_PTR NumberOfPages, PULONG_PTR PageArray)
     * }
     */
    public static MethodHandle AllocateUserPhysicalPages$handle() {
        return AllocateUserPhysicalPages.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL AllocateUserPhysicalPages(HANDLE hProcess, PULONG_PTR NumberOfPages, PULONG_PTR PageArray)
     * }
     */
    public static int AllocateUserPhysicalPages(MemorySegment hProcess, MemorySegment NumberOfPages, MemorySegment PageArray) {
        var mh$ = AllocateUserPhysicalPages.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("AllocateUserPhysicalPages", hProcess, NumberOfPages, PageArray);
            }
            return (int)mh$.invokeExact(hProcess, NumberOfPages, PageArray);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FreeUserPhysicalPages {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("FreeUserPhysicalPages"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL FreeUserPhysicalPages(HANDLE hProcess, PULONG_PTR NumberOfPages, PULONG_PTR PageArray)
     * }
     */
    public static FunctionDescriptor FreeUserPhysicalPages$descriptor() {
        return FreeUserPhysicalPages.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL FreeUserPhysicalPages(HANDLE hProcess, PULONG_PTR NumberOfPages, PULONG_PTR PageArray)
     * }
     */
    public static MethodHandle FreeUserPhysicalPages$handle() {
        return FreeUserPhysicalPages.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL FreeUserPhysicalPages(HANDLE hProcess, PULONG_PTR NumberOfPages, PULONG_PTR PageArray)
     * }
     */
    public static int FreeUserPhysicalPages(MemorySegment hProcess, MemorySegment NumberOfPages, MemorySegment PageArray) {
        var mh$ = FreeUserPhysicalPages.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FreeUserPhysicalPages", hProcess, NumberOfPages, PageArray);
            }
            return (int)mh$.invokeExact(hProcess, NumberOfPages, PageArray);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MapUserPhysicalPages {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_LONG_LONG,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("MapUserPhysicalPages"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL MapUserPhysicalPages(PVOID VirtualAddress, ULONG_PTR NumberOfPages, PULONG_PTR PageArray)
     * }
     */
    public static FunctionDescriptor MapUserPhysicalPages$descriptor() {
        return MapUserPhysicalPages.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL MapUserPhysicalPages(PVOID VirtualAddress, ULONG_PTR NumberOfPages, PULONG_PTR PageArray)
     * }
     */
    public static MethodHandle MapUserPhysicalPages$handle() {
        return MapUserPhysicalPages.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL MapUserPhysicalPages(PVOID VirtualAddress, ULONG_PTR NumberOfPages, PULONG_PTR PageArray)
     * }
     */
    public static int MapUserPhysicalPages(MemorySegment VirtualAddress, long NumberOfPages, MemorySegment PageArray) {
        var mh$ = MapUserPhysicalPages.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MapUserPhysicalPages", VirtualAddress, NumberOfPages, PageArray);
            }
            return (int)mh$.invokeExact(VirtualAddress, NumberOfPages, PageArray);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class AllocateUserPhysicalPagesNuma {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("AllocateUserPhysicalPagesNuma"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL AllocateUserPhysicalPagesNuma(HANDLE hProcess, PULONG_PTR NumberOfPages, PULONG_PTR PageArray, DWORD nndPreferred)
     * }
     */
    public static FunctionDescriptor AllocateUserPhysicalPagesNuma$descriptor() {
        return AllocateUserPhysicalPagesNuma.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL AllocateUserPhysicalPagesNuma(HANDLE hProcess, PULONG_PTR NumberOfPages, PULONG_PTR PageArray, DWORD nndPreferred)
     * }
     */
    public static MethodHandle AllocateUserPhysicalPagesNuma$handle() {
        return AllocateUserPhysicalPagesNuma.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL AllocateUserPhysicalPagesNuma(HANDLE hProcess, PULONG_PTR NumberOfPages, PULONG_PTR PageArray, DWORD nndPreferred)
     * }
     */
    public static int AllocateUserPhysicalPagesNuma(MemorySegment hProcess, MemorySegment NumberOfPages, MemorySegment PageArray, int nndPreferred) {
        var mh$ = AllocateUserPhysicalPagesNuma.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("AllocateUserPhysicalPagesNuma", hProcess, NumberOfPages, PageArray, nndPreferred);
            }
            return (int)mh$.invokeExact(hProcess, NumberOfPages, PageArray, nndPreferred);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class VirtualAllocExNuma {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_LONG_LONG,
            C_LONG,
            C_LONG,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("VirtualAllocExNuma"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LPVOID VirtualAllocExNuma(HANDLE hProcess, LPVOID lpAddress, SIZE_T dwSize, DWORD flAllocationType, DWORD flProtect, DWORD nndPreferred)
     * }
     */
    public static FunctionDescriptor VirtualAllocExNuma$descriptor() {
        return VirtualAllocExNuma.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LPVOID VirtualAllocExNuma(HANDLE hProcess, LPVOID lpAddress, SIZE_T dwSize, DWORD flAllocationType, DWORD flProtect, DWORD nndPreferred)
     * }
     */
    public static MethodHandle VirtualAllocExNuma$handle() {
        return VirtualAllocExNuma.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * LPVOID VirtualAllocExNuma(HANDLE hProcess, LPVOID lpAddress, SIZE_T dwSize, DWORD flAllocationType, DWORD flProtect, DWORD nndPreferred)
     * }
     */
    public static MemorySegment VirtualAllocExNuma(MemorySegment hProcess, MemorySegment lpAddress, long dwSize, int flAllocationType, int flProtect, int nndPreferred) {
        var mh$ = VirtualAllocExNuma.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("VirtualAllocExNuma", hProcess, lpAddress, dwSize, flAllocationType, flProtect, nndPreferred);
            }
            return (MemorySegment)mh$.invokeExact(hProcess, lpAddress, dwSize, flAllocationType, flProtect, nndPreferred);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetMemoryErrorHandlingCapabilities {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetMemoryErrorHandlingCapabilities"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL GetMemoryErrorHandlingCapabilities(PULONG Capabilities)
     * }
     */
    public static FunctionDescriptor GetMemoryErrorHandlingCapabilities$descriptor() {
        return GetMemoryErrorHandlingCapabilities.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL GetMemoryErrorHandlingCapabilities(PULONG Capabilities)
     * }
     */
    public static MethodHandle GetMemoryErrorHandlingCapabilities$handle() {
        return GetMemoryErrorHandlingCapabilities.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL GetMemoryErrorHandlingCapabilities(PULONG Capabilities)
     * }
     */
    public static int GetMemoryErrorHandlingCapabilities(MemorySegment Capabilities) {
        var mh$ = GetMemoryErrorHandlingCapabilities.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetMemoryErrorHandlingCapabilities", Capabilities);
            }
            return (int)mh$.invokeExact(Capabilities);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RegisterBadMemoryNotification {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("RegisterBadMemoryNotification"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PVOID RegisterBadMemoryNotification(PBAD_MEMORY_CALLBACK_ROUTINE Callback)
     * }
     */
    public static FunctionDescriptor RegisterBadMemoryNotification$descriptor() {
        return RegisterBadMemoryNotification.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PVOID RegisterBadMemoryNotification(PBAD_MEMORY_CALLBACK_ROUTINE Callback)
     * }
     */
    public static MethodHandle RegisterBadMemoryNotification$handle() {
        return RegisterBadMemoryNotification.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * PVOID RegisterBadMemoryNotification(PBAD_MEMORY_CALLBACK_ROUTINE Callback)
     * }
     */
    public static MemorySegment RegisterBadMemoryNotification(MemorySegment Callback) {
        var mh$ = RegisterBadMemoryNotification.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RegisterBadMemoryNotification", Callback);
            }
            return (MemorySegment)mh$.invokeExact(Callback);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class UnregisterBadMemoryNotification {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("UnregisterBadMemoryNotification"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL UnregisterBadMemoryNotification(PVOID RegistrationHandle)
     * }
     */
    public static FunctionDescriptor UnregisterBadMemoryNotification$descriptor() {
        return UnregisterBadMemoryNotification.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL UnregisterBadMemoryNotification(PVOID RegistrationHandle)
     * }
     */
    public static MethodHandle UnregisterBadMemoryNotification$handle() {
        return UnregisterBadMemoryNotification.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL UnregisterBadMemoryNotification(PVOID RegistrationHandle)
     * }
     */
    public static int UnregisterBadMemoryNotification(MemorySegment RegistrationHandle) {
        var mh$ = UnregisterBadMemoryNotification.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("UnregisterBadMemoryNotification", RegistrationHandle);
            }
            return (int)mh$.invokeExact(RegistrationHandle);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int VmOfferPriorityVeryLow = (int)1L;
    /**
     * {@snippet lang=c :
     * enum OFFER_PRIORITY.VmOfferPriorityVeryLow = 1
     * }
     */
    public static int VmOfferPriorityVeryLow() {
        return VmOfferPriorityVeryLow;
    }
    private static final int VmOfferPriorityLow = (int)2L;
    /**
     * {@snippet lang=c :
     * enum OFFER_PRIORITY.VmOfferPriorityLow = 2
     * }
     */
    public static int VmOfferPriorityLow() {
        return VmOfferPriorityLow;
    }
    private static final int VmOfferPriorityBelowNormal = (int)3L;
    /**
     * {@snippet lang=c :
     * enum OFFER_PRIORITY.VmOfferPriorityBelowNormal = 3
     * }
     */
    public static int VmOfferPriorityBelowNormal() {
        return VmOfferPriorityBelowNormal;
    }
    private static final int VmOfferPriorityNormal = (int)4L;
    /**
     * {@snippet lang=c :
     * enum OFFER_PRIORITY.VmOfferPriorityNormal = 4
     * }
     */
    public static int VmOfferPriorityNormal() {
        return VmOfferPriorityNormal;
    }

    private static class OfferVirtualMemory {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_POINTER,
            C_LONG_LONG,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("OfferVirtualMemory"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD OfferVirtualMemory(PVOID VirtualAddress, SIZE_T Size, OFFER_PRIORITY Priority)
     * }
     */
    public static FunctionDescriptor OfferVirtualMemory$descriptor() {
        return OfferVirtualMemory.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD OfferVirtualMemory(PVOID VirtualAddress, SIZE_T Size, OFFER_PRIORITY Priority)
     * }
     */
    public static MethodHandle OfferVirtualMemory$handle() {
        return OfferVirtualMemory.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * DWORD OfferVirtualMemory(PVOID VirtualAddress, SIZE_T Size, OFFER_PRIORITY Priority)
     * }
     */
    public static int OfferVirtualMemory(MemorySegment VirtualAddress, long Size, int Priority) {
        var mh$ = OfferVirtualMemory.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("OfferVirtualMemory", VirtualAddress, Size, Priority);
            }
            return (int)mh$.invokeExact(VirtualAddress, Size, Priority);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ReclaimVirtualMemory {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_POINTER,
            C_LONG_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("ReclaimVirtualMemory"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD ReclaimVirtualMemory(const void *VirtualAddress, SIZE_T Size)
     * }
     */
    public static FunctionDescriptor ReclaimVirtualMemory$descriptor() {
        return ReclaimVirtualMemory.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD ReclaimVirtualMemory(const void *VirtualAddress, SIZE_T Size)
     * }
     */
    public static MethodHandle ReclaimVirtualMemory$handle() {
        return ReclaimVirtualMemory.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * DWORD ReclaimVirtualMemory(const void *VirtualAddress, SIZE_T Size)
     * }
     */
    public static int ReclaimVirtualMemory(MemorySegment VirtualAddress, long Size) {
        var mh$ = ReclaimVirtualMemory.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ReclaimVirtualMemory", VirtualAddress, Size);
            }
            return (int)mh$.invokeExact(VirtualAddress, Size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DiscardVirtualMemory {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_POINTER,
            C_LONG_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("DiscardVirtualMemory"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD DiscardVirtualMemory(PVOID VirtualAddress, SIZE_T Size)
     * }
     */
    public static FunctionDescriptor DiscardVirtualMemory$descriptor() {
        return DiscardVirtualMemory.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD DiscardVirtualMemory(PVOID VirtualAddress, SIZE_T Size)
     * }
     */
    public static MethodHandle DiscardVirtualMemory$handle() {
        return DiscardVirtualMemory.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * DWORD DiscardVirtualMemory(PVOID VirtualAddress, SIZE_T Size)
     * }
     */
    public static int DiscardVirtualMemory(MemorySegment VirtualAddress, long Size) {
        var mh$ = DiscardVirtualMemory.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DiscardVirtualMemory", VirtualAddress, Size);
            }
            return (int)mh$.invokeExact(VirtualAddress, Size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetProcessValidCallTargets {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_LONG_LONG,
            C_LONG,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("SetProcessValidCallTargets"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetProcessValidCallTargets(HANDLE hProcess, PVOID VirtualAddress, SIZE_T RegionSize, ULONG NumberOfOffsets, PCFG_CALL_TARGET_INFO OffsetInformation)
     * }
     */
    public static FunctionDescriptor SetProcessValidCallTargets$descriptor() {
        return SetProcessValidCallTargets.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetProcessValidCallTargets(HANDLE hProcess, PVOID VirtualAddress, SIZE_T RegionSize, ULONG NumberOfOffsets, PCFG_CALL_TARGET_INFO OffsetInformation)
     * }
     */
    public static MethodHandle SetProcessValidCallTargets$handle() {
        return SetProcessValidCallTargets.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL SetProcessValidCallTargets(HANDLE hProcess, PVOID VirtualAddress, SIZE_T RegionSize, ULONG NumberOfOffsets, PCFG_CALL_TARGET_INFO OffsetInformation)
     * }
     */
    public static int SetProcessValidCallTargets(MemorySegment hProcess, MemorySegment VirtualAddress, long RegionSize, int NumberOfOffsets, MemorySegment OffsetInformation) {
        var mh$ = SetProcessValidCallTargets.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetProcessValidCallTargets", hProcess, VirtualAddress, RegionSize, NumberOfOffsets, OffsetInformation);
            }
            return (int)mh$.invokeExact(hProcess, VirtualAddress, RegionSize, NumberOfOffsets, OffsetInformation);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetProcessValidCallTargetsForMappedView {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_LONG_LONG,
            C_LONG,
            C_POINTER,
            C_POINTER,
            C_LONG_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("SetProcessValidCallTargetsForMappedView"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetProcessValidCallTargetsForMappedView(HANDLE Process, PVOID VirtualAddress, SIZE_T RegionSize, ULONG NumberOfOffsets, PCFG_CALL_TARGET_INFO OffsetInformation, HANDLE Section, ULONG64 ExpectedFileOffset)
     * }
     */
    public static FunctionDescriptor SetProcessValidCallTargetsForMappedView$descriptor() {
        return SetProcessValidCallTargetsForMappedView.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetProcessValidCallTargetsForMappedView(HANDLE Process, PVOID VirtualAddress, SIZE_T RegionSize, ULONG NumberOfOffsets, PCFG_CALL_TARGET_INFO OffsetInformation, HANDLE Section, ULONG64 ExpectedFileOffset)
     * }
     */
    public static MethodHandle SetProcessValidCallTargetsForMappedView$handle() {
        return SetProcessValidCallTargetsForMappedView.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL SetProcessValidCallTargetsForMappedView(HANDLE Process, PVOID VirtualAddress, SIZE_T RegionSize, ULONG NumberOfOffsets, PCFG_CALL_TARGET_INFO OffsetInformation, HANDLE Section, ULONG64 ExpectedFileOffset)
     * }
     */
    public static int SetProcessValidCallTargetsForMappedView(MemorySegment Process, MemorySegment VirtualAddress, long RegionSize, int NumberOfOffsets, MemorySegment OffsetInformation, MemorySegment Section, long ExpectedFileOffset) {
        var mh$ = SetProcessValidCallTargetsForMappedView.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetProcessValidCallTargetsForMappedView", Process, VirtualAddress, RegionSize, NumberOfOffsets, OffsetInformation, Section, ExpectedFileOffset);
            }
            return (int)mh$.invokeExact(Process, VirtualAddress, RegionSize, NumberOfOffsets, OffsetInformation, Section, ExpectedFileOffset);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class VirtualAllocFromApp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER,
            C_LONG_LONG,
            C_LONG,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("VirtualAllocFromApp"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PVOID VirtualAllocFromApp(PVOID BaseAddress, SIZE_T Size, ULONG AllocationType, ULONG Protection)
     * }
     */
    public static FunctionDescriptor VirtualAllocFromApp$descriptor() {
        return VirtualAllocFromApp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PVOID VirtualAllocFromApp(PVOID BaseAddress, SIZE_T Size, ULONG AllocationType, ULONG Protection)
     * }
     */
    public static MethodHandle VirtualAllocFromApp$handle() {
        return VirtualAllocFromApp.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * PVOID VirtualAllocFromApp(PVOID BaseAddress, SIZE_T Size, ULONG AllocationType, ULONG Protection)
     * }
     */
    public static MemorySegment VirtualAllocFromApp(MemorySegment BaseAddress, long Size, int AllocationType, int Protection) {
        var mh$ = VirtualAllocFromApp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("VirtualAllocFromApp", BaseAddress, Size, AllocationType, Protection);
            }
            return (MemorySegment)mh$.invokeExact(BaseAddress, Size, AllocationType, Protection);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class VirtualProtectFromApp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_LONG_LONG,
            C_LONG,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("VirtualProtectFromApp"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL VirtualProtectFromApp(PVOID Address, SIZE_T Size, ULONG NewProtection, PULONG OldProtection)
     * }
     */
    public static FunctionDescriptor VirtualProtectFromApp$descriptor() {
        return VirtualProtectFromApp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL VirtualProtectFromApp(PVOID Address, SIZE_T Size, ULONG NewProtection, PULONG OldProtection)
     * }
     */
    public static MethodHandle VirtualProtectFromApp$handle() {
        return VirtualProtectFromApp.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL VirtualProtectFromApp(PVOID Address, SIZE_T Size, ULONG NewProtection, PULONG OldProtection)
     * }
     */
    public static int VirtualProtectFromApp(MemorySegment Address, long Size, int NewProtection, MemorySegment OldProtection) {
        var mh$ = VirtualProtectFromApp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("VirtualProtectFromApp", Address, Size, NewProtection, OldProtection);
            }
            return (int)mh$.invokeExact(Address, Size, NewProtection, OldProtection);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class OpenFileMappingFromApp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_LONG,
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("OpenFileMappingFromApp"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HANDLE OpenFileMappingFromApp(ULONG DesiredAccess, BOOL InheritHandle, PCWSTR Name)
     * }
     */
    public static FunctionDescriptor OpenFileMappingFromApp$descriptor() {
        return OpenFileMappingFromApp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HANDLE OpenFileMappingFromApp(ULONG DesiredAccess, BOOL InheritHandle, PCWSTR Name)
     * }
     */
    public static MethodHandle OpenFileMappingFromApp$handle() {
        return OpenFileMappingFromApp.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * HANDLE OpenFileMappingFromApp(ULONG DesiredAccess, BOOL InheritHandle, PCWSTR Name)
     * }
     */
    public static MemorySegment OpenFileMappingFromApp(int DesiredAccess, int InheritHandle, MemorySegment Name) {
        var mh$ = OpenFileMappingFromApp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("OpenFileMappingFromApp", DesiredAccess, InheritHandle, Name);
            }
            return (MemorySegment)mh$.invokeExact(DesiredAccess, InheritHandle, Name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int MemoryRegionInfo = (int)0L;
    /**
     * {@snippet lang=c :
     * enum WIN32_MEMORY_INFORMATION_CLASS.MemoryRegionInfo = 0
     * }
     */
    public static int MemoryRegionInfo() {
        return MemoryRegionInfo;
    }

    private static class QueryVirtualMemoryInformation {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_INT,
            C_POINTER,
            C_LONG_LONG,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("QueryVirtualMemoryInformation"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL QueryVirtualMemoryInformation(HANDLE Process, const void *VirtualAddress, WIN32_MEMORY_INFORMATION_CLASS MemoryInformationClass, PVOID MemoryInformation, SIZE_T MemoryInformationSize, PSIZE_T ReturnSize)
     * }
     */
    public static FunctionDescriptor QueryVirtualMemoryInformation$descriptor() {
        return QueryVirtualMemoryInformation.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL QueryVirtualMemoryInformation(HANDLE Process, const void *VirtualAddress, WIN32_MEMORY_INFORMATION_CLASS MemoryInformationClass, PVOID MemoryInformation, SIZE_T MemoryInformationSize, PSIZE_T ReturnSize)
     * }
     */
    public static MethodHandle QueryVirtualMemoryInformation$handle() {
        return QueryVirtualMemoryInformation.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL QueryVirtualMemoryInformation(HANDLE Process, const void *VirtualAddress, WIN32_MEMORY_INFORMATION_CLASS MemoryInformationClass, PVOID MemoryInformation, SIZE_T MemoryInformationSize, PSIZE_T ReturnSize)
     * }
     */
    public static int QueryVirtualMemoryInformation(MemorySegment Process, MemorySegment VirtualAddress, int MemoryInformationClass, MemorySegment MemoryInformation, long MemoryInformationSize, MemorySegment ReturnSize) {
        var mh$ = QueryVirtualMemoryInformation.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("QueryVirtualMemoryInformation", Process, VirtualAddress, MemoryInformationClass, MemoryInformation, MemoryInformationSize, ReturnSize);
            }
            return (int)mh$.invokeExact(Process, VirtualAddress, MemoryInformationClass, MemoryInformation, MemoryInformationSize, ReturnSize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MapViewOfFileNuma2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_LONG_LONG,
            C_POINTER,
            C_LONG_LONG,
            C_LONG,
            C_LONG,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("MapViewOfFileNuma2"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PVOID MapViewOfFileNuma2(HANDLE FileMappingHandle, HANDLE ProcessHandle, ULONG64 Offset, PVOID BaseAddress, SIZE_T ViewSize, ULONG AllocationType, ULONG PageProtection, ULONG PreferredNode)
     * }
     */
    public static FunctionDescriptor MapViewOfFileNuma2$descriptor() {
        return MapViewOfFileNuma2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PVOID MapViewOfFileNuma2(HANDLE FileMappingHandle, HANDLE ProcessHandle, ULONG64 Offset, PVOID BaseAddress, SIZE_T ViewSize, ULONG AllocationType, ULONG PageProtection, ULONG PreferredNode)
     * }
     */
    public static MethodHandle MapViewOfFileNuma2$handle() {
        return MapViewOfFileNuma2.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * PVOID MapViewOfFileNuma2(HANDLE FileMappingHandle, HANDLE ProcessHandle, ULONG64 Offset, PVOID BaseAddress, SIZE_T ViewSize, ULONG AllocationType, ULONG PageProtection, ULONG PreferredNode)
     * }
     */
    public static MemorySegment MapViewOfFileNuma2(MemorySegment FileMappingHandle, MemorySegment ProcessHandle, long Offset, MemorySegment BaseAddress, long ViewSize, int AllocationType, int PageProtection, int PreferredNode) {
        var mh$ = MapViewOfFileNuma2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MapViewOfFileNuma2", FileMappingHandle, ProcessHandle, Offset, BaseAddress, ViewSize, AllocationType, PageProtection, PreferredNode);
            }
            return (MemorySegment)mh$.invokeExact(FileMappingHandle, ProcessHandle, Offset, BaseAddress, ViewSize, AllocationType, PageProtection, PreferredNode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class UnmapViewOfFile2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("UnmapViewOfFile2"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL UnmapViewOfFile2(HANDLE Process, PVOID BaseAddress, ULONG UnmapFlags)
     * }
     */
    public static FunctionDescriptor UnmapViewOfFile2$descriptor() {
        return UnmapViewOfFile2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL UnmapViewOfFile2(HANDLE Process, PVOID BaseAddress, ULONG UnmapFlags)
     * }
     */
    public static MethodHandle UnmapViewOfFile2$handle() {
        return UnmapViewOfFile2.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL UnmapViewOfFile2(HANDLE Process, PVOID BaseAddress, ULONG UnmapFlags)
     * }
     */
    public static int UnmapViewOfFile2(MemorySegment Process, MemorySegment BaseAddress, int UnmapFlags) {
        var mh$ = UnmapViewOfFile2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("UnmapViewOfFile2", Process, BaseAddress, UnmapFlags);
            }
            return (int)mh$.invokeExact(Process, BaseAddress, UnmapFlags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class VirtualUnlockEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_LONG_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("VirtualUnlockEx"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL VirtualUnlockEx(HANDLE Process, LPVOID Address, SIZE_T Size)
     * }
     */
    public static FunctionDescriptor VirtualUnlockEx$descriptor() {
        return VirtualUnlockEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL VirtualUnlockEx(HANDLE Process, LPVOID Address, SIZE_T Size)
     * }
     */
    public static MethodHandle VirtualUnlockEx$handle() {
        return VirtualUnlockEx.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL VirtualUnlockEx(HANDLE Process, LPVOID Address, SIZE_T Size)
     * }
     */
    public static int VirtualUnlockEx(MemorySegment Process, MemorySegment Address, long Size) {
        var mh$ = VirtualUnlockEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("VirtualUnlockEx", Process, Address, Size);
            }
            return (int)mh$.invokeExact(Process, Address, Size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class VirtualAlloc2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_LONG_LONG,
            C_LONG,
            C_LONG,
            C_POINTER,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("VirtualAlloc2"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PVOID VirtualAlloc2(HANDLE Process, PVOID BaseAddress, SIZE_T Size, ULONG AllocationType, ULONG PageProtection, MEM_EXTENDED_PARAMETER *ExtendedParameters, ULONG ParameterCount)
     * }
     */
    public static FunctionDescriptor VirtualAlloc2$descriptor() {
        return VirtualAlloc2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PVOID VirtualAlloc2(HANDLE Process, PVOID BaseAddress, SIZE_T Size, ULONG AllocationType, ULONG PageProtection, MEM_EXTENDED_PARAMETER *ExtendedParameters, ULONG ParameterCount)
     * }
     */
    public static MethodHandle VirtualAlloc2$handle() {
        return VirtualAlloc2.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * PVOID VirtualAlloc2(HANDLE Process, PVOID BaseAddress, SIZE_T Size, ULONG AllocationType, ULONG PageProtection, MEM_EXTENDED_PARAMETER *ExtendedParameters, ULONG ParameterCount)
     * }
     */
    public static MemorySegment VirtualAlloc2(MemorySegment Process, MemorySegment BaseAddress, long Size, int AllocationType, int PageProtection, MemorySegment ExtendedParameters, int ParameterCount) {
        var mh$ = VirtualAlloc2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("VirtualAlloc2", Process, BaseAddress, Size, AllocationType, PageProtection, ExtendedParameters, ParameterCount);
            }
            return (MemorySegment)mh$.invokeExact(Process, BaseAddress, Size, AllocationType, PageProtection, ExtendedParameters, ParameterCount);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MapViewOfFile3 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_LONG_LONG,
            C_LONG_LONG,
            C_LONG,
            C_LONG,
            C_POINTER,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("MapViewOfFile3"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PVOID MapViewOfFile3(HANDLE FileMapping, HANDLE Process, PVOID BaseAddress, ULONG64 Offset, SIZE_T ViewSize, ULONG AllocationType, ULONG PageProtection, MEM_EXTENDED_PARAMETER *ExtendedParameters, ULONG ParameterCount)
     * }
     */
    public static FunctionDescriptor MapViewOfFile3$descriptor() {
        return MapViewOfFile3.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PVOID MapViewOfFile3(HANDLE FileMapping, HANDLE Process, PVOID BaseAddress, ULONG64 Offset, SIZE_T ViewSize, ULONG AllocationType, ULONG PageProtection, MEM_EXTENDED_PARAMETER *ExtendedParameters, ULONG ParameterCount)
     * }
     */
    public static MethodHandle MapViewOfFile3$handle() {
        return MapViewOfFile3.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * PVOID MapViewOfFile3(HANDLE FileMapping, HANDLE Process, PVOID BaseAddress, ULONG64 Offset, SIZE_T ViewSize, ULONG AllocationType, ULONG PageProtection, MEM_EXTENDED_PARAMETER *ExtendedParameters, ULONG ParameterCount)
     * }
     */
    public static MemorySegment MapViewOfFile3(MemorySegment FileMapping, MemorySegment Process, MemorySegment BaseAddress, long Offset, long ViewSize, int AllocationType, int PageProtection, MemorySegment ExtendedParameters, int ParameterCount) {
        var mh$ = MapViewOfFile3.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MapViewOfFile3", FileMapping, Process, BaseAddress, Offset, ViewSize, AllocationType, PageProtection, ExtendedParameters, ParameterCount);
            }
            return (MemorySegment)mh$.invokeExact(FileMapping, Process, BaseAddress, Offset, ViewSize, AllocationType, PageProtection, ExtendedParameters, ParameterCount);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class VirtualAlloc2FromApp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_LONG_LONG,
            C_LONG,
            C_LONG,
            C_POINTER,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("VirtualAlloc2FromApp"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PVOID VirtualAlloc2FromApp(HANDLE Process, PVOID BaseAddress, SIZE_T Size, ULONG AllocationType, ULONG PageProtection, MEM_EXTENDED_PARAMETER *ExtendedParameters, ULONG ParameterCount)
     * }
     */
    public static FunctionDescriptor VirtualAlloc2FromApp$descriptor() {
        return VirtualAlloc2FromApp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PVOID VirtualAlloc2FromApp(HANDLE Process, PVOID BaseAddress, SIZE_T Size, ULONG AllocationType, ULONG PageProtection, MEM_EXTENDED_PARAMETER *ExtendedParameters, ULONG ParameterCount)
     * }
     */
    public static MethodHandle VirtualAlloc2FromApp$handle() {
        return VirtualAlloc2FromApp.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * PVOID VirtualAlloc2FromApp(HANDLE Process, PVOID BaseAddress, SIZE_T Size, ULONG AllocationType, ULONG PageProtection, MEM_EXTENDED_PARAMETER *ExtendedParameters, ULONG ParameterCount)
     * }
     */
    public static MemorySegment VirtualAlloc2FromApp(MemorySegment Process, MemorySegment BaseAddress, long Size, int AllocationType, int PageProtection, MemorySegment ExtendedParameters, int ParameterCount) {
        var mh$ = VirtualAlloc2FromApp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("VirtualAlloc2FromApp", Process, BaseAddress, Size, AllocationType, PageProtection, ExtendedParameters, ParameterCount);
            }
            return (MemorySegment)mh$.invokeExact(Process, BaseAddress, Size, AllocationType, PageProtection, ExtendedParameters, ParameterCount);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MapViewOfFile3FromApp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_LONG_LONG,
            C_LONG_LONG,
            C_LONG,
            C_LONG,
            C_POINTER,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("MapViewOfFile3FromApp"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PVOID MapViewOfFile3FromApp(HANDLE FileMapping, HANDLE Process, PVOID BaseAddress, ULONG64 Offset, SIZE_T ViewSize, ULONG AllocationType, ULONG PageProtection, MEM_EXTENDED_PARAMETER *ExtendedParameters, ULONG ParameterCount)
     * }
     */
    public static FunctionDescriptor MapViewOfFile3FromApp$descriptor() {
        return MapViewOfFile3FromApp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PVOID MapViewOfFile3FromApp(HANDLE FileMapping, HANDLE Process, PVOID BaseAddress, ULONG64 Offset, SIZE_T ViewSize, ULONG AllocationType, ULONG PageProtection, MEM_EXTENDED_PARAMETER *ExtendedParameters, ULONG ParameterCount)
     * }
     */
    public static MethodHandle MapViewOfFile3FromApp$handle() {
        return MapViewOfFile3FromApp.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * PVOID MapViewOfFile3FromApp(HANDLE FileMapping, HANDLE Process, PVOID BaseAddress, ULONG64 Offset, SIZE_T ViewSize, ULONG AllocationType, ULONG PageProtection, MEM_EXTENDED_PARAMETER *ExtendedParameters, ULONG ParameterCount)
     * }
     */
    public static MemorySegment MapViewOfFile3FromApp(MemorySegment FileMapping, MemorySegment Process, MemorySegment BaseAddress, long Offset, long ViewSize, int AllocationType, int PageProtection, MemorySegment ExtendedParameters, int ParameterCount) {
        var mh$ = MapViewOfFile3FromApp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MapViewOfFile3FromApp", FileMapping, Process, BaseAddress, Offset, ViewSize, AllocationType, PageProtection, ExtendedParameters, ParameterCount);
            }
            return (MemorySegment)mh$.invokeExact(FileMapping, Process, BaseAddress, Offset, ViewSize, AllocationType, PageProtection, ExtendedParameters, ParameterCount);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateFileMapping2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_LONG,
            C_LONG,
            C_LONG,
            C_LONG_LONG,
            C_POINTER,
            C_POINTER,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CreateFileMapping2"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HANDLE CreateFileMapping2(HANDLE File, SECURITY_ATTRIBUTES *SecurityAttributes, ULONG DesiredAccess, ULONG PageProtection, ULONG AllocationAttributes, ULONG64 MaximumSize, PCWSTR Name, MEM_EXTENDED_PARAMETER *ExtendedParameters, ULONG ParameterCount)
     * }
     */
    public static FunctionDescriptor CreateFileMapping2$descriptor() {
        return CreateFileMapping2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HANDLE CreateFileMapping2(HANDLE File, SECURITY_ATTRIBUTES *SecurityAttributes, ULONG DesiredAccess, ULONG PageProtection, ULONG AllocationAttributes, ULONG64 MaximumSize, PCWSTR Name, MEM_EXTENDED_PARAMETER *ExtendedParameters, ULONG ParameterCount)
     * }
     */
    public static MethodHandle CreateFileMapping2$handle() {
        return CreateFileMapping2.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * HANDLE CreateFileMapping2(HANDLE File, SECURITY_ATTRIBUTES *SecurityAttributes, ULONG DesiredAccess, ULONG PageProtection, ULONG AllocationAttributes, ULONG64 MaximumSize, PCWSTR Name, MEM_EXTENDED_PARAMETER *ExtendedParameters, ULONG ParameterCount)
     * }
     */
    public static MemorySegment CreateFileMapping2(MemorySegment File, MemorySegment SecurityAttributes, int DesiredAccess, int PageProtection, int AllocationAttributes, long MaximumSize, MemorySegment Name, MemorySegment ExtendedParameters, int ParameterCount) {
        var mh$ = CreateFileMapping2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateFileMapping2", File, SecurityAttributes, DesiredAccess, PageProtection, AllocationAttributes, MaximumSize, Name, ExtendedParameters, ParameterCount);
            }
            return (MemorySegment)mh$.invokeExact(File, SecurityAttributes, DesiredAccess, PageProtection, AllocationAttributes, MaximumSize, Name, ExtendedParameters, ParameterCount);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class AllocateUserPhysicalPages2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("AllocateUserPhysicalPages2"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL AllocateUserPhysicalPages2(HANDLE ObjectHandle, PULONG_PTR NumberOfPages, PULONG_PTR PageArray, PMEM_EXTENDED_PARAMETER ExtendedParameters, ULONG ExtendedParameterCount)
     * }
     */
    public static FunctionDescriptor AllocateUserPhysicalPages2$descriptor() {
        return AllocateUserPhysicalPages2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL AllocateUserPhysicalPages2(HANDLE ObjectHandle, PULONG_PTR NumberOfPages, PULONG_PTR PageArray, PMEM_EXTENDED_PARAMETER ExtendedParameters, ULONG ExtendedParameterCount)
     * }
     */
    public static MethodHandle AllocateUserPhysicalPages2$handle() {
        return AllocateUserPhysicalPages2.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL AllocateUserPhysicalPages2(HANDLE ObjectHandle, PULONG_PTR NumberOfPages, PULONG_PTR PageArray, PMEM_EXTENDED_PARAMETER ExtendedParameters, ULONG ExtendedParameterCount)
     * }
     */
    public static int AllocateUserPhysicalPages2(MemorySegment ObjectHandle, MemorySegment NumberOfPages, MemorySegment PageArray, MemorySegment ExtendedParameters, int ExtendedParameterCount) {
        var mh$ = AllocateUserPhysicalPages2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("AllocateUserPhysicalPages2", ObjectHandle, NumberOfPages, PageArray, ExtendedParameters, ExtendedParameterCount);
            }
            return (int)mh$.invokeExact(ObjectHandle, NumberOfPages, PageArray, ExtendedParameters, ExtendedParameterCount);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int MemoryPartitionInfo = (int)0L;
    /**
     * {@snippet lang=c :
     * enum WIN32_MEMORY_PARTITION_INFORMATION_CLASS.MemoryPartitionInfo = 0
     * }
     */
    public static int MemoryPartitionInfo() {
        return MemoryPartitionInfo;
    }
    private static final int MemoryPartitionDedicatedMemoryInfo = (int)1L;
    /**
     * {@snippet lang=c :
     * enum WIN32_MEMORY_PARTITION_INFORMATION_CLASS.MemoryPartitionDedicatedMemoryInfo = 1
     * }
     */
    public static int MemoryPartitionDedicatedMemoryInfo() {
        return MemoryPartitionDedicatedMemoryInfo;
    }

    private static class OpenDedicatedMemoryPartition {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER,
            C_LONG_LONG,
            C_LONG,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("OpenDedicatedMemoryPartition"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HANDLE OpenDedicatedMemoryPartition(HANDLE Partition, ULONG64 DedicatedMemoryTypeId, ACCESS_MASK DesiredAccess, BOOL InheritHandle)
     * }
     */
    public static FunctionDescriptor OpenDedicatedMemoryPartition$descriptor() {
        return OpenDedicatedMemoryPartition.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HANDLE OpenDedicatedMemoryPartition(HANDLE Partition, ULONG64 DedicatedMemoryTypeId, ACCESS_MASK DesiredAccess, BOOL InheritHandle)
     * }
     */
    public static MethodHandle OpenDedicatedMemoryPartition$handle() {
        return OpenDedicatedMemoryPartition.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * HANDLE OpenDedicatedMemoryPartition(HANDLE Partition, ULONG64 DedicatedMemoryTypeId, ACCESS_MASK DesiredAccess, BOOL InheritHandle)
     * }
     */
    public static MemorySegment OpenDedicatedMemoryPartition(MemorySegment Partition, long DedicatedMemoryTypeId, int DesiredAccess, int InheritHandle) {
        var mh$ = OpenDedicatedMemoryPartition.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("OpenDedicatedMemoryPartition", Partition, DedicatedMemoryTypeId, DesiredAccess, InheritHandle);
            }
            return (MemorySegment)mh$.invokeExact(Partition, DedicatedMemoryTypeId, DesiredAccess, InheritHandle);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class QueryPartitionInformation {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_INT,
            C_POINTER,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("QueryPartitionInformation"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL QueryPartitionInformation(HANDLE Partition, WIN32_MEMORY_PARTITION_INFORMATION_CLASS PartitionInformationClass, PVOID PartitionInformation, ULONG PartitionInformationLength)
     * }
     */
    public static FunctionDescriptor QueryPartitionInformation$descriptor() {
        return QueryPartitionInformation.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL QueryPartitionInformation(HANDLE Partition, WIN32_MEMORY_PARTITION_INFORMATION_CLASS PartitionInformationClass, PVOID PartitionInformation, ULONG PartitionInformationLength)
     * }
     */
    public static MethodHandle QueryPartitionInformation$handle() {
        return QueryPartitionInformation.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL QueryPartitionInformation(HANDLE Partition, WIN32_MEMORY_PARTITION_INFORMATION_CLASS PartitionInformationClass, PVOID PartitionInformation, ULONG PartitionInformationLength)
     * }
     */
    public static int QueryPartitionInformation(MemorySegment Partition, int PartitionInformationClass, MemorySegment PartitionInformation, int PartitionInformationLength) {
        var mh$ = QueryPartitionInformation.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("QueryPartitionInformation", Partition, PartitionInformationClass, PartitionInformation, PartitionInformationLength);
            }
            return (int)mh$.invokeExact(Partition, PartitionInformationClass, PartitionInformation, PartitionInformationLength);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class IsEnclaveTypeSupported {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("IsEnclaveTypeSupported"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL IsEnclaveTypeSupported(DWORD flEnclaveType)
     * }
     */
    public static FunctionDescriptor IsEnclaveTypeSupported$descriptor() {
        return IsEnclaveTypeSupported.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL IsEnclaveTypeSupported(DWORD flEnclaveType)
     * }
     */
    public static MethodHandle IsEnclaveTypeSupported$handle() {
        return IsEnclaveTypeSupported.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL IsEnclaveTypeSupported(DWORD flEnclaveType)
     * }
     */
    public static int IsEnclaveTypeSupported(int flEnclaveType) {
        var mh$ = IsEnclaveTypeSupported.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("IsEnclaveTypeSupported", flEnclaveType);
            }
            return (int)mh$.invokeExact(flEnclaveType);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateEnclave {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_LONG_LONG,
            C_LONG_LONG,
            C_LONG,
            C_POINTER,
            C_LONG,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CreateEnclave"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * LPVOID CreateEnclave(HANDLE hProcess, LPVOID lpAddress, SIZE_T dwSize, SIZE_T dwInitialCommitment, DWORD flEnclaveType, LPCVOID lpEnclaveInformation, DWORD dwInfoLength, LPDWORD lpEnclaveError)
     * }
     */
    public static FunctionDescriptor CreateEnclave$descriptor() {
        return CreateEnclave.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * LPVOID CreateEnclave(HANDLE hProcess, LPVOID lpAddress, SIZE_T dwSize, SIZE_T dwInitialCommitment, DWORD flEnclaveType, LPCVOID lpEnclaveInformation, DWORD dwInfoLength, LPDWORD lpEnclaveError)
     * }
     */
    public static MethodHandle CreateEnclave$handle() {
        return CreateEnclave.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * LPVOID CreateEnclave(HANDLE hProcess, LPVOID lpAddress, SIZE_T dwSize, SIZE_T dwInitialCommitment, DWORD flEnclaveType, LPCVOID lpEnclaveInformation, DWORD dwInfoLength, LPDWORD lpEnclaveError)
     * }
     */
    public static MemorySegment CreateEnclave(MemorySegment hProcess, MemorySegment lpAddress, long dwSize, long dwInitialCommitment, int flEnclaveType, MemorySegment lpEnclaveInformation, int dwInfoLength, MemorySegment lpEnclaveError) {
        var mh$ = CreateEnclave.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateEnclave", hProcess, lpAddress, dwSize, dwInitialCommitment, flEnclaveType, lpEnclaveInformation, dwInfoLength, lpEnclaveError);
            }
            return (MemorySegment)mh$.invokeExact(hProcess, lpAddress, dwSize, dwInitialCommitment, flEnclaveType, lpEnclaveInformation, dwInfoLength, lpEnclaveError);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LoadEnclaveData {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_LONG_LONG,
            C_LONG,
            C_POINTER,
            C_LONG,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("LoadEnclaveData"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL LoadEnclaveData(HANDLE hProcess, LPVOID lpAddress, LPCVOID lpBuffer, SIZE_T nSize, DWORD flProtect, LPCVOID lpPageInformation, DWORD dwInfoLength, PSIZE_T lpNumberOfBytesWritten, LPDWORD lpEnclaveError)
     * }
     */
    public static FunctionDescriptor LoadEnclaveData$descriptor() {
        return LoadEnclaveData.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL LoadEnclaveData(HANDLE hProcess, LPVOID lpAddress, LPCVOID lpBuffer, SIZE_T nSize, DWORD flProtect, LPCVOID lpPageInformation, DWORD dwInfoLength, PSIZE_T lpNumberOfBytesWritten, LPDWORD lpEnclaveError)
     * }
     */
    public static MethodHandle LoadEnclaveData$handle() {
        return LoadEnclaveData.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL LoadEnclaveData(HANDLE hProcess, LPVOID lpAddress, LPCVOID lpBuffer, SIZE_T nSize, DWORD flProtect, LPCVOID lpPageInformation, DWORD dwInfoLength, PSIZE_T lpNumberOfBytesWritten, LPDWORD lpEnclaveError)
     * }
     */
    public static int LoadEnclaveData(MemorySegment hProcess, MemorySegment lpAddress, MemorySegment lpBuffer, long nSize, int flProtect, MemorySegment lpPageInformation, int dwInfoLength, MemorySegment lpNumberOfBytesWritten, MemorySegment lpEnclaveError) {
        var mh$ = LoadEnclaveData.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LoadEnclaveData", hProcess, lpAddress, lpBuffer, nSize, flProtect, lpPageInformation, dwInfoLength, lpNumberOfBytesWritten, lpEnclaveError);
            }
            return (int)mh$.invokeExact(hProcess, lpAddress, lpBuffer, nSize, flProtect, lpPageInformation, dwInfoLength, lpNumberOfBytesWritten, lpEnclaveError);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class InitializeEnclave {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_LONG,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("InitializeEnclave"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL InitializeEnclave(HANDLE hProcess, LPVOID lpAddress, LPCVOID lpEnclaveInformation, DWORD dwInfoLength, LPDWORD lpEnclaveError)
     * }
     */
    public static FunctionDescriptor InitializeEnclave$descriptor() {
        return InitializeEnclave.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL InitializeEnclave(HANDLE hProcess, LPVOID lpAddress, LPCVOID lpEnclaveInformation, DWORD dwInfoLength, LPDWORD lpEnclaveError)
     * }
     */
    public static MethodHandle InitializeEnclave$handle() {
        return InitializeEnclave.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL InitializeEnclave(HANDLE hProcess, LPVOID lpAddress, LPCVOID lpEnclaveInformation, DWORD dwInfoLength, LPDWORD lpEnclaveError)
     * }
     */
    public static int InitializeEnclave(MemorySegment hProcess, MemorySegment lpAddress, MemorySegment lpEnclaveInformation, int dwInfoLength, MemorySegment lpEnclaveError) {
        var mh$ = InitializeEnclave.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("InitializeEnclave", hProcess, lpAddress, lpEnclaveInformation, dwInfoLength, lpEnclaveError);
            }
            return (int)mh$.invokeExact(hProcess, lpAddress, lpEnclaveInformation, dwInfoLength, lpEnclaveError);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LoadEnclaveImageA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("LoadEnclaveImageA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL LoadEnclaveImageA(LPVOID lpEnclaveAddress, LPCSTR lpImageName)
     * }
     */
    public static FunctionDescriptor LoadEnclaveImageA$descriptor() {
        return LoadEnclaveImageA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL LoadEnclaveImageA(LPVOID lpEnclaveAddress, LPCSTR lpImageName)
     * }
     */
    public static MethodHandle LoadEnclaveImageA$handle() {
        return LoadEnclaveImageA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL LoadEnclaveImageA(LPVOID lpEnclaveAddress, LPCSTR lpImageName)
     * }
     */
    public static int LoadEnclaveImageA(MemorySegment lpEnclaveAddress, MemorySegment lpImageName) {
        var mh$ = LoadEnclaveImageA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LoadEnclaveImageA", lpEnclaveAddress, lpImageName);
            }
            return (int)mh$.invokeExact(lpEnclaveAddress, lpImageName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LoadEnclaveImageW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("LoadEnclaveImageW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL LoadEnclaveImageW(LPVOID lpEnclaveAddress, LPCWSTR lpImageName)
     * }
     */
    public static FunctionDescriptor LoadEnclaveImageW$descriptor() {
        return LoadEnclaveImageW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL LoadEnclaveImageW(LPVOID lpEnclaveAddress, LPCWSTR lpImageName)
     * }
     */
    public static MethodHandle LoadEnclaveImageW$handle() {
        return LoadEnclaveImageW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL LoadEnclaveImageW(LPVOID lpEnclaveAddress, LPCWSTR lpImageName)
     * }
     */
    public static int LoadEnclaveImageW(MemorySegment lpEnclaveAddress, MemorySegment lpImageName) {
        var mh$ = LoadEnclaveImageW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LoadEnclaveImageW", lpEnclaveAddress, lpImageName);
            }
            return (int)mh$.invokeExact(lpEnclaveAddress, lpImageName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CallEnclave {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CallEnclave"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CallEnclave(LPENCLAVE_ROUTINE lpRoutine, LPVOID lpParameter, BOOL fWaitForThread, LPVOID *lpReturnValue)
     * }
     */
    public static FunctionDescriptor CallEnclave$descriptor() {
        return CallEnclave.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CallEnclave(LPENCLAVE_ROUTINE lpRoutine, LPVOID lpParameter, BOOL fWaitForThread, LPVOID *lpReturnValue)
     * }
     */
    public static MethodHandle CallEnclave$handle() {
        return CallEnclave.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL CallEnclave(LPENCLAVE_ROUTINE lpRoutine, LPVOID lpParameter, BOOL fWaitForThread, LPVOID *lpReturnValue)
     * }
     */
    public static int CallEnclave(MemorySegment lpRoutine, MemorySegment lpParameter, int fWaitForThread, MemorySegment lpReturnValue) {
        var mh$ = CallEnclave.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CallEnclave", lpRoutine, lpParameter, fWaitForThread, lpReturnValue);
            }
            return (int)mh$.invokeExact(lpRoutine, lpParameter, fWaitForThread, lpReturnValue);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TerminateEnclave {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("TerminateEnclave"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL TerminateEnclave(LPVOID lpAddress, BOOL fWait)
     * }
     */
    public static FunctionDescriptor TerminateEnclave$descriptor() {
        return TerminateEnclave.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL TerminateEnclave(LPVOID lpAddress, BOOL fWait)
     * }
     */
    public static MethodHandle TerminateEnclave$handle() {
        return TerminateEnclave.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL TerminateEnclave(LPVOID lpAddress, BOOL fWait)
     * }
     */
    public static int TerminateEnclave(MemorySegment lpAddress, int fWait) {
        var mh$ = TerminateEnclave.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TerminateEnclave", lpAddress, fWait);
            }
            return (int)mh$.invokeExact(lpAddress, fWait);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DeleteEnclave {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("DeleteEnclave"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL DeleteEnclave(LPVOID lpAddress)
     * }
     */
    public static FunctionDescriptor DeleteEnclave$descriptor() {
        return DeleteEnclave.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL DeleteEnclave(LPVOID lpAddress)
     * }
     */
    public static MethodHandle DeleteEnclave$handle() {
        return DeleteEnclave.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL DeleteEnclave(LPVOID lpAddress)
     * }
     */
    public static int DeleteEnclave(MemorySegment lpAddress) {
        var mh$ = DeleteEnclave.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DeleteEnclave", lpAddress);
            }
            return (int)mh$.invokeExact(lpAddress);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class QueueUserWorkItem {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("QueueUserWorkItem"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL QueueUserWorkItem(LPTHREAD_START_ROUTINE Function, PVOID Context, ULONG Flags)
     * }
     */
    public static FunctionDescriptor QueueUserWorkItem$descriptor() {
        return QueueUserWorkItem.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL QueueUserWorkItem(LPTHREAD_START_ROUTINE Function, PVOID Context, ULONG Flags)
     * }
     */
    public static MethodHandle QueueUserWorkItem$handle() {
        return QueueUserWorkItem.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL QueueUserWorkItem(LPTHREAD_START_ROUTINE Function, PVOID Context, ULONG Flags)
     * }
     */
    public static int QueueUserWorkItem(MemorySegment Function, MemorySegment Context, int Flags) {
        var mh$ = QueueUserWorkItem.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("QueueUserWorkItem", Function, Context, Flags);
            }
            return (int)mh$.invokeExact(Function, Context, Flags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class UnregisterWaitEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("UnregisterWaitEx"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL UnregisterWaitEx(HANDLE WaitHandle, HANDLE CompletionEvent)
     * }
     */
    public static FunctionDescriptor UnregisterWaitEx$descriptor() {
        return UnregisterWaitEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL UnregisterWaitEx(HANDLE WaitHandle, HANDLE CompletionEvent)
     * }
     */
    public static MethodHandle UnregisterWaitEx$handle() {
        return UnregisterWaitEx.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL UnregisterWaitEx(HANDLE WaitHandle, HANDLE CompletionEvent)
     * }
     */
    public static int UnregisterWaitEx(MemorySegment WaitHandle, MemorySegment CompletionEvent) {
        var mh$ = UnregisterWaitEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("UnregisterWaitEx", WaitHandle, CompletionEvent);
            }
            return (int)mh$.invokeExact(WaitHandle, CompletionEvent);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateTimerQueue {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER    );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CreateTimerQueue"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HANDLE CreateTimerQueue()
     * }
     */
    public static FunctionDescriptor CreateTimerQueue$descriptor() {
        return CreateTimerQueue.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HANDLE CreateTimerQueue()
     * }
     */
    public static MethodHandle CreateTimerQueue$handle() {
        return CreateTimerQueue.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * HANDLE CreateTimerQueue()
     * }
     */
    public static MemorySegment CreateTimerQueue() {
        var mh$ = CreateTimerQueue.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateTimerQueue");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateTimerQueueTimer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_LONG,
            C_LONG,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CreateTimerQueueTimer"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CreateTimerQueueTimer(PHANDLE phNewTimer, HANDLE TimerQueue, WAITORTIMERCALLBACK Callback, PVOID Parameter, DWORD DueTime, DWORD Period, ULONG Flags)
     * }
     */
    public static FunctionDescriptor CreateTimerQueueTimer$descriptor() {
        return CreateTimerQueueTimer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CreateTimerQueueTimer(PHANDLE phNewTimer, HANDLE TimerQueue, WAITORTIMERCALLBACK Callback, PVOID Parameter, DWORD DueTime, DWORD Period, ULONG Flags)
     * }
     */
    public static MethodHandle CreateTimerQueueTimer$handle() {
        return CreateTimerQueueTimer.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL CreateTimerQueueTimer(PHANDLE phNewTimer, HANDLE TimerQueue, WAITORTIMERCALLBACK Callback, PVOID Parameter, DWORD DueTime, DWORD Period, ULONG Flags)
     * }
     */
    public static int CreateTimerQueueTimer(MemorySegment phNewTimer, MemorySegment TimerQueue, MemorySegment Callback, MemorySegment Parameter, int DueTime, int Period, int Flags) {
        var mh$ = CreateTimerQueueTimer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateTimerQueueTimer", phNewTimer, TimerQueue, Callback, Parameter, DueTime, Period, Flags);
            }
            return (int)mh$.invokeExact(phNewTimer, TimerQueue, Callback, Parameter, DueTime, Period, Flags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ChangeTimerQueueTimer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_LONG,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("ChangeTimerQueueTimer"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL ChangeTimerQueueTimer(HANDLE TimerQueue, HANDLE Timer, ULONG DueTime, ULONG Period)
     * }
     */
    public static FunctionDescriptor ChangeTimerQueueTimer$descriptor() {
        return ChangeTimerQueueTimer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL ChangeTimerQueueTimer(HANDLE TimerQueue, HANDLE Timer, ULONG DueTime, ULONG Period)
     * }
     */
    public static MethodHandle ChangeTimerQueueTimer$handle() {
        return ChangeTimerQueueTimer.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL ChangeTimerQueueTimer(HANDLE TimerQueue, HANDLE Timer, ULONG DueTime, ULONG Period)
     * }
     */
    public static int ChangeTimerQueueTimer(MemorySegment TimerQueue, MemorySegment Timer, int DueTime, int Period) {
        var mh$ = ChangeTimerQueueTimer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ChangeTimerQueueTimer", TimerQueue, Timer, DueTime, Period);
            }
            return (int)mh$.invokeExact(TimerQueue, Timer, DueTime, Period);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DeleteTimerQueueTimer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("DeleteTimerQueueTimer"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL DeleteTimerQueueTimer(HANDLE TimerQueue, HANDLE Timer, HANDLE CompletionEvent)
     * }
     */
    public static FunctionDescriptor DeleteTimerQueueTimer$descriptor() {
        return DeleteTimerQueueTimer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL DeleteTimerQueueTimer(HANDLE TimerQueue, HANDLE Timer, HANDLE CompletionEvent)
     * }
     */
    public static MethodHandle DeleteTimerQueueTimer$handle() {
        return DeleteTimerQueueTimer.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL DeleteTimerQueueTimer(HANDLE TimerQueue, HANDLE Timer, HANDLE CompletionEvent)
     * }
     */
    public static int DeleteTimerQueueTimer(MemorySegment TimerQueue, MemorySegment Timer, MemorySegment CompletionEvent) {
        var mh$ = DeleteTimerQueueTimer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DeleteTimerQueueTimer", TimerQueue, Timer, CompletionEvent);
            }
            return (int)mh$.invokeExact(TimerQueue, Timer, CompletionEvent);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DeleteTimerQueue {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("DeleteTimerQueue"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL DeleteTimerQueue(HANDLE TimerQueue)
     * }
     */
    public static FunctionDescriptor DeleteTimerQueue$descriptor() {
        return DeleteTimerQueue.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL DeleteTimerQueue(HANDLE TimerQueue)
     * }
     */
    public static MethodHandle DeleteTimerQueue$handle() {
        return DeleteTimerQueue.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL DeleteTimerQueue(HANDLE TimerQueue)
     * }
     */
    public static int DeleteTimerQueue(MemorySegment TimerQueue) {
        var mh$ = DeleteTimerQueue.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DeleteTimerQueue", TimerQueue);
            }
            return (int)mh$.invokeExact(TimerQueue);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DeleteTimerQueueEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("DeleteTimerQueueEx"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL DeleteTimerQueueEx(HANDLE TimerQueue, HANDLE CompletionEvent)
     * }
     */
    public static FunctionDescriptor DeleteTimerQueueEx$descriptor() {
        return DeleteTimerQueueEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL DeleteTimerQueueEx(HANDLE TimerQueue, HANDLE CompletionEvent)
     * }
     */
    public static MethodHandle DeleteTimerQueueEx$handle() {
        return DeleteTimerQueueEx.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL DeleteTimerQueueEx(HANDLE TimerQueue, HANDLE CompletionEvent)
     * }
     */
    public static int DeleteTimerQueueEx(MemorySegment TimerQueue, MemorySegment CompletionEvent) {
        var mh$ = DeleteTimerQueueEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DeleteTimerQueueEx", TimerQueue, CompletionEvent);
            }
            return (int)mh$.invokeExact(TimerQueue, CompletionEvent);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateThreadpool {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CreateThreadpool"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PTP_POOL CreateThreadpool(PVOID reserved)
     * }
     */
    public static FunctionDescriptor CreateThreadpool$descriptor() {
        return CreateThreadpool.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PTP_POOL CreateThreadpool(PVOID reserved)
     * }
     */
    public static MethodHandle CreateThreadpool$handle() {
        return CreateThreadpool.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * PTP_POOL CreateThreadpool(PVOID reserved)
     * }
     */
    public static MemorySegment CreateThreadpool(MemorySegment reserved) {
        var mh$ = CreateThreadpool.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateThreadpool", reserved);
            }
            return (MemorySegment)mh$.invokeExact(reserved);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetThreadpoolThreadMaximum {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C_POINTER,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("SetThreadpoolThreadMaximum"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SetThreadpoolThreadMaximum(PTP_POOL ptpp, DWORD cthrdMost)
     * }
     */
    public static FunctionDescriptor SetThreadpoolThreadMaximum$descriptor() {
        return SetThreadpoolThreadMaximum.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SetThreadpoolThreadMaximum(PTP_POOL ptpp, DWORD cthrdMost)
     * }
     */
    public static MethodHandle SetThreadpoolThreadMaximum$handle() {
        return SetThreadpoolThreadMaximum.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * void SetThreadpoolThreadMaximum(PTP_POOL ptpp, DWORD cthrdMost)
     * }
     */
    public static void SetThreadpoolThreadMaximum(MemorySegment ptpp, int cthrdMost) {
        var mh$ = SetThreadpoolThreadMaximum.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetThreadpoolThreadMaximum", ptpp, cthrdMost);
            }
            mh$.invokeExact(ptpp, cthrdMost);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetThreadpoolThreadMinimum {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("SetThreadpoolThreadMinimum"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetThreadpoolThreadMinimum(PTP_POOL ptpp, DWORD cthrdMic)
     * }
     */
    public static FunctionDescriptor SetThreadpoolThreadMinimum$descriptor() {
        return SetThreadpoolThreadMinimum.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetThreadpoolThreadMinimum(PTP_POOL ptpp, DWORD cthrdMic)
     * }
     */
    public static MethodHandle SetThreadpoolThreadMinimum$handle() {
        return SetThreadpoolThreadMinimum.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL SetThreadpoolThreadMinimum(PTP_POOL ptpp, DWORD cthrdMic)
     * }
     */
    public static int SetThreadpoolThreadMinimum(MemorySegment ptpp, int cthrdMic) {
        var mh$ = SetThreadpoolThreadMinimum.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetThreadpoolThreadMinimum", ptpp, cthrdMic);
            }
            return (int)mh$.invokeExact(ptpp, cthrdMic);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetThreadpoolStackInformation {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("SetThreadpoolStackInformation"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetThreadpoolStackInformation(PTP_POOL ptpp, PTP_POOL_STACK_INFORMATION ptpsi)
     * }
     */
    public static FunctionDescriptor SetThreadpoolStackInformation$descriptor() {
        return SetThreadpoolStackInformation.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetThreadpoolStackInformation(PTP_POOL ptpp, PTP_POOL_STACK_INFORMATION ptpsi)
     * }
     */
    public static MethodHandle SetThreadpoolStackInformation$handle() {
        return SetThreadpoolStackInformation.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL SetThreadpoolStackInformation(PTP_POOL ptpp, PTP_POOL_STACK_INFORMATION ptpsi)
     * }
     */
    public static int SetThreadpoolStackInformation(MemorySegment ptpp, MemorySegment ptpsi) {
        var mh$ = SetThreadpoolStackInformation.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetThreadpoolStackInformation", ptpp, ptpsi);
            }
            return (int)mh$.invokeExact(ptpp, ptpsi);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class QueryThreadpoolStackInformation {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("QueryThreadpoolStackInformation"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL QueryThreadpoolStackInformation(PTP_POOL ptpp, PTP_POOL_STACK_INFORMATION ptpsi)
     * }
     */
    public static FunctionDescriptor QueryThreadpoolStackInformation$descriptor() {
        return QueryThreadpoolStackInformation.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL QueryThreadpoolStackInformation(PTP_POOL ptpp, PTP_POOL_STACK_INFORMATION ptpsi)
     * }
     */
    public static MethodHandle QueryThreadpoolStackInformation$handle() {
        return QueryThreadpoolStackInformation.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL QueryThreadpoolStackInformation(PTP_POOL ptpp, PTP_POOL_STACK_INFORMATION ptpsi)
     * }
     */
    public static int QueryThreadpoolStackInformation(MemorySegment ptpp, MemorySegment ptpsi) {
        var mh$ = QueryThreadpoolStackInformation.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("QueryThreadpoolStackInformation", ptpp, ptpsi);
            }
            return (int)mh$.invokeExact(ptpp, ptpsi);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CloseThreadpool {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CloseThreadpool"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void CloseThreadpool(PTP_POOL ptpp)
     * }
     */
    public static FunctionDescriptor CloseThreadpool$descriptor() {
        return CloseThreadpool.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void CloseThreadpool(PTP_POOL ptpp)
     * }
     */
    public static MethodHandle CloseThreadpool$handle() {
        return CloseThreadpool.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * void CloseThreadpool(PTP_POOL ptpp)
     * }
     */
    public static void CloseThreadpool(MemorySegment ptpp) {
        var mh$ = CloseThreadpool.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CloseThreadpool", ptpp);
            }
            mh$.invokeExact(ptpp);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateThreadpoolCleanupGroup {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER    );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CreateThreadpoolCleanupGroup"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PTP_CLEANUP_GROUP CreateThreadpoolCleanupGroup()
     * }
     */
    public static FunctionDescriptor CreateThreadpoolCleanupGroup$descriptor() {
        return CreateThreadpoolCleanupGroup.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PTP_CLEANUP_GROUP CreateThreadpoolCleanupGroup()
     * }
     */
    public static MethodHandle CreateThreadpoolCleanupGroup$handle() {
        return CreateThreadpoolCleanupGroup.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * PTP_CLEANUP_GROUP CreateThreadpoolCleanupGroup()
     * }
     */
    public static MemorySegment CreateThreadpoolCleanupGroup() {
        var mh$ = CreateThreadpoolCleanupGroup.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateThreadpoolCleanupGroup");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CloseThreadpoolCleanupGroupMembers {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C_POINTER,
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CloseThreadpoolCleanupGroupMembers"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void CloseThreadpoolCleanupGroupMembers(PTP_CLEANUP_GROUP ptpcg, BOOL fCancelPendingCallbacks, PVOID pvCleanupContext)
     * }
     */
    public static FunctionDescriptor CloseThreadpoolCleanupGroupMembers$descriptor() {
        return CloseThreadpoolCleanupGroupMembers.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void CloseThreadpoolCleanupGroupMembers(PTP_CLEANUP_GROUP ptpcg, BOOL fCancelPendingCallbacks, PVOID pvCleanupContext)
     * }
     */
    public static MethodHandle CloseThreadpoolCleanupGroupMembers$handle() {
        return CloseThreadpoolCleanupGroupMembers.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * void CloseThreadpoolCleanupGroupMembers(PTP_CLEANUP_GROUP ptpcg, BOOL fCancelPendingCallbacks, PVOID pvCleanupContext)
     * }
     */
    public static void CloseThreadpoolCleanupGroupMembers(MemorySegment ptpcg, int fCancelPendingCallbacks, MemorySegment pvCleanupContext) {
        var mh$ = CloseThreadpoolCleanupGroupMembers.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CloseThreadpoolCleanupGroupMembers", ptpcg, fCancelPendingCallbacks, pvCleanupContext);
            }
            mh$.invokeExact(ptpcg, fCancelPendingCallbacks, pvCleanupContext);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CloseThreadpoolCleanupGroup {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CloseThreadpoolCleanupGroup"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void CloseThreadpoolCleanupGroup(PTP_CLEANUP_GROUP ptpcg)
     * }
     */
    public static FunctionDescriptor CloseThreadpoolCleanupGroup$descriptor() {
        return CloseThreadpoolCleanupGroup.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void CloseThreadpoolCleanupGroup(PTP_CLEANUP_GROUP ptpcg)
     * }
     */
    public static MethodHandle CloseThreadpoolCleanupGroup$handle() {
        return CloseThreadpoolCleanupGroup.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * void CloseThreadpoolCleanupGroup(PTP_CLEANUP_GROUP ptpcg)
     * }
     */
    public static void CloseThreadpoolCleanupGroup(MemorySegment ptpcg) {
        var mh$ = CloseThreadpoolCleanupGroup.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CloseThreadpoolCleanupGroup", ptpcg);
            }
            mh$.invokeExact(ptpcg);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetEventWhenCallbackReturns {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("SetEventWhenCallbackReturns"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SetEventWhenCallbackReturns(PTP_CALLBACK_INSTANCE pci, HANDLE evt)
     * }
     */
    public static FunctionDescriptor SetEventWhenCallbackReturns$descriptor() {
        return SetEventWhenCallbackReturns.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SetEventWhenCallbackReturns(PTP_CALLBACK_INSTANCE pci, HANDLE evt)
     * }
     */
    public static MethodHandle SetEventWhenCallbackReturns$handle() {
        return SetEventWhenCallbackReturns.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * void SetEventWhenCallbackReturns(PTP_CALLBACK_INSTANCE pci, HANDLE evt)
     * }
     */
    public static void SetEventWhenCallbackReturns(MemorySegment pci, MemorySegment evt) {
        var mh$ = SetEventWhenCallbackReturns.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetEventWhenCallbackReturns", pci, evt);
            }
            mh$.invokeExact(pci, evt);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ReleaseSemaphoreWhenCallbackReturns {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C_POINTER,
            C_POINTER,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("ReleaseSemaphoreWhenCallbackReturns"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ReleaseSemaphoreWhenCallbackReturns(PTP_CALLBACK_INSTANCE pci, HANDLE sem, DWORD crel)
     * }
     */
    public static FunctionDescriptor ReleaseSemaphoreWhenCallbackReturns$descriptor() {
        return ReleaseSemaphoreWhenCallbackReturns.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ReleaseSemaphoreWhenCallbackReturns(PTP_CALLBACK_INSTANCE pci, HANDLE sem, DWORD crel)
     * }
     */
    public static MethodHandle ReleaseSemaphoreWhenCallbackReturns$handle() {
        return ReleaseSemaphoreWhenCallbackReturns.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * void ReleaseSemaphoreWhenCallbackReturns(PTP_CALLBACK_INSTANCE pci, HANDLE sem, DWORD crel)
     * }
     */
    public static void ReleaseSemaphoreWhenCallbackReturns(MemorySegment pci, MemorySegment sem, int crel) {
        var mh$ = ReleaseSemaphoreWhenCallbackReturns.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ReleaseSemaphoreWhenCallbackReturns", pci, sem, crel);
            }
            mh$.invokeExact(pci, sem, crel);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ReleaseMutexWhenCallbackReturns {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("ReleaseMutexWhenCallbackReturns"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ReleaseMutexWhenCallbackReturns(PTP_CALLBACK_INSTANCE pci, HANDLE mut)
     * }
     */
    public static FunctionDescriptor ReleaseMutexWhenCallbackReturns$descriptor() {
        return ReleaseMutexWhenCallbackReturns.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ReleaseMutexWhenCallbackReturns(PTP_CALLBACK_INSTANCE pci, HANDLE mut)
     * }
     */
    public static MethodHandle ReleaseMutexWhenCallbackReturns$handle() {
        return ReleaseMutexWhenCallbackReturns.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * void ReleaseMutexWhenCallbackReturns(PTP_CALLBACK_INSTANCE pci, HANDLE mut)
     * }
     */
    public static void ReleaseMutexWhenCallbackReturns(MemorySegment pci, MemorySegment mut) {
        var mh$ = ReleaseMutexWhenCallbackReturns.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ReleaseMutexWhenCallbackReturns", pci, mut);
            }
            mh$.invokeExact(pci, mut);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LeaveCriticalSectionWhenCallbackReturns {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("LeaveCriticalSectionWhenCallbackReturns"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void LeaveCriticalSectionWhenCallbackReturns(PTP_CALLBACK_INSTANCE pci, PCRITICAL_SECTION pcs)
     * }
     */
    public static FunctionDescriptor LeaveCriticalSectionWhenCallbackReturns$descriptor() {
        return LeaveCriticalSectionWhenCallbackReturns.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void LeaveCriticalSectionWhenCallbackReturns(PTP_CALLBACK_INSTANCE pci, PCRITICAL_SECTION pcs)
     * }
     */
    public static MethodHandle LeaveCriticalSectionWhenCallbackReturns$handle() {
        return LeaveCriticalSectionWhenCallbackReturns.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * void LeaveCriticalSectionWhenCallbackReturns(PTP_CALLBACK_INSTANCE pci, PCRITICAL_SECTION pcs)
     * }
     */
    public static void LeaveCriticalSectionWhenCallbackReturns(MemorySegment pci, MemorySegment pcs) {
        var mh$ = LeaveCriticalSectionWhenCallbackReturns.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LeaveCriticalSectionWhenCallbackReturns", pci, pcs);
            }
            mh$.invokeExact(pci, pcs);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FreeLibraryWhenCallbackReturns {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("FreeLibraryWhenCallbackReturns"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void FreeLibraryWhenCallbackReturns(PTP_CALLBACK_INSTANCE pci, HMODULE mod)
     * }
     */
    public static FunctionDescriptor FreeLibraryWhenCallbackReturns$descriptor() {
        return FreeLibraryWhenCallbackReturns.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void FreeLibraryWhenCallbackReturns(PTP_CALLBACK_INSTANCE pci, HMODULE mod)
     * }
     */
    public static MethodHandle FreeLibraryWhenCallbackReturns$handle() {
        return FreeLibraryWhenCallbackReturns.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * void FreeLibraryWhenCallbackReturns(PTP_CALLBACK_INSTANCE pci, HMODULE mod)
     * }
     */
    public static void FreeLibraryWhenCallbackReturns(MemorySegment pci, MemorySegment mod) {
        var mh$ = FreeLibraryWhenCallbackReturns.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FreeLibraryWhenCallbackReturns", pci, mod);
            }
            mh$.invokeExact(pci, mod);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CallbackMayRunLong {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CallbackMayRunLong"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL CallbackMayRunLong(PTP_CALLBACK_INSTANCE pci)
     * }
     */
    public static FunctionDescriptor CallbackMayRunLong$descriptor() {
        return CallbackMayRunLong.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL CallbackMayRunLong(PTP_CALLBACK_INSTANCE pci)
     * }
     */
    public static MethodHandle CallbackMayRunLong$handle() {
        return CallbackMayRunLong.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL CallbackMayRunLong(PTP_CALLBACK_INSTANCE pci)
     * }
     */
    public static int CallbackMayRunLong(MemorySegment pci) {
        var mh$ = CallbackMayRunLong.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CallbackMayRunLong", pci);
            }
            return (int)mh$.invokeExact(pci);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DisassociateCurrentThreadFromCallback {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("DisassociateCurrentThreadFromCallback"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void DisassociateCurrentThreadFromCallback(PTP_CALLBACK_INSTANCE pci)
     * }
     */
    public static FunctionDescriptor DisassociateCurrentThreadFromCallback$descriptor() {
        return DisassociateCurrentThreadFromCallback.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void DisassociateCurrentThreadFromCallback(PTP_CALLBACK_INSTANCE pci)
     * }
     */
    public static MethodHandle DisassociateCurrentThreadFromCallback$handle() {
        return DisassociateCurrentThreadFromCallback.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * void DisassociateCurrentThreadFromCallback(PTP_CALLBACK_INSTANCE pci)
     * }
     */
    public static void DisassociateCurrentThreadFromCallback(MemorySegment pci) {
        var mh$ = DisassociateCurrentThreadFromCallback.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DisassociateCurrentThreadFromCallback", pci);
            }
            mh$.invokeExact(pci);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TrySubmitThreadpoolCallback {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("TrySubmitThreadpoolCallback"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL TrySubmitThreadpoolCallback(PTP_SIMPLE_CALLBACK pfns, PVOID pv, PTP_CALLBACK_ENVIRON pcbe)
     * }
     */
    public static FunctionDescriptor TrySubmitThreadpoolCallback$descriptor() {
        return TrySubmitThreadpoolCallback.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL TrySubmitThreadpoolCallback(PTP_SIMPLE_CALLBACK pfns, PVOID pv, PTP_CALLBACK_ENVIRON pcbe)
     * }
     */
    public static MethodHandle TrySubmitThreadpoolCallback$handle() {
        return TrySubmitThreadpoolCallback.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL TrySubmitThreadpoolCallback(PTP_SIMPLE_CALLBACK pfns, PVOID pv, PTP_CALLBACK_ENVIRON pcbe)
     * }
     */
    public static int TrySubmitThreadpoolCallback(MemorySegment pfns, MemorySegment pv, MemorySegment pcbe) {
        var mh$ = TrySubmitThreadpoolCallback.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TrySubmitThreadpoolCallback", pfns, pv, pcbe);
            }
            return (int)mh$.invokeExact(pfns, pv, pcbe);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateThreadpoolWork {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CreateThreadpoolWork"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PTP_WORK CreateThreadpoolWork(PTP_WORK_CALLBACK pfnwk, PVOID pv, PTP_CALLBACK_ENVIRON pcbe)
     * }
     */
    public static FunctionDescriptor CreateThreadpoolWork$descriptor() {
        return CreateThreadpoolWork.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PTP_WORK CreateThreadpoolWork(PTP_WORK_CALLBACK pfnwk, PVOID pv, PTP_CALLBACK_ENVIRON pcbe)
     * }
     */
    public static MethodHandle CreateThreadpoolWork$handle() {
        return CreateThreadpoolWork.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * PTP_WORK CreateThreadpoolWork(PTP_WORK_CALLBACK pfnwk, PVOID pv, PTP_CALLBACK_ENVIRON pcbe)
     * }
     */
    public static MemorySegment CreateThreadpoolWork(MemorySegment pfnwk, MemorySegment pv, MemorySegment pcbe) {
        var mh$ = CreateThreadpoolWork.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateThreadpoolWork", pfnwk, pv, pcbe);
            }
            return (MemorySegment)mh$.invokeExact(pfnwk, pv, pcbe);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SubmitThreadpoolWork {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("SubmitThreadpoolWork"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SubmitThreadpoolWork(PTP_WORK pwk)
     * }
     */
    public static FunctionDescriptor SubmitThreadpoolWork$descriptor() {
        return SubmitThreadpoolWork.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SubmitThreadpoolWork(PTP_WORK pwk)
     * }
     */
    public static MethodHandle SubmitThreadpoolWork$handle() {
        return SubmitThreadpoolWork.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * void SubmitThreadpoolWork(PTP_WORK pwk)
     * }
     */
    public static void SubmitThreadpoolWork(MemorySegment pwk) {
        var mh$ = SubmitThreadpoolWork.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SubmitThreadpoolWork", pwk);
            }
            mh$.invokeExact(pwk);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class WaitForThreadpoolWorkCallbacks {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C_POINTER,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("WaitForThreadpoolWorkCallbacks"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void WaitForThreadpoolWorkCallbacks(PTP_WORK pwk, BOOL fCancelPendingCallbacks)
     * }
     */
    public static FunctionDescriptor WaitForThreadpoolWorkCallbacks$descriptor() {
        return WaitForThreadpoolWorkCallbacks.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void WaitForThreadpoolWorkCallbacks(PTP_WORK pwk, BOOL fCancelPendingCallbacks)
     * }
     */
    public static MethodHandle WaitForThreadpoolWorkCallbacks$handle() {
        return WaitForThreadpoolWorkCallbacks.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * void WaitForThreadpoolWorkCallbacks(PTP_WORK pwk, BOOL fCancelPendingCallbacks)
     * }
     */
    public static void WaitForThreadpoolWorkCallbacks(MemorySegment pwk, int fCancelPendingCallbacks) {
        var mh$ = WaitForThreadpoolWorkCallbacks.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WaitForThreadpoolWorkCallbacks", pwk, fCancelPendingCallbacks);
            }
            mh$.invokeExact(pwk, fCancelPendingCallbacks);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CloseThreadpoolWork {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CloseThreadpoolWork"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void CloseThreadpoolWork(PTP_WORK pwk)
     * }
     */
    public static FunctionDescriptor CloseThreadpoolWork$descriptor() {
        return CloseThreadpoolWork.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void CloseThreadpoolWork(PTP_WORK pwk)
     * }
     */
    public static MethodHandle CloseThreadpoolWork$handle() {
        return CloseThreadpoolWork.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * void CloseThreadpoolWork(PTP_WORK pwk)
     * }
     */
    public static void CloseThreadpoolWork(MemorySegment pwk) {
        var mh$ = CloseThreadpoolWork.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CloseThreadpoolWork", pwk);
            }
            mh$.invokeExact(pwk);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateThreadpoolTimer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CreateThreadpoolTimer"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PTP_TIMER CreateThreadpoolTimer(PTP_TIMER_CALLBACK pfnti, PVOID pv, PTP_CALLBACK_ENVIRON pcbe)
     * }
     */
    public static FunctionDescriptor CreateThreadpoolTimer$descriptor() {
        return CreateThreadpoolTimer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PTP_TIMER CreateThreadpoolTimer(PTP_TIMER_CALLBACK pfnti, PVOID pv, PTP_CALLBACK_ENVIRON pcbe)
     * }
     */
    public static MethodHandle CreateThreadpoolTimer$handle() {
        return CreateThreadpoolTimer.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * PTP_TIMER CreateThreadpoolTimer(PTP_TIMER_CALLBACK pfnti, PVOID pv, PTP_CALLBACK_ENVIRON pcbe)
     * }
     */
    public static MemorySegment CreateThreadpoolTimer(MemorySegment pfnti, MemorySegment pv, MemorySegment pcbe) {
        var mh$ = CreateThreadpoolTimer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateThreadpoolTimer", pfnti, pv, pcbe);
            }
            return (MemorySegment)mh$.invokeExact(pfnti, pv, pcbe);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetThreadpoolTimer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C_POINTER,
            C_POINTER,
            C_LONG,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("SetThreadpoolTimer"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SetThreadpoolTimer(PTP_TIMER pti, PFILETIME pftDueTime, DWORD msPeriod, DWORD msWindowLength)
     * }
     */
    public static FunctionDescriptor SetThreadpoolTimer$descriptor() {
        return SetThreadpoolTimer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SetThreadpoolTimer(PTP_TIMER pti, PFILETIME pftDueTime, DWORD msPeriod, DWORD msWindowLength)
     * }
     */
    public static MethodHandle SetThreadpoolTimer$handle() {
        return SetThreadpoolTimer.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * void SetThreadpoolTimer(PTP_TIMER pti, PFILETIME pftDueTime, DWORD msPeriod, DWORD msWindowLength)
     * }
     */
    public static void SetThreadpoolTimer(MemorySegment pti, MemorySegment pftDueTime, int msPeriod, int msWindowLength) {
        var mh$ = SetThreadpoolTimer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetThreadpoolTimer", pti, pftDueTime, msPeriod, msWindowLength);
            }
            mh$.invokeExact(pti, pftDueTime, msPeriod, msWindowLength);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class IsThreadpoolTimerSet {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("IsThreadpoolTimerSet"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL IsThreadpoolTimerSet(PTP_TIMER pti)
     * }
     */
    public static FunctionDescriptor IsThreadpoolTimerSet$descriptor() {
        return IsThreadpoolTimerSet.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL IsThreadpoolTimerSet(PTP_TIMER pti)
     * }
     */
    public static MethodHandle IsThreadpoolTimerSet$handle() {
        return IsThreadpoolTimerSet.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL IsThreadpoolTimerSet(PTP_TIMER pti)
     * }
     */
    public static int IsThreadpoolTimerSet(MemorySegment pti) {
        var mh$ = IsThreadpoolTimerSet.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("IsThreadpoolTimerSet", pti);
            }
            return (int)mh$.invokeExact(pti);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class WaitForThreadpoolTimerCallbacks {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C_POINTER,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("WaitForThreadpoolTimerCallbacks"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void WaitForThreadpoolTimerCallbacks(PTP_TIMER pti, BOOL fCancelPendingCallbacks)
     * }
     */
    public static FunctionDescriptor WaitForThreadpoolTimerCallbacks$descriptor() {
        return WaitForThreadpoolTimerCallbacks.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void WaitForThreadpoolTimerCallbacks(PTP_TIMER pti, BOOL fCancelPendingCallbacks)
     * }
     */
    public static MethodHandle WaitForThreadpoolTimerCallbacks$handle() {
        return WaitForThreadpoolTimerCallbacks.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * void WaitForThreadpoolTimerCallbacks(PTP_TIMER pti, BOOL fCancelPendingCallbacks)
     * }
     */
    public static void WaitForThreadpoolTimerCallbacks(MemorySegment pti, int fCancelPendingCallbacks) {
        var mh$ = WaitForThreadpoolTimerCallbacks.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WaitForThreadpoolTimerCallbacks", pti, fCancelPendingCallbacks);
            }
            mh$.invokeExact(pti, fCancelPendingCallbacks);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CloseThreadpoolTimer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CloseThreadpoolTimer"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void CloseThreadpoolTimer(PTP_TIMER pti)
     * }
     */
    public static FunctionDescriptor CloseThreadpoolTimer$descriptor() {
        return CloseThreadpoolTimer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void CloseThreadpoolTimer(PTP_TIMER pti)
     * }
     */
    public static MethodHandle CloseThreadpoolTimer$handle() {
        return CloseThreadpoolTimer.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * void CloseThreadpoolTimer(PTP_TIMER pti)
     * }
     */
    public static void CloseThreadpoolTimer(MemorySegment pti) {
        var mh$ = CloseThreadpoolTimer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CloseThreadpoolTimer", pti);
            }
            mh$.invokeExact(pti);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateThreadpoolWait {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CreateThreadpoolWait"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PTP_WAIT CreateThreadpoolWait(PTP_WAIT_CALLBACK pfnwa, PVOID pv, PTP_CALLBACK_ENVIRON pcbe)
     * }
     */
    public static FunctionDescriptor CreateThreadpoolWait$descriptor() {
        return CreateThreadpoolWait.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PTP_WAIT CreateThreadpoolWait(PTP_WAIT_CALLBACK pfnwa, PVOID pv, PTP_CALLBACK_ENVIRON pcbe)
     * }
     */
    public static MethodHandle CreateThreadpoolWait$handle() {
        return CreateThreadpoolWait.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * PTP_WAIT CreateThreadpoolWait(PTP_WAIT_CALLBACK pfnwa, PVOID pv, PTP_CALLBACK_ENVIRON pcbe)
     * }
     */
    public static MemorySegment CreateThreadpoolWait(MemorySegment pfnwa, MemorySegment pv, MemorySegment pcbe) {
        var mh$ = CreateThreadpoolWait.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateThreadpoolWait", pfnwa, pv, pcbe);
            }
            return (MemorySegment)mh$.invokeExact(pfnwa, pv, pcbe);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetThreadpoolWait {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("SetThreadpoolWait"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SetThreadpoolWait(PTP_WAIT pwa, HANDLE h, PFILETIME pftTimeout)
     * }
     */
    public static FunctionDescriptor SetThreadpoolWait$descriptor() {
        return SetThreadpoolWait.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SetThreadpoolWait(PTP_WAIT pwa, HANDLE h, PFILETIME pftTimeout)
     * }
     */
    public static MethodHandle SetThreadpoolWait$handle() {
        return SetThreadpoolWait.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * void SetThreadpoolWait(PTP_WAIT pwa, HANDLE h, PFILETIME pftTimeout)
     * }
     */
    public static void SetThreadpoolWait(MemorySegment pwa, MemorySegment h, MemorySegment pftTimeout) {
        var mh$ = SetThreadpoolWait.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetThreadpoolWait", pwa, h, pftTimeout);
            }
            mh$.invokeExact(pwa, h, pftTimeout);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class WaitForThreadpoolWaitCallbacks {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C_POINTER,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("WaitForThreadpoolWaitCallbacks"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void WaitForThreadpoolWaitCallbacks(PTP_WAIT pwa, BOOL fCancelPendingCallbacks)
     * }
     */
    public static FunctionDescriptor WaitForThreadpoolWaitCallbacks$descriptor() {
        return WaitForThreadpoolWaitCallbacks.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void WaitForThreadpoolWaitCallbacks(PTP_WAIT pwa, BOOL fCancelPendingCallbacks)
     * }
     */
    public static MethodHandle WaitForThreadpoolWaitCallbacks$handle() {
        return WaitForThreadpoolWaitCallbacks.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * void WaitForThreadpoolWaitCallbacks(PTP_WAIT pwa, BOOL fCancelPendingCallbacks)
     * }
     */
    public static void WaitForThreadpoolWaitCallbacks(MemorySegment pwa, int fCancelPendingCallbacks) {
        var mh$ = WaitForThreadpoolWaitCallbacks.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WaitForThreadpoolWaitCallbacks", pwa, fCancelPendingCallbacks);
            }
            mh$.invokeExact(pwa, fCancelPendingCallbacks);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CloseThreadpoolWait {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CloseThreadpoolWait"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void CloseThreadpoolWait(PTP_WAIT pwa)
     * }
     */
    public static FunctionDescriptor CloseThreadpoolWait$descriptor() {
        return CloseThreadpoolWait.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void CloseThreadpoolWait(PTP_WAIT pwa)
     * }
     */
    public static MethodHandle CloseThreadpoolWait$handle() {
        return CloseThreadpoolWait.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * void CloseThreadpoolWait(PTP_WAIT pwa)
     * }
     */
    public static void CloseThreadpoolWait(MemorySegment pwa) {
        var mh$ = CloseThreadpoolWait.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CloseThreadpoolWait", pwa);
            }
            mh$.invokeExact(pwa);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateThreadpoolIo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CreateThreadpoolIo"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * PTP_IO CreateThreadpoolIo(HANDLE fl, PTP_WIN32_IO_CALLBACK pfnio, PVOID pv, PTP_CALLBACK_ENVIRON pcbe)
     * }
     */
    public static FunctionDescriptor CreateThreadpoolIo$descriptor() {
        return CreateThreadpoolIo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * PTP_IO CreateThreadpoolIo(HANDLE fl, PTP_WIN32_IO_CALLBACK pfnio, PVOID pv, PTP_CALLBACK_ENVIRON pcbe)
     * }
     */
    public static MethodHandle CreateThreadpoolIo$handle() {
        return CreateThreadpoolIo.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * PTP_IO CreateThreadpoolIo(HANDLE fl, PTP_WIN32_IO_CALLBACK pfnio, PVOID pv, PTP_CALLBACK_ENVIRON pcbe)
     * }
     */
    public static MemorySegment CreateThreadpoolIo(MemorySegment fl, MemorySegment pfnio, MemorySegment pv, MemorySegment pcbe) {
        var mh$ = CreateThreadpoolIo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateThreadpoolIo", fl, pfnio, pv, pcbe);
            }
            return (MemorySegment)mh$.invokeExact(fl, pfnio, pv, pcbe);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class StartThreadpoolIo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("StartThreadpoolIo"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void StartThreadpoolIo(PTP_IO pio)
     * }
     */
    public static FunctionDescriptor StartThreadpoolIo$descriptor() {
        return StartThreadpoolIo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void StartThreadpoolIo(PTP_IO pio)
     * }
     */
    public static MethodHandle StartThreadpoolIo$handle() {
        return StartThreadpoolIo.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * void StartThreadpoolIo(PTP_IO pio)
     * }
     */
    public static void StartThreadpoolIo(MemorySegment pio) {
        var mh$ = StartThreadpoolIo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("StartThreadpoolIo", pio);
            }
            mh$.invokeExact(pio);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CancelThreadpoolIo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CancelThreadpoolIo"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void CancelThreadpoolIo(PTP_IO pio)
     * }
     */
    public static FunctionDescriptor CancelThreadpoolIo$descriptor() {
        return CancelThreadpoolIo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void CancelThreadpoolIo(PTP_IO pio)
     * }
     */
    public static MethodHandle CancelThreadpoolIo$handle() {
        return CancelThreadpoolIo.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * void CancelThreadpoolIo(PTP_IO pio)
     * }
     */
    public static void CancelThreadpoolIo(MemorySegment pio) {
        var mh$ = CancelThreadpoolIo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CancelThreadpoolIo", pio);
            }
            mh$.invokeExact(pio);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class WaitForThreadpoolIoCallbacks {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C_POINTER,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("WaitForThreadpoolIoCallbacks"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void WaitForThreadpoolIoCallbacks(PTP_IO pio, BOOL fCancelPendingCallbacks)
     * }
     */
    public static FunctionDescriptor WaitForThreadpoolIoCallbacks$descriptor() {
        return WaitForThreadpoolIoCallbacks.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void WaitForThreadpoolIoCallbacks(PTP_IO pio, BOOL fCancelPendingCallbacks)
     * }
     */
    public static MethodHandle WaitForThreadpoolIoCallbacks$handle() {
        return WaitForThreadpoolIoCallbacks.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * void WaitForThreadpoolIoCallbacks(PTP_IO pio, BOOL fCancelPendingCallbacks)
     * }
     */
    public static void WaitForThreadpoolIoCallbacks(MemorySegment pio, int fCancelPendingCallbacks) {
        var mh$ = WaitForThreadpoolIoCallbacks.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WaitForThreadpoolIoCallbacks", pio, fCancelPendingCallbacks);
            }
            mh$.invokeExact(pio, fCancelPendingCallbacks);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CloseThreadpoolIo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CloseThreadpoolIo"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void CloseThreadpoolIo(PTP_IO pio)
     * }
     */
    public static FunctionDescriptor CloseThreadpoolIo$descriptor() {
        return CloseThreadpoolIo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void CloseThreadpoolIo(PTP_IO pio)
     * }
     */
    public static MethodHandle CloseThreadpoolIo$handle() {
        return CloseThreadpoolIo.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * void CloseThreadpoolIo(PTP_IO pio)
     * }
     */
    public static void CloseThreadpoolIo(MemorySegment pio) {
        var mh$ = CloseThreadpoolIo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CloseThreadpoolIo", pio);
            }
            mh$.invokeExact(pio);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetThreadpoolTimerEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_LONG,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("SetThreadpoolTimerEx"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetThreadpoolTimerEx(PTP_TIMER pti, PFILETIME pftDueTime, DWORD msPeriod, DWORD msWindowLength)
     * }
     */
    public static FunctionDescriptor SetThreadpoolTimerEx$descriptor() {
        return SetThreadpoolTimerEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetThreadpoolTimerEx(PTP_TIMER pti, PFILETIME pftDueTime, DWORD msPeriod, DWORD msWindowLength)
     * }
     */
    public static MethodHandle SetThreadpoolTimerEx$handle() {
        return SetThreadpoolTimerEx.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL SetThreadpoolTimerEx(PTP_TIMER pti, PFILETIME pftDueTime, DWORD msPeriod, DWORD msWindowLength)
     * }
     */
    public static int SetThreadpoolTimerEx(MemorySegment pti, MemorySegment pftDueTime, int msPeriod, int msWindowLength) {
        var mh$ = SetThreadpoolTimerEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetThreadpoolTimerEx", pti, pftDueTime, msPeriod, msWindowLength);
            }
            return (int)mh$.invokeExact(pti, pftDueTime, msPeriod, msWindowLength);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetThreadpoolWaitEx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("SetThreadpoolWaitEx"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetThreadpoolWaitEx(PTP_WAIT pwa, HANDLE h, PFILETIME pftTimeout, PVOID Reserved)
     * }
     */
    public static FunctionDescriptor SetThreadpoolWaitEx$descriptor() {
        return SetThreadpoolWaitEx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetThreadpoolWaitEx(PTP_WAIT pwa, HANDLE h, PFILETIME pftTimeout, PVOID Reserved)
     * }
     */
    public static MethodHandle SetThreadpoolWaitEx$handle() {
        return SetThreadpoolWaitEx.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL SetThreadpoolWaitEx(PTP_WAIT pwa, HANDLE h, PFILETIME pftTimeout, PVOID Reserved)
     * }
     */
    public static int SetThreadpoolWaitEx(MemorySegment pwa, MemorySegment h, MemorySegment pftTimeout, MemorySegment Reserved) {
        var mh$ = SetThreadpoolWaitEx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetThreadpoolWaitEx", pwa, h, pftTimeout, Reserved);
            }
            return (int)mh$.invokeExact(pwa, h, pftTimeout, Reserved);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class IsProcessInJob {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("IsProcessInJob"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL IsProcessInJob(HANDLE ProcessHandle, HANDLE JobHandle, PBOOL Result)
     * }
     */
    public static FunctionDescriptor IsProcessInJob$descriptor() {
        return IsProcessInJob.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL IsProcessInJob(HANDLE ProcessHandle, HANDLE JobHandle, PBOOL Result)
     * }
     */
    public static MethodHandle IsProcessInJob$handle() {
        return IsProcessInJob.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL IsProcessInJob(HANDLE ProcessHandle, HANDLE JobHandle, PBOOL Result)
     * }
     */
    public static int IsProcessInJob(MemorySegment ProcessHandle, MemorySegment JobHandle, MemorySegment Result) {
        var mh$ = IsProcessInJob.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("IsProcessInJob", ProcessHandle, JobHandle, Result);
            }
            return (int)mh$.invokeExact(ProcessHandle, JobHandle, Result);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CreateJobObjectW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("CreateJobObjectW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HANDLE CreateJobObjectW(LPSECURITY_ATTRIBUTES lpJobAttributes, LPCWSTR lpName)
     * }
     */
    public static FunctionDescriptor CreateJobObjectW$descriptor() {
        return CreateJobObjectW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HANDLE CreateJobObjectW(LPSECURITY_ATTRIBUTES lpJobAttributes, LPCWSTR lpName)
     * }
     */
    public static MethodHandle CreateJobObjectW$handle() {
        return CreateJobObjectW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * HANDLE CreateJobObjectW(LPSECURITY_ATTRIBUTES lpJobAttributes, LPCWSTR lpName)
     * }
     */
    public static MemorySegment CreateJobObjectW(MemorySegment lpJobAttributes, MemorySegment lpName) {
        var mh$ = CreateJobObjectW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CreateJobObjectW", lpJobAttributes, lpName);
            }
            return (MemorySegment)mh$.invokeExact(lpJobAttributes, lpName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FreeMemoryJobObject {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("FreeMemoryJobObject"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void FreeMemoryJobObject(void *Buffer)
     * }
     */
    public static FunctionDescriptor FreeMemoryJobObject$descriptor() {
        return FreeMemoryJobObject.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void FreeMemoryJobObject(void *Buffer)
     * }
     */
    public static MethodHandle FreeMemoryJobObject$handle() {
        return FreeMemoryJobObject.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * void FreeMemoryJobObject(void *Buffer)
     * }
     */
    public static void FreeMemoryJobObject(MemorySegment Buffer) {
        var mh$ = FreeMemoryJobObject.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FreeMemoryJobObject", Buffer);
            }
            mh$.invokeExact(Buffer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class OpenJobObjectW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_POINTER,
            C_LONG,
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("OpenJobObjectW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HANDLE OpenJobObjectW(DWORD dwDesiredAccess, BOOL bInheritHandle, LPCWSTR lpName)
     * }
     */
    public static FunctionDescriptor OpenJobObjectW$descriptor() {
        return OpenJobObjectW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HANDLE OpenJobObjectW(DWORD dwDesiredAccess, BOOL bInheritHandle, LPCWSTR lpName)
     * }
     */
    public static MethodHandle OpenJobObjectW$handle() {
        return OpenJobObjectW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * HANDLE OpenJobObjectW(DWORD dwDesiredAccess, BOOL bInheritHandle, LPCWSTR lpName)
     * }
     */
    public static MemorySegment OpenJobObjectW(int dwDesiredAccess, int bInheritHandle, MemorySegment lpName) {
        var mh$ = OpenJobObjectW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("OpenJobObjectW", dwDesiredAccess, bInheritHandle, lpName);
            }
            return (MemorySegment)mh$.invokeExact(dwDesiredAccess, bInheritHandle, lpName);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class AssignProcessToJobObject {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("AssignProcessToJobObject"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL AssignProcessToJobObject(HANDLE hJob, HANDLE hProcess)
     * }
     */
    public static FunctionDescriptor AssignProcessToJobObject$descriptor() {
        return AssignProcessToJobObject.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL AssignProcessToJobObject(HANDLE hJob, HANDLE hProcess)
     * }
     */
    public static MethodHandle AssignProcessToJobObject$handle() {
        return AssignProcessToJobObject.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL AssignProcessToJobObject(HANDLE hJob, HANDLE hProcess)
     * }
     */
    public static int AssignProcessToJobObject(MemorySegment hJob, MemorySegment hProcess) {
        var mh$ = AssignProcessToJobObject.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("AssignProcessToJobObject", hJob, hProcess);
            }
            return (int)mh$.invokeExact(hJob, hProcess);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TerminateJobObject {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("TerminateJobObject"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL TerminateJobObject(HANDLE hJob, UINT uExitCode)
     * }
     */
    public static FunctionDescriptor TerminateJobObject$descriptor() {
        return TerminateJobObject.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL TerminateJobObject(HANDLE hJob, UINT uExitCode)
     * }
     */
    public static MethodHandle TerminateJobObject$handle() {
        return TerminateJobObject.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL TerminateJobObject(HANDLE hJob, UINT uExitCode)
     * }
     */
    public static int TerminateJobObject(MemorySegment hJob, int uExitCode) {
        var mh$ = TerminateJobObject.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TerminateJobObject", hJob, uExitCode);
            }
            return (int)mh$.invokeExact(hJob, uExitCode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetInformationJobObject {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_INT,
            C_POINTER,
            C_LONG
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("SetInformationJobObject"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL SetInformationJobObject(HANDLE hJob, JOBOBJECTINFOCLASS JobObjectInformationClass, LPVOID lpJobObjectInformation, DWORD cbJobObjectInformationLength)
     * }
     */
    public static FunctionDescriptor SetInformationJobObject$descriptor() {
        return SetInformationJobObject.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL SetInformationJobObject(HANDLE hJob, JOBOBJECTINFOCLASS JobObjectInformationClass, LPVOID lpJobObjectInformation, DWORD cbJobObjectInformationLength)
     * }
     */
    public static MethodHandle SetInformationJobObject$handle() {
        return SetInformationJobObject.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL SetInformationJobObject(HANDLE hJob, JOBOBJECTINFOCLASS JobObjectInformationClass, LPVOID lpJobObjectInformation, DWORD cbJobObjectInformationLength)
     * }
     */
    public static int SetInformationJobObject(MemorySegment hJob, int JobObjectInformationClass, MemorySegment lpJobObjectInformation, int cbJobObjectInformationLength) {
        var mh$ = SetInformationJobObject.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetInformationJobObject", hJob, JobObjectInformationClass, lpJobObjectInformation, cbJobObjectInformationLength);
            }
            return (int)mh$.invokeExact(hJob, JobObjectInformationClass, lpJobObjectInformation, cbJobObjectInformationLength);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SetIoRateControlInformationJobObject {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("SetIoRateControlInformationJobObject"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD SetIoRateControlInformationJobObject(HANDLE hJob, JOBOBJECT_IO_RATE_CONTROL_INFORMATION *IoRateControlInfo)
     * }
     */
    public static FunctionDescriptor SetIoRateControlInformationJobObject$descriptor() {
        return SetIoRateControlInformationJobObject.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD SetIoRateControlInformationJobObject(HANDLE hJob, JOBOBJECT_IO_RATE_CONTROL_INFORMATION *IoRateControlInfo)
     * }
     */
    public static MethodHandle SetIoRateControlInformationJobObject$handle() {
        return SetIoRateControlInformationJobObject.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * DWORD SetIoRateControlInformationJobObject(HANDLE hJob, JOBOBJECT_IO_RATE_CONTROL_INFORMATION *IoRateControlInfo)
     * }
     */
    public static int SetIoRateControlInformationJobObject(MemorySegment hJob, MemorySegment IoRateControlInfo) {
        var mh$ = SetIoRateControlInformationJobObject.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SetIoRateControlInformationJobObject", hJob, IoRateControlInfo);
            }
            return (int)mh$.invokeExact(hJob, IoRateControlInfo);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class QueryInformationJobObject {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_INT,
            C_POINTER,
            C_LONG,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("QueryInformationJobObject"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL QueryInformationJobObject(HANDLE hJob, JOBOBJECTINFOCLASS JobObjectInformationClass, LPVOID lpJobObjectInformation, DWORD cbJobObjectInformationLength, LPDWORD lpReturnLength)
     * }
     */
    public static FunctionDescriptor QueryInformationJobObject$descriptor() {
        return QueryInformationJobObject.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL QueryInformationJobObject(HANDLE hJob, JOBOBJECTINFOCLASS JobObjectInformationClass, LPVOID lpJobObjectInformation, DWORD cbJobObjectInformationLength, LPDWORD lpReturnLength)
     * }
     */
    public static MethodHandle QueryInformationJobObject$handle() {
        return QueryInformationJobObject.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL QueryInformationJobObject(HANDLE hJob, JOBOBJECTINFOCLASS JobObjectInformationClass, LPVOID lpJobObjectInformation, DWORD cbJobObjectInformationLength, LPDWORD lpReturnLength)
     * }
     */
    public static int QueryInformationJobObject(MemorySegment hJob, int JobObjectInformationClass, MemorySegment lpJobObjectInformation, int cbJobObjectInformationLength, MemorySegment lpReturnLength) {
        var mh$ = QueryInformationJobObject.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("QueryInformationJobObject", hJob, JobObjectInformationClass, lpJobObjectInformation, cbJobObjectInformationLength, lpReturnLength);
            }
            return (int)mh$.invokeExact(hJob, JobObjectInformationClass, lpJobObjectInformation, cbJobObjectInformationLength, lpReturnLength);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class QueryIoRateControlInformationJobObject {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_POINTER,
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("QueryIoRateControlInformationJobObject"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * DWORD QueryIoRateControlInformationJobObject(HANDLE hJob, PCWSTR VolumeName, JOBOBJECT_IO_RATE_CONTROL_INFORMATION **InfoBlocks, ULONG *InfoBlockCount)
     * }
     */
    public static FunctionDescriptor QueryIoRateControlInformationJobObject$descriptor() {
        return QueryIoRateControlInformationJobObject.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * DWORD QueryIoRateControlInformationJobObject(HANDLE hJob, PCWSTR VolumeName, JOBOBJECT_IO_RATE_CONTROL_INFORMATION **InfoBlocks, ULONG *InfoBlockCount)
     * }
     */
    public static MethodHandle QueryIoRateControlInformationJobObject$handle() {
        return QueryIoRateControlInformationJobObject.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * DWORD QueryIoRateControlInformationJobObject(HANDLE hJob, PCWSTR VolumeName, JOBOBJECT_IO_RATE_CONTROL_INFORMATION **InfoBlocks, ULONG *InfoBlockCount)
     * }
     */
    public static int QueryIoRateControlInformationJobObject(MemorySegment hJob, MemorySegment VolumeName, MemorySegment InfoBlocks, MemorySegment InfoBlockCount) {
        var mh$ = QueryIoRateControlInformationJobObject.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("QueryIoRateControlInformationJobObject", hJob, VolumeName, InfoBlocks, InfoBlockCount);
            }
            return (int)mh$.invokeExact(hJob, VolumeName, InfoBlocks, InfoBlockCount);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Wow64EnableWow64FsRedirection {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_CHAR,
            C_CHAR
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("Wow64EnableWow64FsRedirection"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOLEAN Wow64EnableWow64FsRedirection(BOOLEAN Wow64FsEnableRedirection)
     * }
     */
    public static FunctionDescriptor Wow64EnableWow64FsRedirection$descriptor() {
        return Wow64EnableWow64FsRedirection.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOLEAN Wow64EnableWow64FsRedirection(BOOLEAN Wow64FsEnableRedirection)
     * }
     */
    public static MethodHandle Wow64EnableWow64FsRedirection$handle() {
        return Wow64EnableWow64FsRedirection.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOLEAN Wow64EnableWow64FsRedirection(BOOLEAN Wow64FsEnableRedirection)
     * }
     */
    public static byte Wow64EnableWow64FsRedirection(byte Wow64FsEnableRedirection) {
        var mh$ = Wow64EnableWow64FsRedirection.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Wow64EnableWow64FsRedirection", Wow64FsEnableRedirection);
            }
            return (byte)mh$.invokeExact(Wow64FsEnableRedirection);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Wow64DisableWow64FsRedirection {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("Wow64DisableWow64FsRedirection"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL Wow64DisableWow64FsRedirection(PVOID *OldValue)
     * }
     */
    public static FunctionDescriptor Wow64DisableWow64FsRedirection$descriptor() {
        return Wow64DisableWow64FsRedirection.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL Wow64DisableWow64FsRedirection(PVOID *OldValue)
     * }
     */
    public static MethodHandle Wow64DisableWow64FsRedirection$handle() {
        return Wow64DisableWow64FsRedirection.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL Wow64DisableWow64FsRedirection(PVOID *OldValue)
     * }
     */
    public static int Wow64DisableWow64FsRedirection(MemorySegment OldValue) {
        var mh$ = Wow64DisableWow64FsRedirection.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Wow64DisableWow64FsRedirection", OldValue);
            }
            return (int)mh$.invokeExact(OldValue);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Wow64RevertWow64FsRedirection {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("Wow64RevertWow64FsRedirection"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL Wow64RevertWow64FsRedirection(PVOID OlValue)
     * }
     */
    public static FunctionDescriptor Wow64RevertWow64FsRedirection$descriptor() {
        return Wow64RevertWow64FsRedirection.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL Wow64RevertWow64FsRedirection(PVOID OlValue)
     * }
     */
    public static MethodHandle Wow64RevertWow64FsRedirection$handle() {
        return Wow64RevertWow64FsRedirection.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL Wow64RevertWow64FsRedirection(PVOID OlValue)
     * }
     */
    public static int Wow64RevertWow64FsRedirection(MemorySegment OlValue) {
        var mh$ = Wow64RevertWow64FsRedirection.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Wow64RevertWow64FsRedirection", OlValue);
            }
            return (int)mh$.invokeExact(OlValue);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class IsWow64Process {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("IsWow64Process"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL IsWow64Process(HANDLE hProcess, PBOOL Wow64Process)
     * }
     */
    public static FunctionDescriptor IsWow64Process$descriptor() {
        return IsWow64Process.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL IsWow64Process(HANDLE hProcess, PBOOL Wow64Process)
     * }
     */
    public static MethodHandle IsWow64Process$handle() {
        return IsWow64Process.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL IsWow64Process(HANDLE hProcess, PBOOL Wow64Process)
     * }
     */
    public static int IsWow64Process(MemorySegment hProcess, MemorySegment Wow64Process) {
        var mh$ = IsWow64Process.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("IsWow64Process", hProcess, Wow64Process);
            }
            return (int)mh$.invokeExact(hProcess, Wow64Process);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetSystemWow64DirectoryA {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetSystemWow64DirectoryA"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * UINT GetSystemWow64DirectoryA(LPSTR lpBuffer, UINT uSize)
     * }
     */
    public static FunctionDescriptor GetSystemWow64DirectoryA$descriptor() {
        return GetSystemWow64DirectoryA.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * UINT GetSystemWow64DirectoryA(LPSTR lpBuffer, UINT uSize)
     * }
     */
    public static MethodHandle GetSystemWow64DirectoryA$handle() {
        return GetSystemWow64DirectoryA.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * UINT GetSystemWow64DirectoryA(LPSTR lpBuffer, UINT uSize)
     * }
     */
    public static int GetSystemWow64DirectoryA(MemorySegment lpBuffer, int uSize) {
        var mh$ = GetSystemWow64DirectoryA.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetSystemWow64DirectoryA", lpBuffer, uSize);
            }
            return (int)mh$.invokeExact(lpBuffer, uSize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetSystemWow64DirectoryW {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_INT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetSystemWow64DirectoryW"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * UINT GetSystemWow64DirectoryW(LPWSTR lpBuffer, UINT uSize)
     * }
     */
    public static FunctionDescriptor GetSystemWow64DirectoryW$descriptor() {
        return GetSystemWow64DirectoryW.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * UINT GetSystemWow64DirectoryW(LPWSTR lpBuffer, UINT uSize)
     * }
     */
    public static MethodHandle GetSystemWow64DirectoryW$handle() {
        return GetSystemWow64DirectoryW.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * UINT GetSystemWow64DirectoryW(LPWSTR lpBuffer, UINT uSize)
     * }
     */
    public static int GetSystemWow64DirectoryW(MemorySegment lpBuffer, int uSize) {
        var mh$ = GetSystemWow64DirectoryW.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetSystemWow64DirectoryW", lpBuffer, uSize);
            }
            return (int)mh$.invokeExact(lpBuffer, uSize);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Wow64SetThreadDefaultGuestMachine {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_SHORT,
            C_SHORT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("Wow64SetThreadDefaultGuestMachine"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * USHORT Wow64SetThreadDefaultGuestMachine(USHORT Machine)
     * }
     */
    public static FunctionDescriptor Wow64SetThreadDefaultGuestMachine$descriptor() {
        return Wow64SetThreadDefaultGuestMachine.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * USHORT Wow64SetThreadDefaultGuestMachine(USHORT Machine)
     * }
     */
    public static MethodHandle Wow64SetThreadDefaultGuestMachine$handle() {
        return Wow64SetThreadDefaultGuestMachine.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * USHORT Wow64SetThreadDefaultGuestMachine(USHORT Machine)
     * }
     */
    public static short Wow64SetThreadDefaultGuestMachine(short Machine) {
        var mh$ = Wow64SetThreadDefaultGuestMachine.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Wow64SetThreadDefaultGuestMachine", Machine);
            }
            return (short)mh$.invokeExact(Machine);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class IsWow64Process2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("IsWow64Process2"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL IsWow64Process2(HANDLE hProcess, USHORT *pProcessMachine, USHORT *pNativeMachine)
     * }
     */
    public static FunctionDescriptor IsWow64Process2$descriptor() {
        return IsWow64Process2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL IsWow64Process2(HANDLE hProcess, USHORT *pProcessMachine, USHORT *pNativeMachine)
     * }
     */
    public static MethodHandle IsWow64Process2$handle() {
        return IsWow64Process2.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL IsWow64Process2(HANDLE hProcess, USHORT *pProcessMachine, USHORT *pNativeMachine)
     * }
     */
    public static int IsWow64Process2(MemorySegment hProcess, MemorySegment pProcessMachine, MemorySegment pNativeMachine) {
        var mh$ = IsWow64Process2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("IsWow64Process2", hProcess, pProcessMachine, pNativeMachine);
            }
            return (int)mh$.invokeExact(hProcess, pProcessMachine, pNativeMachine);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetSystemWow64Directory2A {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_INT,
            C_SHORT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetSystemWow64Directory2A"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * UINT GetSystemWow64Directory2A(LPSTR lpBuffer, UINT uSize, WORD ImageFileMachineType)
     * }
     */
    public static FunctionDescriptor GetSystemWow64Directory2A$descriptor() {
        return GetSystemWow64Directory2A.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * UINT GetSystemWow64Directory2A(LPSTR lpBuffer, UINT uSize, WORD ImageFileMachineType)
     * }
     */
    public static MethodHandle GetSystemWow64Directory2A$handle() {
        return GetSystemWow64Directory2A.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * UINT GetSystemWow64Directory2A(LPSTR lpBuffer, UINT uSize, WORD ImageFileMachineType)
     * }
     */
    public static int GetSystemWow64Directory2A(MemorySegment lpBuffer, int uSize, short ImageFileMachineType) {
        var mh$ = GetSystemWow64Directory2A.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetSystemWow64Directory2A", lpBuffer, uSize, ImageFileMachineType);
            }
            return (int)mh$.invokeExact(lpBuffer, uSize, ImageFileMachineType);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GetSystemWow64Directory2W {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_INT,
            C_SHORT
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("GetSystemWow64Directory2W"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * UINT GetSystemWow64Directory2W(LPWSTR lpBuffer, UINT uSize, WORD ImageFileMachineType)
     * }
     */
    public static FunctionDescriptor GetSystemWow64Directory2W$descriptor() {
        return GetSystemWow64Directory2W.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * UINT GetSystemWow64Directory2W(LPWSTR lpBuffer, UINT uSize, WORD ImageFileMachineType)
     * }
     */
    public static MethodHandle GetSystemWow64Directory2W$handle() {
        return GetSystemWow64Directory2W.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * UINT GetSystemWow64Directory2W(LPWSTR lpBuffer, UINT uSize, WORD ImageFileMachineType)
     * }
     */
    public static int GetSystemWow64Directory2W(MemorySegment lpBuffer, int uSize, short ImageFileMachineType) {
        var mh$ = GetSystemWow64Directory2W.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GetSystemWow64Directory2W", lpBuffer, uSize, ImageFileMachineType);
            }
            return (int)mh$.invokeExact(lpBuffer, uSize, ImageFileMachineType);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class IsWow64GuestMachineSupported {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_LONG,
            C_SHORT,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("IsWow64GuestMachineSupported"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * HRESULT IsWow64GuestMachineSupported(USHORT WowGuestMachine, BOOL *MachineIsSupported)
     * }
     */
    public static FunctionDescriptor IsWow64GuestMachineSupported$descriptor() {
        return IsWow64GuestMachineSupported.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * HRESULT IsWow64GuestMachineSupported(USHORT WowGuestMachine, BOOL *MachineIsSupported)
     * }
     */
    public static MethodHandle IsWow64GuestMachineSupported$handle() {
        return IsWow64GuestMachineSupported.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * HRESULT IsWow64GuestMachineSupported(USHORT WowGuestMachine, BOOL *MachineIsSupported)
     * }
     */
    public static int IsWow64GuestMachineSupported(short WowGuestMachine, MemorySegment MachineIsSupported) {
        var mh$ = IsWow64GuestMachineSupported.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("IsWow64GuestMachineSupported", WowGuestMachine, MachineIsSupported);
            }
            return (int)mh$.invokeExact(WowGuestMachine, MachineIsSupported);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Wow64GetThreadContext {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            C_INT,
            C_POINTER,
            C_POINTER
        );

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(
                    findOrThrow("Wow64GetThreadContext"),
                    DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * BOOL Wow64GetThreadContext(HANDLE hThread, PWOW64_CONTEXT lpContext)
     * }
     */
    public static FunctionDescriptor Wow64GetThreadContext$descriptor() {
        return Wow64GetThreadContext.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * BOOL Wow64GetThreadContext(HANDLE hThread, PWOW64_CONTEXT lpContext)
     * }
     */
    public static MethodHandle Wow64GetThreadContext$handle() {
        return Wow64GetThreadContext.HANDLE;
    }
    /**
     * {@snippet lang=c :
     * BOOL Wow64GetThreadContext(HANDLE hThread, PWOW64_CONTEXT lpContext)
     * }
     */
    public static int Wow64GetThreadContext(MemorySegment hThread, MemorySegment lpContext) {
        var mh$ = Wow64GetThreadContext.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Wow64GetThreadContext", hThread, lpContext);
            }
            return (int)mh$.invokeExact(hThread, lpContext);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
}

