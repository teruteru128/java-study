// Generated by jextract

package com.github.teruteru128.gmp.linux;

import java.lang.invoke.*;
import java.lang.foreign.*;
import java.nio.ByteOrder;
import java.util.*;
import java.util.function.*;
import java.util.stream.*;

import static java.lang.foreign.ValueLayout.*;
import static java.lang.foreign.MemoryLayout.PathElement.*;

public class gmp_h extends gmp_h$shared {

    gmp_h() {
        // Should not be called directly
    }

    static final Arena LIBRARY_ARENA = Arena.ofAuto();

    static final SymbolLookup SYMBOL_LOOKUP = SymbolLookup.libraryLookup(System.mapLibraryName("/usr/lib/x86_64-linux-gnu/libgmp.so.10"), LIBRARY_ARENA)
            .or(SymbolLookup.loaderLookup())
            .or(Linker.nativeLinker().defaultLookup());

    private static final int __GMP_HAVE_HOST_CPU_FAMILY_power = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __GMP_HAVE_HOST_CPU_FAMILY_power 0
     * }
     */
    public static int __GMP_HAVE_HOST_CPU_FAMILY_power() {
        return __GMP_HAVE_HOST_CPU_FAMILY_power;
    }
    private static final int __GMP_HAVE_HOST_CPU_FAMILY_powerpc = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __GMP_HAVE_HOST_CPU_FAMILY_powerpc 0
     * }
     */
    public static int __GMP_HAVE_HOST_CPU_FAMILY_powerpc() {
        return __GMP_HAVE_HOST_CPU_FAMILY_powerpc;
    }
    private static final int GMP_LIMB_BITS = (int)64L;
    /**
     * {@snippet lang=c :
     * #define GMP_LIMB_BITS 64
     * }
     */
    public static int GMP_LIMB_BITS() {
        return GMP_LIMB_BITS;
    }
    private static final int GMP_NAIL_BITS = (int)0L;
    /**
     * {@snippet lang=c :
     * #define GMP_NAIL_BITS 0
     * }
     */
    public static int GMP_NAIL_BITS() {
        return GMP_NAIL_BITS;
    }
    private static final int __GNU_MP__ = (int)6L;
    /**
     * {@snippet lang=c :
     * #define __GNU_MP__ 6
     * }
     */
    public static int __GNU_MP__() {
        return __GNU_MP__;
    }
    private static final int _LIBC_LIMITS_H_ = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _LIBC_LIMITS_H_ 1
     * }
     */
    public static int _LIBC_LIMITS_H_() {
        return _LIBC_LIMITS_H_;
    }
    private static final int _FEATURES_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _FEATURES_H 1
     * }
     */
    public static int _FEATURES_H() {
        return _FEATURES_H;
    }
    private static final int _DEFAULT_SOURCE = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _DEFAULT_SOURCE 1
     * }
     */
    public static int _DEFAULT_SOURCE() {
        return _DEFAULT_SOURCE;
    }
    private static final int __GLIBC_USE_ISOC2X = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __GLIBC_USE_ISOC2X 0
     * }
     */
    public static int __GLIBC_USE_ISOC2X() {
        return __GLIBC_USE_ISOC2X;
    }
    private static final int __USE_ISOC11 = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __USE_ISOC11 1
     * }
     */
    public static int __USE_ISOC11() {
        return __USE_ISOC11;
    }
    private static final int __USE_ISOC99 = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __USE_ISOC99 1
     * }
     */
    public static int __USE_ISOC99() {
        return __USE_ISOC99;
    }
    private static final int __USE_ISOC95 = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __USE_ISOC95 1
     * }
     */
    public static int __USE_ISOC95() {
        return __USE_ISOC95;
    }
    private static final int __USE_POSIX_IMPLICITLY = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __USE_POSIX_IMPLICITLY 1
     * }
     */
    public static int __USE_POSIX_IMPLICITLY() {
        return __USE_POSIX_IMPLICITLY;
    }
    private static final int _POSIX_SOURCE = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_SOURCE 1
     * }
     */
    public static int _POSIX_SOURCE() {
        return _POSIX_SOURCE;
    }
    private static final int __USE_POSIX = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __USE_POSIX 1
     * }
     */
    public static int __USE_POSIX() {
        return __USE_POSIX;
    }
    private static final int __USE_POSIX2 = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __USE_POSIX2 1
     * }
     */
    public static int __USE_POSIX2() {
        return __USE_POSIX2;
    }
    private static final int __USE_POSIX199309 = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __USE_POSIX199309 1
     * }
     */
    public static int __USE_POSIX199309() {
        return __USE_POSIX199309;
    }
    private static final int __USE_POSIX199506 = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __USE_POSIX199506 1
     * }
     */
    public static int __USE_POSIX199506() {
        return __USE_POSIX199506;
    }
    private static final int __USE_XOPEN2K = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __USE_XOPEN2K 1
     * }
     */
    public static int __USE_XOPEN2K() {
        return __USE_XOPEN2K;
    }
    private static final int __USE_XOPEN2K8 = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __USE_XOPEN2K8 1
     * }
     */
    public static int __USE_XOPEN2K8() {
        return __USE_XOPEN2K8;
    }
    private static final int _ATFILE_SOURCE = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _ATFILE_SOURCE 1
     * }
     */
    public static int _ATFILE_SOURCE() {
        return _ATFILE_SOURCE;
    }
    private static final int __WORDSIZE = (int)64L;
    /**
     * {@snippet lang=c :
     * #define __WORDSIZE 64
     * }
     */
    public static int __WORDSIZE() {
        return __WORDSIZE;
    }
    private static final int __WORDSIZE_TIME64_COMPAT32 = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __WORDSIZE_TIME64_COMPAT32 1
     * }
     */
    public static int __WORDSIZE_TIME64_COMPAT32() {
        return __WORDSIZE_TIME64_COMPAT32;
    }
    private static final int __SYSCALL_WORDSIZE = (int)64L;
    /**
     * {@snippet lang=c :
     * #define __SYSCALL_WORDSIZE 64
     * }
     */
    public static int __SYSCALL_WORDSIZE() {
        return __SYSCALL_WORDSIZE;
    }
    private static final int __USE_MISC = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __USE_MISC 1
     * }
     */
    public static int __USE_MISC() {
        return __USE_MISC;
    }
    private static final int __USE_ATFILE = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __USE_ATFILE 1
     * }
     */
    public static int __USE_ATFILE() {
        return __USE_ATFILE;
    }
    private static final int __USE_FORTIFY_LEVEL = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __USE_FORTIFY_LEVEL 0
     * }
     */
    public static int __USE_FORTIFY_LEVEL() {
        return __USE_FORTIFY_LEVEL;
    }
    private static final int __GLIBC_USE_DEPRECATED_GETS = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __GLIBC_USE_DEPRECATED_GETS 0
     * }
     */
    public static int __GLIBC_USE_DEPRECATED_GETS() {
        return __GLIBC_USE_DEPRECATED_GETS;
    }
    private static final int __GLIBC_USE_DEPRECATED_SCANF = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __GLIBC_USE_DEPRECATED_SCANF 0
     * }
     */
    public static int __GLIBC_USE_DEPRECATED_SCANF() {
        return __GLIBC_USE_DEPRECATED_SCANF;
    }
    private static final int __GLIBC_USE_C2X_STRTOL = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __GLIBC_USE_C2X_STRTOL 0
     * }
     */
    public static int __GLIBC_USE_C2X_STRTOL() {
        return __GLIBC_USE_C2X_STRTOL;
    }
    private static final int _STDC_PREDEF_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _STDC_PREDEF_H 1
     * }
     */
    public static int _STDC_PREDEF_H() {
        return _STDC_PREDEF_H;
    }
    private static final int __STDC_IEC_559__ = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __STDC_IEC_559__ 1
     * }
     */
    public static int __STDC_IEC_559__() {
        return __STDC_IEC_559__;
    }
    private static final int __STDC_IEC_559_COMPLEX__ = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __STDC_IEC_559_COMPLEX__ 1
     * }
     */
    public static int __STDC_IEC_559_COMPLEX__() {
        return __STDC_IEC_559_COMPLEX__;
    }
    private static final int __GNU_LIBRARY__ = (int)6L;
    /**
     * {@snippet lang=c :
     * #define __GNU_LIBRARY__ 6
     * }
     */
    public static int __GNU_LIBRARY__() {
        return __GNU_LIBRARY__;
    }
    private static final int __GLIBC__ = (int)2L;
    /**
     * {@snippet lang=c :
     * #define __GLIBC__ 2
     * }
     */
    public static int __GLIBC__() {
        return __GLIBC__;
    }
    private static final int __GLIBC_MINOR__ = (int)39L;
    /**
     * {@snippet lang=c :
     * #define __GLIBC_MINOR__ 39
     * }
     */
    public static int __GLIBC_MINOR__() {
        return __GLIBC_MINOR__;
    }
    private static final int _SYS_CDEFS_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _SYS_CDEFS_H 1
     * }
     */
    public static int _SYS_CDEFS_H() {
        return _SYS_CDEFS_H;
    }
    private static final int __glibc_c99_flexarr_available = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __glibc_c99_flexarr_available 1
     * }
     */
    public static int __glibc_c99_flexarr_available() {
        return __glibc_c99_flexarr_available;
    }
    private static final int __LDOUBLE_REDIRECTS_TO_FLOAT128_ABI = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __LDOUBLE_REDIRECTS_TO_FLOAT128_ABI 0
     * }
     */
    public static int __LDOUBLE_REDIRECTS_TO_FLOAT128_ABI() {
        return __LDOUBLE_REDIRECTS_TO_FLOAT128_ABI;
    }
    private static final int __HAVE_GENERIC_SELECTION = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __HAVE_GENERIC_SELECTION 1
     * }
     */
    public static int __HAVE_GENERIC_SELECTION() {
        return __HAVE_GENERIC_SELECTION;
    }
    private static final int __GLIBC_USE_LIB_EXT2 = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __GLIBC_USE_LIB_EXT2 0
     * }
     */
    public static int __GLIBC_USE_LIB_EXT2() {
        return __GLIBC_USE_LIB_EXT2;
    }
    private static final int __GLIBC_USE_IEC_60559_BFP_EXT = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __GLIBC_USE_IEC_60559_BFP_EXT 0
     * }
     */
    public static int __GLIBC_USE_IEC_60559_BFP_EXT() {
        return __GLIBC_USE_IEC_60559_BFP_EXT;
    }
    private static final int __GLIBC_USE_IEC_60559_BFP_EXT_C2X = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __GLIBC_USE_IEC_60559_BFP_EXT_C2X 0
     * }
     */
    public static int __GLIBC_USE_IEC_60559_BFP_EXT_C2X() {
        return __GLIBC_USE_IEC_60559_BFP_EXT_C2X;
    }
    private static final int __GLIBC_USE_IEC_60559_EXT = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __GLIBC_USE_IEC_60559_EXT 0
     * }
     */
    public static int __GLIBC_USE_IEC_60559_EXT() {
        return __GLIBC_USE_IEC_60559_EXT;
    }
    private static final int __GLIBC_USE_IEC_60559_FUNCS_EXT = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __GLIBC_USE_IEC_60559_FUNCS_EXT 0
     * }
     */
    public static int __GLIBC_USE_IEC_60559_FUNCS_EXT() {
        return __GLIBC_USE_IEC_60559_FUNCS_EXT;
    }
    private static final int __GLIBC_USE_IEC_60559_FUNCS_EXT_C2X = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __GLIBC_USE_IEC_60559_FUNCS_EXT_C2X 0
     * }
     */
    public static int __GLIBC_USE_IEC_60559_FUNCS_EXT_C2X() {
        return __GLIBC_USE_IEC_60559_FUNCS_EXT_C2X;
    }
    private static final int __GLIBC_USE_IEC_60559_TYPES_EXT = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __GLIBC_USE_IEC_60559_TYPES_EXT 0
     * }
     */
    public static int __GLIBC_USE_IEC_60559_TYPES_EXT() {
        return __GLIBC_USE_IEC_60559_TYPES_EXT;
    }
    private static final int MB_LEN_MAX = (int)16L;
    /**
     * {@snippet lang=c :
     * #define MB_LEN_MAX 16
     * }
     */
    public static int MB_LEN_MAX() {
        return MB_LEN_MAX;
    }
    private static final int _BITS_POSIX1_LIM_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _BITS_POSIX1_LIM_H 1
     * }
     */
    public static int _BITS_POSIX1_LIM_H() {
        return _BITS_POSIX1_LIM_H;
    }
    private static final int _POSIX_AIO_LISTIO_MAX = (int)2L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_AIO_LISTIO_MAX 2
     * }
     */
    public static int _POSIX_AIO_LISTIO_MAX() {
        return _POSIX_AIO_LISTIO_MAX;
    }
    private static final int _POSIX_AIO_MAX = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_AIO_MAX 1
     * }
     */
    public static int _POSIX_AIO_MAX() {
        return _POSIX_AIO_MAX;
    }
    private static final int _POSIX_ARG_MAX = (int)4096L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_ARG_MAX 4096
     * }
     */
    public static int _POSIX_ARG_MAX() {
        return _POSIX_ARG_MAX;
    }
    private static final int _POSIX_CHILD_MAX = (int)25L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_CHILD_MAX 25
     * }
     */
    public static int _POSIX_CHILD_MAX() {
        return _POSIX_CHILD_MAX;
    }
    private static final int _POSIX_DELAYTIMER_MAX = (int)32L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_DELAYTIMER_MAX 32
     * }
     */
    public static int _POSIX_DELAYTIMER_MAX() {
        return _POSIX_DELAYTIMER_MAX;
    }
    private static final int _POSIX_HOST_NAME_MAX = (int)255L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_HOST_NAME_MAX 255
     * }
     */
    public static int _POSIX_HOST_NAME_MAX() {
        return _POSIX_HOST_NAME_MAX;
    }
    private static final int _POSIX_LINK_MAX = (int)8L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_LINK_MAX 8
     * }
     */
    public static int _POSIX_LINK_MAX() {
        return _POSIX_LINK_MAX;
    }
    private static final int _POSIX_LOGIN_NAME_MAX = (int)9L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_LOGIN_NAME_MAX 9
     * }
     */
    public static int _POSIX_LOGIN_NAME_MAX() {
        return _POSIX_LOGIN_NAME_MAX;
    }
    private static final int _POSIX_MAX_CANON = (int)255L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_MAX_CANON 255
     * }
     */
    public static int _POSIX_MAX_CANON() {
        return _POSIX_MAX_CANON;
    }
    private static final int _POSIX_MAX_INPUT = (int)255L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_MAX_INPUT 255
     * }
     */
    public static int _POSIX_MAX_INPUT() {
        return _POSIX_MAX_INPUT;
    }
    private static final int _POSIX_MQ_OPEN_MAX = (int)8L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_MQ_OPEN_MAX 8
     * }
     */
    public static int _POSIX_MQ_OPEN_MAX() {
        return _POSIX_MQ_OPEN_MAX;
    }
    private static final int _POSIX_MQ_PRIO_MAX = (int)32L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_MQ_PRIO_MAX 32
     * }
     */
    public static int _POSIX_MQ_PRIO_MAX() {
        return _POSIX_MQ_PRIO_MAX;
    }
    private static final int _POSIX_NAME_MAX = (int)14L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_NAME_MAX 14
     * }
     */
    public static int _POSIX_NAME_MAX() {
        return _POSIX_NAME_MAX;
    }
    private static final int _POSIX_NGROUPS_MAX = (int)8L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_NGROUPS_MAX 8
     * }
     */
    public static int _POSIX_NGROUPS_MAX() {
        return _POSIX_NGROUPS_MAX;
    }
    private static final int _POSIX_OPEN_MAX = (int)20L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_OPEN_MAX 20
     * }
     */
    public static int _POSIX_OPEN_MAX() {
        return _POSIX_OPEN_MAX;
    }
    private static final int _POSIX_PATH_MAX = (int)256L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_PATH_MAX 256
     * }
     */
    public static int _POSIX_PATH_MAX() {
        return _POSIX_PATH_MAX;
    }
    private static final int _POSIX_PIPE_BUF = (int)512L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_PIPE_BUF 512
     * }
     */
    public static int _POSIX_PIPE_BUF() {
        return _POSIX_PIPE_BUF;
    }
    private static final int _POSIX_RE_DUP_MAX = (int)255L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_RE_DUP_MAX 255
     * }
     */
    public static int _POSIX_RE_DUP_MAX() {
        return _POSIX_RE_DUP_MAX;
    }
    private static final int _POSIX_RTSIG_MAX = (int)8L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_RTSIG_MAX 8
     * }
     */
    public static int _POSIX_RTSIG_MAX() {
        return _POSIX_RTSIG_MAX;
    }
    private static final int _POSIX_SEM_NSEMS_MAX = (int)256L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_SEM_NSEMS_MAX 256
     * }
     */
    public static int _POSIX_SEM_NSEMS_MAX() {
        return _POSIX_SEM_NSEMS_MAX;
    }
    private static final int _POSIX_SEM_VALUE_MAX = (int)32767L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_SEM_VALUE_MAX 32767
     * }
     */
    public static int _POSIX_SEM_VALUE_MAX() {
        return _POSIX_SEM_VALUE_MAX;
    }
    private static final int _POSIX_SIGQUEUE_MAX = (int)32L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_SIGQUEUE_MAX 32
     * }
     */
    public static int _POSIX_SIGQUEUE_MAX() {
        return _POSIX_SIGQUEUE_MAX;
    }
    private static final int _POSIX_SSIZE_MAX = (int)32767L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_SSIZE_MAX 32767
     * }
     */
    public static int _POSIX_SSIZE_MAX() {
        return _POSIX_SSIZE_MAX;
    }
    private static final int _POSIX_STREAM_MAX = (int)8L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_STREAM_MAX 8
     * }
     */
    public static int _POSIX_STREAM_MAX() {
        return _POSIX_STREAM_MAX;
    }
    private static final int _POSIX_SYMLINK_MAX = (int)255L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_SYMLINK_MAX 255
     * }
     */
    public static int _POSIX_SYMLINK_MAX() {
        return _POSIX_SYMLINK_MAX;
    }
    private static final int _POSIX_SYMLOOP_MAX = (int)8L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_SYMLOOP_MAX 8
     * }
     */
    public static int _POSIX_SYMLOOP_MAX() {
        return _POSIX_SYMLOOP_MAX;
    }
    private static final int _POSIX_TIMER_MAX = (int)32L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_TIMER_MAX 32
     * }
     */
    public static int _POSIX_TIMER_MAX() {
        return _POSIX_TIMER_MAX;
    }
    private static final int _POSIX_TTY_NAME_MAX = (int)9L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_TTY_NAME_MAX 9
     * }
     */
    public static int _POSIX_TTY_NAME_MAX() {
        return _POSIX_TTY_NAME_MAX;
    }
    private static final int _POSIX_TZNAME_MAX = (int)6L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_TZNAME_MAX 6
     * }
     */
    public static int _POSIX_TZNAME_MAX() {
        return _POSIX_TZNAME_MAX;
    }
    private static final int _POSIX_CLOCKRES_MIN = (int)20000000L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_CLOCKRES_MIN 20000000
     * }
     */
    public static int _POSIX_CLOCKRES_MIN() {
        return _POSIX_CLOCKRES_MIN;
    }
    private static final int NR_OPEN = (int)1024L;
    /**
     * {@snippet lang=c :
     * #define NR_OPEN 1024
     * }
     */
    public static int NR_OPEN() {
        return NR_OPEN;
    }
    private static final int NGROUPS_MAX = (int)65536L;
    /**
     * {@snippet lang=c :
     * #define NGROUPS_MAX 65536
     * }
     */
    public static int NGROUPS_MAX() {
        return NGROUPS_MAX;
    }
    private static final int ARG_MAX = (int)131072L;
    /**
     * {@snippet lang=c :
     * #define ARG_MAX 131072
     * }
     */
    public static int ARG_MAX() {
        return ARG_MAX;
    }
    private static final int LINK_MAX = (int)127L;
    /**
     * {@snippet lang=c :
     * #define LINK_MAX 127
     * }
     */
    public static int LINK_MAX() {
        return LINK_MAX;
    }
    private static final int MAX_CANON = (int)255L;
    /**
     * {@snippet lang=c :
     * #define MAX_CANON 255
     * }
     */
    public static int MAX_CANON() {
        return MAX_CANON;
    }
    private static final int MAX_INPUT = (int)255L;
    /**
     * {@snippet lang=c :
     * #define MAX_INPUT 255
     * }
     */
    public static int MAX_INPUT() {
        return MAX_INPUT;
    }
    private static final int NAME_MAX = (int)255L;
    /**
     * {@snippet lang=c :
     * #define NAME_MAX 255
     * }
     */
    public static int NAME_MAX() {
        return NAME_MAX;
    }
    private static final int PATH_MAX = (int)4096L;
    /**
     * {@snippet lang=c :
     * #define PATH_MAX 4096
     * }
     */
    public static int PATH_MAX() {
        return PATH_MAX;
    }
    private static final int PIPE_BUF = (int)4096L;
    /**
     * {@snippet lang=c :
     * #define PIPE_BUF 4096
     * }
     */
    public static int PIPE_BUF() {
        return PIPE_BUF;
    }
    private static final int XATTR_NAME_MAX = (int)255L;
    /**
     * {@snippet lang=c :
     * #define XATTR_NAME_MAX 255
     * }
     */
    public static int XATTR_NAME_MAX() {
        return XATTR_NAME_MAX;
    }
    private static final int XATTR_SIZE_MAX = (int)65536L;
    /**
     * {@snippet lang=c :
     * #define XATTR_SIZE_MAX 65536
     * }
     */
    public static int XATTR_SIZE_MAX() {
        return XATTR_SIZE_MAX;
    }
    private static final int XATTR_LIST_MAX = (int)65536L;
    /**
     * {@snippet lang=c :
     * #define XATTR_LIST_MAX 65536
     * }
     */
    public static int XATTR_LIST_MAX() {
        return XATTR_LIST_MAX;
    }
    private static final int RTSIG_MAX = (int)32L;
    /**
     * {@snippet lang=c :
     * #define RTSIG_MAX 32
     * }
     */
    public static int RTSIG_MAX() {
        return RTSIG_MAX;
    }
    private static final int _POSIX_THREAD_KEYS_MAX = (int)128L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_THREAD_KEYS_MAX 128
     * }
     */
    public static int _POSIX_THREAD_KEYS_MAX() {
        return _POSIX_THREAD_KEYS_MAX;
    }
    private static final int PTHREAD_KEYS_MAX = (int)1024L;
    /**
     * {@snippet lang=c :
     * #define PTHREAD_KEYS_MAX 1024
     * }
     */
    public static int PTHREAD_KEYS_MAX() {
        return PTHREAD_KEYS_MAX;
    }
    private static final int _POSIX_THREAD_DESTRUCTOR_ITERATIONS = (int)4L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_THREAD_DESTRUCTOR_ITERATIONS 4
     * }
     */
    public static int _POSIX_THREAD_DESTRUCTOR_ITERATIONS() {
        return _POSIX_THREAD_DESTRUCTOR_ITERATIONS;
    }
    private static final int _POSIX_THREAD_THREADS_MAX = (int)64L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_THREAD_THREADS_MAX 64
     * }
     */
    public static int _POSIX_THREAD_THREADS_MAX() {
        return _POSIX_THREAD_THREADS_MAX;
    }
    private static final int AIO_PRIO_DELTA_MAX = (int)20L;
    /**
     * {@snippet lang=c :
     * #define AIO_PRIO_DELTA_MAX 20
     * }
     */
    public static int AIO_PRIO_DELTA_MAX() {
        return AIO_PRIO_DELTA_MAX;
    }
    private static final int PTHREAD_STACK_MIN = (int)16384L;
    /**
     * {@snippet lang=c :
     * #define PTHREAD_STACK_MIN 16384
     * }
     */
    public static int PTHREAD_STACK_MIN() {
        return PTHREAD_STACK_MIN;
    }
    private static final int DELAYTIMER_MAX = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * #define DELAYTIMER_MAX 2147483647
     * }
     */
    public static int DELAYTIMER_MAX() {
        return DELAYTIMER_MAX;
    }
    private static final int TTY_NAME_MAX = (int)32L;
    /**
     * {@snippet lang=c :
     * #define TTY_NAME_MAX 32
     * }
     */
    public static int TTY_NAME_MAX() {
        return TTY_NAME_MAX;
    }
    private static final int LOGIN_NAME_MAX = (int)256L;
    /**
     * {@snippet lang=c :
     * #define LOGIN_NAME_MAX 256
     * }
     */
    public static int LOGIN_NAME_MAX() {
        return LOGIN_NAME_MAX;
    }
    private static final int HOST_NAME_MAX = (int)64L;
    /**
     * {@snippet lang=c :
     * #define HOST_NAME_MAX 64
     * }
     */
    public static int HOST_NAME_MAX() {
        return HOST_NAME_MAX;
    }
    private static final int MQ_PRIO_MAX = (int)32768L;
    /**
     * {@snippet lang=c :
     * #define MQ_PRIO_MAX 32768
     * }
     */
    public static int MQ_PRIO_MAX() {
        return MQ_PRIO_MAX;
    }
    private static final int _BITS_POSIX2_LIM_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _BITS_POSIX2_LIM_H 1
     * }
     */
    public static int _BITS_POSIX2_LIM_H() {
        return _BITS_POSIX2_LIM_H;
    }
    private static final int _POSIX2_BC_BASE_MAX = (int)99L;
    /**
     * {@snippet lang=c :
     * #define _POSIX2_BC_BASE_MAX 99
     * }
     */
    public static int _POSIX2_BC_BASE_MAX() {
        return _POSIX2_BC_BASE_MAX;
    }
    private static final int _POSIX2_BC_DIM_MAX = (int)2048L;
    /**
     * {@snippet lang=c :
     * #define _POSIX2_BC_DIM_MAX 2048
     * }
     */
    public static int _POSIX2_BC_DIM_MAX() {
        return _POSIX2_BC_DIM_MAX;
    }
    private static final int _POSIX2_BC_SCALE_MAX = (int)99L;
    /**
     * {@snippet lang=c :
     * #define _POSIX2_BC_SCALE_MAX 99
     * }
     */
    public static int _POSIX2_BC_SCALE_MAX() {
        return _POSIX2_BC_SCALE_MAX;
    }
    private static final int _POSIX2_BC_STRING_MAX = (int)1000L;
    /**
     * {@snippet lang=c :
     * #define _POSIX2_BC_STRING_MAX 1000
     * }
     */
    public static int _POSIX2_BC_STRING_MAX() {
        return _POSIX2_BC_STRING_MAX;
    }
    private static final int _POSIX2_COLL_WEIGHTS_MAX = (int)2L;
    /**
     * {@snippet lang=c :
     * #define _POSIX2_COLL_WEIGHTS_MAX 2
     * }
     */
    public static int _POSIX2_COLL_WEIGHTS_MAX() {
        return _POSIX2_COLL_WEIGHTS_MAX;
    }
    private static final int _POSIX2_EXPR_NEST_MAX = (int)32L;
    /**
     * {@snippet lang=c :
     * #define _POSIX2_EXPR_NEST_MAX 32
     * }
     */
    public static int _POSIX2_EXPR_NEST_MAX() {
        return _POSIX2_EXPR_NEST_MAX;
    }
    private static final int _POSIX2_LINE_MAX = (int)2048L;
    /**
     * {@snippet lang=c :
     * #define _POSIX2_LINE_MAX 2048
     * }
     */
    public static int _POSIX2_LINE_MAX() {
        return _POSIX2_LINE_MAX;
    }
    private static final int _POSIX2_RE_DUP_MAX = (int)255L;
    /**
     * {@snippet lang=c :
     * #define _POSIX2_RE_DUP_MAX 255
     * }
     */
    public static int _POSIX2_RE_DUP_MAX() {
        return _POSIX2_RE_DUP_MAX;
    }
    private static final int _POSIX2_CHARCLASS_NAME_MAX = (int)14L;
    /**
     * {@snippet lang=c :
     * #define _POSIX2_CHARCLASS_NAME_MAX 14
     * }
     */
    public static int _POSIX2_CHARCLASS_NAME_MAX() {
        return _POSIX2_CHARCLASS_NAME_MAX;
    }
    private static final int COLL_WEIGHTS_MAX = (int)255L;
    /**
     * {@snippet lang=c :
     * #define COLL_WEIGHTS_MAX 255
     * }
     */
    public static int COLL_WEIGHTS_MAX() {
        return COLL_WEIGHTS_MAX;
    }
    private static final int CHARCLASS_NAME_MAX = (int)2048L;
    /**
     * {@snippet lang=c :
     * #define CHARCLASS_NAME_MAX 2048
     * }
     */
    public static int CHARCLASS_NAME_MAX() {
        return CHARCLASS_NAME_MAX;
    }
    private static final int __GMP_LIBGMP_DLL = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __GMP_LIBGMP_DLL 0
     * }
     */
    public static int __GMP_LIBGMP_DLL() {
        return __GMP_LIBGMP_DLL;
    }
    private static final int __GMP_MP_SIZE_T_INT = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __GMP_MP_SIZE_T_INT 0
     * }
     */
    public static int __GMP_MP_SIZE_T_INT() {
        return __GMP_MP_SIZE_T_INT;
    }
    private static final int __GMP_INLINE_PROTOTYPES = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __GMP_INLINE_PROTOTYPES 1
     * }
     */
    public static int __GMP_INLINE_PROTOTYPES() {
        return __GMP_INLINE_PROTOTYPES;
    }
    private static final int __GNU_MP_VERSION = (int)6L;
    /**
     * {@snippet lang=c :
     * #define __GNU_MP_VERSION 6
     * }
     */
    public static int __GNU_MP_VERSION() {
        return __GNU_MP_VERSION;
    }
    private static final int __GNU_MP_VERSION_MINOR = (int)3L;
    /**
     * {@snippet lang=c :
     * #define __GNU_MP_VERSION_MINOR 3
     * }
     */
    public static int __GNU_MP_VERSION_MINOR() {
        return __GNU_MP_VERSION_MINOR;
    }
    private static final int __GNU_MP_VERSION_PATCHLEVEL = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __GNU_MP_VERSION_PATCHLEVEL 0
     * }
     */
    public static int __GNU_MP_VERSION_PATCHLEVEL() {
        return __GNU_MP_VERSION_PATCHLEVEL;
    }
    /**
     * {@snippet lang=c :
     * typedef long ptrdiff_t
     * }
     */
    public static final OfLong ptrdiff_t = gmp_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long size_t
     * }
     */
    public static final OfLong size_t = gmp_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef int wchar_t
     * }
     */
    public static final OfInt wchar_t = gmp_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned long mp_limb_t
     * }
     */
    public static final OfLong mp_limb_t = gmp_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef long mp_limb_signed_t
     * }
     */
    public static final OfLong mp_limb_signed_t = gmp_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long mp_bitcnt_t
     * }
     */
    public static final OfLong mp_bitcnt_t = gmp_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef mp_limb_t *mp_ptr
     * }
     */
    public static final AddressLayout mp_ptr = gmp_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef const mp_limb_t *mp_srcptr
     * }
     */
    public static final AddressLayout mp_srcptr = gmp_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef long mp_size_t
     * }
     */
    public static final OfLong mp_size_t = gmp_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef long mp_exp_t
     * }
     */
    public static final OfLong mp_exp_t = gmp_h.C_LONG;
    private static final int GMP_RAND_ALG_DEFAULT = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GMP_RAND_ALG_DEFAULT = 0
     * }
     */
    public static int GMP_RAND_ALG_DEFAULT() {
        return GMP_RAND_ALG_DEFAULT;
    }
    private static final int GMP_RAND_ALG_LC = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GMP_RAND_ALG_LC = 0
     * }
     */
    public static int GMP_RAND_ALG_LC() {
        return GMP_RAND_ALG_LC;
    }
    /**
     * {@snippet lang=c :
     * typedef const __mpz_struct *mpz_srcptr
     * }
     */
    public static final AddressLayout mpz_srcptr = gmp_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef __mpz_struct *mpz_ptr
     * }
     */
    public static final AddressLayout mpz_ptr = gmp_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef const __mpf_struct *mpf_srcptr
     * }
     */
    public static final AddressLayout mpf_srcptr = gmp_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef __mpf_struct *mpf_ptr
     * }
     */
    public static final AddressLayout mpf_ptr = gmp_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef const __mpq_struct *mpq_srcptr
     * }
     */
    public static final AddressLayout mpq_srcptr = gmp_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef __mpq_struct *mpq_ptr
     * }
     */
    public static final AddressLayout mpq_ptr = gmp_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef __gmp_randstate_struct *gmp_randstate_ptr
     * }
     */
    public static final AddressLayout gmp_randstate_ptr = gmp_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef const __gmp_randstate_struct *gmp_randstate_srcptr
     * }
     */
    public static final AddressLayout gmp_randstate_srcptr = gmp_h.C_POINTER;

    private static class __gmp_set_memory_functions {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gmp_h.C_POINTER,
            gmp_h.C_POINTER,
            gmp_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__gmp_set_memory_functions");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void __gmp_set_memory_functions(void *(*)(size_t), void *(*)(void *, size_t, size_t), void (*)(void *, size_t))
     * }
     */
    public static FunctionDescriptor __gmp_set_memory_functions$descriptor() {
        return __gmp_set_memory_functions.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void __gmp_set_memory_functions(void *(*)(size_t), void *(*)(void *, size_t, size_t), void (*)(void *, size_t))
     * }
     */
    public static MethodHandle __gmp_set_memory_functions$handle() {
        return __gmp_set_memory_functions.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void __gmp_set_memory_functions(void *(*)(size_t), void *(*)(void *, size_t, size_t), void (*)(void *, size_t))
     * }
     */
    public static MemorySegment __gmp_set_memory_functions$address() {
        return __gmp_set_memory_functions.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void __gmp_set_memory_functions(void *(*)(size_t), void *(*)(void *, size_t, size_t), void (*)(void *, size_t))
     * }
     */
    public static void __gmp_set_memory_functions(MemorySegment x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = __gmp_set_memory_functions.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__gmp_set_memory_functions", x0, x1, x2);
            }
            mh$.invokeExact(x0, x1, x2);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __gmp_get_memory_functions {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gmp_h.C_POINTER,
            gmp_h.C_POINTER,
            gmp_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__gmp_get_memory_functions");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void __gmp_get_memory_functions(void *(**)(size_t), void *(**)(void *, size_t, size_t), void (**)(void *, size_t))
     * }
     */
    public static FunctionDescriptor __gmp_get_memory_functions$descriptor() {
        return __gmp_get_memory_functions.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void __gmp_get_memory_functions(void *(**)(size_t), void *(**)(void *, size_t, size_t), void (**)(void *, size_t))
     * }
     */
    public static MethodHandle __gmp_get_memory_functions$handle() {
        return __gmp_get_memory_functions.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void __gmp_get_memory_functions(void *(**)(size_t), void *(**)(void *, size_t, size_t), void (**)(void *, size_t))
     * }
     */
    public static MemorySegment __gmp_get_memory_functions$address() {
        return __gmp_get_memory_functions.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void __gmp_get_memory_functions(void *(**)(size_t), void *(**)(void *, size_t, size_t), void (**)(void *, size_t))
     * }
     */
    public static void __gmp_get_memory_functions(MemorySegment x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = __gmp_get_memory_functions.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__gmp_get_memory_functions", x0, x1, x2);
            }
            mh$.invokeExact(x0, x1, x2);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __gmp_bits_per_limb$constants {
        public static final OfInt LAYOUT = gmp_h.C_INT;
        public static final MemorySegment SEGMENT = SYMBOL_LOOKUP.findOrThrow("__gmp_bits_per_limb").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const int __gmp_bits_per_limb
     * }
     */
    public static OfInt __gmp_bits_per_limb$layout() {
        return __gmp_bits_per_limb$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern const int __gmp_bits_per_limb
     * }
     */
    public static MemorySegment __gmp_bits_per_limb$segment() {
        return __gmp_bits_per_limb$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const int __gmp_bits_per_limb
     * }
     */
    public static int __gmp_bits_per_limb() {
        return __gmp_bits_per_limb$constants.SEGMENT.get(__gmp_bits_per_limb$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const int __gmp_bits_per_limb
     * }
     */
    public static void __gmp_bits_per_limb(int varValue) {
        __gmp_bits_per_limb$constants.SEGMENT.set(__gmp_bits_per_limb$constants.LAYOUT, 0L, varValue);
    }

    private static class __gmp_errno$constants {
        public static final OfInt LAYOUT = gmp_h.C_INT;
        public static final MemorySegment SEGMENT = SYMBOL_LOOKUP.findOrThrow("__gmp_errno").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern int __gmp_errno
     * }
     */
    public static OfInt __gmp_errno$layout() {
        return __gmp_errno$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern int __gmp_errno
     * }
     */
    public static MemorySegment __gmp_errno$segment() {
        return __gmp_errno$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern int __gmp_errno
     * }
     */
    public static int __gmp_errno() {
        return __gmp_errno$constants.SEGMENT.get(__gmp_errno$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern int __gmp_errno
     * }
     */
    public static void __gmp_errno(int varValue) {
        __gmp_errno$constants.SEGMENT.set(__gmp_errno$constants.LAYOUT, 0L, varValue);
    }

    private static class __gmp_version$constants {
        public static final AddressLayout LAYOUT = gmp_h.C_POINTER;
        public static final MemorySegment SEGMENT = SYMBOL_LOOKUP.findOrThrow("__gmp_version").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const char *const __gmp_version
     * }
     */
    public static AddressLayout __gmp_version$layout() {
        return __gmp_version$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern const char *const __gmp_version
     * }
     */
    public static MemorySegment __gmp_version$segment() {
        return __gmp_version$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const char *const __gmp_version
     * }
     */
    public static MemorySegment __gmp_version() {
        return __gmp_version$constants.SEGMENT.get(__gmp_version$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const char *const __gmp_version
     * }
     */
    public static void __gmp_version(MemorySegment varValue) {
        __gmp_version$constants.SEGMENT.set(__gmp_version$constants.LAYOUT, 0L, varValue);
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * void __gmp_randinit(gmp_randstate_ptr, gmp_randalg_t, ...)
     * }
     */
    public static class __gmp_randinit {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.ofVoid(
                gmp_h.C_POINTER,
                gmp_h.C_INT
            );
        private static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__gmp_randinit");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private __gmp_randinit(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * void __gmp_randinit(gmp_randstate_ptr, gmp_randalg_t, ...)
         * }
         */
        public static __gmp_randinit makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new __gmp_randinit(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public void apply(MemorySegment x0, int x1, Object... x2) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("__gmp_randinit", x0, x1, x2);
                }
                 spreader.invokeExact(x0, x1, x2);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static class __gmp_randinit_default {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gmp_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__gmp_randinit_default");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void __gmp_randinit_default(gmp_randstate_ptr)
     * }
     */
    public static FunctionDescriptor __gmp_randinit_default$descriptor() {
        return __gmp_randinit_default.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void __gmp_randinit_default(gmp_randstate_ptr)
     * }
     */
    public static MethodHandle __gmp_randinit_default$handle() {
        return __gmp_randinit_default.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void __gmp_randinit_default(gmp_randstate_ptr)
     * }
     */
    public static MemorySegment __gmp_randinit_default$address() {
        return __gmp_randinit_default.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void __gmp_randinit_default(gmp_randstate_ptr)
     * }
     */
    public static void __gmp_randinit_default(MemorySegment x0) {
        var mh$ = __gmp_randinit_default.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__gmp_randinit_default", x0);
            }
            mh$.invokeExact(x0);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __gmp_randinit_lc_2exp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gmp_h.C_POINTER,
            gmp_h.C_POINTER,
            gmp_h.C_LONG,
            gmp_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__gmp_randinit_lc_2exp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void __gmp_randinit_lc_2exp(gmp_randstate_ptr, mpz_srcptr, unsigned long, mp_bitcnt_t)
     * }
     */
    public static FunctionDescriptor __gmp_randinit_lc_2exp$descriptor() {
        return __gmp_randinit_lc_2exp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void __gmp_randinit_lc_2exp(gmp_randstate_ptr, mpz_srcptr, unsigned long, mp_bitcnt_t)
     * }
     */
    public static MethodHandle __gmp_randinit_lc_2exp$handle() {
        return __gmp_randinit_lc_2exp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void __gmp_randinit_lc_2exp(gmp_randstate_ptr, mpz_srcptr, unsigned long, mp_bitcnt_t)
     * }
     */
    public static MemorySegment __gmp_randinit_lc_2exp$address() {
        return __gmp_randinit_lc_2exp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void __gmp_randinit_lc_2exp(gmp_randstate_ptr, mpz_srcptr, unsigned long, mp_bitcnt_t)
     * }
     */
    public static void __gmp_randinit_lc_2exp(MemorySegment x0, MemorySegment x1, long x2, long x3) {
        var mh$ = __gmp_randinit_lc_2exp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__gmp_randinit_lc_2exp", x0, x1, x2, x3);
            }
            mh$.invokeExact(x0, x1, x2, x3);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __gmp_randinit_lc_2exp_size {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gmp_h.C_INT,
            gmp_h.C_POINTER,
            gmp_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__gmp_randinit_lc_2exp_size");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int __gmp_randinit_lc_2exp_size(gmp_randstate_ptr, mp_bitcnt_t)
     * }
     */
    public static FunctionDescriptor __gmp_randinit_lc_2exp_size$descriptor() {
        return __gmp_randinit_lc_2exp_size.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int __gmp_randinit_lc_2exp_size(gmp_randstate_ptr, mp_bitcnt_t)
     * }
     */
    public static MethodHandle __gmp_randinit_lc_2exp_size$handle() {
        return __gmp_randinit_lc_2exp_size.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int __gmp_randinit_lc_2exp_size(gmp_randstate_ptr, mp_bitcnt_t)
     * }
     */
    public static MemorySegment __gmp_randinit_lc_2exp_size$address() {
        return __gmp_randinit_lc_2exp_size.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int __gmp_randinit_lc_2exp_size(gmp_randstate_ptr, mp_bitcnt_t)
     * }
     */
    public static int __gmp_randinit_lc_2exp_size(MemorySegment x0, long x1) {
        var mh$ = __gmp_randinit_lc_2exp_size.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__gmp_randinit_lc_2exp_size", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __gmp_randinit_mt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gmp_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__gmp_randinit_mt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void __gmp_randinit_mt(gmp_randstate_ptr)
     * }
     */
    public static FunctionDescriptor __gmp_randinit_mt$descriptor() {
        return __gmp_randinit_mt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void __gmp_randinit_mt(gmp_randstate_ptr)
     * }
     */
    public static MethodHandle __gmp_randinit_mt$handle() {
        return __gmp_randinit_mt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void __gmp_randinit_mt(gmp_randstate_ptr)
     * }
     */
    public static MemorySegment __gmp_randinit_mt$address() {
        return __gmp_randinit_mt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void __gmp_randinit_mt(gmp_randstate_ptr)
     * }
     */
    public static void __gmp_randinit_mt(MemorySegment x0) {
        var mh$ = __gmp_randinit_mt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__gmp_randinit_mt", x0);
            }
            mh$.invokeExact(x0);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __gmp_randinit_set {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gmp_h.C_POINTER,
            gmp_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__gmp_randinit_set");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void __gmp_randinit_set(gmp_randstate_ptr, gmp_randstate_srcptr)
     * }
     */
    public static FunctionDescriptor __gmp_randinit_set$descriptor() {
        return __gmp_randinit_set.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void __gmp_randinit_set(gmp_randstate_ptr, gmp_randstate_srcptr)
     * }
     */
    public static MethodHandle __gmp_randinit_set$handle() {
        return __gmp_randinit_set.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void __gmp_randinit_set(gmp_randstate_ptr, gmp_randstate_srcptr)
     * }
     */
    public static MemorySegment __gmp_randinit_set$address() {
        return __gmp_randinit_set.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void __gmp_randinit_set(gmp_randstate_ptr, gmp_randstate_srcptr)
     * }
     */
    public static void __gmp_randinit_set(MemorySegment x0, MemorySegment x1) {
        var mh$ = __gmp_randinit_set.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__gmp_randinit_set", x0, x1);
            }
            mh$.invokeExact(x0, x1);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __gmp_randseed {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gmp_h.C_POINTER,
            gmp_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__gmp_randseed");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void __gmp_randseed(gmp_randstate_ptr, mpz_srcptr)
     * }
     */
    public static FunctionDescriptor __gmp_randseed$descriptor() {
        return __gmp_randseed.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void __gmp_randseed(gmp_randstate_ptr, mpz_srcptr)
     * }
     */
    public static MethodHandle __gmp_randseed$handle() {
        return __gmp_randseed.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void __gmp_randseed(gmp_randstate_ptr, mpz_srcptr)
     * }
     */
    public static MemorySegment __gmp_randseed$address() {
        return __gmp_randseed.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void __gmp_randseed(gmp_randstate_ptr, mpz_srcptr)
     * }
     */
    public static void __gmp_randseed(MemorySegment x0, MemorySegment x1) {
        var mh$ = __gmp_randseed.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__gmp_randseed", x0, x1);
            }
            mh$.invokeExact(x0, x1);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __gmp_randseed_ui {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gmp_h.C_POINTER,
            gmp_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__gmp_randseed_ui");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void __gmp_randseed_ui(gmp_randstate_ptr, unsigned long)
     * }
     */
    public static FunctionDescriptor __gmp_randseed_ui$descriptor() {
        return __gmp_randseed_ui.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void __gmp_randseed_ui(gmp_randstate_ptr, unsigned long)
     * }
     */
    public static MethodHandle __gmp_randseed_ui$handle() {
        return __gmp_randseed_ui.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void __gmp_randseed_ui(gmp_randstate_ptr, unsigned long)
     * }
     */
    public static MemorySegment __gmp_randseed_ui$address() {
        return __gmp_randseed_ui.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void __gmp_randseed_ui(gmp_randstate_ptr, unsigned long)
     * }
     */
    public static void __gmp_randseed_ui(MemorySegment x0, long x1) {
        var mh$ = __gmp_randseed_ui.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__gmp_randseed_ui", x0, x1);
            }
            mh$.invokeExact(x0, x1);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __gmp_randclear {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gmp_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__gmp_randclear");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void __gmp_randclear(gmp_randstate_ptr)
     * }
     */
    public static FunctionDescriptor __gmp_randclear$descriptor() {
        return __gmp_randclear.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void __gmp_randclear(gmp_randstate_ptr)
     * }
     */
    public static MethodHandle __gmp_randclear$handle() {
        return __gmp_randclear.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void __gmp_randclear(gmp_randstate_ptr)
     * }
     */
    public static MemorySegment __gmp_randclear$address() {
        return __gmp_randclear.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void __gmp_randclear(gmp_randstate_ptr)
     * }
     */
    public static void __gmp_randclear(MemorySegment x0) {
        var mh$ = __gmp_randclear.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__gmp_randclear", x0);
            }
            mh$.invokeExact(x0);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __gmp_urandomb_ui {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gmp_h.C_LONG,
            gmp_h.C_POINTER,
            gmp_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__gmp_urandomb_ui");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned long __gmp_urandomb_ui(gmp_randstate_ptr, unsigned long)
     * }
     */
    public static FunctionDescriptor __gmp_urandomb_ui$descriptor() {
        return __gmp_urandomb_ui.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned long __gmp_urandomb_ui(gmp_randstate_ptr, unsigned long)
     * }
     */
    public static MethodHandle __gmp_urandomb_ui$handle() {
        return __gmp_urandomb_ui.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned long __gmp_urandomb_ui(gmp_randstate_ptr, unsigned long)
     * }
     */
    public static MemorySegment __gmp_urandomb_ui$address() {
        return __gmp_urandomb_ui.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned long __gmp_urandomb_ui(gmp_randstate_ptr, unsigned long)
     * }
     */
    public static long __gmp_urandomb_ui(MemorySegment x0, long x1) {
        var mh$ = __gmp_urandomb_ui.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__gmp_urandomb_ui", x0, x1);
            }
            return (long)mh$.invokeExact(x0, x1);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __gmp_urandomm_ui {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gmp_h.C_LONG,
            gmp_h.C_POINTER,
            gmp_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__gmp_urandomm_ui");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned long __gmp_urandomm_ui(gmp_randstate_ptr, unsigned long)
     * }
     */
    public static FunctionDescriptor __gmp_urandomm_ui$descriptor() {
        return __gmp_urandomm_ui.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned long __gmp_urandomm_ui(gmp_randstate_ptr, unsigned long)
     * }
     */
    public static MethodHandle __gmp_urandomm_ui$handle() {
        return __gmp_urandomm_ui.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned long __gmp_urandomm_ui(gmp_randstate_ptr, unsigned long)
     * }
     */
    public static MemorySegment __gmp_urandomm_ui$address() {
        return __gmp_urandomm_ui.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned long __gmp_urandomm_ui(gmp_randstate_ptr, unsigned long)
     * }
     */
    public static long __gmp_urandomm_ui(MemorySegment x0, long x1) {
        var mh$ = __gmp_urandomm_ui.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__gmp_urandomm_ui", x0, x1);
            }
            return (long)mh$.invokeExact(x0, x1);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * int __gmp_asprintf(char **, const char *, ...)
     * }
     */
    public static class __gmp_asprintf {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                gmp_h.C_INT,
                gmp_h.C_POINTER,
                gmp_h.C_POINTER
            );
        private static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__gmp_asprintf");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private __gmp_asprintf(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * int __gmp_asprintf(char **, const char *, ...)
         * }
         */
        public static __gmp_asprintf makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new __gmp_asprintf(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public int apply(MemorySegment x0, MemorySegment x1, Object... x2) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("__gmp_asprintf", x0, x1, x2);
                }
                return (int) spreader.invokeExact(x0, x1, x2);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * int __gmp_printf(const char *, ...)
     * }
     */
    public static class __gmp_printf {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                gmp_h.C_INT,
                gmp_h.C_POINTER
            );
        private static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__gmp_printf");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private __gmp_printf(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * int __gmp_printf(const char *, ...)
         * }
         */
        public static __gmp_printf makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new __gmp_printf(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public int apply(MemorySegment x0, Object... x1) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("__gmp_printf", x0, x1);
                }
                return (int) spreader.invokeExact(x0, x1);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * int __gmp_snprintf(char *, size_t, const char *, ...)
     * }
     */
    public static class __gmp_snprintf {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                gmp_h.C_INT,
                gmp_h.C_POINTER,
                gmp_h.C_LONG,
                gmp_h.C_POINTER
            );
        private static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__gmp_snprintf");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private __gmp_snprintf(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * int __gmp_snprintf(char *, size_t, const char *, ...)
         * }
         */
        public static __gmp_snprintf makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new __gmp_snprintf(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public int apply(MemorySegment x0, long x1, MemorySegment x2, Object... x3) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("__gmp_snprintf", x0, x1, x2, x3);
                }
                return (int) spreader.invokeExact(x0, x1, x2, x3);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * int __gmp_sprintf(char *, const char *, ...)
     * }
     */
    public static class __gmp_sprintf {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                gmp_h.C_INT,
                gmp_h.C_POINTER,
                gmp_h.C_POINTER
            );
        private static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__gmp_sprintf");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private __gmp_sprintf(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * int __gmp_sprintf(char *, const char *, ...)
         * }
         */
        public static __gmp_sprintf makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new __gmp_sprintf(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public int apply(MemorySegment x0, MemorySegment x1, Object... x2) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("__gmp_sprintf", x0, x1, x2);
                }
                return (int) spreader.invokeExact(x0, x1, x2);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * int __gmp_scanf(const char *, ...)
     * }
     */
    public static class __gmp_scanf {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                gmp_h.C_INT,
                gmp_h.C_POINTER
            );
        private static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__gmp_scanf");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private __gmp_scanf(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * int __gmp_scanf(const char *, ...)
         * }
         */
        public static __gmp_scanf makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new __gmp_scanf(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public int apply(MemorySegment x0, Object... x1) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("__gmp_scanf", x0, x1);
                }
                return (int) spreader.invokeExact(x0, x1);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * int __gmp_sscanf(const char *, const char *, ...)
     * }
     */
    public static class __gmp_sscanf {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                gmp_h.C_INT,
                gmp_h.C_POINTER,
                gmp_h.C_POINTER
            );
        private static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__gmp_sscanf");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private __gmp_sscanf(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * int __gmp_sscanf(const char *, const char *, ...)
         * }
         */
        public static __gmp_sscanf makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new __gmp_sscanf(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public int apply(MemorySegment x0, MemorySegment x1, Object... x2) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("__gmp_sscanf", x0, x1, x2);
                }
                return (int) spreader.invokeExact(x0, x1, x2);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static class __gmpz_realloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gmp_h.C_POINTER,
            gmp_h.C_POINTER,
            gmp_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__gmpz_realloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *__gmpz_realloc(mpz_ptr, mp_size_t)
     * }
     */
    public static FunctionDescriptor __gmpz_realloc$descriptor() {
        return __gmpz_realloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *__gmpz_realloc(mpz_ptr, mp_size_t)
     * }
     */
    public static MethodHandle __gmpz_realloc$handle() {
        return __gmpz_realloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *__gmpz_realloc(mpz_ptr, mp_size_t)
     * }
     */
    public static MemorySegment __gmpz_realloc$address() {
        return __gmpz_realloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *__gmpz_realloc(mpz_ptr, mp_size_t)
     * }
     */
    public static MemorySegment __gmpz_realloc(MemorySegment x0, long x1) {
        var mh$ = __gmpz_realloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__gmpz_realloc", x0, x1);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __gmpz_abs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gmp_h.C_POINTER,
            gmp_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__gmpz_abs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void __gmpz_abs(mpz_ptr, mpz_srcptr)
     * }
     */
    public static FunctionDescriptor __gmpz_abs$descriptor() {
        return __gmpz_abs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void __gmpz_abs(mpz_ptr, mpz_srcptr)
     * }
     */
    public static MethodHandle __gmpz_abs$handle() {
        return __gmpz_abs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void __gmpz_abs(mpz_ptr, mpz_srcptr)
     * }
     */
    public static MemorySegment __gmpz_abs$address() {
        return __gmpz_abs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void __gmpz_abs(mpz_ptr, mpz_srcptr)
     * }
     */
    public static void __gmpz_abs(MemorySegment x0, MemorySegment x1) {
        var mh$ = __gmpz_abs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__gmpz_abs", x0, x1);
            }
            mh$.invokeExact(x0, x1);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __gmpz_add {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gmp_h.C_POINTER,
            gmp_h.C_POINTER,
            gmp_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__gmpz_add");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void __gmpz_add(mpz_ptr, mpz_srcptr, mpz_srcptr)
     * }
     */
    public static FunctionDescriptor __gmpz_add$descriptor() {
        return __gmpz_add.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void __gmpz_add(mpz_ptr, mpz_srcptr, mpz_srcptr)
     * }
     */
    public static MethodHandle __gmpz_add$handle() {
        return __gmpz_add.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void __gmpz_add(mpz_ptr, mpz_srcptr, mpz_srcptr)
     * }
     */
    public static MemorySegment __gmpz_add$address() {
        return __gmpz_add.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void __gmpz_add(mpz_ptr, mpz_srcptr, mpz_srcptr)
     * }
     */
    public static void __gmpz_add(MemorySegment x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = __gmpz_add.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__gmpz_add", x0, x1, x2);
            }
            mh$.invokeExact(x0, x1, x2);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __gmpz_add_ui {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gmp_h.C_POINTER,
            gmp_h.C_POINTER,
            gmp_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__gmpz_add_ui");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void __gmpz_add_ui(mpz_ptr, mpz_srcptr, unsigned long)
     * }
     */
    public static FunctionDescriptor __gmpz_add_ui$descriptor() {
        return __gmpz_add_ui.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void __gmpz_add_ui(mpz_ptr, mpz_srcptr, unsigned long)
     * }
     */
    public static MethodHandle __gmpz_add_ui$handle() {
        return __gmpz_add_ui.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void __gmpz_add_ui(mpz_ptr, mpz_srcptr, unsigned long)
     * }
     */
    public static MemorySegment __gmpz_add_ui$address() {
        return __gmpz_add_ui.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void __gmpz_add_ui(mpz_ptr, mpz_srcptr, unsigned long)
     * }
     */
    public static void __gmpz_add_ui(MemorySegment x0, MemorySegment x1, long x2) {
        var mh$ = __gmpz_add_ui.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__gmpz_add_ui", x0, x1, x2);
            }
            mh$.invokeExact(x0, x1, x2);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __gmpz_addmul {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gmp_h.C_POINTER,
            gmp_h.C_POINTER,
            gmp_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__gmpz_addmul");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void __gmpz_addmul(mpz_ptr, mpz_srcptr, mpz_srcptr)
     * }
     */
    public static FunctionDescriptor __gmpz_addmul$descriptor() {
        return __gmpz_addmul.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void __gmpz_addmul(mpz_ptr, mpz_srcptr, mpz_srcptr)
     * }
     */
    public static MethodHandle __gmpz_addmul$handle() {
        return __gmpz_addmul.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void __gmpz_addmul(mpz_ptr, mpz_srcptr, mpz_srcptr)
     * }
     */
    public static MemorySegment __gmpz_addmul$address() {
        return __gmpz_addmul.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void __gmpz_addmul(mpz_ptr, mpz_srcptr, mpz_srcptr)
     * }
     */
    public static void __gmpz_addmul(MemorySegment x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = __gmpz_addmul.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__gmpz_addmul", x0, x1, x2);
            }
            mh$.invokeExact(x0, x1, x2);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __gmpz_addmul_ui {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gmp_h.C_POINTER,
            gmp_h.C_POINTER,
            gmp_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__gmpz_addmul_ui");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void __gmpz_addmul_ui(mpz_ptr, mpz_srcptr, unsigned long)
     * }
     */
    public static FunctionDescriptor __gmpz_addmul_ui$descriptor() {
        return __gmpz_addmul_ui.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void __gmpz_addmul_ui(mpz_ptr, mpz_srcptr, unsigned long)
     * }
     */
    public static MethodHandle __gmpz_addmul_ui$handle() {
        return __gmpz_addmul_ui.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void __gmpz_addmul_ui(mpz_ptr, mpz_srcptr, unsigned long)
     * }
     */
    public static MemorySegment __gmpz_addmul_ui$address() {
        return __gmpz_addmul_ui.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void __gmpz_addmul_ui(mpz_ptr, mpz_srcptr, unsigned long)
     * }
     */
    public static void __gmpz_addmul_ui(MemorySegment x0, MemorySegment x1, long x2) {
        var mh$ = __gmpz_addmul_ui.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__gmpz_addmul_ui", x0, x1, x2);
            }
            mh$.invokeExact(x0, x1, x2);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __gmpz_and {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gmp_h.C_POINTER,
            gmp_h.C_POINTER,
            gmp_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__gmpz_and");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void __gmpz_and(mpz_ptr, mpz_srcptr, mpz_srcptr)
     * }
     */
    public static FunctionDescriptor __gmpz_and$descriptor() {
        return __gmpz_and.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void __gmpz_and(mpz_ptr, mpz_srcptr, mpz_srcptr)
     * }
     */
    public static MethodHandle __gmpz_and$handle() {
        return __gmpz_and.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void __gmpz_and(mpz_ptr, mpz_srcptr, mpz_srcptr)
     * }
     */
    public static MemorySegment __gmpz_and$address() {
        return __gmpz_and.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void __gmpz_and(mpz_ptr, mpz_srcptr, mpz_srcptr)
     * }
     */
    public static void __gmpz_and(MemorySegment x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = __gmpz_and.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__gmpz_and", x0, x1, x2);
            }
            mh$.invokeExact(x0, x1, x2);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __gmpz_array_init {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gmp_h.C_POINTER,
            gmp_h.C_LONG,
            gmp_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__gmpz_array_init");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void __gmpz_array_init(mpz_ptr, mp_size_t, mp_size_t)
     * }
     */
    public static FunctionDescriptor __gmpz_array_init$descriptor() {
        return __gmpz_array_init.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void __gmpz_array_init(mpz_ptr, mp_size_t, mp_size_t)
     * }
     */
    public static MethodHandle __gmpz_array_init$handle() {
        return __gmpz_array_init.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void __gmpz_array_init(mpz_ptr, mp_size_t, mp_size_t)
     * }
     */
    public static MemorySegment __gmpz_array_init$address() {
        return __gmpz_array_init.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void __gmpz_array_init(mpz_ptr, mp_size_t, mp_size_t)
     * }
     */
    public static void __gmpz_array_init(MemorySegment x0, long x1, long x2) {
        var mh$ = __gmpz_array_init.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__gmpz_array_init", x0, x1, x2);
            }
            mh$.invokeExact(x0, x1, x2);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __gmpz_bin_ui {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gmp_h.C_POINTER,
            gmp_h.C_POINTER,
            gmp_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__gmpz_bin_ui");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void __gmpz_bin_ui(mpz_ptr, mpz_srcptr, unsigned long)
     * }
     */
    public static FunctionDescriptor __gmpz_bin_ui$descriptor() {
        return __gmpz_bin_ui.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void __gmpz_bin_ui(mpz_ptr, mpz_srcptr, unsigned long)
     * }
     */
    public static MethodHandle __gmpz_bin_ui$handle() {
        return __gmpz_bin_ui.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void __gmpz_bin_ui(mpz_ptr, mpz_srcptr, unsigned long)
     * }
     */
    public static MemorySegment __gmpz_bin_ui$address() {
        return __gmpz_bin_ui.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void __gmpz_bin_ui(mpz_ptr, mpz_srcptr, unsigned long)
     * }
     */
    public static void __gmpz_bin_ui(MemorySegment x0, MemorySegment x1, long x2) {
        var mh$ = __gmpz_bin_ui.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__gmpz_bin_ui", x0, x1, x2);
            }
            mh$.invokeExact(x0, x1, x2);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __gmpz_bin_uiui {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gmp_h.C_POINTER,
            gmp_h.C_LONG,
            gmp_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__gmpz_bin_uiui");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void __gmpz_bin_uiui(mpz_ptr, unsigned long, unsigned long)
     * }
     */
    public static FunctionDescriptor __gmpz_bin_uiui$descriptor() {
        return __gmpz_bin_uiui.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void __gmpz_bin_uiui(mpz_ptr, unsigned long, unsigned long)
     * }
     */
    public static MethodHandle __gmpz_bin_uiui$handle() {
        return __gmpz_bin_uiui.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void __gmpz_bin_uiui(mpz_ptr, unsigned long, unsigned long)
     * }
     */
    public static MemorySegment __gmpz_bin_uiui$address() {
        return __gmpz_bin_uiui.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void __gmpz_bin_uiui(mpz_ptr, unsigned long, unsigned long)
     * }
     */
    public static void __gmpz_bin_uiui(MemorySegment x0, long x1, long x2) {
        var mh$ = __gmpz_bin_uiui.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__gmpz_bin_uiui", x0, x1, x2);
            }
            mh$.invokeExact(x0, x1, x2);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __gmpz_cdiv_q {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gmp_h.C_POINTER,
            gmp_h.C_POINTER,
            gmp_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__gmpz_cdiv_q");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void __gmpz_cdiv_q(mpz_ptr, mpz_srcptr, mpz_srcptr)
     * }
     */
    public static FunctionDescriptor __gmpz_cdiv_q$descriptor() {
        return __gmpz_cdiv_q.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void __gmpz_cdiv_q(mpz_ptr, mpz_srcptr, mpz_srcptr)
     * }
     */
    public static MethodHandle __gmpz_cdiv_q$handle() {
        return __gmpz_cdiv_q.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void __gmpz_cdiv_q(mpz_ptr, mpz_srcptr, mpz_srcptr)
     * }
     */
    public static MemorySegment __gmpz_cdiv_q$address() {
        return __gmpz_cdiv_q.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void __gmpz_cdiv_q(mpz_ptr, mpz_srcptr, mpz_srcptr)
     * }
     */
    public static void __gmpz_cdiv_q(MemorySegment x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = __gmpz_cdiv_q.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__gmpz_cdiv_q", x0, x1, x2);
            }
            mh$.invokeExact(x0, x1, x2);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __gmpz_cdiv_q_2exp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gmp_h.C_POINTER,
            gmp_h.C_POINTER,
            gmp_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__gmpz_cdiv_q_2exp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void __gmpz_cdiv_q_2exp(mpz_ptr, mpz_srcptr, mp_bitcnt_t)
     * }
     */
    public static FunctionDescriptor __gmpz_cdiv_q_2exp$descriptor() {
        return __gmpz_cdiv_q_2exp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void __gmpz_cdiv_q_2exp(mpz_ptr, mpz_srcptr, mp_bitcnt_t)
     * }
     */
    public static MethodHandle __gmpz_cdiv_q_2exp$handle() {
        return __gmpz_cdiv_q_2exp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void __gmpz_cdiv_q_2exp(mpz_ptr, mpz_srcptr, mp_bitcnt_t)
     * }
     */
    public static MemorySegment __gmpz_cdiv_q_2exp$address() {
        return __gmpz_cdiv_q_2exp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void __gmpz_cdiv_q_2exp(mpz_ptr, mpz_srcptr, mp_bitcnt_t)
     * }
     */
    public static void __gmpz_cdiv_q_2exp(MemorySegment x0, MemorySegment x1, long x2) {
        var mh$ = __gmpz_cdiv_q_2exp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__gmpz_cdiv_q_2exp", x0, x1, x2);
            }
            mh$.invokeExact(x0, x1, x2);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __gmpz_cdiv_q_ui {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gmp_h.C_LONG,
            gmp_h.C_POINTER,
            gmp_h.C_POINTER,
            gmp_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__gmpz_cdiv_q_ui");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned long __gmpz_cdiv_q_ui(mpz_ptr, mpz_srcptr, unsigned long)
     * }
     */
    public static FunctionDescriptor __gmpz_cdiv_q_ui$descriptor() {
        return __gmpz_cdiv_q_ui.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned long __gmpz_cdiv_q_ui(mpz_ptr, mpz_srcptr, unsigned long)
     * }
     */
    public static MethodHandle __gmpz_cdiv_q_ui$handle() {
        return __gmpz_cdiv_q_ui.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned long __gmpz_cdiv_q_ui(mpz_ptr, mpz_srcptr, unsigned long)
     * }
     */
    public static MemorySegment __gmpz_cdiv_q_ui$address() {
        return __gmpz_cdiv_q_ui.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned long __gmpz_cdiv_q_ui(mpz_ptr, mpz_srcptr, unsigned long)
     * }
     */
    public static long __gmpz_cdiv_q_ui(MemorySegment x0, MemorySegment x1, long x2) {
        var mh$ = __gmpz_cdiv_q_ui.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__gmpz_cdiv_q_ui", x0, x1, x2);
            }
            return (long)mh$.invokeExact(x0, x1, x2);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __gmpz_cdiv_qr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gmp_h.C_POINTER,
            gmp_h.C_POINTER,
            gmp_h.C_POINTER,
            gmp_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__gmpz_cdiv_qr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void __gmpz_cdiv_qr(mpz_ptr, mpz_ptr, mpz_srcptr, mpz_srcptr)
     * }
     */
    public static FunctionDescriptor __gmpz_cdiv_qr$descriptor() {
        return __gmpz_cdiv_qr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void __gmpz_cdiv_qr(mpz_ptr, mpz_ptr, mpz_srcptr, mpz_srcptr)
     * }
     */
    public static MethodHandle __gmpz_cdiv_qr$handle() {
        return __gmpz_cdiv_qr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void __gmpz_cdiv_qr(mpz_ptr, mpz_ptr, mpz_srcptr, mpz_srcptr)
     * }
     */
    public static MemorySegment __gmpz_cdiv_qr$address() {
        return __gmpz_cdiv_qr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void __gmpz_cdiv_qr(mpz_ptr, mpz_ptr, mpz_srcptr, mpz_srcptr)
     * }
     */
    public static void __gmpz_cdiv_qr(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = __gmpz_cdiv_qr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__gmpz_cdiv_qr", x0, x1, x2, x3);
            }
            mh$.invokeExact(x0, x1, x2, x3);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __gmpz_cdiv_qr_ui {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gmp_h.C_LONG,
            gmp_h.C_POINTER,
            gmp_h.C_POINTER,
            gmp_h.C_POINTER,
            gmp_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__gmpz_cdiv_qr_ui");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned long __gmpz_cdiv_qr_ui(mpz_ptr, mpz_ptr, mpz_srcptr, unsigned long)
     * }
     */
    public static FunctionDescriptor __gmpz_cdiv_qr_ui$descriptor() {
        return __gmpz_cdiv_qr_ui.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned long __gmpz_cdiv_qr_ui(mpz_ptr, mpz_ptr, mpz_srcptr, unsigned long)
     * }
     */
    public static MethodHandle __gmpz_cdiv_qr_ui$handle() {
        return __gmpz_cdiv_qr_ui.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned long __gmpz_cdiv_qr_ui(mpz_ptr, mpz_ptr, mpz_srcptr, unsigned long)
     * }
     */
    public static MemorySegment __gmpz_cdiv_qr_ui$address() {
        return __gmpz_cdiv_qr_ui.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned long __gmpz_cdiv_qr_ui(mpz_ptr, mpz_ptr, mpz_srcptr, unsigned long)
     * }
     */
    public static long __gmpz_cdiv_qr_ui(MemorySegment x0, MemorySegment x1, MemorySegment x2, long x3) {
        var mh$ = __gmpz_cdiv_qr_ui.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__gmpz_cdiv_qr_ui", x0, x1, x2, x3);
            }
            return (long)mh$.invokeExact(x0, x1, x2, x3);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __gmpz_cdiv_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gmp_h.C_POINTER,
            gmp_h.C_POINTER,
            gmp_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__gmpz_cdiv_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void __gmpz_cdiv_r(mpz_ptr, mpz_srcptr, mpz_srcptr)
     * }
     */
    public static FunctionDescriptor __gmpz_cdiv_r$descriptor() {
        return __gmpz_cdiv_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void __gmpz_cdiv_r(mpz_ptr, mpz_srcptr, mpz_srcptr)
     * }
     */
    public static MethodHandle __gmpz_cdiv_r$handle() {
        return __gmpz_cdiv_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void __gmpz_cdiv_r(mpz_ptr, mpz_srcptr, mpz_srcptr)
     * }
     */
    public static MemorySegment __gmpz_cdiv_r$address() {
        return __gmpz_cdiv_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void __gmpz_cdiv_r(mpz_ptr, mpz_srcptr, mpz_srcptr)
     * }
     */
    public static void __gmpz_cdiv_r(MemorySegment x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = __gmpz_cdiv_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__gmpz_cdiv_r", x0, x1, x2);
            }
            mh$.invokeExact(x0, x1, x2);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __gmpz_cdiv_r_2exp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gmp_h.C_POINTER,
            gmp_h.C_POINTER,
            gmp_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__gmpz_cdiv_r_2exp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void __gmpz_cdiv_r_2exp(mpz_ptr, mpz_srcptr, mp_bitcnt_t)
     * }
     */
    public static FunctionDescriptor __gmpz_cdiv_r_2exp$descriptor() {
        return __gmpz_cdiv_r_2exp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void __gmpz_cdiv_r_2exp(mpz_ptr, mpz_srcptr, mp_bitcnt_t)
     * }
     */
    public static MethodHandle __gmpz_cdiv_r_2exp$handle() {
        return __gmpz_cdiv_r_2exp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void __gmpz_cdiv_r_2exp(mpz_ptr, mpz_srcptr, mp_bitcnt_t)
     * }
     */
    public static MemorySegment __gmpz_cdiv_r_2exp$address() {
        return __gmpz_cdiv_r_2exp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void __gmpz_cdiv_r_2exp(mpz_ptr, mpz_srcptr, mp_bitcnt_t)
     * }
     */
    public static void __gmpz_cdiv_r_2exp(MemorySegment x0, MemorySegment x1, long x2) {
        var mh$ = __gmpz_cdiv_r_2exp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__gmpz_cdiv_r_2exp", x0, x1, x2);
            }
            mh$.invokeExact(x0, x1, x2);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __gmpz_cdiv_r_ui {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gmp_h.C_LONG,
            gmp_h.C_POINTER,
            gmp_h.C_POINTER,
            gmp_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__gmpz_cdiv_r_ui");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned long __gmpz_cdiv_r_ui(mpz_ptr, mpz_srcptr, unsigned long)
     * }
     */
    public static FunctionDescriptor __gmpz_cdiv_r_ui$descriptor() {
        return __gmpz_cdiv_r_ui.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned long __gmpz_cdiv_r_ui(mpz_ptr, mpz_srcptr, unsigned long)
     * }
     */
    public static MethodHandle __gmpz_cdiv_r_ui$handle() {
        return __gmpz_cdiv_r_ui.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned long __gmpz_cdiv_r_ui(mpz_ptr, mpz_srcptr, unsigned long)
     * }
     */
    public static MemorySegment __gmpz_cdiv_r_ui$address() {
        return __gmpz_cdiv_r_ui.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned long __gmpz_cdiv_r_ui(mpz_ptr, mpz_srcptr, unsigned long)
     * }
     */
    public static long __gmpz_cdiv_r_ui(MemorySegment x0, MemorySegment x1, long x2) {
        var mh$ = __gmpz_cdiv_r_ui.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__gmpz_cdiv_r_ui", x0, x1, x2);
            }
            return (long)mh$.invokeExact(x0, x1, x2);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __gmpz_cdiv_ui {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gmp_h.C_LONG,
            gmp_h.C_POINTER,
            gmp_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__gmpz_cdiv_ui");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned long __gmpz_cdiv_ui(mpz_srcptr, unsigned long)
     * }
     */
    public static FunctionDescriptor __gmpz_cdiv_ui$descriptor() {
        return __gmpz_cdiv_ui.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned long __gmpz_cdiv_ui(mpz_srcptr, unsigned long)
     * }
     */
    public static MethodHandle __gmpz_cdiv_ui$handle() {
        return __gmpz_cdiv_ui.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned long __gmpz_cdiv_ui(mpz_srcptr, unsigned long)
     * }
     */
    public static MemorySegment __gmpz_cdiv_ui$address() {
        return __gmpz_cdiv_ui.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned long __gmpz_cdiv_ui(mpz_srcptr, unsigned long)
     * }
     */
    public static long __gmpz_cdiv_ui(MemorySegment x0, long x1) {
        var mh$ = __gmpz_cdiv_ui.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__gmpz_cdiv_ui", x0, x1);
            }
            return (long)mh$.invokeExact(x0, x1);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __gmpz_clear {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gmp_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__gmpz_clear");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void __gmpz_clear(mpz_ptr)
     * }
     */
    public static FunctionDescriptor __gmpz_clear$descriptor() {
        return __gmpz_clear.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void __gmpz_clear(mpz_ptr)
     * }
     */
    public static MethodHandle __gmpz_clear$handle() {
        return __gmpz_clear.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void __gmpz_clear(mpz_ptr)
     * }
     */
    public static MemorySegment __gmpz_clear$address() {
        return __gmpz_clear.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void __gmpz_clear(mpz_ptr)
     * }
     */
    public static void __gmpz_clear(MemorySegment x0) {
        var mh$ = __gmpz_clear.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__gmpz_clear", x0);
            }
            mh$.invokeExact(x0);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * void __gmpz_clears(mpz_ptr, ...)
     * }
     */
    public static class __gmpz_clears {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.ofVoid(
                gmp_h.C_POINTER
            );
        private static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__gmpz_clears");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private __gmpz_clears(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * void __gmpz_clears(mpz_ptr, ...)
         * }
         */
        public static __gmpz_clears makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new __gmpz_clears(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public void apply(MemorySegment x0, Object... x1) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("__gmpz_clears", x0, x1);
                }
                 spreader.invokeExact(x0, x1);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static class __gmpz_clrbit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gmp_h.C_POINTER,
            gmp_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__gmpz_clrbit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void __gmpz_clrbit(mpz_ptr, mp_bitcnt_t)
     * }
     */
    public static FunctionDescriptor __gmpz_clrbit$descriptor() {
        return __gmpz_clrbit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void __gmpz_clrbit(mpz_ptr, mp_bitcnt_t)
     * }
     */
    public static MethodHandle __gmpz_clrbit$handle() {
        return __gmpz_clrbit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void __gmpz_clrbit(mpz_ptr, mp_bitcnt_t)
     * }
     */
    public static MemorySegment __gmpz_clrbit$address() {
        return __gmpz_clrbit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void __gmpz_clrbit(mpz_ptr, mp_bitcnt_t)
     * }
     */
    public static void __gmpz_clrbit(MemorySegment x0, long x1) {
        var mh$ = __gmpz_clrbit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__gmpz_clrbit", x0, x1);
            }
            mh$.invokeExact(x0, x1);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __gmpz_cmp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gmp_h.C_INT,
            gmp_h.C_POINTER,
            gmp_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__gmpz_cmp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int __gmpz_cmp(mpz_srcptr, mpz_srcptr)
     * }
     */
    public static FunctionDescriptor __gmpz_cmp$descriptor() {
        return __gmpz_cmp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int __gmpz_cmp(mpz_srcptr, mpz_srcptr)
     * }
     */
    public static MethodHandle __gmpz_cmp$handle() {
        return __gmpz_cmp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int __gmpz_cmp(mpz_srcptr, mpz_srcptr)
     * }
     */
    public static MemorySegment __gmpz_cmp$address() {
        return __gmpz_cmp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int __gmpz_cmp(mpz_srcptr, mpz_srcptr)
     * }
     */
    public static int __gmpz_cmp(MemorySegment x0, MemorySegment x1) {
        var mh$ = __gmpz_cmp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__gmpz_cmp", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __gmpz_cmp_d {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gmp_h.C_INT,
            gmp_h.C_POINTER,
            gmp_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__gmpz_cmp_d");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int __gmpz_cmp_d(mpz_srcptr, double)
     * }
     */
    public static FunctionDescriptor __gmpz_cmp_d$descriptor() {
        return __gmpz_cmp_d.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int __gmpz_cmp_d(mpz_srcptr, double)
     * }
     */
    public static MethodHandle __gmpz_cmp_d$handle() {
        return __gmpz_cmp_d.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int __gmpz_cmp_d(mpz_srcptr, double)
     * }
     */
    public static MemorySegment __gmpz_cmp_d$address() {
        return __gmpz_cmp_d.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int __gmpz_cmp_d(mpz_srcptr, double)
     * }
     */
    public static int __gmpz_cmp_d(MemorySegment x0, double x1) {
        var mh$ = __gmpz_cmp_d.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__gmpz_cmp_d", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __gmpz_cmp_si {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gmp_h.C_INT,
            gmp_h.C_POINTER,
            gmp_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__gmpz_cmp_si");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int __gmpz_cmp_si(mpz_srcptr, long)
     * }
     */
    public static FunctionDescriptor __gmpz_cmp_si$descriptor() {
        return __gmpz_cmp_si.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int __gmpz_cmp_si(mpz_srcptr, long)
     * }
     */
    public static MethodHandle __gmpz_cmp_si$handle() {
        return __gmpz_cmp_si.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int __gmpz_cmp_si(mpz_srcptr, long)
     * }
     */
    public static MemorySegment __gmpz_cmp_si$address() {
        return __gmpz_cmp_si.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int __gmpz_cmp_si(mpz_srcptr, long)
     * }
     */
    public static int __gmpz_cmp_si(MemorySegment x0, long x1) {
        var mh$ = __gmpz_cmp_si.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__gmpz_cmp_si", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __gmpz_cmp_ui {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gmp_h.C_INT,
            gmp_h.C_POINTER,
            gmp_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__gmpz_cmp_ui");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int __gmpz_cmp_ui(mpz_srcptr, unsigned long)
     * }
     */
    public static FunctionDescriptor __gmpz_cmp_ui$descriptor() {
        return __gmpz_cmp_ui.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int __gmpz_cmp_ui(mpz_srcptr, unsigned long)
     * }
     */
    public static MethodHandle __gmpz_cmp_ui$handle() {
        return __gmpz_cmp_ui.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int __gmpz_cmp_ui(mpz_srcptr, unsigned long)
     * }
     */
    public static MemorySegment __gmpz_cmp_ui$address() {
        return __gmpz_cmp_ui.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int __gmpz_cmp_ui(mpz_srcptr, unsigned long)
     * }
     */
    public static int __gmpz_cmp_ui(MemorySegment x0, long x1) {
        var mh$ = __gmpz_cmp_ui.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__gmpz_cmp_ui", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __gmpz_cmpabs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gmp_h.C_INT,
            gmp_h.C_POINTER,
            gmp_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__gmpz_cmpabs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int __gmpz_cmpabs(mpz_srcptr, mpz_srcptr)
     * }
     */
    public static FunctionDescriptor __gmpz_cmpabs$descriptor() {
        return __gmpz_cmpabs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int __gmpz_cmpabs(mpz_srcptr, mpz_srcptr)
     * }
     */
    public static MethodHandle __gmpz_cmpabs$handle() {
        return __gmpz_cmpabs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int __gmpz_cmpabs(mpz_srcptr, mpz_srcptr)
     * }
     */
    public static MemorySegment __gmpz_cmpabs$address() {
        return __gmpz_cmpabs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int __gmpz_cmpabs(mpz_srcptr, mpz_srcptr)
     * }
     */
    public static int __gmpz_cmpabs(MemorySegment x0, MemorySegment x1) {
        var mh$ = __gmpz_cmpabs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__gmpz_cmpabs", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __gmpz_cmpabs_d {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gmp_h.C_INT,
            gmp_h.C_POINTER,
            gmp_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__gmpz_cmpabs_d");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int __gmpz_cmpabs_d(mpz_srcptr, double)
     * }
     */
    public static FunctionDescriptor __gmpz_cmpabs_d$descriptor() {
        return __gmpz_cmpabs_d.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int __gmpz_cmpabs_d(mpz_srcptr, double)
     * }
     */
    public static MethodHandle __gmpz_cmpabs_d$handle() {
        return __gmpz_cmpabs_d.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int __gmpz_cmpabs_d(mpz_srcptr, double)
     * }
     */
    public static MemorySegment __gmpz_cmpabs_d$address() {
        return __gmpz_cmpabs_d.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int __gmpz_cmpabs_d(mpz_srcptr, double)
     * }
     */
    public static int __gmpz_cmpabs_d(MemorySegment x0, double x1) {
        var mh$ = __gmpz_cmpabs_d.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__gmpz_cmpabs_d", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __gmpz_cmpabs_ui {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gmp_h.C_INT,
            gmp_h.C_POINTER,
            gmp_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__gmpz_cmpabs_ui");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int __gmpz_cmpabs_ui(mpz_srcptr, unsigned long)
     * }
     */
    public static FunctionDescriptor __gmpz_cmpabs_ui$descriptor() {
        return __gmpz_cmpabs_ui.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int __gmpz_cmpabs_ui(mpz_srcptr, unsigned long)
     * }
     */
    public static MethodHandle __gmpz_cmpabs_ui$handle() {
        return __gmpz_cmpabs_ui.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int __gmpz_cmpabs_ui(mpz_srcptr, unsigned long)
     * }
     */
    public static MemorySegment __gmpz_cmpabs_ui$address() {
        return __gmpz_cmpabs_ui.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int __gmpz_cmpabs_ui(mpz_srcptr, unsigned long)
     * }
     */
    public static int __gmpz_cmpabs_ui(MemorySegment x0, long x1) {
        var mh$ = __gmpz_cmpabs_ui.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__gmpz_cmpabs_ui", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __gmpz_com {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gmp_h.C_POINTER,
            gmp_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__gmpz_com");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void __gmpz_com(mpz_ptr, mpz_srcptr)
     * }
     */
    public static FunctionDescriptor __gmpz_com$descriptor() {
        return __gmpz_com.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void __gmpz_com(mpz_ptr, mpz_srcptr)
     * }
     */
    public static MethodHandle __gmpz_com$handle() {
        return __gmpz_com.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void __gmpz_com(mpz_ptr, mpz_srcptr)
     * }
     */
    public static MemorySegment __gmpz_com$address() {
        return __gmpz_com.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void __gmpz_com(mpz_ptr, mpz_srcptr)
     * }
     */
    public static void __gmpz_com(MemorySegment x0, MemorySegment x1) {
        var mh$ = __gmpz_com.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__gmpz_com", x0, x1);
            }
            mh$.invokeExact(x0, x1);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __gmpz_combit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gmp_h.C_POINTER,
            gmp_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__gmpz_combit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void __gmpz_combit(mpz_ptr, mp_bitcnt_t)
     * }
     */
    public static FunctionDescriptor __gmpz_combit$descriptor() {
        return __gmpz_combit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void __gmpz_combit(mpz_ptr, mp_bitcnt_t)
     * }
     */
    public static MethodHandle __gmpz_combit$handle() {
        return __gmpz_combit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void __gmpz_combit(mpz_ptr, mp_bitcnt_t)
     * }
     */
    public static MemorySegment __gmpz_combit$address() {
        return __gmpz_combit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void __gmpz_combit(mpz_ptr, mp_bitcnt_t)
     * }
     */
    public static void __gmpz_combit(MemorySegment x0, long x1) {
        var mh$ = __gmpz_combit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__gmpz_combit", x0, x1);
            }
            mh$.invokeExact(x0, x1);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __gmpz_congruent_p {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gmp_h.C_INT,
            gmp_h.C_POINTER,
            gmp_h.C_POINTER,
            gmp_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__gmpz_congruent_p");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int __gmpz_congruent_p(mpz_srcptr, mpz_srcptr, mpz_srcptr)
     * }
     */
    public static FunctionDescriptor __gmpz_congruent_p$descriptor() {
        return __gmpz_congruent_p.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int __gmpz_congruent_p(mpz_srcptr, mpz_srcptr, mpz_srcptr)
     * }
     */
    public static MethodHandle __gmpz_congruent_p$handle() {
        return __gmpz_congruent_p.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int __gmpz_congruent_p(mpz_srcptr, mpz_srcptr, mpz_srcptr)
     * }
     */
    public static MemorySegment __gmpz_congruent_p$address() {
        return __gmpz_congruent_p.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int __gmpz_congruent_p(mpz_srcptr, mpz_srcptr, mpz_srcptr)
     * }
     */
    public static int __gmpz_congruent_p(MemorySegment x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = __gmpz_congruent_p.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__gmpz_congruent_p", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __gmpz_congruent_2exp_p {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gmp_h.C_INT,
            gmp_h.C_POINTER,
            gmp_h.C_POINTER,
            gmp_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__gmpz_congruent_2exp_p");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int __gmpz_congruent_2exp_p(mpz_srcptr, mpz_srcptr, mp_bitcnt_t)
     * }
     */
    public static FunctionDescriptor __gmpz_congruent_2exp_p$descriptor() {
        return __gmpz_congruent_2exp_p.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int __gmpz_congruent_2exp_p(mpz_srcptr, mpz_srcptr, mp_bitcnt_t)
     * }
     */
    public static MethodHandle __gmpz_congruent_2exp_p$handle() {
        return __gmpz_congruent_2exp_p.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int __gmpz_congruent_2exp_p(mpz_srcptr, mpz_srcptr, mp_bitcnt_t)
     * }
     */
    public static MemorySegment __gmpz_congruent_2exp_p$address() {
        return __gmpz_congruent_2exp_p.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int __gmpz_congruent_2exp_p(mpz_srcptr, mpz_srcptr, mp_bitcnt_t)
     * }
     */
    public static int __gmpz_congruent_2exp_p(MemorySegment x0, MemorySegment x1, long x2) {
        var mh$ = __gmpz_congruent_2exp_p.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__gmpz_congruent_2exp_p", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __gmpz_congruent_ui_p {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gmp_h.C_INT,
            gmp_h.C_POINTER,
            gmp_h.C_LONG,
            gmp_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__gmpz_congruent_ui_p");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int __gmpz_congruent_ui_p(mpz_srcptr, unsigned long, unsigned long)
     * }
     */
    public static FunctionDescriptor __gmpz_congruent_ui_p$descriptor() {
        return __gmpz_congruent_ui_p.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int __gmpz_congruent_ui_p(mpz_srcptr, unsigned long, unsigned long)
     * }
     */
    public static MethodHandle __gmpz_congruent_ui_p$handle() {
        return __gmpz_congruent_ui_p.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int __gmpz_congruent_ui_p(mpz_srcptr, unsigned long, unsigned long)
     * }
     */
    public static MemorySegment __gmpz_congruent_ui_p$address() {
        return __gmpz_congruent_ui_p.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int __gmpz_congruent_ui_p(mpz_srcptr, unsigned long, unsigned long)
     * }
     */
    public static int __gmpz_congruent_ui_p(MemorySegment x0, long x1, long x2) {
        var mh$ = __gmpz_congruent_ui_p.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__gmpz_congruent_ui_p", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __gmpz_divexact {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gmp_h.C_POINTER,
            gmp_h.C_POINTER,
            gmp_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__gmpz_divexact");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void __gmpz_divexact(mpz_ptr, mpz_srcptr, mpz_srcptr)
     * }
     */
    public static FunctionDescriptor __gmpz_divexact$descriptor() {
        return __gmpz_divexact.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void __gmpz_divexact(mpz_ptr, mpz_srcptr, mpz_srcptr)
     * }
     */
    public static MethodHandle __gmpz_divexact$handle() {
        return __gmpz_divexact.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void __gmpz_divexact(mpz_ptr, mpz_srcptr, mpz_srcptr)
     * }
     */
    public static MemorySegment __gmpz_divexact$address() {
        return __gmpz_divexact.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void __gmpz_divexact(mpz_ptr, mpz_srcptr, mpz_srcptr)
     * }
     */
    public static void __gmpz_divexact(MemorySegment x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = __gmpz_divexact.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__gmpz_divexact", x0, x1, x2);
            }
            mh$.invokeExact(x0, x1, x2);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __gmpz_divexact_ui {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gmp_h.C_POINTER,
            gmp_h.C_POINTER,
            gmp_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__gmpz_divexact_ui");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void __gmpz_divexact_ui(mpz_ptr, mpz_srcptr, unsigned long)
     * }
     */
    public static FunctionDescriptor __gmpz_divexact_ui$descriptor() {
        return __gmpz_divexact_ui.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void __gmpz_divexact_ui(mpz_ptr, mpz_srcptr, unsigned long)
     * }
     */
    public static MethodHandle __gmpz_divexact_ui$handle() {
        return __gmpz_divexact_ui.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void __gmpz_divexact_ui(mpz_ptr, mpz_srcptr, unsigned long)
     * }
     */
    public static MemorySegment __gmpz_divexact_ui$address() {
        return __gmpz_divexact_ui.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void __gmpz_divexact_ui(mpz_ptr, mpz_srcptr, unsigned long)
     * }
     */
    public static void __gmpz_divexact_ui(MemorySegment x0, MemorySegment x1, long x2) {
        var mh$ = __gmpz_divexact_ui.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__gmpz_divexact_ui", x0, x1, x2);
            }
            mh$.invokeExact(x0, x1, x2);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __gmpz_divisible_p {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gmp_h.C_INT,
            gmp_h.C_POINTER,
            gmp_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__gmpz_divisible_p");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int __gmpz_divisible_p(mpz_srcptr, mpz_srcptr)
     * }
     */
    public static FunctionDescriptor __gmpz_divisible_p$descriptor() {
        return __gmpz_divisible_p.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int __gmpz_divisible_p(mpz_srcptr, mpz_srcptr)
     * }
     */
    public static MethodHandle __gmpz_divisible_p$handle() {
        return __gmpz_divisible_p.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int __gmpz_divisible_p(mpz_srcptr, mpz_srcptr)
     * }
     */
    public static MemorySegment __gmpz_divisible_p$address() {
        return __gmpz_divisible_p.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int __gmpz_divisible_p(mpz_srcptr, mpz_srcptr)
     * }
     */
    public static int __gmpz_divisible_p(MemorySegment x0, MemorySegment x1) {
        var mh$ = __gmpz_divisible_p.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__gmpz_divisible_p", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __gmpz_divisible_ui_p {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gmp_h.C_INT,
            gmp_h.C_POINTER,
            gmp_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__gmpz_divisible_ui_p");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int __gmpz_divisible_ui_p(mpz_srcptr, unsigned long)
     * }
     */
    public static FunctionDescriptor __gmpz_divisible_ui_p$descriptor() {
        return __gmpz_divisible_ui_p.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int __gmpz_divisible_ui_p(mpz_srcptr, unsigned long)
     * }
     */
    public static MethodHandle __gmpz_divisible_ui_p$handle() {
        return __gmpz_divisible_ui_p.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int __gmpz_divisible_ui_p(mpz_srcptr, unsigned long)
     * }
     */
    public static MemorySegment __gmpz_divisible_ui_p$address() {
        return __gmpz_divisible_ui_p.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int __gmpz_divisible_ui_p(mpz_srcptr, unsigned long)
     * }
     */
    public static int __gmpz_divisible_ui_p(MemorySegment x0, long x1) {
        var mh$ = __gmpz_divisible_ui_p.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__gmpz_divisible_ui_p", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __gmpz_divisible_2exp_p {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gmp_h.C_INT,
            gmp_h.C_POINTER,
            gmp_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__gmpz_divisible_2exp_p");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int __gmpz_divisible_2exp_p(mpz_srcptr, mp_bitcnt_t)
     * }
     */
    public static FunctionDescriptor __gmpz_divisible_2exp_p$descriptor() {
        return __gmpz_divisible_2exp_p.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int __gmpz_divisible_2exp_p(mpz_srcptr, mp_bitcnt_t)
     * }
     */
    public static MethodHandle __gmpz_divisible_2exp_p$handle() {
        return __gmpz_divisible_2exp_p.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int __gmpz_divisible_2exp_p(mpz_srcptr, mp_bitcnt_t)
     * }
     */
    public static MemorySegment __gmpz_divisible_2exp_p$address() {
        return __gmpz_divisible_2exp_p.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int __gmpz_divisible_2exp_p(mpz_srcptr, mp_bitcnt_t)
     * }
     */
    public static int __gmpz_divisible_2exp_p(MemorySegment x0, long x1) {
        var mh$ = __gmpz_divisible_2exp_p.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__gmpz_divisible_2exp_p", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __gmpz_dump {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gmp_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__gmpz_dump");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void __gmpz_dump(mpz_srcptr)
     * }
     */
    public static FunctionDescriptor __gmpz_dump$descriptor() {
        return __gmpz_dump.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void __gmpz_dump(mpz_srcptr)
     * }
     */
    public static MethodHandle __gmpz_dump$handle() {
        return __gmpz_dump.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void __gmpz_dump(mpz_srcptr)
     * }
     */
    public static MemorySegment __gmpz_dump$address() {
        return __gmpz_dump.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void __gmpz_dump(mpz_srcptr)
     * }
     */
    public static void __gmpz_dump(MemorySegment x0) {
        var mh$ = __gmpz_dump.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__gmpz_dump", x0);
            }
            mh$.invokeExact(x0);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __gmpz_export {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gmp_h.C_POINTER,
            gmp_h.C_POINTER,
            gmp_h.C_POINTER,
            gmp_h.C_INT,
            gmp_h.C_LONG,
            gmp_h.C_INT,
            gmp_h.C_LONG,
            gmp_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__gmpz_export");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *__gmpz_export(void *, size_t *, int, size_t, int, size_t, mpz_srcptr)
     * }
     */
    public static FunctionDescriptor __gmpz_export$descriptor() {
        return __gmpz_export.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *__gmpz_export(void *, size_t *, int, size_t, int, size_t, mpz_srcptr)
     * }
     */
    public static MethodHandle __gmpz_export$handle() {
        return __gmpz_export.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *__gmpz_export(void *, size_t *, int, size_t, int, size_t, mpz_srcptr)
     * }
     */
    public static MemorySegment __gmpz_export$address() {
        return __gmpz_export.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *__gmpz_export(void *, size_t *, int, size_t, int, size_t, mpz_srcptr)
     * }
     */
    public static MemorySegment __gmpz_export(MemorySegment x0, MemorySegment x1, int x2, long x3, int x4, long x5, MemorySegment x6) {
        var mh$ = __gmpz_export.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__gmpz_export", x0, x1, x2, x3, x4, x5, x6);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1, x2, x3, x4, x5, x6);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __gmpz_fac_ui {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gmp_h.C_POINTER,
            gmp_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__gmpz_fac_ui");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void __gmpz_fac_ui(mpz_ptr, unsigned long)
     * }
     */
    public static FunctionDescriptor __gmpz_fac_ui$descriptor() {
        return __gmpz_fac_ui.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void __gmpz_fac_ui(mpz_ptr, unsigned long)
     * }
     */
    public static MethodHandle __gmpz_fac_ui$handle() {
        return __gmpz_fac_ui.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void __gmpz_fac_ui(mpz_ptr, unsigned long)
     * }
     */
    public static MemorySegment __gmpz_fac_ui$address() {
        return __gmpz_fac_ui.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void __gmpz_fac_ui(mpz_ptr, unsigned long)
     * }
     */
    public static void __gmpz_fac_ui(MemorySegment x0, long x1) {
        var mh$ = __gmpz_fac_ui.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__gmpz_fac_ui", x0, x1);
            }
            mh$.invokeExact(x0, x1);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __gmpz_2fac_ui {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gmp_h.C_POINTER,
            gmp_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__gmpz_2fac_ui");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void __gmpz_2fac_ui(mpz_ptr, unsigned long)
     * }
     */
    public static FunctionDescriptor __gmpz_2fac_ui$descriptor() {
        return __gmpz_2fac_ui.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void __gmpz_2fac_ui(mpz_ptr, unsigned long)
     * }
     */
    public static MethodHandle __gmpz_2fac_ui$handle() {
        return __gmpz_2fac_ui.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void __gmpz_2fac_ui(mpz_ptr, unsigned long)
     * }
     */
    public static MemorySegment __gmpz_2fac_ui$address() {
        return __gmpz_2fac_ui.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void __gmpz_2fac_ui(mpz_ptr, unsigned long)
     * }
     */
    public static void __gmpz_2fac_ui(MemorySegment x0, long x1) {
        var mh$ = __gmpz_2fac_ui.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__gmpz_2fac_ui", x0, x1);
            }
            mh$.invokeExact(x0, x1);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __gmpz_mfac_uiui {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gmp_h.C_POINTER,
            gmp_h.C_LONG,
            gmp_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__gmpz_mfac_uiui");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void __gmpz_mfac_uiui(mpz_ptr, unsigned long, unsigned long)
     * }
     */
    public static FunctionDescriptor __gmpz_mfac_uiui$descriptor() {
        return __gmpz_mfac_uiui.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void __gmpz_mfac_uiui(mpz_ptr, unsigned long, unsigned long)
     * }
     */
    public static MethodHandle __gmpz_mfac_uiui$handle() {
        return __gmpz_mfac_uiui.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void __gmpz_mfac_uiui(mpz_ptr, unsigned long, unsigned long)
     * }
     */
    public static MemorySegment __gmpz_mfac_uiui$address() {
        return __gmpz_mfac_uiui.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void __gmpz_mfac_uiui(mpz_ptr, unsigned long, unsigned long)
     * }
     */
    public static void __gmpz_mfac_uiui(MemorySegment x0, long x1, long x2) {
        var mh$ = __gmpz_mfac_uiui.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__gmpz_mfac_uiui", x0, x1, x2);
            }
            mh$.invokeExact(x0, x1, x2);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __gmpz_primorial_ui {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gmp_h.C_POINTER,
            gmp_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__gmpz_primorial_ui");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void __gmpz_primorial_ui(mpz_ptr, unsigned long)
     * }
     */
    public static FunctionDescriptor __gmpz_primorial_ui$descriptor() {
        return __gmpz_primorial_ui.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void __gmpz_primorial_ui(mpz_ptr, unsigned long)
     * }
     */
    public static MethodHandle __gmpz_primorial_ui$handle() {
        return __gmpz_primorial_ui.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void __gmpz_primorial_ui(mpz_ptr, unsigned long)
     * }
     */
    public static MemorySegment __gmpz_primorial_ui$address() {
        return __gmpz_primorial_ui.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void __gmpz_primorial_ui(mpz_ptr, unsigned long)
     * }
     */
    public static void __gmpz_primorial_ui(MemorySegment x0, long x1) {
        var mh$ = __gmpz_primorial_ui.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__gmpz_primorial_ui", x0, x1);
            }
            mh$.invokeExact(x0, x1);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __gmpz_fdiv_q {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gmp_h.C_POINTER,
            gmp_h.C_POINTER,
            gmp_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__gmpz_fdiv_q");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void __gmpz_fdiv_q(mpz_ptr, mpz_srcptr, mpz_srcptr)
     * }
     */
    public static FunctionDescriptor __gmpz_fdiv_q$descriptor() {
        return __gmpz_fdiv_q.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void __gmpz_fdiv_q(mpz_ptr, mpz_srcptr, mpz_srcptr)
     * }
     */
    public static MethodHandle __gmpz_fdiv_q$handle() {
        return __gmpz_fdiv_q.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void __gmpz_fdiv_q(mpz_ptr, mpz_srcptr, mpz_srcptr)
     * }
     */
    public static MemorySegment __gmpz_fdiv_q$address() {
        return __gmpz_fdiv_q.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void __gmpz_fdiv_q(mpz_ptr, mpz_srcptr, mpz_srcptr)
     * }
     */
    public static void __gmpz_fdiv_q(MemorySegment x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = __gmpz_fdiv_q.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__gmpz_fdiv_q", x0, x1, x2);
            }
            mh$.invokeExact(x0, x1, x2);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __gmpz_fdiv_q_2exp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gmp_h.C_POINTER,
            gmp_h.C_POINTER,
            gmp_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__gmpz_fdiv_q_2exp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void __gmpz_fdiv_q_2exp(mpz_ptr, mpz_srcptr, mp_bitcnt_t)
     * }
     */
    public static FunctionDescriptor __gmpz_fdiv_q_2exp$descriptor() {
        return __gmpz_fdiv_q_2exp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void __gmpz_fdiv_q_2exp(mpz_ptr, mpz_srcptr, mp_bitcnt_t)
     * }
     */
    public static MethodHandle __gmpz_fdiv_q_2exp$handle() {
        return __gmpz_fdiv_q_2exp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void __gmpz_fdiv_q_2exp(mpz_ptr, mpz_srcptr, mp_bitcnt_t)
     * }
     */
    public static MemorySegment __gmpz_fdiv_q_2exp$address() {
        return __gmpz_fdiv_q_2exp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void __gmpz_fdiv_q_2exp(mpz_ptr, mpz_srcptr, mp_bitcnt_t)
     * }
     */
    public static void __gmpz_fdiv_q_2exp(MemorySegment x0, MemorySegment x1, long x2) {
        var mh$ = __gmpz_fdiv_q_2exp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__gmpz_fdiv_q_2exp", x0, x1, x2);
            }
            mh$.invokeExact(x0, x1, x2);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __gmpz_fdiv_q_ui {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gmp_h.C_LONG,
            gmp_h.C_POINTER,
            gmp_h.C_POINTER,
            gmp_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__gmpz_fdiv_q_ui");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned long __gmpz_fdiv_q_ui(mpz_ptr, mpz_srcptr, unsigned long)
     * }
     */
    public static FunctionDescriptor __gmpz_fdiv_q_ui$descriptor() {
        return __gmpz_fdiv_q_ui.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned long __gmpz_fdiv_q_ui(mpz_ptr, mpz_srcptr, unsigned long)
     * }
     */
    public static MethodHandle __gmpz_fdiv_q_ui$handle() {
        return __gmpz_fdiv_q_ui.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned long __gmpz_fdiv_q_ui(mpz_ptr, mpz_srcptr, unsigned long)
     * }
     */
    public static MemorySegment __gmpz_fdiv_q_ui$address() {
        return __gmpz_fdiv_q_ui.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned long __gmpz_fdiv_q_ui(mpz_ptr, mpz_srcptr, unsigned long)
     * }
     */
    public static long __gmpz_fdiv_q_ui(MemorySegment x0, MemorySegment x1, long x2) {
        var mh$ = __gmpz_fdiv_q_ui.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__gmpz_fdiv_q_ui", x0, x1, x2);
            }
            return (long)mh$.invokeExact(x0, x1, x2);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __gmpz_fdiv_qr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gmp_h.C_POINTER,
            gmp_h.C_POINTER,
            gmp_h.C_POINTER,
            gmp_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__gmpz_fdiv_qr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void __gmpz_fdiv_qr(mpz_ptr, mpz_ptr, mpz_srcptr, mpz_srcptr)
     * }
     */
    public static FunctionDescriptor __gmpz_fdiv_qr$descriptor() {
        return __gmpz_fdiv_qr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void __gmpz_fdiv_qr(mpz_ptr, mpz_ptr, mpz_srcptr, mpz_srcptr)
     * }
     */
    public static MethodHandle __gmpz_fdiv_qr$handle() {
        return __gmpz_fdiv_qr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void __gmpz_fdiv_qr(mpz_ptr, mpz_ptr, mpz_srcptr, mpz_srcptr)
     * }
     */
    public static MemorySegment __gmpz_fdiv_qr$address() {
        return __gmpz_fdiv_qr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void __gmpz_fdiv_qr(mpz_ptr, mpz_ptr, mpz_srcptr, mpz_srcptr)
     * }
     */
    public static void __gmpz_fdiv_qr(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = __gmpz_fdiv_qr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__gmpz_fdiv_qr", x0, x1, x2, x3);
            }
            mh$.invokeExact(x0, x1, x2, x3);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __gmpz_fdiv_qr_ui {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gmp_h.C_LONG,
            gmp_h.C_POINTER,
            gmp_h.C_POINTER,
            gmp_h.C_POINTER,
            gmp_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__gmpz_fdiv_qr_ui");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned long __gmpz_fdiv_qr_ui(mpz_ptr, mpz_ptr, mpz_srcptr, unsigned long)
     * }
     */
    public static FunctionDescriptor __gmpz_fdiv_qr_ui$descriptor() {
        return __gmpz_fdiv_qr_ui.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned long __gmpz_fdiv_qr_ui(mpz_ptr, mpz_ptr, mpz_srcptr, unsigned long)
     * }
     */
    public static MethodHandle __gmpz_fdiv_qr_ui$handle() {
        return __gmpz_fdiv_qr_ui.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned long __gmpz_fdiv_qr_ui(mpz_ptr, mpz_ptr, mpz_srcptr, unsigned long)
     * }
     */
    public static MemorySegment __gmpz_fdiv_qr_ui$address() {
        return __gmpz_fdiv_qr_ui.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned long __gmpz_fdiv_qr_ui(mpz_ptr, mpz_ptr, mpz_srcptr, unsigned long)
     * }
     */
    public static long __gmpz_fdiv_qr_ui(MemorySegment x0, MemorySegment x1, MemorySegment x2, long x3) {
        var mh$ = __gmpz_fdiv_qr_ui.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__gmpz_fdiv_qr_ui", x0, x1, x2, x3);
            }
            return (long)mh$.invokeExact(x0, x1, x2, x3);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __gmpz_fdiv_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gmp_h.C_POINTER,
            gmp_h.C_POINTER,
            gmp_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__gmpz_fdiv_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void __gmpz_fdiv_r(mpz_ptr, mpz_srcptr, mpz_srcptr)
     * }
     */
    public static FunctionDescriptor __gmpz_fdiv_r$descriptor() {
        return __gmpz_fdiv_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void __gmpz_fdiv_r(mpz_ptr, mpz_srcptr, mpz_srcptr)
     * }
     */
    public static MethodHandle __gmpz_fdiv_r$handle() {
        return __gmpz_fdiv_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void __gmpz_fdiv_r(mpz_ptr, mpz_srcptr, mpz_srcptr)
     * }
     */
    public static MemorySegment __gmpz_fdiv_r$address() {
        return __gmpz_fdiv_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void __gmpz_fdiv_r(mpz_ptr, mpz_srcptr, mpz_srcptr)
     * }
     */
    public static void __gmpz_fdiv_r(MemorySegment x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = __gmpz_fdiv_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__gmpz_fdiv_r", x0, x1, x2);
            }
            mh$.invokeExact(x0, x1, x2);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __gmpz_fdiv_r_2exp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gmp_h.C_POINTER,
            gmp_h.C_POINTER,
            gmp_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__gmpz_fdiv_r_2exp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void __gmpz_fdiv_r_2exp(mpz_ptr, mpz_srcptr, mp_bitcnt_t)
     * }
     */
    public static FunctionDescriptor __gmpz_fdiv_r_2exp$descriptor() {
        return __gmpz_fdiv_r_2exp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void __gmpz_fdiv_r_2exp(mpz_ptr, mpz_srcptr, mp_bitcnt_t)
     * }
     */
    public static MethodHandle __gmpz_fdiv_r_2exp$handle() {
        return __gmpz_fdiv_r_2exp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void __gmpz_fdiv_r_2exp(mpz_ptr, mpz_srcptr, mp_bitcnt_t)
     * }
     */
    public static MemorySegment __gmpz_fdiv_r_2exp$address() {
        return __gmpz_fdiv_r_2exp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void __gmpz_fdiv_r_2exp(mpz_ptr, mpz_srcptr, mp_bitcnt_t)
     * }
     */
    public static void __gmpz_fdiv_r_2exp(MemorySegment x0, MemorySegment x1, long x2) {
        var mh$ = __gmpz_fdiv_r_2exp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__gmpz_fdiv_r_2exp", x0, x1, x2);
            }
            mh$.invokeExact(x0, x1, x2);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __gmpz_fdiv_r_ui {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gmp_h.C_LONG,
            gmp_h.C_POINTER,
            gmp_h.C_POINTER,
            gmp_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__gmpz_fdiv_r_ui");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned long __gmpz_fdiv_r_ui(mpz_ptr, mpz_srcptr, unsigned long)
     * }
     */
    public static FunctionDescriptor __gmpz_fdiv_r_ui$descriptor() {
        return __gmpz_fdiv_r_ui.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned long __gmpz_fdiv_r_ui(mpz_ptr, mpz_srcptr, unsigned long)
     * }
     */
    public static MethodHandle __gmpz_fdiv_r_ui$handle() {
        return __gmpz_fdiv_r_ui.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned long __gmpz_fdiv_r_ui(mpz_ptr, mpz_srcptr, unsigned long)
     * }
     */
    public static MemorySegment __gmpz_fdiv_r_ui$address() {
        return __gmpz_fdiv_r_ui.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned long __gmpz_fdiv_r_ui(mpz_ptr, mpz_srcptr, unsigned long)
     * }
     */
    public static long __gmpz_fdiv_r_ui(MemorySegment x0, MemorySegment x1, long x2) {
        var mh$ = __gmpz_fdiv_r_ui.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__gmpz_fdiv_r_ui", x0, x1, x2);
            }
            return (long)mh$.invokeExact(x0, x1, x2);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __gmpz_fdiv_ui {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gmp_h.C_LONG,
            gmp_h.C_POINTER,
            gmp_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__gmpz_fdiv_ui");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned long __gmpz_fdiv_ui(mpz_srcptr, unsigned long)
     * }
     */
    public static FunctionDescriptor __gmpz_fdiv_ui$descriptor() {
        return __gmpz_fdiv_ui.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned long __gmpz_fdiv_ui(mpz_srcptr, unsigned long)
     * }
     */
    public static MethodHandle __gmpz_fdiv_ui$handle() {
        return __gmpz_fdiv_ui.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned long __gmpz_fdiv_ui(mpz_srcptr, unsigned long)
     * }
     */
    public static MemorySegment __gmpz_fdiv_ui$address() {
        return __gmpz_fdiv_ui.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned long __gmpz_fdiv_ui(mpz_srcptr, unsigned long)
     * }
     */
    public static long __gmpz_fdiv_ui(MemorySegment x0, long x1) {
        var mh$ = __gmpz_fdiv_ui.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__gmpz_fdiv_ui", x0, x1);
            }
            return (long)mh$.invokeExact(x0, x1);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __gmpz_fib_ui {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gmp_h.C_POINTER,
            gmp_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__gmpz_fib_ui");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void __gmpz_fib_ui(mpz_ptr, unsigned long)
     * }
     */
    public static FunctionDescriptor __gmpz_fib_ui$descriptor() {
        return __gmpz_fib_ui.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void __gmpz_fib_ui(mpz_ptr, unsigned long)
     * }
     */
    public static MethodHandle __gmpz_fib_ui$handle() {
        return __gmpz_fib_ui.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void __gmpz_fib_ui(mpz_ptr, unsigned long)
     * }
     */
    public static MemorySegment __gmpz_fib_ui$address() {
        return __gmpz_fib_ui.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void __gmpz_fib_ui(mpz_ptr, unsigned long)
     * }
     */
    public static void __gmpz_fib_ui(MemorySegment x0, long x1) {
        var mh$ = __gmpz_fib_ui.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__gmpz_fib_ui", x0, x1);
            }
            mh$.invokeExact(x0, x1);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __gmpz_fib2_ui {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gmp_h.C_POINTER,
            gmp_h.C_POINTER,
            gmp_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__gmpz_fib2_ui");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void __gmpz_fib2_ui(mpz_ptr, mpz_ptr, unsigned long)
     * }
     */
    public static FunctionDescriptor __gmpz_fib2_ui$descriptor() {
        return __gmpz_fib2_ui.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void __gmpz_fib2_ui(mpz_ptr, mpz_ptr, unsigned long)
     * }
     */
    public static MethodHandle __gmpz_fib2_ui$handle() {
        return __gmpz_fib2_ui.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void __gmpz_fib2_ui(mpz_ptr, mpz_ptr, unsigned long)
     * }
     */
    public static MemorySegment __gmpz_fib2_ui$address() {
        return __gmpz_fib2_ui.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void __gmpz_fib2_ui(mpz_ptr, mpz_ptr, unsigned long)
     * }
     */
    public static void __gmpz_fib2_ui(MemorySegment x0, MemorySegment x1, long x2) {
        var mh$ = __gmpz_fib2_ui.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__gmpz_fib2_ui", x0, x1, x2);
            }
            mh$.invokeExact(x0, x1, x2);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __gmpz_fits_sint_p {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gmp_h.C_INT,
            gmp_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__gmpz_fits_sint_p");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int __gmpz_fits_sint_p(mpz_srcptr)
     * }
     */
    public static FunctionDescriptor __gmpz_fits_sint_p$descriptor() {
        return __gmpz_fits_sint_p.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int __gmpz_fits_sint_p(mpz_srcptr)
     * }
     */
    public static MethodHandle __gmpz_fits_sint_p$handle() {
        return __gmpz_fits_sint_p.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int __gmpz_fits_sint_p(mpz_srcptr)
     * }
     */
    public static MemorySegment __gmpz_fits_sint_p$address() {
        return __gmpz_fits_sint_p.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int __gmpz_fits_sint_p(mpz_srcptr)
     * }
     */
    public static int __gmpz_fits_sint_p(MemorySegment x0) {
        var mh$ = __gmpz_fits_sint_p.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__gmpz_fits_sint_p", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __gmpz_fits_slong_p {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gmp_h.C_INT,
            gmp_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__gmpz_fits_slong_p");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int __gmpz_fits_slong_p(mpz_srcptr)
     * }
     */
    public static FunctionDescriptor __gmpz_fits_slong_p$descriptor() {
        return __gmpz_fits_slong_p.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int __gmpz_fits_slong_p(mpz_srcptr)
     * }
     */
    public static MethodHandle __gmpz_fits_slong_p$handle() {
        return __gmpz_fits_slong_p.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int __gmpz_fits_slong_p(mpz_srcptr)
     * }
     */
    public static MemorySegment __gmpz_fits_slong_p$address() {
        return __gmpz_fits_slong_p.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int __gmpz_fits_slong_p(mpz_srcptr)
     * }
     */
    public static int __gmpz_fits_slong_p(MemorySegment x0) {
        var mh$ = __gmpz_fits_slong_p.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__gmpz_fits_slong_p", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __gmpz_fits_sshort_p {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gmp_h.C_INT,
            gmp_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__gmpz_fits_sshort_p");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int __gmpz_fits_sshort_p(mpz_srcptr)
     * }
     */
    public static FunctionDescriptor __gmpz_fits_sshort_p$descriptor() {
        return __gmpz_fits_sshort_p.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int __gmpz_fits_sshort_p(mpz_srcptr)
     * }
     */
    public static MethodHandle __gmpz_fits_sshort_p$handle() {
        return __gmpz_fits_sshort_p.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int __gmpz_fits_sshort_p(mpz_srcptr)
     * }
     */
    public static MemorySegment __gmpz_fits_sshort_p$address() {
        return __gmpz_fits_sshort_p.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int __gmpz_fits_sshort_p(mpz_srcptr)
     * }
     */
    public static int __gmpz_fits_sshort_p(MemorySegment x0) {
        var mh$ = __gmpz_fits_sshort_p.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__gmpz_fits_sshort_p", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __gmpz_fits_uint_p {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gmp_h.C_INT,
            gmp_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__gmpz_fits_uint_p");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int __gmpz_fits_uint_p(mpz_srcptr)
     * }
     */
    public static FunctionDescriptor __gmpz_fits_uint_p$descriptor() {
        return __gmpz_fits_uint_p.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int __gmpz_fits_uint_p(mpz_srcptr)
     * }
     */
    public static MethodHandle __gmpz_fits_uint_p$handle() {
        return __gmpz_fits_uint_p.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int __gmpz_fits_uint_p(mpz_srcptr)
     * }
     */
    public static MemorySegment __gmpz_fits_uint_p$address() {
        return __gmpz_fits_uint_p.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int __gmpz_fits_uint_p(mpz_srcptr)
     * }
     */
    public static int __gmpz_fits_uint_p(MemorySegment x0) {
        var mh$ = __gmpz_fits_uint_p.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__gmpz_fits_uint_p", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __gmpz_fits_ulong_p {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gmp_h.C_INT,
            gmp_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__gmpz_fits_ulong_p");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int __gmpz_fits_ulong_p(mpz_srcptr)
     * }
     */
    public static FunctionDescriptor __gmpz_fits_ulong_p$descriptor() {
        return __gmpz_fits_ulong_p.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int __gmpz_fits_ulong_p(mpz_srcptr)
     * }
     */
    public static MethodHandle __gmpz_fits_ulong_p$handle() {
        return __gmpz_fits_ulong_p.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int __gmpz_fits_ulong_p(mpz_srcptr)
     * }
     */
    public static MemorySegment __gmpz_fits_ulong_p$address() {
        return __gmpz_fits_ulong_p.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int __gmpz_fits_ulong_p(mpz_srcptr)
     * }
     */
    public static int __gmpz_fits_ulong_p(MemorySegment x0) {
        var mh$ = __gmpz_fits_ulong_p.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__gmpz_fits_ulong_p", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __gmpz_fits_ushort_p {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gmp_h.C_INT,
            gmp_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__gmpz_fits_ushort_p");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int __gmpz_fits_ushort_p(mpz_srcptr)
     * }
     */
    public static FunctionDescriptor __gmpz_fits_ushort_p$descriptor() {
        return __gmpz_fits_ushort_p.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int __gmpz_fits_ushort_p(mpz_srcptr)
     * }
     */
    public static MethodHandle __gmpz_fits_ushort_p$handle() {
        return __gmpz_fits_ushort_p.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int __gmpz_fits_ushort_p(mpz_srcptr)
     * }
     */
    public static MemorySegment __gmpz_fits_ushort_p$address() {
        return __gmpz_fits_ushort_p.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int __gmpz_fits_ushort_p(mpz_srcptr)
     * }
     */
    public static int __gmpz_fits_ushort_p(MemorySegment x0) {
        var mh$ = __gmpz_fits_ushort_p.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__gmpz_fits_ushort_p", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __gmpz_gcd {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gmp_h.C_POINTER,
            gmp_h.C_POINTER,
            gmp_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__gmpz_gcd");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void __gmpz_gcd(mpz_ptr, mpz_srcptr, mpz_srcptr)
     * }
     */
    public static FunctionDescriptor __gmpz_gcd$descriptor() {
        return __gmpz_gcd.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void __gmpz_gcd(mpz_ptr, mpz_srcptr, mpz_srcptr)
     * }
     */
    public static MethodHandle __gmpz_gcd$handle() {
        return __gmpz_gcd.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void __gmpz_gcd(mpz_ptr, mpz_srcptr, mpz_srcptr)
     * }
     */
    public static MemorySegment __gmpz_gcd$address() {
        return __gmpz_gcd.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void __gmpz_gcd(mpz_ptr, mpz_srcptr, mpz_srcptr)
     * }
     */
    public static void __gmpz_gcd(MemorySegment x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = __gmpz_gcd.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__gmpz_gcd", x0, x1, x2);
            }
            mh$.invokeExact(x0, x1, x2);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __gmpz_gcd_ui {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gmp_h.C_LONG,
            gmp_h.C_POINTER,
            gmp_h.C_POINTER,
            gmp_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__gmpz_gcd_ui");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned long __gmpz_gcd_ui(mpz_ptr, mpz_srcptr, unsigned long)
     * }
     */
    public static FunctionDescriptor __gmpz_gcd_ui$descriptor() {
        return __gmpz_gcd_ui.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned long __gmpz_gcd_ui(mpz_ptr, mpz_srcptr, unsigned long)
     * }
     */
    public static MethodHandle __gmpz_gcd_ui$handle() {
        return __gmpz_gcd_ui.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned long __gmpz_gcd_ui(mpz_ptr, mpz_srcptr, unsigned long)
     * }
     */
    public static MemorySegment __gmpz_gcd_ui$address() {
        return __gmpz_gcd_ui.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned long __gmpz_gcd_ui(mpz_ptr, mpz_srcptr, unsigned long)
     * }
     */
    public static long __gmpz_gcd_ui(MemorySegment x0, MemorySegment x1, long x2) {
        var mh$ = __gmpz_gcd_ui.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__gmpz_gcd_ui", x0, x1, x2);
            }
            return (long)mh$.invokeExact(x0, x1, x2);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __gmpz_gcdext {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gmp_h.C_POINTER,
            gmp_h.C_POINTER,
            gmp_h.C_POINTER,
            gmp_h.C_POINTER,
            gmp_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__gmpz_gcdext");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void __gmpz_gcdext(mpz_ptr, mpz_ptr, mpz_ptr, mpz_srcptr, mpz_srcptr)
     * }
     */
    public static FunctionDescriptor __gmpz_gcdext$descriptor() {
        return __gmpz_gcdext.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void __gmpz_gcdext(mpz_ptr, mpz_ptr, mpz_ptr, mpz_srcptr, mpz_srcptr)
     * }
     */
    public static MethodHandle __gmpz_gcdext$handle() {
        return __gmpz_gcdext.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void __gmpz_gcdext(mpz_ptr, mpz_ptr, mpz_ptr, mpz_srcptr, mpz_srcptr)
     * }
     */
    public static MemorySegment __gmpz_gcdext$address() {
        return __gmpz_gcdext.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void __gmpz_gcdext(mpz_ptr, mpz_ptr, mpz_ptr, mpz_srcptr, mpz_srcptr)
     * }
     */
    public static void __gmpz_gcdext(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = __gmpz_gcdext.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__gmpz_gcdext", x0, x1, x2, x3, x4);
            }
            mh$.invokeExact(x0, x1, x2, x3, x4);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __gmpz_get_d {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gmp_h.C_DOUBLE,
            gmp_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__gmpz_get_d");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double __gmpz_get_d(mpz_srcptr)
     * }
     */
    public static FunctionDescriptor __gmpz_get_d$descriptor() {
        return __gmpz_get_d.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double __gmpz_get_d(mpz_srcptr)
     * }
     */
    public static MethodHandle __gmpz_get_d$handle() {
        return __gmpz_get_d.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double __gmpz_get_d(mpz_srcptr)
     * }
     */
    public static MemorySegment __gmpz_get_d$address() {
        return __gmpz_get_d.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double __gmpz_get_d(mpz_srcptr)
     * }
     */
    public static double __gmpz_get_d(MemorySegment x0) {
        var mh$ = __gmpz_get_d.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__gmpz_get_d", x0);
            }
            return (double)mh$.invokeExact(x0);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __gmpz_get_d_2exp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gmp_h.C_DOUBLE,
            gmp_h.C_POINTER,
            gmp_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__gmpz_get_d_2exp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double __gmpz_get_d_2exp(long *, mpz_srcptr)
     * }
     */
    public static FunctionDescriptor __gmpz_get_d_2exp$descriptor() {
        return __gmpz_get_d_2exp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double __gmpz_get_d_2exp(long *, mpz_srcptr)
     * }
     */
    public static MethodHandle __gmpz_get_d_2exp$handle() {
        return __gmpz_get_d_2exp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double __gmpz_get_d_2exp(long *, mpz_srcptr)
     * }
     */
    public static MemorySegment __gmpz_get_d_2exp$address() {
        return __gmpz_get_d_2exp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double __gmpz_get_d_2exp(long *, mpz_srcptr)
     * }
     */
    public static double __gmpz_get_d_2exp(MemorySegment x0, MemorySegment x1) {
        var mh$ = __gmpz_get_d_2exp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__gmpz_get_d_2exp", x0, x1);
            }
            return (double)mh$.invokeExact(x0, x1);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __gmpz_get_si {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gmp_h.C_LONG,
            gmp_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__gmpz_get_si");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long __gmpz_get_si(mpz_srcptr)
     * }
     */
    public static FunctionDescriptor __gmpz_get_si$descriptor() {
        return __gmpz_get_si.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long __gmpz_get_si(mpz_srcptr)
     * }
     */
    public static MethodHandle __gmpz_get_si$handle() {
        return __gmpz_get_si.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long __gmpz_get_si(mpz_srcptr)
     * }
     */
    public static MemorySegment __gmpz_get_si$address() {
        return __gmpz_get_si.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long __gmpz_get_si(mpz_srcptr)
     * }
     */
    public static long __gmpz_get_si(MemorySegment x0) {
        var mh$ = __gmpz_get_si.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__gmpz_get_si", x0);
            }
            return (long)mh$.invokeExact(x0);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __gmpz_get_str {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gmp_h.C_POINTER,
            gmp_h.C_POINTER,
            gmp_h.C_INT,
            gmp_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__gmpz_get_str");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *__gmpz_get_str(char *, int, mpz_srcptr)
     * }
     */
    public static FunctionDescriptor __gmpz_get_str$descriptor() {
        return __gmpz_get_str.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *__gmpz_get_str(char *, int, mpz_srcptr)
     * }
     */
    public static MethodHandle __gmpz_get_str$handle() {
        return __gmpz_get_str.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *__gmpz_get_str(char *, int, mpz_srcptr)
     * }
     */
    public static MemorySegment __gmpz_get_str$address() {
        return __gmpz_get_str.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *__gmpz_get_str(char *, int, mpz_srcptr)
     * }
     */
    public static MemorySegment __gmpz_get_str(MemorySegment x0, int x1, MemorySegment x2) {
        var mh$ = __gmpz_get_str.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__gmpz_get_str", x0, x1, x2);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1, x2);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __gmpz_get_ui {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gmp_h.C_LONG,
            gmp_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__gmpz_get_ui");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned long __gmpz_get_ui(mpz_srcptr)
     * }
     */
    public static FunctionDescriptor __gmpz_get_ui$descriptor() {
        return __gmpz_get_ui.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned long __gmpz_get_ui(mpz_srcptr)
     * }
     */
    public static MethodHandle __gmpz_get_ui$handle() {
        return __gmpz_get_ui.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned long __gmpz_get_ui(mpz_srcptr)
     * }
     */
    public static MemorySegment __gmpz_get_ui$address() {
        return __gmpz_get_ui.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned long __gmpz_get_ui(mpz_srcptr)
     * }
     */
    public static long __gmpz_get_ui(MemorySegment x0) {
        var mh$ = __gmpz_get_ui.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__gmpz_get_ui", x0);
            }
            return (long)mh$.invokeExact(x0);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __gmpz_getlimbn {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gmp_h.C_LONG,
            gmp_h.C_POINTER,
            gmp_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__gmpz_getlimbn");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * mp_limb_t __gmpz_getlimbn(mpz_srcptr, mp_size_t)
     * }
     */
    public static FunctionDescriptor __gmpz_getlimbn$descriptor() {
        return __gmpz_getlimbn.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * mp_limb_t __gmpz_getlimbn(mpz_srcptr, mp_size_t)
     * }
     */
    public static MethodHandle __gmpz_getlimbn$handle() {
        return __gmpz_getlimbn.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * mp_limb_t __gmpz_getlimbn(mpz_srcptr, mp_size_t)
     * }
     */
    public static MemorySegment __gmpz_getlimbn$address() {
        return __gmpz_getlimbn.ADDR;
    }

    /**
     * {@snippet lang=c :
     * mp_limb_t __gmpz_getlimbn(mpz_srcptr, mp_size_t)
     * }
     */
    public static long __gmpz_getlimbn(MemorySegment x0, long x1) {
        var mh$ = __gmpz_getlimbn.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__gmpz_getlimbn", x0, x1);
            }
            return (long)mh$.invokeExact(x0, x1);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __gmpz_hamdist {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gmp_h.C_LONG,
            gmp_h.C_POINTER,
            gmp_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__gmpz_hamdist");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * mp_bitcnt_t __gmpz_hamdist(mpz_srcptr, mpz_srcptr)
     * }
     */
    public static FunctionDescriptor __gmpz_hamdist$descriptor() {
        return __gmpz_hamdist.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * mp_bitcnt_t __gmpz_hamdist(mpz_srcptr, mpz_srcptr)
     * }
     */
    public static MethodHandle __gmpz_hamdist$handle() {
        return __gmpz_hamdist.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * mp_bitcnt_t __gmpz_hamdist(mpz_srcptr, mpz_srcptr)
     * }
     */
    public static MemorySegment __gmpz_hamdist$address() {
        return __gmpz_hamdist.ADDR;
    }

    /**
     * {@snippet lang=c :
     * mp_bitcnt_t __gmpz_hamdist(mpz_srcptr, mpz_srcptr)
     * }
     */
    public static long __gmpz_hamdist(MemorySegment x0, MemorySegment x1) {
        var mh$ = __gmpz_hamdist.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__gmpz_hamdist", x0, x1);
            }
            return (long)mh$.invokeExact(x0, x1);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __gmpz_import {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gmp_h.C_POINTER,
            gmp_h.C_LONG,
            gmp_h.C_INT,
            gmp_h.C_LONG,
            gmp_h.C_INT,
            gmp_h.C_LONG,
            gmp_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__gmpz_import");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void __gmpz_import(mpz_ptr, size_t, int, size_t, int, size_t, const void *)
     * }
     */
    public static FunctionDescriptor __gmpz_import$descriptor() {
        return __gmpz_import.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void __gmpz_import(mpz_ptr, size_t, int, size_t, int, size_t, const void *)
     * }
     */
    public static MethodHandle __gmpz_import$handle() {
        return __gmpz_import.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void __gmpz_import(mpz_ptr, size_t, int, size_t, int, size_t, const void *)
     * }
     */
    public static MemorySegment __gmpz_import$address() {
        return __gmpz_import.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void __gmpz_import(mpz_ptr, size_t, int, size_t, int, size_t, const void *)
     * }
     */
    public static void __gmpz_import(MemorySegment x0, long x1, int x2, long x3, int x4, long x5, MemorySegment x6) {
        var mh$ = __gmpz_import.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__gmpz_import", x0, x1, x2, x3, x4, x5, x6);
            }
            mh$.invokeExact(x0, x1, x2, x3, x4, x5, x6);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __gmpz_init {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gmp_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__gmpz_init");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void __gmpz_init(mpz_ptr)
     * }
     */
    public static FunctionDescriptor __gmpz_init$descriptor() {
        return __gmpz_init.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void __gmpz_init(mpz_ptr)
     * }
     */
    public static MethodHandle __gmpz_init$handle() {
        return __gmpz_init.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void __gmpz_init(mpz_ptr)
     * }
     */
    public static MemorySegment __gmpz_init$address() {
        return __gmpz_init.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void __gmpz_init(mpz_ptr)
     * }
     */
    public static void __gmpz_init(MemorySegment x0) {
        var mh$ = __gmpz_init.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__gmpz_init", x0);
            }
            mh$.invokeExact(x0);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __gmpz_init2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gmp_h.C_POINTER,
            gmp_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__gmpz_init2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void __gmpz_init2(mpz_ptr, mp_bitcnt_t)
     * }
     */
    public static FunctionDescriptor __gmpz_init2$descriptor() {
        return __gmpz_init2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void __gmpz_init2(mpz_ptr, mp_bitcnt_t)
     * }
     */
    public static MethodHandle __gmpz_init2$handle() {
        return __gmpz_init2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void __gmpz_init2(mpz_ptr, mp_bitcnt_t)
     * }
     */
    public static MemorySegment __gmpz_init2$address() {
        return __gmpz_init2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void __gmpz_init2(mpz_ptr, mp_bitcnt_t)
     * }
     */
    public static void __gmpz_init2(MemorySegment x0, long x1) {
        var mh$ = __gmpz_init2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__gmpz_init2", x0, x1);
            }
            mh$.invokeExact(x0, x1);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * void __gmpz_inits(mpz_ptr, ...)
     * }
     */
    public static class __gmpz_inits {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.ofVoid(
                gmp_h.C_POINTER
            );
        private static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__gmpz_inits");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private __gmpz_inits(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * void __gmpz_inits(mpz_ptr, ...)
         * }
         */
        public static __gmpz_inits makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new __gmpz_inits(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public void apply(MemorySegment x0, Object... x1) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("__gmpz_inits", x0, x1);
                }
                 spreader.invokeExact(x0, x1);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static class __gmpz_init_set {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gmp_h.C_POINTER,
            gmp_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__gmpz_init_set");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void __gmpz_init_set(mpz_ptr, mpz_srcptr)
     * }
     */
    public static FunctionDescriptor __gmpz_init_set$descriptor() {
        return __gmpz_init_set.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void __gmpz_init_set(mpz_ptr, mpz_srcptr)
     * }
     */
    public static MethodHandle __gmpz_init_set$handle() {
        return __gmpz_init_set.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void __gmpz_init_set(mpz_ptr, mpz_srcptr)
     * }
     */
    public static MemorySegment __gmpz_init_set$address() {
        return __gmpz_init_set.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void __gmpz_init_set(mpz_ptr, mpz_srcptr)
     * }
     */
    public static void __gmpz_init_set(MemorySegment x0, MemorySegment x1) {
        var mh$ = __gmpz_init_set.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__gmpz_init_set", x0, x1);
            }
            mh$.invokeExact(x0, x1);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __gmpz_init_set_d {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gmp_h.C_POINTER,
            gmp_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__gmpz_init_set_d");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void __gmpz_init_set_d(mpz_ptr, double)
     * }
     */
    public static FunctionDescriptor __gmpz_init_set_d$descriptor() {
        return __gmpz_init_set_d.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void __gmpz_init_set_d(mpz_ptr, double)
     * }
     */
    public static MethodHandle __gmpz_init_set_d$handle() {
        return __gmpz_init_set_d.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void __gmpz_init_set_d(mpz_ptr, double)
     * }
     */
    public static MemorySegment __gmpz_init_set_d$address() {
        return __gmpz_init_set_d.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void __gmpz_init_set_d(mpz_ptr, double)
     * }
     */
    public static void __gmpz_init_set_d(MemorySegment x0, double x1) {
        var mh$ = __gmpz_init_set_d.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__gmpz_init_set_d", x0, x1);
            }
            mh$.invokeExact(x0, x1);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __gmpz_init_set_si {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gmp_h.C_POINTER,
            gmp_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__gmpz_init_set_si");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void __gmpz_init_set_si(mpz_ptr, long)
     * }
     */
    public static FunctionDescriptor __gmpz_init_set_si$descriptor() {
        return __gmpz_init_set_si.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void __gmpz_init_set_si(mpz_ptr, long)
     * }
     */
    public static MethodHandle __gmpz_init_set_si$handle() {
        return __gmpz_init_set_si.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void __gmpz_init_set_si(mpz_ptr, long)
     * }
     */
    public static MemorySegment __gmpz_init_set_si$address() {
        return __gmpz_init_set_si.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void __gmpz_init_set_si(mpz_ptr, long)
     * }
     */
    public static void __gmpz_init_set_si(MemorySegment x0, long x1) {
        var mh$ = __gmpz_init_set_si.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__gmpz_init_set_si", x0, x1);
            }
            mh$.invokeExact(x0, x1);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __gmpz_init_set_str {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gmp_h.C_INT,
            gmp_h.C_POINTER,
            gmp_h.C_POINTER,
            gmp_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__gmpz_init_set_str");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int __gmpz_init_set_str(mpz_ptr, const char *, int)
     * }
     */
    public static FunctionDescriptor __gmpz_init_set_str$descriptor() {
        return __gmpz_init_set_str.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int __gmpz_init_set_str(mpz_ptr, const char *, int)
     * }
     */
    public static MethodHandle __gmpz_init_set_str$handle() {
        return __gmpz_init_set_str.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int __gmpz_init_set_str(mpz_ptr, const char *, int)
     * }
     */
    public static MemorySegment __gmpz_init_set_str$address() {
        return __gmpz_init_set_str.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int __gmpz_init_set_str(mpz_ptr, const char *, int)
     * }
     */
    public static int __gmpz_init_set_str(MemorySegment x0, MemorySegment x1, int x2) {
        var mh$ = __gmpz_init_set_str.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__gmpz_init_set_str", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __gmpz_init_set_ui {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gmp_h.C_POINTER,
            gmp_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__gmpz_init_set_ui");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void __gmpz_init_set_ui(mpz_ptr, unsigned long)
     * }
     */
    public static FunctionDescriptor __gmpz_init_set_ui$descriptor() {
        return __gmpz_init_set_ui.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void __gmpz_init_set_ui(mpz_ptr, unsigned long)
     * }
     */
    public static MethodHandle __gmpz_init_set_ui$handle() {
        return __gmpz_init_set_ui.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void __gmpz_init_set_ui(mpz_ptr, unsigned long)
     * }
     */
    public static MemorySegment __gmpz_init_set_ui$address() {
        return __gmpz_init_set_ui.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void __gmpz_init_set_ui(mpz_ptr, unsigned long)
     * }
     */
    public static void __gmpz_init_set_ui(MemorySegment x0, long x1) {
        var mh$ = __gmpz_init_set_ui.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__gmpz_init_set_ui", x0, x1);
            }
            mh$.invokeExact(x0, x1);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __gmpz_invert {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gmp_h.C_INT,
            gmp_h.C_POINTER,
            gmp_h.C_POINTER,
            gmp_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__gmpz_invert");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int __gmpz_invert(mpz_ptr, mpz_srcptr, mpz_srcptr)
     * }
     */
    public static FunctionDescriptor __gmpz_invert$descriptor() {
        return __gmpz_invert.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int __gmpz_invert(mpz_ptr, mpz_srcptr, mpz_srcptr)
     * }
     */
    public static MethodHandle __gmpz_invert$handle() {
        return __gmpz_invert.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int __gmpz_invert(mpz_ptr, mpz_srcptr, mpz_srcptr)
     * }
     */
    public static MemorySegment __gmpz_invert$address() {
        return __gmpz_invert.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int __gmpz_invert(mpz_ptr, mpz_srcptr, mpz_srcptr)
     * }
     */
    public static int __gmpz_invert(MemorySegment x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = __gmpz_invert.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__gmpz_invert", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __gmpz_ior {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gmp_h.C_POINTER,
            gmp_h.C_POINTER,
            gmp_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__gmpz_ior");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void __gmpz_ior(mpz_ptr, mpz_srcptr, mpz_srcptr)
     * }
     */
    public static FunctionDescriptor __gmpz_ior$descriptor() {
        return __gmpz_ior.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void __gmpz_ior(mpz_ptr, mpz_srcptr, mpz_srcptr)
     * }
     */
    public static MethodHandle __gmpz_ior$handle() {
        return __gmpz_ior.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void __gmpz_ior(mpz_ptr, mpz_srcptr, mpz_srcptr)
     * }
     */
    public static MemorySegment __gmpz_ior$address() {
        return __gmpz_ior.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void __gmpz_ior(mpz_ptr, mpz_srcptr, mpz_srcptr)
     * }
     */
    public static void __gmpz_ior(MemorySegment x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = __gmpz_ior.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__gmpz_ior", x0, x1, x2);
            }
            mh$.invokeExact(x0, x1, x2);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __gmpz_jacobi {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gmp_h.C_INT,
            gmp_h.C_POINTER,
            gmp_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__gmpz_jacobi");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int __gmpz_jacobi(mpz_srcptr, mpz_srcptr)
     * }
     */
    public static FunctionDescriptor __gmpz_jacobi$descriptor() {
        return __gmpz_jacobi.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int __gmpz_jacobi(mpz_srcptr, mpz_srcptr)
     * }
     */
    public static MethodHandle __gmpz_jacobi$handle() {
        return __gmpz_jacobi.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int __gmpz_jacobi(mpz_srcptr, mpz_srcptr)
     * }
     */
    public static MemorySegment __gmpz_jacobi$address() {
        return __gmpz_jacobi.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int __gmpz_jacobi(mpz_srcptr, mpz_srcptr)
     * }
     */
    public static int __gmpz_jacobi(MemorySegment x0, MemorySegment x1) {
        var mh$ = __gmpz_jacobi.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__gmpz_jacobi", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __gmpz_kronecker_si {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gmp_h.C_INT,
            gmp_h.C_POINTER,
            gmp_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__gmpz_kronecker_si");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int __gmpz_kronecker_si(mpz_srcptr, long)
     * }
     */
    public static FunctionDescriptor __gmpz_kronecker_si$descriptor() {
        return __gmpz_kronecker_si.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int __gmpz_kronecker_si(mpz_srcptr, long)
     * }
     */
    public static MethodHandle __gmpz_kronecker_si$handle() {
        return __gmpz_kronecker_si.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int __gmpz_kronecker_si(mpz_srcptr, long)
     * }
     */
    public static MemorySegment __gmpz_kronecker_si$address() {
        return __gmpz_kronecker_si.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int __gmpz_kronecker_si(mpz_srcptr, long)
     * }
     */
    public static int __gmpz_kronecker_si(MemorySegment x0, long x1) {
        var mh$ = __gmpz_kronecker_si.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__gmpz_kronecker_si", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __gmpz_kronecker_ui {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gmp_h.C_INT,
            gmp_h.C_POINTER,
            gmp_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__gmpz_kronecker_ui");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int __gmpz_kronecker_ui(mpz_srcptr, unsigned long)
     * }
     */
    public static FunctionDescriptor __gmpz_kronecker_ui$descriptor() {
        return __gmpz_kronecker_ui.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int __gmpz_kronecker_ui(mpz_srcptr, unsigned long)
     * }
     */
    public static MethodHandle __gmpz_kronecker_ui$handle() {
        return __gmpz_kronecker_ui.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int __gmpz_kronecker_ui(mpz_srcptr, unsigned long)
     * }
     */
    public static MemorySegment __gmpz_kronecker_ui$address() {
        return __gmpz_kronecker_ui.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int __gmpz_kronecker_ui(mpz_srcptr, unsigned long)
     * }
     */
    public static int __gmpz_kronecker_ui(MemorySegment x0, long x1) {
        var mh$ = __gmpz_kronecker_ui.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__gmpz_kronecker_ui", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __gmpz_si_kronecker {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gmp_h.C_INT,
            gmp_h.C_LONG,
            gmp_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__gmpz_si_kronecker");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int __gmpz_si_kronecker(long, mpz_srcptr)
     * }
     */
    public static FunctionDescriptor __gmpz_si_kronecker$descriptor() {
        return __gmpz_si_kronecker.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int __gmpz_si_kronecker(long, mpz_srcptr)
     * }
     */
    public static MethodHandle __gmpz_si_kronecker$handle() {
        return __gmpz_si_kronecker.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int __gmpz_si_kronecker(long, mpz_srcptr)
     * }
     */
    public static MemorySegment __gmpz_si_kronecker$address() {
        return __gmpz_si_kronecker.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int __gmpz_si_kronecker(long, mpz_srcptr)
     * }
     */
    public static int __gmpz_si_kronecker(long x0, MemorySegment x1) {
        var mh$ = __gmpz_si_kronecker.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__gmpz_si_kronecker", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __gmpz_ui_kronecker {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gmp_h.C_INT,
            gmp_h.C_LONG,
            gmp_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__gmpz_ui_kronecker");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int __gmpz_ui_kronecker(unsigned long, mpz_srcptr)
     * }
     */
    public static FunctionDescriptor __gmpz_ui_kronecker$descriptor() {
        return __gmpz_ui_kronecker.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int __gmpz_ui_kronecker(unsigned long, mpz_srcptr)
     * }
     */
    public static MethodHandle __gmpz_ui_kronecker$handle() {
        return __gmpz_ui_kronecker.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int __gmpz_ui_kronecker(unsigned long, mpz_srcptr)
     * }
     */
    public static MemorySegment __gmpz_ui_kronecker$address() {
        return __gmpz_ui_kronecker.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int __gmpz_ui_kronecker(unsigned long, mpz_srcptr)
     * }
     */
    public static int __gmpz_ui_kronecker(long x0, MemorySegment x1) {
        var mh$ = __gmpz_ui_kronecker.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__gmpz_ui_kronecker", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __gmpz_lcm {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gmp_h.C_POINTER,
            gmp_h.C_POINTER,
            gmp_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__gmpz_lcm");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void __gmpz_lcm(mpz_ptr, mpz_srcptr, mpz_srcptr)
     * }
     */
    public static FunctionDescriptor __gmpz_lcm$descriptor() {
        return __gmpz_lcm.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void __gmpz_lcm(mpz_ptr, mpz_srcptr, mpz_srcptr)
     * }
     */
    public static MethodHandle __gmpz_lcm$handle() {
        return __gmpz_lcm.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void __gmpz_lcm(mpz_ptr, mpz_srcptr, mpz_srcptr)
     * }
     */
    public static MemorySegment __gmpz_lcm$address() {
        return __gmpz_lcm.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void __gmpz_lcm(mpz_ptr, mpz_srcptr, mpz_srcptr)
     * }
     */
    public static void __gmpz_lcm(MemorySegment x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = __gmpz_lcm.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__gmpz_lcm", x0, x1, x2);
            }
            mh$.invokeExact(x0, x1, x2);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __gmpz_lcm_ui {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gmp_h.C_POINTER,
            gmp_h.C_POINTER,
            gmp_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__gmpz_lcm_ui");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void __gmpz_lcm_ui(mpz_ptr, mpz_srcptr, unsigned long)
     * }
     */
    public static FunctionDescriptor __gmpz_lcm_ui$descriptor() {
        return __gmpz_lcm_ui.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void __gmpz_lcm_ui(mpz_ptr, mpz_srcptr, unsigned long)
     * }
     */
    public static MethodHandle __gmpz_lcm_ui$handle() {
        return __gmpz_lcm_ui.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void __gmpz_lcm_ui(mpz_ptr, mpz_srcptr, unsigned long)
     * }
     */
    public static MemorySegment __gmpz_lcm_ui$address() {
        return __gmpz_lcm_ui.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void __gmpz_lcm_ui(mpz_ptr, mpz_srcptr, unsigned long)
     * }
     */
    public static void __gmpz_lcm_ui(MemorySegment x0, MemorySegment x1, long x2) {
        var mh$ = __gmpz_lcm_ui.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__gmpz_lcm_ui", x0, x1, x2);
            }
            mh$.invokeExact(x0, x1, x2);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __gmpz_lucnum_ui {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gmp_h.C_POINTER,
            gmp_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__gmpz_lucnum_ui");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void __gmpz_lucnum_ui(mpz_ptr, unsigned long)
     * }
     */
    public static FunctionDescriptor __gmpz_lucnum_ui$descriptor() {
        return __gmpz_lucnum_ui.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void __gmpz_lucnum_ui(mpz_ptr, unsigned long)
     * }
     */
    public static MethodHandle __gmpz_lucnum_ui$handle() {
        return __gmpz_lucnum_ui.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void __gmpz_lucnum_ui(mpz_ptr, unsigned long)
     * }
     */
    public static MemorySegment __gmpz_lucnum_ui$address() {
        return __gmpz_lucnum_ui.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void __gmpz_lucnum_ui(mpz_ptr, unsigned long)
     * }
     */
    public static void __gmpz_lucnum_ui(MemorySegment x0, long x1) {
        var mh$ = __gmpz_lucnum_ui.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__gmpz_lucnum_ui", x0, x1);
            }
            mh$.invokeExact(x0, x1);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __gmpz_lucnum2_ui {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gmp_h.C_POINTER,
            gmp_h.C_POINTER,
            gmp_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__gmpz_lucnum2_ui");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void __gmpz_lucnum2_ui(mpz_ptr, mpz_ptr, unsigned long)
     * }
     */
    public static FunctionDescriptor __gmpz_lucnum2_ui$descriptor() {
        return __gmpz_lucnum2_ui.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void __gmpz_lucnum2_ui(mpz_ptr, mpz_ptr, unsigned long)
     * }
     */
    public static MethodHandle __gmpz_lucnum2_ui$handle() {
        return __gmpz_lucnum2_ui.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void __gmpz_lucnum2_ui(mpz_ptr, mpz_ptr, unsigned long)
     * }
     */
    public static MemorySegment __gmpz_lucnum2_ui$address() {
        return __gmpz_lucnum2_ui.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void __gmpz_lucnum2_ui(mpz_ptr, mpz_ptr, unsigned long)
     * }
     */
    public static void __gmpz_lucnum2_ui(MemorySegment x0, MemorySegment x1, long x2) {
        var mh$ = __gmpz_lucnum2_ui.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__gmpz_lucnum2_ui", x0, x1, x2);
            }
            mh$.invokeExact(x0, x1, x2);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __gmpz_millerrabin {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gmp_h.C_INT,
            gmp_h.C_POINTER,
            gmp_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__gmpz_millerrabin");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int __gmpz_millerrabin(mpz_srcptr, int)
     * }
     */
    public static FunctionDescriptor __gmpz_millerrabin$descriptor() {
        return __gmpz_millerrabin.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int __gmpz_millerrabin(mpz_srcptr, int)
     * }
     */
    public static MethodHandle __gmpz_millerrabin$handle() {
        return __gmpz_millerrabin.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int __gmpz_millerrabin(mpz_srcptr, int)
     * }
     */
    public static MemorySegment __gmpz_millerrabin$address() {
        return __gmpz_millerrabin.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int __gmpz_millerrabin(mpz_srcptr, int)
     * }
     */
    public static int __gmpz_millerrabin(MemorySegment x0, int x1) {
        var mh$ = __gmpz_millerrabin.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__gmpz_millerrabin", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __gmpz_mod {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gmp_h.C_POINTER,
            gmp_h.C_POINTER,
            gmp_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__gmpz_mod");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void __gmpz_mod(mpz_ptr, mpz_srcptr, mpz_srcptr)
     * }
     */
    public static FunctionDescriptor __gmpz_mod$descriptor() {
        return __gmpz_mod.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void __gmpz_mod(mpz_ptr, mpz_srcptr, mpz_srcptr)
     * }
     */
    public static MethodHandle __gmpz_mod$handle() {
        return __gmpz_mod.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void __gmpz_mod(mpz_ptr, mpz_srcptr, mpz_srcptr)
     * }
     */
    public static MemorySegment __gmpz_mod$address() {
        return __gmpz_mod.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void __gmpz_mod(mpz_ptr, mpz_srcptr, mpz_srcptr)
     * }
     */
    public static void __gmpz_mod(MemorySegment x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = __gmpz_mod.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__gmpz_mod", x0, x1, x2);
            }
            mh$.invokeExact(x0, x1, x2);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __gmpz_mul {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gmp_h.C_POINTER,
            gmp_h.C_POINTER,
            gmp_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__gmpz_mul");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void __gmpz_mul(mpz_ptr, mpz_srcptr, mpz_srcptr)
     * }
     */
    public static FunctionDescriptor __gmpz_mul$descriptor() {
        return __gmpz_mul.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void __gmpz_mul(mpz_ptr, mpz_srcptr, mpz_srcptr)
     * }
     */
    public static MethodHandle __gmpz_mul$handle() {
        return __gmpz_mul.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void __gmpz_mul(mpz_ptr, mpz_srcptr, mpz_srcptr)
     * }
     */
    public static MemorySegment __gmpz_mul$address() {
        return __gmpz_mul.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void __gmpz_mul(mpz_ptr, mpz_srcptr, mpz_srcptr)
     * }
     */
    public static void __gmpz_mul(MemorySegment x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = __gmpz_mul.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__gmpz_mul", x0, x1, x2);
            }
            mh$.invokeExact(x0, x1, x2);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __gmpz_mul_2exp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gmp_h.C_POINTER,
            gmp_h.C_POINTER,
            gmp_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__gmpz_mul_2exp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void __gmpz_mul_2exp(mpz_ptr, mpz_srcptr, mp_bitcnt_t)
     * }
     */
    public static FunctionDescriptor __gmpz_mul_2exp$descriptor() {
        return __gmpz_mul_2exp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void __gmpz_mul_2exp(mpz_ptr, mpz_srcptr, mp_bitcnt_t)
     * }
     */
    public static MethodHandle __gmpz_mul_2exp$handle() {
        return __gmpz_mul_2exp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void __gmpz_mul_2exp(mpz_ptr, mpz_srcptr, mp_bitcnt_t)
     * }
     */
    public static MemorySegment __gmpz_mul_2exp$address() {
        return __gmpz_mul_2exp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void __gmpz_mul_2exp(mpz_ptr, mpz_srcptr, mp_bitcnt_t)
     * }
     */
    public static void __gmpz_mul_2exp(MemorySegment x0, MemorySegment x1, long x2) {
        var mh$ = __gmpz_mul_2exp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__gmpz_mul_2exp", x0, x1, x2);
            }
            mh$.invokeExact(x0, x1, x2);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __gmpz_mul_si {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gmp_h.C_POINTER,
            gmp_h.C_POINTER,
            gmp_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__gmpz_mul_si");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void __gmpz_mul_si(mpz_ptr, mpz_srcptr, long)
     * }
     */
    public static FunctionDescriptor __gmpz_mul_si$descriptor() {
        return __gmpz_mul_si.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void __gmpz_mul_si(mpz_ptr, mpz_srcptr, long)
     * }
     */
    public static MethodHandle __gmpz_mul_si$handle() {
        return __gmpz_mul_si.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void __gmpz_mul_si(mpz_ptr, mpz_srcptr, long)
     * }
     */
    public static MemorySegment __gmpz_mul_si$address() {
        return __gmpz_mul_si.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void __gmpz_mul_si(mpz_ptr, mpz_srcptr, long)
     * }
     */
    public static void __gmpz_mul_si(MemorySegment x0, MemorySegment x1, long x2) {
        var mh$ = __gmpz_mul_si.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__gmpz_mul_si", x0, x1, x2);
            }
            mh$.invokeExact(x0, x1, x2);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __gmpz_mul_ui {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gmp_h.C_POINTER,
            gmp_h.C_POINTER,
            gmp_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__gmpz_mul_ui");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void __gmpz_mul_ui(mpz_ptr, mpz_srcptr, unsigned long)
     * }
     */
    public static FunctionDescriptor __gmpz_mul_ui$descriptor() {
        return __gmpz_mul_ui.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void __gmpz_mul_ui(mpz_ptr, mpz_srcptr, unsigned long)
     * }
     */
    public static MethodHandle __gmpz_mul_ui$handle() {
        return __gmpz_mul_ui.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void __gmpz_mul_ui(mpz_ptr, mpz_srcptr, unsigned long)
     * }
     */
    public static MemorySegment __gmpz_mul_ui$address() {
        return __gmpz_mul_ui.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void __gmpz_mul_ui(mpz_ptr, mpz_srcptr, unsigned long)
     * }
     */
    public static void __gmpz_mul_ui(MemorySegment x0, MemorySegment x1, long x2) {
        var mh$ = __gmpz_mul_ui.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__gmpz_mul_ui", x0, x1, x2);
            }
            mh$.invokeExact(x0, x1, x2);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __gmpz_neg {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gmp_h.C_POINTER,
            gmp_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__gmpz_neg");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void __gmpz_neg(mpz_ptr, mpz_srcptr)
     * }
     */
    public static FunctionDescriptor __gmpz_neg$descriptor() {
        return __gmpz_neg.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void __gmpz_neg(mpz_ptr, mpz_srcptr)
     * }
     */
    public static MethodHandle __gmpz_neg$handle() {
        return __gmpz_neg.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void __gmpz_neg(mpz_ptr, mpz_srcptr)
     * }
     */
    public static MemorySegment __gmpz_neg$address() {
        return __gmpz_neg.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void __gmpz_neg(mpz_ptr, mpz_srcptr)
     * }
     */
    public static void __gmpz_neg(MemorySegment x0, MemorySegment x1) {
        var mh$ = __gmpz_neg.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__gmpz_neg", x0, x1);
            }
            mh$.invokeExact(x0, x1);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __gmpz_nextprime {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gmp_h.C_POINTER,
            gmp_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__gmpz_nextprime");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void __gmpz_nextprime(mpz_ptr, mpz_srcptr)
     * }
     */
    public static FunctionDescriptor __gmpz_nextprime$descriptor() {
        return __gmpz_nextprime.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void __gmpz_nextprime(mpz_ptr, mpz_srcptr)
     * }
     */
    public static MethodHandle __gmpz_nextprime$handle() {
        return __gmpz_nextprime.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void __gmpz_nextprime(mpz_ptr, mpz_srcptr)
     * }
     */
    public static MemorySegment __gmpz_nextprime$address() {
        return __gmpz_nextprime.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void __gmpz_nextprime(mpz_ptr, mpz_srcptr)
     * }
     */
    public static void __gmpz_nextprime(MemorySegment x0, MemorySegment x1) {
        var mh$ = __gmpz_nextprime.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__gmpz_nextprime", x0, x1);
            }
            mh$.invokeExact(x0, x1);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __gmpz_prevprime {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gmp_h.C_INT,
            gmp_h.C_POINTER,
            gmp_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__gmpz_prevprime");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int __gmpz_prevprime(mpz_ptr, mpz_srcptr)
     * }
     */
    public static FunctionDescriptor __gmpz_prevprime$descriptor() {
        return __gmpz_prevprime.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int __gmpz_prevprime(mpz_ptr, mpz_srcptr)
     * }
     */
    public static MethodHandle __gmpz_prevprime$handle() {
        return __gmpz_prevprime.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int __gmpz_prevprime(mpz_ptr, mpz_srcptr)
     * }
     */
    public static MemorySegment __gmpz_prevprime$address() {
        return __gmpz_prevprime.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int __gmpz_prevprime(mpz_ptr, mpz_srcptr)
     * }
     */
    public static int __gmpz_prevprime(MemorySegment x0, MemorySegment x1) {
        var mh$ = __gmpz_prevprime.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__gmpz_prevprime", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __gmpz_perfect_power_p {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gmp_h.C_INT,
            gmp_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__gmpz_perfect_power_p");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int __gmpz_perfect_power_p(mpz_srcptr)
     * }
     */
    public static FunctionDescriptor __gmpz_perfect_power_p$descriptor() {
        return __gmpz_perfect_power_p.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int __gmpz_perfect_power_p(mpz_srcptr)
     * }
     */
    public static MethodHandle __gmpz_perfect_power_p$handle() {
        return __gmpz_perfect_power_p.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int __gmpz_perfect_power_p(mpz_srcptr)
     * }
     */
    public static MemorySegment __gmpz_perfect_power_p$address() {
        return __gmpz_perfect_power_p.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int __gmpz_perfect_power_p(mpz_srcptr)
     * }
     */
    public static int __gmpz_perfect_power_p(MemorySegment x0) {
        var mh$ = __gmpz_perfect_power_p.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__gmpz_perfect_power_p", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __gmpz_perfect_square_p {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gmp_h.C_INT,
            gmp_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__gmpz_perfect_square_p");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int __gmpz_perfect_square_p(mpz_srcptr)
     * }
     */
    public static FunctionDescriptor __gmpz_perfect_square_p$descriptor() {
        return __gmpz_perfect_square_p.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int __gmpz_perfect_square_p(mpz_srcptr)
     * }
     */
    public static MethodHandle __gmpz_perfect_square_p$handle() {
        return __gmpz_perfect_square_p.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int __gmpz_perfect_square_p(mpz_srcptr)
     * }
     */
    public static MemorySegment __gmpz_perfect_square_p$address() {
        return __gmpz_perfect_square_p.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int __gmpz_perfect_square_p(mpz_srcptr)
     * }
     */
    public static int __gmpz_perfect_square_p(MemorySegment x0) {
        var mh$ = __gmpz_perfect_square_p.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__gmpz_perfect_square_p", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __gmpz_popcount {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gmp_h.C_LONG,
            gmp_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__gmpz_popcount");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * mp_bitcnt_t __gmpz_popcount(mpz_srcptr)
     * }
     */
    public static FunctionDescriptor __gmpz_popcount$descriptor() {
        return __gmpz_popcount.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * mp_bitcnt_t __gmpz_popcount(mpz_srcptr)
     * }
     */
    public static MethodHandle __gmpz_popcount$handle() {
        return __gmpz_popcount.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * mp_bitcnt_t __gmpz_popcount(mpz_srcptr)
     * }
     */
    public static MemorySegment __gmpz_popcount$address() {
        return __gmpz_popcount.ADDR;
    }

    /**
     * {@snippet lang=c :
     * mp_bitcnt_t __gmpz_popcount(mpz_srcptr)
     * }
     */
    public static long __gmpz_popcount(MemorySegment x0) {
        var mh$ = __gmpz_popcount.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__gmpz_popcount", x0);
            }
            return (long)mh$.invokeExact(x0);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __gmpz_pow_ui {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gmp_h.C_POINTER,
            gmp_h.C_POINTER,
            gmp_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__gmpz_pow_ui");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void __gmpz_pow_ui(mpz_ptr, mpz_srcptr, unsigned long)
     * }
     */
    public static FunctionDescriptor __gmpz_pow_ui$descriptor() {
        return __gmpz_pow_ui.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void __gmpz_pow_ui(mpz_ptr, mpz_srcptr, unsigned long)
     * }
     */
    public static MethodHandle __gmpz_pow_ui$handle() {
        return __gmpz_pow_ui.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void __gmpz_pow_ui(mpz_ptr, mpz_srcptr, unsigned long)
     * }
     */
    public static MemorySegment __gmpz_pow_ui$address() {
        return __gmpz_pow_ui.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void __gmpz_pow_ui(mpz_ptr, mpz_srcptr, unsigned long)
     * }
     */
    public static void __gmpz_pow_ui(MemorySegment x0, MemorySegment x1, long x2) {
        var mh$ = __gmpz_pow_ui.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__gmpz_pow_ui", x0, x1, x2);
            }
            mh$.invokeExact(x0, x1, x2);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __gmpz_powm {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gmp_h.C_POINTER,
            gmp_h.C_POINTER,
            gmp_h.C_POINTER,
            gmp_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__gmpz_powm");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void __gmpz_powm(mpz_ptr, mpz_srcptr, mpz_srcptr, mpz_srcptr)
     * }
     */
    public static FunctionDescriptor __gmpz_powm$descriptor() {
        return __gmpz_powm.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void __gmpz_powm(mpz_ptr, mpz_srcptr, mpz_srcptr, mpz_srcptr)
     * }
     */
    public static MethodHandle __gmpz_powm$handle() {
        return __gmpz_powm.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void __gmpz_powm(mpz_ptr, mpz_srcptr, mpz_srcptr, mpz_srcptr)
     * }
     */
    public static MemorySegment __gmpz_powm$address() {
        return __gmpz_powm.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void __gmpz_powm(mpz_ptr, mpz_srcptr, mpz_srcptr, mpz_srcptr)
     * }
     */
    public static void __gmpz_powm(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = __gmpz_powm.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__gmpz_powm", x0, x1, x2, x3);
            }
            mh$.invokeExact(x0, x1, x2, x3);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __gmpz_powm_sec {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gmp_h.C_POINTER,
            gmp_h.C_POINTER,
            gmp_h.C_POINTER,
            gmp_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__gmpz_powm_sec");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void __gmpz_powm_sec(mpz_ptr, mpz_srcptr, mpz_srcptr, mpz_srcptr)
     * }
     */
    public static FunctionDescriptor __gmpz_powm_sec$descriptor() {
        return __gmpz_powm_sec.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void __gmpz_powm_sec(mpz_ptr, mpz_srcptr, mpz_srcptr, mpz_srcptr)
     * }
     */
    public static MethodHandle __gmpz_powm_sec$handle() {
        return __gmpz_powm_sec.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void __gmpz_powm_sec(mpz_ptr, mpz_srcptr, mpz_srcptr, mpz_srcptr)
     * }
     */
    public static MemorySegment __gmpz_powm_sec$address() {
        return __gmpz_powm_sec.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void __gmpz_powm_sec(mpz_ptr, mpz_srcptr, mpz_srcptr, mpz_srcptr)
     * }
     */
    public static void __gmpz_powm_sec(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = __gmpz_powm_sec.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__gmpz_powm_sec", x0, x1, x2, x3);
            }
            mh$.invokeExact(x0, x1, x2, x3);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __gmpz_powm_ui {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gmp_h.C_POINTER,
            gmp_h.C_POINTER,
            gmp_h.C_LONG,
            gmp_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__gmpz_powm_ui");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void __gmpz_powm_ui(mpz_ptr, mpz_srcptr, unsigned long, mpz_srcptr)
     * }
     */
    public static FunctionDescriptor __gmpz_powm_ui$descriptor() {
        return __gmpz_powm_ui.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void __gmpz_powm_ui(mpz_ptr, mpz_srcptr, unsigned long, mpz_srcptr)
     * }
     */
    public static MethodHandle __gmpz_powm_ui$handle() {
        return __gmpz_powm_ui.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void __gmpz_powm_ui(mpz_ptr, mpz_srcptr, unsigned long, mpz_srcptr)
     * }
     */
    public static MemorySegment __gmpz_powm_ui$address() {
        return __gmpz_powm_ui.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void __gmpz_powm_ui(mpz_ptr, mpz_srcptr, unsigned long, mpz_srcptr)
     * }
     */
    public static void __gmpz_powm_ui(MemorySegment x0, MemorySegment x1, long x2, MemorySegment x3) {
        var mh$ = __gmpz_powm_ui.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__gmpz_powm_ui", x0, x1, x2, x3);
            }
            mh$.invokeExact(x0, x1, x2, x3);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __gmpz_probab_prime_p {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gmp_h.C_INT,
            gmp_h.C_POINTER,
            gmp_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__gmpz_probab_prime_p");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int __gmpz_probab_prime_p(mpz_srcptr, int)
     * }
     */
    public static FunctionDescriptor __gmpz_probab_prime_p$descriptor() {
        return __gmpz_probab_prime_p.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int __gmpz_probab_prime_p(mpz_srcptr, int)
     * }
     */
    public static MethodHandle __gmpz_probab_prime_p$handle() {
        return __gmpz_probab_prime_p.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int __gmpz_probab_prime_p(mpz_srcptr, int)
     * }
     */
    public static MemorySegment __gmpz_probab_prime_p$address() {
        return __gmpz_probab_prime_p.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int __gmpz_probab_prime_p(mpz_srcptr, int)
     * }
     */
    public static int __gmpz_probab_prime_p(MemorySegment x0, int x1) {
        var mh$ = __gmpz_probab_prime_p.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__gmpz_probab_prime_p", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __gmpz_random {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gmp_h.C_POINTER,
            gmp_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__gmpz_random");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void __gmpz_random(mpz_ptr, mp_size_t)
     * }
     */
    public static FunctionDescriptor __gmpz_random$descriptor() {
        return __gmpz_random.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void __gmpz_random(mpz_ptr, mp_size_t)
     * }
     */
    public static MethodHandle __gmpz_random$handle() {
        return __gmpz_random.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void __gmpz_random(mpz_ptr, mp_size_t)
     * }
     */
    public static MemorySegment __gmpz_random$address() {
        return __gmpz_random.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void __gmpz_random(mpz_ptr, mp_size_t)
     * }
     */
    public static void __gmpz_random(MemorySegment x0, long x1) {
        var mh$ = __gmpz_random.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__gmpz_random", x0, x1);
            }
            mh$.invokeExact(x0, x1);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __gmpz_random2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gmp_h.C_POINTER,
            gmp_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__gmpz_random2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void __gmpz_random2(mpz_ptr, mp_size_t)
     * }
     */
    public static FunctionDescriptor __gmpz_random2$descriptor() {
        return __gmpz_random2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void __gmpz_random2(mpz_ptr, mp_size_t)
     * }
     */
    public static MethodHandle __gmpz_random2$handle() {
        return __gmpz_random2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void __gmpz_random2(mpz_ptr, mp_size_t)
     * }
     */
    public static MemorySegment __gmpz_random2$address() {
        return __gmpz_random2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void __gmpz_random2(mpz_ptr, mp_size_t)
     * }
     */
    public static void __gmpz_random2(MemorySegment x0, long x1) {
        var mh$ = __gmpz_random2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__gmpz_random2", x0, x1);
            }
            mh$.invokeExact(x0, x1);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __gmpz_realloc2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gmp_h.C_POINTER,
            gmp_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__gmpz_realloc2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void __gmpz_realloc2(mpz_ptr, mp_bitcnt_t)
     * }
     */
    public static FunctionDescriptor __gmpz_realloc2$descriptor() {
        return __gmpz_realloc2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void __gmpz_realloc2(mpz_ptr, mp_bitcnt_t)
     * }
     */
    public static MethodHandle __gmpz_realloc2$handle() {
        return __gmpz_realloc2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void __gmpz_realloc2(mpz_ptr, mp_bitcnt_t)
     * }
     */
    public static MemorySegment __gmpz_realloc2$address() {
        return __gmpz_realloc2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void __gmpz_realloc2(mpz_ptr, mp_bitcnt_t)
     * }
     */
    public static void __gmpz_realloc2(MemorySegment x0, long x1) {
        var mh$ = __gmpz_realloc2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__gmpz_realloc2", x0, x1);
            }
            mh$.invokeExact(x0, x1);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __gmpz_remove {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gmp_h.C_LONG,
            gmp_h.C_POINTER,
            gmp_h.C_POINTER,
            gmp_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__gmpz_remove");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * mp_bitcnt_t __gmpz_remove(mpz_ptr, mpz_srcptr, mpz_srcptr)
     * }
     */
    public static FunctionDescriptor __gmpz_remove$descriptor() {
        return __gmpz_remove.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * mp_bitcnt_t __gmpz_remove(mpz_ptr, mpz_srcptr, mpz_srcptr)
     * }
     */
    public static MethodHandle __gmpz_remove$handle() {
        return __gmpz_remove.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * mp_bitcnt_t __gmpz_remove(mpz_ptr, mpz_srcptr, mpz_srcptr)
     * }
     */
    public static MemorySegment __gmpz_remove$address() {
        return __gmpz_remove.ADDR;
    }

    /**
     * {@snippet lang=c :
     * mp_bitcnt_t __gmpz_remove(mpz_ptr, mpz_srcptr, mpz_srcptr)
     * }
     */
    public static long __gmpz_remove(MemorySegment x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = __gmpz_remove.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__gmpz_remove", x0, x1, x2);
            }
            return (long)mh$.invokeExact(x0, x1, x2);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __gmpz_root {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gmp_h.C_INT,
            gmp_h.C_POINTER,
            gmp_h.C_POINTER,
            gmp_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__gmpz_root");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int __gmpz_root(mpz_ptr, mpz_srcptr, unsigned long)
     * }
     */
    public static FunctionDescriptor __gmpz_root$descriptor() {
        return __gmpz_root.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int __gmpz_root(mpz_ptr, mpz_srcptr, unsigned long)
     * }
     */
    public static MethodHandle __gmpz_root$handle() {
        return __gmpz_root.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int __gmpz_root(mpz_ptr, mpz_srcptr, unsigned long)
     * }
     */
    public static MemorySegment __gmpz_root$address() {
        return __gmpz_root.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int __gmpz_root(mpz_ptr, mpz_srcptr, unsigned long)
     * }
     */
    public static int __gmpz_root(MemorySegment x0, MemorySegment x1, long x2) {
        var mh$ = __gmpz_root.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__gmpz_root", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __gmpz_rootrem {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gmp_h.C_POINTER,
            gmp_h.C_POINTER,
            gmp_h.C_POINTER,
            gmp_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__gmpz_rootrem");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void __gmpz_rootrem(mpz_ptr, mpz_ptr, mpz_srcptr, unsigned long)
     * }
     */
    public static FunctionDescriptor __gmpz_rootrem$descriptor() {
        return __gmpz_rootrem.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void __gmpz_rootrem(mpz_ptr, mpz_ptr, mpz_srcptr, unsigned long)
     * }
     */
    public static MethodHandle __gmpz_rootrem$handle() {
        return __gmpz_rootrem.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void __gmpz_rootrem(mpz_ptr, mpz_ptr, mpz_srcptr, unsigned long)
     * }
     */
    public static MemorySegment __gmpz_rootrem$address() {
        return __gmpz_rootrem.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void __gmpz_rootrem(mpz_ptr, mpz_ptr, mpz_srcptr, unsigned long)
     * }
     */
    public static void __gmpz_rootrem(MemorySegment x0, MemorySegment x1, MemorySegment x2, long x3) {
        var mh$ = __gmpz_rootrem.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__gmpz_rootrem", x0, x1, x2, x3);
            }
            mh$.invokeExact(x0, x1, x2, x3);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __gmpz_rrandomb {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gmp_h.C_POINTER,
            gmp_h.C_POINTER,
            gmp_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__gmpz_rrandomb");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void __gmpz_rrandomb(mpz_ptr, gmp_randstate_ptr, mp_bitcnt_t)
     * }
     */
    public static FunctionDescriptor __gmpz_rrandomb$descriptor() {
        return __gmpz_rrandomb.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void __gmpz_rrandomb(mpz_ptr, gmp_randstate_ptr, mp_bitcnt_t)
     * }
     */
    public static MethodHandle __gmpz_rrandomb$handle() {
        return __gmpz_rrandomb.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void __gmpz_rrandomb(mpz_ptr, gmp_randstate_ptr, mp_bitcnt_t)
     * }
     */
    public static MemorySegment __gmpz_rrandomb$address() {
        return __gmpz_rrandomb.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void __gmpz_rrandomb(mpz_ptr, gmp_randstate_ptr, mp_bitcnt_t)
     * }
     */
    public static void __gmpz_rrandomb(MemorySegment x0, MemorySegment x1, long x2) {
        var mh$ = __gmpz_rrandomb.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__gmpz_rrandomb", x0, x1, x2);
            }
            mh$.invokeExact(x0, x1, x2);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __gmpz_scan0 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gmp_h.C_LONG,
            gmp_h.C_POINTER,
            gmp_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__gmpz_scan0");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * mp_bitcnt_t __gmpz_scan0(mpz_srcptr, mp_bitcnt_t)
     * }
     */
    public static FunctionDescriptor __gmpz_scan0$descriptor() {
        return __gmpz_scan0.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * mp_bitcnt_t __gmpz_scan0(mpz_srcptr, mp_bitcnt_t)
     * }
     */
    public static MethodHandle __gmpz_scan0$handle() {
        return __gmpz_scan0.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * mp_bitcnt_t __gmpz_scan0(mpz_srcptr, mp_bitcnt_t)
     * }
     */
    public static MemorySegment __gmpz_scan0$address() {
        return __gmpz_scan0.ADDR;
    }

    /**
     * {@snippet lang=c :
     * mp_bitcnt_t __gmpz_scan0(mpz_srcptr, mp_bitcnt_t)
     * }
     */
    public static long __gmpz_scan0(MemorySegment x0, long x1) {
        var mh$ = __gmpz_scan0.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__gmpz_scan0", x0, x1);
            }
            return (long)mh$.invokeExact(x0, x1);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __gmpz_scan1 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gmp_h.C_LONG,
            gmp_h.C_POINTER,
            gmp_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__gmpz_scan1");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * mp_bitcnt_t __gmpz_scan1(mpz_srcptr, mp_bitcnt_t)
     * }
     */
    public static FunctionDescriptor __gmpz_scan1$descriptor() {
        return __gmpz_scan1.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * mp_bitcnt_t __gmpz_scan1(mpz_srcptr, mp_bitcnt_t)
     * }
     */
    public static MethodHandle __gmpz_scan1$handle() {
        return __gmpz_scan1.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * mp_bitcnt_t __gmpz_scan1(mpz_srcptr, mp_bitcnt_t)
     * }
     */
    public static MemorySegment __gmpz_scan1$address() {
        return __gmpz_scan1.ADDR;
    }

    /**
     * {@snippet lang=c :
     * mp_bitcnt_t __gmpz_scan1(mpz_srcptr, mp_bitcnt_t)
     * }
     */
    public static long __gmpz_scan1(MemorySegment x0, long x1) {
        var mh$ = __gmpz_scan1.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__gmpz_scan1", x0, x1);
            }
            return (long)mh$.invokeExact(x0, x1);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __gmpz_set {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gmp_h.C_POINTER,
            gmp_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__gmpz_set");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void __gmpz_set(mpz_ptr, mpz_srcptr)
     * }
     */
    public static FunctionDescriptor __gmpz_set$descriptor() {
        return __gmpz_set.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void __gmpz_set(mpz_ptr, mpz_srcptr)
     * }
     */
    public static MethodHandle __gmpz_set$handle() {
        return __gmpz_set.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void __gmpz_set(mpz_ptr, mpz_srcptr)
     * }
     */
    public static MemorySegment __gmpz_set$address() {
        return __gmpz_set.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void __gmpz_set(mpz_ptr, mpz_srcptr)
     * }
     */
    public static void __gmpz_set(MemorySegment x0, MemorySegment x1) {
        var mh$ = __gmpz_set.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__gmpz_set", x0, x1);
            }
            mh$.invokeExact(x0, x1);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __gmpz_set_d {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gmp_h.C_POINTER,
            gmp_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__gmpz_set_d");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void __gmpz_set_d(mpz_ptr, double)
     * }
     */
    public static FunctionDescriptor __gmpz_set_d$descriptor() {
        return __gmpz_set_d.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void __gmpz_set_d(mpz_ptr, double)
     * }
     */
    public static MethodHandle __gmpz_set_d$handle() {
        return __gmpz_set_d.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void __gmpz_set_d(mpz_ptr, double)
     * }
     */
    public static MemorySegment __gmpz_set_d$address() {
        return __gmpz_set_d.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void __gmpz_set_d(mpz_ptr, double)
     * }
     */
    public static void __gmpz_set_d(MemorySegment x0, double x1) {
        var mh$ = __gmpz_set_d.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__gmpz_set_d", x0, x1);
            }
            mh$.invokeExact(x0, x1);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __gmpz_set_f {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gmp_h.C_POINTER,
            gmp_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__gmpz_set_f");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void __gmpz_set_f(mpz_ptr, mpf_srcptr)
     * }
     */
    public static FunctionDescriptor __gmpz_set_f$descriptor() {
        return __gmpz_set_f.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void __gmpz_set_f(mpz_ptr, mpf_srcptr)
     * }
     */
    public static MethodHandle __gmpz_set_f$handle() {
        return __gmpz_set_f.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void __gmpz_set_f(mpz_ptr, mpf_srcptr)
     * }
     */
    public static MemorySegment __gmpz_set_f$address() {
        return __gmpz_set_f.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void __gmpz_set_f(mpz_ptr, mpf_srcptr)
     * }
     */
    public static void __gmpz_set_f(MemorySegment x0, MemorySegment x1) {
        var mh$ = __gmpz_set_f.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__gmpz_set_f", x0, x1);
            }
            mh$.invokeExact(x0, x1);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __gmpz_set_q {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gmp_h.C_POINTER,
            gmp_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__gmpz_set_q");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void __gmpz_set_q(mpz_ptr, mpq_srcptr)
     * }
     */
    public static FunctionDescriptor __gmpz_set_q$descriptor() {
        return __gmpz_set_q.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void __gmpz_set_q(mpz_ptr, mpq_srcptr)
     * }
     */
    public static MethodHandle __gmpz_set_q$handle() {
        return __gmpz_set_q.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void __gmpz_set_q(mpz_ptr, mpq_srcptr)
     * }
     */
    public static MemorySegment __gmpz_set_q$address() {
        return __gmpz_set_q.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void __gmpz_set_q(mpz_ptr, mpq_srcptr)
     * }
     */
    public static void __gmpz_set_q(MemorySegment x0, MemorySegment x1) {
        var mh$ = __gmpz_set_q.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__gmpz_set_q", x0, x1);
            }
            mh$.invokeExact(x0, x1);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __gmpz_set_si {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gmp_h.C_POINTER,
            gmp_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__gmpz_set_si");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void __gmpz_set_si(mpz_ptr, long)
     * }
     */
    public static FunctionDescriptor __gmpz_set_si$descriptor() {
        return __gmpz_set_si.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void __gmpz_set_si(mpz_ptr, long)
     * }
     */
    public static MethodHandle __gmpz_set_si$handle() {
        return __gmpz_set_si.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void __gmpz_set_si(mpz_ptr, long)
     * }
     */
    public static MemorySegment __gmpz_set_si$address() {
        return __gmpz_set_si.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void __gmpz_set_si(mpz_ptr, long)
     * }
     */
    public static void __gmpz_set_si(MemorySegment x0, long x1) {
        var mh$ = __gmpz_set_si.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__gmpz_set_si", x0, x1);
            }
            mh$.invokeExact(x0, x1);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __gmpz_set_str {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gmp_h.C_INT,
            gmp_h.C_POINTER,
            gmp_h.C_POINTER,
            gmp_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__gmpz_set_str");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int __gmpz_set_str(mpz_ptr, const char *, int)
     * }
     */
    public static FunctionDescriptor __gmpz_set_str$descriptor() {
        return __gmpz_set_str.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int __gmpz_set_str(mpz_ptr, const char *, int)
     * }
     */
    public static MethodHandle __gmpz_set_str$handle() {
        return __gmpz_set_str.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int __gmpz_set_str(mpz_ptr, const char *, int)
     * }
     */
    public static MemorySegment __gmpz_set_str$address() {
        return __gmpz_set_str.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int __gmpz_set_str(mpz_ptr, const char *, int)
     * }
     */
    public static int __gmpz_set_str(MemorySegment x0, MemorySegment x1, int x2) {
        var mh$ = __gmpz_set_str.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__gmpz_set_str", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __gmpz_set_ui {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gmp_h.C_POINTER,
            gmp_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__gmpz_set_ui");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void __gmpz_set_ui(mpz_ptr, unsigned long)
     * }
     */
    public static FunctionDescriptor __gmpz_set_ui$descriptor() {
        return __gmpz_set_ui.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void __gmpz_set_ui(mpz_ptr, unsigned long)
     * }
     */
    public static MethodHandle __gmpz_set_ui$handle() {
        return __gmpz_set_ui.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void __gmpz_set_ui(mpz_ptr, unsigned long)
     * }
     */
    public static MemorySegment __gmpz_set_ui$address() {
        return __gmpz_set_ui.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void __gmpz_set_ui(mpz_ptr, unsigned long)
     * }
     */
    public static void __gmpz_set_ui(MemorySegment x0, long x1) {
        var mh$ = __gmpz_set_ui.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__gmpz_set_ui", x0, x1);
            }
            mh$.invokeExact(x0, x1);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __gmpz_setbit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gmp_h.C_POINTER,
            gmp_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__gmpz_setbit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void __gmpz_setbit(mpz_ptr, mp_bitcnt_t)
     * }
     */
    public static FunctionDescriptor __gmpz_setbit$descriptor() {
        return __gmpz_setbit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void __gmpz_setbit(mpz_ptr, mp_bitcnt_t)
     * }
     */
    public static MethodHandle __gmpz_setbit$handle() {
        return __gmpz_setbit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void __gmpz_setbit(mpz_ptr, mp_bitcnt_t)
     * }
     */
    public static MemorySegment __gmpz_setbit$address() {
        return __gmpz_setbit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void __gmpz_setbit(mpz_ptr, mp_bitcnt_t)
     * }
     */
    public static void __gmpz_setbit(MemorySegment x0, long x1) {
        var mh$ = __gmpz_setbit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__gmpz_setbit", x0, x1);
            }
            mh$.invokeExact(x0, x1);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __gmpz_size {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gmp_h.C_LONG,
            gmp_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__gmpz_size");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * size_t __gmpz_size(mpz_srcptr)
     * }
     */
    public static FunctionDescriptor __gmpz_size$descriptor() {
        return __gmpz_size.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * size_t __gmpz_size(mpz_srcptr)
     * }
     */
    public static MethodHandle __gmpz_size$handle() {
        return __gmpz_size.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * size_t __gmpz_size(mpz_srcptr)
     * }
     */
    public static MemorySegment __gmpz_size$address() {
        return __gmpz_size.ADDR;
    }

    /**
     * {@snippet lang=c :
     * size_t __gmpz_size(mpz_srcptr)
     * }
     */
    public static long __gmpz_size(MemorySegment x0) {
        var mh$ = __gmpz_size.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__gmpz_size", x0);
            }
            return (long)mh$.invokeExact(x0);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __gmpz_sizeinbase {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gmp_h.C_LONG,
            gmp_h.C_POINTER,
            gmp_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__gmpz_sizeinbase");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * size_t __gmpz_sizeinbase(mpz_srcptr, int)
     * }
     */
    public static FunctionDescriptor __gmpz_sizeinbase$descriptor() {
        return __gmpz_sizeinbase.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * size_t __gmpz_sizeinbase(mpz_srcptr, int)
     * }
     */
    public static MethodHandle __gmpz_sizeinbase$handle() {
        return __gmpz_sizeinbase.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * size_t __gmpz_sizeinbase(mpz_srcptr, int)
     * }
     */
    public static MemorySegment __gmpz_sizeinbase$address() {
        return __gmpz_sizeinbase.ADDR;
    }

    /**
     * {@snippet lang=c :
     * size_t __gmpz_sizeinbase(mpz_srcptr, int)
     * }
     */
    public static long __gmpz_sizeinbase(MemorySegment x0, int x1) {
        var mh$ = __gmpz_sizeinbase.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__gmpz_sizeinbase", x0, x1);
            }
            return (long)mh$.invokeExact(x0, x1);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __gmpz_sqrt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gmp_h.C_POINTER,
            gmp_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__gmpz_sqrt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void __gmpz_sqrt(mpz_ptr, mpz_srcptr)
     * }
     */
    public static FunctionDescriptor __gmpz_sqrt$descriptor() {
        return __gmpz_sqrt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void __gmpz_sqrt(mpz_ptr, mpz_srcptr)
     * }
     */
    public static MethodHandle __gmpz_sqrt$handle() {
        return __gmpz_sqrt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void __gmpz_sqrt(mpz_ptr, mpz_srcptr)
     * }
     */
    public static MemorySegment __gmpz_sqrt$address() {
        return __gmpz_sqrt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void __gmpz_sqrt(mpz_ptr, mpz_srcptr)
     * }
     */
    public static void __gmpz_sqrt(MemorySegment x0, MemorySegment x1) {
        var mh$ = __gmpz_sqrt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__gmpz_sqrt", x0, x1);
            }
            mh$.invokeExact(x0, x1);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __gmpz_sqrtrem {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gmp_h.C_POINTER,
            gmp_h.C_POINTER,
            gmp_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__gmpz_sqrtrem");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void __gmpz_sqrtrem(mpz_ptr, mpz_ptr, mpz_srcptr)
     * }
     */
    public static FunctionDescriptor __gmpz_sqrtrem$descriptor() {
        return __gmpz_sqrtrem.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void __gmpz_sqrtrem(mpz_ptr, mpz_ptr, mpz_srcptr)
     * }
     */
    public static MethodHandle __gmpz_sqrtrem$handle() {
        return __gmpz_sqrtrem.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void __gmpz_sqrtrem(mpz_ptr, mpz_ptr, mpz_srcptr)
     * }
     */
    public static MemorySegment __gmpz_sqrtrem$address() {
        return __gmpz_sqrtrem.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void __gmpz_sqrtrem(mpz_ptr, mpz_ptr, mpz_srcptr)
     * }
     */
    public static void __gmpz_sqrtrem(MemorySegment x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = __gmpz_sqrtrem.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__gmpz_sqrtrem", x0, x1, x2);
            }
            mh$.invokeExact(x0, x1, x2);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __gmpz_sub {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gmp_h.C_POINTER,
            gmp_h.C_POINTER,
            gmp_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__gmpz_sub");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void __gmpz_sub(mpz_ptr, mpz_srcptr, mpz_srcptr)
     * }
     */
    public static FunctionDescriptor __gmpz_sub$descriptor() {
        return __gmpz_sub.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void __gmpz_sub(mpz_ptr, mpz_srcptr, mpz_srcptr)
     * }
     */
    public static MethodHandle __gmpz_sub$handle() {
        return __gmpz_sub.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void __gmpz_sub(mpz_ptr, mpz_srcptr, mpz_srcptr)
     * }
     */
    public static MemorySegment __gmpz_sub$address() {
        return __gmpz_sub.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void __gmpz_sub(mpz_ptr, mpz_srcptr, mpz_srcptr)
     * }
     */
    public static void __gmpz_sub(MemorySegment x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = __gmpz_sub.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__gmpz_sub", x0, x1, x2);
            }
            mh$.invokeExact(x0, x1, x2);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __gmpz_sub_ui {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gmp_h.C_POINTER,
            gmp_h.C_POINTER,
            gmp_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__gmpz_sub_ui");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void __gmpz_sub_ui(mpz_ptr, mpz_srcptr, unsigned long)
     * }
     */
    public static FunctionDescriptor __gmpz_sub_ui$descriptor() {
        return __gmpz_sub_ui.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void __gmpz_sub_ui(mpz_ptr, mpz_srcptr, unsigned long)
     * }
     */
    public static MethodHandle __gmpz_sub_ui$handle() {
        return __gmpz_sub_ui.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void __gmpz_sub_ui(mpz_ptr, mpz_srcptr, unsigned long)
     * }
     */
    public static MemorySegment __gmpz_sub_ui$address() {
        return __gmpz_sub_ui.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void __gmpz_sub_ui(mpz_ptr, mpz_srcptr, unsigned long)
     * }
     */
    public static void __gmpz_sub_ui(MemorySegment x0, MemorySegment x1, long x2) {
        var mh$ = __gmpz_sub_ui.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__gmpz_sub_ui", x0, x1, x2);
            }
            mh$.invokeExact(x0, x1, x2);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __gmpz_ui_sub {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gmp_h.C_POINTER,
            gmp_h.C_LONG,
            gmp_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__gmpz_ui_sub");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void __gmpz_ui_sub(mpz_ptr, unsigned long, mpz_srcptr)
     * }
     */
    public static FunctionDescriptor __gmpz_ui_sub$descriptor() {
        return __gmpz_ui_sub.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void __gmpz_ui_sub(mpz_ptr, unsigned long, mpz_srcptr)
     * }
     */
    public static MethodHandle __gmpz_ui_sub$handle() {
        return __gmpz_ui_sub.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void __gmpz_ui_sub(mpz_ptr, unsigned long, mpz_srcptr)
     * }
     */
    public static MemorySegment __gmpz_ui_sub$address() {
        return __gmpz_ui_sub.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void __gmpz_ui_sub(mpz_ptr, unsigned long, mpz_srcptr)
     * }
     */
    public static void __gmpz_ui_sub(MemorySegment x0, long x1, MemorySegment x2) {
        var mh$ = __gmpz_ui_sub.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__gmpz_ui_sub", x0, x1, x2);
            }
            mh$.invokeExact(x0, x1, x2);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __gmpz_submul {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gmp_h.C_POINTER,
            gmp_h.C_POINTER,
            gmp_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__gmpz_submul");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void __gmpz_submul(mpz_ptr, mpz_srcptr, mpz_srcptr)
     * }
     */
    public static FunctionDescriptor __gmpz_submul$descriptor() {
        return __gmpz_submul.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void __gmpz_submul(mpz_ptr, mpz_srcptr, mpz_srcptr)
     * }
     */
    public static MethodHandle __gmpz_submul$handle() {
        return __gmpz_submul.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void __gmpz_submul(mpz_ptr, mpz_srcptr, mpz_srcptr)
     * }
     */
    public static MemorySegment __gmpz_submul$address() {
        return __gmpz_submul.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void __gmpz_submul(mpz_ptr, mpz_srcptr, mpz_srcptr)
     * }
     */
    public static void __gmpz_submul(MemorySegment x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = __gmpz_submul.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__gmpz_submul", x0, x1, x2);
            }
            mh$.invokeExact(x0, x1, x2);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __gmpz_submul_ui {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gmp_h.C_POINTER,
            gmp_h.C_POINTER,
            gmp_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__gmpz_submul_ui");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void __gmpz_submul_ui(mpz_ptr, mpz_srcptr, unsigned long)
     * }
     */
    public static FunctionDescriptor __gmpz_submul_ui$descriptor() {
        return __gmpz_submul_ui.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void __gmpz_submul_ui(mpz_ptr, mpz_srcptr, unsigned long)
     * }
     */
    public static MethodHandle __gmpz_submul_ui$handle() {
        return __gmpz_submul_ui.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void __gmpz_submul_ui(mpz_ptr, mpz_srcptr, unsigned long)
     * }
     */
    public static MemorySegment __gmpz_submul_ui$address() {
        return __gmpz_submul_ui.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void __gmpz_submul_ui(mpz_ptr, mpz_srcptr, unsigned long)
     * }
     */
    public static void __gmpz_submul_ui(MemorySegment x0, MemorySegment x1, long x2) {
        var mh$ = __gmpz_submul_ui.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__gmpz_submul_ui", x0, x1, x2);
            }
            mh$.invokeExact(x0, x1, x2);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __gmpz_swap {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gmp_h.C_POINTER,
            gmp_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__gmpz_swap");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void __gmpz_swap(mpz_ptr, mpz_ptr)
     * }
     */
    public static FunctionDescriptor __gmpz_swap$descriptor() {
        return __gmpz_swap.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void __gmpz_swap(mpz_ptr, mpz_ptr)
     * }
     */
    public static MethodHandle __gmpz_swap$handle() {
        return __gmpz_swap.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void __gmpz_swap(mpz_ptr, mpz_ptr)
     * }
     */
    public static MemorySegment __gmpz_swap$address() {
        return __gmpz_swap.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void __gmpz_swap(mpz_ptr, mpz_ptr)
     * }
     */
    public static void __gmpz_swap(MemorySegment x0, MemorySegment x1) {
        var mh$ = __gmpz_swap.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__gmpz_swap", x0, x1);
            }
            mh$.invokeExact(x0, x1);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __gmpz_tdiv_ui {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gmp_h.C_LONG,
            gmp_h.C_POINTER,
            gmp_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__gmpz_tdiv_ui");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned long __gmpz_tdiv_ui(mpz_srcptr, unsigned long)
     * }
     */
    public static FunctionDescriptor __gmpz_tdiv_ui$descriptor() {
        return __gmpz_tdiv_ui.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned long __gmpz_tdiv_ui(mpz_srcptr, unsigned long)
     * }
     */
    public static MethodHandle __gmpz_tdiv_ui$handle() {
        return __gmpz_tdiv_ui.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned long __gmpz_tdiv_ui(mpz_srcptr, unsigned long)
     * }
     */
    public static MemorySegment __gmpz_tdiv_ui$address() {
        return __gmpz_tdiv_ui.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned long __gmpz_tdiv_ui(mpz_srcptr, unsigned long)
     * }
     */
    public static long __gmpz_tdiv_ui(MemorySegment x0, long x1) {
        var mh$ = __gmpz_tdiv_ui.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__gmpz_tdiv_ui", x0, x1);
            }
            return (long)mh$.invokeExact(x0, x1);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __gmpz_tdiv_q {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gmp_h.C_POINTER,
            gmp_h.C_POINTER,
            gmp_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__gmpz_tdiv_q");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void __gmpz_tdiv_q(mpz_ptr, mpz_srcptr, mpz_srcptr)
     * }
     */
    public static FunctionDescriptor __gmpz_tdiv_q$descriptor() {
        return __gmpz_tdiv_q.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void __gmpz_tdiv_q(mpz_ptr, mpz_srcptr, mpz_srcptr)
     * }
     */
    public static MethodHandle __gmpz_tdiv_q$handle() {
        return __gmpz_tdiv_q.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void __gmpz_tdiv_q(mpz_ptr, mpz_srcptr, mpz_srcptr)
     * }
     */
    public static MemorySegment __gmpz_tdiv_q$address() {
        return __gmpz_tdiv_q.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void __gmpz_tdiv_q(mpz_ptr, mpz_srcptr, mpz_srcptr)
     * }
     */
    public static void __gmpz_tdiv_q(MemorySegment x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = __gmpz_tdiv_q.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__gmpz_tdiv_q", x0, x1, x2);
            }
            mh$.invokeExact(x0, x1, x2);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __gmpz_tdiv_q_2exp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gmp_h.C_POINTER,
            gmp_h.C_POINTER,
            gmp_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__gmpz_tdiv_q_2exp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void __gmpz_tdiv_q_2exp(mpz_ptr, mpz_srcptr, mp_bitcnt_t)
     * }
     */
    public static FunctionDescriptor __gmpz_tdiv_q_2exp$descriptor() {
        return __gmpz_tdiv_q_2exp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void __gmpz_tdiv_q_2exp(mpz_ptr, mpz_srcptr, mp_bitcnt_t)
     * }
     */
    public static MethodHandle __gmpz_tdiv_q_2exp$handle() {
        return __gmpz_tdiv_q_2exp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void __gmpz_tdiv_q_2exp(mpz_ptr, mpz_srcptr, mp_bitcnt_t)
     * }
     */
    public static MemorySegment __gmpz_tdiv_q_2exp$address() {
        return __gmpz_tdiv_q_2exp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void __gmpz_tdiv_q_2exp(mpz_ptr, mpz_srcptr, mp_bitcnt_t)
     * }
     */
    public static void __gmpz_tdiv_q_2exp(MemorySegment x0, MemorySegment x1, long x2) {
        var mh$ = __gmpz_tdiv_q_2exp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__gmpz_tdiv_q_2exp", x0, x1, x2);
            }
            mh$.invokeExact(x0, x1, x2);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __gmpz_tdiv_q_ui {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gmp_h.C_LONG,
            gmp_h.C_POINTER,
            gmp_h.C_POINTER,
            gmp_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__gmpz_tdiv_q_ui");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned long __gmpz_tdiv_q_ui(mpz_ptr, mpz_srcptr, unsigned long)
     * }
     */
    public static FunctionDescriptor __gmpz_tdiv_q_ui$descriptor() {
        return __gmpz_tdiv_q_ui.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned long __gmpz_tdiv_q_ui(mpz_ptr, mpz_srcptr, unsigned long)
     * }
     */
    public static MethodHandle __gmpz_tdiv_q_ui$handle() {
        return __gmpz_tdiv_q_ui.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned long __gmpz_tdiv_q_ui(mpz_ptr, mpz_srcptr, unsigned long)
     * }
     */
    public static MemorySegment __gmpz_tdiv_q_ui$address() {
        return __gmpz_tdiv_q_ui.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned long __gmpz_tdiv_q_ui(mpz_ptr, mpz_srcptr, unsigned long)
     * }
     */
    public static long __gmpz_tdiv_q_ui(MemorySegment x0, MemorySegment x1, long x2) {
        var mh$ = __gmpz_tdiv_q_ui.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__gmpz_tdiv_q_ui", x0, x1, x2);
            }
            return (long)mh$.invokeExact(x0, x1, x2);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __gmpz_tdiv_qr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gmp_h.C_POINTER,
            gmp_h.C_POINTER,
            gmp_h.C_POINTER,
            gmp_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__gmpz_tdiv_qr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void __gmpz_tdiv_qr(mpz_ptr, mpz_ptr, mpz_srcptr, mpz_srcptr)
     * }
     */
    public static FunctionDescriptor __gmpz_tdiv_qr$descriptor() {
        return __gmpz_tdiv_qr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void __gmpz_tdiv_qr(mpz_ptr, mpz_ptr, mpz_srcptr, mpz_srcptr)
     * }
     */
    public static MethodHandle __gmpz_tdiv_qr$handle() {
        return __gmpz_tdiv_qr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void __gmpz_tdiv_qr(mpz_ptr, mpz_ptr, mpz_srcptr, mpz_srcptr)
     * }
     */
    public static MemorySegment __gmpz_tdiv_qr$address() {
        return __gmpz_tdiv_qr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void __gmpz_tdiv_qr(mpz_ptr, mpz_ptr, mpz_srcptr, mpz_srcptr)
     * }
     */
    public static void __gmpz_tdiv_qr(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = __gmpz_tdiv_qr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__gmpz_tdiv_qr", x0, x1, x2, x3);
            }
            mh$.invokeExact(x0, x1, x2, x3);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __gmpz_tdiv_qr_ui {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gmp_h.C_LONG,
            gmp_h.C_POINTER,
            gmp_h.C_POINTER,
            gmp_h.C_POINTER,
            gmp_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__gmpz_tdiv_qr_ui");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned long __gmpz_tdiv_qr_ui(mpz_ptr, mpz_ptr, mpz_srcptr, unsigned long)
     * }
     */
    public static FunctionDescriptor __gmpz_tdiv_qr_ui$descriptor() {
        return __gmpz_tdiv_qr_ui.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned long __gmpz_tdiv_qr_ui(mpz_ptr, mpz_ptr, mpz_srcptr, unsigned long)
     * }
     */
    public static MethodHandle __gmpz_tdiv_qr_ui$handle() {
        return __gmpz_tdiv_qr_ui.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned long __gmpz_tdiv_qr_ui(mpz_ptr, mpz_ptr, mpz_srcptr, unsigned long)
     * }
     */
    public static MemorySegment __gmpz_tdiv_qr_ui$address() {
        return __gmpz_tdiv_qr_ui.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned long __gmpz_tdiv_qr_ui(mpz_ptr, mpz_ptr, mpz_srcptr, unsigned long)
     * }
     */
    public static long __gmpz_tdiv_qr_ui(MemorySegment x0, MemorySegment x1, MemorySegment x2, long x3) {
        var mh$ = __gmpz_tdiv_qr_ui.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__gmpz_tdiv_qr_ui", x0, x1, x2, x3);
            }
            return (long)mh$.invokeExact(x0, x1, x2, x3);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __gmpz_tdiv_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gmp_h.C_POINTER,
            gmp_h.C_POINTER,
            gmp_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__gmpz_tdiv_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void __gmpz_tdiv_r(mpz_ptr, mpz_srcptr, mpz_srcptr)
     * }
     */
    public static FunctionDescriptor __gmpz_tdiv_r$descriptor() {
        return __gmpz_tdiv_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void __gmpz_tdiv_r(mpz_ptr, mpz_srcptr, mpz_srcptr)
     * }
     */
    public static MethodHandle __gmpz_tdiv_r$handle() {
        return __gmpz_tdiv_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void __gmpz_tdiv_r(mpz_ptr, mpz_srcptr, mpz_srcptr)
     * }
     */
    public static MemorySegment __gmpz_tdiv_r$address() {
        return __gmpz_tdiv_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void __gmpz_tdiv_r(mpz_ptr, mpz_srcptr, mpz_srcptr)
     * }
     */
    public static void __gmpz_tdiv_r(MemorySegment x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = __gmpz_tdiv_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__gmpz_tdiv_r", x0, x1, x2);
            }
            mh$.invokeExact(x0, x1, x2);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __gmpz_tdiv_r_2exp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gmp_h.C_POINTER,
            gmp_h.C_POINTER,
            gmp_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__gmpz_tdiv_r_2exp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void __gmpz_tdiv_r_2exp(mpz_ptr, mpz_srcptr, mp_bitcnt_t)
     * }
     */
    public static FunctionDescriptor __gmpz_tdiv_r_2exp$descriptor() {
        return __gmpz_tdiv_r_2exp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void __gmpz_tdiv_r_2exp(mpz_ptr, mpz_srcptr, mp_bitcnt_t)
     * }
     */
    public static MethodHandle __gmpz_tdiv_r_2exp$handle() {
        return __gmpz_tdiv_r_2exp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void __gmpz_tdiv_r_2exp(mpz_ptr, mpz_srcptr, mp_bitcnt_t)
     * }
     */
    public static MemorySegment __gmpz_tdiv_r_2exp$address() {
        return __gmpz_tdiv_r_2exp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void __gmpz_tdiv_r_2exp(mpz_ptr, mpz_srcptr, mp_bitcnt_t)
     * }
     */
    public static void __gmpz_tdiv_r_2exp(MemorySegment x0, MemorySegment x1, long x2) {
        var mh$ = __gmpz_tdiv_r_2exp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__gmpz_tdiv_r_2exp", x0, x1, x2);
            }
            mh$.invokeExact(x0, x1, x2);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __gmpz_tdiv_r_ui {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gmp_h.C_LONG,
            gmp_h.C_POINTER,
            gmp_h.C_POINTER,
            gmp_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__gmpz_tdiv_r_ui");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned long __gmpz_tdiv_r_ui(mpz_ptr, mpz_srcptr, unsigned long)
     * }
     */
    public static FunctionDescriptor __gmpz_tdiv_r_ui$descriptor() {
        return __gmpz_tdiv_r_ui.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned long __gmpz_tdiv_r_ui(mpz_ptr, mpz_srcptr, unsigned long)
     * }
     */
    public static MethodHandle __gmpz_tdiv_r_ui$handle() {
        return __gmpz_tdiv_r_ui.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned long __gmpz_tdiv_r_ui(mpz_ptr, mpz_srcptr, unsigned long)
     * }
     */
    public static MemorySegment __gmpz_tdiv_r_ui$address() {
        return __gmpz_tdiv_r_ui.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned long __gmpz_tdiv_r_ui(mpz_ptr, mpz_srcptr, unsigned long)
     * }
     */
    public static long __gmpz_tdiv_r_ui(MemorySegment x0, MemorySegment x1, long x2) {
        var mh$ = __gmpz_tdiv_r_ui.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__gmpz_tdiv_r_ui", x0, x1, x2);
            }
            return (long)mh$.invokeExact(x0, x1, x2);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __gmpz_tstbit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gmp_h.C_INT,
            gmp_h.C_POINTER,
            gmp_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__gmpz_tstbit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int __gmpz_tstbit(mpz_srcptr, mp_bitcnt_t)
     * }
     */
    public static FunctionDescriptor __gmpz_tstbit$descriptor() {
        return __gmpz_tstbit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int __gmpz_tstbit(mpz_srcptr, mp_bitcnt_t)
     * }
     */
    public static MethodHandle __gmpz_tstbit$handle() {
        return __gmpz_tstbit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int __gmpz_tstbit(mpz_srcptr, mp_bitcnt_t)
     * }
     */
    public static MemorySegment __gmpz_tstbit$address() {
        return __gmpz_tstbit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int __gmpz_tstbit(mpz_srcptr, mp_bitcnt_t)
     * }
     */
    public static int __gmpz_tstbit(MemorySegment x0, long x1) {
        var mh$ = __gmpz_tstbit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__gmpz_tstbit", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __gmpz_ui_pow_ui {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gmp_h.C_POINTER,
            gmp_h.C_LONG,
            gmp_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__gmpz_ui_pow_ui");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void __gmpz_ui_pow_ui(mpz_ptr, unsigned long, unsigned long)
     * }
     */
    public static FunctionDescriptor __gmpz_ui_pow_ui$descriptor() {
        return __gmpz_ui_pow_ui.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void __gmpz_ui_pow_ui(mpz_ptr, unsigned long, unsigned long)
     * }
     */
    public static MethodHandle __gmpz_ui_pow_ui$handle() {
        return __gmpz_ui_pow_ui.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void __gmpz_ui_pow_ui(mpz_ptr, unsigned long, unsigned long)
     * }
     */
    public static MemorySegment __gmpz_ui_pow_ui$address() {
        return __gmpz_ui_pow_ui.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void __gmpz_ui_pow_ui(mpz_ptr, unsigned long, unsigned long)
     * }
     */
    public static void __gmpz_ui_pow_ui(MemorySegment x0, long x1, long x2) {
        var mh$ = __gmpz_ui_pow_ui.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__gmpz_ui_pow_ui", x0, x1, x2);
            }
            mh$.invokeExact(x0, x1, x2);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __gmpz_urandomb {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gmp_h.C_POINTER,
            gmp_h.C_POINTER,
            gmp_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__gmpz_urandomb");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void __gmpz_urandomb(mpz_ptr, gmp_randstate_ptr, mp_bitcnt_t)
     * }
     */
    public static FunctionDescriptor __gmpz_urandomb$descriptor() {
        return __gmpz_urandomb.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void __gmpz_urandomb(mpz_ptr, gmp_randstate_ptr, mp_bitcnt_t)
     * }
     */
    public static MethodHandle __gmpz_urandomb$handle() {
        return __gmpz_urandomb.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void __gmpz_urandomb(mpz_ptr, gmp_randstate_ptr, mp_bitcnt_t)
     * }
     */
    public static MemorySegment __gmpz_urandomb$address() {
        return __gmpz_urandomb.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void __gmpz_urandomb(mpz_ptr, gmp_randstate_ptr, mp_bitcnt_t)
     * }
     */
    public static void __gmpz_urandomb(MemorySegment x0, MemorySegment x1, long x2) {
        var mh$ = __gmpz_urandomb.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__gmpz_urandomb", x0, x1, x2);
            }
            mh$.invokeExact(x0, x1, x2);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __gmpz_urandomm {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gmp_h.C_POINTER,
            gmp_h.C_POINTER,
            gmp_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__gmpz_urandomm");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void __gmpz_urandomm(mpz_ptr, gmp_randstate_ptr, mpz_srcptr)
     * }
     */
    public static FunctionDescriptor __gmpz_urandomm$descriptor() {
        return __gmpz_urandomm.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void __gmpz_urandomm(mpz_ptr, gmp_randstate_ptr, mpz_srcptr)
     * }
     */
    public static MethodHandle __gmpz_urandomm$handle() {
        return __gmpz_urandomm.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void __gmpz_urandomm(mpz_ptr, gmp_randstate_ptr, mpz_srcptr)
     * }
     */
    public static MemorySegment __gmpz_urandomm$address() {
        return __gmpz_urandomm.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void __gmpz_urandomm(mpz_ptr, gmp_randstate_ptr, mpz_srcptr)
     * }
     */
    public static void __gmpz_urandomm(MemorySegment x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = __gmpz_urandomm.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__gmpz_urandomm", x0, x1, x2);
            }
            mh$.invokeExact(x0, x1, x2);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __gmpz_xor {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gmp_h.C_POINTER,
            gmp_h.C_POINTER,
            gmp_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__gmpz_xor");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void __gmpz_xor(mpz_ptr, mpz_srcptr, mpz_srcptr)
     * }
     */
    public static FunctionDescriptor __gmpz_xor$descriptor() {
        return __gmpz_xor.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void __gmpz_xor(mpz_ptr, mpz_srcptr, mpz_srcptr)
     * }
     */
    public static MethodHandle __gmpz_xor$handle() {
        return __gmpz_xor.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void __gmpz_xor(mpz_ptr, mpz_srcptr, mpz_srcptr)
     * }
     */
    public static MemorySegment __gmpz_xor$address() {
        return __gmpz_xor.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void __gmpz_xor(mpz_ptr, mpz_srcptr, mpz_srcptr)
     * }
     */
    public static void __gmpz_xor(MemorySegment x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = __gmpz_xor.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__gmpz_xor", x0, x1, x2);
            }
            mh$.invokeExact(x0, x1, x2);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __gmpz_limbs_read {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gmp_h.C_POINTER,
            gmp_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__gmpz_limbs_read");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * mp_srcptr __gmpz_limbs_read(mpz_srcptr)
     * }
     */
    public static FunctionDescriptor __gmpz_limbs_read$descriptor() {
        return __gmpz_limbs_read.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * mp_srcptr __gmpz_limbs_read(mpz_srcptr)
     * }
     */
    public static MethodHandle __gmpz_limbs_read$handle() {
        return __gmpz_limbs_read.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * mp_srcptr __gmpz_limbs_read(mpz_srcptr)
     * }
     */
    public static MemorySegment __gmpz_limbs_read$address() {
        return __gmpz_limbs_read.ADDR;
    }

    /**
     * {@snippet lang=c :
     * mp_srcptr __gmpz_limbs_read(mpz_srcptr)
     * }
     */
    public static MemorySegment __gmpz_limbs_read(MemorySegment x0) {
        var mh$ = __gmpz_limbs_read.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__gmpz_limbs_read", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __gmpz_limbs_write {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gmp_h.C_POINTER,
            gmp_h.C_POINTER,
            gmp_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__gmpz_limbs_write");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * mp_ptr __gmpz_limbs_write(mpz_ptr, mp_size_t)
     * }
     */
    public static FunctionDescriptor __gmpz_limbs_write$descriptor() {
        return __gmpz_limbs_write.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * mp_ptr __gmpz_limbs_write(mpz_ptr, mp_size_t)
     * }
     */
    public static MethodHandle __gmpz_limbs_write$handle() {
        return __gmpz_limbs_write.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * mp_ptr __gmpz_limbs_write(mpz_ptr, mp_size_t)
     * }
     */
    public static MemorySegment __gmpz_limbs_write$address() {
        return __gmpz_limbs_write.ADDR;
    }

    /**
     * {@snippet lang=c :
     * mp_ptr __gmpz_limbs_write(mpz_ptr, mp_size_t)
     * }
     */
    public static MemorySegment __gmpz_limbs_write(MemorySegment x0, long x1) {
        var mh$ = __gmpz_limbs_write.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__gmpz_limbs_write", x0, x1);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __gmpz_limbs_modify {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gmp_h.C_POINTER,
            gmp_h.C_POINTER,
            gmp_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__gmpz_limbs_modify");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * mp_ptr __gmpz_limbs_modify(mpz_ptr, mp_size_t)
     * }
     */
    public static FunctionDescriptor __gmpz_limbs_modify$descriptor() {
        return __gmpz_limbs_modify.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * mp_ptr __gmpz_limbs_modify(mpz_ptr, mp_size_t)
     * }
     */
    public static MethodHandle __gmpz_limbs_modify$handle() {
        return __gmpz_limbs_modify.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * mp_ptr __gmpz_limbs_modify(mpz_ptr, mp_size_t)
     * }
     */
    public static MemorySegment __gmpz_limbs_modify$address() {
        return __gmpz_limbs_modify.ADDR;
    }

    /**
     * {@snippet lang=c :
     * mp_ptr __gmpz_limbs_modify(mpz_ptr, mp_size_t)
     * }
     */
    public static MemorySegment __gmpz_limbs_modify(MemorySegment x0, long x1) {
        var mh$ = __gmpz_limbs_modify.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__gmpz_limbs_modify", x0, x1);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __gmpz_limbs_finish {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gmp_h.C_POINTER,
            gmp_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__gmpz_limbs_finish");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void __gmpz_limbs_finish(mpz_ptr, mp_size_t)
     * }
     */
    public static FunctionDescriptor __gmpz_limbs_finish$descriptor() {
        return __gmpz_limbs_finish.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void __gmpz_limbs_finish(mpz_ptr, mp_size_t)
     * }
     */
    public static MethodHandle __gmpz_limbs_finish$handle() {
        return __gmpz_limbs_finish.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void __gmpz_limbs_finish(mpz_ptr, mp_size_t)
     * }
     */
    public static MemorySegment __gmpz_limbs_finish$address() {
        return __gmpz_limbs_finish.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void __gmpz_limbs_finish(mpz_ptr, mp_size_t)
     * }
     */
    public static void __gmpz_limbs_finish(MemorySegment x0, long x1) {
        var mh$ = __gmpz_limbs_finish.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__gmpz_limbs_finish", x0, x1);
            }
            mh$.invokeExact(x0, x1);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __gmpz_roinit_n {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gmp_h.C_POINTER,
            gmp_h.C_POINTER,
            gmp_h.C_POINTER,
            gmp_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__gmpz_roinit_n");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * mpz_srcptr __gmpz_roinit_n(mpz_ptr, mp_srcptr, mp_size_t)
     * }
     */
    public static FunctionDescriptor __gmpz_roinit_n$descriptor() {
        return __gmpz_roinit_n.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * mpz_srcptr __gmpz_roinit_n(mpz_ptr, mp_srcptr, mp_size_t)
     * }
     */
    public static MethodHandle __gmpz_roinit_n$handle() {
        return __gmpz_roinit_n.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * mpz_srcptr __gmpz_roinit_n(mpz_ptr, mp_srcptr, mp_size_t)
     * }
     */
    public static MemorySegment __gmpz_roinit_n$address() {
        return __gmpz_roinit_n.ADDR;
    }

    /**
     * {@snippet lang=c :
     * mpz_srcptr __gmpz_roinit_n(mpz_ptr, mp_srcptr, mp_size_t)
     * }
     */
    public static MemorySegment __gmpz_roinit_n(MemorySegment x0, MemorySegment x1, long x2) {
        var mh$ = __gmpz_roinit_n.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__gmpz_roinit_n", x0, x1, x2);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1, x2);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __gmpq_abs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gmp_h.C_POINTER,
            gmp_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__gmpq_abs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void __gmpq_abs(mpq_ptr, mpq_srcptr)
     * }
     */
    public static FunctionDescriptor __gmpq_abs$descriptor() {
        return __gmpq_abs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void __gmpq_abs(mpq_ptr, mpq_srcptr)
     * }
     */
    public static MethodHandle __gmpq_abs$handle() {
        return __gmpq_abs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void __gmpq_abs(mpq_ptr, mpq_srcptr)
     * }
     */
    public static MemorySegment __gmpq_abs$address() {
        return __gmpq_abs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void __gmpq_abs(mpq_ptr, mpq_srcptr)
     * }
     */
    public static void __gmpq_abs(MemorySegment x0, MemorySegment x1) {
        var mh$ = __gmpq_abs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__gmpq_abs", x0, x1);
            }
            mh$.invokeExact(x0, x1);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __gmpq_add {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gmp_h.C_POINTER,
            gmp_h.C_POINTER,
            gmp_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__gmpq_add");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void __gmpq_add(mpq_ptr, mpq_srcptr, mpq_srcptr)
     * }
     */
    public static FunctionDescriptor __gmpq_add$descriptor() {
        return __gmpq_add.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void __gmpq_add(mpq_ptr, mpq_srcptr, mpq_srcptr)
     * }
     */
    public static MethodHandle __gmpq_add$handle() {
        return __gmpq_add.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void __gmpq_add(mpq_ptr, mpq_srcptr, mpq_srcptr)
     * }
     */
    public static MemorySegment __gmpq_add$address() {
        return __gmpq_add.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void __gmpq_add(mpq_ptr, mpq_srcptr, mpq_srcptr)
     * }
     */
    public static void __gmpq_add(MemorySegment x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = __gmpq_add.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__gmpq_add", x0, x1, x2);
            }
            mh$.invokeExact(x0, x1, x2);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __gmpq_canonicalize {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gmp_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__gmpq_canonicalize");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void __gmpq_canonicalize(mpq_ptr)
     * }
     */
    public static FunctionDescriptor __gmpq_canonicalize$descriptor() {
        return __gmpq_canonicalize.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void __gmpq_canonicalize(mpq_ptr)
     * }
     */
    public static MethodHandle __gmpq_canonicalize$handle() {
        return __gmpq_canonicalize.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void __gmpq_canonicalize(mpq_ptr)
     * }
     */
    public static MemorySegment __gmpq_canonicalize$address() {
        return __gmpq_canonicalize.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void __gmpq_canonicalize(mpq_ptr)
     * }
     */
    public static void __gmpq_canonicalize(MemorySegment x0) {
        var mh$ = __gmpq_canonicalize.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__gmpq_canonicalize", x0);
            }
            mh$.invokeExact(x0);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __gmpq_clear {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gmp_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__gmpq_clear");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void __gmpq_clear(mpq_ptr)
     * }
     */
    public static FunctionDescriptor __gmpq_clear$descriptor() {
        return __gmpq_clear.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void __gmpq_clear(mpq_ptr)
     * }
     */
    public static MethodHandle __gmpq_clear$handle() {
        return __gmpq_clear.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void __gmpq_clear(mpq_ptr)
     * }
     */
    public static MemorySegment __gmpq_clear$address() {
        return __gmpq_clear.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void __gmpq_clear(mpq_ptr)
     * }
     */
    public static void __gmpq_clear(MemorySegment x0) {
        var mh$ = __gmpq_clear.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__gmpq_clear", x0);
            }
            mh$.invokeExact(x0);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * void __gmpq_clears(mpq_ptr, ...)
     * }
     */
    public static class __gmpq_clears {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.ofVoid(
                gmp_h.C_POINTER
            );
        private static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__gmpq_clears");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private __gmpq_clears(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * void __gmpq_clears(mpq_ptr, ...)
         * }
         */
        public static __gmpq_clears makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new __gmpq_clears(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public void apply(MemorySegment x0, Object... x1) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("__gmpq_clears", x0, x1);
                }
                 spreader.invokeExact(x0, x1);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static class __gmpq_cmp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gmp_h.C_INT,
            gmp_h.C_POINTER,
            gmp_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__gmpq_cmp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int __gmpq_cmp(mpq_srcptr, mpq_srcptr)
     * }
     */
    public static FunctionDescriptor __gmpq_cmp$descriptor() {
        return __gmpq_cmp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int __gmpq_cmp(mpq_srcptr, mpq_srcptr)
     * }
     */
    public static MethodHandle __gmpq_cmp$handle() {
        return __gmpq_cmp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int __gmpq_cmp(mpq_srcptr, mpq_srcptr)
     * }
     */
    public static MemorySegment __gmpq_cmp$address() {
        return __gmpq_cmp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int __gmpq_cmp(mpq_srcptr, mpq_srcptr)
     * }
     */
    public static int __gmpq_cmp(MemorySegment x0, MemorySegment x1) {
        var mh$ = __gmpq_cmp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__gmpq_cmp", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __gmpq_cmp_si {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gmp_h.C_INT,
            gmp_h.C_POINTER,
            gmp_h.C_LONG,
            gmp_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__gmpq_cmp_si");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int __gmpq_cmp_si(mpq_srcptr, long, unsigned long)
     * }
     */
    public static FunctionDescriptor __gmpq_cmp_si$descriptor() {
        return __gmpq_cmp_si.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int __gmpq_cmp_si(mpq_srcptr, long, unsigned long)
     * }
     */
    public static MethodHandle __gmpq_cmp_si$handle() {
        return __gmpq_cmp_si.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int __gmpq_cmp_si(mpq_srcptr, long, unsigned long)
     * }
     */
    public static MemorySegment __gmpq_cmp_si$address() {
        return __gmpq_cmp_si.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int __gmpq_cmp_si(mpq_srcptr, long, unsigned long)
     * }
     */
    public static int __gmpq_cmp_si(MemorySegment x0, long x1, long x2) {
        var mh$ = __gmpq_cmp_si.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__gmpq_cmp_si", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __gmpq_cmp_ui {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gmp_h.C_INT,
            gmp_h.C_POINTER,
            gmp_h.C_LONG,
            gmp_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__gmpq_cmp_ui");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int __gmpq_cmp_ui(mpq_srcptr, unsigned long, unsigned long)
     * }
     */
    public static FunctionDescriptor __gmpq_cmp_ui$descriptor() {
        return __gmpq_cmp_ui.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int __gmpq_cmp_ui(mpq_srcptr, unsigned long, unsigned long)
     * }
     */
    public static MethodHandle __gmpq_cmp_ui$handle() {
        return __gmpq_cmp_ui.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int __gmpq_cmp_ui(mpq_srcptr, unsigned long, unsigned long)
     * }
     */
    public static MemorySegment __gmpq_cmp_ui$address() {
        return __gmpq_cmp_ui.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int __gmpq_cmp_ui(mpq_srcptr, unsigned long, unsigned long)
     * }
     */
    public static int __gmpq_cmp_ui(MemorySegment x0, long x1, long x2) {
        var mh$ = __gmpq_cmp_ui.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__gmpq_cmp_ui", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __gmpq_cmp_z {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gmp_h.C_INT,
            gmp_h.C_POINTER,
            gmp_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__gmpq_cmp_z");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int __gmpq_cmp_z(mpq_srcptr, mpz_srcptr)
     * }
     */
    public static FunctionDescriptor __gmpq_cmp_z$descriptor() {
        return __gmpq_cmp_z.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int __gmpq_cmp_z(mpq_srcptr, mpz_srcptr)
     * }
     */
    public static MethodHandle __gmpq_cmp_z$handle() {
        return __gmpq_cmp_z.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int __gmpq_cmp_z(mpq_srcptr, mpz_srcptr)
     * }
     */
    public static MemorySegment __gmpq_cmp_z$address() {
        return __gmpq_cmp_z.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int __gmpq_cmp_z(mpq_srcptr, mpz_srcptr)
     * }
     */
    public static int __gmpq_cmp_z(MemorySegment x0, MemorySegment x1) {
        var mh$ = __gmpq_cmp_z.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__gmpq_cmp_z", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __gmpq_div {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gmp_h.C_POINTER,
            gmp_h.C_POINTER,
            gmp_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__gmpq_div");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void __gmpq_div(mpq_ptr, mpq_srcptr, mpq_srcptr)
     * }
     */
    public static FunctionDescriptor __gmpq_div$descriptor() {
        return __gmpq_div.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void __gmpq_div(mpq_ptr, mpq_srcptr, mpq_srcptr)
     * }
     */
    public static MethodHandle __gmpq_div$handle() {
        return __gmpq_div.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void __gmpq_div(mpq_ptr, mpq_srcptr, mpq_srcptr)
     * }
     */
    public static MemorySegment __gmpq_div$address() {
        return __gmpq_div.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void __gmpq_div(mpq_ptr, mpq_srcptr, mpq_srcptr)
     * }
     */
    public static void __gmpq_div(MemorySegment x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = __gmpq_div.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__gmpq_div", x0, x1, x2);
            }
            mh$.invokeExact(x0, x1, x2);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __gmpq_div_2exp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gmp_h.C_POINTER,
            gmp_h.C_POINTER,
            gmp_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__gmpq_div_2exp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void __gmpq_div_2exp(mpq_ptr, mpq_srcptr, mp_bitcnt_t)
     * }
     */
    public static FunctionDescriptor __gmpq_div_2exp$descriptor() {
        return __gmpq_div_2exp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void __gmpq_div_2exp(mpq_ptr, mpq_srcptr, mp_bitcnt_t)
     * }
     */
    public static MethodHandle __gmpq_div_2exp$handle() {
        return __gmpq_div_2exp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void __gmpq_div_2exp(mpq_ptr, mpq_srcptr, mp_bitcnt_t)
     * }
     */
    public static MemorySegment __gmpq_div_2exp$address() {
        return __gmpq_div_2exp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void __gmpq_div_2exp(mpq_ptr, mpq_srcptr, mp_bitcnt_t)
     * }
     */
    public static void __gmpq_div_2exp(MemorySegment x0, MemorySegment x1, long x2) {
        var mh$ = __gmpq_div_2exp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__gmpq_div_2exp", x0, x1, x2);
            }
            mh$.invokeExact(x0, x1, x2);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __gmpq_equal {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gmp_h.C_INT,
            gmp_h.C_POINTER,
            gmp_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__gmpq_equal");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int __gmpq_equal(mpq_srcptr, mpq_srcptr)
     * }
     */
    public static FunctionDescriptor __gmpq_equal$descriptor() {
        return __gmpq_equal.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int __gmpq_equal(mpq_srcptr, mpq_srcptr)
     * }
     */
    public static MethodHandle __gmpq_equal$handle() {
        return __gmpq_equal.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int __gmpq_equal(mpq_srcptr, mpq_srcptr)
     * }
     */
    public static MemorySegment __gmpq_equal$address() {
        return __gmpq_equal.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int __gmpq_equal(mpq_srcptr, mpq_srcptr)
     * }
     */
    public static int __gmpq_equal(MemorySegment x0, MemorySegment x1) {
        var mh$ = __gmpq_equal.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__gmpq_equal", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __gmpq_get_num {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gmp_h.C_POINTER,
            gmp_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__gmpq_get_num");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void __gmpq_get_num(mpz_ptr, mpq_srcptr)
     * }
     */
    public static FunctionDescriptor __gmpq_get_num$descriptor() {
        return __gmpq_get_num.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void __gmpq_get_num(mpz_ptr, mpq_srcptr)
     * }
     */
    public static MethodHandle __gmpq_get_num$handle() {
        return __gmpq_get_num.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void __gmpq_get_num(mpz_ptr, mpq_srcptr)
     * }
     */
    public static MemorySegment __gmpq_get_num$address() {
        return __gmpq_get_num.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void __gmpq_get_num(mpz_ptr, mpq_srcptr)
     * }
     */
    public static void __gmpq_get_num(MemorySegment x0, MemorySegment x1) {
        var mh$ = __gmpq_get_num.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__gmpq_get_num", x0, x1);
            }
            mh$.invokeExact(x0, x1);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __gmpq_get_den {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gmp_h.C_POINTER,
            gmp_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__gmpq_get_den");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void __gmpq_get_den(mpz_ptr, mpq_srcptr)
     * }
     */
    public static FunctionDescriptor __gmpq_get_den$descriptor() {
        return __gmpq_get_den.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void __gmpq_get_den(mpz_ptr, mpq_srcptr)
     * }
     */
    public static MethodHandle __gmpq_get_den$handle() {
        return __gmpq_get_den.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void __gmpq_get_den(mpz_ptr, mpq_srcptr)
     * }
     */
    public static MemorySegment __gmpq_get_den$address() {
        return __gmpq_get_den.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void __gmpq_get_den(mpz_ptr, mpq_srcptr)
     * }
     */
    public static void __gmpq_get_den(MemorySegment x0, MemorySegment x1) {
        var mh$ = __gmpq_get_den.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__gmpq_get_den", x0, x1);
            }
            mh$.invokeExact(x0, x1);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __gmpq_get_d {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gmp_h.C_DOUBLE,
            gmp_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__gmpq_get_d");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double __gmpq_get_d(mpq_srcptr)
     * }
     */
    public static FunctionDescriptor __gmpq_get_d$descriptor() {
        return __gmpq_get_d.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double __gmpq_get_d(mpq_srcptr)
     * }
     */
    public static MethodHandle __gmpq_get_d$handle() {
        return __gmpq_get_d.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double __gmpq_get_d(mpq_srcptr)
     * }
     */
    public static MemorySegment __gmpq_get_d$address() {
        return __gmpq_get_d.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double __gmpq_get_d(mpq_srcptr)
     * }
     */
    public static double __gmpq_get_d(MemorySegment x0) {
        var mh$ = __gmpq_get_d.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__gmpq_get_d", x0);
            }
            return (double)mh$.invokeExact(x0);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __gmpq_get_str {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gmp_h.C_POINTER,
            gmp_h.C_POINTER,
            gmp_h.C_INT,
            gmp_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__gmpq_get_str");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *__gmpq_get_str(char *, int, mpq_srcptr)
     * }
     */
    public static FunctionDescriptor __gmpq_get_str$descriptor() {
        return __gmpq_get_str.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *__gmpq_get_str(char *, int, mpq_srcptr)
     * }
     */
    public static MethodHandle __gmpq_get_str$handle() {
        return __gmpq_get_str.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *__gmpq_get_str(char *, int, mpq_srcptr)
     * }
     */
    public static MemorySegment __gmpq_get_str$address() {
        return __gmpq_get_str.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *__gmpq_get_str(char *, int, mpq_srcptr)
     * }
     */
    public static MemorySegment __gmpq_get_str(MemorySegment x0, int x1, MemorySegment x2) {
        var mh$ = __gmpq_get_str.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__gmpq_get_str", x0, x1, x2);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1, x2);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __gmpq_init {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gmp_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__gmpq_init");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void __gmpq_init(mpq_ptr)
     * }
     */
    public static FunctionDescriptor __gmpq_init$descriptor() {
        return __gmpq_init.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void __gmpq_init(mpq_ptr)
     * }
     */
    public static MethodHandle __gmpq_init$handle() {
        return __gmpq_init.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void __gmpq_init(mpq_ptr)
     * }
     */
    public static MemorySegment __gmpq_init$address() {
        return __gmpq_init.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void __gmpq_init(mpq_ptr)
     * }
     */
    public static void __gmpq_init(MemorySegment x0) {
        var mh$ = __gmpq_init.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__gmpq_init", x0);
            }
            mh$.invokeExact(x0);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * void __gmpq_inits(mpq_ptr, ...)
     * }
     */
    public static class __gmpq_inits {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.ofVoid(
                gmp_h.C_POINTER
            );
        private static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__gmpq_inits");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private __gmpq_inits(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * void __gmpq_inits(mpq_ptr, ...)
         * }
         */
        public static __gmpq_inits makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new __gmpq_inits(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public void apply(MemorySegment x0, Object... x1) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("__gmpq_inits", x0, x1);
                }
                 spreader.invokeExact(x0, x1);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static class __gmpq_inv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gmp_h.C_POINTER,
            gmp_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__gmpq_inv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void __gmpq_inv(mpq_ptr, mpq_srcptr)
     * }
     */
    public static FunctionDescriptor __gmpq_inv$descriptor() {
        return __gmpq_inv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void __gmpq_inv(mpq_ptr, mpq_srcptr)
     * }
     */
    public static MethodHandle __gmpq_inv$handle() {
        return __gmpq_inv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void __gmpq_inv(mpq_ptr, mpq_srcptr)
     * }
     */
    public static MemorySegment __gmpq_inv$address() {
        return __gmpq_inv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void __gmpq_inv(mpq_ptr, mpq_srcptr)
     * }
     */
    public static void __gmpq_inv(MemorySegment x0, MemorySegment x1) {
        var mh$ = __gmpq_inv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__gmpq_inv", x0, x1);
            }
            mh$.invokeExact(x0, x1);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __gmpq_mul {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gmp_h.C_POINTER,
            gmp_h.C_POINTER,
            gmp_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__gmpq_mul");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void __gmpq_mul(mpq_ptr, mpq_srcptr, mpq_srcptr)
     * }
     */
    public static FunctionDescriptor __gmpq_mul$descriptor() {
        return __gmpq_mul.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void __gmpq_mul(mpq_ptr, mpq_srcptr, mpq_srcptr)
     * }
     */
    public static MethodHandle __gmpq_mul$handle() {
        return __gmpq_mul.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void __gmpq_mul(mpq_ptr, mpq_srcptr, mpq_srcptr)
     * }
     */
    public static MemorySegment __gmpq_mul$address() {
        return __gmpq_mul.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void __gmpq_mul(mpq_ptr, mpq_srcptr, mpq_srcptr)
     * }
     */
    public static void __gmpq_mul(MemorySegment x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = __gmpq_mul.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__gmpq_mul", x0, x1, x2);
            }
            mh$.invokeExact(x0, x1, x2);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __gmpq_mul_2exp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gmp_h.C_POINTER,
            gmp_h.C_POINTER,
            gmp_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__gmpq_mul_2exp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void __gmpq_mul_2exp(mpq_ptr, mpq_srcptr, mp_bitcnt_t)
     * }
     */
    public static FunctionDescriptor __gmpq_mul_2exp$descriptor() {
        return __gmpq_mul_2exp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void __gmpq_mul_2exp(mpq_ptr, mpq_srcptr, mp_bitcnt_t)
     * }
     */
    public static MethodHandle __gmpq_mul_2exp$handle() {
        return __gmpq_mul_2exp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void __gmpq_mul_2exp(mpq_ptr, mpq_srcptr, mp_bitcnt_t)
     * }
     */
    public static MemorySegment __gmpq_mul_2exp$address() {
        return __gmpq_mul_2exp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void __gmpq_mul_2exp(mpq_ptr, mpq_srcptr, mp_bitcnt_t)
     * }
     */
    public static void __gmpq_mul_2exp(MemorySegment x0, MemorySegment x1, long x2) {
        var mh$ = __gmpq_mul_2exp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__gmpq_mul_2exp", x0, x1, x2);
            }
            mh$.invokeExact(x0, x1, x2);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __gmpq_neg {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gmp_h.C_POINTER,
            gmp_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__gmpq_neg");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void __gmpq_neg(mpq_ptr, mpq_srcptr)
     * }
     */
    public static FunctionDescriptor __gmpq_neg$descriptor() {
        return __gmpq_neg.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void __gmpq_neg(mpq_ptr, mpq_srcptr)
     * }
     */
    public static MethodHandle __gmpq_neg$handle() {
        return __gmpq_neg.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void __gmpq_neg(mpq_ptr, mpq_srcptr)
     * }
     */
    public static MemorySegment __gmpq_neg$address() {
        return __gmpq_neg.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void __gmpq_neg(mpq_ptr, mpq_srcptr)
     * }
     */
    public static void __gmpq_neg(MemorySegment x0, MemorySegment x1) {
        var mh$ = __gmpq_neg.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__gmpq_neg", x0, x1);
            }
            mh$.invokeExact(x0, x1);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __gmpq_set {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gmp_h.C_POINTER,
            gmp_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__gmpq_set");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void __gmpq_set(mpq_ptr, mpq_srcptr)
     * }
     */
    public static FunctionDescriptor __gmpq_set$descriptor() {
        return __gmpq_set.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void __gmpq_set(mpq_ptr, mpq_srcptr)
     * }
     */
    public static MethodHandle __gmpq_set$handle() {
        return __gmpq_set.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void __gmpq_set(mpq_ptr, mpq_srcptr)
     * }
     */
    public static MemorySegment __gmpq_set$address() {
        return __gmpq_set.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void __gmpq_set(mpq_ptr, mpq_srcptr)
     * }
     */
    public static void __gmpq_set(MemorySegment x0, MemorySegment x1) {
        var mh$ = __gmpq_set.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__gmpq_set", x0, x1);
            }
            mh$.invokeExact(x0, x1);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __gmpq_set_d {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gmp_h.C_POINTER,
            gmp_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__gmpq_set_d");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void __gmpq_set_d(mpq_ptr, double)
     * }
     */
    public static FunctionDescriptor __gmpq_set_d$descriptor() {
        return __gmpq_set_d.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void __gmpq_set_d(mpq_ptr, double)
     * }
     */
    public static MethodHandle __gmpq_set_d$handle() {
        return __gmpq_set_d.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void __gmpq_set_d(mpq_ptr, double)
     * }
     */
    public static MemorySegment __gmpq_set_d$address() {
        return __gmpq_set_d.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void __gmpq_set_d(mpq_ptr, double)
     * }
     */
    public static void __gmpq_set_d(MemorySegment x0, double x1) {
        var mh$ = __gmpq_set_d.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__gmpq_set_d", x0, x1);
            }
            mh$.invokeExact(x0, x1);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __gmpq_set_den {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gmp_h.C_POINTER,
            gmp_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__gmpq_set_den");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void __gmpq_set_den(mpq_ptr, mpz_srcptr)
     * }
     */
    public static FunctionDescriptor __gmpq_set_den$descriptor() {
        return __gmpq_set_den.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void __gmpq_set_den(mpq_ptr, mpz_srcptr)
     * }
     */
    public static MethodHandle __gmpq_set_den$handle() {
        return __gmpq_set_den.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void __gmpq_set_den(mpq_ptr, mpz_srcptr)
     * }
     */
    public static MemorySegment __gmpq_set_den$address() {
        return __gmpq_set_den.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void __gmpq_set_den(mpq_ptr, mpz_srcptr)
     * }
     */
    public static void __gmpq_set_den(MemorySegment x0, MemorySegment x1) {
        var mh$ = __gmpq_set_den.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__gmpq_set_den", x0, x1);
            }
            mh$.invokeExact(x0, x1);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __gmpq_set_f {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gmp_h.C_POINTER,
            gmp_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__gmpq_set_f");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void __gmpq_set_f(mpq_ptr, mpf_srcptr)
     * }
     */
    public static FunctionDescriptor __gmpq_set_f$descriptor() {
        return __gmpq_set_f.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void __gmpq_set_f(mpq_ptr, mpf_srcptr)
     * }
     */
    public static MethodHandle __gmpq_set_f$handle() {
        return __gmpq_set_f.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void __gmpq_set_f(mpq_ptr, mpf_srcptr)
     * }
     */
    public static MemorySegment __gmpq_set_f$address() {
        return __gmpq_set_f.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void __gmpq_set_f(mpq_ptr, mpf_srcptr)
     * }
     */
    public static void __gmpq_set_f(MemorySegment x0, MemorySegment x1) {
        var mh$ = __gmpq_set_f.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__gmpq_set_f", x0, x1);
            }
            mh$.invokeExact(x0, x1);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __gmpq_set_num {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gmp_h.C_POINTER,
            gmp_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__gmpq_set_num");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void __gmpq_set_num(mpq_ptr, mpz_srcptr)
     * }
     */
    public static FunctionDescriptor __gmpq_set_num$descriptor() {
        return __gmpq_set_num.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void __gmpq_set_num(mpq_ptr, mpz_srcptr)
     * }
     */
    public static MethodHandle __gmpq_set_num$handle() {
        return __gmpq_set_num.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void __gmpq_set_num(mpq_ptr, mpz_srcptr)
     * }
     */
    public static MemorySegment __gmpq_set_num$address() {
        return __gmpq_set_num.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void __gmpq_set_num(mpq_ptr, mpz_srcptr)
     * }
     */
    public static void __gmpq_set_num(MemorySegment x0, MemorySegment x1) {
        var mh$ = __gmpq_set_num.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__gmpq_set_num", x0, x1);
            }
            mh$.invokeExact(x0, x1);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __gmpq_set_si {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gmp_h.C_POINTER,
            gmp_h.C_LONG,
            gmp_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__gmpq_set_si");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void __gmpq_set_si(mpq_ptr, long, unsigned long)
     * }
     */
    public static FunctionDescriptor __gmpq_set_si$descriptor() {
        return __gmpq_set_si.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void __gmpq_set_si(mpq_ptr, long, unsigned long)
     * }
     */
    public static MethodHandle __gmpq_set_si$handle() {
        return __gmpq_set_si.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void __gmpq_set_si(mpq_ptr, long, unsigned long)
     * }
     */
    public static MemorySegment __gmpq_set_si$address() {
        return __gmpq_set_si.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void __gmpq_set_si(mpq_ptr, long, unsigned long)
     * }
     */
    public static void __gmpq_set_si(MemorySegment x0, long x1, long x2) {
        var mh$ = __gmpq_set_si.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__gmpq_set_si", x0, x1, x2);
            }
            mh$.invokeExact(x0, x1, x2);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __gmpq_set_str {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gmp_h.C_INT,
            gmp_h.C_POINTER,
            gmp_h.C_POINTER,
            gmp_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__gmpq_set_str");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int __gmpq_set_str(mpq_ptr, const char *, int)
     * }
     */
    public static FunctionDescriptor __gmpq_set_str$descriptor() {
        return __gmpq_set_str.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int __gmpq_set_str(mpq_ptr, const char *, int)
     * }
     */
    public static MethodHandle __gmpq_set_str$handle() {
        return __gmpq_set_str.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int __gmpq_set_str(mpq_ptr, const char *, int)
     * }
     */
    public static MemorySegment __gmpq_set_str$address() {
        return __gmpq_set_str.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int __gmpq_set_str(mpq_ptr, const char *, int)
     * }
     */
    public static int __gmpq_set_str(MemorySegment x0, MemorySegment x1, int x2) {
        var mh$ = __gmpq_set_str.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__gmpq_set_str", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __gmpq_set_ui {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gmp_h.C_POINTER,
            gmp_h.C_LONG,
            gmp_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__gmpq_set_ui");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void __gmpq_set_ui(mpq_ptr, unsigned long, unsigned long)
     * }
     */
    public static FunctionDescriptor __gmpq_set_ui$descriptor() {
        return __gmpq_set_ui.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void __gmpq_set_ui(mpq_ptr, unsigned long, unsigned long)
     * }
     */
    public static MethodHandle __gmpq_set_ui$handle() {
        return __gmpq_set_ui.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void __gmpq_set_ui(mpq_ptr, unsigned long, unsigned long)
     * }
     */
    public static MemorySegment __gmpq_set_ui$address() {
        return __gmpq_set_ui.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void __gmpq_set_ui(mpq_ptr, unsigned long, unsigned long)
     * }
     */
    public static void __gmpq_set_ui(MemorySegment x0, long x1, long x2) {
        var mh$ = __gmpq_set_ui.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__gmpq_set_ui", x0, x1, x2);
            }
            mh$.invokeExact(x0, x1, x2);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __gmpq_set_z {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gmp_h.C_POINTER,
            gmp_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__gmpq_set_z");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void __gmpq_set_z(mpq_ptr, mpz_srcptr)
     * }
     */
    public static FunctionDescriptor __gmpq_set_z$descriptor() {
        return __gmpq_set_z.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void __gmpq_set_z(mpq_ptr, mpz_srcptr)
     * }
     */
    public static MethodHandle __gmpq_set_z$handle() {
        return __gmpq_set_z.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void __gmpq_set_z(mpq_ptr, mpz_srcptr)
     * }
     */
    public static MemorySegment __gmpq_set_z$address() {
        return __gmpq_set_z.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void __gmpq_set_z(mpq_ptr, mpz_srcptr)
     * }
     */
    public static void __gmpq_set_z(MemorySegment x0, MemorySegment x1) {
        var mh$ = __gmpq_set_z.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__gmpq_set_z", x0, x1);
            }
            mh$.invokeExact(x0, x1);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __gmpq_sub {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gmp_h.C_POINTER,
            gmp_h.C_POINTER,
            gmp_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__gmpq_sub");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void __gmpq_sub(mpq_ptr, mpq_srcptr, mpq_srcptr)
     * }
     */
    public static FunctionDescriptor __gmpq_sub$descriptor() {
        return __gmpq_sub.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void __gmpq_sub(mpq_ptr, mpq_srcptr, mpq_srcptr)
     * }
     */
    public static MethodHandle __gmpq_sub$handle() {
        return __gmpq_sub.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void __gmpq_sub(mpq_ptr, mpq_srcptr, mpq_srcptr)
     * }
     */
    public static MemorySegment __gmpq_sub$address() {
        return __gmpq_sub.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void __gmpq_sub(mpq_ptr, mpq_srcptr, mpq_srcptr)
     * }
     */
    public static void __gmpq_sub(MemorySegment x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = __gmpq_sub.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__gmpq_sub", x0, x1, x2);
            }
            mh$.invokeExact(x0, x1, x2);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __gmpq_swap {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gmp_h.C_POINTER,
            gmp_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__gmpq_swap");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void __gmpq_swap(mpq_ptr, mpq_ptr)
     * }
     */
    public static FunctionDescriptor __gmpq_swap$descriptor() {
        return __gmpq_swap.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void __gmpq_swap(mpq_ptr, mpq_ptr)
     * }
     */
    public static MethodHandle __gmpq_swap$handle() {
        return __gmpq_swap.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void __gmpq_swap(mpq_ptr, mpq_ptr)
     * }
     */
    public static MemorySegment __gmpq_swap$address() {
        return __gmpq_swap.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void __gmpq_swap(mpq_ptr, mpq_ptr)
     * }
     */
    public static void __gmpq_swap(MemorySegment x0, MemorySegment x1) {
        var mh$ = __gmpq_swap.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__gmpq_swap", x0, x1);
            }
            mh$.invokeExact(x0, x1);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __gmpf_abs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gmp_h.C_POINTER,
            gmp_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__gmpf_abs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void __gmpf_abs(mpf_ptr, mpf_srcptr)
     * }
     */
    public static FunctionDescriptor __gmpf_abs$descriptor() {
        return __gmpf_abs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void __gmpf_abs(mpf_ptr, mpf_srcptr)
     * }
     */
    public static MethodHandle __gmpf_abs$handle() {
        return __gmpf_abs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void __gmpf_abs(mpf_ptr, mpf_srcptr)
     * }
     */
    public static MemorySegment __gmpf_abs$address() {
        return __gmpf_abs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void __gmpf_abs(mpf_ptr, mpf_srcptr)
     * }
     */
    public static void __gmpf_abs(MemorySegment x0, MemorySegment x1) {
        var mh$ = __gmpf_abs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__gmpf_abs", x0, x1);
            }
            mh$.invokeExact(x0, x1);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __gmpf_add {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gmp_h.C_POINTER,
            gmp_h.C_POINTER,
            gmp_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__gmpf_add");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void __gmpf_add(mpf_ptr, mpf_srcptr, mpf_srcptr)
     * }
     */
    public static FunctionDescriptor __gmpf_add$descriptor() {
        return __gmpf_add.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void __gmpf_add(mpf_ptr, mpf_srcptr, mpf_srcptr)
     * }
     */
    public static MethodHandle __gmpf_add$handle() {
        return __gmpf_add.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void __gmpf_add(mpf_ptr, mpf_srcptr, mpf_srcptr)
     * }
     */
    public static MemorySegment __gmpf_add$address() {
        return __gmpf_add.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void __gmpf_add(mpf_ptr, mpf_srcptr, mpf_srcptr)
     * }
     */
    public static void __gmpf_add(MemorySegment x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = __gmpf_add.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__gmpf_add", x0, x1, x2);
            }
            mh$.invokeExact(x0, x1, x2);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __gmpf_add_ui {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gmp_h.C_POINTER,
            gmp_h.C_POINTER,
            gmp_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__gmpf_add_ui");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void __gmpf_add_ui(mpf_ptr, mpf_srcptr, unsigned long)
     * }
     */
    public static FunctionDescriptor __gmpf_add_ui$descriptor() {
        return __gmpf_add_ui.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void __gmpf_add_ui(mpf_ptr, mpf_srcptr, unsigned long)
     * }
     */
    public static MethodHandle __gmpf_add_ui$handle() {
        return __gmpf_add_ui.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void __gmpf_add_ui(mpf_ptr, mpf_srcptr, unsigned long)
     * }
     */
    public static MemorySegment __gmpf_add_ui$address() {
        return __gmpf_add_ui.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void __gmpf_add_ui(mpf_ptr, mpf_srcptr, unsigned long)
     * }
     */
    public static void __gmpf_add_ui(MemorySegment x0, MemorySegment x1, long x2) {
        var mh$ = __gmpf_add_ui.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__gmpf_add_ui", x0, x1, x2);
            }
            mh$.invokeExact(x0, x1, x2);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __gmpf_ceil {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gmp_h.C_POINTER,
            gmp_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__gmpf_ceil");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void __gmpf_ceil(mpf_ptr, mpf_srcptr)
     * }
     */
    public static FunctionDescriptor __gmpf_ceil$descriptor() {
        return __gmpf_ceil.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void __gmpf_ceil(mpf_ptr, mpf_srcptr)
     * }
     */
    public static MethodHandle __gmpf_ceil$handle() {
        return __gmpf_ceil.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void __gmpf_ceil(mpf_ptr, mpf_srcptr)
     * }
     */
    public static MemorySegment __gmpf_ceil$address() {
        return __gmpf_ceil.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void __gmpf_ceil(mpf_ptr, mpf_srcptr)
     * }
     */
    public static void __gmpf_ceil(MemorySegment x0, MemorySegment x1) {
        var mh$ = __gmpf_ceil.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__gmpf_ceil", x0, x1);
            }
            mh$.invokeExact(x0, x1);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __gmpf_clear {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gmp_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__gmpf_clear");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void __gmpf_clear(mpf_ptr)
     * }
     */
    public static FunctionDescriptor __gmpf_clear$descriptor() {
        return __gmpf_clear.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void __gmpf_clear(mpf_ptr)
     * }
     */
    public static MethodHandle __gmpf_clear$handle() {
        return __gmpf_clear.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void __gmpf_clear(mpf_ptr)
     * }
     */
    public static MemorySegment __gmpf_clear$address() {
        return __gmpf_clear.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void __gmpf_clear(mpf_ptr)
     * }
     */
    public static void __gmpf_clear(MemorySegment x0) {
        var mh$ = __gmpf_clear.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__gmpf_clear", x0);
            }
            mh$.invokeExact(x0);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * void __gmpf_clears(mpf_ptr, ...)
     * }
     */
    public static class __gmpf_clears {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.ofVoid(
                gmp_h.C_POINTER
            );
        private static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__gmpf_clears");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private __gmpf_clears(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * void __gmpf_clears(mpf_ptr, ...)
         * }
         */
        public static __gmpf_clears makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new __gmpf_clears(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public void apply(MemorySegment x0, Object... x1) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("__gmpf_clears", x0, x1);
                }
                 spreader.invokeExact(x0, x1);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static class __gmpf_cmp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gmp_h.C_INT,
            gmp_h.C_POINTER,
            gmp_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__gmpf_cmp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int __gmpf_cmp(mpf_srcptr, mpf_srcptr)
     * }
     */
    public static FunctionDescriptor __gmpf_cmp$descriptor() {
        return __gmpf_cmp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int __gmpf_cmp(mpf_srcptr, mpf_srcptr)
     * }
     */
    public static MethodHandle __gmpf_cmp$handle() {
        return __gmpf_cmp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int __gmpf_cmp(mpf_srcptr, mpf_srcptr)
     * }
     */
    public static MemorySegment __gmpf_cmp$address() {
        return __gmpf_cmp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int __gmpf_cmp(mpf_srcptr, mpf_srcptr)
     * }
     */
    public static int __gmpf_cmp(MemorySegment x0, MemorySegment x1) {
        var mh$ = __gmpf_cmp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__gmpf_cmp", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __gmpf_cmp_z {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gmp_h.C_INT,
            gmp_h.C_POINTER,
            gmp_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__gmpf_cmp_z");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int __gmpf_cmp_z(mpf_srcptr, mpz_srcptr)
     * }
     */
    public static FunctionDescriptor __gmpf_cmp_z$descriptor() {
        return __gmpf_cmp_z.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int __gmpf_cmp_z(mpf_srcptr, mpz_srcptr)
     * }
     */
    public static MethodHandle __gmpf_cmp_z$handle() {
        return __gmpf_cmp_z.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int __gmpf_cmp_z(mpf_srcptr, mpz_srcptr)
     * }
     */
    public static MemorySegment __gmpf_cmp_z$address() {
        return __gmpf_cmp_z.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int __gmpf_cmp_z(mpf_srcptr, mpz_srcptr)
     * }
     */
    public static int __gmpf_cmp_z(MemorySegment x0, MemorySegment x1) {
        var mh$ = __gmpf_cmp_z.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__gmpf_cmp_z", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __gmpf_cmp_d {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gmp_h.C_INT,
            gmp_h.C_POINTER,
            gmp_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__gmpf_cmp_d");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int __gmpf_cmp_d(mpf_srcptr, double)
     * }
     */
    public static FunctionDescriptor __gmpf_cmp_d$descriptor() {
        return __gmpf_cmp_d.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int __gmpf_cmp_d(mpf_srcptr, double)
     * }
     */
    public static MethodHandle __gmpf_cmp_d$handle() {
        return __gmpf_cmp_d.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int __gmpf_cmp_d(mpf_srcptr, double)
     * }
     */
    public static MemorySegment __gmpf_cmp_d$address() {
        return __gmpf_cmp_d.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int __gmpf_cmp_d(mpf_srcptr, double)
     * }
     */
    public static int __gmpf_cmp_d(MemorySegment x0, double x1) {
        var mh$ = __gmpf_cmp_d.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__gmpf_cmp_d", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __gmpf_cmp_si {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gmp_h.C_INT,
            gmp_h.C_POINTER,
            gmp_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__gmpf_cmp_si");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int __gmpf_cmp_si(mpf_srcptr, long)
     * }
     */
    public static FunctionDescriptor __gmpf_cmp_si$descriptor() {
        return __gmpf_cmp_si.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int __gmpf_cmp_si(mpf_srcptr, long)
     * }
     */
    public static MethodHandle __gmpf_cmp_si$handle() {
        return __gmpf_cmp_si.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int __gmpf_cmp_si(mpf_srcptr, long)
     * }
     */
    public static MemorySegment __gmpf_cmp_si$address() {
        return __gmpf_cmp_si.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int __gmpf_cmp_si(mpf_srcptr, long)
     * }
     */
    public static int __gmpf_cmp_si(MemorySegment x0, long x1) {
        var mh$ = __gmpf_cmp_si.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__gmpf_cmp_si", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __gmpf_cmp_ui {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gmp_h.C_INT,
            gmp_h.C_POINTER,
            gmp_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__gmpf_cmp_ui");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int __gmpf_cmp_ui(mpf_srcptr, unsigned long)
     * }
     */
    public static FunctionDescriptor __gmpf_cmp_ui$descriptor() {
        return __gmpf_cmp_ui.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int __gmpf_cmp_ui(mpf_srcptr, unsigned long)
     * }
     */
    public static MethodHandle __gmpf_cmp_ui$handle() {
        return __gmpf_cmp_ui.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int __gmpf_cmp_ui(mpf_srcptr, unsigned long)
     * }
     */
    public static MemorySegment __gmpf_cmp_ui$address() {
        return __gmpf_cmp_ui.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int __gmpf_cmp_ui(mpf_srcptr, unsigned long)
     * }
     */
    public static int __gmpf_cmp_ui(MemorySegment x0, long x1) {
        var mh$ = __gmpf_cmp_ui.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__gmpf_cmp_ui", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __gmpf_div {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gmp_h.C_POINTER,
            gmp_h.C_POINTER,
            gmp_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__gmpf_div");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void __gmpf_div(mpf_ptr, mpf_srcptr, mpf_srcptr)
     * }
     */
    public static FunctionDescriptor __gmpf_div$descriptor() {
        return __gmpf_div.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void __gmpf_div(mpf_ptr, mpf_srcptr, mpf_srcptr)
     * }
     */
    public static MethodHandle __gmpf_div$handle() {
        return __gmpf_div.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void __gmpf_div(mpf_ptr, mpf_srcptr, mpf_srcptr)
     * }
     */
    public static MemorySegment __gmpf_div$address() {
        return __gmpf_div.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void __gmpf_div(mpf_ptr, mpf_srcptr, mpf_srcptr)
     * }
     */
    public static void __gmpf_div(MemorySegment x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = __gmpf_div.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__gmpf_div", x0, x1, x2);
            }
            mh$.invokeExact(x0, x1, x2);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __gmpf_div_2exp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gmp_h.C_POINTER,
            gmp_h.C_POINTER,
            gmp_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__gmpf_div_2exp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void __gmpf_div_2exp(mpf_ptr, mpf_srcptr, mp_bitcnt_t)
     * }
     */
    public static FunctionDescriptor __gmpf_div_2exp$descriptor() {
        return __gmpf_div_2exp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void __gmpf_div_2exp(mpf_ptr, mpf_srcptr, mp_bitcnt_t)
     * }
     */
    public static MethodHandle __gmpf_div_2exp$handle() {
        return __gmpf_div_2exp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void __gmpf_div_2exp(mpf_ptr, mpf_srcptr, mp_bitcnt_t)
     * }
     */
    public static MemorySegment __gmpf_div_2exp$address() {
        return __gmpf_div_2exp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void __gmpf_div_2exp(mpf_ptr, mpf_srcptr, mp_bitcnt_t)
     * }
     */
    public static void __gmpf_div_2exp(MemorySegment x0, MemorySegment x1, long x2) {
        var mh$ = __gmpf_div_2exp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__gmpf_div_2exp", x0, x1, x2);
            }
            mh$.invokeExact(x0, x1, x2);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __gmpf_div_ui {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gmp_h.C_POINTER,
            gmp_h.C_POINTER,
            gmp_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__gmpf_div_ui");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void __gmpf_div_ui(mpf_ptr, mpf_srcptr, unsigned long)
     * }
     */
    public static FunctionDescriptor __gmpf_div_ui$descriptor() {
        return __gmpf_div_ui.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void __gmpf_div_ui(mpf_ptr, mpf_srcptr, unsigned long)
     * }
     */
    public static MethodHandle __gmpf_div_ui$handle() {
        return __gmpf_div_ui.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void __gmpf_div_ui(mpf_ptr, mpf_srcptr, unsigned long)
     * }
     */
    public static MemorySegment __gmpf_div_ui$address() {
        return __gmpf_div_ui.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void __gmpf_div_ui(mpf_ptr, mpf_srcptr, unsigned long)
     * }
     */
    public static void __gmpf_div_ui(MemorySegment x0, MemorySegment x1, long x2) {
        var mh$ = __gmpf_div_ui.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__gmpf_div_ui", x0, x1, x2);
            }
            mh$.invokeExact(x0, x1, x2);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __gmpf_dump {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gmp_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__gmpf_dump");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void __gmpf_dump(mpf_srcptr)
     * }
     */
    public static FunctionDescriptor __gmpf_dump$descriptor() {
        return __gmpf_dump.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void __gmpf_dump(mpf_srcptr)
     * }
     */
    public static MethodHandle __gmpf_dump$handle() {
        return __gmpf_dump.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void __gmpf_dump(mpf_srcptr)
     * }
     */
    public static MemorySegment __gmpf_dump$address() {
        return __gmpf_dump.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void __gmpf_dump(mpf_srcptr)
     * }
     */
    public static void __gmpf_dump(MemorySegment x0) {
        var mh$ = __gmpf_dump.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__gmpf_dump", x0);
            }
            mh$.invokeExact(x0);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __gmpf_eq {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gmp_h.C_INT,
            gmp_h.C_POINTER,
            gmp_h.C_POINTER,
            gmp_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__gmpf_eq");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int __gmpf_eq(mpf_srcptr, mpf_srcptr, mp_bitcnt_t)
     * }
     */
    public static FunctionDescriptor __gmpf_eq$descriptor() {
        return __gmpf_eq.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int __gmpf_eq(mpf_srcptr, mpf_srcptr, mp_bitcnt_t)
     * }
     */
    public static MethodHandle __gmpf_eq$handle() {
        return __gmpf_eq.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int __gmpf_eq(mpf_srcptr, mpf_srcptr, mp_bitcnt_t)
     * }
     */
    public static MemorySegment __gmpf_eq$address() {
        return __gmpf_eq.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int __gmpf_eq(mpf_srcptr, mpf_srcptr, mp_bitcnt_t)
     * }
     */
    public static int __gmpf_eq(MemorySegment x0, MemorySegment x1, long x2) {
        var mh$ = __gmpf_eq.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__gmpf_eq", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __gmpf_fits_sint_p {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gmp_h.C_INT,
            gmp_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__gmpf_fits_sint_p");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int __gmpf_fits_sint_p(mpf_srcptr)
     * }
     */
    public static FunctionDescriptor __gmpf_fits_sint_p$descriptor() {
        return __gmpf_fits_sint_p.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int __gmpf_fits_sint_p(mpf_srcptr)
     * }
     */
    public static MethodHandle __gmpf_fits_sint_p$handle() {
        return __gmpf_fits_sint_p.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int __gmpf_fits_sint_p(mpf_srcptr)
     * }
     */
    public static MemorySegment __gmpf_fits_sint_p$address() {
        return __gmpf_fits_sint_p.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int __gmpf_fits_sint_p(mpf_srcptr)
     * }
     */
    public static int __gmpf_fits_sint_p(MemorySegment x0) {
        var mh$ = __gmpf_fits_sint_p.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__gmpf_fits_sint_p", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __gmpf_fits_slong_p {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gmp_h.C_INT,
            gmp_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__gmpf_fits_slong_p");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int __gmpf_fits_slong_p(mpf_srcptr)
     * }
     */
    public static FunctionDescriptor __gmpf_fits_slong_p$descriptor() {
        return __gmpf_fits_slong_p.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int __gmpf_fits_slong_p(mpf_srcptr)
     * }
     */
    public static MethodHandle __gmpf_fits_slong_p$handle() {
        return __gmpf_fits_slong_p.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int __gmpf_fits_slong_p(mpf_srcptr)
     * }
     */
    public static MemorySegment __gmpf_fits_slong_p$address() {
        return __gmpf_fits_slong_p.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int __gmpf_fits_slong_p(mpf_srcptr)
     * }
     */
    public static int __gmpf_fits_slong_p(MemorySegment x0) {
        var mh$ = __gmpf_fits_slong_p.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__gmpf_fits_slong_p", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __gmpf_fits_sshort_p {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gmp_h.C_INT,
            gmp_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__gmpf_fits_sshort_p");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int __gmpf_fits_sshort_p(mpf_srcptr)
     * }
     */
    public static FunctionDescriptor __gmpf_fits_sshort_p$descriptor() {
        return __gmpf_fits_sshort_p.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int __gmpf_fits_sshort_p(mpf_srcptr)
     * }
     */
    public static MethodHandle __gmpf_fits_sshort_p$handle() {
        return __gmpf_fits_sshort_p.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int __gmpf_fits_sshort_p(mpf_srcptr)
     * }
     */
    public static MemorySegment __gmpf_fits_sshort_p$address() {
        return __gmpf_fits_sshort_p.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int __gmpf_fits_sshort_p(mpf_srcptr)
     * }
     */
    public static int __gmpf_fits_sshort_p(MemorySegment x0) {
        var mh$ = __gmpf_fits_sshort_p.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__gmpf_fits_sshort_p", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __gmpf_fits_uint_p {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gmp_h.C_INT,
            gmp_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__gmpf_fits_uint_p");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int __gmpf_fits_uint_p(mpf_srcptr)
     * }
     */
    public static FunctionDescriptor __gmpf_fits_uint_p$descriptor() {
        return __gmpf_fits_uint_p.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int __gmpf_fits_uint_p(mpf_srcptr)
     * }
     */
    public static MethodHandle __gmpf_fits_uint_p$handle() {
        return __gmpf_fits_uint_p.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int __gmpf_fits_uint_p(mpf_srcptr)
     * }
     */
    public static MemorySegment __gmpf_fits_uint_p$address() {
        return __gmpf_fits_uint_p.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int __gmpf_fits_uint_p(mpf_srcptr)
     * }
     */
    public static int __gmpf_fits_uint_p(MemorySegment x0) {
        var mh$ = __gmpf_fits_uint_p.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__gmpf_fits_uint_p", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __gmpf_fits_ulong_p {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gmp_h.C_INT,
            gmp_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__gmpf_fits_ulong_p");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int __gmpf_fits_ulong_p(mpf_srcptr)
     * }
     */
    public static FunctionDescriptor __gmpf_fits_ulong_p$descriptor() {
        return __gmpf_fits_ulong_p.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int __gmpf_fits_ulong_p(mpf_srcptr)
     * }
     */
    public static MethodHandle __gmpf_fits_ulong_p$handle() {
        return __gmpf_fits_ulong_p.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int __gmpf_fits_ulong_p(mpf_srcptr)
     * }
     */
    public static MemorySegment __gmpf_fits_ulong_p$address() {
        return __gmpf_fits_ulong_p.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int __gmpf_fits_ulong_p(mpf_srcptr)
     * }
     */
    public static int __gmpf_fits_ulong_p(MemorySegment x0) {
        var mh$ = __gmpf_fits_ulong_p.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__gmpf_fits_ulong_p", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __gmpf_fits_ushort_p {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gmp_h.C_INT,
            gmp_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__gmpf_fits_ushort_p");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int __gmpf_fits_ushort_p(mpf_srcptr)
     * }
     */
    public static FunctionDescriptor __gmpf_fits_ushort_p$descriptor() {
        return __gmpf_fits_ushort_p.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int __gmpf_fits_ushort_p(mpf_srcptr)
     * }
     */
    public static MethodHandle __gmpf_fits_ushort_p$handle() {
        return __gmpf_fits_ushort_p.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int __gmpf_fits_ushort_p(mpf_srcptr)
     * }
     */
    public static MemorySegment __gmpf_fits_ushort_p$address() {
        return __gmpf_fits_ushort_p.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int __gmpf_fits_ushort_p(mpf_srcptr)
     * }
     */
    public static int __gmpf_fits_ushort_p(MemorySegment x0) {
        var mh$ = __gmpf_fits_ushort_p.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__gmpf_fits_ushort_p", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __gmpf_floor {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gmp_h.C_POINTER,
            gmp_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__gmpf_floor");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void __gmpf_floor(mpf_ptr, mpf_srcptr)
     * }
     */
    public static FunctionDescriptor __gmpf_floor$descriptor() {
        return __gmpf_floor.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void __gmpf_floor(mpf_ptr, mpf_srcptr)
     * }
     */
    public static MethodHandle __gmpf_floor$handle() {
        return __gmpf_floor.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void __gmpf_floor(mpf_ptr, mpf_srcptr)
     * }
     */
    public static MemorySegment __gmpf_floor$address() {
        return __gmpf_floor.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void __gmpf_floor(mpf_ptr, mpf_srcptr)
     * }
     */
    public static void __gmpf_floor(MemorySegment x0, MemorySegment x1) {
        var mh$ = __gmpf_floor.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__gmpf_floor", x0, x1);
            }
            mh$.invokeExact(x0, x1);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __gmpf_get_d {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gmp_h.C_DOUBLE,
            gmp_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__gmpf_get_d");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double __gmpf_get_d(mpf_srcptr)
     * }
     */
    public static FunctionDescriptor __gmpf_get_d$descriptor() {
        return __gmpf_get_d.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double __gmpf_get_d(mpf_srcptr)
     * }
     */
    public static MethodHandle __gmpf_get_d$handle() {
        return __gmpf_get_d.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double __gmpf_get_d(mpf_srcptr)
     * }
     */
    public static MemorySegment __gmpf_get_d$address() {
        return __gmpf_get_d.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double __gmpf_get_d(mpf_srcptr)
     * }
     */
    public static double __gmpf_get_d(MemorySegment x0) {
        var mh$ = __gmpf_get_d.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__gmpf_get_d", x0);
            }
            return (double)mh$.invokeExact(x0);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __gmpf_get_d_2exp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gmp_h.C_DOUBLE,
            gmp_h.C_POINTER,
            gmp_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__gmpf_get_d_2exp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double __gmpf_get_d_2exp(long *, mpf_srcptr)
     * }
     */
    public static FunctionDescriptor __gmpf_get_d_2exp$descriptor() {
        return __gmpf_get_d_2exp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double __gmpf_get_d_2exp(long *, mpf_srcptr)
     * }
     */
    public static MethodHandle __gmpf_get_d_2exp$handle() {
        return __gmpf_get_d_2exp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double __gmpf_get_d_2exp(long *, mpf_srcptr)
     * }
     */
    public static MemorySegment __gmpf_get_d_2exp$address() {
        return __gmpf_get_d_2exp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double __gmpf_get_d_2exp(long *, mpf_srcptr)
     * }
     */
    public static double __gmpf_get_d_2exp(MemorySegment x0, MemorySegment x1) {
        var mh$ = __gmpf_get_d_2exp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__gmpf_get_d_2exp", x0, x1);
            }
            return (double)mh$.invokeExact(x0, x1);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __gmpf_get_default_prec {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gmp_h.C_LONG    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__gmpf_get_default_prec");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * mp_bitcnt_t __gmpf_get_default_prec()
     * }
     */
    public static FunctionDescriptor __gmpf_get_default_prec$descriptor() {
        return __gmpf_get_default_prec.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * mp_bitcnt_t __gmpf_get_default_prec()
     * }
     */
    public static MethodHandle __gmpf_get_default_prec$handle() {
        return __gmpf_get_default_prec.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * mp_bitcnt_t __gmpf_get_default_prec()
     * }
     */
    public static MemorySegment __gmpf_get_default_prec$address() {
        return __gmpf_get_default_prec.ADDR;
    }

    /**
     * {@snippet lang=c :
     * mp_bitcnt_t __gmpf_get_default_prec()
     * }
     */
    public static long __gmpf_get_default_prec() {
        var mh$ = __gmpf_get_default_prec.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__gmpf_get_default_prec");
            }
            return (long)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __gmpf_get_prec {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gmp_h.C_LONG,
            gmp_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__gmpf_get_prec");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * mp_bitcnt_t __gmpf_get_prec(mpf_srcptr)
     * }
     */
    public static FunctionDescriptor __gmpf_get_prec$descriptor() {
        return __gmpf_get_prec.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * mp_bitcnt_t __gmpf_get_prec(mpf_srcptr)
     * }
     */
    public static MethodHandle __gmpf_get_prec$handle() {
        return __gmpf_get_prec.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * mp_bitcnt_t __gmpf_get_prec(mpf_srcptr)
     * }
     */
    public static MemorySegment __gmpf_get_prec$address() {
        return __gmpf_get_prec.ADDR;
    }

    /**
     * {@snippet lang=c :
     * mp_bitcnt_t __gmpf_get_prec(mpf_srcptr)
     * }
     */
    public static long __gmpf_get_prec(MemorySegment x0) {
        var mh$ = __gmpf_get_prec.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__gmpf_get_prec", x0);
            }
            return (long)mh$.invokeExact(x0);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __gmpf_get_si {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gmp_h.C_LONG,
            gmp_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__gmpf_get_si");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long __gmpf_get_si(mpf_srcptr)
     * }
     */
    public static FunctionDescriptor __gmpf_get_si$descriptor() {
        return __gmpf_get_si.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long __gmpf_get_si(mpf_srcptr)
     * }
     */
    public static MethodHandle __gmpf_get_si$handle() {
        return __gmpf_get_si.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long __gmpf_get_si(mpf_srcptr)
     * }
     */
    public static MemorySegment __gmpf_get_si$address() {
        return __gmpf_get_si.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long __gmpf_get_si(mpf_srcptr)
     * }
     */
    public static long __gmpf_get_si(MemorySegment x0) {
        var mh$ = __gmpf_get_si.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__gmpf_get_si", x0);
            }
            return (long)mh$.invokeExact(x0);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __gmpf_get_str {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gmp_h.C_POINTER,
            gmp_h.C_POINTER,
            gmp_h.C_POINTER,
            gmp_h.C_INT,
            gmp_h.C_LONG,
            gmp_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__gmpf_get_str");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *__gmpf_get_str(char *, mp_exp_t *, int, size_t, mpf_srcptr)
     * }
     */
    public static FunctionDescriptor __gmpf_get_str$descriptor() {
        return __gmpf_get_str.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *__gmpf_get_str(char *, mp_exp_t *, int, size_t, mpf_srcptr)
     * }
     */
    public static MethodHandle __gmpf_get_str$handle() {
        return __gmpf_get_str.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *__gmpf_get_str(char *, mp_exp_t *, int, size_t, mpf_srcptr)
     * }
     */
    public static MemorySegment __gmpf_get_str$address() {
        return __gmpf_get_str.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *__gmpf_get_str(char *, mp_exp_t *, int, size_t, mpf_srcptr)
     * }
     */
    public static MemorySegment __gmpf_get_str(MemorySegment x0, MemorySegment x1, int x2, long x3, MemorySegment x4) {
        var mh$ = __gmpf_get_str.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__gmpf_get_str", x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1, x2, x3, x4);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __gmpf_get_ui {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gmp_h.C_LONG,
            gmp_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__gmpf_get_ui");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned long __gmpf_get_ui(mpf_srcptr)
     * }
     */
    public static FunctionDescriptor __gmpf_get_ui$descriptor() {
        return __gmpf_get_ui.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned long __gmpf_get_ui(mpf_srcptr)
     * }
     */
    public static MethodHandle __gmpf_get_ui$handle() {
        return __gmpf_get_ui.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned long __gmpf_get_ui(mpf_srcptr)
     * }
     */
    public static MemorySegment __gmpf_get_ui$address() {
        return __gmpf_get_ui.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned long __gmpf_get_ui(mpf_srcptr)
     * }
     */
    public static long __gmpf_get_ui(MemorySegment x0) {
        var mh$ = __gmpf_get_ui.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__gmpf_get_ui", x0);
            }
            return (long)mh$.invokeExact(x0);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __gmpf_init {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gmp_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__gmpf_init");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void __gmpf_init(mpf_ptr)
     * }
     */
    public static FunctionDescriptor __gmpf_init$descriptor() {
        return __gmpf_init.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void __gmpf_init(mpf_ptr)
     * }
     */
    public static MethodHandle __gmpf_init$handle() {
        return __gmpf_init.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void __gmpf_init(mpf_ptr)
     * }
     */
    public static MemorySegment __gmpf_init$address() {
        return __gmpf_init.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void __gmpf_init(mpf_ptr)
     * }
     */
    public static void __gmpf_init(MemorySegment x0) {
        var mh$ = __gmpf_init.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__gmpf_init", x0);
            }
            mh$.invokeExact(x0);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __gmpf_init2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gmp_h.C_POINTER,
            gmp_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__gmpf_init2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void __gmpf_init2(mpf_ptr, mp_bitcnt_t)
     * }
     */
    public static FunctionDescriptor __gmpf_init2$descriptor() {
        return __gmpf_init2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void __gmpf_init2(mpf_ptr, mp_bitcnt_t)
     * }
     */
    public static MethodHandle __gmpf_init2$handle() {
        return __gmpf_init2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void __gmpf_init2(mpf_ptr, mp_bitcnt_t)
     * }
     */
    public static MemorySegment __gmpf_init2$address() {
        return __gmpf_init2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void __gmpf_init2(mpf_ptr, mp_bitcnt_t)
     * }
     */
    public static void __gmpf_init2(MemorySegment x0, long x1) {
        var mh$ = __gmpf_init2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__gmpf_init2", x0, x1);
            }
            mh$.invokeExact(x0, x1);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * void __gmpf_inits(mpf_ptr, ...)
     * }
     */
    public static class __gmpf_inits {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.ofVoid(
                gmp_h.C_POINTER
            );
        private static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__gmpf_inits");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private __gmpf_inits(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * void __gmpf_inits(mpf_ptr, ...)
         * }
         */
        public static __gmpf_inits makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new __gmpf_inits(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public void apply(MemorySegment x0, Object... x1) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("__gmpf_inits", x0, x1);
                }
                 spreader.invokeExact(x0, x1);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static class __gmpf_init_set {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gmp_h.C_POINTER,
            gmp_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__gmpf_init_set");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void __gmpf_init_set(mpf_ptr, mpf_srcptr)
     * }
     */
    public static FunctionDescriptor __gmpf_init_set$descriptor() {
        return __gmpf_init_set.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void __gmpf_init_set(mpf_ptr, mpf_srcptr)
     * }
     */
    public static MethodHandle __gmpf_init_set$handle() {
        return __gmpf_init_set.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void __gmpf_init_set(mpf_ptr, mpf_srcptr)
     * }
     */
    public static MemorySegment __gmpf_init_set$address() {
        return __gmpf_init_set.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void __gmpf_init_set(mpf_ptr, mpf_srcptr)
     * }
     */
    public static void __gmpf_init_set(MemorySegment x0, MemorySegment x1) {
        var mh$ = __gmpf_init_set.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__gmpf_init_set", x0, x1);
            }
            mh$.invokeExact(x0, x1);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __gmpf_init_set_d {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gmp_h.C_POINTER,
            gmp_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__gmpf_init_set_d");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void __gmpf_init_set_d(mpf_ptr, double)
     * }
     */
    public static FunctionDescriptor __gmpf_init_set_d$descriptor() {
        return __gmpf_init_set_d.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void __gmpf_init_set_d(mpf_ptr, double)
     * }
     */
    public static MethodHandle __gmpf_init_set_d$handle() {
        return __gmpf_init_set_d.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void __gmpf_init_set_d(mpf_ptr, double)
     * }
     */
    public static MemorySegment __gmpf_init_set_d$address() {
        return __gmpf_init_set_d.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void __gmpf_init_set_d(mpf_ptr, double)
     * }
     */
    public static void __gmpf_init_set_d(MemorySegment x0, double x1) {
        var mh$ = __gmpf_init_set_d.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__gmpf_init_set_d", x0, x1);
            }
            mh$.invokeExact(x0, x1);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __gmpf_init_set_si {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gmp_h.C_POINTER,
            gmp_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__gmpf_init_set_si");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void __gmpf_init_set_si(mpf_ptr, long)
     * }
     */
    public static FunctionDescriptor __gmpf_init_set_si$descriptor() {
        return __gmpf_init_set_si.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void __gmpf_init_set_si(mpf_ptr, long)
     * }
     */
    public static MethodHandle __gmpf_init_set_si$handle() {
        return __gmpf_init_set_si.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void __gmpf_init_set_si(mpf_ptr, long)
     * }
     */
    public static MemorySegment __gmpf_init_set_si$address() {
        return __gmpf_init_set_si.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void __gmpf_init_set_si(mpf_ptr, long)
     * }
     */
    public static void __gmpf_init_set_si(MemorySegment x0, long x1) {
        var mh$ = __gmpf_init_set_si.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__gmpf_init_set_si", x0, x1);
            }
            mh$.invokeExact(x0, x1);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __gmpf_init_set_str {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gmp_h.C_INT,
            gmp_h.C_POINTER,
            gmp_h.C_POINTER,
            gmp_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__gmpf_init_set_str");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int __gmpf_init_set_str(mpf_ptr, const char *, int)
     * }
     */
    public static FunctionDescriptor __gmpf_init_set_str$descriptor() {
        return __gmpf_init_set_str.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int __gmpf_init_set_str(mpf_ptr, const char *, int)
     * }
     */
    public static MethodHandle __gmpf_init_set_str$handle() {
        return __gmpf_init_set_str.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int __gmpf_init_set_str(mpf_ptr, const char *, int)
     * }
     */
    public static MemorySegment __gmpf_init_set_str$address() {
        return __gmpf_init_set_str.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int __gmpf_init_set_str(mpf_ptr, const char *, int)
     * }
     */
    public static int __gmpf_init_set_str(MemorySegment x0, MemorySegment x1, int x2) {
        var mh$ = __gmpf_init_set_str.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__gmpf_init_set_str", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __gmpf_init_set_ui {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gmp_h.C_POINTER,
            gmp_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__gmpf_init_set_ui");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void __gmpf_init_set_ui(mpf_ptr, unsigned long)
     * }
     */
    public static FunctionDescriptor __gmpf_init_set_ui$descriptor() {
        return __gmpf_init_set_ui.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void __gmpf_init_set_ui(mpf_ptr, unsigned long)
     * }
     */
    public static MethodHandle __gmpf_init_set_ui$handle() {
        return __gmpf_init_set_ui.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void __gmpf_init_set_ui(mpf_ptr, unsigned long)
     * }
     */
    public static MemorySegment __gmpf_init_set_ui$address() {
        return __gmpf_init_set_ui.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void __gmpf_init_set_ui(mpf_ptr, unsigned long)
     * }
     */
    public static void __gmpf_init_set_ui(MemorySegment x0, long x1) {
        var mh$ = __gmpf_init_set_ui.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__gmpf_init_set_ui", x0, x1);
            }
            mh$.invokeExact(x0, x1);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __gmpf_integer_p {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gmp_h.C_INT,
            gmp_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__gmpf_integer_p");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int __gmpf_integer_p(mpf_srcptr)
     * }
     */
    public static FunctionDescriptor __gmpf_integer_p$descriptor() {
        return __gmpf_integer_p.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int __gmpf_integer_p(mpf_srcptr)
     * }
     */
    public static MethodHandle __gmpf_integer_p$handle() {
        return __gmpf_integer_p.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int __gmpf_integer_p(mpf_srcptr)
     * }
     */
    public static MemorySegment __gmpf_integer_p$address() {
        return __gmpf_integer_p.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int __gmpf_integer_p(mpf_srcptr)
     * }
     */
    public static int __gmpf_integer_p(MemorySegment x0) {
        var mh$ = __gmpf_integer_p.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__gmpf_integer_p", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __gmpf_mul {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gmp_h.C_POINTER,
            gmp_h.C_POINTER,
            gmp_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__gmpf_mul");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void __gmpf_mul(mpf_ptr, mpf_srcptr, mpf_srcptr)
     * }
     */
    public static FunctionDescriptor __gmpf_mul$descriptor() {
        return __gmpf_mul.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void __gmpf_mul(mpf_ptr, mpf_srcptr, mpf_srcptr)
     * }
     */
    public static MethodHandle __gmpf_mul$handle() {
        return __gmpf_mul.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void __gmpf_mul(mpf_ptr, mpf_srcptr, mpf_srcptr)
     * }
     */
    public static MemorySegment __gmpf_mul$address() {
        return __gmpf_mul.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void __gmpf_mul(mpf_ptr, mpf_srcptr, mpf_srcptr)
     * }
     */
    public static void __gmpf_mul(MemorySegment x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = __gmpf_mul.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__gmpf_mul", x0, x1, x2);
            }
            mh$.invokeExact(x0, x1, x2);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __gmpf_mul_2exp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gmp_h.C_POINTER,
            gmp_h.C_POINTER,
            gmp_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__gmpf_mul_2exp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void __gmpf_mul_2exp(mpf_ptr, mpf_srcptr, mp_bitcnt_t)
     * }
     */
    public static FunctionDescriptor __gmpf_mul_2exp$descriptor() {
        return __gmpf_mul_2exp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void __gmpf_mul_2exp(mpf_ptr, mpf_srcptr, mp_bitcnt_t)
     * }
     */
    public static MethodHandle __gmpf_mul_2exp$handle() {
        return __gmpf_mul_2exp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void __gmpf_mul_2exp(mpf_ptr, mpf_srcptr, mp_bitcnt_t)
     * }
     */
    public static MemorySegment __gmpf_mul_2exp$address() {
        return __gmpf_mul_2exp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void __gmpf_mul_2exp(mpf_ptr, mpf_srcptr, mp_bitcnt_t)
     * }
     */
    public static void __gmpf_mul_2exp(MemorySegment x0, MemorySegment x1, long x2) {
        var mh$ = __gmpf_mul_2exp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__gmpf_mul_2exp", x0, x1, x2);
            }
            mh$.invokeExact(x0, x1, x2);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __gmpf_mul_ui {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gmp_h.C_POINTER,
            gmp_h.C_POINTER,
            gmp_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__gmpf_mul_ui");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void __gmpf_mul_ui(mpf_ptr, mpf_srcptr, unsigned long)
     * }
     */
    public static FunctionDescriptor __gmpf_mul_ui$descriptor() {
        return __gmpf_mul_ui.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void __gmpf_mul_ui(mpf_ptr, mpf_srcptr, unsigned long)
     * }
     */
    public static MethodHandle __gmpf_mul_ui$handle() {
        return __gmpf_mul_ui.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void __gmpf_mul_ui(mpf_ptr, mpf_srcptr, unsigned long)
     * }
     */
    public static MemorySegment __gmpf_mul_ui$address() {
        return __gmpf_mul_ui.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void __gmpf_mul_ui(mpf_ptr, mpf_srcptr, unsigned long)
     * }
     */
    public static void __gmpf_mul_ui(MemorySegment x0, MemorySegment x1, long x2) {
        var mh$ = __gmpf_mul_ui.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__gmpf_mul_ui", x0, x1, x2);
            }
            mh$.invokeExact(x0, x1, x2);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __gmpf_neg {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gmp_h.C_POINTER,
            gmp_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__gmpf_neg");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void __gmpf_neg(mpf_ptr, mpf_srcptr)
     * }
     */
    public static FunctionDescriptor __gmpf_neg$descriptor() {
        return __gmpf_neg.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void __gmpf_neg(mpf_ptr, mpf_srcptr)
     * }
     */
    public static MethodHandle __gmpf_neg$handle() {
        return __gmpf_neg.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void __gmpf_neg(mpf_ptr, mpf_srcptr)
     * }
     */
    public static MemorySegment __gmpf_neg$address() {
        return __gmpf_neg.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void __gmpf_neg(mpf_ptr, mpf_srcptr)
     * }
     */
    public static void __gmpf_neg(MemorySegment x0, MemorySegment x1) {
        var mh$ = __gmpf_neg.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__gmpf_neg", x0, x1);
            }
            mh$.invokeExact(x0, x1);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __gmpf_pow_ui {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gmp_h.C_POINTER,
            gmp_h.C_POINTER,
            gmp_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__gmpf_pow_ui");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void __gmpf_pow_ui(mpf_ptr, mpf_srcptr, unsigned long)
     * }
     */
    public static FunctionDescriptor __gmpf_pow_ui$descriptor() {
        return __gmpf_pow_ui.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void __gmpf_pow_ui(mpf_ptr, mpf_srcptr, unsigned long)
     * }
     */
    public static MethodHandle __gmpf_pow_ui$handle() {
        return __gmpf_pow_ui.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void __gmpf_pow_ui(mpf_ptr, mpf_srcptr, unsigned long)
     * }
     */
    public static MemorySegment __gmpf_pow_ui$address() {
        return __gmpf_pow_ui.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void __gmpf_pow_ui(mpf_ptr, mpf_srcptr, unsigned long)
     * }
     */
    public static void __gmpf_pow_ui(MemorySegment x0, MemorySegment x1, long x2) {
        var mh$ = __gmpf_pow_ui.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__gmpf_pow_ui", x0, x1, x2);
            }
            mh$.invokeExact(x0, x1, x2);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __gmpf_random2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gmp_h.C_POINTER,
            gmp_h.C_LONG,
            gmp_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__gmpf_random2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void __gmpf_random2(mpf_ptr, mp_size_t, mp_exp_t)
     * }
     */
    public static FunctionDescriptor __gmpf_random2$descriptor() {
        return __gmpf_random2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void __gmpf_random2(mpf_ptr, mp_size_t, mp_exp_t)
     * }
     */
    public static MethodHandle __gmpf_random2$handle() {
        return __gmpf_random2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void __gmpf_random2(mpf_ptr, mp_size_t, mp_exp_t)
     * }
     */
    public static MemorySegment __gmpf_random2$address() {
        return __gmpf_random2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void __gmpf_random2(mpf_ptr, mp_size_t, mp_exp_t)
     * }
     */
    public static void __gmpf_random2(MemorySegment x0, long x1, long x2) {
        var mh$ = __gmpf_random2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__gmpf_random2", x0, x1, x2);
            }
            mh$.invokeExact(x0, x1, x2);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __gmpf_reldiff {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gmp_h.C_POINTER,
            gmp_h.C_POINTER,
            gmp_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__gmpf_reldiff");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void __gmpf_reldiff(mpf_ptr, mpf_srcptr, mpf_srcptr)
     * }
     */
    public static FunctionDescriptor __gmpf_reldiff$descriptor() {
        return __gmpf_reldiff.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void __gmpf_reldiff(mpf_ptr, mpf_srcptr, mpf_srcptr)
     * }
     */
    public static MethodHandle __gmpf_reldiff$handle() {
        return __gmpf_reldiff.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void __gmpf_reldiff(mpf_ptr, mpf_srcptr, mpf_srcptr)
     * }
     */
    public static MemorySegment __gmpf_reldiff$address() {
        return __gmpf_reldiff.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void __gmpf_reldiff(mpf_ptr, mpf_srcptr, mpf_srcptr)
     * }
     */
    public static void __gmpf_reldiff(MemorySegment x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = __gmpf_reldiff.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__gmpf_reldiff", x0, x1, x2);
            }
            mh$.invokeExact(x0, x1, x2);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __gmpf_set {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gmp_h.C_POINTER,
            gmp_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__gmpf_set");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void __gmpf_set(mpf_ptr, mpf_srcptr)
     * }
     */
    public static FunctionDescriptor __gmpf_set$descriptor() {
        return __gmpf_set.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void __gmpf_set(mpf_ptr, mpf_srcptr)
     * }
     */
    public static MethodHandle __gmpf_set$handle() {
        return __gmpf_set.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void __gmpf_set(mpf_ptr, mpf_srcptr)
     * }
     */
    public static MemorySegment __gmpf_set$address() {
        return __gmpf_set.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void __gmpf_set(mpf_ptr, mpf_srcptr)
     * }
     */
    public static void __gmpf_set(MemorySegment x0, MemorySegment x1) {
        var mh$ = __gmpf_set.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__gmpf_set", x0, x1);
            }
            mh$.invokeExact(x0, x1);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __gmpf_set_d {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gmp_h.C_POINTER,
            gmp_h.C_DOUBLE
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__gmpf_set_d");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void __gmpf_set_d(mpf_ptr, double)
     * }
     */
    public static FunctionDescriptor __gmpf_set_d$descriptor() {
        return __gmpf_set_d.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void __gmpf_set_d(mpf_ptr, double)
     * }
     */
    public static MethodHandle __gmpf_set_d$handle() {
        return __gmpf_set_d.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void __gmpf_set_d(mpf_ptr, double)
     * }
     */
    public static MemorySegment __gmpf_set_d$address() {
        return __gmpf_set_d.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void __gmpf_set_d(mpf_ptr, double)
     * }
     */
    public static void __gmpf_set_d(MemorySegment x0, double x1) {
        var mh$ = __gmpf_set_d.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__gmpf_set_d", x0, x1);
            }
            mh$.invokeExact(x0, x1);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __gmpf_set_default_prec {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gmp_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__gmpf_set_default_prec");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void __gmpf_set_default_prec(mp_bitcnt_t)
     * }
     */
    public static FunctionDescriptor __gmpf_set_default_prec$descriptor() {
        return __gmpf_set_default_prec.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void __gmpf_set_default_prec(mp_bitcnt_t)
     * }
     */
    public static MethodHandle __gmpf_set_default_prec$handle() {
        return __gmpf_set_default_prec.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void __gmpf_set_default_prec(mp_bitcnt_t)
     * }
     */
    public static MemorySegment __gmpf_set_default_prec$address() {
        return __gmpf_set_default_prec.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void __gmpf_set_default_prec(mp_bitcnt_t)
     * }
     */
    public static void __gmpf_set_default_prec(long x0) {
        var mh$ = __gmpf_set_default_prec.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__gmpf_set_default_prec", x0);
            }
            mh$.invokeExact(x0);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __gmpf_set_prec {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gmp_h.C_POINTER,
            gmp_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__gmpf_set_prec");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void __gmpf_set_prec(mpf_ptr, mp_bitcnt_t)
     * }
     */
    public static FunctionDescriptor __gmpf_set_prec$descriptor() {
        return __gmpf_set_prec.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void __gmpf_set_prec(mpf_ptr, mp_bitcnt_t)
     * }
     */
    public static MethodHandle __gmpf_set_prec$handle() {
        return __gmpf_set_prec.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void __gmpf_set_prec(mpf_ptr, mp_bitcnt_t)
     * }
     */
    public static MemorySegment __gmpf_set_prec$address() {
        return __gmpf_set_prec.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void __gmpf_set_prec(mpf_ptr, mp_bitcnt_t)
     * }
     */
    public static void __gmpf_set_prec(MemorySegment x0, long x1) {
        var mh$ = __gmpf_set_prec.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__gmpf_set_prec", x0, x1);
            }
            mh$.invokeExact(x0, x1);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __gmpf_set_prec_raw {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gmp_h.C_POINTER,
            gmp_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__gmpf_set_prec_raw");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void __gmpf_set_prec_raw(mpf_ptr, mp_bitcnt_t)
     * }
     */
    public static FunctionDescriptor __gmpf_set_prec_raw$descriptor() {
        return __gmpf_set_prec_raw.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void __gmpf_set_prec_raw(mpf_ptr, mp_bitcnt_t)
     * }
     */
    public static MethodHandle __gmpf_set_prec_raw$handle() {
        return __gmpf_set_prec_raw.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void __gmpf_set_prec_raw(mpf_ptr, mp_bitcnt_t)
     * }
     */
    public static MemorySegment __gmpf_set_prec_raw$address() {
        return __gmpf_set_prec_raw.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void __gmpf_set_prec_raw(mpf_ptr, mp_bitcnt_t)
     * }
     */
    public static void __gmpf_set_prec_raw(MemorySegment x0, long x1) {
        var mh$ = __gmpf_set_prec_raw.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__gmpf_set_prec_raw", x0, x1);
            }
            mh$.invokeExact(x0, x1);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __gmpf_set_q {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gmp_h.C_POINTER,
            gmp_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__gmpf_set_q");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void __gmpf_set_q(mpf_ptr, mpq_srcptr)
     * }
     */
    public static FunctionDescriptor __gmpf_set_q$descriptor() {
        return __gmpf_set_q.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void __gmpf_set_q(mpf_ptr, mpq_srcptr)
     * }
     */
    public static MethodHandle __gmpf_set_q$handle() {
        return __gmpf_set_q.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void __gmpf_set_q(mpf_ptr, mpq_srcptr)
     * }
     */
    public static MemorySegment __gmpf_set_q$address() {
        return __gmpf_set_q.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void __gmpf_set_q(mpf_ptr, mpq_srcptr)
     * }
     */
    public static void __gmpf_set_q(MemorySegment x0, MemorySegment x1) {
        var mh$ = __gmpf_set_q.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__gmpf_set_q", x0, x1);
            }
            mh$.invokeExact(x0, x1);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __gmpf_set_si {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gmp_h.C_POINTER,
            gmp_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__gmpf_set_si");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void __gmpf_set_si(mpf_ptr, long)
     * }
     */
    public static FunctionDescriptor __gmpf_set_si$descriptor() {
        return __gmpf_set_si.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void __gmpf_set_si(mpf_ptr, long)
     * }
     */
    public static MethodHandle __gmpf_set_si$handle() {
        return __gmpf_set_si.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void __gmpf_set_si(mpf_ptr, long)
     * }
     */
    public static MemorySegment __gmpf_set_si$address() {
        return __gmpf_set_si.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void __gmpf_set_si(mpf_ptr, long)
     * }
     */
    public static void __gmpf_set_si(MemorySegment x0, long x1) {
        var mh$ = __gmpf_set_si.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__gmpf_set_si", x0, x1);
            }
            mh$.invokeExact(x0, x1);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __gmpf_set_str {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gmp_h.C_INT,
            gmp_h.C_POINTER,
            gmp_h.C_POINTER,
            gmp_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__gmpf_set_str");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int __gmpf_set_str(mpf_ptr, const char *, int)
     * }
     */
    public static FunctionDescriptor __gmpf_set_str$descriptor() {
        return __gmpf_set_str.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int __gmpf_set_str(mpf_ptr, const char *, int)
     * }
     */
    public static MethodHandle __gmpf_set_str$handle() {
        return __gmpf_set_str.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int __gmpf_set_str(mpf_ptr, const char *, int)
     * }
     */
    public static MemorySegment __gmpf_set_str$address() {
        return __gmpf_set_str.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int __gmpf_set_str(mpf_ptr, const char *, int)
     * }
     */
    public static int __gmpf_set_str(MemorySegment x0, MemorySegment x1, int x2) {
        var mh$ = __gmpf_set_str.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__gmpf_set_str", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __gmpf_set_ui {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gmp_h.C_POINTER,
            gmp_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__gmpf_set_ui");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void __gmpf_set_ui(mpf_ptr, unsigned long)
     * }
     */
    public static FunctionDescriptor __gmpf_set_ui$descriptor() {
        return __gmpf_set_ui.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void __gmpf_set_ui(mpf_ptr, unsigned long)
     * }
     */
    public static MethodHandle __gmpf_set_ui$handle() {
        return __gmpf_set_ui.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void __gmpf_set_ui(mpf_ptr, unsigned long)
     * }
     */
    public static MemorySegment __gmpf_set_ui$address() {
        return __gmpf_set_ui.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void __gmpf_set_ui(mpf_ptr, unsigned long)
     * }
     */
    public static void __gmpf_set_ui(MemorySegment x0, long x1) {
        var mh$ = __gmpf_set_ui.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__gmpf_set_ui", x0, x1);
            }
            mh$.invokeExact(x0, x1);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __gmpf_set_z {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gmp_h.C_POINTER,
            gmp_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__gmpf_set_z");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void __gmpf_set_z(mpf_ptr, mpz_srcptr)
     * }
     */
    public static FunctionDescriptor __gmpf_set_z$descriptor() {
        return __gmpf_set_z.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void __gmpf_set_z(mpf_ptr, mpz_srcptr)
     * }
     */
    public static MethodHandle __gmpf_set_z$handle() {
        return __gmpf_set_z.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void __gmpf_set_z(mpf_ptr, mpz_srcptr)
     * }
     */
    public static MemorySegment __gmpf_set_z$address() {
        return __gmpf_set_z.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void __gmpf_set_z(mpf_ptr, mpz_srcptr)
     * }
     */
    public static void __gmpf_set_z(MemorySegment x0, MemorySegment x1) {
        var mh$ = __gmpf_set_z.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__gmpf_set_z", x0, x1);
            }
            mh$.invokeExact(x0, x1);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __gmpf_size {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gmp_h.C_LONG,
            gmp_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__gmpf_size");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * size_t __gmpf_size(mpf_srcptr)
     * }
     */
    public static FunctionDescriptor __gmpf_size$descriptor() {
        return __gmpf_size.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * size_t __gmpf_size(mpf_srcptr)
     * }
     */
    public static MethodHandle __gmpf_size$handle() {
        return __gmpf_size.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * size_t __gmpf_size(mpf_srcptr)
     * }
     */
    public static MemorySegment __gmpf_size$address() {
        return __gmpf_size.ADDR;
    }

    /**
     * {@snippet lang=c :
     * size_t __gmpf_size(mpf_srcptr)
     * }
     */
    public static long __gmpf_size(MemorySegment x0) {
        var mh$ = __gmpf_size.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__gmpf_size", x0);
            }
            return (long)mh$.invokeExact(x0);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __gmpf_sqrt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gmp_h.C_POINTER,
            gmp_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__gmpf_sqrt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void __gmpf_sqrt(mpf_ptr, mpf_srcptr)
     * }
     */
    public static FunctionDescriptor __gmpf_sqrt$descriptor() {
        return __gmpf_sqrt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void __gmpf_sqrt(mpf_ptr, mpf_srcptr)
     * }
     */
    public static MethodHandle __gmpf_sqrt$handle() {
        return __gmpf_sqrt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void __gmpf_sqrt(mpf_ptr, mpf_srcptr)
     * }
     */
    public static MemorySegment __gmpf_sqrt$address() {
        return __gmpf_sqrt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void __gmpf_sqrt(mpf_ptr, mpf_srcptr)
     * }
     */
    public static void __gmpf_sqrt(MemorySegment x0, MemorySegment x1) {
        var mh$ = __gmpf_sqrt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__gmpf_sqrt", x0, x1);
            }
            mh$.invokeExact(x0, x1);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __gmpf_sqrt_ui {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gmp_h.C_POINTER,
            gmp_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__gmpf_sqrt_ui");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void __gmpf_sqrt_ui(mpf_ptr, unsigned long)
     * }
     */
    public static FunctionDescriptor __gmpf_sqrt_ui$descriptor() {
        return __gmpf_sqrt_ui.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void __gmpf_sqrt_ui(mpf_ptr, unsigned long)
     * }
     */
    public static MethodHandle __gmpf_sqrt_ui$handle() {
        return __gmpf_sqrt_ui.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void __gmpf_sqrt_ui(mpf_ptr, unsigned long)
     * }
     */
    public static MemorySegment __gmpf_sqrt_ui$address() {
        return __gmpf_sqrt_ui.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void __gmpf_sqrt_ui(mpf_ptr, unsigned long)
     * }
     */
    public static void __gmpf_sqrt_ui(MemorySegment x0, long x1) {
        var mh$ = __gmpf_sqrt_ui.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__gmpf_sqrt_ui", x0, x1);
            }
            mh$.invokeExact(x0, x1);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __gmpf_sub {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gmp_h.C_POINTER,
            gmp_h.C_POINTER,
            gmp_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__gmpf_sub");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void __gmpf_sub(mpf_ptr, mpf_srcptr, mpf_srcptr)
     * }
     */
    public static FunctionDescriptor __gmpf_sub$descriptor() {
        return __gmpf_sub.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void __gmpf_sub(mpf_ptr, mpf_srcptr, mpf_srcptr)
     * }
     */
    public static MethodHandle __gmpf_sub$handle() {
        return __gmpf_sub.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void __gmpf_sub(mpf_ptr, mpf_srcptr, mpf_srcptr)
     * }
     */
    public static MemorySegment __gmpf_sub$address() {
        return __gmpf_sub.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void __gmpf_sub(mpf_ptr, mpf_srcptr, mpf_srcptr)
     * }
     */
    public static void __gmpf_sub(MemorySegment x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = __gmpf_sub.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__gmpf_sub", x0, x1, x2);
            }
            mh$.invokeExact(x0, x1, x2);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __gmpf_sub_ui {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gmp_h.C_POINTER,
            gmp_h.C_POINTER,
            gmp_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__gmpf_sub_ui");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void __gmpf_sub_ui(mpf_ptr, mpf_srcptr, unsigned long)
     * }
     */
    public static FunctionDescriptor __gmpf_sub_ui$descriptor() {
        return __gmpf_sub_ui.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void __gmpf_sub_ui(mpf_ptr, mpf_srcptr, unsigned long)
     * }
     */
    public static MethodHandle __gmpf_sub_ui$handle() {
        return __gmpf_sub_ui.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void __gmpf_sub_ui(mpf_ptr, mpf_srcptr, unsigned long)
     * }
     */
    public static MemorySegment __gmpf_sub_ui$address() {
        return __gmpf_sub_ui.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void __gmpf_sub_ui(mpf_ptr, mpf_srcptr, unsigned long)
     * }
     */
    public static void __gmpf_sub_ui(MemorySegment x0, MemorySegment x1, long x2) {
        var mh$ = __gmpf_sub_ui.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__gmpf_sub_ui", x0, x1, x2);
            }
            mh$.invokeExact(x0, x1, x2);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __gmpf_swap {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gmp_h.C_POINTER,
            gmp_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__gmpf_swap");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void __gmpf_swap(mpf_ptr, mpf_ptr)
     * }
     */
    public static FunctionDescriptor __gmpf_swap$descriptor() {
        return __gmpf_swap.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void __gmpf_swap(mpf_ptr, mpf_ptr)
     * }
     */
    public static MethodHandle __gmpf_swap$handle() {
        return __gmpf_swap.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void __gmpf_swap(mpf_ptr, mpf_ptr)
     * }
     */
    public static MemorySegment __gmpf_swap$address() {
        return __gmpf_swap.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void __gmpf_swap(mpf_ptr, mpf_ptr)
     * }
     */
    public static void __gmpf_swap(MemorySegment x0, MemorySegment x1) {
        var mh$ = __gmpf_swap.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__gmpf_swap", x0, x1);
            }
            mh$.invokeExact(x0, x1);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __gmpf_trunc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gmp_h.C_POINTER,
            gmp_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__gmpf_trunc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void __gmpf_trunc(mpf_ptr, mpf_srcptr)
     * }
     */
    public static FunctionDescriptor __gmpf_trunc$descriptor() {
        return __gmpf_trunc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void __gmpf_trunc(mpf_ptr, mpf_srcptr)
     * }
     */
    public static MethodHandle __gmpf_trunc$handle() {
        return __gmpf_trunc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void __gmpf_trunc(mpf_ptr, mpf_srcptr)
     * }
     */
    public static MemorySegment __gmpf_trunc$address() {
        return __gmpf_trunc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void __gmpf_trunc(mpf_ptr, mpf_srcptr)
     * }
     */
    public static void __gmpf_trunc(MemorySegment x0, MemorySegment x1) {
        var mh$ = __gmpf_trunc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__gmpf_trunc", x0, x1);
            }
            mh$.invokeExact(x0, x1);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __gmpf_ui_div {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gmp_h.C_POINTER,
            gmp_h.C_LONG,
            gmp_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__gmpf_ui_div");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void __gmpf_ui_div(mpf_ptr, unsigned long, mpf_srcptr)
     * }
     */
    public static FunctionDescriptor __gmpf_ui_div$descriptor() {
        return __gmpf_ui_div.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void __gmpf_ui_div(mpf_ptr, unsigned long, mpf_srcptr)
     * }
     */
    public static MethodHandle __gmpf_ui_div$handle() {
        return __gmpf_ui_div.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void __gmpf_ui_div(mpf_ptr, unsigned long, mpf_srcptr)
     * }
     */
    public static MemorySegment __gmpf_ui_div$address() {
        return __gmpf_ui_div.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void __gmpf_ui_div(mpf_ptr, unsigned long, mpf_srcptr)
     * }
     */
    public static void __gmpf_ui_div(MemorySegment x0, long x1, MemorySegment x2) {
        var mh$ = __gmpf_ui_div.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__gmpf_ui_div", x0, x1, x2);
            }
            mh$.invokeExact(x0, x1, x2);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __gmpf_ui_sub {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gmp_h.C_POINTER,
            gmp_h.C_LONG,
            gmp_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__gmpf_ui_sub");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void __gmpf_ui_sub(mpf_ptr, unsigned long, mpf_srcptr)
     * }
     */
    public static FunctionDescriptor __gmpf_ui_sub$descriptor() {
        return __gmpf_ui_sub.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void __gmpf_ui_sub(mpf_ptr, unsigned long, mpf_srcptr)
     * }
     */
    public static MethodHandle __gmpf_ui_sub$handle() {
        return __gmpf_ui_sub.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void __gmpf_ui_sub(mpf_ptr, unsigned long, mpf_srcptr)
     * }
     */
    public static MemorySegment __gmpf_ui_sub$address() {
        return __gmpf_ui_sub.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void __gmpf_ui_sub(mpf_ptr, unsigned long, mpf_srcptr)
     * }
     */
    public static void __gmpf_ui_sub(MemorySegment x0, long x1, MemorySegment x2) {
        var mh$ = __gmpf_ui_sub.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__gmpf_ui_sub", x0, x1, x2);
            }
            mh$.invokeExact(x0, x1, x2);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __gmpf_urandomb {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gmp_h.C_POINTER,
            gmp_h.C_POINTER,
            gmp_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__gmpf_urandomb");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void __gmpf_urandomb(mpf_ptr, gmp_randstate_ptr, mp_bitcnt_t)
     * }
     */
    public static FunctionDescriptor __gmpf_urandomb$descriptor() {
        return __gmpf_urandomb.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void __gmpf_urandomb(mpf_ptr, gmp_randstate_ptr, mp_bitcnt_t)
     * }
     */
    public static MethodHandle __gmpf_urandomb$handle() {
        return __gmpf_urandomb.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void __gmpf_urandomb(mpf_ptr, gmp_randstate_ptr, mp_bitcnt_t)
     * }
     */
    public static MemorySegment __gmpf_urandomb$address() {
        return __gmpf_urandomb.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void __gmpf_urandomb(mpf_ptr, gmp_randstate_ptr, mp_bitcnt_t)
     * }
     */
    public static void __gmpf_urandomb(MemorySegment x0, MemorySegment x1, long x2) {
        var mh$ = __gmpf_urandomb.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__gmpf_urandomb", x0, x1, x2);
            }
            mh$.invokeExact(x0, x1, x2);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __gmpn_add {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gmp_h.C_LONG,
            gmp_h.C_POINTER,
            gmp_h.C_POINTER,
            gmp_h.C_LONG,
            gmp_h.C_POINTER,
            gmp_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__gmpn_add");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * mp_limb_t __gmpn_add(mp_ptr, mp_srcptr, mp_size_t, mp_srcptr, mp_size_t)
     * }
     */
    public static FunctionDescriptor __gmpn_add$descriptor() {
        return __gmpn_add.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * mp_limb_t __gmpn_add(mp_ptr, mp_srcptr, mp_size_t, mp_srcptr, mp_size_t)
     * }
     */
    public static MethodHandle __gmpn_add$handle() {
        return __gmpn_add.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * mp_limb_t __gmpn_add(mp_ptr, mp_srcptr, mp_size_t, mp_srcptr, mp_size_t)
     * }
     */
    public static MemorySegment __gmpn_add$address() {
        return __gmpn_add.ADDR;
    }

    /**
     * {@snippet lang=c :
     * mp_limb_t __gmpn_add(mp_ptr, mp_srcptr, mp_size_t, mp_srcptr, mp_size_t)
     * }
     */
    public static long __gmpn_add(MemorySegment x0, MemorySegment x1, long x2, MemorySegment x3, long x4) {
        var mh$ = __gmpn_add.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__gmpn_add", x0, x1, x2, x3, x4);
            }
            return (long)mh$.invokeExact(x0, x1, x2, x3, x4);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __gmpn_add_1 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gmp_h.C_LONG,
            gmp_h.C_POINTER,
            gmp_h.C_POINTER,
            gmp_h.C_LONG,
            gmp_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__gmpn_add_1");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * mp_limb_t __gmpn_add_1(mp_ptr, mp_srcptr, mp_size_t, mp_limb_t)
     * }
     */
    public static FunctionDescriptor __gmpn_add_1$descriptor() {
        return __gmpn_add_1.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * mp_limb_t __gmpn_add_1(mp_ptr, mp_srcptr, mp_size_t, mp_limb_t)
     * }
     */
    public static MethodHandle __gmpn_add_1$handle() {
        return __gmpn_add_1.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * mp_limb_t __gmpn_add_1(mp_ptr, mp_srcptr, mp_size_t, mp_limb_t)
     * }
     */
    public static MemorySegment __gmpn_add_1$address() {
        return __gmpn_add_1.ADDR;
    }

    /**
     * {@snippet lang=c :
     * mp_limb_t __gmpn_add_1(mp_ptr, mp_srcptr, mp_size_t, mp_limb_t)
     * }
     */
    public static long __gmpn_add_1(MemorySegment x0, MemorySegment x1, long x2, long x3) {
        var mh$ = __gmpn_add_1.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__gmpn_add_1", x0, x1, x2, x3);
            }
            return (long)mh$.invokeExact(x0, x1, x2, x3);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __gmpn_add_n {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gmp_h.C_LONG,
            gmp_h.C_POINTER,
            gmp_h.C_POINTER,
            gmp_h.C_POINTER,
            gmp_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__gmpn_add_n");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * mp_limb_t __gmpn_add_n(mp_ptr, mp_srcptr, mp_srcptr, mp_size_t)
     * }
     */
    public static FunctionDescriptor __gmpn_add_n$descriptor() {
        return __gmpn_add_n.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * mp_limb_t __gmpn_add_n(mp_ptr, mp_srcptr, mp_srcptr, mp_size_t)
     * }
     */
    public static MethodHandle __gmpn_add_n$handle() {
        return __gmpn_add_n.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * mp_limb_t __gmpn_add_n(mp_ptr, mp_srcptr, mp_srcptr, mp_size_t)
     * }
     */
    public static MemorySegment __gmpn_add_n$address() {
        return __gmpn_add_n.ADDR;
    }

    /**
     * {@snippet lang=c :
     * mp_limb_t __gmpn_add_n(mp_ptr, mp_srcptr, mp_srcptr, mp_size_t)
     * }
     */
    public static long __gmpn_add_n(MemorySegment x0, MemorySegment x1, MemorySegment x2, long x3) {
        var mh$ = __gmpn_add_n.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__gmpn_add_n", x0, x1, x2, x3);
            }
            return (long)mh$.invokeExact(x0, x1, x2, x3);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __gmpn_addmul_1 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gmp_h.C_LONG,
            gmp_h.C_POINTER,
            gmp_h.C_POINTER,
            gmp_h.C_LONG,
            gmp_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__gmpn_addmul_1");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * mp_limb_t __gmpn_addmul_1(mp_ptr, mp_srcptr, mp_size_t, mp_limb_t)
     * }
     */
    public static FunctionDescriptor __gmpn_addmul_1$descriptor() {
        return __gmpn_addmul_1.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * mp_limb_t __gmpn_addmul_1(mp_ptr, mp_srcptr, mp_size_t, mp_limb_t)
     * }
     */
    public static MethodHandle __gmpn_addmul_1$handle() {
        return __gmpn_addmul_1.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * mp_limb_t __gmpn_addmul_1(mp_ptr, mp_srcptr, mp_size_t, mp_limb_t)
     * }
     */
    public static MemorySegment __gmpn_addmul_1$address() {
        return __gmpn_addmul_1.ADDR;
    }

    /**
     * {@snippet lang=c :
     * mp_limb_t __gmpn_addmul_1(mp_ptr, mp_srcptr, mp_size_t, mp_limb_t)
     * }
     */
    public static long __gmpn_addmul_1(MemorySegment x0, MemorySegment x1, long x2, long x3) {
        var mh$ = __gmpn_addmul_1.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__gmpn_addmul_1", x0, x1, x2, x3);
            }
            return (long)mh$.invokeExact(x0, x1, x2, x3);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __gmpn_cmp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gmp_h.C_INT,
            gmp_h.C_POINTER,
            gmp_h.C_POINTER,
            gmp_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__gmpn_cmp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int __gmpn_cmp(mp_srcptr, mp_srcptr, mp_size_t)
     * }
     */
    public static FunctionDescriptor __gmpn_cmp$descriptor() {
        return __gmpn_cmp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int __gmpn_cmp(mp_srcptr, mp_srcptr, mp_size_t)
     * }
     */
    public static MethodHandle __gmpn_cmp$handle() {
        return __gmpn_cmp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int __gmpn_cmp(mp_srcptr, mp_srcptr, mp_size_t)
     * }
     */
    public static MemorySegment __gmpn_cmp$address() {
        return __gmpn_cmp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int __gmpn_cmp(mp_srcptr, mp_srcptr, mp_size_t)
     * }
     */
    public static int __gmpn_cmp(MemorySegment x0, MemorySegment x1, long x2) {
        var mh$ = __gmpn_cmp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__gmpn_cmp", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __gmpn_zero_p {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gmp_h.C_INT,
            gmp_h.C_POINTER,
            gmp_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__gmpn_zero_p");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int __gmpn_zero_p(mp_srcptr, mp_size_t)
     * }
     */
    public static FunctionDescriptor __gmpn_zero_p$descriptor() {
        return __gmpn_zero_p.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int __gmpn_zero_p(mp_srcptr, mp_size_t)
     * }
     */
    public static MethodHandle __gmpn_zero_p$handle() {
        return __gmpn_zero_p.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int __gmpn_zero_p(mp_srcptr, mp_size_t)
     * }
     */
    public static MemorySegment __gmpn_zero_p$address() {
        return __gmpn_zero_p.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int __gmpn_zero_p(mp_srcptr, mp_size_t)
     * }
     */
    public static int __gmpn_zero_p(MemorySegment x0, long x1) {
        var mh$ = __gmpn_zero_p.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__gmpn_zero_p", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __gmpn_divexact_1 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gmp_h.C_POINTER,
            gmp_h.C_POINTER,
            gmp_h.C_LONG,
            gmp_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__gmpn_divexact_1");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void __gmpn_divexact_1(mp_ptr, mp_srcptr, mp_size_t, mp_limb_t)
     * }
     */
    public static FunctionDescriptor __gmpn_divexact_1$descriptor() {
        return __gmpn_divexact_1.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void __gmpn_divexact_1(mp_ptr, mp_srcptr, mp_size_t, mp_limb_t)
     * }
     */
    public static MethodHandle __gmpn_divexact_1$handle() {
        return __gmpn_divexact_1.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void __gmpn_divexact_1(mp_ptr, mp_srcptr, mp_size_t, mp_limb_t)
     * }
     */
    public static MemorySegment __gmpn_divexact_1$address() {
        return __gmpn_divexact_1.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void __gmpn_divexact_1(mp_ptr, mp_srcptr, mp_size_t, mp_limb_t)
     * }
     */
    public static void __gmpn_divexact_1(MemorySegment x0, MemorySegment x1, long x2, long x3) {
        var mh$ = __gmpn_divexact_1.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__gmpn_divexact_1", x0, x1, x2, x3);
            }
            mh$.invokeExact(x0, x1, x2, x3);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __gmpn_divexact_by3c {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gmp_h.C_LONG,
            gmp_h.C_POINTER,
            gmp_h.C_POINTER,
            gmp_h.C_LONG,
            gmp_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__gmpn_divexact_by3c");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * mp_limb_t __gmpn_divexact_by3c(mp_ptr, mp_srcptr, mp_size_t, mp_limb_t)
     * }
     */
    public static FunctionDescriptor __gmpn_divexact_by3c$descriptor() {
        return __gmpn_divexact_by3c.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * mp_limb_t __gmpn_divexact_by3c(mp_ptr, mp_srcptr, mp_size_t, mp_limb_t)
     * }
     */
    public static MethodHandle __gmpn_divexact_by3c$handle() {
        return __gmpn_divexact_by3c.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * mp_limb_t __gmpn_divexact_by3c(mp_ptr, mp_srcptr, mp_size_t, mp_limb_t)
     * }
     */
    public static MemorySegment __gmpn_divexact_by3c$address() {
        return __gmpn_divexact_by3c.ADDR;
    }

    /**
     * {@snippet lang=c :
     * mp_limb_t __gmpn_divexact_by3c(mp_ptr, mp_srcptr, mp_size_t, mp_limb_t)
     * }
     */
    public static long __gmpn_divexact_by3c(MemorySegment x0, MemorySegment x1, long x2, long x3) {
        var mh$ = __gmpn_divexact_by3c.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__gmpn_divexact_by3c", x0, x1, x2, x3);
            }
            return (long)mh$.invokeExact(x0, x1, x2, x3);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __gmpn_divrem {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gmp_h.C_LONG,
            gmp_h.C_POINTER,
            gmp_h.C_LONG,
            gmp_h.C_POINTER,
            gmp_h.C_LONG,
            gmp_h.C_POINTER,
            gmp_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__gmpn_divrem");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * mp_limb_t __gmpn_divrem(mp_ptr, mp_size_t, mp_ptr, mp_size_t, mp_srcptr, mp_size_t)
     * }
     */
    public static FunctionDescriptor __gmpn_divrem$descriptor() {
        return __gmpn_divrem.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * mp_limb_t __gmpn_divrem(mp_ptr, mp_size_t, mp_ptr, mp_size_t, mp_srcptr, mp_size_t)
     * }
     */
    public static MethodHandle __gmpn_divrem$handle() {
        return __gmpn_divrem.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * mp_limb_t __gmpn_divrem(mp_ptr, mp_size_t, mp_ptr, mp_size_t, mp_srcptr, mp_size_t)
     * }
     */
    public static MemorySegment __gmpn_divrem$address() {
        return __gmpn_divrem.ADDR;
    }

    /**
     * {@snippet lang=c :
     * mp_limb_t __gmpn_divrem(mp_ptr, mp_size_t, mp_ptr, mp_size_t, mp_srcptr, mp_size_t)
     * }
     */
    public static long __gmpn_divrem(MemorySegment x0, long x1, MemorySegment x2, long x3, MemorySegment x4, long x5) {
        var mh$ = __gmpn_divrem.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__gmpn_divrem", x0, x1, x2, x3, x4, x5);
            }
            return (long)mh$.invokeExact(x0, x1, x2, x3, x4, x5);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __gmpn_divrem_1 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gmp_h.C_LONG,
            gmp_h.C_POINTER,
            gmp_h.C_LONG,
            gmp_h.C_POINTER,
            gmp_h.C_LONG,
            gmp_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__gmpn_divrem_1");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * mp_limb_t __gmpn_divrem_1(mp_ptr, mp_size_t, mp_srcptr, mp_size_t, mp_limb_t)
     * }
     */
    public static FunctionDescriptor __gmpn_divrem_1$descriptor() {
        return __gmpn_divrem_1.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * mp_limb_t __gmpn_divrem_1(mp_ptr, mp_size_t, mp_srcptr, mp_size_t, mp_limb_t)
     * }
     */
    public static MethodHandle __gmpn_divrem_1$handle() {
        return __gmpn_divrem_1.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * mp_limb_t __gmpn_divrem_1(mp_ptr, mp_size_t, mp_srcptr, mp_size_t, mp_limb_t)
     * }
     */
    public static MemorySegment __gmpn_divrem_1$address() {
        return __gmpn_divrem_1.ADDR;
    }

    /**
     * {@snippet lang=c :
     * mp_limb_t __gmpn_divrem_1(mp_ptr, mp_size_t, mp_srcptr, mp_size_t, mp_limb_t)
     * }
     */
    public static long __gmpn_divrem_1(MemorySegment x0, long x1, MemorySegment x2, long x3, long x4) {
        var mh$ = __gmpn_divrem_1.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__gmpn_divrem_1", x0, x1, x2, x3, x4);
            }
            return (long)mh$.invokeExact(x0, x1, x2, x3, x4);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __gmpn_divrem_2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gmp_h.C_LONG,
            gmp_h.C_POINTER,
            gmp_h.C_LONG,
            gmp_h.C_POINTER,
            gmp_h.C_LONG,
            gmp_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__gmpn_divrem_2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * mp_limb_t __gmpn_divrem_2(mp_ptr, mp_size_t, mp_ptr, mp_size_t, mp_srcptr)
     * }
     */
    public static FunctionDescriptor __gmpn_divrem_2$descriptor() {
        return __gmpn_divrem_2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * mp_limb_t __gmpn_divrem_2(mp_ptr, mp_size_t, mp_ptr, mp_size_t, mp_srcptr)
     * }
     */
    public static MethodHandle __gmpn_divrem_2$handle() {
        return __gmpn_divrem_2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * mp_limb_t __gmpn_divrem_2(mp_ptr, mp_size_t, mp_ptr, mp_size_t, mp_srcptr)
     * }
     */
    public static MemorySegment __gmpn_divrem_2$address() {
        return __gmpn_divrem_2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * mp_limb_t __gmpn_divrem_2(mp_ptr, mp_size_t, mp_ptr, mp_size_t, mp_srcptr)
     * }
     */
    public static long __gmpn_divrem_2(MemorySegment x0, long x1, MemorySegment x2, long x3, MemorySegment x4) {
        var mh$ = __gmpn_divrem_2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__gmpn_divrem_2", x0, x1, x2, x3, x4);
            }
            return (long)mh$.invokeExact(x0, x1, x2, x3, x4);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __gmpn_div_qr_1 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gmp_h.C_LONG,
            gmp_h.C_POINTER,
            gmp_h.C_POINTER,
            gmp_h.C_POINTER,
            gmp_h.C_LONG,
            gmp_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__gmpn_div_qr_1");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * mp_limb_t __gmpn_div_qr_1(mp_ptr, mp_limb_t *, mp_srcptr, mp_size_t, mp_limb_t)
     * }
     */
    public static FunctionDescriptor __gmpn_div_qr_1$descriptor() {
        return __gmpn_div_qr_1.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * mp_limb_t __gmpn_div_qr_1(mp_ptr, mp_limb_t *, mp_srcptr, mp_size_t, mp_limb_t)
     * }
     */
    public static MethodHandle __gmpn_div_qr_1$handle() {
        return __gmpn_div_qr_1.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * mp_limb_t __gmpn_div_qr_1(mp_ptr, mp_limb_t *, mp_srcptr, mp_size_t, mp_limb_t)
     * }
     */
    public static MemorySegment __gmpn_div_qr_1$address() {
        return __gmpn_div_qr_1.ADDR;
    }

    /**
     * {@snippet lang=c :
     * mp_limb_t __gmpn_div_qr_1(mp_ptr, mp_limb_t *, mp_srcptr, mp_size_t, mp_limb_t)
     * }
     */
    public static long __gmpn_div_qr_1(MemorySegment x0, MemorySegment x1, MemorySegment x2, long x3, long x4) {
        var mh$ = __gmpn_div_qr_1.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__gmpn_div_qr_1", x0, x1, x2, x3, x4);
            }
            return (long)mh$.invokeExact(x0, x1, x2, x3, x4);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __gmpn_div_qr_2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gmp_h.C_LONG,
            gmp_h.C_POINTER,
            gmp_h.C_POINTER,
            gmp_h.C_POINTER,
            gmp_h.C_LONG,
            gmp_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__gmpn_div_qr_2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * mp_limb_t __gmpn_div_qr_2(mp_ptr, mp_ptr, mp_srcptr, mp_size_t, mp_srcptr)
     * }
     */
    public static FunctionDescriptor __gmpn_div_qr_2$descriptor() {
        return __gmpn_div_qr_2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * mp_limb_t __gmpn_div_qr_2(mp_ptr, mp_ptr, mp_srcptr, mp_size_t, mp_srcptr)
     * }
     */
    public static MethodHandle __gmpn_div_qr_2$handle() {
        return __gmpn_div_qr_2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * mp_limb_t __gmpn_div_qr_2(mp_ptr, mp_ptr, mp_srcptr, mp_size_t, mp_srcptr)
     * }
     */
    public static MemorySegment __gmpn_div_qr_2$address() {
        return __gmpn_div_qr_2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * mp_limb_t __gmpn_div_qr_2(mp_ptr, mp_ptr, mp_srcptr, mp_size_t, mp_srcptr)
     * }
     */
    public static long __gmpn_div_qr_2(MemorySegment x0, MemorySegment x1, MemorySegment x2, long x3, MemorySegment x4) {
        var mh$ = __gmpn_div_qr_2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__gmpn_div_qr_2", x0, x1, x2, x3, x4);
            }
            return (long)mh$.invokeExact(x0, x1, x2, x3, x4);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __gmpn_gcd {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gmp_h.C_LONG,
            gmp_h.C_POINTER,
            gmp_h.C_POINTER,
            gmp_h.C_LONG,
            gmp_h.C_POINTER,
            gmp_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__gmpn_gcd");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * mp_size_t __gmpn_gcd(mp_ptr, mp_ptr, mp_size_t, mp_ptr, mp_size_t)
     * }
     */
    public static FunctionDescriptor __gmpn_gcd$descriptor() {
        return __gmpn_gcd.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * mp_size_t __gmpn_gcd(mp_ptr, mp_ptr, mp_size_t, mp_ptr, mp_size_t)
     * }
     */
    public static MethodHandle __gmpn_gcd$handle() {
        return __gmpn_gcd.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * mp_size_t __gmpn_gcd(mp_ptr, mp_ptr, mp_size_t, mp_ptr, mp_size_t)
     * }
     */
    public static MemorySegment __gmpn_gcd$address() {
        return __gmpn_gcd.ADDR;
    }

    /**
     * {@snippet lang=c :
     * mp_size_t __gmpn_gcd(mp_ptr, mp_ptr, mp_size_t, mp_ptr, mp_size_t)
     * }
     */
    public static long __gmpn_gcd(MemorySegment x0, MemorySegment x1, long x2, MemorySegment x3, long x4) {
        var mh$ = __gmpn_gcd.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__gmpn_gcd", x0, x1, x2, x3, x4);
            }
            return (long)mh$.invokeExact(x0, x1, x2, x3, x4);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __gmpn_gcd_11 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gmp_h.C_LONG,
            gmp_h.C_LONG,
            gmp_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__gmpn_gcd_11");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * mp_limb_t __gmpn_gcd_11(mp_limb_t, mp_limb_t)
     * }
     */
    public static FunctionDescriptor __gmpn_gcd_11$descriptor() {
        return __gmpn_gcd_11.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * mp_limb_t __gmpn_gcd_11(mp_limb_t, mp_limb_t)
     * }
     */
    public static MethodHandle __gmpn_gcd_11$handle() {
        return __gmpn_gcd_11.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * mp_limb_t __gmpn_gcd_11(mp_limb_t, mp_limb_t)
     * }
     */
    public static MemorySegment __gmpn_gcd_11$address() {
        return __gmpn_gcd_11.ADDR;
    }

    /**
     * {@snippet lang=c :
     * mp_limb_t __gmpn_gcd_11(mp_limb_t, mp_limb_t)
     * }
     */
    public static long __gmpn_gcd_11(long x0, long x1) {
        var mh$ = __gmpn_gcd_11.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__gmpn_gcd_11", x0, x1);
            }
            return (long)mh$.invokeExact(x0, x1);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __gmpn_gcd_1 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gmp_h.C_LONG,
            gmp_h.C_POINTER,
            gmp_h.C_LONG,
            gmp_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__gmpn_gcd_1");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * mp_limb_t __gmpn_gcd_1(mp_srcptr, mp_size_t, mp_limb_t)
     * }
     */
    public static FunctionDescriptor __gmpn_gcd_1$descriptor() {
        return __gmpn_gcd_1.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * mp_limb_t __gmpn_gcd_1(mp_srcptr, mp_size_t, mp_limb_t)
     * }
     */
    public static MethodHandle __gmpn_gcd_1$handle() {
        return __gmpn_gcd_1.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * mp_limb_t __gmpn_gcd_1(mp_srcptr, mp_size_t, mp_limb_t)
     * }
     */
    public static MemorySegment __gmpn_gcd_1$address() {
        return __gmpn_gcd_1.ADDR;
    }

    /**
     * {@snippet lang=c :
     * mp_limb_t __gmpn_gcd_1(mp_srcptr, mp_size_t, mp_limb_t)
     * }
     */
    public static long __gmpn_gcd_1(MemorySegment x0, long x1, long x2) {
        var mh$ = __gmpn_gcd_1.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__gmpn_gcd_1", x0, x1, x2);
            }
            return (long)mh$.invokeExact(x0, x1, x2);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __gmpn_gcdext_1 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gmp_h.C_LONG,
            gmp_h.C_POINTER,
            gmp_h.C_POINTER,
            gmp_h.C_LONG,
            gmp_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__gmpn_gcdext_1");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * mp_limb_t __gmpn_gcdext_1(mp_limb_signed_t *, mp_limb_signed_t *, mp_limb_t, mp_limb_t)
     * }
     */
    public static FunctionDescriptor __gmpn_gcdext_1$descriptor() {
        return __gmpn_gcdext_1.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * mp_limb_t __gmpn_gcdext_1(mp_limb_signed_t *, mp_limb_signed_t *, mp_limb_t, mp_limb_t)
     * }
     */
    public static MethodHandle __gmpn_gcdext_1$handle() {
        return __gmpn_gcdext_1.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * mp_limb_t __gmpn_gcdext_1(mp_limb_signed_t *, mp_limb_signed_t *, mp_limb_t, mp_limb_t)
     * }
     */
    public static MemorySegment __gmpn_gcdext_1$address() {
        return __gmpn_gcdext_1.ADDR;
    }

    /**
     * {@snippet lang=c :
     * mp_limb_t __gmpn_gcdext_1(mp_limb_signed_t *, mp_limb_signed_t *, mp_limb_t, mp_limb_t)
     * }
     */
    public static long __gmpn_gcdext_1(MemorySegment x0, MemorySegment x1, long x2, long x3) {
        var mh$ = __gmpn_gcdext_1.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__gmpn_gcdext_1", x0, x1, x2, x3);
            }
            return (long)mh$.invokeExact(x0, x1, x2, x3);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __gmpn_gcdext {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gmp_h.C_LONG,
            gmp_h.C_POINTER,
            gmp_h.C_POINTER,
            gmp_h.C_POINTER,
            gmp_h.C_POINTER,
            gmp_h.C_LONG,
            gmp_h.C_POINTER,
            gmp_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__gmpn_gcdext");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * mp_size_t __gmpn_gcdext(mp_ptr, mp_ptr, mp_size_t *, mp_ptr, mp_size_t, mp_ptr, mp_size_t)
     * }
     */
    public static FunctionDescriptor __gmpn_gcdext$descriptor() {
        return __gmpn_gcdext.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * mp_size_t __gmpn_gcdext(mp_ptr, mp_ptr, mp_size_t *, mp_ptr, mp_size_t, mp_ptr, mp_size_t)
     * }
     */
    public static MethodHandle __gmpn_gcdext$handle() {
        return __gmpn_gcdext.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * mp_size_t __gmpn_gcdext(mp_ptr, mp_ptr, mp_size_t *, mp_ptr, mp_size_t, mp_ptr, mp_size_t)
     * }
     */
    public static MemorySegment __gmpn_gcdext$address() {
        return __gmpn_gcdext.ADDR;
    }

    /**
     * {@snippet lang=c :
     * mp_size_t __gmpn_gcdext(mp_ptr, mp_ptr, mp_size_t *, mp_ptr, mp_size_t, mp_ptr, mp_size_t)
     * }
     */
    public static long __gmpn_gcdext(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, long x4, MemorySegment x5, long x6) {
        var mh$ = __gmpn_gcdext.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__gmpn_gcdext", x0, x1, x2, x3, x4, x5, x6);
            }
            return (long)mh$.invokeExact(x0, x1, x2, x3, x4, x5, x6);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __gmpn_get_str {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gmp_h.C_LONG,
            gmp_h.C_POINTER,
            gmp_h.C_INT,
            gmp_h.C_POINTER,
            gmp_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__gmpn_get_str");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * size_t __gmpn_get_str(unsigned char *, int, mp_ptr, mp_size_t)
     * }
     */
    public static FunctionDescriptor __gmpn_get_str$descriptor() {
        return __gmpn_get_str.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * size_t __gmpn_get_str(unsigned char *, int, mp_ptr, mp_size_t)
     * }
     */
    public static MethodHandle __gmpn_get_str$handle() {
        return __gmpn_get_str.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * size_t __gmpn_get_str(unsigned char *, int, mp_ptr, mp_size_t)
     * }
     */
    public static MemorySegment __gmpn_get_str$address() {
        return __gmpn_get_str.ADDR;
    }

    /**
     * {@snippet lang=c :
     * size_t __gmpn_get_str(unsigned char *, int, mp_ptr, mp_size_t)
     * }
     */
    public static long __gmpn_get_str(MemorySegment x0, int x1, MemorySegment x2, long x3) {
        var mh$ = __gmpn_get_str.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__gmpn_get_str", x0, x1, x2, x3);
            }
            return (long)mh$.invokeExact(x0, x1, x2, x3);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __gmpn_hamdist {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gmp_h.C_LONG,
            gmp_h.C_POINTER,
            gmp_h.C_POINTER,
            gmp_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__gmpn_hamdist");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * mp_bitcnt_t __gmpn_hamdist(mp_srcptr, mp_srcptr, mp_size_t)
     * }
     */
    public static FunctionDescriptor __gmpn_hamdist$descriptor() {
        return __gmpn_hamdist.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * mp_bitcnt_t __gmpn_hamdist(mp_srcptr, mp_srcptr, mp_size_t)
     * }
     */
    public static MethodHandle __gmpn_hamdist$handle() {
        return __gmpn_hamdist.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * mp_bitcnt_t __gmpn_hamdist(mp_srcptr, mp_srcptr, mp_size_t)
     * }
     */
    public static MemorySegment __gmpn_hamdist$address() {
        return __gmpn_hamdist.ADDR;
    }

    /**
     * {@snippet lang=c :
     * mp_bitcnt_t __gmpn_hamdist(mp_srcptr, mp_srcptr, mp_size_t)
     * }
     */
    public static long __gmpn_hamdist(MemorySegment x0, MemorySegment x1, long x2) {
        var mh$ = __gmpn_hamdist.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__gmpn_hamdist", x0, x1, x2);
            }
            return (long)mh$.invokeExact(x0, x1, x2);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __gmpn_lshift {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gmp_h.C_LONG,
            gmp_h.C_POINTER,
            gmp_h.C_POINTER,
            gmp_h.C_LONG,
            gmp_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__gmpn_lshift");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * mp_limb_t __gmpn_lshift(mp_ptr, mp_srcptr, mp_size_t, unsigned int)
     * }
     */
    public static FunctionDescriptor __gmpn_lshift$descriptor() {
        return __gmpn_lshift.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * mp_limb_t __gmpn_lshift(mp_ptr, mp_srcptr, mp_size_t, unsigned int)
     * }
     */
    public static MethodHandle __gmpn_lshift$handle() {
        return __gmpn_lshift.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * mp_limb_t __gmpn_lshift(mp_ptr, mp_srcptr, mp_size_t, unsigned int)
     * }
     */
    public static MemorySegment __gmpn_lshift$address() {
        return __gmpn_lshift.ADDR;
    }

    /**
     * {@snippet lang=c :
     * mp_limb_t __gmpn_lshift(mp_ptr, mp_srcptr, mp_size_t, unsigned int)
     * }
     */
    public static long __gmpn_lshift(MemorySegment x0, MemorySegment x1, long x2, int x3) {
        var mh$ = __gmpn_lshift.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__gmpn_lshift", x0, x1, x2, x3);
            }
            return (long)mh$.invokeExact(x0, x1, x2, x3);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __gmpn_mod_1 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gmp_h.C_LONG,
            gmp_h.C_POINTER,
            gmp_h.C_LONG,
            gmp_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__gmpn_mod_1");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * mp_limb_t __gmpn_mod_1(mp_srcptr, mp_size_t, mp_limb_t)
     * }
     */
    public static FunctionDescriptor __gmpn_mod_1$descriptor() {
        return __gmpn_mod_1.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * mp_limb_t __gmpn_mod_1(mp_srcptr, mp_size_t, mp_limb_t)
     * }
     */
    public static MethodHandle __gmpn_mod_1$handle() {
        return __gmpn_mod_1.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * mp_limb_t __gmpn_mod_1(mp_srcptr, mp_size_t, mp_limb_t)
     * }
     */
    public static MemorySegment __gmpn_mod_1$address() {
        return __gmpn_mod_1.ADDR;
    }

    /**
     * {@snippet lang=c :
     * mp_limb_t __gmpn_mod_1(mp_srcptr, mp_size_t, mp_limb_t)
     * }
     */
    public static long __gmpn_mod_1(MemorySegment x0, long x1, long x2) {
        var mh$ = __gmpn_mod_1.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__gmpn_mod_1", x0, x1, x2);
            }
            return (long)mh$.invokeExact(x0, x1, x2);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __gmpn_mul {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gmp_h.C_LONG,
            gmp_h.C_POINTER,
            gmp_h.C_POINTER,
            gmp_h.C_LONG,
            gmp_h.C_POINTER,
            gmp_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__gmpn_mul");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * mp_limb_t __gmpn_mul(mp_ptr, mp_srcptr, mp_size_t, mp_srcptr, mp_size_t)
     * }
     */
    public static FunctionDescriptor __gmpn_mul$descriptor() {
        return __gmpn_mul.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * mp_limb_t __gmpn_mul(mp_ptr, mp_srcptr, mp_size_t, mp_srcptr, mp_size_t)
     * }
     */
    public static MethodHandle __gmpn_mul$handle() {
        return __gmpn_mul.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * mp_limb_t __gmpn_mul(mp_ptr, mp_srcptr, mp_size_t, mp_srcptr, mp_size_t)
     * }
     */
    public static MemorySegment __gmpn_mul$address() {
        return __gmpn_mul.ADDR;
    }

    /**
     * {@snippet lang=c :
     * mp_limb_t __gmpn_mul(mp_ptr, mp_srcptr, mp_size_t, mp_srcptr, mp_size_t)
     * }
     */
    public static long __gmpn_mul(MemorySegment x0, MemorySegment x1, long x2, MemorySegment x3, long x4) {
        var mh$ = __gmpn_mul.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__gmpn_mul", x0, x1, x2, x3, x4);
            }
            return (long)mh$.invokeExact(x0, x1, x2, x3, x4);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __gmpn_mul_1 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gmp_h.C_LONG,
            gmp_h.C_POINTER,
            gmp_h.C_POINTER,
            gmp_h.C_LONG,
            gmp_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__gmpn_mul_1");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * mp_limb_t __gmpn_mul_1(mp_ptr, mp_srcptr, mp_size_t, mp_limb_t)
     * }
     */
    public static FunctionDescriptor __gmpn_mul_1$descriptor() {
        return __gmpn_mul_1.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * mp_limb_t __gmpn_mul_1(mp_ptr, mp_srcptr, mp_size_t, mp_limb_t)
     * }
     */
    public static MethodHandle __gmpn_mul_1$handle() {
        return __gmpn_mul_1.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * mp_limb_t __gmpn_mul_1(mp_ptr, mp_srcptr, mp_size_t, mp_limb_t)
     * }
     */
    public static MemorySegment __gmpn_mul_1$address() {
        return __gmpn_mul_1.ADDR;
    }

    /**
     * {@snippet lang=c :
     * mp_limb_t __gmpn_mul_1(mp_ptr, mp_srcptr, mp_size_t, mp_limb_t)
     * }
     */
    public static long __gmpn_mul_1(MemorySegment x0, MemorySegment x1, long x2, long x3) {
        var mh$ = __gmpn_mul_1.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__gmpn_mul_1", x0, x1, x2, x3);
            }
            return (long)mh$.invokeExact(x0, x1, x2, x3);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __gmpn_mul_n {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gmp_h.C_POINTER,
            gmp_h.C_POINTER,
            gmp_h.C_POINTER,
            gmp_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__gmpn_mul_n");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void __gmpn_mul_n(mp_ptr, mp_srcptr, mp_srcptr, mp_size_t)
     * }
     */
    public static FunctionDescriptor __gmpn_mul_n$descriptor() {
        return __gmpn_mul_n.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void __gmpn_mul_n(mp_ptr, mp_srcptr, mp_srcptr, mp_size_t)
     * }
     */
    public static MethodHandle __gmpn_mul_n$handle() {
        return __gmpn_mul_n.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void __gmpn_mul_n(mp_ptr, mp_srcptr, mp_srcptr, mp_size_t)
     * }
     */
    public static MemorySegment __gmpn_mul_n$address() {
        return __gmpn_mul_n.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void __gmpn_mul_n(mp_ptr, mp_srcptr, mp_srcptr, mp_size_t)
     * }
     */
    public static void __gmpn_mul_n(MemorySegment x0, MemorySegment x1, MemorySegment x2, long x3) {
        var mh$ = __gmpn_mul_n.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__gmpn_mul_n", x0, x1, x2, x3);
            }
            mh$.invokeExact(x0, x1, x2, x3);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __gmpn_sqr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gmp_h.C_POINTER,
            gmp_h.C_POINTER,
            gmp_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__gmpn_sqr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void __gmpn_sqr(mp_ptr, mp_srcptr, mp_size_t)
     * }
     */
    public static FunctionDescriptor __gmpn_sqr$descriptor() {
        return __gmpn_sqr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void __gmpn_sqr(mp_ptr, mp_srcptr, mp_size_t)
     * }
     */
    public static MethodHandle __gmpn_sqr$handle() {
        return __gmpn_sqr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void __gmpn_sqr(mp_ptr, mp_srcptr, mp_size_t)
     * }
     */
    public static MemorySegment __gmpn_sqr$address() {
        return __gmpn_sqr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void __gmpn_sqr(mp_ptr, mp_srcptr, mp_size_t)
     * }
     */
    public static void __gmpn_sqr(MemorySegment x0, MemorySegment x1, long x2) {
        var mh$ = __gmpn_sqr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__gmpn_sqr", x0, x1, x2);
            }
            mh$.invokeExact(x0, x1, x2);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __gmpn_neg {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gmp_h.C_LONG,
            gmp_h.C_POINTER,
            gmp_h.C_POINTER,
            gmp_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__gmpn_neg");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * mp_limb_t __gmpn_neg(mp_ptr, mp_srcptr, mp_size_t)
     * }
     */
    public static FunctionDescriptor __gmpn_neg$descriptor() {
        return __gmpn_neg.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * mp_limb_t __gmpn_neg(mp_ptr, mp_srcptr, mp_size_t)
     * }
     */
    public static MethodHandle __gmpn_neg$handle() {
        return __gmpn_neg.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * mp_limb_t __gmpn_neg(mp_ptr, mp_srcptr, mp_size_t)
     * }
     */
    public static MemorySegment __gmpn_neg$address() {
        return __gmpn_neg.ADDR;
    }

    /**
     * {@snippet lang=c :
     * mp_limb_t __gmpn_neg(mp_ptr, mp_srcptr, mp_size_t)
     * }
     */
    public static long __gmpn_neg(MemorySegment x0, MemorySegment x1, long x2) {
        var mh$ = __gmpn_neg.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__gmpn_neg", x0, x1, x2);
            }
            return (long)mh$.invokeExact(x0, x1, x2);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __gmpn_com {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gmp_h.C_POINTER,
            gmp_h.C_POINTER,
            gmp_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__gmpn_com");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void __gmpn_com(mp_ptr, mp_srcptr, mp_size_t)
     * }
     */
    public static FunctionDescriptor __gmpn_com$descriptor() {
        return __gmpn_com.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void __gmpn_com(mp_ptr, mp_srcptr, mp_size_t)
     * }
     */
    public static MethodHandle __gmpn_com$handle() {
        return __gmpn_com.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void __gmpn_com(mp_ptr, mp_srcptr, mp_size_t)
     * }
     */
    public static MemorySegment __gmpn_com$address() {
        return __gmpn_com.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void __gmpn_com(mp_ptr, mp_srcptr, mp_size_t)
     * }
     */
    public static void __gmpn_com(MemorySegment x0, MemorySegment x1, long x2) {
        var mh$ = __gmpn_com.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__gmpn_com", x0, x1, x2);
            }
            mh$.invokeExact(x0, x1, x2);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __gmpn_perfect_square_p {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gmp_h.C_INT,
            gmp_h.C_POINTER,
            gmp_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__gmpn_perfect_square_p");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int __gmpn_perfect_square_p(mp_srcptr, mp_size_t)
     * }
     */
    public static FunctionDescriptor __gmpn_perfect_square_p$descriptor() {
        return __gmpn_perfect_square_p.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int __gmpn_perfect_square_p(mp_srcptr, mp_size_t)
     * }
     */
    public static MethodHandle __gmpn_perfect_square_p$handle() {
        return __gmpn_perfect_square_p.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int __gmpn_perfect_square_p(mp_srcptr, mp_size_t)
     * }
     */
    public static MemorySegment __gmpn_perfect_square_p$address() {
        return __gmpn_perfect_square_p.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int __gmpn_perfect_square_p(mp_srcptr, mp_size_t)
     * }
     */
    public static int __gmpn_perfect_square_p(MemorySegment x0, long x1) {
        var mh$ = __gmpn_perfect_square_p.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__gmpn_perfect_square_p", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __gmpn_perfect_power_p {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gmp_h.C_INT,
            gmp_h.C_POINTER,
            gmp_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__gmpn_perfect_power_p");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int __gmpn_perfect_power_p(mp_srcptr, mp_size_t)
     * }
     */
    public static FunctionDescriptor __gmpn_perfect_power_p$descriptor() {
        return __gmpn_perfect_power_p.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int __gmpn_perfect_power_p(mp_srcptr, mp_size_t)
     * }
     */
    public static MethodHandle __gmpn_perfect_power_p$handle() {
        return __gmpn_perfect_power_p.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int __gmpn_perfect_power_p(mp_srcptr, mp_size_t)
     * }
     */
    public static MemorySegment __gmpn_perfect_power_p$address() {
        return __gmpn_perfect_power_p.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int __gmpn_perfect_power_p(mp_srcptr, mp_size_t)
     * }
     */
    public static int __gmpn_perfect_power_p(MemorySegment x0, long x1) {
        var mh$ = __gmpn_perfect_power_p.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__gmpn_perfect_power_p", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __gmpn_popcount {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gmp_h.C_LONG,
            gmp_h.C_POINTER,
            gmp_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__gmpn_popcount");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * mp_bitcnt_t __gmpn_popcount(mp_srcptr, mp_size_t)
     * }
     */
    public static FunctionDescriptor __gmpn_popcount$descriptor() {
        return __gmpn_popcount.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * mp_bitcnt_t __gmpn_popcount(mp_srcptr, mp_size_t)
     * }
     */
    public static MethodHandle __gmpn_popcount$handle() {
        return __gmpn_popcount.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * mp_bitcnt_t __gmpn_popcount(mp_srcptr, mp_size_t)
     * }
     */
    public static MemorySegment __gmpn_popcount$address() {
        return __gmpn_popcount.ADDR;
    }

    /**
     * {@snippet lang=c :
     * mp_bitcnt_t __gmpn_popcount(mp_srcptr, mp_size_t)
     * }
     */
    public static long __gmpn_popcount(MemorySegment x0, long x1) {
        var mh$ = __gmpn_popcount.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__gmpn_popcount", x0, x1);
            }
            return (long)mh$.invokeExact(x0, x1);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __gmpn_pow_1 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gmp_h.C_LONG,
            gmp_h.C_POINTER,
            gmp_h.C_POINTER,
            gmp_h.C_LONG,
            gmp_h.C_LONG,
            gmp_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__gmpn_pow_1");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * mp_size_t __gmpn_pow_1(mp_ptr, mp_srcptr, mp_size_t, mp_limb_t, mp_ptr)
     * }
     */
    public static FunctionDescriptor __gmpn_pow_1$descriptor() {
        return __gmpn_pow_1.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * mp_size_t __gmpn_pow_1(mp_ptr, mp_srcptr, mp_size_t, mp_limb_t, mp_ptr)
     * }
     */
    public static MethodHandle __gmpn_pow_1$handle() {
        return __gmpn_pow_1.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * mp_size_t __gmpn_pow_1(mp_ptr, mp_srcptr, mp_size_t, mp_limb_t, mp_ptr)
     * }
     */
    public static MemorySegment __gmpn_pow_1$address() {
        return __gmpn_pow_1.ADDR;
    }

    /**
     * {@snippet lang=c :
     * mp_size_t __gmpn_pow_1(mp_ptr, mp_srcptr, mp_size_t, mp_limb_t, mp_ptr)
     * }
     */
    public static long __gmpn_pow_1(MemorySegment x0, MemorySegment x1, long x2, long x3, MemorySegment x4) {
        var mh$ = __gmpn_pow_1.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__gmpn_pow_1", x0, x1, x2, x3, x4);
            }
            return (long)mh$.invokeExact(x0, x1, x2, x3, x4);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __gmpn_preinv_mod_1 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gmp_h.C_LONG,
            gmp_h.C_POINTER,
            gmp_h.C_LONG,
            gmp_h.C_LONG,
            gmp_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__gmpn_preinv_mod_1");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * mp_limb_t __gmpn_preinv_mod_1(mp_srcptr, mp_size_t, mp_limb_t, mp_limb_t)
     * }
     */
    public static FunctionDescriptor __gmpn_preinv_mod_1$descriptor() {
        return __gmpn_preinv_mod_1.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * mp_limb_t __gmpn_preinv_mod_1(mp_srcptr, mp_size_t, mp_limb_t, mp_limb_t)
     * }
     */
    public static MethodHandle __gmpn_preinv_mod_1$handle() {
        return __gmpn_preinv_mod_1.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * mp_limb_t __gmpn_preinv_mod_1(mp_srcptr, mp_size_t, mp_limb_t, mp_limb_t)
     * }
     */
    public static MemorySegment __gmpn_preinv_mod_1$address() {
        return __gmpn_preinv_mod_1.ADDR;
    }

    /**
     * {@snippet lang=c :
     * mp_limb_t __gmpn_preinv_mod_1(mp_srcptr, mp_size_t, mp_limb_t, mp_limb_t)
     * }
     */
    public static long __gmpn_preinv_mod_1(MemorySegment x0, long x1, long x2, long x3) {
        var mh$ = __gmpn_preinv_mod_1.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__gmpn_preinv_mod_1", x0, x1, x2, x3);
            }
            return (long)mh$.invokeExact(x0, x1, x2, x3);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __gmpn_random {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gmp_h.C_POINTER,
            gmp_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__gmpn_random");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void __gmpn_random(mp_ptr, mp_size_t)
     * }
     */
    public static FunctionDescriptor __gmpn_random$descriptor() {
        return __gmpn_random.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void __gmpn_random(mp_ptr, mp_size_t)
     * }
     */
    public static MethodHandle __gmpn_random$handle() {
        return __gmpn_random.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void __gmpn_random(mp_ptr, mp_size_t)
     * }
     */
    public static MemorySegment __gmpn_random$address() {
        return __gmpn_random.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void __gmpn_random(mp_ptr, mp_size_t)
     * }
     */
    public static void __gmpn_random(MemorySegment x0, long x1) {
        var mh$ = __gmpn_random.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__gmpn_random", x0, x1);
            }
            mh$.invokeExact(x0, x1);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __gmpn_random2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gmp_h.C_POINTER,
            gmp_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__gmpn_random2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void __gmpn_random2(mp_ptr, mp_size_t)
     * }
     */
    public static FunctionDescriptor __gmpn_random2$descriptor() {
        return __gmpn_random2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void __gmpn_random2(mp_ptr, mp_size_t)
     * }
     */
    public static MethodHandle __gmpn_random2$handle() {
        return __gmpn_random2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void __gmpn_random2(mp_ptr, mp_size_t)
     * }
     */
    public static MemorySegment __gmpn_random2$address() {
        return __gmpn_random2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void __gmpn_random2(mp_ptr, mp_size_t)
     * }
     */
    public static void __gmpn_random2(MemorySegment x0, long x1) {
        var mh$ = __gmpn_random2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__gmpn_random2", x0, x1);
            }
            mh$.invokeExact(x0, x1);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __gmpn_rshift {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gmp_h.C_LONG,
            gmp_h.C_POINTER,
            gmp_h.C_POINTER,
            gmp_h.C_LONG,
            gmp_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__gmpn_rshift");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * mp_limb_t __gmpn_rshift(mp_ptr, mp_srcptr, mp_size_t, unsigned int)
     * }
     */
    public static FunctionDescriptor __gmpn_rshift$descriptor() {
        return __gmpn_rshift.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * mp_limb_t __gmpn_rshift(mp_ptr, mp_srcptr, mp_size_t, unsigned int)
     * }
     */
    public static MethodHandle __gmpn_rshift$handle() {
        return __gmpn_rshift.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * mp_limb_t __gmpn_rshift(mp_ptr, mp_srcptr, mp_size_t, unsigned int)
     * }
     */
    public static MemorySegment __gmpn_rshift$address() {
        return __gmpn_rshift.ADDR;
    }

    /**
     * {@snippet lang=c :
     * mp_limb_t __gmpn_rshift(mp_ptr, mp_srcptr, mp_size_t, unsigned int)
     * }
     */
    public static long __gmpn_rshift(MemorySegment x0, MemorySegment x1, long x2, int x3) {
        var mh$ = __gmpn_rshift.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__gmpn_rshift", x0, x1, x2, x3);
            }
            return (long)mh$.invokeExact(x0, x1, x2, x3);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __gmpn_scan0 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gmp_h.C_LONG,
            gmp_h.C_POINTER,
            gmp_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__gmpn_scan0");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * mp_bitcnt_t __gmpn_scan0(mp_srcptr, mp_bitcnt_t)
     * }
     */
    public static FunctionDescriptor __gmpn_scan0$descriptor() {
        return __gmpn_scan0.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * mp_bitcnt_t __gmpn_scan0(mp_srcptr, mp_bitcnt_t)
     * }
     */
    public static MethodHandle __gmpn_scan0$handle() {
        return __gmpn_scan0.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * mp_bitcnt_t __gmpn_scan0(mp_srcptr, mp_bitcnt_t)
     * }
     */
    public static MemorySegment __gmpn_scan0$address() {
        return __gmpn_scan0.ADDR;
    }

    /**
     * {@snippet lang=c :
     * mp_bitcnt_t __gmpn_scan0(mp_srcptr, mp_bitcnt_t)
     * }
     */
    public static long __gmpn_scan0(MemorySegment x0, long x1) {
        var mh$ = __gmpn_scan0.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__gmpn_scan0", x0, x1);
            }
            return (long)mh$.invokeExact(x0, x1);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __gmpn_scan1 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gmp_h.C_LONG,
            gmp_h.C_POINTER,
            gmp_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__gmpn_scan1");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * mp_bitcnt_t __gmpn_scan1(mp_srcptr, mp_bitcnt_t)
     * }
     */
    public static FunctionDescriptor __gmpn_scan1$descriptor() {
        return __gmpn_scan1.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * mp_bitcnt_t __gmpn_scan1(mp_srcptr, mp_bitcnt_t)
     * }
     */
    public static MethodHandle __gmpn_scan1$handle() {
        return __gmpn_scan1.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * mp_bitcnt_t __gmpn_scan1(mp_srcptr, mp_bitcnt_t)
     * }
     */
    public static MemorySegment __gmpn_scan1$address() {
        return __gmpn_scan1.ADDR;
    }

    /**
     * {@snippet lang=c :
     * mp_bitcnt_t __gmpn_scan1(mp_srcptr, mp_bitcnt_t)
     * }
     */
    public static long __gmpn_scan1(MemorySegment x0, long x1) {
        var mh$ = __gmpn_scan1.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__gmpn_scan1", x0, x1);
            }
            return (long)mh$.invokeExact(x0, x1);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __gmpn_set_str {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gmp_h.C_LONG,
            gmp_h.C_POINTER,
            gmp_h.C_POINTER,
            gmp_h.C_LONG,
            gmp_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__gmpn_set_str");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * mp_size_t __gmpn_set_str(mp_ptr, const unsigned char *, size_t, int)
     * }
     */
    public static FunctionDescriptor __gmpn_set_str$descriptor() {
        return __gmpn_set_str.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * mp_size_t __gmpn_set_str(mp_ptr, const unsigned char *, size_t, int)
     * }
     */
    public static MethodHandle __gmpn_set_str$handle() {
        return __gmpn_set_str.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * mp_size_t __gmpn_set_str(mp_ptr, const unsigned char *, size_t, int)
     * }
     */
    public static MemorySegment __gmpn_set_str$address() {
        return __gmpn_set_str.ADDR;
    }

    /**
     * {@snippet lang=c :
     * mp_size_t __gmpn_set_str(mp_ptr, const unsigned char *, size_t, int)
     * }
     */
    public static long __gmpn_set_str(MemorySegment x0, MemorySegment x1, long x2, int x3) {
        var mh$ = __gmpn_set_str.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__gmpn_set_str", x0, x1, x2, x3);
            }
            return (long)mh$.invokeExact(x0, x1, x2, x3);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __gmpn_sizeinbase {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gmp_h.C_LONG,
            gmp_h.C_POINTER,
            gmp_h.C_LONG,
            gmp_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__gmpn_sizeinbase");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * size_t __gmpn_sizeinbase(mp_srcptr, mp_size_t, int)
     * }
     */
    public static FunctionDescriptor __gmpn_sizeinbase$descriptor() {
        return __gmpn_sizeinbase.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * size_t __gmpn_sizeinbase(mp_srcptr, mp_size_t, int)
     * }
     */
    public static MethodHandle __gmpn_sizeinbase$handle() {
        return __gmpn_sizeinbase.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * size_t __gmpn_sizeinbase(mp_srcptr, mp_size_t, int)
     * }
     */
    public static MemorySegment __gmpn_sizeinbase$address() {
        return __gmpn_sizeinbase.ADDR;
    }

    /**
     * {@snippet lang=c :
     * size_t __gmpn_sizeinbase(mp_srcptr, mp_size_t, int)
     * }
     */
    public static long __gmpn_sizeinbase(MemorySegment x0, long x1, int x2) {
        var mh$ = __gmpn_sizeinbase.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__gmpn_sizeinbase", x0, x1, x2);
            }
            return (long)mh$.invokeExact(x0, x1, x2);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __gmpn_sqrtrem {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gmp_h.C_LONG,
            gmp_h.C_POINTER,
            gmp_h.C_POINTER,
            gmp_h.C_POINTER,
            gmp_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__gmpn_sqrtrem");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * mp_size_t __gmpn_sqrtrem(mp_ptr, mp_ptr, mp_srcptr, mp_size_t)
     * }
     */
    public static FunctionDescriptor __gmpn_sqrtrem$descriptor() {
        return __gmpn_sqrtrem.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * mp_size_t __gmpn_sqrtrem(mp_ptr, mp_ptr, mp_srcptr, mp_size_t)
     * }
     */
    public static MethodHandle __gmpn_sqrtrem$handle() {
        return __gmpn_sqrtrem.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * mp_size_t __gmpn_sqrtrem(mp_ptr, mp_ptr, mp_srcptr, mp_size_t)
     * }
     */
    public static MemorySegment __gmpn_sqrtrem$address() {
        return __gmpn_sqrtrem.ADDR;
    }

    /**
     * {@snippet lang=c :
     * mp_size_t __gmpn_sqrtrem(mp_ptr, mp_ptr, mp_srcptr, mp_size_t)
     * }
     */
    public static long __gmpn_sqrtrem(MemorySegment x0, MemorySegment x1, MemorySegment x2, long x3) {
        var mh$ = __gmpn_sqrtrem.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__gmpn_sqrtrem", x0, x1, x2, x3);
            }
            return (long)mh$.invokeExact(x0, x1, x2, x3);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __gmpn_sub {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gmp_h.C_LONG,
            gmp_h.C_POINTER,
            gmp_h.C_POINTER,
            gmp_h.C_LONG,
            gmp_h.C_POINTER,
            gmp_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__gmpn_sub");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * mp_limb_t __gmpn_sub(mp_ptr, mp_srcptr, mp_size_t, mp_srcptr, mp_size_t)
     * }
     */
    public static FunctionDescriptor __gmpn_sub$descriptor() {
        return __gmpn_sub.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * mp_limb_t __gmpn_sub(mp_ptr, mp_srcptr, mp_size_t, mp_srcptr, mp_size_t)
     * }
     */
    public static MethodHandle __gmpn_sub$handle() {
        return __gmpn_sub.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * mp_limb_t __gmpn_sub(mp_ptr, mp_srcptr, mp_size_t, mp_srcptr, mp_size_t)
     * }
     */
    public static MemorySegment __gmpn_sub$address() {
        return __gmpn_sub.ADDR;
    }

    /**
     * {@snippet lang=c :
     * mp_limb_t __gmpn_sub(mp_ptr, mp_srcptr, mp_size_t, mp_srcptr, mp_size_t)
     * }
     */
    public static long __gmpn_sub(MemorySegment x0, MemorySegment x1, long x2, MemorySegment x3, long x4) {
        var mh$ = __gmpn_sub.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__gmpn_sub", x0, x1, x2, x3, x4);
            }
            return (long)mh$.invokeExact(x0, x1, x2, x3, x4);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __gmpn_sub_1 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gmp_h.C_LONG,
            gmp_h.C_POINTER,
            gmp_h.C_POINTER,
            gmp_h.C_LONG,
            gmp_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__gmpn_sub_1");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * mp_limb_t __gmpn_sub_1(mp_ptr, mp_srcptr, mp_size_t, mp_limb_t)
     * }
     */
    public static FunctionDescriptor __gmpn_sub_1$descriptor() {
        return __gmpn_sub_1.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * mp_limb_t __gmpn_sub_1(mp_ptr, mp_srcptr, mp_size_t, mp_limb_t)
     * }
     */
    public static MethodHandle __gmpn_sub_1$handle() {
        return __gmpn_sub_1.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * mp_limb_t __gmpn_sub_1(mp_ptr, mp_srcptr, mp_size_t, mp_limb_t)
     * }
     */
    public static MemorySegment __gmpn_sub_1$address() {
        return __gmpn_sub_1.ADDR;
    }

    /**
     * {@snippet lang=c :
     * mp_limb_t __gmpn_sub_1(mp_ptr, mp_srcptr, mp_size_t, mp_limb_t)
     * }
     */
    public static long __gmpn_sub_1(MemorySegment x0, MemorySegment x1, long x2, long x3) {
        var mh$ = __gmpn_sub_1.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__gmpn_sub_1", x0, x1, x2, x3);
            }
            return (long)mh$.invokeExact(x0, x1, x2, x3);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __gmpn_sub_n {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gmp_h.C_LONG,
            gmp_h.C_POINTER,
            gmp_h.C_POINTER,
            gmp_h.C_POINTER,
            gmp_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__gmpn_sub_n");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * mp_limb_t __gmpn_sub_n(mp_ptr, mp_srcptr, mp_srcptr, mp_size_t)
     * }
     */
    public static FunctionDescriptor __gmpn_sub_n$descriptor() {
        return __gmpn_sub_n.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * mp_limb_t __gmpn_sub_n(mp_ptr, mp_srcptr, mp_srcptr, mp_size_t)
     * }
     */
    public static MethodHandle __gmpn_sub_n$handle() {
        return __gmpn_sub_n.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * mp_limb_t __gmpn_sub_n(mp_ptr, mp_srcptr, mp_srcptr, mp_size_t)
     * }
     */
    public static MemorySegment __gmpn_sub_n$address() {
        return __gmpn_sub_n.ADDR;
    }

    /**
     * {@snippet lang=c :
     * mp_limb_t __gmpn_sub_n(mp_ptr, mp_srcptr, mp_srcptr, mp_size_t)
     * }
     */
    public static long __gmpn_sub_n(MemorySegment x0, MemorySegment x1, MemorySegment x2, long x3) {
        var mh$ = __gmpn_sub_n.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__gmpn_sub_n", x0, x1, x2, x3);
            }
            return (long)mh$.invokeExact(x0, x1, x2, x3);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __gmpn_submul_1 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gmp_h.C_LONG,
            gmp_h.C_POINTER,
            gmp_h.C_POINTER,
            gmp_h.C_LONG,
            gmp_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__gmpn_submul_1");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * mp_limb_t __gmpn_submul_1(mp_ptr, mp_srcptr, mp_size_t, mp_limb_t)
     * }
     */
    public static FunctionDescriptor __gmpn_submul_1$descriptor() {
        return __gmpn_submul_1.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * mp_limb_t __gmpn_submul_1(mp_ptr, mp_srcptr, mp_size_t, mp_limb_t)
     * }
     */
    public static MethodHandle __gmpn_submul_1$handle() {
        return __gmpn_submul_1.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * mp_limb_t __gmpn_submul_1(mp_ptr, mp_srcptr, mp_size_t, mp_limb_t)
     * }
     */
    public static MemorySegment __gmpn_submul_1$address() {
        return __gmpn_submul_1.ADDR;
    }

    /**
     * {@snippet lang=c :
     * mp_limb_t __gmpn_submul_1(mp_ptr, mp_srcptr, mp_size_t, mp_limb_t)
     * }
     */
    public static long __gmpn_submul_1(MemorySegment x0, MemorySegment x1, long x2, long x3) {
        var mh$ = __gmpn_submul_1.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__gmpn_submul_1", x0, x1, x2, x3);
            }
            return (long)mh$.invokeExact(x0, x1, x2, x3);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __gmpn_tdiv_qr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gmp_h.C_POINTER,
            gmp_h.C_POINTER,
            gmp_h.C_LONG,
            gmp_h.C_POINTER,
            gmp_h.C_LONG,
            gmp_h.C_POINTER,
            gmp_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__gmpn_tdiv_qr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void __gmpn_tdiv_qr(mp_ptr, mp_ptr, mp_size_t, mp_srcptr, mp_size_t, mp_srcptr, mp_size_t)
     * }
     */
    public static FunctionDescriptor __gmpn_tdiv_qr$descriptor() {
        return __gmpn_tdiv_qr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void __gmpn_tdiv_qr(mp_ptr, mp_ptr, mp_size_t, mp_srcptr, mp_size_t, mp_srcptr, mp_size_t)
     * }
     */
    public static MethodHandle __gmpn_tdiv_qr$handle() {
        return __gmpn_tdiv_qr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void __gmpn_tdiv_qr(mp_ptr, mp_ptr, mp_size_t, mp_srcptr, mp_size_t, mp_srcptr, mp_size_t)
     * }
     */
    public static MemorySegment __gmpn_tdiv_qr$address() {
        return __gmpn_tdiv_qr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void __gmpn_tdiv_qr(mp_ptr, mp_ptr, mp_size_t, mp_srcptr, mp_size_t, mp_srcptr, mp_size_t)
     * }
     */
    public static void __gmpn_tdiv_qr(MemorySegment x0, MemorySegment x1, long x2, MemorySegment x3, long x4, MemorySegment x5, long x6) {
        var mh$ = __gmpn_tdiv_qr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__gmpn_tdiv_qr", x0, x1, x2, x3, x4, x5, x6);
            }
            mh$.invokeExact(x0, x1, x2, x3, x4, x5, x6);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __gmpn_and_n {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gmp_h.C_POINTER,
            gmp_h.C_POINTER,
            gmp_h.C_POINTER,
            gmp_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__gmpn_and_n");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void __gmpn_and_n(mp_ptr, mp_srcptr, mp_srcptr, mp_size_t)
     * }
     */
    public static FunctionDescriptor __gmpn_and_n$descriptor() {
        return __gmpn_and_n.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void __gmpn_and_n(mp_ptr, mp_srcptr, mp_srcptr, mp_size_t)
     * }
     */
    public static MethodHandle __gmpn_and_n$handle() {
        return __gmpn_and_n.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void __gmpn_and_n(mp_ptr, mp_srcptr, mp_srcptr, mp_size_t)
     * }
     */
    public static MemorySegment __gmpn_and_n$address() {
        return __gmpn_and_n.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void __gmpn_and_n(mp_ptr, mp_srcptr, mp_srcptr, mp_size_t)
     * }
     */
    public static void __gmpn_and_n(MemorySegment x0, MemorySegment x1, MemorySegment x2, long x3) {
        var mh$ = __gmpn_and_n.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__gmpn_and_n", x0, x1, x2, x3);
            }
            mh$.invokeExact(x0, x1, x2, x3);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __gmpn_andn_n {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gmp_h.C_POINTER,
            gmp_h.C_POINTER,
            gmp_h.C_POINTER,
            gmp_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__gmpn_andn_n");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void __gmpn_andn_n(mp_ptr, mp_srcptr, mp_srcptr, mp_size_t)
     * }
     */
    public static FunctionDescriptor __gmpn_andn_n$descriptor() {
        return __gmpn_andn_n.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void __gmpn_andn_n(mp_ptr, mp_srcptr, mp_srcptr, mp_size_t)
     * }
     */
    public static MethodHandle __gmpn_andn_n$handle() {
        return __gmpn_andn_n.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void __gmpn_andn_n(mp_ptr, mp_srcptr, mp_srcptr, mp_size_t)
     * }
     */
    public static MemorySegment __gmpn_andn_n$address() {
        return __gmpn_andn_n.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void __gmpn_andn_n(mp_ptr, mp_srcptr, mp_srcptr, mp_size_t)
     * }
     */
    public static void __gmpn_andn_n(MemorySegment x0, MemorySegment x1, MemorySegment x2, long x3) {
        var mh$ = __gmpn_andn_n.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__gmpn_andn_n", x0, x1, x2, x3);
            }
            mh$.invokeExact(x0, x1, x2, x3);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __gmpn_nand_n {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gmp_h.C_POINTER,
            gmp_h.C_POINTER,
            gmp_h.C_POINTER,
            gmp_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__gmpn_nand_n");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void __gmpn_nand_n(mp_ptr, mp_srcptr, mp_srcptr, mp_size_t)
     * }
     */
    public static FunctionDescriptor __gmpn_nand_n$descriptor() {
        return __gmpn_nand_n.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void __gmpn_nand_n(mp_ptr, mp_srcptr, mp_srcptr, mp_size_t)
     * }
     */
    public static MethodHandle __gmpn_nand_n$handle() {
        return __gmpn_nand_n.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void __gmpn_nand_n(mp_ptr, mp_srcptr, mp_srcptr, mp_size_t)
     * }
     */
    public static MemorySegment __gmpn_nand_n$address() {
        return __gmpn_nand_n.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void __gmpn_nand_n(mp_ptr, mp_srcptr, mp_srcptr, mp_size_t)
     * }
     */
    public static void __gmpn_nand_n(MemorySegment x0, MemorySegment x1, MemorySegment x2, long x3) {
        var mh$ = __gmpn_nand_n.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__gmpn_nand_n", x0, x1, x2, x3);
            }
            mh$.invokeExact(x0, x1, x2, x3);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __gmpn_ior_n {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gmp_h.C_POINTER,
            gmp_h.C_POINTER,
            gmp_h.C_POINTER,
            gmp_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__gmpn_ior_n");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void __gmpn_ior_n(mp_ptr, mp_srcptr, mp_srcptr, mp_size_t)
     * }
     */
    public static FunctionDescriptor __gmpn_ior_n$descriptor() {
        return __gmpn_ior_n.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void __gmpn_ior_n(mp_ptr, mp_srcptr, mp_srcptr, mp_size_t)
     * }
     */
    public static MethodHandle __gmpn_ior_n$handle() {
        return __gmpn_ior_n.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void __gmpn_ior_n(mp_ptr, mp_srcptr, mp_srcptr, mp_size_t)
     * }
     */
    public static MemorySegment __gmpn_ior_n$address() {
        return __gmpn_ior_n.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void __gmpn_ior_n(mp_ptr, mp_srcptr, mp_srcptr, mp_size_t)
     * }
     */
    public static void __gmpn_ior_n(MemorySegment x0, MemorySegment x1, MemorySegment x2, long x3) {
        var mh$ = __gmpn_ior_n.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__gmpn_ior_n", x0, x1, x2, x3);
            }
            mh$.invokeExact(x0, x1, x2, x3);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __gmpn_iorn_n {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gmp_h.C_POINTER,
            gmp_h.C_POINTER,
            gmp_h.C_POINTER,
            gmp_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__gmpn_iorn_n");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void __gmpn_iorn_n(mp_ptr, mp_srcptr, mp_srcptr, mp_size_t)
     * }
     */
    public static FunctionDescriptor __gmpn_iorn_n$descriptor() {
        return __gmpn_iorn_n.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void __gmpn_iorn_n(mp_ptr, mp_srcptr, mp_srcptr, mp_size_t)
     * }
     */
    public static MethodHandle __gmpn_iorn_n$handle() {
        return __gmpn_iorn_n.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void __gmpn_iorn_n(mp_ptr, mp_srcptr, mp_srcptr, mp_size_t)
     * }
     */
    public static MemorySegment __gmpn_iorn_n$address() {
        return __gmpn_iorn_n.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void __gmpn_iorn_n(mp_ptr, mp_srcptr, mp_srcptr, mp_size_t)
     * }
     */
    public static void __gmpn_iorn_n(MemorySegment x0, MemorySegment x1, MemorySegment x2, long x3) {
        var mh$ = __gmpn_iorn_n.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__gmpn_iorn_n", x0, x1, x2, x3);
            }
            mh$.invokeExact(x0, x1, x2, x3);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __gmpn_nior_n {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gmp_h.C_POINTER,
            gmp_h.C_POINTER,
            gmp_h.C_POINTER,
            gmp_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__gmpn_nior_n");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void __gmpn_nior_n(mp_ptr, mp_srcptr, mp_srcptr, mp_size_t)
     * }
     */
    public static FunctionDescriptor __gmpn_nior_n$descriptor() {
        return __gmpn_nior_n.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void __gmpn_nior_n(mp_ptr, mp_srcptr, mp_srcptr, mp_size_t)
     * }
     */
    public static MethodHandle __gmpn_nior_n$handle() {
        return __gmpn_nior_n.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void __gmpn_nior_n(mp_ptr, mp_srcptr, mp_srcptr, mp_size_t)
     * }
     */
    public static MemorySegment __gmpn_nior_n$address() {
        return __gmpn_nior_n.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void __gmpn_nior_n(mp_ptr, mp_srcptr, mp_srcptr, mp_size_t)
     * }
     */
    public static void __gmpn_nior_n(MemorySegment x0, MemorySegment x1, MemorySegment x2, long x3) {
        var mh$ = __gmpn_nior_n.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__gmpn_nior_n", x0, x1, x2, x3);
            }
            mh$.invokeExact(x0, x1, x2, x3);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __gmpn_xor_n {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gmp_h.C_POINTER,
            gmp_h.C_POINTER,
            gmp_h.C_POINTER,
            gmp_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__gmpn_xor_n");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void __gmpn_xor_n(mp_ptr, mp_srcptr, mp_srcptr, mp_size_t)
     * }
     */
    public static FunctionDescriptor __gmpn_xor_n$descriptor() {
        return __gmpn_xor_n.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void __gmpn_xor_n(mp_ptr, mp_srcptr, mp_srcptr, mp_size_t)
     * }
     */
    public static MethodHandle __gmpn_xor_n$handle() {
        return __gmpn_xor_n.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void __gmpn_xor_n(mp_ptr, mp_srcptr, mp_srcptr, mp_size_t)
     * }
     */
    public static MemorySegment __gmpn_xor_n$address() {
        return __gmpn_xor_n.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void __gmpn_xor_n(mp_ptr, mp_srcptr, mp_srcptr, mp_size_t)
     * }
     */
    public static void __gmpn_xor_n(MemorySegment x0, MemorySegment x1, MemorySegment x2, long x3) {
        var mh$ = __gmpn_xor_n.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__gmpn_xor_n", x0, x1, x2, x3);
            }
            mh$.invokeExact(x0, x1, x2, x3);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __gmpn_xnor_n {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gmp_h.C_POINTER,
            gmp_h.C_POINTER,
            gmp_h.C_POINTER,
            gmp_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__gmpn_xnor_n");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void __gmpn_xnor_n(mp_ptr, mp_srcptr, mp_srcptr, mp_size_t)
     * }
     */
    public static FunctionDescriptor __gmpn_xnor_n$descriptor() {
        return __gmpn_xnor_n.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void __gmpn_xnor_n(mp_ptr, mp_srcptr, mp_srcptr, mp_size_t)
     * }
     */
    public static MethodHandle __gmpn_xnor_n$handle() {
        return __gmpn_xnor_n.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void __gmpn_xnor_n(mp_ptr, mp_srcptr, mp_srcptr, mp_size_t)
     * }
     */
    public static MemorySegment __gmpn_xnor_n$address() {
        return __gmpn_xnor_n.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void __gmpn_xnor_n(mp_ptr, mp_srcptr, mp_srcptr, mp_size_t)
     * }
     */
    public static void __gmpn_xnor_n(MemorySegment x0, MemorySegment x1, MemorySegment x2, long x3) {
        var mh$ = __gmpn_xnor_n.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__gmpn_xnor_n", x0, x1, x2, x3);
            }
            mh$.invokeExact(x0, x1, x2, x3);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __gmpn_copyi {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gmp_h.C_POINTER,
            gmp_h.C_POINTER,
            gmp_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__gmpn_copyi");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void __gmpn_copyi(mp_ptr, mp_srcptr, mp_size_t)
     * }
     */
    public static FunctionDescriptor __gmpn_copyi$descriptor() {
        return __gmpn_copyi.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void __gmpn_copyi(mp_ptr, mp_srcptr, mp_size_t)
     * }
     */
    public static MethodHandle __gmpn_copyi$handle() {
        return __gmpn_copyi.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void __gmpn_copyi(mp_ptr, mp_srcptr, mp_size_t)
     * }
     */
    public static MemorySegment __gmpn_copyi$address() {
        return __gmpn_copyi.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void __gmpn_copyi(mp_ptr, mp_srcptr, mp_size_t)
     * }
     */
    public static void __gmpn_copyi(MemorySegment x0, MemorySegment x1, long x2) {
        var mh$ = __gmpn_copyi.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__gmpn_copyi", x0, x1, x2);
            }
            mh$.invokeExact(x0, x1, x2);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __gmpn_copyd {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gmp_h.C_POINTER,
            gmp_h.C_POINTER,
            gmp_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__gmpn_copyd");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void __gmpn_copyd(mp_ptr, mp_srcptr, mp_size_t)
     * }
     */
    public static FunctionDescriptor __gmpn_copyd$descriptor() {
        return __gmpn_copyd.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void __gmpn_copyd(mp_ptr, mp_srcptr, mp_size_t)
     * }
     */
    public static MethodHandle __gmpn_copyd$handle() {
        return __gmpn_copyd.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void __gmpn_copyd(mp_ptr, mp_srcptr, mp_size_t)
     * }
     */
    public static MemorySegment __gmpn_copyd$address() {
        return __gmpn_copyd.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void __gmpn_copyd(mp_ptr, mp_srcptr, mp_size_t)
     * }
     */
    public static void __gmpn_copyd(MemorySegment x0, MemorySegment x1, long x2) {
        var mh$ = __gmpn_copyd.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__gmpn_copyd", x0, x1, x2);
            }
            mh$.invokeExact(x0, x1, x2);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __gmpn_zero {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gmp_h.C_POINTER,
            gmp_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__gmpn_zero");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void __gmpn_zero(mp_ptr, mp_size_t)
     * }
     */
    public static FunctionDescriptor __gmpn_zero$descriptor() {
        return __gmpn_zero.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void __gmpn_zero(mp_ptr, mp_size_t)
     * }
     */
    public static MethodHandle __gmpn_zero$handle() {
        return __gmpn_zero.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void __gmpn_zero(mp_ptr, mp_size_t)
     * }
     */
    public static MemorySegment __gmpn_zero$address() {
        return __gmpn_zero.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void __gmpn_zero(mp_ptr, mp_size_t)
     * }
     */
    public static void __gmpn_zero(MemorySegment x0, long x1) {
        var mh$ = __gmpn_zero.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__gmpn_zero", x0, x1);
            }
            mh$.invokeExact(x0, x1);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __gmpn_cnd_add_n {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gmp_h.C_LONG,
            gmp_h.C_LONG,
            gmp_h.C_POINTER,
            gmp_h.C_POINTER,
            gmp_h.C_POINTER,
            gmp_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__gmpn_cnd_add_n");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * mp_limb_t __gmpn_cnd_add_n(mp_limb_t, mp_ptr, mp_srcptr, mp_srcptr, mp_size_t)
     * }
     */
    public static FunctionDescriptor __gmpn_cnd_add_n$descriptor() {
        return __gmpn_cnd_add_n.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * mp_limb_t __gmpn_cnd_add_n(mp_limb_t, mp_ptr, mp_srcptr, mp_srcptr, mp_size_t)
     * }
     */
    public static MethodHandle __gmpn_cnd_add_n$handle() {
        return __gmpn_cnd_add_n.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * mp_limb_t __gmpn_cnd_add_n(mp_limb_t, mp_ptr, mp_srcptr, mp_srcptr, mp_size_t)
     * }
     */
    public static MemorySegment __gmpn_cnd_add_n$address() {
        return __gmpn_cnd_add_n.ADDR;
    }

    /**
     * {@snippet lang=c :
     * mp_limb_t __gmpn_cnd_add_n(mp_limb_t, mp_ptr, mp_srcptr, mp_srcptr, mp_size_t)
     * }
     */
    public static long __gmpn_cnd_add_n(long x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, long x4) {
        var mh$ = __gmpn_cnd_add_n.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__gmpn_cnd_add_n", x0, x1, x2, x3, x4);
            }
            return (long)mh$.invokeExact(x0, x1, x2, x3, x4);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __gmpn_cnd_sub_n {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gmp_h.C_LONG,
            gmp_h.C_LONG,
            gmp_h.C_POINTER,
            gmp_h.C_POINTER,
            gmp_h.C_POINTER,
            gmp_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__gmpn_cnd_sub_n");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * mp_limb_t __gmpn_cnd_sub_n(mp_limb_t, mp_ptr, mp_srcptr, mp_srcptr, mp_size_t)
     * }
     */
    public static FunctionDescriptor __gmpn_cnd_sub_n$descriptor() {
        return __gmpn_cnd_sub_n.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * mp_limb_t __gmpn_cnd_sub_n(mp_limb_t, mp_ptr, mp_srcptr, mp_srcptr, mp_size_t)
     * }
     */
    public static MethodHandle __gmpn_cnd_sub_n$handle() {
        return __gmpn_cnd_sub_n.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * mp_limb_t __gmpn_cnd_sub_n(mp_limb_t, mp_ptr, mp_srcptr, mp_srcptr, mp_size_t)
     * }
     */
    public static MemorySegment __gmpn_cnd_sub_n$address() {
        return __gmpn_cnd_sub_n.ADDR;
    }

    /**
     * {@snippet lang=c :
     * mp_limb_t __gmpn_cnd_sub_n(mp_limb_t, mp_ptr, mp_srcptr, mp_srcptr, mp_size_t)
     * }
     */
    public static long __gmpn_cnd_sub_n(long x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, long x4) {
        var mh$ = __gmpn_cnd_sub_n.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__gmpn_cnd_sub_n", x0, x1, x2, x3, x4);
            }
            return (long)mh$.invokeExact(x0, x1, x2, x3, x4);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __gmpn_sec_add_1 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gmp_h.C_LONG,
            gmp_h.C_POINTER,
            gmp_h.C_POINTER,
            gmp_h.C_LONG,
            gmp_h.C_LONG,
            gmp_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__gmpn_sec_add_1");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * mp_limb_t __gmpn_sec_add_1(mp_ptr, mp_srcptr, mp_size_t, mp_limb_t, mp_ptr)
     * }
     */
    public static FunctionDescriptor __gmpn_sec_add_1$descriptor() {
        return __gmpn_sec_add_1.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * mp_limb_t __gmpn_sec_add_1(mp_ptr, mp_srcptr, mp_size_t, mp_limb_t, mp_ptr)
     * }
     */
    public static MethodHandle __gmpn_sec_add_1$handle() {
        return __gmpn_sec_add_1.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * mp_limb_t __gmpn_sec_add_1(mp_ptr, mp_srcptr, mp_size_t, mp_limb_t, mp_ptr)
     * }
     */
    public static MemorySegment __gmpn_sec_add_1$address() {
        return __gmpn_sec_add_1.ADDR;
    }

    /**
     * {@snippet lang=c :
     * mp_limb_t __gmpn_sec_add_1(mp_ptr, mp_srcptr, mp_size_t, mp_limb_t, mp_ptr)
     * }
     */
    public static long __gmpn_sec_add_1(MemorySegment x0, MemorySegment x1, long x2, long x3, MemorySegment x4) {
        var mh$ = __gmpn_sec_add_1.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__gmpn_sec_add_1", x0, x1, x2, x3, x4);
            }
            return (long)mh$.invokeExact(x0, x1, x2, x3, x4);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __gmpn_sec_add_1_itch {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gmp_h.C_LONG,
            gmp_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__gmpn_sec_add_1_itch");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * mp_size_t __gmpn_sec_add_1_itch(mp_size_t)
     * }
     */
    public static FunctionDescriptor __gmpn_sec_add_1_itch$descriptor() {
        return __gmpn_sec_add_1_itch.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * mp_size_t __gmpn_sec_add_1_itch(mp_size_t)
     * }
     */
    public static MethodHandle __gmpn_sec_add_1_itch$handle() {
        return __gmpn_sec_add_1_itch.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * mp_size_t __gmpn_sec_add_1_itch(mp_size_t)
     * }
     */
    public static MemorySegment __gmpn_sec_add_1_itch$address() {
        return __gmpn_sec_add_1_itch.ADDR;
    }

    /**
     * {@snippet lang=c :
     * mp_size_t __gmpn_sec_add_1_itch(mp_size_t)
     * }
     */
    public static long __gmpn_sec_add_1_itch(long x0) {
        var mh$ = __gmpn_sec_add_1_itch.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__gmpn_sec_add_1_itch", x0);
            }
            return (long)mh$.invokeExact(x0);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __gmpn_sec_sub_1 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gmp_h.C_LONG,
            gmp_h.C_POINTER,
            gmp_h.C_POINTER,
            gmp_h.C_LONG,
            gmp_h.C_LONG,
            gmp_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__gmpn_sec_sub_1");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * mp_limb_t __gmpn_sec_sub_1(mp_ptr, mp_srcptr, mp_size_t, mp_limb_t, mp_ptr)
     * }
     */
    public static FunctionDescriptor __gmpn_sec_sub_1$descriptor() {
        return __gmpn_sec_sub_1.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * mp_limb_t __gmpn_sec_sub_1(mp_ptr, mp_srcptr, mp_size_t, mp_limb_t, mp_ptr)
     * }
     */
    public static MethodHandle __gmpn_sec_sub_1$handle() {
        return __gmpn_sec_sub_1.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * mp_limb_t __gmpn_sec_sub_1(mp_ptr, mp_srcptr, mp_size_t, mp_limb_t, mp_ptr)
     * }
     */
    public static MemorySegment __gmpn_sec_sub_1$address() {
        return __gmpn_sec_sub_1.ADDR;
    }

    /**
     * {@snippet lang=c :
     * mp_limb_t __gmpn_sec_sub_1(mp_ptr, mp_srcptr, mp_size_t, mp_limb_t, mp_ptr)
     * }
     */
    public static long __gmpn_sec_sub_1(MemorySegment x0, MemorySegment x1, long x2, long x3, MemorySegment x4) {
        var mh$ = __gmpn_sec_sub_1.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__gmpn_sec_sub_1", x0, x1, x2, x3, x4);
            }
            return (long)mh$.invokeExact(x0, x1, x2, x3, x4);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __gmpn_sec_sub_1_itch {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gmp_h.C_LONG,
            gmp_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__gmpn_sec_sub_1_itch");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * mp_size_t __gmpn_sec_sub_1_itch(mp_size_t)
     * }
     */
    public static FunctionDescriptor __gmpn_sec_sub_1_itch$descriptor() {
        return __gmpn_sec_sub_1_itch.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * mp_size_t __gmpn_sec_sub_1_itch(mp_size_t)
     * }
     */
    public static MethodHandle __gmpn_sec_sub_1_itch$handle() {
        return __gmpn_sec_sub_1_itch.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * mp_size_t __gmpn_sec_sub_1_itch(mp_size_t)
     * }
     */
    public static MemorySegment __gmpn_sec_sub_1_itch$address() {
        return __gmpn_sec_sub_1_itch.ADDR;
    }

    /**
     * {@snippet lang=c :
     * mp_size_t __gmpn_sec_sub_1_itch(mp_size_t)
     * }
     */
    public static long __gmpn_sec_sub_1_itch(long x0) {
        var mh$ = __gmpn_sec_sub_1_itch.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__gmpn_sec_sub_1_itch", x0);
            }
            return (long)mh$.invokeExact(x0);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __gmpn_cnd_swap {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gmp_h.C_LONG,
            gmp_h.C_POINTER,
            gmp_h.C_POINTER,
            gmp_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__gmpn_cnd_swap");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void __gmpn_cnd_swap(mp_limb_t, volatile mp_limb_t *, volatile mp_limb_t *, mp_size_t)
     * }
     */
    public static FunctionDescriptor __gmpn_cnd_swap$descriptor() {
        return __gmpn_cnd_swap.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void __gmpn_cnd_swap(mp_limb_t, volatile mp_limb_t *, volatile mp_limb_t *, mp_size_t)
     * }
     */
    public static MethodHandle __gmpn_cnd_swap$handle() {
        return __gmpn_cnd_swap.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void __gmpn_cnd_swap(mp_limb_t, volatile mp_limb_t *, volatile mp_limb_t *, mp_size_t)
     * }
     */
    public static MemorySegment __gmpn_cnd_swap$address() {
        return __gmpn_cnd_swap.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void __gmpn_cnd_swap(mp_limb_t, volatile mp_limb_t *, volatile mp_limb_t *, mp_size_t)
     * }
     */
    public static void __gmpn_cnd_swap(long x0, MemorySegment x1, MemorySegment x2, long x3) {
        var mh$ = __gmpn_cnd_swap.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__gmpn_cnd_swap", x0, x1, x2, x3);
            }
            mh$.invokeExact(x0, x1, x2, x3);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __gmpn_sec_mul {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gmp_h.C_POINTER,
            gmp_h.C_POINTER,
            gmp_h.C_LONG,
            gmp_h.C_POINTER,
            gmp_h.C_LONG,
            gmp_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__gmpn_sec_mul");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void __gmpn_sec_mul(mp_ptr, mp_srcptr, mp_size_t, mp_srcptr, mp_size_t, mp_ptr)
     * }
     */
    public static FunctionDescriptor __gmpn_sec_mul$descriptor() {
        return __gmpn_sec_mul.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void __gmpn_sec_mul(mp_ptr, mp_srcptr, mp_size_t, mp_srcptr, mp_size_t, mp_ptr)
     * }
     */
    public static MethodHandle __gmpn_sec_mul$handle() {
        return __gmpn_sec_mul.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void __gmpn_sec_mul(mp_ptr, mp_srcptr, mp_size_t, mp_srcptr, mp_size_t, mp_ptr)
     * }
     */
    public static MemorySegment __gmpn_sec_mul$address() {
        return __gmpn_sec_mul.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void __gmpn_sec_mul(mp_ptr, mp_srcptr, mp_size_t, mp_srcptr, mp_size_t, mp_ptr)
     * }
     */
    public static void __gmpn_sec_mul(MemorySegment x0, MemorySegment x1, long x2, MemorySegment x3, long x4, MemorySegment x5) {
        var mh$ = __gmpn_sec_mul.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__gmpn_sec_mul", x0, x1, x2, x3, x4, x5);
            }
            mh$.invokeExact(x0, x1, x2, x3, x4, x5);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __gmpn_sec_mul_itch {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gmp_h.C_LONG,
            gmp_h.C_LONG,
            gmp_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__gmpn_sec_mul_itch");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * mp_size_t __gmpn_sec_mul_itch(mp_size_t, mp_size_t)
     * }
     */
    public static FunctionDescriptor __gmpn_sec_mul_itch$descriptor() {
        return __gmpn_sec_mul_itch.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * mp_size_t __gmpn_sec_mul_itch(mp_size_t, mp_size_t)
     * }
     */
    public static MethodHandle __gmpn_sec_mul_itch$handle() {
        return __gmpn_sec_mul_itch.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * mp_size_t __gmpn_sec_mul_itch(mp_size_t, mp_size_t)
     * }
     */
    public static MemorySegment __gmpn_sec_mul_itch$address() {
        return __gmpn_sec_mul_itch.ADDR;
    }

    /**
     * {@snippet lang=c :
     * mp_size_t __gmpn_sec_mul_itch(mp_size_t, mp_size_t)
     * }
     */
    public static long __gmpn_sec_mul_itch(long x0, long x1) {
        var mh$ = __gmpn_sec_mul_itch.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__gmpn_sec_mul_itch", x0, x1);
            }
            return (long)mh$.invokeExact(x0, x1);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __gmpn_sec_sqr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gmp_h.C_POINTER,
            gmp_h.C_POINTER,
            gmp_h.C_LONG,
            gmp_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__gmpn_sec_sqr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void __gmpn_sec_sqr(mp_ptr, mp_srcptr, mp_size_t, mp_ptr)
     * }
     */
    public static FunctionDescriptor __gmpn_sec_sqr$descriptor() {
        return __gmpn_sec_sqr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void __gmpn_sec_sqr(mp_ptr, mp_srcptr, mp_size_t, mp_ptr)
     * }
     */
    public static MethodHandle __gmpn_sec_sqr$handle() {
        return __gmpn_sec_sqr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void __gmpn_sec_sqr(mp_ptr, mp_srcptr, mp_size_t, mp_ptr)
     * }
     */
    public static MemorySegment __gmpn_sec_sqr$address() {
        return __gmpn_sec_sqr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void __gmpn_sec_sqr(mp_ptr, mp_srcptr, mp_size_t, mp_ptr)
     * }
     */
    public static void __gmpn_sec_sqr(MemorySegment x0, MemorySegment x1, long x2, MemorySegment x3) {
        var mh$ = __gmpn_sec_sqr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__gmpn_sec_sqr", x0, x1, x2, x3);
            }
            mh$.invokeExact(x0, x1, x2, x3);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __gmpn_sec_sqr_itch {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gmp_h.C_LONG,
            gmp_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__gmpn_sec_sqr_itch");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * mp_size_t __gmpn_sec_sqr_itch(mp_size_t)
     * }
     */
    public static FunctionDescriptor __gmpn_sec_sqr_itch$descriptor() {
        return __gmpn_sec_sqr_itch.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * mp_size_t __gmpn_sec_sqr_itch(mp_size_t)
     * }
     */
    public static MethodHandle __gmpn_sec_sqr_itch$handle() {
        return __gmpn_sec_sqr_itch.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * mp_size_t __gmpn_sec_sqr_itch(mp_size_t)
     * }
     */
    public static MemorySegment __gmpn_sec_sqr_itch$address() {
        return __gmpn_sec_sqr_itch.ADDR;
    }

    /**
     * {@snippet lang=c :
     * mp_size_t __gmpn_sec_sqr_itch(mp_size_t)
     * }
     */
    public static long __gmpn_sec_sqr_itch(long x0) {
        var mh$ = __gmpn_sec_sqr_itch.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__gmpn_sec_sqr_itch", x0);
            }
            return (long)mh$.invokeExact(x0);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __gmpn_sec_powm {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gmp_h.C_POINTER,
            gmp_h.C_POINTER,
            gmp_h.C_LONG,
            gmp_h.C_POINTER,
            gmp_h.C_LONG,
            gmp_h.C_POINTER,
            gmp_h.C_LONG,
            gmp_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__gmpn_sec_powm");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void __gmpn_sec_powm(mp_ptr, mp_srcptr, mp_size_t, mp_srcptr, mp_bitcnt_t, mp_srcptr, mp_size_t, mp_ptr)
     * }
     */
    public static FunctionDescriptor __gmpn_sec_powm$descriptor() {
        return __gmpn_sec_powm.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void __gmpn_sec_powm(mp_ptr, mp_srcptr, mp_size_t, mp_srcptr, mp_bitcnt_t, mp_srcptr, mp_size_t, mp_ptr)
     * }
     */
    public static MethodHandle __gmpn_sec_powm$handle() {
        return __gmpn_sec_powm.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void __gmpn_sec_powm(mp_ptr, mp_srcptr, mp_size_t, mp_srcptr, mp_bitcnt_t, mp_srcptr, mp_size_t, mp_ptr)
     * }
     */
    public static MemorySegment __gmpn_sec_powm$address() {
        return __gmpn_sec_powm.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void __gmpn_sec_powm(mp_ptr, mp_srcptr, mp_size_t, mp_srcptr, mp_bitcnt_t, mp_srcptr, mp_size_t, mp_ptr)
     * }
     */
    public static void __gmpn_sec_powm(MemorySegment x0, MemorySegment x1, long x2, MemorySegment x3, long x4, MemorySegment x5, long x6, MemorySegment x7) {
        var mh$ = __gmpn_sec_powm.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__gmpn_sec_powm", x0, x1, x2, x3, x4, x5, x6, x7);
            }
            mh$.invokeExact(x0, x1, x2, x3, x4, x5, x6, x7);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __gmpn_sec_powm_itch {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gmp_h.C_LONG,
            gmp_h.C_LONG,
            gmp_h.C_LONG,
            gmp_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__gmpn_sec_powm_itch");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * mp_size_t __gmpn_sec_powm_itch(mp_size_t, mp_bitcnt_t, mp_size_t)
     * }
     */
    public static FunctionDescriptor __gmpn_sec_powm_itch$descriptor() {
        return __gmpn_sec_powm_itch.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * mp_size_t __gmpn_sec_powm_itch(mp_size_t, mp_bitcnt_t, mp_size_t)
     * }
     */
    public static MethodHandle __gmpn_sec_powm_itch$handle() {
        return __gmpn_sec_powm_itch.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * mp_size_t __gmpn_sec_powm_itch(mp_size_t, mp_bitcnt_t, mp_size_t)
     * }
     */
    public static MemorySegment __gmpn_sec_powm_itch$address() {
        return __gmpn_sec_powm_itch.ADDR;
    }

    /**
     * {@snippet lang=c :
     * mp_size_t __gmpn_sec_powm_itch(mp_size_t, mp_bitcnt_t, mp_size_t)
     * }
     */
    public static long __gmpn_sec_powm_itch(long x0, long x1, long x2) {
        var mh$ = __gmpn_sec_powm_itch.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__gmpn_sec_powm_itch", x0, x1, x2);
            }
            return (long)mh$.invokeExact(x0, x1, x2);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __gmpn_sec_tabselect {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gmp_h.C_POINTER,
            gmp_h.C_POINTER,
            gmp_h.C_LONG,
            gmp_h.C_LONG,
            gmp_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__gmpn_sec_tabselect");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void __gmpn_sec_tabselect(volatile mp_limb_t *, const volatile mp_limb_t *, mp_size_t, mp_size_t, mp_size_t)
     * }
     */
    public static FunctionDescriptor __gmpn_sec_tabselect$descriptor() {
        return __gmpn_sec_tabselect.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void __gmpn_sec_tabselect(volatile mp_limb_t *, const volatile mp_limb_t *, mp_size_t, mp_size_t, mp_size_t)
     * }
     */
    public static MethodHandle __gmpn_sec_tabselect$handle() {
        return __gmpn_sec_tabselect.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void __gmpn_sec_tabselect(volatile mp_limb_t *, const volatile mp_limb_t *, mp_size_t, mp_size_t, mp_size_t)
     * }
     */
    public static MemorySegment __gmpn_sec_tabselect$address() {
        return __gmpn_sec_tabselect.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void __gmpn_sec_tabselect(volatile mp_limb_t *, const volatile mp_limb_t *, mp_size_t, mp_size_t, mp_size_t)
     * }
     */
    public static void __gmpn_sec_tabselect(MemorySegment x0, MemorySegment x1, long x2, long x3, long x4) {
        var mh$ = __gmpn_sec_tabselect.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__gmpn_sec_tabselect", x0, x1, x2, x3, x4);
            }
            mh$.invokeExact(x0, x1, x2, x3, x4);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __gmpn_sec_div_qr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gmp_h.C_LONG,
            gmp_h.C_POINTER,
            gmp_h.C_POINTER,
            gmp_h.C_LONG,
            gmp_h.C_POINTER,
            gmp_h.C_LONG,
            gmp_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__gmpn_sec_div_qr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * mp_limb_t __gmpn_sec_div_qr(mp_ptr, mp_ptr, mp_size_t, mp_srcptr, mp_size_t, mp_ptr)
     * }
     */
    public static FunctionDescriptor __gmpn_sec_div_qr$descriptor() {
        return __gmpn_sec_div_qr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * mp_limb_t __gmpn_sec_div_qr(mp_ptr, mp_ptr, mp_size_t, mp_srcptr, mp_size_t, mp_ptr)
     * }
     */
    public static MethodHandle __gmpn_sec_div_qr$handle() {
        return __gmpn_sec_div_qr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * mp_limb_t __gmpn_sec_div_qr(mp_ptr, mp_ptr, mp_size_t, mp_srcptr, mp_size_t, mp_ptr)
     * }
     */
    public static MemorySegment __gmpn_sec_div_qr$address() {
        return __gmpn_sec_div_qr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * mp_limb_t __gmpn_sec_div_qr(mp_ptr, mp_ptr, mp_size_t, mp_srcptr, mp_size_t, mp_ptr)
     * }
     */
    public static long __gmpn_sec_div_qr(MemorySegment x0, MemorySegment x1, long x2, MemorySegment x3, long x4, MemorySegment x5) {
        var mh$ = __gmpn_sec_div_qr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__gmpn_sec_div_qr", x0, x1, x2, x3, x4, x5);
            }
            return (long)mh$.invokeExact(x0, x1, x2, x3, x4, x5);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __gmpn_sec_div_qr_itch {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gmp_h.C_LONG,
            gmp_h.C_LONG,
            gmp_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__gmpn_sec_div_qr_itch");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * mp_size_t __gmpn_sec_div_qr_itch(mp_size_t, mp_size_t)
     * }
     */
    public static FunctionDescriptor __gmpn_sec_div_qr_itch$descriptor() {
        return __gmpn_sec_div_qr_itch.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * mp_size_t __gmpn_sec_div_qr_itch(mp_size_t, mp_size_t)
     * }
     */
    public static MethodHandle __gmpn_sec_div_qr_itch$handle() {
        return __gmpn_sec_div_qr_itch.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * mp_size_t __gmpn_sec_div_qr_itch(mp_size_t, mp_size_t)
     * }
     */
    public static MemorySegment __gmpn_sec_div_qr_itch$address() {
        return __gmpn_sec_div_qr_itch.ADDR;
    }

    /**
     * {@snippet lang=c :
     * mp_size_t __gmpn_sec_div_qr_itch(mp_size_t, mp_size_t)
     * }
     */
    public static long __gmpn_sec_div_qr_itch(long x0, long x1) {
        var mh$ = __gmpn_sec_div_qr_itch.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__gmpn_sec_div_qr_itch", x0, x1);
            }
            return (long)mh$.invokeExact(x0, x1);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __gmpn_sec_div_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            gmp_h.C_POINTER,
            gmp_h.C_LONG,
            gmp_h.C_POINTER,
            gmp_h.C_LONG,
            gmp_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__gmpn_sec_div_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void __gmpn_sec_div_r(mp_ptr, mp_size_t, mp_srcptr, mp_size_t, mp_ptr)
     * }
     */
    public static FunctionDescriptor __gmpn_sec_div_r$descriptor() {
        return __gmpn_sec_div_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void __gmpn_sec_div_r(mp_ptr, mp_size_t, mp_srcptr, mp_size_t, mp_ptr)
     * }
     */
    public static MethodHandle __gmpn_sec_div_r$handle() {
        return __gmpn_sec_div_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void __gmpn_sec_div_r(mp_ptr, mp_size_t, mp_srcptr, mp_size_t, mp_ptr)
     * }
     */
    public static MemorySegment __gmpn_sec_div_r$address() {
        return __gmpn_sec_div_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void __gmpn_sec_div_r(mp_ptr, mp_size_t, mp_srcptr, mp_size_t, mp_ptr)
     * }
     */
    public static void __gmpn_sec_div_r(MemorySegment x0, long x1, MemorySegment x2, long x3, MemorySegment x4) {
        var mh$ = __gmpn_sec_div_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__gmpn_sec_div_r", x0, x1, x2, x3, x4);
            }
            mh$.invokeExact(x0, x1, x2, x3, x4);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __gmpn_sec_div_r_itch {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gmp_h.C_LONG,
            gmp_h.C_LONG,
            gmp_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__gmpn_sec_div_r_itch");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * mp_size_t __gmpn_sec_div_r_itch(mp_size_t, mp_size_t)
     * }
     */
    public static FunctionDescriptor __gmpn_sec_div_r_itch$descriptor() {
        return __gmpn_sec_div_r_itch.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * mp_size_t __gmpn_sec_div_r_itch(mp_size_t, mp_size_t)
     * }
     */
    public static MethodHandle __gmpn_sec_div_r_itch$handle() {
        return __gmpn_sec_div_r_itch.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * mp_size_t __gmpn_sec_div_r_itch(mp_size_t, mp_size_t)
     * }
     */
    public static MemorySegment __gmpn_sec_div_r_itch$address() {
        return __gmpn_sec_div_r_itch.ADDR;
    }

    /**
     * {@snippet lang=c :
     * mp_size_t __gmpn_sec_div_r_itch(mp_size_t, mp_size_t)
     * }
     */
    public static long __gmpn_sec_div_r_itch(long x0, long x1) {
        var mh$ = __gmpn_sec_div_r_itch.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__gmpn_sec_div_r_itch", x0, x1);
            }
            return (long)mh$.invokeExact(x0, x1);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __gmpn_sec_invert {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gmp_h.C_INT,
            gmp_h.C_POINTER,
            gmp_h.C_POINTER,
            gmp_h.C_POINTER,
            gmp_h.C_LONG,
            gmp_h.C_LONG,
            gmp_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__gmpn_sec_invert");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int __gmpn_sec_invert(mp_ptr, mp_ptr, mp_srcptr, mp_size_t, mp_bitcnt_t, mp_ptr)
     * }
     */
    public static FunctionDescriptor __gmpn_sec_invert$descriptor() {
        return __gmpn_sec_invert.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int __gmpn_sec_invert(mp_ptr, mp_ptr, mp_srcptr, mp_size_t, mp_bitcnt_t, mp_ptr)
     * }
     */
    public static MethodHandle __gmpn_sec_invert$handle() {
        return __gmpn_sec_invert.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int __gmpn_sec_invert(mp_ptr, mp_ptr, mp_srcptr, mp_size_t, mp_bitcnt_t, mp_ptr)
     * }
     */
    public static MemorySegment __gmpn_sec_invert$address() {
        return __gmpn_sec_invert.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int __gmpn_sec_invert(mp_ptr, mp_ptr, mp_srcptr, mp_size_t, mp_bitcnt_t, mp_ptr)
     * }
     */
    public static int __gmpn_sec_invert(MemorySegment x0, MemorySegment x1, MemorySegment x2, long x3, long x4, MemorySegment x5) {
        var mh$ = __gmpn_sec_invert.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__gmpn_sec_invert", x0, x1, x2, x3, x4, x5);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4, x5);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __gmpn_sec_invert_itch {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            gmp_h.C_LONG,
            gmp_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__gmpn_sec_invert_itch");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * mp_size_t __gmpn_sec_invert_itch(mp_size_t)
     * }
     */
    public static FunctionDescriptor __gmpn_sec_invert_itch$descriptor() {
        return __gmpn_sec_invert_itch.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * mp_size_t __gmpn_sec_invert_itch(mp_size_t)
     * }
     */
    public static MethodHandle __gmpn_sec_invert_itch$handle() {
        return __gmpn_sec_invert_itch.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * mp_size_t __gmpn_sec_invert_itch(mp_size_t)
     * }
     */
    public static MemorySegment __gmpn_sec_invert_itch$address() {
        return __gmpn_sec_invert_itch.ADDR;
    }

    /**
     * {@snippet lang=c :
     * mp_size_t __gmpn_sec_invert_itch(mp_size_t)
     * }
     */
    public static long __gmpn_sec_invert_itch(long x0) {
        var mh$ = __gmpn_sec_invert_itch.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__gmpn_sec_invert_itch", x0);
            }
            return (long)mh$.invokeExact(x0);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int GMP_ERROR_NONE = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GMP_ERROR_NONE = 0
     * }
     */
    public static int GMP_ERROR_NONE() {
        return GMP_ERROR_NONE;
    }
    private static final int GMP_ERROR_UNSUPPORTED_ARGUMENT = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GMP_ERROR_UNSUPPORTED_ARGUMENT = 1
     * }
     */
    public static int GMP_ERROR_UNSUPPORTED_ARGUMENT() {
        return GMP_ERROR_UNSUPPORTED_ARGUMENT;
    }
    private static final int GMP_ERROR_DIVISION_BY_ZERO = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GMP_ERROR_DIVISION_BY_ZERO = 2
     * }
     */
    public static int GMP_ERROR_DIVISION_BY_ZERO() {
        return GMP_ERROR_DIVISION_BY_ZERO;
    }
    private static final int GMP_ERROR_SQRT_OF_NEGATIVE = (int)4L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GMP_ERROR_SQRT_OF_NEGATIVE = 4
     * }
     */
    public static int GMP_ERROR_SQRT_OF_NEGATIVE() {
        return GMP_ERROR_SQRT_OF_NEGATIVE;
    }
    private static final int GMP_ERROR_INVALID_ARGUMENT = (int)8L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GMP_ERROR_INVALID_ARGUMENT = 8
     * }
     */
    public static int GMP_ERROR_INVALID_ARGUMENT() {
        return GMP_ERROR_INVALID_ARGUMENT;
    }
    private static final int GMP_ERROR_MPZ_OVERFLOW = (int)16L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.GMP_ERROR_MPZ_OVERFLOW = 16
     * }
     */
    public static int GMP_ERROR_MPZ_OVERFLOW() {
        return GMP_ERROR_MPZ_OVERFLOW;
    }
    private static final int GMP_NUMB_BITS = (int)64L;
    /**
     * {@snippet lang=c :
     * #define GMP_NUMB_BITS 64
     * }
     */
    public static int GMP_NUMB_BITS() {
        return GMP_NUMB_BITS;
    }
    private static final long GMP_NUMB_MASK = -1L;
    /**
     * {@snippet lang=c :
     * #define GMP_NUMB_MASK -1
     * }
     */
    public static long GMP_NUMB_MASK() {
        return GMP_NUMB_MASK;
    }
    private static final long GMP_NUMB_MAX = -1L;
    /**
     * {@snippet lang=c :
     * #define GMP_NUMB_MAX -1
     * }
     */
    public static long GMP_NUMB_MAX() {
        return GMP_NUMB_MAX;
    }
    private static final long GMP_NAIL_MASK = 0L;
    /**
     * {@snippet lang=c :
     * #define GMP_NAIL_MASK 0
     * }
     */
    public static long GMP_NAIL_MASK() {
        return GMP_NAIL_MASK;
    }
    private static final MemorySegment NULL = MemorySegment.ofAddress(0L);
    /**
     * {@snippet lang=c :
     * #define NULL (void*) 0
     * }
     */
    public static MemorySegment NULL() {
        return NULL;
    }
    private static final long _POSIX_C_SOURCE = 200809L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_C_SOURCE 200809
     * }
     */
    public static long _POSIX_C_SOURCE() {
        return _POSIX_C_SOURCE;
    }
    private static final int __TIMESIZE = (int)64L;
    /**
     * {@snippet lang=c :
     * #define __TIMESIZE 64
     * }
     */
    public static int __TIMESIZE() {
        return __TIMESIZE;
    }
    private static final long __STDC_IEC_60559_BFP__ = 201404L;
    /**
     * {@snippet lang=c :
     * #define __STDC_IEC_60559_BFP__ 201404
     * }
     */
    public static long __STDC_IEC_60559_BFP__() {
        return __STDC_IEC_60559_BFP__;
    }
    private static final long __STDC_IEC_60559_COMPLEX__ = 201404L;
    /**
     * {@snippet lang=c :
     * #define __STDC_IEC_60559_COMPLEX__ 201404
     * }
     */
    public static long __STDC_IEC_60559_COMPLEX__() {
        return __STDC_IEC_60559_COMPLEX__;
    }
    private static final long __STDC_ISO_10646__ = 201706L;
    /**
     * {@snippet lang=c :
     * #define __STDC_ISO_10646__ 201706
     * }
     */
    public static long __STDC_ISO_10646__() {
        return __STDC_ISO_10646__;
    }
    private static final long LLONG_MIN = -9223372036854775808L;
    /**
     * {@snippet lang=c :
     * #define LLONG_MIN -9223372036854775808
     * }
     */
    public static long LLONG_MIN() {
        return LLONG_MIN;
    }
    private static final long LLONG_MAX = 9223372036854775807L;
    /**
     * {@snippet lang=c :
     * #define LLONG_MAX 9223372036854775807
     * }
     */
    public static long LLONG_MAX() {
        return LLONG_MAX;
    }
    private static final long ULLONG_MAX = -1L;
    /**
     * {@snippet lang=c :
     * #define ULLONG_MAX -1
     * }
     */
    public static long ULLONG_MAX() {
        return ULLONG_MAX;
    }
    private static final int PTHREAD_DESTRUCTOR_ITERATIONS = (int)4L;
    /**
     * {@snippet lang=c :
     * #define PTHREAD_DESTRUCTOR_ITERATIONS 4
     * }
     */
    public static int PTHREAD_DESTRUCTOR_ITERATIONS() {
        return PTHREAD_DESTRUCTOR_ITERATIONS;
    }
    private static final int SEM_VALUE_MAX = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * #define SEM_VALUE_MAX 2147483647
     * }
     */
    public static int SEM_VALUE_MAX() {
        return SEM_VALUE_MAX;
    }
    private static final long SSIZE_MAX = 9223372036854775807L;
    /**
     * {@snippet lang=c :
     * #define SSIZE_MAX 9223372036854775807
     * }
     */
    public static long SSIZE_MAX() {
        return SSIZE_MAX;
    }
    private static final int BC_BASE_MAX = (int)99L;
    /**
     * {@snippet lang=c :
     * #define BC_BASE_MAX 99
     * }
     */
    public static int BC_BASE_MAX() {
        return BC_BASE_MAX;
    }
    private static final int BC_DIM_MAX = (int)2048L;
    /**
     * {@snippet lang=c :
     * #define BC_DIM_MAX 2048
     * }
     */
    public static int BC_DIM_MAX() {
        return BC_DIM_MAX;
    }
    private static final int BC_SCALE_MAX = (int)99L;
    /**
     * {@snippet lang=c :
     * #define BC_SCALE_MAX 99
     * }
     */
    public static int BC_SCALE_MAX() {
        return BC_SCALE_MAX;
    }
    private static final int BC_STRING_MAX = (int)1000L;
    /**
     * {@snippet lang=c :
     * #define BC_STRING_MAX 1000
     * }
     */
    public static int BC_STRING_MAX() {
        return BC_STRING_MAX;
    }
    private static final int EXPR_NEST_MAX = (int)32L;
    /**
     * {@snippet lang=c :
     * #define EXPR_NEST_MAX 32
     * }
     */
    public static int EXPR_NEST_MAX() {
        return EXPR_NEST_MAX;
    }
    private static final int LINE_MAX = (int)2048L;
    /**
     * {@snippet lang=c :
     * #define LINE_MAX 2048
     * }
     */
    public static int LINE_MAX() {
        return LINE_MAX;
    }
    private static final int RE_DUP_MAX = (int)32767L;
    /**
     * {@snippet lang=c :
     * #define RE_DUP_MAX 32767
     * }
     */
    public static int RE_DUP_MAX() {
        return RE_DUP_MAX;
    }
    private static final int SCHAR_MAX = (int)127L;
    /**
     * {@snippet lang=c :
     * #define SCHAR_MAX 127
     * }
     */
    public static int SCHAR_MAX() {
        return SCHAR_MAX;
    }
    private static final int SHRT_MAX = (int)32767L;
    /**
     * {@snippet lang=c :
     * #define SHRT_MAX 32767
     * }
     */
    public static int SHRT_MAX() {
        return SHRT_MAX;
    }
    private static final int INT_MAX = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * #define INT_MAX 2147483647
     * }
     */
    public static int INT_MAX() {
        return INT_MAX;
    }
    private static final long LONG_MAX = 9223372036854775807L;
    /**
     * {@snippet lang=c :
     * #define LONG_MAX 9223372036854775807
     * }
     */
    public static long LONG_MAX() {
        return LONG_MAX;
    }
    private static final int SCHAR_MIN = (int)-128L;
    /**
     * {@snippet lang=c :
     * #define SCHAR_MIN -128
     * }
     */
    public static int SCHAR_MIN() {
        return SCHAR_MIN;
    }
    private static final int SHRT_MIN = (int)-32768L;
    /**
     * {@snippet lang=c :
     * #define SHRT_MIN -32768
     * }
     */
    public static int SHRT_MIN() {
        return SHRT_MIN;
    }
    private static final int INT_MIN = (int)-2147483648L;
    /**
     * {@snippet lang=c :
     * #define INT_MIN -2147483648
     * }
     */
    public static int INT_MIN() {
        return INT_MIN;
    }
    private static final long LONG_MIN = -9223372036854775808L;
    /**
     * {@snippet lang=c :
     * #define LONG_MIN -9223372036854775808
     * }
     */
    public static long LONG_MIN() {
        return LONG_MIN;
    }
    private static final int UCHAR_MAX = (int)255L;
    /**
     * {@snippet lang=c :
     * #define UCHAR_MAX 255
     * }
     */
    public static int UCHAR_MAX() {
        return UCHAR_MAX;
    }
    private static final int USHRT_MAX = (int)65535L;
    /**
     * {@snippet lang=c :
     * #define USHRT_MAX 65535
     * }
     */
    public static int USHRT_MAX() {
        return USHRT_MAX;
    }
    private static final int UINT_MAX = (int)4294967295L;
    /**
     * {@snippet lang=c :
     * #define UINT_MAX 4294967295
     * }
     */
    public static int UINT_MAX() {
        return UINT_MAX;
    }
    private static final long ULONG_MAX = -1L;
    /**
     * {@snippet lang=c :
     * #define ULONG_MAX -1
     * }
     */
    public static long ULONG_MAX() {
        return ULONG_MAX;
    }
    private static final int CHAR_BIT = (int)8L;
    /**
     * {@snippet lang=c :
     * #define CHAR_BIT 8
     * }
     */
    public static int CHAR_BIT() {
        return CHAR_BIT;
    }
    private static final int CHAR_MIN = (int)-128L;
    /**
     * {@snippet lang=c :
     * #define CHAR_MIN -128
     * }
     */
    public static int CHAR_MIN() {
        return CHAR_MIN;
    }
    private static final int CHAR_MAX = (int)127L;
    /**
     * {@snippet lang=c :
     * #define CHAR_MAX 127
     * }
     */
    public static int CHAR_MAX() {
        return CHAR_MAX;
    }
    /**
     * {@snippet lang=c :
     * #define __GMP_CC "x86_64-linux-gnu-gcc"
     * }
     */
    public static MemorySegment __GMP_CC() {
        class Holder {
            static final MemorySegment __GMP_CC
                = gmp_h.LIBRARY_ARENA.allocateFrom("x86_64-linux-gnu-gcc");
        }
        return Holder.__GMP_CC;
    }
    /**
     * {@snippet lang=c :
     * #define __GMP_CFLAGS "-g -O2 -fno-omit-frame-pointer -mno-omit-leaf-frame-pointer -ffile-prefix-map=BUILDPATH=. -flto=auto -ffat-lto-objects -fstack-protector-strong -fstack-clash-protection -Wformat -Werror=format-security -fcf-protection -fdebug-prefix-map=BUILDPATH=/usr/src/gmp-2:6.3.0+dfsg-2ubuntu6.1 -O3"
     * }
     */
    public static MemorySegment __GMP_CFLAGS() {
        class Holder {
            static final MemorySegment __GMP_CFLAGS
                = gmp_h.LIBRARY_ARENA.allocateFrom("-g -O2 -fno-omit-frame-pointer -mno-omit-leaf-frame-pointer -ffile-prefix-map=BUILDPATH=. -flto=auto -ffat-lto-objects -fstack-protector-strong -fstack-clash-protection -Wformat -Werror=format-security -fcf-protection -fdebug-prefix-map=BUILDPATH=/usr/src/gmp-2:6.3.0+dfsg-2ubuntu6.1 -O3");
        }
        return Holder.__GMP_CFLAGS;
    }
    private static final int __GNU_MP_RELEASE = (int)60300L;
    /**
     * {@snippet lang=c :
     * #define __GNU_MP_RELEASE 60300
     * }
     */
    public static int __GNU_MP_RELEASE() {
        return __GNU_MP_RELEASE;
    }
}

